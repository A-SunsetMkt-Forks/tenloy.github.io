---
title: 数据加密 — 非对称加密(加签/加密，以RSA为例)
date: 2021-12-20 15:49:12
urlname: asymmetric.html
tags:
categories:
  - 计算机网络
---

## 一、概述

### 1.1 非对称加密(公钥加密)

公开密钥密码学（Public-key cryptography）也称非对称式密码学（Asymmetric cryptography）是密码学的一种算法。

- 它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。
- 公钥可以公开，可任意向外发布；**私钥不可以公开，必须由用户自行严格秘密保管**，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。
- **公钥加密，私钥加密**：使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。
- **私钥签名，公钥验签**：基于非对称加密的特性，它还能提供[数字签名](https://zh.wikipedia.org/wiki/數位簽章)的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。

### 1.2 RSA算法

**RSA加密算法**是一种非对称加密算法。

RSA在相关应用的时候，是需要有一些标准的 — PKI(public key infrastructure)标准(见上篇)。最常用的是pkcs。现在的各种程序中，基本都是遵循这个标准来使用RSA的。

- [RSA官网](https://www.rsa.com)

- [标准的查看](https://www.rfc-editor.org/search/rfc_search_detail.php?title=pkcs&pubstatus%5B%5D=Any&pub_date_type=any)

公钥加密标准(The Public-Key Cryptography Standards, PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。

**RSA根据密钥长度可以分为rsa 2048、rsa 1024(单位是bit，换算成字节分别是256、128)。注意不要把密钥长度跟证书长度混淆，在rsa1024中，证书的长度应该是216。**

## 二、加密、解密

加密的目的是实现只有指定个体才能打开发送方发出的数据，所以**公钥加密**(使用指定接受者的公钥来加密)，**私钥解密**，常用的加密算法如RSA

## 三、加签、验签

接收方可以通过签名来确认发送方的身份，并可进行数据完整性检查。由RSA加密算法的规则可知，一个安全个体的私钥只有自己才知道，公钥则是可以被多方知道，所以要起到签名的效果，需要**私钥签名，公钥验签**。

<img src="/images/encrypt/01.jpg" alt="01" style="zoom:70%;" />

**步骤**：

- 将原始数据哈希运算，得出标记，用 A 的私钥进行一次非对称加密算法处理。
- B用A的公钥进行解密：
  - 如果能解出来，表示：确实是 A 发的。
  - 如果解出来的值与收到的原始文本算出的哈希值相同，表示：数据传输途中未被修改。

**过程中出现的算法**：

- 哈希算法：将任意长度的消息M映射成一个固定长度的散列值h(也称为消息摘要)，常见的比如MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512

- 签名算法：RSA、DSA。其中RSA既能当做加密算法，也能当做签名算法来用，正反逆运算都是通的。**DSA只能用作签名** 

- 本文代码签名算法为SHA1+RSA，Java中称 `SHA1WithRSA`

## 四、iOS中的RSA
在iOS中使用RSA加/验签、加/解密，首先需要拿到我们想要的公钥、私钥，在 [上篇博客]([https://www.jianshu.com/p/bc32cbfe49e7](https://www.jianshu.com/p/bc32cbfe49e7)
) 中已经介绍过：

证书文件常见的两种编码方式：**DER编码**、**PEM编码**。

在iOS中经常接触到的证书格式标准：**PKCS#1**、**PKCS#8(java中经常使用)**、**PKCS#12**，PKCS#12文件扩展名为**.p12或者.pfx**(可存储公钥+私钥)，此外常见的还有`.cer/.crt/.der` (存储的是公钥)。

注意：

- 加载 .p12 文件代码转换成私钥
- 加载.cer .crt  .der文件代码转换成公钥
- 直接将PEM编码格式的、PKCS#1格式的公钥、PKCS#1 / PKCS#8标准的私钥硬编码，写在代码里使用

以上都是可以的，但是首先需要先确定到底使用哪种方式，因为不同的数据加载方式、不同的证书格式，所要处理的过程是不一样的。详见下面代码

## 五、代码处理过程
这里使用的是iOS SDK中的 Security.framework 库，非openssl库，多年以前苹果就弃用了 OpenSSL，转而推荐自有框架 Security 和 CommonCrypto。当然你仍然可以使用 OpenSSL，比如说在 iOS 上使用开源库 [OpenSSL for iPhone](https://link.jianshu.com?t=https://github.com/x2on/OpenSSL-for-iPhone)。

分为两步(其实很简单)：
1. 将公私钥文件或者字符串转换成 SecKeyRef 对象， SecKeyRef 对象是一个密码学角度的抽象的密钥对象（也就是说它可以代表一个公钥、私钥或者某种对称加密的密钥）。无论是加解密还是签名，都会需要这个对象。
```objectivec
##pragma mark - '.der'公钥文件生成SecKeyRef对象(公钥)

##pragma mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(公钥)
//PKCS#8格式的证书如果在代码的处理上，比PKCS#1多了一步对header的处理，也就是demo中的stripPublicKeyHeader函数，如果是PKCS#1的证书，跳过这个函数即可
##pragma mark - '.12'私钥文件生成SecKeyRef对象(私钥)

##pragma mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(私钥)
//生成代码与公钥过程大致相同，有一些细微差别
```
有兴趣可以看下[这篇文章 — iOS 生成 SecKeyRef 的正规方式](https://www.jianshu.com/p/783f2605f3e9)，文章有提到直接处理PEM编码格式的头时，由于对应的代码解析力不够强，经常会返回一个空的密钥对象，但是在我们APP内频繁测试没有发现这个问题(如果读到这里能为我解答这个疑问，麻烦评论留言一下吧，多谢)

2. 调用相应的函数，实现功能
```objectivec
//加签函数
OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen);
//验签函数
OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen);
//加密
OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, const uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen);
//加密
OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, const uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)
```
从上面的函数可以看到，函数参数并不复杂，将1中生成SecKeyRef对象传入，数据传输两端确定padding填充方式即可。**要确认两边使用的签名算法设置参数一致**；，详细代码看demo即可
```objectivec
// digest message with sha1
+ (NSData *)sha1:(NSString *)str
{
    const void *data = [str cStringUsingEncoding:NSUTF8StringEncoding];
    CC_LONG len = (CC_LONG)strlen(data);
    uint8_t * md = malloc( CC_SHA1_DIGEST_LENGTH * sizeof(uint8_t) );;
    CC_SHA1(data, len, md);
    return [NSData dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];
}
```

## 六、常见问题

### 6.1 为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？

在[上一篇博客 — 常见的PKI标准(X.509、PKCS)](https://tenloy.github.io/2021/12/09/pki.html#PKCS1%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F) 中已经介绍过PKCS1填充方式的过程,不再赘述，总结一下：

- **PKCS1填充格式：加密块EB** = **00 + 块类型BT + 填充字符PS + 00 + 数据D**。

- **如果使用公钥操作，BT永远为02，而对于BT为02的，PS对应的填充字节的值随机产生但不能是0字节(非00)。**

- 填充后，进行加密运算之前的数据不一致，得出的结果当然就不一样。
- ([这篇博客](https://blog.csdn.net/guyongqiangx/article/details/74930951)的作者一步步验证了这个现象，感兴趣的可以看下)

## 七、代码整理Demo

在[Objective-C-RSA](https://github.com/ideawu/Objective-C-RSA)项目代码的基础上，根据自己项目的使用场景，整理了一下代码，放在了 [GitHub - RSAHandle](https://github.com/Roten8/RSAHandle) 上，希望能有所帮助，有什么问题可以留言讨论。