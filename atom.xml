<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-04-10T02:37:07.461Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Test Travis CI</title>
    <link href="https://tenloy.github.io/2021/04/10/Test-Travis-CI/"/>
    <id>https://tenloy.github.io/2021/04/10/Test-Travis-CI/</id>
    <published>2021-04-10T10:25:24.000Z</published>
    <updated>2021-04-10T02:37:07.461Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/RunLoop/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/RunLoop/</id>
    <published>2021-04-06T19:16:47.000Z</published>
    <updated>2021-04-10T02:37:07.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define POOL_BOUNDARY nil</span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── id objc_object::rootAutorelease()</span><br><span class="line">    └── id objc_object::rootAutorelease2()</span><br><span class="line">        └── static id AutoreleasePoolPage::autorelease(id obj)</span><br><span class="line">            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)</span><br><span class="line">                ├── id *add(id obj)</span><br><span class="line">                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── id *add(id obj)</span><br><span class="line">                └── static id *autoreleaseNoPage(id obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── id *add(id obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>iOS-interview</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/Interview/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/Interview/</id>
    <published>2021-04-06T13:16:47.000Z</published>
    <updated>2021-04-10T02:37:07.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、算法与数据结构"><a href="#一、算法与数据结构" class="headerlink" title="一、算法与数据结构"></a>一、算法与数据结构</h2><ul><li><p>链表中是否有环</p></li><li><p>一个整型数组，将所有元素拼接成一个最大数输出</p></li><li><p>大型数组里面装了几万个数，找到前5个，不能用for循环。TopK问题，建小/大顶堆</p></li><li><p>贪心</p></li><li><p>LRU</p></li><li><p>N万个点勾勒一个国家的范围，然后染色</p></li><li><p>剑指offer 42：连续子数组的最大和</p></li><li><p>hash表</p></li><li><p>用底层设计一个缓存，上限是40mb</p></li><li><p>二叉树按层次遍历</p></li><li><p>数组链表的使用场景</p></li><li><p>数组底层内存如何优化</p></li><li><p>10进制转16进制 算法。</p></li></ul><h2 id="二、OC相关知识"><a href="#二、OC相关知识" class="headerlink" title="二、OC相关知识"></a>二、OC相关知识</h2><h3 id="2-1-TaggedPointer"><a href="#2-1-TaggedPointer" class="headerlink" title="2.1 TaggedPointer"></a>2.1 TaggedPointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongString;</span><br><span class="line">@property (nonatomic, weak)   NSString *weakString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D;  [NSString stringWithFormat:@&quot;%@&quot;,@&quot;string1&quot;];</span><br><span class="line">_weakString &#x3D;  _strongString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D; nil;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, _weakString);</span><br></pre></td></tr></table></figure><p><img src="/images/Interview/TaggedPoint.png" alt="TaggedPoint"></p><h3 id="2-2-KVO"><a href="#2-2-KVO" class="headerlink" title="2.2 KVO"></a>2.2 KVO</h3><ul><li>为什么KVO不释放 会闪退</li></ul><h3 id="2-3-KVC"><a href="#2-3-KVC" class="headerlink" title="2.3 KVC"></a>2.3 KVC</h3><h3 id="2-4-Block"><a href="#2-4-Block" class="headerlink" title="2.4 Block"></a>2.4 Block</h3><h4 id="2-4-1-Block1：讲讲Block的底层实现"><a href="#2-4-1-Block1：讲讲Block的底层实现" class="headerlink" title="2.4.1 Block1：讲讲Block的底层实现"></a>2.4.1 Block1：讲讲Block的底层实现</h4><ul><li>Block底层也是struct封装的，本质是个对象，拥有ISA指针</li><li>Block中的代码以函数的形式存在于代码段，Block对应的struct有一个指针类型成员，记录了函数地址</li><li>Block会对代码中使用到的局部变量进行捕获<ul><li>auto变量：值捕获</li><li>static变量：地址捕获</li><li>全局变量：不捕获，直接访问</li></ul></li></ul><h4 id="2-4-2-block的底层原理"><a href="#2-4-2-block的底层原理" class="headerlink" title="2.4.2 __block的底层原理"></a>2.4.2 __block的底层原理</h4><ul><li>编译器会将 __block变量包装成一个对象</li><li>再次使用的时候是实现的底层形成的 __Block_byref_xx_y类型的结构体中的成员变量</li></ul><h4 id="2-4-3-block会造成循环引用吗"><a href="#2-4-3-block会造成循环引用吗" class="headerlink" title="2.4.3 __block会造成循环引用吗"></a>2.4.3 __block会造成循环引用吗</h4><h4 id="2-4-4-例题"><a href="#2-4-4-例题" class="headerlink" title="2.4.4 例题"></a>2.4.4 例题</h4><ol><li><p>如果调用一个赋值为空的 block，会发生什么情况？闪退的那个地址值（address）是多少？为什么？</p><p>0x10. 参考Block的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;  &#x2F;&#x2F;地址值0x10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^test)(int);</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) test block;</span><br><span class="line">@property (nonatomic, assign) int b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    _b &#x3D; 1;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    _block &#x3D; ^(int value)&#123;</span><br><span class="line">        return a+value+_b;  &#x2F;&#x2F; 问题2：block会捕获哪些变量？捕获了a、self</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_block class]);</span><br><span class="line">    </span><br><span class="line">    if (a&gt;10) &#123;</span><br><span class="line">        a &#x3D; 10;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        a &#x3D; 20;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;,_block(1)); &#x2F;&#x2F; 问题1：102。对a是值捕获，改变无效。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 问题3：如果该页面是二级页面，退出时，会调用dealloc吗？会，block是assign修饰的，block是在栈上，不对self产生强引用。如果修饰符换成copy呢？不会调用dealloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Runtime"><a href="#2-5-Runtime" class="headerlink" title="2.5 Runtime"></a>2.5 Runtime</h3><h4 id="2-5-1-Category中能添加成员变量吗？为什么？"><a href="#2-5-1-Category中能添加成员变量吗？为什么？" class="headerlink" title="2.5.1 Category中能添加成员变量吗？为什么？"></a>2.5.1 Category中能添加成员变量吗？为什么？</h4><p>分类的底层结构体中就没有ivars这个成员，存放不了成员变量。</p><h4 id="2-5-2-Category的数据在编译运行过程中具体是怎么处理的？"><a href="#2-5-2-Category的数据在编译运行过程中具体是怎么处理的？" class="headerlink" title="2.5.2 Category的数据在编译运行过程中具体是怎么处理的？"></a>2.5.2 Category的数据在编译运行过程中具体是怎么处理的？</h4><ol><li><p>通过Runtime加载某个类的所有Category数据</p></li><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中</p><ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li><p>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p></li></ol><h4 id="2-5-3-说说-load与-initialize"><a href="#2-5-3-说说-load与-initialize" class="headerlink" title="2.5.3 说说+load与+initialize"></a>2.5.3 说说+load与+initialize</h4><ol><li>调用时机：+load方法会在runtime加载类、分类时调用；+initialize方法会在类第一次接收到消息时调用</li><li>调用方式：+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用；+initialize是通过objc_msgSend进行调用的</li></ol><h4 id="2-5-4-消息发送-传递机制"><a href="#2-5-4-消息发送-传递机制" class="headerlink" title="2.5.4 消息发送/传递机制"></a>2.5.4 消息发送/传递机制</h4><p>objc_msgSend()函数会依据接受者（调用方法的对象）的类型和选择子（方法名）来调用适当的方法。</p><ol><li>接收者会根据isa指针找到接收者自己所属的类，然后在所属类的”方法列表“（method list）中从上向下遍历。如果能找到与选择子名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果找不到与选择子名称相符的方法，接收者会根据所属类的superClass指针，沿着类的继承体系继续向上查找（向父类查找），如果 能找到与名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果在继承体系中还是找不到与选择子相符的方法，此时就会执行”<code>消息转发（message forwarding）</code>“操作。</li></ol><h4 id="2-5-5-消息转发"><a href="#2-5-5-消息转发" class="headerlink" title="2.5.5 消息转发"></a>2.5.5 消息转发</h4><p><img src="/images/Interview/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p><p>消息转发分为两大阶段。第一阶段叫做“动态方法解析（dynamic method resolution）”，或者叫“动态方法决议”。第二阶段涉及到“完整的消息转发机制（full forwarding mechanism）”，或者叫“完整的消息转发原理”。</p><h5 id="第一阶段：动态方法解析"><a href="#第一阶段：动态方法解析" class="headerlink" title="第一阶段：动态方法解析"></a>第一阶段：动态方法解析</h5><p>动态方法解析的意思就是，征询消息接受者所属的类，看其是否能动态添加方法，以处理当前“这个未知的选择子（unknown selector）“。实例对象在接受到无法解读的消息后，首先会调用其<code>所属类</code>的下列<code>类方法</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>类对象在接受到无法解读的消息后，那么运行期系统就会调用另外的一个方法，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>如果运行期系统已经执行完了动态方法解析，那么消息接受者自己就无法再以动态新增方法的形式来响应包含该未知选择子的消息了，此时就进入了第二阶段——<code>完整的消息转发</code>。运行期系统会请求消息接受者以其他手段来处理与消息相关的方法调用。</p><h5 id="第二阶段：又细分为两小步"><a href="#第二阶段：又细分为两小步" class="headerlink" title="第二阶段：又细分为两小步"></a>第二阶段：又细分为两小步</h5><h5 id="2-1-备援接受者-replacement-receiver"><a href="#2-1-备援接受者-replacement-receiver" class="headerlink" title="2.1 备援接受者(replacement receiver)"></a>2.1 备援接受者(replacement receiver)</h5><p>当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)selector &#x2F;&#x2F;方法参数代表未知的选择子</span><br></pre></td></tr></table></figure><ul><li>若当前接收者能找到备援对象，则将其返回，此时运行期系统(Runtime)会把消息转给那个对象，消息转发过程结束</li><li>若找不到，就返回nil，此时启动完整的消息转发机制。</li></ul><p>通过此方案，我们可以用”组合”(composition)来模拟出“多重继承”(multiple inheritance) 的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p><p>请注意，我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p><h5 id="2-2-完整的消息转发"><a href="#2-2-完整的消息转发" class="headerlink" title="2.2 完整的消息转发"></a>2.2 完整的消息转发</h5><p>首先创建NSInvocation对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标(target)及参数。<br>在触发NSInvocation对象时，“消息派发系统”(message-dispatch system)将亲自出马，把消息指派给目标对象。</p><p>此步骤需要先实现一个方法，来返回方法的签名：返回值类型、参数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>然后会调用下列方法来转发消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation*)invocation</span><br></pre></td></tr></table></figure><p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p><h4 id="2-5-6-常见面试题"><a href="#2-5-6-常见面试题" class="headerlink" title="2.5.6 常见面试题"></a>2.5.6 常见面试题</h4><ul><li><p>Methodswizzing使用中遇到过什么问题吗，怎么避免</p></li><li><p>类和一些分类都hook( methodswizzing)了一个方法，会发生什么</p></li><li><p>a和b互换方法，c方法在不知情的状况下和a互换了方法，会有什么问题，a执行的是哪个方法，如何避免这个问题</p></li><li><p>本类一个方法，分类中有一个同名的方法，怎么调用本类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)callClassMethod &#123;</span><br><span class="line">    u_int count;</span><br><span class="line">    Method *methods &#x3D; class_copyMethodList([Student class], &amp;count);</span><br><span class="line">    NSInteger index &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        SEL name &#x3D; method_getName(methods[i]);</span><br><span class="line">        NSString *strName &#x3D; [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">        if ([strName isEqualToString:@&quot;run&quot;]) &#123;</span><br><span class="line">            index &#x3D; i;  &#x2F;&#x2F; 先获取原类方法在方法列表中的索引。分类的在前，后面的本类中的会覆盖前面的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 调用方法</span><br><span class="line">    Student *stu &#x3D; [[Student alloc] init];</span><br><span class="line">    SEL sel &#x3D; method_getName(methods[index]);</span><br><span class="line">    IMP imp &#x3D; method_getImplementation(methods[index]);</span><br><span class="line">    ((void (*)(id, SEL))imp)(stu,sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分类文件 +声明 -实现，调用会崩溃吗，为什么</p></li><li><p>用runtime 关联对象 为什么就能实现增加属性？内部数据结构怎么处理的的</p></li></ul><h3 id="2-6-RunLoop"><a href="#2-6-RunLoop" class="headerlink" title="2.6 RunLoop"></a>2.6 RunLoop</h3><h4 id="2-6-1-RunLoop的大概流程及常见运用"><a href="#2-6-1-RunLoop的大概流程及常见运用" class="headerlink" title="2.6.1 RunLoop的大概流程及常见运用"></a>2.6.1 RunLoop的大概流程及常见运用</h4><p>Timers Sources Blocks Source0 Source1</p><p>运用：线程保活、NSTimer滑动停止工作、监控引用卡顿(比如使用CADisplayLink，添加到runloop中)等</p><h4 id="2-6-2-自动释放池"><a href="#2-6-2-自动释放池" class="headerlink" title="2.6.2 自动释放池"></a>2.6.2 自动释放池</h4><p><a href="https://www.jianshu.com/p/7bd2f85f03dc">iOS内存管理-深入解析自动释放池</a></p><h5 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1) 实现原理"></a>1) 实现原理</h5><h5 id="2-NSThread、NSRunLoop、Autorelease的关系"><a href="#2-NSThread、NSRunLoop、Autorelease的关系" class="headerlink" title="2) NSThread、NSRunLoop、Autorelease的关系"></a>2) NSThread、NSRunLoop、Autorelease的关系</h5><p>总结<code>NSThread</code>(线程)与<code>RunLoop</code>之间的关系如下：</p><ul><li>线程与<code>RunLoop</code>是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ul><p><code>RunLoop</code>与<code>AutoreleasePool</code>的关系：</p><ul><li>主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</li></ul><p><code>Thread</code>和<code>AutoreleasePool</code>的关系：</p><ul><li>包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</li></ul><h5 id="3-AutoreleasePool在主线程上的释放时机"><a href="#3-AutoreleasePool在主线程上的释放时机" class="headerlink" title="3) AutoreleasePool在主线程上的释放时机"></a>3) AutoreleasePool在主线程上的释放时机</h5><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h5 id="4-AutoreleasePool在子线程上的释放时机"><a href="#4-AutoreleasePool在子线程上的释放时机" class="headerlink" title="4) AutoreleasePool在子线程上的释放时机"></a>4) AutoreleasePool在子线程上的释放时机</h5><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><h5 id="5-AutoreleasePool需要手动添加的情况"><a href="#5-AutoreleasePool需要手动添加的情况" class="headerlink" title="5) AutoreleasePool需要手动添加的情况"></a>5) AutoreleasePool需要手动添加的情况</h5><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><h4 id="2-6-3-其他"><a href="#2-6-3-其他" class="headerlink" title="2.6.3 其他"></a>2.6.3 其他</h4><ul><li>runloop运行逻辑</li><li>runloop跟线程什么关系，runloop怎么唤起线程</li><li>子线程的runloop怎么获取，具体应用场景有哪些</li><li>线程保活具体怎么做</li><li>你讲到runloop有多种mode,那为什么要设计多种mode呢，一个组合mode行不行</li></ul><h3 id="2-7-内存管理"><a href="#2-7-内存管理" class="headerlink" title="2.7 内存管理"></a>2.7 内存管理</h3><h4 id="2-7-1-iOS的内存管理机制"><a href="#2-7-1-iOS的内存管理机制" class="headerlink" title="2.7.1 iOS的内存管理机制"></a>2.7.1 iOS的内存管理机制</h4><h5 id="1-64位后出现的TaggedPoint"><a href="#1-64位后出现的TaggedPoint" class="headerlink" title="1) 64位后出现的TaggedPoint"></a>1) 64位后出现的TaggedPoint</h5><p>Tagged Pointer专门用来存储例如NSNumber、NSDate、NSString等小对象数据，这种数据绝大多数4字节都够满足需求了，在64位系统下就会造成极大的浪费，所以它会将值存在Tagged Pointer，而不是将它作为一个地址，值另外存储，它的内存并不存储在堆中，不需要malloc和free，可以极大得提高创建和读写效率，并且节省内存空间。</p><ul><li>当指针(8字节)不够存储数据时，才会使用动态分配内存的方式来存储数据<ul><li>NSString达到10位就放不下了</li><li>注意：当使用字符串字面量，给NSString实例赋值时，实例的类型是__NSCFConstantString，而不会是NSTaggedPointerString。其他数据类型使用字面量创建实例时，就没有这个限制</li></ul></li><li>objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销(消息发送流程)</li><li>release()方法中，释放之前，会先判断是否是TaggedPointer</li><li>如何判断一个指针是否为Tagged Pointer？iOS平台，指针的最高有效位是1(第64bit);   Mac平台，指针的最低有效位是1</li></ul><h5 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2) 引用计数"></a>2) 引用计数</h5><p>如果不是TaggedPoint，那么内存管理仍是靠引用计数的</p><h5 id="3-64位系统中，ISA的改变"><a href="#3-64位系统中，ISA的改变" class="headerlink" title="3) 64位系统中，ISA的改变"></a>3) 64位系统中，ISA的改变</h5><p>由普通的地址 → nonpointer (day10-Runtime ISA详解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- OBJC 1.0</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    &#x2F;&#x2F; 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">#pragma mark -- OBJC 2.0</span><br><span class="line">&#x2F;&#x2F;从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</span><br><span class="line">&#x2F;**</span><br><span class="line"> 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</span><br><span class="line"> *&#x2F;</span><br><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    #define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">    #define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">    #define ISA_MAGIC_VALUE 0x000001a000000001ULL  &#x2F;&#x2F; magic的值，如果对应的1a，表示对象已经初始化成功</span><br><span class="line">    #define RC_ONE          (1ULL&lt;&lt;45)</span><br><span class="line">    #define RC_HALF         (1ULL&lt;&lt;18)</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         注意，越前面的成员放在越低位</span><br><span class="line">         p&#x2F;x obj.isa &#x3D; 0000000000000000000 0 0 0 011010 000100000000000011110100111010101 0 0 1</span><br><span class="line">                         extra_rc                 magic             shiftcls                  nonpointer</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t nonpointer        : 1;  &#x2F;&#x2F; 0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span><br><span class="line">        &#x2F;**</span><br><span class="line">         objc_setAssociatedObject简单可以验证。</span><br><span class="line">         注意：是&#96;设置过&#96;，清除了也算。</span><br><span class="line">         如果没有，释放时会更快的意思是：见下源码</span><br><span class="line">         void *objc_destructInstance(id obj)&#123; &#x2F;&#x2F; objc-runtime-new.mm，对象在释放时调用</span><br><span class="line">             if (obj) &#123;</span><br><span class="line">                 if (obj-&gt;hasCxxDtor()) object_cxxDestruct(obj);  &#x2F;&#x2F; 有析构函数，调用析构函数</span><br><span class="line">                 if (obj-&gt;hasAssociatedObjects()) _object_remove_assocations(obj); &#x2F;&#x2F; 有关联对象，移除关联对象</span><br><span class="line">                 obj-&gt;clearDeallocating();</span><br><span class="line">             &#125;</span><br><span class="line">             return obj;</span><br><span class="line">         &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_assoc         : 1;  &#x2F;&#x2F; 是否有设置过关联对象(associatedObject)，如果没有，释放时会更快</span><br><span class="line">        &#x2F;**</span><br><span class="line">         析构函数(destructor)与构造函数相反，是当对象的生命周期结束时，自动地被调用运行。它最主要的目的在于，清空并释放对象先前创建或是占用的存储器资源。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;  &#x2F;&#x2F; 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;&#x2F; shift cls 存储着Class、Meta-Class对象的内存地址信息</span><br><span class="line">        uintptr_t magic             : 6;  &#x2F;&#x2F; 用于在调试时分辨对象是否未完成初始化</span><br><span class="line">        &#x2F;**</span><br><span class="line">         加个__weak简单可以验证。</span><br><span class="line">         注意：是&#96;指向过&#96;，弱引用销毁了也算</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t weakly_referenced : 1;  &#x2F;&#x2F; 是否有被弱引用指向过，如果没有，释放时会更快</span><br><span class="line">        uintptr_t deallocating      : 1;  &#x2F;&#x2F; 对象是否正在释放</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;  &#x2F;&#x2F; 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span><br><span class="line">        uintptr_t extra_rc          : 19; &#x2F;&#x2F; 里面存储的值是引用计数器减1 （举例的对象引用计数器是1，所以这里是0）</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-SideTables-—-引用计数、Weak引用的管理"><a href="#4-SideTables-—-引用计数、Weak引用的管理" class="headerlink" title="4) SideTables — 引用计数、Weak引用的管理"></a>4) SideTables — 引用计数、Weak引用的管理</h5><ul><li>weak哈希表怎么保存键值对的，说说哈希表的实现，以什么作为key保存到哈希表的</li></ul><p><img src="/images/Interview/SideTables.png" alt="SideTables"></p><h5 id="5-C指针需要自己管理释放"><a href="#5-C指针需要自己管理释放" class="headerlink" title="5) C指针需要自己管理释放"></a>5) C指针需要自己管理释放</h5><h4 id="2-7-2-手写一个MRC-setter方法"><a href="#2-7-2-手写一个MRC-setter方法" class="headerlink" title="2.7.2 手写一个MRC setter方法"></a>2.7.2 手写一个MRC setter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCar:(MJCar *)car</span><br><span class="line">&#123;</span><br><span class="line">    if (_car !&#x3D; car) &#123;   &#x2F;&#x2F; 需要先判断赋值与正在持有的值是否是同一个，避免错误release</span><br><span class="line">        [_car release];  &#x2F;&#x2F; 赋值之前，需要将之前的数据release</span><br><span class="line">        _car &#x3D; [car retain]; </span><br><span class="line">      &#x2F;*</span><br><span class="line">      MRC下：赋值给属性，引用计数是+1的，赋值给成员变量，引用计数不变。区别主要是在于Setter方法内部做的一次retain操作</span><br><span class="line">      ARC下：给成员变量赋值，也会对被赋值对象造成强引用(ARC下通过KVC来访问私有API)。</span><br><span class="line">      *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-3-内存管理2：weak的实现原理"><a href="#2-7-3-内存管理2：weak的实现原理" class="headerlink" title="2.7.3 内存管理2：weak的实现原理"></a>2.7.3 内存管理2：weak的实现原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">▼ dealloc</span><br><span class="line">  ▼ _objc_rootDealloc</span><br><span class="line">    ▼ rootDealloc</span><br><span class="line">      ▶ free</span><br><span class="line">      ▼ object_dispose</span><br><span class="line">        ▼ objc_destructInstance</span><br><span class="line">          ▶ object_cxxDestruct          &#x2F;&#x2F;调用C++析构函数(如果有的话)，会清除自己的成员变量</span><br><span class="line">          ▶ _object_remove_assocations  &#x2F;&#x2F;移除关联对象</span><br><span class="line">          ▶ clearDeallocating           &#x2F;&#x2F;将指向当前对象的弱指针置为nil</span><br><span class="line">        ▶ free</span><br></pre></td></tr></table></figure><h4 id="2-7-4-野指针、僵尸对象"><a href="#2-7-4-野指针、僵尸对象" class="headerlink" title="2.7.4 野指针、僵尸对象"></a>2.7.4 野指针、僵尸对象</h4><ul><li><p>野指针：地址值是个不合法的地址。</p><ul><li>可能是不能访问的区域</li><li>可能是数据已经被释放</li></ul></li><li><p>僵尸对象：1个已经被释放的对象 就叫做僵尸对象。</p></li><li><p>使用**<code>野指针访问僵尸对象</code><strong>有的时候会出问题报错（</strong><code>EXC_BAD_ACCESS</code>**），有的时候不会出问题。</p><p>当OC对象<code>引用计数为0被释放</code>就变成了僵尸对象，此时僵尸对象的内存已经被系统回收，虽然该对象的数据可能还存在于内存中(申请空间时，才初始化)，但僵尸对象已经不是稳定对象，不可以再访问或者使用，它的内存是随时可能被别的对象申请而占用的。</p></li><li><p>僵尸对象的检测：在Xcode中设置Edit Scheme -&gt; Diagnostics -&gt; Zombie Objects</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zombie Objects hook 住了对象的dealloc方法，在回收对象时，不将其真的回收，而是把它转化为僵尸对象。这种对象所在的内存无法重用，因此不可遭到重写，所以将随机变成必然。</span><br><span class="line">系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择器，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序，这非常有利于调试。</span><br></pre></td></tr></table></figure></li><li><p>修改：检测到之后，把野指针置为nil即可</p></li></ul><h3 id="2-8-属性关键字、对象所有权修饰符"><a href="#2-8-属性关键字、对象所有权修饰符" class="headerlink" title="2.8 属性关键字、对象所有权修饰符"></a>2.8 属性关键字、对象所有权修饰符</h3><p>参考链接：<a href="https://juejin.cn/post/6844904067425124366">OC - 属性关键字和所有权修饰符</a></p><h4 id="2-8-1-assign-和-weak-关键字的区别有哪些？"><a href="#2-8-1-assign-和-weak-关键字的区别有哪些？" class="headerlink" title="2.8.1 assign 和 weak 关键字的区别有哪些？"></a>2.8.1 assign 和 weak 关键字的区别有哪些？</h4><ul><li><code>weak</code>只能修饰对象，而<code>assign</code>既可以修饰对象也可以修饰基本数据类型；</li><li><code>assign</code>修饰的对象在被释放后，指针仍然指向原对象地址；而<code>weak</code>修饰的对象在被释放之后会自动置指针为 nil；</li><li>相同点：在修饰对象的时候，<code>assign</code>和<code>weak</code>都不改变对象的引用计数。</li></ul><h4 id="2-8-2-copy-strong的底层实现"><a href="#2-8-2-copy-strong的底层实现" class="headerlink" title="2.8.2 copy strong的底层实现"></a>2.8.2 copy strong的底层实现</h4><p><a href="https://www.jianshu.com/p/bc16a644784d">https://www.jianshu.com/p/bc16a644784d</a></p><h2 id="三、运行库与三方库API"><a href="#三、运行库与三方库API" class="headerlink" title="三、运行库与三方库API"></a>三、运行库与三方库API</h2><h3 id="3-1-UIKit、QuartzCore"><a href="#3-1-UIKit、QuartzCore" class="headerlink" title="3.1 UIKit、QuartzCore"></a>3.1 UIKit、QuartzCore</h3><h4 id="3-1-1-触摸事件的分发机制"><a href="#3-1-1-触摸事件的分发机制" class="headerlink" title="3.1.1 触摸事件的分发机制"></a>3.1.1 触摸事件的分发机制</h4><p><a href="https://www.jianshu.com/p/74a2f44840fa">参考链接</a></p><ul><li>hitTest:withEvent:</li><li>pointInside:withEvent:</li></ul><h4 id="3-1-2-异步渲染"><a href="#3-1-2-异步渲染" class="headerlink" title="3.1.2 异步渲染"></a>3.1.2 异步渲染</h4><p>异步渲染就是在子线程进行绘制，然后拿到主线程显示。</p><p>UIView的显示是通过CALayer实现的，CALayer的显示则是通过contents进行的。异步渲染的实现原理是当我们改变UIView的frame时，会调用layer的setNeedsDisplay，然后调用layer的display方法。我们不能在非主线程将内容绘制到layer的context上，但我们单独开一个子线程通过<code>CGBitmapContextCreateImage()</code>绘制内容，绘制完成之后切回主线程，将内容赋值到contents上。</p><h4 id="3-1-3-离屏渲染"><a href="#3-1-3-离屏渲染" class="headerlink" title="3.1.3 离屏渲染"></a>3.1.3 离屏渲染</h4><p>什么是离屏渲染？</p><ul><li>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</li></ul><p>什么情况会导致离屏渲染？</p><ul><li><p>以阴影为例，为什么它会导致离屏渲染。因为<a href="https://cloud.tencent.com/product/gpu?from=10680">GPU</a>的渲染是遵循“画家算法”，一层一层绘制的，但阴影很特殊，它需要全部内容绘制完成，再根据外轮廓进行绘制。这就导致了，阴影这一层要一直占据一块内存区域，这就导致了离屏渲染。</p></li><li><p>类似导致离屏渲染的情况还有：</p><ul><li>cornerRadius+clipsToBounds</li><li>group opacity 组透明度</li><li>mask 遮罩</li><li>UIBlurEffect 毛玻璃效果</li></ul></li></ul><p>有一篇文章详细的讨论了这些情况：<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></p><h4 id="3-1-4-UIView与CALayer的关系"><a href="#3-1-4-UIView与CALayer的关系" class="headerlink" title="3.1.4 UIView与CALayer的关系"></a>3.1.4 UIView与CALayer的关系</h4><ul><li><p>创建UIView对象时，UIView内部会自动创建一个层(CALayer对象)，通过UIView的layer属性可以访问这个层。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图渲染，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示</p></li><li><p>UIView相比CALayer最大区别是UIView继承自UIResponder，可以响应用户事件，而CALayer不可以；UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</p></li><li><p>UIView本身，更像是一个CALayer的管理器，访问它的和绘图、坐标相关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性</p></li><li><p>UIView和CALayer是相互依赖的关系。UIView依赖CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</p></li><li><p>高级：UIView的layer树形在系统内部被系统维护着三份copy</p><ul><li>逻辑树：就是代码里可以操纵的，例如更改layer的属性（阴影，圆角等）就在这一份</li><li>动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作</li><li>显示树：这棵树的内容是当前正被显示在屏幕上的内容</li><li>这三棵树的逻辑结构都是一样的，区别只有各自的属性</li></ul></li></ul><h4 id="3-1-5-Core-Animation"><a href="#3-1-5-Core-Animation" class="headerlink" title="3.1.5 Core Animation"></a>3.1.5 Core Animation</h4><p>与UIView动画的关系：</p><ul><li>UIView动画其实就是对Core Animation的一种封装，向客户程序员呈现更简洁的接口</li></ul><p>动画执行过程中是否响应事件？</p><ul><li>UIView的block animation在执行过程中不能响应其自身的触摸事件。</li></ul><h4 id="3-1-6-UITableView重用机制"><a href="#3-1-6-UITableView重用机制" class="headerlink" title="3.1.6 UITableView重用机制"></a>3.1.6 UITableView重用机制</h4><h3 id="3-2-Foundation"><a href="#3-2-Foundation" class="headerlink" title="3.2 Foundation"></a>3.2 Foundation</h3><ul><li>NSString、NSArray相关的类簇概念了解一下<ul><li>当hook方法时，要用真正的类名，不能用这个类簇名</li></ul></li></ul><h3 id="3-3-WebKit-—-WKWebview"><a href="#3-3-WebKit-—-WKWebview" class="headerlink" title="3.3 WebKit — WKWebview"></a>3.3 WebKit — WKWebview</h3><ul><li>cookie同步</li><li>post body</li><li>webp图片处理</li><li>NSURLProtocol的机制，有什么问题，拦截的成功率</li><li>除了NSURLProtocol还有什么方式能拦截请求：说hook ajax xmlhttprequest的open set方法</li><li>白屏检测：为什么会白屏，怎么监测，webViewWebContentProcessDidTerminate触发了就是白屏？因为其他问题，WK进程崩溃了，这个方法就不会调用吗</li><li>白屏优化</li><li>BRBridge的通信机制<ul><li>数据是怎么传递的，复杂数据是怎么编码、序列化、反序列化的</li><li>为什么要用iframe，原生的API message那一套行不行。不够灵活，且有兼容性，UIWebView、WKWebView之间不能无缝衔接</li></ul></li><li>webview的优化点：<ul><li>缓存</li><li>WKWebview进程是单独的，启动时涉及内核，所以耗时？要进行相关的优化吗？进程开始就创建一个，really？还是扯呢</li><li>HTTP2.0 相比HTTP1.1，报文压缩，加快传输速度</li><li>Webp图片压缩</li></ul></li></ul><h3 id="3-4-常见三方库"><a href="#3-4-常见三方库" class="headerlink" title="3.4 常见三方库"></a>3.4 常见三方库</h3><ul><li>看过什么源码</li><li>是带着问题看的，还是系统得看</li><li>带着什么问题，找到答案了吗。比如atomic的实现</li><li>SD 和YYCache的缓存机制的区别，以及淘汰规则，最后设计一个LRU的方案</li><li>lottie的原理：lottie json 描述了 关键帧和参数，iOS通过解析iOS，转为代码 就可以实现动画</li></ul><h3 id="3-5-图像处理相关"><a href="#3-5-图像处理相关" class="headerlink" title="3.5 图像处理相关"></a>3.5 图像处理相关</h3><ul><li>png图片压缩机制</li><li>jpg png sd底层能够是如何解析的</li><li>webp 和 Lottie 在对动图的优化，webp压缩算法 丢弃了什么(通过丢掉 高频部分，达到一定程度的压缩??)<ul><li>webp 虽然解码时间边长了，但是100k的图片能压缩到4k不到？</li></ul></li></ul><h2 id="四、计算机网络"><a href="#四、计算机网络" class="headerlink" title="四、计算机网络"></a>四、计算机网络</h2><h3 id="4-1-HTTP（霜神的HTTP网络全套的blog）"><a href="#4-1-HTTP（霜神的HTTP网络全套的blog）" class="headerlink" title="4.1 HTTP（霜神的HTTP网络全套的blog）"></a>4.1 HTTP（霜神的HTTP网络全套的blog）</h3><ul><li>HTTPS与HTTP的关系，就是加了个SSL？SSL与TLS的关系</li><li>HTTP2.0了解吗，相比之前的优化<ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送？</li></ul></li></ul><h3 id="4-1-HTTPS"><a href="#4-1-HTTPS" class="headerlink" title="4.1 HTTPS"></a>4.1 HTTPS</h3><p><a href="https://juejin.cn/post/6844903901037084686">https://juejin.cn/post/6844903901037084686</a></p><h4 id="4-1-1-连接过程"><a href="#4-1-1-连接过程" class="headerlink" title="4.1.1 连接过程"></a>4.1.1 连接过程</h4><ul><li><p>HTTPS的连接过程：TLS SSL 预置密钥</p></li><li><p>握手阶段细分为五步: </p><ol><li>客户端发送出协议版本号，一个客户端生成的随机数，以及客户端支持的加密方法。 </li><li>服务端确认双方使用的加密方法，并给出数字证书以及一个服务器生成的随机数。</li><li>客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，发送给服务端。</li><li>服务端使用自己的私钥，解密出随机数。 </li><li>客户端和服务端根据约定的加密方法，使用前面的三个随机数生成对话密钥，用来加密接下来的对话。</li></ol></li><li><p>预备主密钥？？</p></li><li><p>如果第4步失败了，两端会怎么办？不知道是不是下面这个答案 <a href="https://halfrost.com/https_tls1-2_handshake/#toc-6">https://halfrost.com/https_tls1-2_handshake/#toc-6</a></p><ul><li>Server 拿到 EncryptedPreMasterSecret 以后，用自己的 RSA 私钥解密。解密以后还需要再次校验 PreMasterSecret 中的 ProtocolVersion 和 ClientHello 中传递的 ProtocolVersion 是否一致。如果不相等，校验失败，Server 会根据下面说的规则重新生成 PreMasterSecret，并继续进行握手。</li><li>在任何情况下，如果处理一个 RSA 加密的预备主密钥消息失败的时候，或版本号不是期望的时候，一个 TLS Server 一定不能产生一个警报。作为替代，它必须以一个随机生成的预备主密钥继续握手流程。出于定位问题的意图将失败的真正原因记录在日志中可能是有帮助的。但必须注意避免泄露信息给攻击者（例如，计时，日志文件或其它渠道）</li></ul></li></ul><h4 id="4-1-2-CA证书"><a href="#4-1-2-CA证书" class="headerlink" title="4.1.2 CA证书"></a>4.1.2 CA证书</h4><p>其中有什么内容：颁发机构、过期时间、密钥</p><h3 id="4-2-TCP"><a href="#4-2-TCP" class="headerlink" title="4.2 TCP"></a>4.2 TCP</h3><ul><li><p>TCP协议的流量控制机制、分片原理</p></li><li><p>三次握手与四次挥手</p><ul><li><p>讲一下三次握手与四次挥手的过程。握手为什么要三次、挥手为什么要四次？</p></li><li><p>三次握手与四次挥手：<a href="https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw">https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw</a></p></li><li><p>三次握手：<a href="https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg">https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg</a></p></li><li><p>四次挥手：<a href="https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA">https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA</a></p></li></ul></li></ul><h3 id="4-3-Socket"><a href="#4-3-Socket" class="headerlink" title="4.3 Socket"></a>4.3 Socket</h3><ul><li>socket保证连接，心跳包</li></ul><h3 id="4-4-断点下载实现原理"><a href="#4-4-断点下载实现原理" class="headerlink" title="4.4 断点下载实现原理"></a>4.4 断点下载实现原理</h3><h3 id="4-5-POST数据格式"><a href="#4-5-POST数据格式" class="headerlink" title="4.5 POST数据格式"></a>4.5 POST数据格式</h3><p>默认POST提交方式是application/x-www-form-urlencoded，这个是application/json</p><h2 id="五、OS之多线程"><a href="#五、OS之多线程" class="headerlink" title="五、OS之多线程"></a>五、OS之多线程</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><p><img src="/images/Interview/Thread.png" alt="Thread"></p><h3 id="5-2-多线程的几种方案"><a href="#5-2-多线程的几种方案" class="headerlink" title="5.2 多线程的几种方案"></a>5.2 多线程的几种方案</h3><p>NSThread、GCD、NSOperationQueue的区别？各自的一些优点，以及应用场景</p><ul><li>NSThread：实现常驻线程，创建并开启RunLoop</li><li>GCD：dispatch_group、dispatch_barry、</li><li>NSOperationQueue：面向对象的封装，可以监控任务的状态、取消任务</li></ul><h3 id="5-3-常见的线程同步的手段"><a href="#5-3-常见的线程同步的手段" class="headerlink" title="5.3 常见的线程同步的手段"></a>5.3 常见的线程同步的手段</h3><ul><li><p>原子操作</p><p>我们在声明一个变量的时候一般会使用<code>nonatomic</code>，这个就是非原子操作；原子操作是<code>atomic</code>。</p><p>简单的加减使用原子操作具有更高的性能优势。注意是加减，不是增删！！</p><p>也就是说仅仅对于getter,setter是线程安全的，两个线程都去对变量赋值是安全的。对于比如NSMutableArray类型的增删操作不是线程安全的</p></li><li><p>线程锁</p><p>锁可以保护临界区，代码在临界区同一时间只会被一个线程执行。有互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等。</p></li><li><p>条件、信号量</p><p>有个BOOL类型的变量，当线程A进入临界区时把BOOL值置为NO，如果线程B准备进入临界区时发现BOOL值为NO就挂起等待，当线程A出临界区时把BOOL置为YES，线程B会被唤醒并继续执行。</p><p>条件就是使用信号量在线程之间相互发生信号。</p><p>条件通常被使用来说明资源可用性，或用来确保任务以特定的顺序执行。</p></li><li><p>使用Selector</p><p>selector方法允许你的线程以异步的方式来传递消息，以确保它们在同一个线程上面执行是同步的。</p><p>比如<code>NSObject</code>中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelectorInBackground:withObject:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-都有哪些锁"><a href="#5-4-都有哪些锁" class="headerlink" title="5.4 都有哪些锁"></a>5.4 都有哪些锁</h3><p>互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等</p><ul><li>说说读写锁</li></ul><p>分类自旋锁、互斥锁。性能从高到低排序(仅供参考，不同环境下有差异)</p><ul><li>os_unfair_lock(iOS10)</li><li>OSSpinLock</li><li>dispatch_semaphore(常用)</li><li>pthread_mutex（常用）</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive) （为了保证能递归加锁，内部肯定是有一些逻辑的，所以性能上稍差点）</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul><h3 id="5-5-死锁"><a href="#5-5-死锁" class="headerlink" title="5.5 死锁"></a>5.5 死锁</h3><p>死锁的原因：只有4个条件都满足时，才会出现死锁。</p><ul><li>互斥(Mutual exclusion)：任一时刻只允许一个进程使用资源;</li><li>请求和保持(Request and hold)：进程在请求其余资源时，不主动释放已经占用的资源; </li><li>非剥夺(Nonpreemptive)：进程已经占用的资源，不会被强制剥夺;</li><li>环路等待(Circular Wait)：环路中的每一条边是进程在请求另一进程已经占有的资源。</li></ul><p>如何解决？</p><h3 id="5-5-其他常见问题"><a href="#5-5-其他常见问题" class="headerlink" title="5.5 其他常见问题"></a>5.5 其他常见问题</h3><ul><li><p>如果要在GCD里面取消任务 怎么操作</p></li><li><p>创建队列的时候， 这个 label 你有没有用到过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li><li><p>多线程并发，多少比较合适，有没有了解过相关的标准。AFN、SD中都是多少</p></li><li><p>如果有多个任务来回做，它们有优先级的处理，要怎么做？（线程的优先级、任务的优先级可以理解为一个东西，都是任务的优先级，它与线程是绑定的）</p></li><li><p>已经执行的任务可能干扰不了，那排队未执行的任务根据优先级要怎么调整</p></li><li><p>多个异步任务依赖的处理方案</p></li><li><p>多读单写的实现：pthread_rwlock、dispatch_barrier_async</p></li><li><p>atomic是线程安全吗</p><p>atomic只能保证setter、getter方法之间是线程安全的。并不能保证使用属性、方法的过程是线程安全的，比如对NSMutableArray实例的使用，setter、getter过程是安全的，但接下来对NSMutableArray实例的使用（addObject）是有线程安全隐患的。还需要自己加锁</p><p>或者说，若属性是指针类型，只能保证对属性这个指针变量本身的读写是线程安全的，并不保证对指针指向的内存空间的读写是否线程安全</p></li></ul><h2 id="六、设计模式与框架"><a href="#六、设计模式与框架" class="headerlink" title="六、设计模式与框架"></a>六、设计模式与框架</h2><h3 id="6-1-Apple-MVC与传统MVC"><a href="#6-1-Apple-MVC与传统MVC" class="headerlink" title="6.1 Apple MVC与传统MVC"></a>6.1 Apple MVC与传统MVC</h3><h3 id="6-1-MVVM"><a href="#6-1-MVVM" class="headerlink" title="6.1 MVVM"></a>6.1 MVVM</h3><ul><li>RAC 冷信号</li><li>RAC 数据流</li><li>RAC 如果出现 A-&gt;B-&gt;C-&gt;A, 那么怎么断环</li></ul><h3 id="6-2-MVP"><a href="#6-2-MVP" class="headerlink" title="6.2 MVP"></a>6.2 MVP</h3><p>优点：说了相比MVC的改进</p><p>缺点：说了相比MVVM的不足</p><h3 id="6-3-组件化"><a href="#6-3-组件化" class="headerlink" title="6.3 组件化"></a>6.3 组件化</h3><ul><li><p>模块解耦：中心化 去中心化</p></li><li><p>组件化、模块化的理解：划分粒度</p></li></ul><h3 id="6-4-设计模式"><a href="#6-4-设计模式" class="headerlink" title="6.4 设计模式"></a>6.4 设计模式</h3><p>常用的设计模式，熟练哪一个，用纸笔画一下类图，什么结构、联系</p><p>平时会画类图吗，如果不画，那平时设计架构，怎么跟别人沟通讲解呢，每个类在干什么、具体什么联系、别人怎么修改你的</p><h2 id="七、性能问题监测及优化"><a href="#七、性能问题监测及优化" class="headerlink" title="七、性能问题监测及优化"></a>七、性能问题监测及优化</h2><h3 id="7-1-流畅性-FPS"><a href="#7-1-流畅性-FPS" class="headerlink" title="7.1 流畅性(FPS)"></a>7.1 流畅性(FPS)</h3><p>例如runloop能检测卡顿 是在runloop哪个阶段 多线程runloop收集到卡顿 如何告诉主线程</p><ul><li><a href="https://blog.csdn.net/Hello_Hwc/article/details/84311933?utm_source=app&app_version=4.5.7">iOS 性能优化 - TimeProfiler分析代码耗时</a></li></ul><h3 id="7-2-内存"><a href="#7-2-内存" class="headerlink" title="7.2 内存"></a>7.2 内存</h3><blockquote><p>OOM，是 Out of Memory 的缩写，指的是 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后，而被系统强杀掉的现象</p></blockquote><ul><li>内存过高被杀死，如何定位大概位置</li><li>内存泄露监控，说一下思路（如果你自己写一个检测内存泄露的工具，你会怎么写）</li></ul><h3 id="7-3-崩溃"><a href="#7-3-崩溃" class="headerlink" title="7.3 崩溃"></a>7.3 崩溃</h3><blockquote><p> 检测、采集、防崩溃</p></blockquote><ul><li><p>Crash产生的原因，都有哪些种类：exception、signal等，</p></li><li><p>对于难处理的exception、signal是怎么处理的</p></li><li><p>NSSetUncaughtExceptionHandler一定能采集到吗？什么是采集不到的</p></li><li><p>后台崩溃是采集不到的，那怎么采集后台崩溃呢？</p></li><li><p>对于Mach层次的异常，是怎么捕获的</p><p>Mach为XNU的微内核，Mach异常为最底层的内核级异常，在iOS系统中，底层Crash先触发Mach异常，然后再转换为对应的signal信号。</p></li><li><p><a href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p></li><li><p><a href="https://time.geekbang.org/column/article/88600">12 | iOS 崩溃千奇百怪，如何全面监控？</a></p></li><li><p><a href="https://www.jianshu.com/p/930d7f77df6c">iOS中Crash采集及PLCrashReporter使用</a></p></li><li><p>自己编写防崩溃组件，功能：</p><ul><li>常见崩溃的预防拦截<ul><li>比如给NSArray、NSDictionary添加分类，hook方法，处理insert nil的crash</li><li>运用消息转发机制，处理unrecognized selector的方法</li><li>这些拦截，是一直开着，还是只debug开着，线上开着这个，会造成其它未知的错误吗  </li></ul></li><li>其它崩溃的采集、崩溃信息的可视化、统计<ul><li>都上传了什么数据：backtrace C函数获取调用堆栈。是什么时机调用的呢？</li><li>怎么可视化</li></ul></li></ul></li><li><p>bugly无法获取的崩溃有哪些</p></li><li><p>数组越界的处理，除了hook外，有什么更好的处理方式</p></li><li><p>Crash收集防护怎么做，常见的Crash场景，怎么收集上报的，OOM性能怎么监控，如果让你打造一款Bugly,你会考虑怎么设计</p></li></ul><h3 id="7-4-网络层优化"><a href="#7-4-网络层优化" class="headerlink" title="7.4 网络层优化"></a>7.4 网络层优化</h3><ul><li>安全性<ul><li>防中间人攻击？单向校验，双向校验还是双向认证</li><li>AFN中关于安全校验的一些API</li><li>了解榕树贷款的证书机制</li><li>了解别人能抓包的原因，配置的什么证书就可以了？为什么可以？处于证书信任链中？</li></ul></li></ul><h3 id="7-5-启动速度优化"><a href="#7-5-启动速度优化" class="headerlink" title="7.5 启动速度优化"></a>7.5 启动速度优化</h3><blockquote><p>优化方案及数据</p></blockquote><p>冷启动速度</p><ul><li>运行，有个环境变量，配置之后可以打印premain耗时情况</li><li>冷启动时间的统计：kill进程并不代表一定就是真正的冷启动流程，必须等刚刚运行时占用的内存被真正回收掉。可以卸载APP或者重启手机。1.2s左右</li><li>main阶段的时间统计：APPdelegate时间戳 - main函数时间戳。2.7 2.8s左右</li><li>插桩、重排是优化哪个阶段的，效果是多少。premain</li></ul><p>二进制重排</p><ul><li><p>为什么：缺页中断影响执行速度 </p></li><li><p>原理：Clang插桩</p></li><li><p>配置路径：build setting - order file</p></li></ul><h3 id="7-6-包体积优化"><a href="#7-6-包体积优化" class="headerlink" title="7.6 包体积优化"></a>7.6 包体积优化</h3><ul><li><p>优化手段</p></li><li><p>怎么检测项目中无用代码，背后的检测原理知道吗</p></li></ul><h3 id="7-7-LLVM中间代码优化"><a href="#7-7-LLVM中间代码优化" class="headerlink" title="7.7 LLVM中间代码优化"></a>7.7 LLVM中间代码优化</h3><blockquote><p>LLVM pass是否了解过，有编写过吗</p></blockquote><h3 id="7-8-应用安全"><a href="#7-8-应用安全" class="headerlink" title="7.8 应用安全"></a>7.8 应用安全</h3><h4 id="7-8-1-网络安全"><a href="#7-8-1-网络安全" class="headerlink" title="7.8.1 网络安全"></a>7.8.1 网络安全</h4><h4 id="7-8-2-防逆向"><a href="#7-8-2-防逆向" class="headerlink" title="7.8.2 防逆向"></a>7.8.2 防逆向</h4><h3 id="7-9-Xcode提供的优化手段"><a href="#7-9-Xcode提供的优化手段" class="headerlink" title="7.9 Xcode提供的优化手段"></a>7.9 Xcode提供的优化手段</h3><h4 id="7-9-1-Analyze静态分析"><a href="#7-9-1-Analyze静态分析" class="headerlink" title="7.9.1 Analyze静态分析"></a>7.9.1 Analyze静态分析</h4><p>僵尸对象诊断可以帮助快速定位多数情况下的野指针问题，但也有时候不能奏效，这个时候只能利用Xcode的Analyze静态分析帮助检查可能出问题的地方，仔细检查问题所在，比较费时。</p><p>使用方法很简单，选中Xcode顶部导航栏Product-Analyze或使用快捷键Command+Shift+B，分析需要花一些时间，然后左侧会列出编辑器发现的存在潜在问题的地方，选中蓝色图标对应的问题项会跳到问题项所在的代码行。但这只能给出一些潜在提示，帮助搜索问题所在，不一定和我们的bug相关。</p><h3 id="7-10-常见面试题"><a href="#7-10-常见面试题" class="headerlink" title="7.10 常见面试题"></a>7.10 常见面试题</h3><ul><li>做过哪些性能优化</li><li>线上有做性能检测措施吗？比如卡顿(FPS检查)上报(上报堆栈)</li><li>崩溃率有统计过吗？万2左右(Keep)算不错了</li><li>应用安全方面？<ul><li>ptrace 防lldb 远程debug</li></ul></li><li>APM （Application Performance Management，即应用性能管理，在分布式领域也称为分布式跟踪管理）对企业的应用系统进行实时监控，它是用于实现对应用程序性能管理和故障管理的系统化的解决方案。<ul><li>matrix(矩阵、模型)  —— 微信开源的工具 <a href="https://github.com/Tencent/matrix">https://github.com/Tencent/matrix</a></li></ul></li><li><a href="https://satanwoo.github.io/2017/07/30/xlog/">微信高性能线上日志系统xlog剖析 — SatanWoo</a></li></ul><h2 id="八、编译、链接、装载"><a href="#八、编译、链接、装载" class="headerlink" title="八、编译、链接、装载"></a>八、编译、链接、装载</h2><ul><li><p>编译过程</p><ul><li>中间的binding过程，可以做什么优化：减少动态库、动态库改静态库？</li></ul></li><li><p>app启动流程</p></li><li><p>堆栈符号化定位</p></li><li><p>写一个APP，原则上一个文件就能搞定所有的事情，我们为什么还搞那么多文件，那么多类</p></li><li><p>内存和虚拟内存 如何映射</p></li><li><p>混合架构的framework 静态库 需要分离么</p></li><li><p>静态库中包含分类文件，如何调用。</p></li><li><p>为什么需要加Objc，静态库的加载流程，Objc的语义？</p></li><li></li></ul><h2 id="九、数据库"><a href="#九、数据库" class="headerlink" title="九、数据库"></a>九、数据库</h2><ul><li>以txt文本文件为例，实现类似数据库的增删改查，比如存储信息为通讯录：姓名 电话 手机号 超长的介绍</li><li>存储 文件和数据库 选择</li><li>比fmdb更好的优化方案</li></ul><h3 id="9-1-Protocol-Buffers-PB"><a href="#9-1-Protocol-Buffers-PB" class="headerlink" title="9.1 Protocol Buffers(PB)"></a>9.1 Protocol Buffers(PB)</h3><p>Protocol Buffers(简称Protobuf, PB) ，是Google出品的序列化框架，与开发语言无关，和平台无关，具有良好的可扩展性。Protobuf和所有的序列化框架一样，都可以用于数据存储、通讯协议。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><p>Portobuf的序列化的结果体积要比XML、JSON小很多，XML和JSON的描述信息太多了，导致消息要大；此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</p><p>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</p><p><a href="https://juejin.cn/post/6844903622266847246">https://juejin.cn/post/6844903622266847246</a></p><ul><li>protobuf 是怎么进行解析的， 有啥可以优化点</li></ul><h2 id="十、Swift"><a href="#十、Swift" class="headerlink" title="十、Swift"></a>十、Swift</h2><ul><li>oc怎么转换成SwiftUI</li><li>swift 为什么推荐使用 结构体，swift数组为什么选择使用 结构体。类和结构体的区别</li><li>静态库中swift与OC如何实现混编？</li><li>swift 与 OC混编 module的原理是什么？</li><li>swift 与 OC 混编 module的配置流程？</li><li>oc的 KVO 你已经知道了，那么 swift 的KVO 原理懂么</li><li>Swift的修饰词</li></ul><h2 id="十一、JavaScript与RN"><a href="#十一、JavaScript与RN" class="headerlink" title="十一、JavaScript与RN"></a>十一、JavaScript与RN</h2><ul><li>跨平台的方案分析，选型以及优化点</li></ul><ol><li><p>原型继承</p></li><li><p>写过JS吗？获取一个元素试试？</p></li></ol><p>document.getElementById:()</p><ol start="3"><li>写过CSS样式吗？选择器的权重</li></ol><p>默认/继承样式 &lt; 标签选择器 &lt; 类选择器 &lt; “ID”选择器 &lt; 行内样式 &lt; “!important”修饰符</p><p>通配符选择器仅大于继承样式，但是不推荐使用</p><ol start="4"><li>组件的生命周期 </li></ol><p><a href="https://www.jianshu.com/p/7b4fe125aa92">https://www.jianshu.com/p/7b4fe125aa92</a></p><ol start="5"><li>props state 区别</li></ol><p><code>props（“properties” 的缩写）</code>和 <code>state</code> 都是普通的 <code>JavaScript</code> 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：</p><ul><li><code>props</code> 是传递给组件的（类似于函数的形参），而 <code>state</code> 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li><li><code>props</code> 是不可修改的，所有 <code>React</code> 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改。 由于 <code>props</code> 是传入的，并且它们不能更改，因此我们可以将任何仅使用 <code>props</code> 的 <code>React</code> 组件视为 <code>pureComponent</code>，也就是说，在相同的输入下，它将始终呈现相同的输出。</li><li><code>state</code> 是在组件中创建的，一般在 <code>constructor</code>中初始化 <code>state</code></li><li><code>state</code> 是多变的、可以修改，每次<code>setState</code>都异步更新的。</li></ul><h2 id="十二、开放题"><a href="#十二、开放题" class="headerlink" title="十二、开放题"></a>十二、开放题</h2><h3 id="12-1-项目"><a href="#12-1-项目" class="headerlink" title="12.1 项目"></a>12.1 项目</h3><ul><li>感觉有亮点的项目讲一下</li><li>遇到了哪些问题以及怎么解决的</li><li>开发中遇到问题是怎么排查的，讲一下解决问题的思路及手段</li></ul><h3 id="12-2-其他"><a href="#12-2-其他" class="headerlink" title="12.2 其他"></a>12.2 其他</h3><ul><li>哪个项目是你觉得最有经验、心得的？</li><li>最有成就感的一项技术产出是什么</li></ul><ul><li><p>如果多个组件，还有 弹窗，前后台切换，页面push等等 都可能 控制 播放器的播放和停止，那么你怎么设计一个无依赖的方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通知。但通知有一个大问题，就是不好管理，然后没有传递链(抖音应该不会用这么low的方案...)</span><br><span class="line">2. 中间状态 statefulwidget（题目的意思可能在考察组件化的概念）</span><br><span class="line">3. 但感觉面试官不满意答案2...</span><br></pre></td></tr></table></figure></li></ul><h2 id="待归类"><a href="#待归类" class="headerlink" title="待归类"></a>待归类</h2><p>CI构建，编译打包流程；(Jenkins、fastlane。就是持续集成，讲讲你的理解，怎么配置，怎么构建之类)</p><ul><li>自动打包是其中的一个功能</li></ul><p>Runtime/Runloop这种机制，为啥要设计这种机制呢，编译时运行时；</p><p>几种多线程方案的利弊；</p><p>APP安装包都有什么，怎么瘦身，背后怎么做的，哪些场景可能会引起包体积增大；</p><p>怎么看待异常；</p><p>进程和线程；</p><p>对iOS新技术有关注吗（我说了Flutter，那Flutter具体怎么做的，事件响应怎么设计之类的。。。）</p><p>ˇ好未来</p><p>1：组件化 理解 解耦 方式<br>2：项目结构 模块<br>3：网络模块 怎么处理  AFNetWorking  源码  NSURLConnection  NSURLSession的区别<br>4:  HTTP HTTPS  加密过程<br>5：TCP网络三次握手<br>6：网络相关常见错误码<br>7：自动释放池  自动师范池与runloop的区别<br>8：堆和栈的区别<br>9：block  为什么要用copy修饰  注意点<br>10： 启动优化  load  initialize 的区别<br>11：App 打包成 api 做了那些事<br>12：自动化搭建<br>13：线上的问题的定位 修复 监护 卡顿<br>14：崩溃类型  解决方案<br>15：空指针<br>16：单例<br>17：设计模式<br>18：原生和H5的交互  释放时间 监控白屏 其他坑<br>19：内存占用  内存泄漏<br>20：卡顿：tableView    切圆角  离屏渲染<br>21：最近学习东西<br>22：isa </p><p>了解过 __ attribute__((constructor))相关函数么？作用是什么 ？</p><ul><li><p><a href="https://www.jianshu.com/p/dd425b9dc9db">https://www.jianshu.com/p/dd425b9dc9db</a></p></li><li><p><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html</a></p></li></ul><p>多个非系统动态库的合并？需要合并么，如果需要，怎么合并</p><p>iOS6以下系统，默认navBar和tabBar都不占空间。</p><p>iOS7及以上系统默认：</p><ul><li>self.navigationController.navigationBar.translucent(半透明)为YES</li><li>self.edgesForExtendedLayout = UIRectEdgeAll</li><li>此时，self.view.frame.origin.y从0开始（屏幕最上部、navigationBar的顶部）。</li></ul><p>设置translucent=NO、与edgesForExtendedLayout=UIRectEdgeNone 都会使self.view.frame.origin.y下移(navBar高度)个像素，即self.view中的子控件布局从navBar下方开始</p><ul><li>如果只设置后者，由于navBar是透明的，会出现64像素的黑色区域。设置背景色、背景图片都有点问题，所以最好设置前者</li></ul><p>iOS7之后也增加了一个self.tabBarController.tabBar.translucent的属性，默认为YES。效果同上</p><p>注意：在viewDidLoad中打印self.view.frame是屏幕宽高，在viewWillAppear及之后的生命周期方法中，才会因为上面的设置而改变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、算法与数据结构&quot;&gt;&lt;a href=&quot;#一、算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、算法与数据结构&quot;&gt;&lt;/a&gt;一、算法与数据结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;链表中是否有环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个整型数组，将</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="interview" scheme="https://tenloy.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
