<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-09-09T02:40:14.393Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转] AFN框架实现解析</title>
    <link href="https://tenloy.github.io/2021/09/10/AFN-Analyse.html"/>
    <id>https://tenloy.github.io/2021/09/10/AFN-Analyse.html</id>
    <published>2021-09-10T18:53:12.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">原文链接</a>，有一些细节修改</p></blockquote><img src="/images/AFN/AFN-01.png" alt="img" style="zoom:70%;" /><ul><li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li><li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li><li>本文将从源码的角度去分析AF的实际作用。 <strong>或许看完这篇文章，你心里会有一个答案。</strong></li></ul><h1 id="一、框架结构"><a href="#一、框架结构" class="headerlink" title="一、框架结构"></a>一、框架结构</h1><p>先从最新的AF3.x讲起吧：</p><p>首先，我们就一起分析一下该框架的组成。 将AF下载导入工程后，下面是AF代码结构图，相对于2.x变得非常简单了：</p><img src="/images/AFN/AFN-02.jpg" alt="img" style="zoom:60%;" /><p>除去Support Files，可以看到AF分为如下5个功能模块：</p><ul><li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li><li>网络状态监听模块(Reachability)</li><li>网络通信安全策略模块(Security)</li><li>网络通信信息序列化/反序列化模块(Serialization)</li><li>对于iOS UIKit库的扩展(UIKit)</li></ul><p>这五个模块所对应的类的结构关系图（AF架构图）如下所示：</p><ul><li><strong>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</strong></li><li>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></li></ul><img src="/images/AFN/AFN-03.jpg" alt="img" style="zoom:55%;" /><h1 id="二、AFURL-amp-HTTPSessionManager"><a href="#二、AFURL-amp-HTTPSessionManager" class="headerlink" title="二、AFURL&amp;HTTPSessionManager"></a>二、AFURL&amp;HTTPSessionManager</h1><h2 id="2-1-AFHTTPSessionManager的初始化"><a href="#2-1-AFHTTPSessionManager的初始化" class="headerlink" title="2.1 AFHTTPSessionManager的初始化"></a>2.1 AFHTTPSessionManager的初始化</h2><h3 id="2-1-1-初始化源码"><a href="#2-1-1-初始化源码" class="headerlink" title="2.1.1 初始化源码"></a>2.1.1 初始化源码</h3><p>首先我们简单的写个get请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:<span class="string">@&quot;http://localhost&quot;</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="1-AFHTTPSessionManager"><a href="#1-AFHTTPSessionManager" class="headerlink" title="1. AFHTTPSessionManager"></a>1. AFHTTPSessionManager</h4><p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:url sessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span> sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化都调用到这个方法中来了</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li><li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li></ul><h4 id="2-AFURLSessionManager"><a href="#2-AFURLSessionManager" class="headerlink" title="2. AFURLSessionManager"></a>2. AFURLSessionManager</h4><p>直接来到父类AFURLSessionManager的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">      configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">  <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">  <span class="comment">// 重点：这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span></span><br><span class="line">  <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//各种响应转码</span></span><br><span class="line">  <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认安全策略</span></span><br><span class="line">  <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">  <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点2：这个字典是用来让每一个请求task和我们自定义的AF代理来建立映射用的。</span></span><br><span class="line">    <span class="comment">// 在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理</span></span><br><span class="line">    <span class="comment">// 其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span></span><br><span class="line">  <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点3：置空task关联的代理。</span></span><br><span class="line">    <span class="comment">// 作用：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。</span></span><br><span class="line">    <span class="comment">// 但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：https://github.com/AFNetworking/AFNetworking/issues/3499。原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</span></span><br><span class="line">  [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;        </span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-NSURLSession概述"><a href="#2-1-2-NSURLSession概述" class="headerlink" title="2.1.2 NSURLSession概述"></a>2.1.2 NSURLSession概述</h3><ul><li>用于替代 <code>NSURLConnection</code></li><li>支持后台运行的网络任务</li><li>暂停、停止、重启网络任务，不再需要 <code>NSOperation</code> 封装</li><li>请求可以使用同样的<code>配置容器</code></li><li>不同的 <code>session</code> 可以使用不同的私有存储</li><li><code>block</code> 和<code>代理</code>可以同时起作用</li><li>直接从文件系统上传、下载</li><li>为了方便程序员使用，苹果提供了一个全局 <code>session</code></li><li>所有的 <code>任务(Task)</code> 都是由 <code>Session</code> 发起的</li><li>所有的任务默认是<code>挂起</code>的，需要 <code>Resume</code></li></ul><p>协议支持：</p><ul><li>NSURLSession 类支持data、file、ftp、http 和 https URL schemes，透明支持代理服务器和 SOCKS 网关，如用户系统首选项中配置的那样。</li><li>NSURLSession 支持 HTTP/1.1、HTTP/2 和 HTTP/3 协议。 如 RFC 7540 所述，HTTP/2 支持需要支持应用层协议协商 (ALPN) 的服务器。</li><li>还可以通过继承 NSURLProtocol 来添加对开发者自定义的网络协议和 URL 方案的支持（供您的应用程序私人使用）。</li></ul><p>线程安全：</p><p>URL Session API 是线程安全的。 可以在任何线程上下文中自由创建 sessions 和 tasks。 当调用提供的 completion handlers 时，工作会自动安排在正确的 delegate queue 中。</p><h3 id="2-1-3-NSURLSessionConfigration概述"><a href="#2-1-3-NSURLSessionConfigration概述" class="headerlink" title="2.1.3 NSURLSessionConfigration概述"></a>2.1.3 NSURLSessionConfigration概述</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">    configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration。会话配置文件用于设置网络会话属性，包括：身份验证，超时时长，缓存策略，Cookie等。</p><h4 id="1-三种模式"><a href="#1-三种模式" class="headerlink" title="1. 三种模式"></a>1. 三种模式</h4><p>NSURLSessionConfiguration有三个类工厂方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通模式（default）：返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//临时模式（ephemeral）：返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//后台模式（background）：特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在按下home键后，即应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfiguration:(<span class="built_in">NSString</span> *)identifier; </span><br></pre></td></tr></table></figure><p>一般基本上都是使用默认设置。</p><h4 id="2-HTTPMaximumConnectionsPerHost属性"><a href="#2-HTTPMaximumConnectionsPerHost属性" class="headerlink" title="2. HTTPMaximumConnectionsPerHost属性"></a>2. HTTPMaximumConnectionsPerHost属性</h4><p>与给定主机建立的最大同时连接数。</p><p>此属性决定了根据本configuration创建的 sessions 中的任务与每个主机建立的最大同时连接数。</p><p>此限制是针对每个 session 的，因此如果使用了多个 session，那应用程序作为一个整体可能会超过此限制。 此外，根据与 Internet 的连接，session 使用的限制可能低于指定的限制。</p><p>macOS 中的默认值为 6，iOS 中的默认值为 4。</p><ul><li>如果 session 是用上面三个类工厂方法创建的，那么将共享 HTTPMaximumConnectionsPerHost 的设置，即最后一次的配置为所有session使用的最终的配置。</li><li>最好不要为了增加并发而创建多个Session，创建多个Session的目的应该是为了对不同的Task使用不同的策略，来实现更符合我们需求的交互。</li></ul><h3 id="2-1-4-AF-maxConcurrentOperationCount设置"><a href="#2-1-4-AF-maxConcurrentOperationCount设置" class="headerlink" title="2.1.4 AF maxConcurrentOperationCount设置"></a>2.1.4 AF maxConcurrentOperationCount设置</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里先说结论，有些内容是在下面陈述的：</p><ul><li><p>首先我们要明确一个概念，<strong>这里的并发数仅仅是回调代理的线程并发数。而不是请求网络的线程并发数。请求网络是由NSURLSession来做的，它内部维护了一个线程池，用来做网络请求</strong>。它调度线程，基于底层的CFSocket去发送请求和接收数据。这些<strong>线程是并发的</strong>。</p></li><li><p>明确了这个概念之后，我们来梳理一下AF3.x的整个流程和线程的关系：</p><ul><li>我们一开始初始化sessionManager的时候，一般都是在主线程，（当然不排除有些人喜欢在分线程初始化…）</li><li>然后我们调用get或者post等去请求数据，接着会进行request拼接，AF代理的字典映射，progress的KVO添加等等，到NSUrlSession的resume之前这些准备工作，仍旧是在主线程中的。</li><li>然后我们调用NSUrlSession的resume，接着就跑到NSUrlSession内部去对网络进行数据请求了,在它内部是多线程并发的去请求数据的。</li><li>紧接着数据请求完成后，回调回来在我们一开始生成的并发数为1的NSOperationQueue中，这个时候会是多线程串行的回调回来的。（注：不明白的朋友可以看看雷纯峰大神这篇<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues</a>）</li><li>然后我们到返回数据解析那一块，我们自己又创建了并发的多线程，去对这些数据进行了各种类型的解析。</li><li>最后我们如果有自定义的completionQueue，则在自定义的queue中回调回来，也就是分线程回调回来，否则就是主队列，主线程中回调结束。</li></ul></li><li><p>最后我们来解释解释为什么回调Queue要设置并发数为1：个人认为AF这么做有以下两点原因：</p><ul><li><p>众所周知，AF2.x所有的回调是在一条线程（<em>参考6.7小节</em>），这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。</p></li><li><p>因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。<strong>反而多task回调导致的多线程并发，平白浪费了部分性能。</strong></p><p>而设置Queue的并发数为1（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFURLSessionManager的那些方法）至少回调的事件，是不需要多线程并发的。<strong>回调没有了NSLock的等待时间，所以对时间并没有多大的影响。</strong></p></li><li><p>注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程：<font color='red'>response的解析是并发线程执行的</font>（<em>参考2.3.6-1小节</em>）。</p></li></ul></li></ul><p>初始化方法到这就全部完成了。</p><h2 id="2-2-AFHTTPSessionManager创建GET-Task"><a href="#2-2-AFHTTPSessionManager创建GET-Task" class="headerlink" title="2.2 AFHTTPSessionManager创建GET Task"></a>2.2 AFHTTPSessionManager创建GET Task</h2><h3 id="2-2-1-源码实现"><a href="#2-2-1-源码实现" class="headerlink" title="2.2.1 源码实现"></a>2.2.1 源码实现</h3><p>接着我们来看看网络请求:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//生成一个系统的NSURLSessionDataTask实例</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始网络请求</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                          uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                        downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                 success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                 failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 用self.requestSerializer把各种参数转化为一个我们最终请求网络需要的NSMutableURLRequest实例。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span>  <span class="comment">// 这里是用来忽略 ?: 带来的警告</span></span></span><br><span class="line">            <span class="comment">// 当解析错误，我们直接调用传进来的 failure 的 Block 失败返回了，这里有一个 self.completionQueue ，这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</span></span><br><span class="line">            <span class="comment">// 实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-AFURLRequestSerialization创建request"><a href="#2-2-2-AFURLRequestSerialization创建request" class="headerlink" title="2.2.2 AFURLRequestSerialization创建request"></a>2.2.2 AFURLRequestSerialization创建request</h3><p>AFURLRequestSerialization文件中定义了三个请求参数序列化的类：</p><ul><li>AFHTTPRequestSerializer<ul><li>符合 <code>AFURLRequestSerialization</code> 和 <code>AFURLResponseSerialization</code> 协议，提供 query 字符串 / URL form-encoded 参数序列化和默认请求头的具体基础实现，以及响应状态代码和内容类型验证。</li><li>鼓励任何处理 HTTP 请求序列化的程序继承 <code>AFHTTPRequestSerializer</code> ，以确保一致的默认行为。</li><li>当请求的 Content-Type 是 <code>application/x-www-form-urlencoded</code> 时使用。<font color='red'>默认</font></li></ul></li><li>AFJSONRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSJSONSerialization</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/json</code>。</li><li>当请求的 Content-Type 是 <code>application/json</code> 时使用。</li></ul></li><li>AFPropertyListRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSPropertyListSerializer</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/x-plist</code>。</li><li>当请求的 Content-Type 是 <code>application/x-plist</code> 时使用。</li></ul></li></ul><p>此处主要看的也是 AFHTTPRequestSerializer 序列化类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，debug模式下，如果缺少改参数，crash</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将request的各种观察属性循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="comment">//如果该观察属性已经发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           <span class="comment">//把给自己设置的属性给request设置</span></span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲一下这个方法，这个方法做了3件事：</p><h4 id="1-设置request请求类型"><a href="#1-设置request请求类型" class="headerlink" title="1. 设置request请求类型"></a>1. 设置request请求类型</h4><p>设置request的请求类型，get、post、put…等</p><h4 id="2-添加request配置参数"><a href="#2-添加request配置参数" class="headerlink" title="2. 添加request配置参数"></a>2. 添加request配置参数</h4><p>往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span></span><br><span class="line">    <span class="comment">// HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//就是一个数组里装了很多方法的名字,</span></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个函数就是封装了一些属性的名字，这些都是NSURLRequest的属性。</p><p>再来看看<code>self.mutableObservedChangedKeyPaths</code>，这个是 AFHTTPRequestSerializer 类的一个属性，在 init 方法中对这个集合进行了初始化，<strong>并对当前类的和NSURLRequest相关的那些属性添加了KVO监听</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *mutableObservedChangedKeyPaths;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 每次都会重置变化</span></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给这些key添加观察者为自己，就是request的各种属性，set方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO触发的方法：</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span></span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。</p><p>接下来调用下面的代码，用KVC的方式，把属性值都设置到我们请求的request中去。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure><h4 id="3-编码及设置请求参数"><a href="#3-编码及设置请求参数" class="headerlink" title="3. 编码及设置请求参数"></a>3. 编码及设置请求参数</h4><p>把需要传递的参数进行编码，并且设置到request中去：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从自己的head里去遍历，如果有值则设置给request的head</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来把各种类型的参数，array dic set转化成字符串，给request</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">//自定义的解析方式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认解析方式</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//post put请求</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了3件事：</p><h5 id="1-设置header中的参数"><a href="#1-设置header中的参数" class="headerlink" title="1) 设置header中的参数"></a>1) 设置header中的参数</h5><p>从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去</p><h5 id="2-将请求参数转换为字符串"><a href="#2-将请求参数转换为字符串" class="headerlink" title="2) 将请求参数转换为字符串"></a>2) 将请求参数转换为字符串</h5><p>把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span></span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分数组返回参数字符串</span></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="comment">//往下调用</span></span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span></span><br><span class="line">    <span class="comment">// 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span></span><br><span class="line">    <span class="comment">// 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;description&quot;</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[%@]&quot;</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[]&quot;</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</p><p>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.field = field;</span><br><span class="line">    <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@=%@&quot;</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     <span class="string">@&quot;phone&quot;</span>: @&#123;<span class="string">@&quot;mobile&quot;</span>: <span class="string">@&quot;xx&quot;</span>, <span class="string">@&quot;home&quot;</span>: <span class="string">@&quot;xx&quot;</span>&#125;, </span><br><span class="line">     <span class="string">@&quot;families&quot;</span>: @[<span class="string">@&quot;father&quot;</span>, <span class="string">@&quot;mother&quot;</span>], </span><br><span class="line">     <span class="string">@&quot;nums&quot;</span>: [NSSet setWithObjects:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: <span class="string">@&quot;name&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[mobile]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[home]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;father&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;mother&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;1&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;2&quot;</span>, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=<span class="number">1</span>&amp;num=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p><h5 id="3-根据请求类型设置请求参数"><a href="#3-根据请求类型设置请求参数" class="headerlink" title="3) 根据请求类型设置请求参数"></a>3) 根据请求类型设置请求参数</h5><p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//post put请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求体</span></span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们生成了一个request。</p><h3 id="2-2-3-AFURLSessionManger父类创建task"><a href="#2-2-3-AFURLSessionManger父类创建task" class="headerlink" title="2.2.3 AFURLSessionManger父类创建task"></a>2.2.3 AFURLSessionManger父类创建task</h3><p>现在弄清楚request的创建流程中，我们跳出当前方法，再回到上层AFHTTPSessionManager类中的 <code>dataTaskWithHTTPMethod:URLString:...</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                      uploadProgress:uploadProgress</span><br><span class="line">                    downloadProgress:downloadProgress</span><br><span class="line">                   completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            failure(dataTask, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(dataTask, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这是调用了继承自父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                    uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                  downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                 completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//第一件事，创建NSURLSessionDataTask，里面适配了iOS 8以下taskIdentifiers，函数创建task对象。</span></span><br><span class="line">    <span class="comment">//其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span></span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</p><h4 id="1-create-task-safely"><a href="#1-create-task-safely" class="headerlink" title="1. create_task_safely()"></a>1. create_task_safely()</h4><p>我们到这先到这个函数里去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="comment">// Fix of bug</span></span><br><span class="line">        <span class="comment">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line">        <span class="comment">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span></span><br><span class="line">      <span class="comment">//第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span></span><br><span class="line">      <span class="comment">//这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">//保证了即使是在多线程的环境下，也不会创建其他队列</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.creation&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用 <code>dataTask = [self.session dataTaskWithRequest:request];</code> 非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</p><p><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</p><p>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</p><h4 id="2-addDelegateForDataTask"><a href="#2-addDelegateForDataTask" class="headerlink" title="2. addDelegateForDataTask:"></a>2. addDelegateForDataTask:</h4><p>我们接着看到：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure><p>一起来看一下主要的调用流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</span><br><span class="line">﹂setDelegate:forTask:</span><br><span class="line">﹂setupProgressForTask:</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 生成一个AFURLSessionManagerTaskDelegate，这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系。代理把AFURLSessionManager这个类作为属性了，属性是weak声明的，所以不会存在循环引用的问题。</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. ***** 将AF delegate对象与 dataTask建立关系</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置AF delegate的上传进度，下载进度块。</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，如果没有这个参数，debug下crash在这</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁保证字典线程安全。要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为AF delegate 设置task 的progress监听</span></span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加task开始和暂停的通知</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为task设置progress</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 设置 downloadProgress 与 uploadProgress 的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么...）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//拿到上传下载期望的数据大小</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span></span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.downloadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 给task和progress的各个属及添加KVO监听</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//观察task的这些属性</span></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察progress这两个属性</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                            forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                               context:<span class="literal">NULL</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                          forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                             options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                             context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KVO 触发的监听方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是task</span></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]] || [object isKindOfClass:[<span class="built_in">NSURLSessionDownloadTask</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//给进度条赋新值</span></span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的赋新值会触发这两个，调用block回调，用户拿到进度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单直观，主要就是如果task触发KVO，则给progress进度赋值，因为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</p><p>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</p><p>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</p><p>到这里我们整个对task的处理就完成了。</p><h2 id="2-3-AFURLSessionManager中Session代理实现及转发"><a href="#2-3-AFURLSessionManager中Session代理实现及转发" class="headerlink" title="2.3 AFURLSessionManager中Session代理实现及转发"></a>2.3 AFURLSessionManager中Session代理实现及转发</h2><h3 id="2-3-1-代理方法概览"><a href="#2-3-1-代理方法概览" class="headerlink" title="2.3.1 代理方法概览"></a>2.3.1 代理方法概览</h3><p>接着task就开始请求网络了，还记得我们初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，下图这些NSUrlSession的代理开始调用了：</p><img src="/images/AFN/AFN-04.jpg" alt="img" style="zoom:60%;" /><p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p><p>而只转发了其中3条到下图中AF自定义的delegate中：</p><img src="/images/AFN/AFN-05.jpg" alt="img" style="zoom:60%;" /><p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p><p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSURLSession这么多代理呢？我们点到NSURLSession.h中去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionTaskDelegate</span> &lt;<span class="title">NSURLSessionDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDataDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDownloadDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionStreamDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</p><p>而AF还重写了<code>respondsToSelector</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复写了selector的方法，这几个方法是在本类有实现的，但这些代理方法实现中只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。所以返回NO，相当于没有实现！也就不会去回调这些代理。</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:willCacheResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSessionDidFinishEventsForBackgroundURLSession:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[self <span class="class"><span class="keyword">class</span>] <span class="title">instancesRespondToSelector</span>:<span class="type">selector];</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这，我们顺便看看AFURLSessionManager的一些自定义Block：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure><p>各自对应的还有一堆这样的set方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法都是一样的，就不重复粘贴占篇幅了。主要谈谈这个设计思路</p><ul><li>作者用@property把这些Block属性在.m文件中声明，然后复写了set方法。</li><li>然后在.h中去声明这些set方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br></pre></td></tr></table></figure><p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p><p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p><h3 id="2-3-2-NSURLSessionDelegate实现"><a href="#2-3-2-NSURLSessionDelegate实现" class="headerlink" title="2.3.2 NSURLSessionDelegate实现"></a>2.3.2 NSURLSessionDelegate实现</h3><h4 id="01-URLSession-didBecomeInvalidWithError"><a href="#01-URLSession-didBecomeInvalidWithError" class="headerlink" title="01. URLSession:didBecomeInvalidWithError"></a>01. URLSession:didBecomeInvalidWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前这个session已经失效时，该代理方法被调用。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span></span><br><span class="line"><span class="comment"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span></span><br><span class="line"><span class="comment"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li><li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li></ul><h4 id="02-URLSession-didReceiveChallenge"><a href="#02-URLSession-didReceiveChallenge" class="headerlink" title="02. URLSession:didReceiveChallenge"></a>02. URLSession:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、用作https认证的，详细看第四节AFSecurityPolicy</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-URLSessionDidFinishEventsForBackgro"><a href="#03-URLSessionDidFinishEventsForBackgro" class="headerlink" title="03. URLSessionDidFinishEventsForBackgro.."></a>03. URLSessionDidFinishEventsForBackgro..</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li>函数讨论：<ul><li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler: 消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li><li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li></ul></li></ul><h3 id="2-3-3-NSURLSessionTaskDelegate实现"><a href="#2-3-3-NSURLSessionTaskDelegate实现" class="headerlink" title="2.3.3 NSURLSessionTaskDelegate实现"></a>2.3.3 NSURLSessionTaskDelegate实现</h3><h4 id="04-URLSession-task-willPerformHTTPRedirection"><a href="#04-URLSession-task-willPerformHTTPRedirection" class="headerlink" title="04. URLSession:task:willPerformHTTPRedirection"></a>04. URLSession:task:willPerformHTTPRedirection</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被服务器重定向的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        <span class="comment">//用自己自定义的一个重定向的block实现，返回一个新的request。</span></span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        <span class="comment">// step2. 用request重新请求</span></span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">&#x27;BASEPATH&#x27;</span>) <span class="keyword">OR</span> <span class="keyword">exit</span>(<span class="string">&#x27;No direct script access allowed&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        header(<span class="string">&quot;location: http://www.huixionghome.cn/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p><p>关于这个代理还有一些需要注意的地方：此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。（这里指的模式是我们一开始初始化 session时的模式）。</p><h4 id="05-URLSession-task-didReceiveChallenge"><a href="#05-URLSession-task-didReceiveChallenge" class="headerlink" title="05.URLSession:task:didReceiveChallenge"></a>05.URLSession:task:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https认证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：</p><ul><li>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li><li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li><li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li></ul><h4 id="06-URLSession-task-needNewBodyStream"><a href="#06-URLSession-task-needNewBodyStream" class="headerlink" title="06. URLSession:task:needNewBodyStream"></a>06. URLSession:task:needNewBodyStream</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代理方法会在下面两种情况被调用：</p><ol><li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li><li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li></ol><h4 id="07-URLSession-task-didSendBodyData"><a href="#07-URLSession-task-didSendBodyData" class="headerlink" title="07. URLSession:task:didSendBodyData"></a>07. URLSession:task:didSendBodyData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 周期性地通知代理发送到服务器端数据的进度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span></span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Length&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li><li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li></ul><h4 id="08-URLSession-task-didCompleteWithError"><a href="#08-URLSession-task-didCompleteWithError" class="headerlink" title="08. URLSession:task:didCompleteWithError"></a>08. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> task完成之后的回调，成功和失败都会回调这里</span></span><br><span class="line"><span class="comment"> 函数讨论：</span></span><br><span class="line"><span class="comment"> 注意这里的error不会报告服务期端的error，他表示的是客户端这边的error，比如无法解析hostname或者连不上host主机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//根据task去取我们一开始创建绑定的delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//把代理转发给我们绑定的delegate</span></span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        <span class="comment">//转发完移除delegate</span></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Block回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理就是task完成了的回调，方法内做了下面这几件事：</p><ul><li><p>在这里我们拿到了之前和这个task对应绑定的AF的delegate:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>去转发了调用了AF代理的方法。这个等我们下面讲完NSUrlSession的代理之后会详细说。</p></li><li><p>然后把这个AF的代理和task的绑定解除了，并且移除了相关的progress和通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">  <span class="comment">//移除跟AF代理相关的东西</span></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  [delegate cleanUpProgressForTask:task];</span><br><span class="line">  [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用了自定义的Blcok:self.taskDidComplete(session, task, error);</p><p>代码还是很简单的，至于这个通知，我们等会再来补充吧。</p></li></ul><h3 id="2-3-4-NSURLSessionDataDelegate实现"><a href="#2-3-4-NSURLSessionDataDelegate实现" class="headerlink" title="2.3.4 NSURLSessionDataDelegate实现"></a>2.3.4 NSURLSessionDataDelegate实现</h3><h4 id="09-URLSession-dataTask-didReceiveResponse"><a href="#09-URLSession-dataTask-didReceiveResponse" class="headerlink" title="09. URLSession:dataTask:didReceiveResponse"></a>09. URLSession:dataTask:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务器响应后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置默认为继续进行</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义去设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><p>函数作用：告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：</p><ul><li>NSURLSessionResponseAllow 该task正常进行</li><li>NSURLSessionResponseCancel 该task会被取消</li><li>NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task</li><li>NSURLSessionResponseBecomeStream 转成一个StreamTask</li></ul><p>函数讨论：</p><p>该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。</p><p>总结一下：</p><ul><li>当你把添加content-type的类型为 multipart/x-mixed-replace 那么服务器的数据会分片的传回来。然后这个方法是每次接受到对应片响应的时候会调被调用。你可以去设置上述4种对这个task的处理。</li><li>如果我们实现了自定义Block，则调用一下，不然就用默认的NSURLSessionResponseAllow方式。</li></ul><h4 id="10-URLSession-dataTask-didBecomeDownloadTask"><a href="#10-URLSession-dataTask-didBecomeDownloadTask" class="headerlink" title="10. URLSession:dataTask:didBecomeDownloadTask"></a>10. URLSession:dataTask:didBecomeDownloadTask</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代理如果设置为NSURLSessionResponseBecomeDownload，则会触发调用这个方法，作用就是新建一个downloadTask，替换掉当前的dataTask。所以我们在这里做了AF自定义代理的重新绑定操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为转变了task，所以要对task做一个重新绑定</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照顺序来，其实还有个AF没有去实现的代理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF没实现的代理</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeStreamTask:(<span class="built_in">NSURLSessionStreamTask</span> *)streamTask;</span><br></pre></td></tr></table></figure><p>这个也是之前的那个代理，设置为NSURLSessionResponseBecomeStream则会调用到这个代理里来。会新生成一个NSURLSessionStreamTask来替换掉之前的dataTask。</p><h4 id="11-URLSession-dataTask-didReceiveData"><a href="#11-URLSession-dataTask-didReceiveData" class="headerlink" title="11. URLSession:dataTask:didReceiveData"></a>11. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们获取到数据就会调用，会被反复调用，请求到的数据就在这被拼装完整</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和上面didCompleteWithError算是NSUrlSession的代理中最重要的两个方法了。</p><p>我们转发了这个方法到AF的代理中去，所以数据的拼接都是在AF的代理中进行的。这也是情理中的，毕竟每个响应数据都是对应各个task，各个AF代理的。在AFURLSessionManager都只是做一些公共的处理。</p><h4 id="12-URLSession-dataTask-willCacheResponse"><a href="#12-URLSession-dataTask-willCacheResponse" class="headerlink" title="12. URLSession:dataTask:willCacheResponse"></a>12. URLSession:dataTask:willCacheResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当task接收到所有期望的数据后，session会调用此代理方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><ul><li><p>函数作用：</p><ul><li>询问data task或上传任务（upload task）是否缓存response。</li></ul></li><li><p>函数讨论：</p><ul><li>当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。</li><li>该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：<ul><li>该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）</li><li>确保request请求是成功的（返回的status code为200-299）</li><li>返回的response是来自服务器端的，而非缓存中本身就有的</li><li>提供的NSURLRequest对象的缓存策略要允许进行缓存</li><li>服务器返回的response中与缓存相关的header要允许缓存</li><li>该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）</li></ul></li></ul></li><li><p>总结一下就是一个用来缓存response的方法，方法中调用了我们自定义的Block，自定义一个response用来缓存。</p></li></ul><h3 id="2-3-5-NSURLSessionDownloadDelegate实现"><a href="#2-3-5-NSURLSessionDownloadDelegate实现" class="headerlink" title="2.3.5 NSURLSessionDownloadDelegate实现"></a>2.3.5 NSURLSessionDownloadDelegate实现</h3><h4 id="13-URLSession-downloadTask-didFinishDown…"><a href="#13-URLSession-downloadTask-didFinishDown…" class="headerlink" title="13. URLSession:downloadTask:didFinishDown…"></a>13. URLSession:downloadTask:didFinishDown…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载完成的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//这个是session的，也就是全局的，后面的个人代理也会做同样的这件事</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用自定义的block拿到文件存储的地址</span></span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">//从临时的下载路径移动至我们需要的路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            <span class="comment">//如果移动出错</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发代理</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和之前的两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)taskdidCompleteWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure><p>总共就这3个方法，被转调到AF自定义delegate中。</p><p>方法做了什么看注释应该很简单，就不赘述了。</p><h4 id="14-URLSession-downloadTask-didWriteData"><a href="#14-URLSession-downloadTask-didWriteData" class="headerlink" title="14. URLSession:downloadTask:didWriteData"></a>14. URLSession:downloadTask:didWriteData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//周期性地通知下载进度调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下这几个参数:</p><ul><li>bytesWritten表示自上次调用该方法后，接收到的数据字节数</li><li>totalBytesWritten表示目前已经接收到的数据字节数</li><li>totalBytesExpectedToWrite表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown。</li></ul><h4 id="15-URLSession-downloadTask-didResumeAtOffset"><a href="#15-URLSession-downloadTask-didResumeAtOffset" class="headerlink" title="15. URLSession:downloadTask:didResumeAtOffset"></a>15. URLSession:downloadTask:didResumeAtOffset</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当下载被取消或者失败后重新恢复下载时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交给自定义的Block去调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li><p>函数作用：</p><ul><li>告诉代理，下载任务重新开始下载了。</li></ul></li><li><p>函数讨论：</p><ul><li>如果一个正在下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。</li><li>随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。</li></ul></li></ul><p>总结一下：</p><ul><li><strong>其实这个就是用来做断点续传的代理方法。</strong>可以在下载失败的时候，拿到我们失败的拼接的部分resumeData，然后用去调用downloadTaskWithResumeData：就会调用到这个代理方法来了。</li><li>其中注意：fileOffset这个参数，如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。否则，该值表示当前已经下载data的偏移量。</li><li>方法中仅仅调用了downloadTaskDidResume自定义Block。</li></ul><p>至此NSUrlSesssion的delegate讲完了。大概总结下：</p><ul><li>每个代理方法对应一个我们自定义的Block,如果Block被赋值了，那么就调用它。</li><li>在这些代理方法里，我们做的处理都是相对于这个sessionManager所有的request的。<strong>是公用的处理。</strong></li><li>转发了3个代理方法到AF的deleagate中去了，AF中的deleagate是需要对应每个task去<strong>私有化处理的</strong>。</li></ul><h3 id="2-3-6-转发到AFURLSxxMxxTaskDelegate的方法"><a href="#2-3-6-转发到AFURLSxxMxxTaskDelegate的方法" class="headerlink" title="2.3.6 转发到AFURLSxxMxxTaskDelegate的方法"></a>2.3.6 转发到AFURLSxxMxxTaskDelegate的方法</h3><p>接下来我们来看从 AFURLSessionManager 中转发到 AFURLSessionManagerTaskDelegate 的deleagate，一共3个方法：</p><h4 id="1-URLSession-task-didCompleteWithError"><a href="#1-URLSession-task-didCompleteWithError" class="headerlink" title="1. URLSession:task:didCompleteWithError"></a>1. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF实现的代理！被从urlsession那转发到这</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block</span></span><br><span class="line"></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储一些相关信息，来发送通知用的</span></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//存储responseSerializer响应解析对象</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续给userinfo填数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以自己自定义完成组 和自定义完成queue,完成回调</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//主线程中发送完成通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//url_session_manager_processing_queue AF的并行队列</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析数据</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是下载文件，那么responseObject为下载的路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入userInfo</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果解析错误</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回调结果</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是NSURLSession任务完成的代理方法中，主动调用过来的。配合注释，应该代码很容易读，这个方法大概做了以下几件事：</p><ol><li><p>生成了一个存储这个task相关信息的字典：userInfo，这个字典是用来作为发送任务完成的通知的参数。</p></li><li><p>判断了参数error的值，来区分请求成功还是失败。</p></li><li><p>如果成功则在一个AF的并行queue中，去做数据解析等后续操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意AF的优化的点：<font color='red'>虽然代理回调是串行的(参考2.1.4小节 maxConcurrentOperationCount属性)。但是数据解析这种费时操作，确是用并行线程来做的。</font></p></li><li><p>然后根据我们一开始设置的responseSerializer来解析data。如果解析成功，调用成功的回调，否则调用失败的回调。我们重点来看看返回数据解析这行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br></pre></td></tr></table></figure><p>我们点进去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                         data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>原来就是这么一个协议方法，各种类型的responseSerializer类，都是遵守这个协议方法，实现了一个把我们请求到的data转换为我们需要的类型的数据的方法。至于各种类型的responseSerializer如何解析数据，我们到代理讲完再来补充。</p></li><li><p>这边还做了一个判断，如果自定义了GCD完成组completionGroup和完成队列的话completionQueue，会在加入这个组和在队列中回调Block。否则默认的是AF的创建的组：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和主队列回调。<strong>AF没有用这个GCD组做任何处理，只是提供这个接口，让我们有需求的自行调用处理。</strong>如果有对多个任务完成度的监听，可以自行处理。<br>而队列的话，如果你不需要回调主线程，可以自己设置一个回调队列。</p></li><li><p>回到主线程，发送了任务完成的通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>这个通知这回AF有用到了，在我们对UIKit的扩展中，用到了这个通知。</p></li></ol><h4 id="2-URLSession-dataTask-didReceiveData"><a href="#2-URLSession-dataTask-didReceiveData" class="headerlink" title="2. URLSession:dataTask:didReceiveData"></a>2. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拼接数据</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样被NSUrlSession代理转发到这里，拼接了需要回调的数据。</p><h4 id="3-URLSession-downloadTask-didFinishDownload…"><a href="#3-URLSession-downloadTask-didFinishDownload…" class="headerlink" title="3. URLSession:downloadTask:didFinishDownload…"></a>3. URLSession:downloadTask:didFinishDownload…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF代理的自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//得到自定义下载路径</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="comment">//把下载路径移动到我们自定义的下载路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误发通知</span></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载成功了被NSUrlSession代理转发到这里，这里有个地方需要注意下：</p><ul><li><p>之前的NSUrlSession代理和这里都移动了文件到下载路径，而NSUrlSession代理的下载路径是所有request公用的下载路径，一旦设置，所有的request都会下载到之前那个路径。</p></li><li><p>而这个是对应的每个task的，每个task可以设置各自下载路径,还记得AFHttpManager的download方法么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[manager downloadTaskWithRequest:resquest progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个地方return的path就是对应的这个代理方法里的path，我们调用最终会走到这么一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                     destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">  delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">  delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回地址的Block</span></span><br><span class="line">  <span class="keyword">if</span> (destination) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//有点绕，就是把一个block赋值给我们代理的downloadTaskDidFinishDownloading，这个Block里的内部返回也是调用Block去获取到的，这里面的参数都是AF代理传过去的。</span></span><br><span class="line">      delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">          <span class="comment">//把Block返回的地址返回</span></span><br><span class="line">          <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">  delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清楚的可以看到地址被赋值给AF的Block了。</p></li></ul><p>至此AF的代理也讲完了，<strong>数据或错误信息随着AF代理成功失败回调，回到了用户的手中。</strong></p><h2 id="2-4-AFURLSessionTaskSwizzling类"><a href="#2-4-AFURLSessionTaskSwizzling类" class="headerlink" title="2.4 _AFURLSessionTaskSwizzling类"></a>2.4 _AFURLSessionTaskSwizzling类</h2><p>在AFURLSessionManager中，有这么一个类：_AFURLSessionTaskSwizzling。这个类大概的作用就是替换掉NSURLSession中的resume和suspend方法。正常处理原有逻辑的同时，多发送一个通知，以下是我们需要替换的新方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被替换掉的方法，只要有TASK开启或者暂停，都会执行</span></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块知识是关于OC的Runtime:method swizzling的，如果有不清楚的地方，可以看看这里<a href="http://www.jianshu.com/p/db6dc23834e3">method swizzling–by冰霜</a>或者自行查阅。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionTask&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">&quot;-Wnonnull&quot;</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 2) 获取到af_resume实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 检查当前class是否实现了resume。如果实现了，继续第4步。</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 获取到当前class的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) 获取到当前class对于resume实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  6) 获取到父类对于resume实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                <span class="comment">//执行交换的函数</span></span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8) 设置当前操作的class为其父类class，重复步骤3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原方法中有大量的英文注释，我把它翻译过来如下：</p><ul><li><p>iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick</p><p>关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的</p></li><li><p>目前我们所知的：</p><ul><li>NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）</li><li>简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。</li><li>iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 <strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自__NSCFURLSessionTask。</li><li>iOS 8上，localDataTask的类型为<strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自NSURLSessionTask</li><li>iOS 7上，<strong>NSCFLocalSessionTask和</strong>NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外<strong>NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即</strong>NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。</li><li>iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类</li><li>因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。</li></ul></li><li><p>一些假设前提:</p><ul><li>目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理。</li><li>没有哪个后台task会重写resume和suspend函数</li></ul></li></ul><p>其余的一部分翻译在注释中，对应那一行代码。大概总结下这个注释：</p><ul><li>其实这是被社区大量讨论的一个bug，之前AF因为这个替换方法，会导致偶发性的crash，如果不要这个swizzle则问题不会再出现，但是这样会导致AF中很多UIKit的扩展都不能正常使用。</li><li><strong>原来这是因为iOS7和iOS8的NSURLSessionTask的继承链不同导致的，</strong>而且在iOS7继承链中会有两个类都实现了resume和suspend方法。而且子类没有调用父类的方法，我们则需要对着两个类都进行方法替换。而iOS8只需要对一个类进行替换。</li><li>对着注释看，上述方法代码不难理解，用一个while循环，一级一级去获取父类，如果实现了resume方法，则进行替换。</li></ul><p>但是有几个点大家可能会觉得疑惑的，我们先把这个方法调用的替换的函数一块贴出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其引用的交换的函数：</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有小伙伴问到过，所以我们来分析分析大家可能会觉得疑惑的地方：</p><ol><li><p>首先可以注意class_getInstanceMethod这个方法，它会获取到当前类继承链逐级往上，第一个实现的该方法。所以说它获取到的方法不能确定是当前类还是父类的。而且这里也没有用dispatch_once_t来保证一个方法只交换一次，那万一这是父类的方法，当前类换一次，父类又换一次，不是等于没交换么？…请注意这行判断：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line"><span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; </span><br><span class="line">      <span class="comment">//执行交换的函数</span></span><br><span class="line">     [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件就杜绝了这种情况的发生，只有当前类实现了这个方法，才可能进入这个if块。</p></li><li><p>那iOS7两个类都交换了af_resume，那岂不是父类换到子类方法了?…只能说又是没仔细看代码的…注意AF是去向当前类添加af_resume方法，然后去交换当前类的af_resume。所以说根本不会出现这种情况…</p></li></ol><h1 id="三、AFURLResponseSerialization"><a href="#三、AFURLResponseSerialization" class="headerlink" title="三、AFURLResponseSerialization"></a>三、AFURLResponseSerialization</h1><p>接下来我们来补充之前AFURLResponseSerialization这一块是如何解析数据的：</p><img src="/images/AFN/AFN-06.jpg" alt="img" style="zoom:70%;" /><p>如图所示，AF用来解析数据的一共上述这些方法。第一个实际是一个协议方法，协议方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>而后面6个类都是遵守这个协议方法，去做数据解析。**这地方可以再次感受一下AF的设计模式…**接下来我们就来主要看看这些类对这个协议方法的实现：</p><h2 id="3-1-AFHTTPResponseSerializer"><a href="#3-1-AFHTTPResponseSerializer" class="headerlink" title="3.1 AFHTTPResponseSerializer"></a>3.1 AFHTTPResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用了一个另外的方法之后，就把data返回来了，我们继续往里看这个方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是可接受类型和可接受code，不是则填充error</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//response是否合法标识</span></span><br><span class="line">  <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">//验证的error</span></span><br><span class="line">  <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果存在且是NSHTTPURLResponse</span></span><br><span class="line">  <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要判断自己能接受的数据类型和response的数据类型是否匹配，</span></span><br><span class="line">    <span class="comment">//如果有接受数据类型，如果不匹配response，而且响应类型不为空，数据长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">        !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入If块说明解析数据肯定是失败的，这时候要把解析错误信息放到error里。</span></span><br><span class="line">        <span class="comment">//如果数据长度大于0，而且有响应url</span></span><br><span class="line">        <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误信息字典，填充一些错误信息</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: unacceptable content-type: %@&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">            &#125; mutableCopy];</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成错误</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断自己可接受的状态吗</span></span><br><span class="line">    <span class="comment">//如果和response的状态码不匹配，则进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">        <span class="comment">//填写错误信息字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">             <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: %@ (%ld)&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">             <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">             AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">        &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成错误</span></span><br><span class="line">        validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给我们传过来的错误指针赋值</span></span><br><span class="line">  <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">      *error = validationError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回是否错误标识</span></span><br><span class="line">  <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看注释应该很容易明白这个方法有什么作用。简单来说，<strong>这个方法就是来判断返回数据与咱们使用的解析器是否匹配，需要解析的状态码是否匹配。</strong>如果错误，则填充错误信息，并且返回NO，否则返回YES，错误信息为nil。</li><li>其中里面出现了两个属性值，一个acceptableContentTypes，一个acceptableStatusCodes，两者在初始化的时候有给默认值，我们也可以去自定义，但是如果给acceptableContentTypes定义了不匹配的类型，那么数据仍旧会解析错误。</li><li>而AFHTTPResponseSerializer仅仅是调用验证方法，然后就返回了data。</li></ul><h2 id="3-2-AFJSONResponseSerializer"><a href="#3-2-AFJSONResponseSerializer" class="headerlink" title="3.2 AFJSONResponseSerializer"></a>3.2 AFJSONResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断是不是可接受类型和可接受code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空，或者有错误，去函数里判断。</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="comment">//返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">&quot; &quot;</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//没空格去json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要移除Null值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿着json解析的error去填充错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回解析结果</span></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，大概需要讲一下的是以下几个函数: （之前注释已经写清楚了这些函数的作用）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain))</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">AFErrorWithUnderlyingError(serializationError, *error);</span><br></pre></td></tr></table></figure><p>第一个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是我们自己之前生成的错误信息，是的话返回YES</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域名和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果userInfo的NSUnderlyingErrorKey有值，则在判断一次。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以注意，我们这里传过去的code和domain两个参数分别为NSURLErrorCannotDecodeContentData、AFURLResponseSerializationErrorDomain，这两个参数是我们之前判断response可接受类型和code时候自己去生成错误的时候填写的。</p><p>第二个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//分数组和字典</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个数组，只需要JSONObject.count个，感受到大神写代码的严谨态度了吗...</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            <span class="comment">//调用自己</span></span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看我们解析类型是mutable还是非muatable,返回mutableArray或者array</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="comment">//value空则移除</span></span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//如果数组还是去调用自己</span></span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要还是通过递归的形式实现。比较简单。</p><p>第三个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要是把json解析的错误，赋值给我们需要返回给用户的error上。比较简单，小伙伴们自己看看就好。</p><p>至此，AFJSONResponseSerializer就讲完了。而我们ResponseSerialize还有一些其他的类型解析，大家可以自行去阅读，代码还是很容易读的，在这里就不浪费篇幅去讲了。</p><p>至此我们AF3.X业务层的逻辑，基本上结束了。</p><h1 id="四、AFSecurityPolicy"><a href="#四、AFSecurityPolicy" class="headerlink" title="四、AFSecurityPolicy"></a>四、AFSecurityPolicy</h1><p>关于TLS的连接过程、单向认证/双向认证、证书信任链等概念，这里不再赘述了。</p><p>AF就是用AFSecurityPolicy这个类来满足我们各种https认证需求。在这之前我们来看看AF实现的 NSURLSessionDelegate 中用来做https认证的代理方法：</p><h2 id="4-1-session-didReceiveChallenge代理方法"><a href="#4-1-session-didReceiveChallenge代理方法" class="headerlink" title="4.1 session:didReceiveChallenge代理方法"></a>4.1 session:didReceiveChallenge代理方法</h2><p>这个方法就是做https认证的。把官方文档对这个方法的描述翻译一下：</p><ul><li><p>函数作用：</p><ul><li>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</li><li>接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential。<ul><li>disposition是应对这个挑战的认证方式，而credential是客户端应对这个挑战生成的证书。</li><li>注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书。</li></ul></li><li>最后调用completionHandler回应服务器端的挑战。</li></ul></li><li><p>函数讨论：</p><ul><li>该代理方法会在下面两种情况调用：<ul><li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li><li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）</li></ul></li><li>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 首先指定了https为默认的认证方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理。就像这个delegate方法没实现，credential被忽略</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书(证书可能为nil)</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战。整个请求都将被取消，credential被忽略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. sessionDidReceiveAuthenticationChallenge属性是一个自定义的做认证的Block，判断是否有值。</span></span><br><span class="line">    <span class="comment">// 若有，则调用，会生成一个认证方式，并给 credential 赋值，即我们需要接受认证的证书。</span></span><br><span class="line">    <span class="comment">// 若无，则去执行默认的认证步骤</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 3. 判断如果服务端的认证方法要求是 NSURLAuthenticationMethodServerTrust ，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust。也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。该证书需要使用credentialForTrust:来创建一个NSURLCredential对象。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 执行AFSecurityPolicy的方法，做一个AF内部的https认证：基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 用服务器返回的一个 serverTrust 去生成了一个认证证书。然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。</span></span><br><span class="line">                <span class="comment">// 注1：这个 serverTrust 是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）</span></span><br><span class="line">                <span class="comment">// 注2：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; <span class="comment">// 证书挑战</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;  <span class="comment">// 默认挑战</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回NO，说明AF内部认证失败，则取消挑战，即取消请求。</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 最后调用 completionHandler 传递认证方式和要认证的证书，去做系统根证书验证。</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下这里 <code>securityPolicy</code> 存在的作用就是，<strong>使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。</strong>如果通不过，则直接越过系统的验证，取消https的网络请求。否则，继续去走系统根证书的验证。</p><h2 id="4-2-AFSecurityPolicy内部"><a href="#4-2-AFSecurityPolicy内部" class="headerlink" title="4.2 AFSecurityPolicy内部"></a>4.2 AFSecurityPolicy内部</h2><p>接下来我们看看<code>AFSecurityPolicy</code>内部是如何做https认证的:</p><h3 id="4-2-1-五个属性"><a href="#4-2-1-五个属性" class="headerlink" title="4.2.1 五个属性"></a>4.2.1 五个属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFSSLPinningMode 共提供了3种验证方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    <span class="comment">//验证证书</span></span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFSecurityPolicy，一共有4个公有属性：</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https验证模式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="comment">// if pinning(固定) is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否去验证证书域名是否匹配</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如下方式，我们可以创建一个<code>securityPolicy</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">  AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  securityPolicy.SSLPinningMode = AFSSLPinningModeNone; <span class="comment">// 默认指定了SSLPinningMode模式为AFSSLPinningModeNone</span></span><br><span class="line">  <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFSecurityPolicy 还有一个私有属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br></pre></td></tr></table></figure><p>AF复写了 pinnedCertificates 属性的setter方法，会同时把证书中每个公钥放在了self.pinnedPublicKeys中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置证书数组</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    </span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应公钥集合</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="comment">//创建公钥集合</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//从证书中拿到公钥。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-evaluateServerTrust-方法"><a href="#4-2-2-evaluateServerTrust-方法" class="headerlink" title="4.2.2 evaluateServerTrust:方法"></a>4.2.2 evaluateServerTrust:方法</h3><h4 id="1-参数SecTrustRef与源码实现解读"><a href="#1-参数SecTrustRef与源码实现解读" class="headerlink" title="1. 参数SecTrustRef与源码实现解读"></a>1. 参数SecTrustRef与源码实现解读</h4><p>我们接着回到代理https认证的这行代码上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>我们传了两个参数进去，一个是<code>SecTrustRef</code>类型的serverTrust，这是什么呢？我们看到苹果的文档介绍如下：</p><blockquote><p>CFType used for performing X.509 certificate trust evaluations.  </p><p>大概意思是用于执行X.509证书信任评估，再讲简单点，其实就是一个容器，装了服务器端需要验证的证书的基本信息、公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，这个客户端的证书，可以用来和服务端的证书去匹配验证的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Security.framework 源码 https://opensource.apple.com/tarballs/Security/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> &#123;</span></span><br><span class="line">    CFRuntimeBase           _base;</span><br><span class="line">    CFArrayRef              _certificates;  <span class="comment">//证书</span></span><br><span class="line">    CFArrayRef              _anchors; <span class="comment">// 锚点</span></span><br><span class="line">    CFTypeRef               _policies; <span class="comment">// 评估信任的策略</span></span><br><span class="line">    CFArrayRef              _responses;</span><br><span class="line">    CFArrayRef              _SCTs;</span><br><span class="line">    CFArrayRef              _trustedLogs;</span><br><span class="line">    CFDateRef               _verifyDate;</span><br><span class="line"><span class="comment">// 证书链。什么是证书链？百科：证书链由两个环节组成：信任锚（CA证书）环节和已签名证书环节。自我签名的证书仅有一个环节的长度：信任锚环节就是已签名证书本身。简单来说，证书链就是就是根证书，和根据根证书签名派发得到的证书。</span></span><br><span class="line">  CFArrayRef              _chain; </span><br><span class="line">    SecKeyRef               _publicKey;</span><br><span class="line">    CFArrayRef              _details;</span><br><span class="line">    CFDictionaryRef         _info;</span><br><span class="line">    CFArrayRef              _exceptions;</span><br><span class="line"></span><br><span class="line">    SecTrustResultType      _trustResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If true we don&#x27;t trust any anchors other than the ones in _anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _anchorsOnly;</span><br><span class="line">    <span class="comment">/* If false we shouldn&#x27;t search keychains for parents or anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _keychainsAllowed;</span><br><span class="line">    <span class="comment">/* Dispatch queue for thread-safety */</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span>        _trustQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> *<span class="title">SecTrustRef</span>;</span>  <span class="comment">// trust management object(信任管理对象)，包括要验证的证书以及用于评估信任的一个或多个策略</span></span><br></pre></td></tr></table></figure><p>这个方法是<code>AFSecurityPolicy</code>最核心的方法，其他的都是为了配合这个方法。这个方法完成了服务端的证书的信任评估。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 验证服务端是否值得信任</span></span><br><span class="line"><span class="comment"> * serverTrust SecTrustRef </span></span><br><span class="line"><span class="comment"> * domain 服务器域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判断矛盾的条件</span></span><br><span class="line">    <span class="comment">//判断有域名，且允许自建证书，需要验证域名，</span></span><br><span class="line">    <span class="comment">//因为要验证域名，所以必须不能是后者两种：AFSSLPinningModeNone或者添加到项目里的证书为0个。</span></span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;</span>);</span><br><span class="line">        <span class="comment">//不受信任，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 为serverTrust设置验证策略</span></span><br><span class="line"><span class="comment">// 用来装验证策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">//要验证域名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">        <span class="comment">//添加验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要验证domain，就使用默认的BasicX509验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//serverTrust：X.509服务器的证书信任。</span></span><br><span class="line">    <span class="comment">//为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 判断模式，如果是AFSSLPinningModeNone，按照下面的逻辑肯定是返回YES，不论是自签还是公信机构的证书。</span></span><br><span class="line">    <span class="comment">//有验证策略了，可以去验证了。如果是AFSSLPinningModeNone，是自签名，直接返回可信任，否则不是自签名的就去系统根证书里去找是否有匹配的证书。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="comment">//如果支持自签名，直接返回YES，不允许才去判断第二个条件，判断serverTrust是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是AFSSLPinningModeNone，且验证无效AFServerTrustIsValid，而且allowInvalidCertificates不允许自签，返回NO</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SSLPinningMode</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="comment">// 理论上，上面那个部分已经解决了self.SSLPinningMode 为 AFSSLPinningModeNone 等情况，所以此处再遇到，就直接返回NO</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 如果是AFSSLPinningModeCertificate(验证证书类型)，则从serverTrust中去获取证书链，然后和我们一开始初始化设置的证书集合self.pinnedCertificates去匹配，如果有一对能匹配成功的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把证书data，用系统api转成 SecCertificateRef 类型的数据，SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 将pinnedCertificates设置成评估 信任管理对象 时使用的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书）</span></span><br><span class="line">            <span class="comment">//serverTrust是服务器来的验证，有需要被验证的证书。在不调用SecTrustSetAnchorCertificatesOnly()的情况下调用此函数将禁用对锚证书中锚之外的任何锚的信任。</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自签在之前是验证通过不了的，在这一步，把我们自己设置的证书加进去之后，就能验证成功了。</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//在设置锚点证书之后，再调用SecTrustEvaluate来验证一下serverTrust的证书是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#x27;s the Root CA)</span></span><br><span class="line">            <span class="comment">//注意，这个方法和我们之前的锚点证书没关系了，是去从我们需要被验证的服务端证书，去拿证书链。</span></span><br><span class="line">            <span class="comment">//服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//reverseObjectEnumerator逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果我们的证书中，有一个和它证书链中的证书匹配的，就返回YES</span></span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有匹配的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 5. 如果是AFSSLPinningModePublicKey公钥验证，则和第二步一样还是从serverTrust，获取证书链每一个证书的公钥，放到数组中。和我们的self.pinnedPublicKeys，去配对，如果有一个相同的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="comment">//公钥验证 AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历服务端公钥</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//遍历本地公钥</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="comment">//判断如果相同 trustedPublicKeyCount+1</span></span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中关联了一系列的函数，我在这边按照调用顺序一一列出来（有些是系统函数，不在这里列出，会在下文集体描述作用）：</p><h4 id="2-调用函数一-AFServerTrustIsValid"><a href="#2-调用函数一-AFServerTrustIsValid" class="headerlink" title="2. 调用函数一: AFServerTrustIsValid"></a>2. 调用函数一: AFServerTrustIsValid</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断serverTrust是否有效</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认无效</span></span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//用来装验证结果，枚举</span></span><br><span class="line">    SecTrustResultType result;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//__Require_noErr_Quiet 用来判断前者是0还是非0，如果0则表示没错，就跳到后面的表达式所在位置去执行，否则表示有错就继续往下执行。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//SecTrustEvaluate系统评估证书的是否可信的函数，去系统根目录找，然后把结果赋值给result。评估结果匹配，返回0，否则出错返回非0</span></span><br><span class="line">    <span class="comment">//do while 0 ,只执行一次，为啥要这样写....</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评估没出错走掉这，只有两种结果能设置为有效，isValid= 1</span></span><br><span class="line">    <span class="comment">//当result为kSecTrustResultUnspecified（此标志表示serverTrust评估成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书）。</span></span><br><span class="line">    <span class="comment">//或者当result为kSecTrustResultProceed（此标志表示评估成功，和上面不同的是该评估得到了用户认可），这两者取其一就可以认为对serverTrust评估成功</span></span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out函数块,如果为SecTrustEvaluate，返回非0，则评估出错，则isValid为NO</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来验证serverTrust是否有效，其中主要是交由系统API<code>SecTrustEvaluate</code>来验证的，它验证完之后会返回一个<code>SecTrustResultType</code>枚举类型的result，然后我们根据这个result去判断是否证书是否有效。</p><p>其中比较有意思的是，它调用了一个系统定义的宏函数<code>__Require_noErr_Quiet</code>，函数定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __Require_noErr_Quiet</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">      <span class="keyword">do</span>                                                                          \</span><br><span class="line">      &#123;                                                                           \</span><br><span class="line">          <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            \</span><br><span class="line">          &#123;                                                                       \</span><br><span class="line">              <span class="keyword">goto</span> exceptionLabel;                                                \</span><br><span class="line">          &#125;                                                                       \</span><br><span class="line">      &#125; <span class="keyword">while</span> ( <span class="number">0</span> ) <span class="comment">// 在Linux内核和其它一些著名的C库中都会有许多使用do&#123;...&#125;while(0)的宏定义。作用：使用do&#123;...&#125;while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数主要作用就是，判断errorCode是否为0，不为0则，程序用<code>goto</code>跳到<code>exceptionLabel</code>位置去执行。这个<code>exceptionLabel</code>就是一个代码位置标识，类似上面的<code>_out</code>。</p><h4 id="3-调用函数二、三获取证书链证书-公钥"><a href="#3-调用函数二、三获取证书链证书-公钥" class="headerlink" title="3. 调用函数二、三获取证书链证书/公钥"></a>3. 调用函数二、三获取证书链证书/公钥</h4><p>函数二、三（两个函数类似，所以放在一起）：获取serverTrust证书链证书，获取serverTrust证书链公钥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取证书链</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//使用SecTrustGetCertificateCount函数获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。</span></span><br><span class="line">    <span class="comment">//安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//遍历serverTrust里证书的证书链。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        <span class="comment">//从证书链取证书</span></span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="comment">//CF数组</span></span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据给定的certificates和policy来生成一个trust对象</span></span><br><span class="line">        <span class="comment">//不成功跳到 _out。</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用SecTrustEvaluate来评估上面构建的trust</span></span><br><span class="line">        <span class="comment">//评估失败跳到 _out</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的一组公钥</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法功能类似，都是调用了一些系统的API，利用For循环，获取证书链上每一个证书或者公钥。具体内容看源码很好理解。唯一需要注意的是，这个获取的证书排序，是从证书链的叶节点，到根节点的。</p><h4 id="4-调用函数四-判断公钥是否相同"><a href="#4-调用函数四-判断公钥是否相同" class="headerlink" title="4. 调用函数四: 判断公钥是否相同"></a>4. 调用函数四: 判断公钥是否相同</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个公钥是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">AFSecKeyIsEqualToKey</span><span class="params">(SecKeyRef key1, SecKeyRef key2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">    <span class="comment">//iOS 判断二者地址</span></span><br><span class="line">    <span class="keyword">return</span> [(__bridge id)key1 isEqual:(__bridge id)key2];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AFSecKeyGetData</span>(key1) isEqual:<span class="built_in">AFSecKeyGetData</span>(key2)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法适配了各种运行环境，做了匹配的判断。</p><h4 id="5-验证过程中调用的系统原生函数"><a href="#5-验证过程中调用的系统原生函数" class="headerlink" title="5. 验证过程中调用的系统原生函数"></a>5. 验证过程中调用的系统原生函数</h4><p>接下来列出验证过程中调用过得系统原生函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个验证SSL的策略，两个参数，第一个参数true则表示验证整个证书链</span></span><br><span class="line"><span class="comment">//第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">SecPolicyCreateSSL(&lt;#Boolean server#&gt;, &lt;#CFStringRef  _Nullable hostname#&gt;)</span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.默认的BasicX509验证策略,不验证域名。</span></span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">SecTrustSetPolicies(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#CFTypeRef  _Nonnull policies#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.验证serverTrust,并且把验证结果返回给第二参数 result</span></span><br><span class="line">SecTrustEvaluate(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#SecTrustResultType * _Nullable result#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判断前者errorCode是否为0，为0则跳到exceptionLabel处执行代码</span></span><br><span class="line">__Require_noErr(&lt;#errorCode#&gt;, &lt;#exceptionLabel#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.根据证书data,去创建SecCertificateRef类型的数据。</span></span><br><span class="line">SecCertificateCreateWithData(&lt;#CFAllocatorRef  _Nullable allocator#&gt;, &lt;#CFDataRef  _Nonnull data#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.给serverTrust设置锚点证书，即如果以后再次去验证serverTrust，会从锚点证书去找是否匹配。</span></span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.拿到证书链中的证书个数</span></span><br><span class="line">CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="function">CFIndex <span class="title">SecTrustGetCertificateCount</span><span class="params">(SecTrustRef trust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    __block CFIndex certCount = <span class="number">1</span>;</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            certCount = CFArrayGetCount(trust-&gt;_chain);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> certCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.去取得证书链中对应下标的证书。</span></span><br><span class="line">SecTrustGetCertificateAtIndex(serverTrust, i)</span><br><span class="line">  </span><br><span class="line"><span class="function">SecCertificateRef <span class="title">SecTrustGetCertificateAtIndex</span><span class="params">(SecTrustRef trust,</span></span></span><br><span class="line"><span class="function"><span class="params">    CFIndex ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block SecCertificateRef cert = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == <span class="number">0</span>) &#123;</span><br><span class="line">        dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_certificates, <span class="number">0</span>);  <span class="comment">// SecTrustRef成员_certificates</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cert;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_chain, ix);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.根据证书获取公钥。</span></span><br><span class="line">SecTrustCopyPublicKey(trust)</span><br></pre></td></tr></table></figure><p>其功能如注释，大家可以对比着源码，去加以理解~</p><h2 id="4-3-关于HTTPS-开发者需要做什么"><a href="#4-3-关于HTTPS-开发者需要做什么" class="headerlink" title="4.3 关于HTTPS, 开发者需要做什么"></a>4.3 关于HTTPS, 开发者需要做什么</h2><p>可能看到这，又有些小伙伴迷糊了，讲了这么多，<strong>那如果做https请求，真正需要我们自己做的到底是什么呢？</strong></p><h3 id="4-3-1-如果只想访问能通"><a href="#4-3-1-如果只想访问能通" class="headerlink" title="4.3.1 如果只想访问能通"></a>4.3.1 如果只想访问能通</h3><p>分为以下两种情况：</p><ol><li>如果你用的是付费的公信机构颁发的证书，标准的https，<strong>那么无论你用的是AF还是NSUrlSession,什么都不用做，代理方法也不用实现。</strong>你的网络请求就能正常完成。</li><li>如果你用的是自签名的证书:</li></ol><ul><li>首先你需要在plist文件中，设置可以返回不安全的请求（关闭该域名的ATS）。</li><li>其次，如果是<code>NSUrlSesion</code>，那么需要在代理方法实现如下（其实就是AF的相对于自签证书的实现的简化版）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust]; </span><br><span class="line">    <span class="comment">// 确定挑战的方式</span></span><br><span class="line">    <span class="keyword">if</span> (credential) &#123; </span><br><span class="line">    <span class="comment">//证书挑战 则跑到这里</span></span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">       completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是AF，你则需要设置policy：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许自签名证书，必须的</span></span><br><span class="line">policy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//是否验证域名的CN字段</span></span><br><span class="line"><span class="comment">//不是必须的，但是如果写YES，则必须导入证书。</span></span><br><span class="line">policy.validatesDomainName = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-如果想验证服务器来源"><a href="#4-3-2-如果想验证服务器来源" class="headerlink" title="4.3.2 如果想验证服务器来源"></a>4.3.2 如果想验证服务器来源</h3><p>当然还可以根据需求，你可以去验证证书或者公钥，这一步的目的是实现：要求数据必须来自指定的服务器。</p><ul><li>如果是自签证书，需要把自签的服务端证书，或者自签的CA根证书导入到项目中。</li><li>如果是付费的公信机构颁发的证书，那也要把证书导入到项目中。</li></ul><img src="/images/AFN/AFN-07.jpg" alt="img" style="zoom:83%;" /><p>并且如下设置证书：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *certFilePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;AFUse_server.cer&quot;</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:certFilePath];</span><br><span class="line"><span class="built_in">NSSet</span> *certSet = [<span class="built_in">NSSet</span> setWithObjects:certData,certData, <span class="literal">nil</span>]; </span><br><span class="line">policy.pinnedCertificates = certSet;</span><br></pre></td></tr></table></figure><p>这样你就可以使用AF的不同<code>AFSSLPinningMode</code>去验证了。</p><p>这一步实现了防中间人攻击劫持，比如如果用 Charles 代理抓包，那么客户端中的请求 https 认证是无法通过的，<font color='red'><strong>报错：已取消。</strong></font>（一般AF中证书错误的code码是 -999，报错信息是已取消）。</p><h2 id="4-4-总结-AF之于https到底做了什么"><a href="#4-4-总结-AF之于https到底做了什么" class="headerlink" title="4.4 总结: AF之于https到底做了什么"></a>4.4 总结: AF之于https到底做了什么</h2><p>最后总结一下，AF之于https到底做了什么：</p><ul><li><strong>AF可以让你在系统验证证书之前，就去自主验证。</strong>然后如果自己验证不正确，直接取消网络请求。否则验证通过则继续进行系统验证。</li><li>讲到这，顺便提一下，系统验证的流程：首先是去系统的根证书找，看是否有能匹配服务端的证书，如果匹配，则验证成功，返回https的安全数据。</li><li>如果不匹配则去判断ATS是否关闭，如果关闭，则返回https不安全连接的数据。如果开启ATS，则拒绝这个请求，请求失败。</li></ul><p>总之一句话：<strong>AF的验证方式不是必须的，但是对有特殊验证需求的用户确是必要的</strong>。</p><p>写在结尾：</p><ul><li>看完之后，有些小伙伴可能还是会比较迷惑，建议还是不清楚的小伙伴，可以自己生成一个自签名的证书或者用百度地址等做请求，然后设置<code>AFSecurityPolicy</code>不同参数，打断点，一步步的看AF是如何去调用函数作证书验证的。相信这样能加深你的理解。</li><li>最后关于自签名证书的问题，等2017年1月1日，也没多久了…一个月不到。除非有特殊原因说明，否则已经无法审核通过了。详细的可以看看这篇文章：<a href="https://www.jianshu.com/p/36ddc5b009a7">iOS 10 适配 ATS（app支持https通过App Store审核）</a>。</li><li>苹果官网最新消息：原定于2017.1.1强制的https被延期了，具体延期到什么时候不确定，得等官方通知：</li></ul><h1 id="五、UIKit扩展与缓存实现"><a href="#五、UIKit扩展与缓存实现" class="headerlink" title="五、UIKit扩展与缓存实现"></a>五、UIKit扩展与缓存实现</h1><p>我们来看看AF对<code>UIkit</code>的扩展:</p><img src="/images/AFN/AFN-08.jpg" alt="img" style="zoom:67%;" /><p>一共如上这个多类，下面我们开始着重讲其中两个UIKit的扩展：</p><ul><li>一个是我们网络请求时状态栏的小菊花。</li><li>一个是我们几乎都用到过请求网络图片的如下一行方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url ;</span><br></pre></td></tr></table></figure><h2 id="5-1-AFNetworkActivityIndicatorManager"><a href="#5-1-AFNetworkActivityIndicatorManager" class="headerlink" title="5.1 AFNetworkActivityIndicatorManager"></a>5.1 AFNetworkActivityIndicatorManager</h2><p>这个类的作用相当简单，就是当网络请求的时候，状态栏上的小菊花就会开始转:</p><img src="/images/AFN/AFN-09.jpg" alt="img" style="zoom:100%;" /><p>需要的代码也很简单，只需在你需要它的位置中（比如AppDelegate）导入类，并加一行代码即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;AFNetworkActivityIndicatorManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>接下来我们来讲讲这个类的实现：</p><ul><li>这个类的实现也非常简单，还记得我们之前讲的AF对<code>NSURLSessionTask</code>中做了一个<strong>Method Swizzling</strong>吗？大意是把它的<code>resume</code>和<code>suspend</code>方法做了一个替换，在原有实现的基础上添加了一个通知的发送。</li><li>这个类就是基于这两个通知和task完成的通知来实现的。</li></ul><h3 id="5-1-1-初始化方法"><a href="#5-1-1-初始化方法" class="headerlink" title="5.1.1 初始化方法"></a>5.1.1 初始化方法</h3><p>首先我们来看看它的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkActivityManagerState) &#123;</span><br><span class="line">    <span class="comment">//没有请求</span></span><br><span class="line">    AFNetworkActivityManagerStateNotActive,</span><br><span class="line">    <span class="comment">//请求延迟开始</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingStart,</span><br><span class="line">    <span class="comment">//请求进行中</span></span><br><span class="line">    AFNetworkActivityManagerStateActive,</span><br><span class="line">    <span class="comment">//请求延迟结束</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingEnd</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* state一共如上4种状态，其中两种应该很好理解，而延迟开始和延迟结束怎么理解呢？</span></span><br><span class="line"><span class="comment">- 原来这是AF对请求菊花显示做的一个优化处理，试问如果一个请求时间很短，那么菊花很可能闪一下就结束了。如果很多请求过来，那么菊花会不停的闪啊闪，这显然并不是我们想要的效果。</span></span><br><span class="line"><span class="comment">- 所以多了这两个参数：</span></span><br><span class="line"><span class="comment">1）在一个请求开始的时候，我延迟一会在去转菊花，如果在这延迟时间内，请求结束了，那么我就不需要去转菊花了。</span></span><br><span class="line"><span class="comment">  2）但是一旦转菊花开始，哪怕很短请求就结束了，我们还是会去转一个时间再去结束，这时间就是延迟结束的时间。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerActivationDelay = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerCompletionDelay = <span class="number">0.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFNetworkActivityIndicatorManager</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkActivityIndicatorManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _sharedManager = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1. 设置状态为没有request活跃</span></span><br><span class="line">    <span class="keyword">self</span>.currentState = AFNetworkActivityManagerStateNotActive;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 监听了三个通知，用来监听当前正在进行的网络请求的状态。</span></span><br><span class="line">    <span class="comment">//开始下载通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidStart:) name:AFNetworkingTaskDidResumeNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//挂起通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidSuspendNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//完成通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 设置了我们前面提到的这个转菊花延迟开始和延迟结束的时间，</span></span><br><span class="line">    <span class="comment">//开始延迟</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelay = kDefaultAFNetworkActivityManagerActivationDelay;</span><br><span class="line">    <span class="comment">//结束延迟</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelay = kDefaultAFNetworkActivityManagerCompletionDelay;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-通知触发调用的方法"><a href="#5-1-2-通知触发调用的方法" class="headerlink" title="5.1.2 通知触发调用的方法"></a>5.1.2 通知触发调用的方法</h3><p>接着我们来看看三个通知触发调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求开始</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidStart:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//增加请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> incrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidFinish:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//AFNetworkRequestFromNotification(notification)返回这个通知的request,用来判断request是否是有效的</span></span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//减少请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> decrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，就是开始的时候增加了请求活跃数，结束则减少。调用了如下两个方法进行加减：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)incrementActivityCount &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//活跃的网络数+1，并手动发送KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        _activityCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程去做</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)decrementActivityCount &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">        _activityCount = MAX(_activityCount - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法做了什么应该很容易看明白，这里需要注意的是，<strong>task的几个状态的通知，是会在多线程的环境下发送过来的</strong>。所以这里对活跃数的加减，都用了<code>@synchronized</code>这种方式的锁，进行了线程保护。然后回到主线程调用了<code>updateCurrentStateForNetworkActivityChange</code></p><p>我们接着来看看这个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateCurrentStateForNetworkActivityChange &#123;</span><br><span class="line">    <span class="comment">//1. 判断了我们一开始设置是否需要菊花的`self.enabled`，如果需要，才执行。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.enabled) &#123;</span><br><span class="line">        <span class="comment">// 2. 这里主要是根据当前的状态，来判断下一个状态应该是什么。</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.currentState) &#123;</span><br><span class="line">            <span class="comment">//不活跃</span></span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                <span class="comment">//判断活跃数，大于0为YES</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    <span class="comment">//设置状态为延迟开始</span></span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingStart];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                <span class="comment">//No op. Let the delay timer finish out.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingEnd];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有这么一个属性<code>self.isNetworkActivityOccurring</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否活跃</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isNetworkActivityOccurring &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activityCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-重写currentState的setter"><a href="#5-1-3-重写currentState的setter" class="headerlink" title="5.1.3 重写currentState的setter"></a>5.1.3 重写currentState的setter</h3><p>这个类复写了currentState的set方法，每当我们改变这个state，就会触发set方法，而怎么该转菊花也在该方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前小菊花状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setCurrentState:(AFNetworkActivityManagerState)currentState &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != currentState) &#123;</span><br><span class="line">            <span class="comment">//KVO</span></span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">            _currentState = currentState;</span><br><span class="line">            <span class="keyword">switch</span> (currentState) &#123;</span><br><span class="line">                <span class="comment">//如果为不活跃</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                    <span class="comment">//取消两个延迟用的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelActivationDelayTimer];</span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//设置小菊花不可见</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">NO</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                    <span class="comment">//开启一个定时器延迟去转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> startActivationDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果是活跃状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                    <span class="comment">//取消延迟完成的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//开始转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">YES</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//延迟完成状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                    <span class="comment">//开启延迟完成timer</span></span><br><span class="line">                    [<span class="keyword">self</span> startCompletionDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set方法就是这个类最核心的方法了。它的作用如下：</p><ul><li>这里根据当前状态，是否需要开始执行一个延迟开始或者延迟完成，又或者是否需要取消这两个延迟。</li><li>还判断了，是否需要去转状态栏的菊花，调用了<code>setNetworkActivityIndicatorVisible:</code>方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setNetworkActivityIndicatorVisible:(<span class="built_in">BOOL</span>)networkActivityIndicatorVisible &#123;</span><br><span class="line">    <span class="keyword">if</span> (_networkActivityIndicatorVisible != networkActivityIndicatorVisible) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">             _networkActivityIndicatorVisible = networkActivityIndicatorVisible;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//支持自定义的Block，去自己控制小菊花</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityActionBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.networkActivityActionBlock(networkActivityIndicatorVisible);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则默认AF根据该Bool，去控制状态栏小菊花是否显示</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法就是用来控制菊花是否转。并且支持一个自定义的Block,我们可以自己去拿到这个菊花是否应该转的状态值，去做一些自定义的处理。</li><li>如果我们没有实现这个Block，则调用下面的方法去转菊花。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br></pre></td></tr></table></figure><p>回到state的set方法中，我们除了控制菊花去转，还调用了以下4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始任务到结束的时间，默认为1秒，如果1秒就结束，那么不转菊花，延迟去开始转</span></span><br><span class="line">- (<span class="keyword">void</span>)startActivationDelayTimer &#123;</span><br><span class="line">    <span class="comment">//只执行一次</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelayTimer = [<span class="built_in">NSTimer</span></span><br><span class="line">                                 timerWithTimeInterval:<span class="keyword">self</span>.activationDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(activationDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//添加到主线程runloop去触发</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.activationDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成任务到下一个任务开始，默认为0.17秒，如果0.17秒就开始下一个，那么不停  延迟去结束菊花转</span></span><br><span class="line">- (<span class="keyword">void</span>)startCompletionDelayTimer &#123;</span><br><span class="line">    <span class="comment">//先取消之前的</span></span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">    <span class="comment">//延迟执行让菊花不在转</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelayTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.completionDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(completionDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.completionDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelActivationDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.activationDelayTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelCompletionDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这4个方法分别是开始延迟执行一个方法，和结束的时候延迟执行一个方法，和对应这两个方法的取消。其作用，注释应该很容易理解。</p><p>我们继续往下看，这两个延迟调用的到底是什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)activationDelayTimerFired &#123;</span><br><span class="line">    <span class="comment">//活跃状态，即活跃数大于1才转</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityOccurring) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)completionDelayTimerFired &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个开始，一个完成调用，都设置了不同的currentState的值，又回到之前<code>state</code>的<code>set</code>方法中了。</p><p>至此这个<code>AFNetworkActivityIndicatorManager</code>类就讲完了，代码还是相当简单明了的。</p><h2 id="5-2-UIImageView-AFNetworking"><a href="#5-2-UIImageView-AFNetworking" class="headerlink" title="5.2 UIImageView+AFNetworking"></a>5.2 UIImageView+AFNetworking</h2><p>接下来我们来讲一个我们经常用的方法，这个方法的实现类是：<code>UIImageView+AFNetworking.h</code>。</p><p>这是个类目，并且给UIImageView扩展了4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个UIImageView去异步的请求一张图片，并且可以设置一张占位图。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line"> placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一张图，并且可以拿到成功和失败的回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">      placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前的图片设置请求</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask;</span><br></pre></td></tr></table></figure><p><code>SDWebImage</code>、<code>YYKit</code>、<code>AF</code>都实现了这么个类目。AF关于这个类目<code>UIImageView+AFNetworking</code>的实现，<strong>依赖于这么两个类：<code>AFImageDownloader</code>，<code>AFAutoPurgingImageCache</code>。</strong></p><p>当然<code>AFImageDownloader</code>中，关于图片数据请求的部分，还是使用<code>AFURLSessionManager</code>来实现的。</p><h3 id="5-2-1-AFImageDownloader"><a href="#5-2-1-AFImageDownloader" class="headerlink" title="5.2.1 AFImageDownloader"></a>5.2.1 AFImageDownloader</h3><h4 id="1-先看初始化方法"><a href="#1-先看初始化方法" class="headerlink" title="1. 先看初始化方法"></a>1. 先看初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类为单例，上述方法中，创建了一个 sessionManager, 这个 sessionManager 将用于我们之后的网络请求。从这里我们可以看到，这个类的网络请求都是基于之前AF自己封装的 AFHTTPSessionManager。</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> AFImageDownloader *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="comment">// 在这里初始化了一系列的对象</span></span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *defaultConfiguration = [<span class="keyword">self</span>.class defaultURLSessionConfiguration];</span><br><span class="line">    AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:defaultConfiguration];</span><br><span class="line">    sessionManager.responseSerializer = [AFImageResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //这个枚举值代表着，一堆图片下载，执行任务的顺序</span></span><br><span class="line"><span class="comment">      typedef NS_ENUM(NSInteger, AFImageDownloadPrioritization) &#123;</span></span><br><span class="line"><span class="comment">          //先进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationFIFO,</span></span><br><span class="line"><span class="comment">          //后进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationLIFO</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionManager:sessionManager</span><br><span class="line">                 downloadPrioritization:AFImageDownloadPrioritizationFIFO <span class="comment">// </span></span><br><span class="line">                 maximumActiveDownloads:<span class="number">4</span></span><br><span class="line">                             imageCache:[[AFAutoPurgingImageCache alloc] init]]; </span><br><span class="line">  <span class="comment">// AFAutoPurgingImageCache这个类是AF做图片缓存用的。这里我们暂时就这么理解它，讲完当前类，我们再来补充它。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultURLSessionConfiguration &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO set the default HTTP headers</span></span><br><span class="line">  </span><br><span class="line">    configuration.HTTPShouldSetCookies = <span class="literal">YES</span>;</span><br><span class="line">    configuration.HTTPShouldUsePipelining = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    configuration.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</span><br><span class="line">    <span class="comment">//是否允许蜂窝网络，手机网</span></span><br><span class="line">    configuration.allowsCellularAccess = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//默认超时</span></span><br><span class="line">    configuration.timeoutIntervalForRequest = <span class="number">60.0</span>;</span><br><span class="line">    <span class="comment">//设置的图片缓存对象</span></span><br><span class="line">    configuration.URLCache = [AFImageDownloader defaultURLCache];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们看到除了<code>[[AFAutoPurgingImageCache alloc] init]</code>，还创建了一个cache：<code>[AFImageDownloader defaultURLCache]</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个系统缓存，内存缓存为20M，磁盘缓存为150M，</span></span><br><span class="line"><span class="comment">//这个是系统级别维护的缓存。</span></span><br><span class="line"> + (<span class="built_in">NSURLCache</span> *)defaultURLCache &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                         diskCapacity:<span class="number">150</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                             diskPath:<span class="string">@&quot;com.alamofire.imagedownloader&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到这可能迷惑了，怎么这么多cache，那AF做图片缓存到底用哪个呢？答案是AF自己控制的图片缓用 <code>AFAutoPurgingImageCache</code>，而 <code>NSUrlRequest</code> 的缓存由它自己内部根据策略去控制，用的是<code>NSURLCache</code>，不归AF处理，只需在configuration中设置上即可。</p><ul><li>那么看到这有些小伙伴又要问了，为什么不直接用<code>NSURLCache</code>，还要自定义一个<code>AFAutoPurgingImageCache</code>呢？原来是因为<code>NSURLCache</code>的诸多限制，例如只支持get请求等等。而且因为是系统维护的，我们自己的可控度不强，并且如果需要做一些自定义的缓存处理，无法实现。</li><li>更多关于<code>NSURLCache</code>的内容，大家可以自行查阅。</li></ul><p>接着上面的方法调用到这个最终的初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionManager:(AFHTTPSessionManager *)sessionManager</span><br><span class="line">                downloadPrioritization:(AFImageDownloadPrioritization)downloadPrioritization</span><br><span class="line">                maximumActiveDownloads:(<span class="built_in">NSInteger</span>)maximumActiveDownloads</span><br><span class="line">                            imageCache:(<span class="keyword">id</span> &lt;AFImageRequestCache&gt;)imageCache &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">//持有</span></span><br><span class="line">        <span class="keyword">self</span>.sessionManager = sessionManager;</span><br><span class="line">        <span class="comment">//定义下载任务的顺序，默认FIFO，先进先出-队列模式，还有后进先出-栈模式</span></span><br><span class="line">        <span class="keyword">self</span>.downloadPrioritizaton = downloadPrioritization;</span><br><span class="line">        <span class="comment">//最大的下载数</span></span><br><span class="line">        <span class="keyword">self</span>.maximumActiveDownloads = maximumActiveDownloads;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义的cache</span></span><br><span class="line">        <span class="keyword">self</span>.imageCache = imageCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列中的任务，待执行的</span></span><br><span class="line">        <span class="keyword">self</span>.queuedMergedTasks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">//合并的任务，所有任务的字典</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">        <span class="comment">//活跃的request数</span></span><br><span class="line">        <span class="keyword">self</span>.activeRequestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用UUID来拼接名字</span></span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.synchronizationqueue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建一个串行的queue</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.responsequeue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建并行queue</span></span><br><span class="line">        <span class="keyword">self</span>.responseQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边初始化了一些属性，这些属性跟着注释看应该很容易明白其作用。主要需要注意的就是，这里创建了两个queue：<strong>一个串行的请求queue，和一个并行的响应queue。</strong></p><ul><li>这个串行queue,是用来做内部生成task等等一系列业务逻辑的。它保证了我们在这些逻辑处理中的线程安全问题（迷惑的接着往下看）。</li><li>这个并行queue，被用来做网络请求完成的数据回调。</li></ul><h4 id="2-再看创建请求task的方法"><a href="#2-再看创建请求task的方法" class="headerlink" title="2. 再看创建请求task的方法"></a>2. 再看创建请求task的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">        success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">UIImage</span> * ))success</span><br><span class="line">        failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">NSError</span> * ))failure </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> downloadImageForURLRequest:request withReceiptID:[<span class="built_in">NSUUID</span> UUID] </span><br><span class="line">            success:success failure:failure];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                  withReceiptID:(<span class="keyword">nonnull</span> <span class="built_in">NSUUID</span> *)receiptID</span><br><span class="line">        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="comment">//还是类似之前的，同步串行去做下载的事 生成一个task,这些事情都是在当前线程中串行同步做的，所以不用担心线程安全问题。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//url字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</span><br><span class="line">        <span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                <span class="comment">//错误返回，没Url</span></span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    failure(request, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个任务已经存在，则添加成功失败Block,然后直接返回，即一个url用一个request,可以响应好几个block</span></span><br><span class="line">        <span class="comment">//从自己task字典中根据Url去取AFImageDownloaderMergedTask，里面有task id url等等信息</span></span><br><span class="line">        AFImageDownloaderMergedTask *existingMergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        <span class="keyword">if</span> (existingMergedTask != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//里面包含成功和失败Block和UUid</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</span><br><span class="line">            <span class="comment">//添加handler</span></span><br><span class="line">            [existingMergedTask addResponseHandler:handler];</span><br><span class="line">            <span class="comment">//给task赋值</span></span><br><span class="line">            task = existingMergedTask.task;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据request的缓存策略，加载缓存</span></span><br><span class="line">        <span class="keyword">switch</span> (request.cachePolicy) &#123;</span><br><span class="line">            <span class="comment">//这3种情况都会去加载缓存</span></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</span><br><span class="line">                <span class="comment">//从cache中根据request拿数据</span></span><br><span class="line">                <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(request, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这说明即没有请求中的request,也没有cache,开始请求</span></span><br><span class="line">        <span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        <span class="comment">//task</span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *createdTask;</span><br><span class="line">        __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用sessionManager的去请求，注意，只是创建task,还是挂起状态</span></span><br><span class="line">        createdTask = [<span class="keyword">self</span>.sessionManager</span><br><span class="line">                       dataTaskWithRequest:request</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">//在responseQueue中回调数据,初始化为并行queue</span></span><br><span class="line">                           <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.responseQueue, ^&#123;</span><br><span class="line">                               __<span class="keyword">strong</span> __typeof__(weakSelf) strongSelf = weakSelf;</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//拿到当前的task</span></span><br><span class="line">                               AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//如果之前的task数组中，有这个请求的任务task，则从数组中移除</span></span><br><span class="line">                               <span class="keyword">if</span> ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</span><br><span class="line">                                   <span class="comment">//安全的移除，并返回当前被移除的AF task</span></span><br><span class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">                                   <span class="comment">//请求错误</span></span><br><span class="line">                                   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                       <span class="comment">//去遍历task所有响应的处理</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="comment">//主线程，调用失败的Block</span></span><br><span class="line">                                           <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.failureBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, error);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                       <span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                                       <span class="comment">//调用成功Block</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="keyword">if</span> (handler.successBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.successBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, responseObject);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                       </span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">//减少活跃的任务数</span></span><br><span class="line">                               [strongSelf safelyDecrementActiveTaskCount];</span><br><span class="line">                               [strongSelf safelyStartNextTaskIfNecessary];</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) Store the response handler for use when the request completes</span></span><br><span class="line">        <span class="comment">//创建handler</span></span><br><span class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</span><br><span class="line">                                                                                                   success:success</span><br><span class="line">                                                                                                   failure:failure];</span><br><span class="line">        <span class="comment">//创建task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</span><br><span class="line">                                                   initWithURLIdentifier:URLIdentifier</span><br><span class="line">                                                   identifier:mergedTaskIdentifier</span><br><span class="line">                                                   task:createdTask];</span><br><span class="line">        <span class="comment">//添加handler</span></span><br><span class="line">        [mergedTask addResponseHandler:handler];</span><br><span class="line">        <span class="comment">//往当前任务字典里添加任务</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) Either start the request or enqueue it depending on the current active request count</span></span><br><span class="line">        <span class="comment">//如果小于，则开始任务下载resume</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到最终生成的task</span></span><br><span class="line">        task = mergedTask.task;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        <span class="comment">//创建一个AFImageDownloadReceipt并返回，里面就多一个receiptID。</span></span><br><span class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么一个非常非常长的方法，这个方法执行的内容都是在我们之前创建的串行queue中，同步的执行的，这是因为这个方法绝大多数的操作都是需要线程安全的。可以对着源码和注释来看，我们在这讲下它做了什么：</p><h5 id="1-判断url是否为空"><a href="#1-判断url是否为空" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>首先做了一个url的判断，如果为空则返回失败Block。</p><h5 id="2-判断是否是已生成task"><a href="#2-判断是否是已生成task" class="headerlink" title="2) 判断是否是已生成task"></a>2) 判断是否是已生成task</h5><p>判断这个需要请求的url，是不是已经被生成的task中，如果是的话，则多添加一个回调处理就可以。</p><h5 id="2-1-AFImageDownloaderResponseHandler"><a href="#2-1-AFImageDownloaderResponseHandler" class="headerlink" title="2-1) AFImageDownloaderResponseHandler"></a>2-1) AFImageDownloaderResponseHandler</h5><p>回调处理对象为<code>AFImageDownloaderResponseHandler</code>。这个类非常简单，总共就如下3个属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderResponseHandler</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderResponseHandler</span></span></span><br><span class="line"><span class="comment">//初始化回调对象</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithUUID:(<span class="built_in">NSUUID</span> *)uuid</span><br><span class="line">                     success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">                     failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.uuid = uuid;</span><br><span class="line">        <span class="keyword">self</span>.successBlock = success;</span><br><span class="line">        <span class="keyword">self</span>.failureBlock = failure;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个task完成的时候，会调用我们添加的回调。</p><h5 id="2-2-AFImageDownloaderMergedTask"><a href="#2-2-AFImageDownloaderMergedTask" class="headerlink" title="2-2) AFImageDownloaderMergedTask"></a>2-2) AFImageDownloaderMergedTask</h5><p>关于<code>AFImageDownloaderMergedTask</code>，我们在这里都用的是这种类型的task，其实这个task也很简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderMergedTask</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;AFImageDownloaderResponseHandler*&gt; *responseHandlers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderMergedTask</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier identifier:(<span class="built_in">NSUUID</span> *)identifier task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URLIdentifier = URLIdentifier;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line">        <span class="keyword">self</span>.responseHandlers = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)addResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers addObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)removeResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers removeObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>其实就是除了<code>NSURLSessionDataTask</code>，多加了几个参数，<code>URLIdentifier</code>和<code>identifier</code>都是用来标识这个task的，responseHandlers是用来存储task完成后的回调的，里面可以存一组，当任务完成时候，里面的回调都会被调用。</p><h5 id="3-判断缓存是否存在"><a href="#3-判断缓存是否存在" class="headerlink" title="3. 判断缓存是否存在"></a>3. 判断缓存是否存在</h5><p>接着去根据缓存策略，去加载缓存，如果有缓存，从<code>self.imageCache</code>中返回缓存，否则继续往下走。</p><h5 id="4-创建NSURLSessionDataTask并设置完成回调"><a href="#4-创建NSURLSessionDataTask并设置完成回调" class="headerlink" title="4. 创建NSURLSessionDataTask并设置完成回调"></a>4. 创建NSURLSessionDataTask并设置完成回调</h5><p>走到这说明没相同url的task，也没有cache，那么就开始一个新的task，调用的是<code>AFUrlSessionManager</code>里的请求方法生成了一个task（前面已经说过，不赘述）。</p><p>同时做了请求完成的处理。注意，这里处理是在我们一开始初始化的并行queue:<code>self.responseQueue</code>中的，这里的响应处理是多线程并发进行的。</p><p>完成后：</p><ol><li>调用如下方法把这个task从全局字典中移除：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除task相关，用同步串行的形式，防止移除中出现重复移除一系列问题</span></span><br><span class="line">- (AFImageDownloaderMergedTask*)safelyRemoveMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    __block AFImageDownloaderMergedTask *mergedTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        mergedTask = [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据task的成功或失败情况，去循环这个task的<code>responseHandlers</code>，分别调用它的成功或者失败的回调。</li><li>如果成功，把成功请求到的数据，加到AF自定义的cache中：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">[<span class="meta">strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil</span>];</span><br></pre></td></tr></table></figure><ol start="4"><li>并且调用下面两个方法，去减少正在请求的任务数，和开启下一个任务：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//减少活跃的任务数</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</span><br><span class="line">    <span class="comment">//回到串行queue去-</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果可以，则开启下一个任务</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyStartNextTaskIfNecessary &#123;</span><br><span class="line">    <span class="comment">//回到串行queue</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//先判断并行数限制</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">self</span>.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取数组中第一个task</span></span><br><span class="line">                AFImageDownloaderMergedTask *mergedTask = [<span class="keyword">self</span> dequeueMergedTask];</span><br><span class="line">                <span class="comment">//如果状态是挂起状态</span></span><br><span class="line">                <span class="keyword">if</span> (mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，跟我们本类的一些数据相关的操作，<strong>都是在我们一开始的串行queue中同步进行的。</strong></p><h5 id="5-创建ResponseHandler和MergedTask"><a href="#5-创建ResponseHandler和MergedTask" class="headerlink" title="5. 创建ResponseHandler和MergedTask"></a>5. 创建ResponseHandler和MergedTask</h5><p>用<code>NSUUID</code>生成的唯一标识，去生成<code>AFImageDownloaderResponseHandler</code>，然后生成一个<code>AFImageDownloaderMergedTask</code>，把之前第5步生成的<code>createdTask</code>和回调都绑定给这个AF自定义可合并回调的task，然后这个task加到全局的task映射字典中，key为url:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br></pre></td></tr></table></figure><h5 id="6-判断当前并行数是否超限"><a href="#6-判断当前并行数是否超限" class="headerlink" title="6. 判断当前并行数是否超限"></a>6. 判断当前并行数是否超限</h5><p>判断当前正在下载的任务是否超过最大并行数，如果没有则开始下载，否则先加到等待的数组中去:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果小于最大并行数，则开始任务下载resume</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断并行数限制</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isActiveRequestCountBelowMaximumLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeRequestCount &lt; <span class="keyword">self</span>.maximumActiveDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载</span></span><br><span class="line"> - (<span class="keyword">void</span>)startMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    [mergedTask.task resume];</span><br><span class="line">    <span class="comment">//任务活跃数+1</span></span><br><span class="line">    ++<span class="keyword">self</span>.activeRequestCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把任务先加到数组里</span></span><br><span class="line"> - (<span class="keyword">void</span>)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.downloadPrioritizaton) &#123;</span><br><span class="line">            <span class="comment">//先进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationFIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks addObject:mergedTask];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//后进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationLIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks insertObject:mergedTask atIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断并行数限制，如果小于最大限制，则开始下载，把当前活跃的request数量+1。</li><li>如果暂时不能下载，被加到等待下载的数组中去的话，会根据我们一开始设置的下载策略，是先进先出，还是后进先出，去插入这个下载任务。</li></ul><h5 id="7-创建AFImageDownloadReceipt"><a href="#7-创建AFImageDownloadReceipt" class="headerlink" title="7. 创建AFImageDownloadReceipt"></a>7. 创建AFImageDownloadReceipt</h5><p>最后判断这个mergeTask是否为空。不为空，我们生成了一个<code>AFImageDownloadReceipt</code>，绑定了一个UUID，否则为空返回nil。这个<code>AFImageDownloadReceipt</code>仅仅是多封装了一个UUID:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloadReceipt</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloadReceipt</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithReceiptID:(<span class="built_in">NSUUID</span> *)receiptID task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.receiptID = receiptID;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么封装是为了标识每一个task，我们后面可以根据这个<code>AFImageDownloadReceipt</code>来对task做取消操作。</p><h4 id="3-取消task"><a href="#3-取消task" class="headerlink" title="3. 取消task"></a>3. 取消task</h4><p>这个<code>AFImageDownloader</code>中最核心的方法基本就讲完了，还剩下一些方法没讲，像前面讲到的task的取消的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据AFImageDownloadReceipt来取消任务，即对应一个响应回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//拿到url</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</span><br><span class="line">        <span class="comment">//根据url拿到task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快速遍历查找某个下标，如果返回YES，则index为当前下标</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> index = [mergedTask.responseHandlers indexOfObjectPassingTest:^<span class="built_in">BOOL</span>(AFImageDownloaderResponseHandler * _Nonnull handler, __unused <span class="built_in">NSUInteger</span> idx, __unused <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> handler.uuid == imageDownloadReceipt.receiptID;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">//移除响应处理</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</span><br><span class="line">            [mergedTask removeResponseHandler:handler];</span><br><span class="line">            <span class="built_in">NSString</span> *failureReason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ImageDownloader cancelled URL request: %@&quot;</span>,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>:failureReason&#125;;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorCancelled</span> userInfo:userInfo];</span><br><span class="line">            <span class="comment">//并调用失败block，原因为取消</span></span><br><span class="line">            <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果任务里的响应回调为空或者状态为挂起，则取消task,并且从字典中移除</span></span><br><span class="line">        <span class="keyword">if</span> (mergedTask.responseHandlers.count == <span class="number">0</span> &amp;&amp; mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">            [mergedTask.task cancel];</span><br><span class="line">            [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据URLIdentifier移除task</span></span><br><span class="line">- (AFImageDownloaderMergedTask *)removeMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">    [<span class="keyword">self</span>.mergedTasks removeObjectForKey:URLIdentifier];</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法比较简单，大家自己看看就好。至此```AFImageDownloader``这个类讲完了。如果大家看的感觉比较绕，没关系，等到最后我们一起来总结一下，捋一捋。</p><h3 id="5-2-2-AFAutoPurgingImageCache"><a href="#5-2-2-AFAutoPurgingImageCache" class="headerlink" title="5.2.2 AFAutoPurgingImageCache"></a>5.2.2 AFAutoPurgingImageCache</h3><p>我们之前讲到<code>AFAutoPurgingImageCache</code>这个类略过去了，现在我们就来补充一下这个类的相关内容：</p><p>首先来讲讲这个类的作用，它是AF自定义用来做图片缓存的。</p><h4 id="1-下文要用到的AFCachedImage"><a href="#1-下文要用到的AFCachedImage" class="headerlink" title="1. 下文要用到的AFCachedImage"></a>1. 下文要用到的AFCachedImage</h4><p>关于这个<code>AFCachedImage</code>，其实就是Image之外封装了几个关于这个缓存的参数，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFCachedImage</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;  <span class="comment">//url标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;   <span class="comment">//总大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;  <span class="comment">//上次获取时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage; <span class="comment">//这个参数没被用到过</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFCachedImage</span></span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"> -(<span class="keyword">instancetype</span>)initWithImage:(<span class="built_in">UIImage</span> *)image identifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = image;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerPixel = <span class="number">4.0</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        <span class="keyword">self</span>.totalBytes = (<span class="built_in">UInt64</span>)bytesPerPixel * (<span class="built_in">UInt64</span>)bytesPerSize;</span><br><span class="line">        <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次获取缓存的时间</span></span><br><span class="line"> - (<span class="built_in">UIImage</span>*)accessImage &#123;</span><br><span class="line">    <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2. 初始化方法"></a>2. 初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//默认为内存100M，后者为缓存溢出后保留的内存</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithMemoryCapacity:<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span> preferredMemoryCapacity:<span class="number">60</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMemoryCapacity:(<span class="built_in">UInt64</span>)memoryCapacity preferredMemoryCapacity:(<span class="built_in">UInt64</span>)preferredMemoryCapacity &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//1. 声明了一个默认的内存缓存大小100M，还有一个意思是如果超出100M之后，我们去清除缓存，此时仍要保留的缓存大小60M。（如果还是不理解，可以看后文，源码中会讲到）</span></span><br><span class="line">        <span class="keyword">self</span>.memoryCapacity = memoryCapacity;</span><br><span class="line">        <span class="keyword">self</span>.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 创建了一个cache字典，我们所有的缓存数据，都被保存在这个字典中，key为url，value为`AFCachedImage`。</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.autopurgingimagecache-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 创建了一个并行queue，这个并行queue，这个类除了初始化以外，所有的方法都是在这个并行queue中调用的。</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//4. 添加了一个通知，监听内存警告，当发生内存警告，调用该方法，移除所有的缓存，并且把当前缓存数置为0：</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">         addObserver:<span class="keyword">self</span></span><br><span class="line">         selector:<span class="keyword">@selector</span>(removeAllImages)</span><br><span class="line">         name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">         object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有图片</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)removeAllImages &#123;</span><br><span class="line">    __block <span class="built_in">BOOL</span> removed = <span class="literal">NO</span>;</span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cachedImages.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cachedImages removeAllObjects];</span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage = <span class="number">0</span>;</span><br><span class="line">            removed = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类大量的使用了<code>dispatch_barrier_sync</code>与<code>dispatch_barrier_async</code>，小伙伴们如果对这两个方法有任何疑惑，可以看看这篇文章：<a href="http://blog.csdn.net/u013046795/article/details/47057585">dispatch_barrier_async与dispatch_barrier_sync异同</a>。</p><ul><li><p>这里我们可以看到使用了<code>dispatch_barrier_sync</code>，这里没有用锁，但是因为使用了<code>dispatch_barrier_sync</code>，不仅同步了<code>synchronizationQueue</code>队列，而且阻塞了当前线程，所以保证了里面执行代码的线程安全问题。</p></li><li><p>在这里其实使用锁也可以，但是AF在这的处理却是使用同步的机制来保证线程安全，<strong>或许这跟图片的加载缓存的使用场景，高频次有关系</strong>，在这里使用sync，并不需要在去开辟新的线程，浪费性能，只需要在原有线程，提交到<code>synchronizationQueue</code>队列中，阻塞的执行即可。这样省去大量的开辟线程与使用锁带来的性能消耗。（当然这仅仅是我的一个猜测，有不同意见的朋友欢迎讨论~）</p><ul><li>在这里用了<code>dispatch_barrier_sync</code>，因为<code>synchronizationQueue</code>是个并行queue，所以在这里不会出现死锁的问题。</li><li>关于保证线程安全的同时，同步还是异步，与性能方面的考量，可以参考这篇文章：<a href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a>。</li></ul></li></ul><h4 id="3-核心方法addImage"><a href="#3-核心方法addImage" class="headerlink" title="3. 核心方法addImage:"></a>3. 核心方法addImage:</h4><p>接着我们来看看这个类最核心的一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加image到cache里</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image withIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用dispatch_barrier_async，来同步这个并行队列</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//生成cache对象</span></span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去之前cache的字典里取</span></span><br><span class="line">        AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//如果有被缓存过</span></span><br><span class="line">        <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//当前已经使用的内存大小减去图片的大小</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新cache的image加上去</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</span><br><span class="line">        <span class="comment">//加上内存大小</span></span><br><span class="line">        <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做缓存溢出的清除，清除的是早期的缓存</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//如果使用的内存大于我们设置的内存容量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</span><br><span class="line">            <span class="comment">//拿到使用内存 - 被清空后首选内存 =  需要被清除的内存</span></span><br><span class="line">            <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</span><br><span class="line">            <span class="comment">//拿到所有缓存的数据</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据lastAccessDate排序 升序，越晚的越后面</span></span><br><span class="line">            <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@&quot;lastAccessDate&quot;</span></span><br><span class="line">                                                                           ascending:<span class="literal">YES</span>];</span><br><span class="line">            </span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//移除早期的cache bytesToPurge大小</span></span><br><span class="line">            <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减去被清掉的内存</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释应该很容易明白，这个方法做了两件事：</p><ol><li>设置缓存到字典里，并且把对应的缓存大小设置到当前已缓存的数量属性中。</li><li>判断是缓存超出了我们设置的最大缓存100M，如果是的话，则清除掉部分早时间的缓存，清除到缓存小于我们溢出后保留的内存60M以内。</li></ol><p>当然在这里更需要说一说的是<code>dispatch_barrier_async</code>，这里整个类都没有使用<code>dispatch_async</code>，所以不存在是为了做一个栅栏，来同步上下文的线程。其实它在本类中的作用很简单，就是一个串行执行。</p><ul><li>讲到这，小伙伴们又疑惑了，既然就是只是为了串行，那为什么我们不用一个串行queue就得了？非得用<code>dispatch_barrier_async</code>干嘛？其实小伙伴要是看的仔细，就明白了，上文我们说过，我们要用<code>dispatch_barrier_sync</code>来保证线程安全。<strong>如果我们使用串行queue,那么线程是极其容易死锁的。</strong></li></ul><h4 id="4-其他几个方法"><a href="#4-其他几个方法" class="headerlink" title="4. 其他几个方法"></a>4. 其他几个方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id获取图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//用同步的方式获取，防止线程安全问题</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//并且刷新获取的时间</span></span><br><span class="line">        image = [cachedImage accessImage];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier添加cache</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image forRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    [<span class="keyword">self</span> addImage:image withIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier移除图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeImageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> removeImageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据request和additionalIdentifier获取图片</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> imageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成id的方式为Url字符串+additionalIdentifier</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</span><br><span class="line">    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>) &#123;</span><br><span class="line">        key = [key stringByAppendingString:additionalIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法都很简单，大家自己看看就好了，就不赘述了。至此<code>AFAutoPurgingImageCache</code>也讲完了，我们还是等到最后再来总结。</p><h3 id="5-2-3-UIImageView-AFNetworking"><a href="#5-2-3-UIImageView-AFNetworking" class="headerlink" title="5.2.3 UIImageView+AFNetworking"></a>5.2.3 UIImageView+AFNetworking</h3><p>我们绕了一大圈，总算回到了<code>UIImageView+AFNetworking</code>这个类，现在图片下载的方法，和缓存的方法都有了，实现这个类也是水到渠成的事了。</p><h4 id="1-setImageWithURL"><a href="#1-setImageWithURL" class="headerlink" title="1. setImageWithURL:"></a>1. setImageWithURL:</h4><p>我们来看下面我们绝大多数人很熟悉的方法，看看它的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> setImageWithURL:url placeholderImage:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">       placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置head，可接受类型为image</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    [request addValue:<span class="string">@&quot;image/*&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Accept&quot;</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setImageWithURLRequest:request placeholderImage:placeholderImage success:<span class="literal">nil</span> failure:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法按顺序往下调用，第二个方法给head的Accept类型设置为Image。接着调用到第三个方法，也是这个类目唯一一个重要的方法：</p><h4 id="2-setImageWithURLRequest"><a href="#2-setImageWithURLRequest" class="headerlink" title="2. setImageWithURLRequest:"></a>2. setImageWithURLRequest:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">              placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//url为空，则取消</span></span><br><span class="line">    <span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消task</span></span><br><span class="line">        [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line">        <span class="comment">//设置为占位图</span></span><br><span class="line">        <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看设置的当前的回调的request和需要请求的request是不是为同一个，是的话为重复调用，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveTaskURLEqualToURLRequest:urlRequest])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始请求前，先取消之前的task,即解绑回调</span></span><br><span class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到downloader</span></span><br><span class="line">    AFImageDownloader *downloader = [[<span class="keyword">self</span> <span class="keyword">class</span>] sharedImageDownloader];</span><br><span class="line">    <span class="comment">//拿到cache</span></span><br><span class="line">    <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Use the image from the image cache if it exists</span></span><br><span class="line">    <span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//去获取cachedImage</span></span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//有的话直接设置，并且置空回调</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = cachedImage;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无缓存，如果有占位图，先设置</span></span><br><span class="line">        <span class="keyword">if</span> (placeholderImage) &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        AFImageDownloadReceipt *receipt;</span><br><span class="line">        <span class="comment">//去下载，并得到一个receipt，可以用来取消回调</span></span><br><span class="line">        receipt = [downloader</span><br><span class="line">                   downloadImageForURLRequest:urlRequest</span><br><span class="line">                   withReceiptID:downloadID</span><br><span class="line">                   success:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> * _Nonnull responseObject) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//判断receiptID和downloadID是否相同 成功回调，设置图片</span></span><br><span class="line">                       <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                               success(request, response, responseObject);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(responseObject) &#123;</span><br><span class="line">                               strongSelf.image = responseObject;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//置空回调</span></span><br><span class="line">                           [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   failure:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//失败有failuerBlock就回调，</span></span><br><span class="line">                        <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                failure(request, response, error);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//置空回调对象</span></span><br><span class="line">                            [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                        &#125;</span><br><span class="line">                   &#125;];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">self</span>.af_activeImageDownloadReceipt = receipt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，细节的地方可以关注注释，这里总结一下做了什么：</p><h5 id="1-判断url是否为空-1"><a href="#1-判断url是否为空-1" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>如果为空则取消task，调用如下方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearActiveDownloadInformation &#123;</span><br><span class="line">    <span class="keyword">self</span>.af_activeImageDownloadReceipt = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意<code>cancelImageDownloadTask</code>中，调用了<code>self.af_activeImageDownloadReceipt</code>这么一个属性，看看定义的地方：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">setter</span> = af_setActiveImageDownloadReceipt:) AFImageDownloadReceipt *af_activeImageDownloadReceipt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="comment">//绑定属性 AFImageDownloadReceipt，就是一个事件响应的接受对象，包含一个task，一个uuid</span></span><br><span class="line"> - (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</span><br><span class="line">    <span class="keyword">return</span> (AFImageDownloadReceipt *)objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"> - (<span class="keyword">void</span>)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们现在是给<code>UIImageView</code>添加的一个类目，所以我们无法直接添加属性，而是使用的是runtime的方式来生成set和get方法生成了一个<code>AFImageDownloadReceipt</code>类型的属性。看过上文应该知道这个对象里面就一个task和一个UUID。这个属性就是我们这次下载任务相关联的信息。</p><h5 id="2-做了一系列判断，见注释"><a href="#2-做了一系列判断，见注释" class="headerlink" title="2) 做了一系列判断，见注释"></a>2) 做了一系列判断，见注释</h5><h5 id="3-创建AFImageDownloader并判断缓存"><a href="#3-创建AFImageDownloader并判断缓存" class="headerlink" title="3) 创建AFImageDownloader并判断缓存"></a>3) 创建AFImageDownloader并判断缓存</h5><p>然后生成了一个我们之前分析过得<code>AFImageDownloader</code>，然后去获取缓存，如果有缓存，则直接读缓存。还记得<code>AFImageDownloader</code>里也有一个读缓存的方法么？那个是和cachePolicy相关的，而这个是有缓存的话直接读取。不明白的可以回过头去看看。</p><h5 id="4-请求图片"><a href="#4-请求图片" class="headerlink" title="4) 请求图片"></a>4) 请求图片</h5><p>走到这说明没缓存了，然后就去用<code>AFImageDownloader</code>，我们之前讲过的方法，去请求图片。完成后，则调用成功或者失败的回调，并且置空属性<code>self.af_activeImageDownloadReceipt</code>，成功则设置图片。</p><h4 id="3-cancelImageDownloadTask"><a href="#3-cancelImageDownloadTask" class="headerlink" title="3. cancelImageDownloadTask"></a>3. cancelImageDownloadTask</h4><p>还有一个取消这次任务的方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也是去调用我们之前讲过的<code>AFImageDownloader</code>的取消方法。</p><p>这个类总共就这么几行代码，就完成了我们几乎没有人不用的，设置ImageView图片的方法。当然真正的难点在于<code>AFImageDownloader</code>和<code>AFAutoPurgingImageCache</code>。</p><h3 id="5-2-4-总结"><a href="#5-2-4-总结" class="headerlink" title="5.2.4 总结"></a>5.2.4 总结</h3><p>接下来我们来总结一下整个请求图片，缓存，然后设置图片的流程：</p><ul><li>调用<code>- (void)setImageWithURL:(NSURL *)url;</code>时，我们生成 <code>AFImageDownloader</code>单例，并替我们请求数据。</li><li>而<code>AFImageDownloader</code>会生成一个<code>AFAutoPurgingImageCache</code>替我们缓存生成的数据。当然我们设置的时候，给<code>session</code>的<code>configuration</code>设置了一个系统级别的缓存<code>NSUrlCache</code>,这两者是互相独立工作的，互不影响的。</li><li>然后<code>AFImageDownloader</code>，就实现下载和协调<code>AFAutoPurgingImageCache</code>去缓存，还有一些取消下载的方法。然后通过回调把数据给到我们的类目<code>UIImageView+AFNetworking</code>,如果成功获取数据，则由类目设置上图片，整个流程结束。</li></ul><p>经过这三个文件： <code>UIImageView+AFNetworking</code>、<code>AFImageDownloader</code>、<code>AFAutoPurgingImageCache</code>，至此整个设置网络图片的方法结束了。</p><p>写在最后：对于UIKit的总结，我们就到此为止了，其它部分的扩展，小伙伴们可以自行阅读，都很简单，基本上每个类200行左右的代码。核心功能基本上都是围绕<code>AFURLSessionManager</code>实现的。</p><h1 id="六、AF2-x与AF3-x"><a href="#六、AF2-x与AF3-x" class="headerlink" title="六、AF2.x与AF3.x"></a>六、AF2.x与AF3.x</h1><p>以下是<strong>涉及AF2.x的核心实现，与AF3.x最新版本之间的对比，以及本系列的一个最终总结：AFNetworking到底做了什么？</strong></p><h2 id="6-1-源码结构"><a href="#6-1-源码结构" class="headerlink" title="6.1 源码结构"></a>6.1 源码结构</h2><p>首先我们来看看AF2.x的项目目录:</p><img src="/images/AFN/AFN-10.jpg" alt="img" style="zoom:70%;" /><p>除了UIKit扩展外，大概就是上述这么多类，其中最重要的有3个类：</p><ul><li>AFURLConnectionOperation：大家都知道，AF2.x是基于<code>NSURLConnection</code>来封装的，而<code>NSURLConnection</code>的创建以及数据请求，就被封装在这个类中。所以这个类基本上是AF2.x最底层也是最核心的类。</li><li>AFHTTPRequestOperation：继承自<code>AFURLConnectionOperation</code>，对它父类一些方法做了些封装。</li><li>AFHTTPRequestOperationManager：则是一个管家，去管理这些这些<code>operation</code>。</li></ul><p>我们接下来按照网络请求的流程去看看AF2.x的实现：</p><p>注：本文会涉及一些<code>NSOperationQueue</code>、<code>NSOperation</code>方面的知识，如果对这方面的内容不了解的话，可以先看看雷纯峰的这篇：<a href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues </a></p><p>首先，我们来写一个get或者post请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:url parameters:params</span><br><span class="line">     success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure><p>就这么简单的几行代码，完成了一个网络请求。</p><h2 id="6-2-AFHTTPRequestOperationManager"><a href="#6-2-AFHTTPRequestOperationManager" class="headerlink" title="6.2 AFHTTPRequestOperationManager"></a>6.2 AFHTTPRequestOperationManager</h2><h3 id="6-2-1-初始化方法"><a href="#6-2-1-初始化方法" class="headerlink" title="6.2.1 初始化方法"></a>6.2.1 初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    <span class="comment">//用来调度所有请求的queue</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="comment">//是否做证书验证</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，基本和AF3.x类似，除了以下两点：</p><ol><li>设置了一个<code>operationQueue</code>，这个队列，用来调度里面所有的<code>operation</code>，在AF2.x中，每一个<code>operation</code>就是一个网络请求。</li><li>设置<code>shouldUseCredentialStorage</code>为YES，这个后面会传给<code>operation</code>，<code>operation</code>会根据这个值，去返回给代理，系统是否做https的证书验证。</li></ol><h3 id="6-2-2-get方法及AFHTTPRequestOperation创建"><a href="#6-2-2-get方法及AFHTTPRequestOperation创建" class="headerlink" title="6.2.2 get方法及AFHTTPRequestOperation创建"></a>6.2.2 get方法及AFHTTPRequestOperation创建</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                     parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                        success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                        failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 用 self.requestSerializer 生成了一个request，至于如何生成，可以参考之前的文章，这里就不赘述了。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2. 生成了一个 AFHTTPRequestOperation，然后把这个 operation 加到我们一开始创建的 queue 中。</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [<span class="keyword">self</span> HTTPRequestOperationWithRequest:request success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建<code>AFHTTPRequestOperation</code>方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 方法创建了一个 AFHTTPRequestOperation ，并把自己的一些参数交给了这个 operation 处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建自定义的AFHTTPRequestOperation</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">    operation.responseSerializer = <span class="keyword">self</span>.responseSerializer;</span><br><span class="line">    operation.shouldUseCredentialStorage = <span class="keyword">self</span>.shouldUseCredentialStorage;</span><br><span class="line">    operation.credential = <span class="keyword">self</span>.credential;</span><br><span class="line">    <span class="comment">//设置自定义的安全策略</span></span><br><span class="line">    operation.securityPolicy = <span class="keyword">self</span>.securityPolicy;</span><br><span class="line"></span><br><span class="line">    [operation setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    operation.completionQueue = <span class="keyword">self</span>.completionQueue;</span><br><span class="line">    operation.completionGroup = <span class="keyword">self</span>.completionGroup;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AFHTTPRequestOperation的初始化方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h2 id="6-3-AFURLConnectionOperation"><a href="#6-3-AFURLConnectionOperation" class="headerlink" title="6.3 AFURLConnectionOperation"></a>6.3 AFURLConnectionOperation</h2><h3 id="6-3-1-初始化方法"><a href="#6-3-1-初始化方法" class="headerlink" title="6.3.1 初始化方法"></a>6.3.1 初始化方法</h3><p>首先我们要明确<strong>这个类是继承自NSOperation的</strong>，然后我们接着往下看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(urlRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为ready</span></span><br><span class="line">    _state = AFOperationReadyState;</span><br><span class="line">    <span class="comment">//递归锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = kAFNetworkingLockName;</span><br><span class="line">    <span class="keyword">self</span>.runLoopModes = [<span class="built_in">NSSet</span> setWithObject:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="keyword">self</span>.request = urlRequest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否应该咨询证书存储连接</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//https认证策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法中，初始化了一些属性，下面我们来简单的介绍一下这些属性：</p><h3 id="6-3-2-成员变量和属性"><a href="#6-3-2-成员变量和属性" class="headerlink" title="6.3.2 成员变量和属性"></a>6.3.2 成员变量和属性</h3><h4 id="1-属性state和重写setter"><a href="#1-属性state和重写setter" class="headerlink" title="1. 属性state和重写setter"></a>1. 属性state和重写setter</h4><p><code>_state</code>设置为<code>AFOperationReadyState</code> 准备就绪状态，这是个枚举：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFOperationState) &#123;</span><br><span class="line">    AFOperationPausedState      = <span class="number">-1</span>,  <span class="comment">//停止</span></span><br><span class="line">    AFOperationReadyState       = <span class="number">1</span>,   <span class="comment">//准备就绪</span></span><br><span class="line">    AFOperationExecutingState   = <span class="number">2</span>,  <span class="comment">//正在进行中</span></span><br><span class="line">    AFOperationFinishedState    = <span class="number">3</span>,  <span class="comment">//完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本类重写了state的setter方法，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setState:(AFOperationState)state &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断从当前状态到另一个状态是不是合理，在加上现在是否取消。。大神的框架就是屌啊，这判断严谨的。。一层层</span></span><br><span class="line">    <span class="keyword">if</span> (!AFStateTransitionIsValid(<span class="keyword">self</span>.state, state, [<span class="keyword">self</span> isCancelled])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到对应的父类管理当前线程周期的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *oldStateKey = AFKeyPathFromOperationState(<span class="keyword">self</span>.state);</span><br><span class="line">    <span class="built_in">NSString</span> *newStateKey = AFKeyPathFromOperationState(state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:oldStateKey];</span><br><span class="line">    _state = state;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:oldStateKey];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_state</code>标志着这个网络请求的状态，一共如上4种状态。这些状态其实对应着<code>operation</code>如下的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射这个operation的各个状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NSString * <span class="title">AFKeyPathFromOperationState</span><span class="params">(AFOperationState state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFOperationReadyState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isReady&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationExecutingState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isExecuting&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationFinishedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isFinished&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationPausedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isPaused&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wunreachable-code&quot;</span></span></span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;state&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重写父类NSOperation的属性getter"><a href="#2-重写父类NSOperation的属性getter" class="headerlink" title="2. 重写父类NSOperation的属性getter"></a>2. 重写父类NSOperation的属性getter</h4><p>复写了这些属性的get方法，用来和自定义的state一一对应：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写这些方法，与自己的定义的state对应</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isReady &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationReadyState &amp;&amp; [<span class="keyword">super</span> isReady];</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationExecutingState;</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationFinishedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性lock"><a href="#3-属性lock" class="headerlink" title="3. 属性lock"></a>3. 属性lock</h4><p><code>self.lock</code>这个锁是用来提供给本类一些数据操作的线程安全，至于为什么要用递归锁，是因为有些方法可能会存在递归调用的情况，例如有些需要锁的方法可能会在一个大的操作环中，形成递归。<strong>而AF使用了递归锁，避免了这种情况下死锁的发生</strong>。</p><h4 id="4-属性runLoopModes"><a href="#4-属性runLoopModes" class="headerlink" title="4. 属性runLoopModes"></a>4. 属性runLoopModes</h4><p>初始化了<code>self.runLoopModes</code>，默认为<code>NSRunLoopCommonModes</code>。</p><h4 id="5-属性securityPolicy"><a href="#5-属性securityPolicy" class="headerlink" title="5. 属性securityPolicy"></a>5. 属性securityPolicy</h4><p>生成了一个默认的 <code>self.securityPolicy</code>，关于这个policy执行的https认证，可以见楼主之前的文章。</p><h3 id="6-3-3-复写operation的start方法"><a href="#6-3-3-复写operation的start方法" class="headerlink" title="6.3.3 复写operation的start方法"></a>6.3.3 复写operation的start方法</h3><p>这个类为了自定义<code>operation</code>的各种状态，而且更好的掌控它的生命周期，复写了<code>operation</code>的<code>start</code>方法。</p><h4 id="1-源码实现"><a href="#1-源码实现" class="headerlink" title="1. 源码实现"></a>1. 源码实现</h4><p>当这个<code>operation</code>在一个新线程被调度执行的时候，首先就调入这个<code>start</code>方法中，接下来我们它的实现看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果被取消了就调用取消的方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//在AF常驻线程中去执行</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备好了，才开始</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="comment">//改变状态，开始执行</span></span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，发起请求和取消请求都是在同一个线程！！包括回调都是在一个线程</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法判断了当前的状态，是取消还是准备就绪，然后去调用了各自对应的方法。</p><h4 id="2-开辟新线程"><a href="#2-开辟新线程" class="headerlink" title="2. 开辟新线程"></a>2. 开辟新线程</h4><p>注意这些方法都是在另外一个线程中去调用的，我们来看看这个线程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">//添加端口，防止runloop直接退出</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法基本上是被许多人举例用过无数次了…</p><ul><li>这是一个单例，用<code>NSThread</code>创建了一个线程，并且为这个线程添加了一个<code>runloop</code>，并且加了一个<code>NSMachPort</code>，来防止<code>runloop</code>直接退出。</li><li><strong>这条线程就是AF用来发起网络请求，并且接受网络请求回调的线程，仅仅就这一条线程</strong>（到最后我们来讲为什么要这么做）。和我们之前讲的AF3.x发起请求，并且接受请求回调时的处理方式，遥相呼应。</li></ul><h4 id="3-start调用流程"><a href="#3-start调用流程" class="headerlink" title="3. start调用流程"></a>3. start调用流程</h4><p>我们接着来看如果准备就绪，start调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态，开始执行</span></span><br><span class="line"><span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br></pre></td></tr></table></figure><p>接着在常驻线程中,并且不阻塞的方式，在我们<code>self.runLoopModes</code>的模式下调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationDidStart &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//如果没取消</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//设置为startImmediately YES 请求发出，回调会加入到主线程的 Runloop 下，RunloopMode 会默认为 NSDefaultRunLoopMode</span></span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line">            <span class="comment">//把connection和outputStream注册到当前线程runloop中去，只有这样，才能在这个线程中回调</span></span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开输出流</span></span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line">        <span class="comment">//开启请求</span></span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了以下几件事：</p><h5 id="1-创建NSURLConnection"><a href="#1-创建NSURLConnection" class="headerlink" title="1) 创建NSURLConnection"></a>1) 创建NSURLConnection</h5><p>首先这个方法创建了一个<code>NSURLConnection</code>，设置代理为自己，startImmediately为NO，至于这个参数干什么用的，我们来看看官方文档：</p><blockquote><p>startImmediately<br> YES if the connection should begin loading data immediately, otherwise NO. If you pass NO, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling scheduleInRunLoop:forMode: .</p></blockquote><p>大意是，这个值默认为YES，而且任务完成的结果会在主线程的runloop中回调。如果我们设置为NO，则需要调用我们下面看到的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.connection scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>去注册一个runloop和mode，它会在我们指定的这个runloop所在的线程中回调结果。</p><h5 id="2-outputStream的创建及注册"><a href="#2-outputStream的创建及注册" class="headerlink" title="2) outputStream的创建及注册"></a>2) outputStream的创建及注册</h5><p>值得一提的是这里调用了:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>这个<code>outputStream</code>在getter方法中被初始化了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_outputStream) &#123;</span><br><span class="line">        <span class="comment">//一个写入到内存中的流，可以通过NSStreamDataWrittenToMemoryStreamKey拿到写入后的数据</span></span><br><span class="line">        <span class="keyword">self</span>.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _outputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里数据请求和拼接并没有用<code>NSMutableData</code>，而是用了<code>outputStream</code>，而且把写入的数据，放到内存中。</p><ul><li>其实讲道理来说<code>outputStream</code>的优势在于下载大文件的时候，可以以流的形式，将文件直接保存到本地，<strong>这样可以为我们节省很多的内存</strong>，调用如下方法设置：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:<span class="string">@&quot;filePath&quot;</span> append:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><ul><li>但是这里是把流写入内存中，这样其实这个节省内存的意义已经不存在了。那为什么还要用呢？这里我猜测的是就是为了用它这个可以注册在某一个<code>runloop</code>的指定<code>mode</code>下。 虽然AF使用这个<code>outputStream</code>是肯定在这个常驻线程中的，不会有线程安全的问题。但是要注意它是被声明在.h中的：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *outputStream;</span><br></pre></td></tr></table></figure><p>难保外部不会在其他线程对这个数据做什么操作，所以它相对于<code>NSMutableData</code>作用就体现出来了，就算我们在外部其它线程中去操作它，也不会有线程安全的问题。</p><h5 id="3-开始执行connection"><a href="#3-开始执行connection" class="headerlink" title="3) 开始执行connection"></a>3) 开始执行connection</h5><h5 id="4-到主线程发送任务开始执行的通知"><a href="#4-到主线程发送任务开始执行的通知" class="headerlink" title="4) 到主线程发送任务开始执行的通知"></a>4) 到主线程发送任务开始执行的通知</h5><h3 id="6-3-4-实现NSURLConnectionDelegate"><a href="#6-3-4-实现NSURLConnectionDelegate" class="headerlink" title="6.3.4 实现NSURLConnectionDelegate"></a>6.3.4 实现NSURLConnectionDelegate</h3><p>接下来网络请求开始执行了，就开始触发<code>connection</code>的代理方法了：</p><img src="/images/AFN/AFN-11.jpg" alt="img" style="zoom:74%;" /><p> AF2.x一共实现了如上这么多代理方法，这些代理方法，作用大部分和我们之前讲的<code>NSURLSession</code>的代理方法类似，我们重点讲下面这四个代理：</p><p>注意，有一点需要说明，我们之前是把connection注册在我们常驻线程的runloop中了，<strong>所以以下所有的代理方法，都是在这仅有的一条常驻线程中回调。</strong></p><h4 id="1-connection-didReceiveResponse"><a href="#1-connection-didReceiveResponse" class="headerlink" title="1. connection:didReceiveResponse"></a>1. connection:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到响应，响应头类似相关数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，就是收到响应后，把response赋给自己的属性。</p><h4 id="2-connection-didReceiveData"><a href="#2-connection-didReceiveData" class="headerlink" title="2. connection:didReceiveData"></a>2. connection:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接获取到的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [data length];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> totalNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果outputStream 还有空余空间</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//创建一个buffer流缓冲区，大小为data的字节数</span></span><br><span class="line">            <span class="keyword">const</span> uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//当写的长度小于数据的长度，在循环里</span></span><br><span class="line">            <span class="keyword">while</span> (totalNumberOfBytesWritten &lt; (<span class="built_in">NSInteger</span>)length) &#123;</span><br><span class="line">                <span class="comment">//往outputStream写数据，系统的方法，一次就写一部分，得循环写</span></span><br><span class="line">                numberOfBytesWritten = [<span class="keyword">self</span>.outputStream write:&amp;dataBuffer[(<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten)];</span><br><span class="line">                <span class="comment">//如果 numberOfBytesWritten写入失败了。跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加上每次写的长度</span></span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.outputStream.streamError) &#123;</span><br><span class="line">            <span class="comment">//取消connection</span></span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            <span class="comment">//调用失败的方法</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(connection:didFailWithError:) withObject:<span class="keyword">self</span>.connection withObject:<span class="keyword">self</span>.outputStream.streamError];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程回调下载数据大小</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.totalBytesRead += (<span class="keyword">long</span> <span class="keyword">long</span>)length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgress) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress(length, <span class="keyword">self</span>.totalBytesRead, <span class="keyword">self</span>.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看起来长，其实容易理解而且简单，它只做了3件事：</p><ol><li>给<code>outputStream</code>拼接数据，具体如果拼接，大家可以读注释自行理解下。</li><li>如果出错则调用：<code>connection:didFailWithError:</code>也就是网络请求失败的代理，我们一会下面就会讲。</li><li>在主线程中回调下载进度。</li></ol><h4 id="3-connectionDidFinishLoading"><a href="#3-connectionDidFinishLoading" class="headerlink" title="3. connectionDidFinishLoading"></a>3. connectionDidFinishLoading</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成了调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> __unused *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从outputStream中拿到数据 NSStreamDataWrittenToMemoryStreamKey写入到内存中的流</span></span><br><span class="line">    <span class="keyword">self</span>.responseData = [<span class="keyword">self</span>.outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">       <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空connection</span></span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理是任务完成之后调用。我们从<code>outputStream</code>拿到了最后下载数据，然后关闭置空了<code>outputStream</code>。并且清空了<code>connection</code>。调用了<code>finish</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)finish &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//修改状态</span></span><br><span class="line">    <span class="keyword">self</span>.state = AFOperationFinishedState;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送完成的通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把当前任务状态改为已完成，并且到主线程发送任务完成的通知。<strong>这里我们设置状态为已完成。注意上面已经讲过：本类是复写了state的setter方法的</strong>，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><p>大家了解<code>NSOperationQueue</code>就知道，如果对应的operation的属性<code>finnished</code>被设置为YES，则代表当前<code>operation</code>结束了，会把<code>operation</code>从队列中移除，并且调用<code>operation</code>的<code>completionBlock</code>。<strong>这点很重要，因为我们请求到的数据就是从这个<code>completionBlock</code>中传递回去的</strong>（下面接着讲这个完成Block，就能从这里对接上了）。</p><h4 id="4-connection-didFailWithError"><a href="#4-connection-didFailWithError" class="headerlink" title="4. connection:didFailWithError"></a>4. connection:didFailWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求失败的回调，在cancel connection的时候，自己也主动调用了</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到error</span></span><br><span class="line">    <span class="keyword">self</span>.error = error;</span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一需要说一下的就是这里给<code>self.error</code>赋值，之后完成Block会根据这个error，去判断这次请求是成功还是失败。</p><p>至此我们把<code>AFURLConnectionOperation</code>的业务主线讲完了。</p><p>我们此时数据请求完了，数据在<code>self.responseData</code>中，那它是怎么回到我们手里的呢。需要回到<code>AFURLConnectionOperation</code>子类<code>AFHTTPRequestOperation</code>，有这么一个方法：<code>setCompletionBlockWithSuccess:failure:</code></p><h2 id="6-4-AFHTTPRequestOperation"><a href="#6-4-AFHTTPRequestOperation" class="headerlink" title="6.4 AFHTTPRequestOperation"></a>6.4 AFHTTPRequestOperation</h2><h3 id="6-4-1-初始化方法"><a href="#6-4-1-初始化方法" class="headerlink" title="6.4.1 初始化方法"></a>6.4.1 初始化方法</h3><p>前面已经看过这个AFHTTPRequestOperation的初始化方法，这里再整合一下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h3 id="6-4-2-设置completionBlock"><a href="#6-4-2-设置completionBlock" class="headerlink" title="6.4.2 设置completionBlock"></a>6.4.2 设置completionBlock</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                              failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">    <span class="keyword">self</span>.completionBlock = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">            dispatch_group_enter(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(http_request_operation_processing_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> responseObject = <span class="keyword">self</span>.responseObject;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(<span class="keyword">self</span>, responseObject);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">                dispatch_group_leave(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我们在<code>AFHTTPRequestOperationManager</code>中是调用过这个方法的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation setCompletionBlockWithSuccess:success failure:failure];</span><br></pre></td></tr></table></figure><ul><li>我们在把成功和失败的Block传给了这个方法。</li><li>这个方法也很好理解，就是设置我们之前提到过得<code>completionBlock</code>，<strong>当自己数据请求完成，就会调用这个Block。然后我们在这个Block中调用传过来的成功或者失败的Block。</strong>如果error为空，说明请求成功，把数据传出去，否则为失败，把error信息传出。</li><li>这里也类似AF3.x，可以自定义一个完成组和完成队列。数据可以在我们自定义的完成组和队列中回调出去。</li><li>除此之外，还有一个有意思的地方：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>之前我们说过，这是在忽略编译器的一些警告。</p><ul><li><code>-Wgnu</code>就不说了，是忽略 ?: 。</li><li>值得提下的是<code>-Warc-retain-cycles</code>，这里忽略了循环引用的警告。我们仔细看看就知道<code>self</code>持有了<code>completionBlock</code>，而<code>completionBlock</code>内部持有<code>self</code>。这里确实循环引用了。那么AF是如何解决这个循环引用的呢？</li></ul><p>我们在回到<code>AFURLConnectionOperation</code>，还有一个方法我们之前没讲到，它复写了setCompletionBlock这个方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写setCompletionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:^ &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">            <span class="comment">//看有没有自定义的完成组，否则用AF的组</span></span><br><span class="line">            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</span><br><span class="line">            <span class="comment">//看有没有自定义的完成queue，否则用主队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用设置的Block,在这个组和队列中</span></span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                block();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结束时候置nil，防止循环引用</span></span><br><span class="line">            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&#123;</span><br><span class="line">                [strongSelf setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，它在我们设置的block调用结束的时候，主动的调用:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">strongSelf setCompletionBlock:nil</span>];</span><br></pre></td></tr></table></figure><p>把Block置空，这样循环引用不复存在了。</p><h3 id="6-4-3-数据解析的调用"><a href="#6-4-3-数据解析的调用" class="headerlink" title="6.4.3 数据解析的调用"></a>6.4.3 数据解析的调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObject &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!_responseObject &amp;&amp; [<span class="keyword">self</span> isFinished] &amp;&amp; !<span class="keyword">self</span>.error) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//做数据解析</span></span><br><span class="line">        <span class="keyword">self</span>.responseObject = [<span class="keyword">self</span>.responseSerializer responseObjectForResponse:<span class="keyword">self</span>.response data:<span class="keyword">self</span>.responseData error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">self</span>.responseSerializationError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> _responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestOperation</code> 复写了 <code>responseObject</code> 的getter方法，并且把数据按照我们需要的类型（json、xml等等）进行解析。</p><h2 id="6-5-ResponseSerializer与SecurityPolicy"><a href="#6-5-ResponseSerializer与SecurityPolicy" class="headerlink" title="6.5 ResponseSerializer与SecurityPolicy"></a>6.5 ResponseSerializer与SecurityPolicy</h2><p>关于数据的序列化、SecurityPolicy，前面已经详细的讲过，AF2.x与AF3.x基本差不多，不再赘述。<code>AFSecurityPolicy</code> 在  <code>AFURLConnectionOperation</code>中https认证的代理中被调用</p><p>至此，AF2.x整个业务流程就结束了。</p><h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><p>接下来，我们来总结总结AF2.x整个业务请求的流程：</p><img src="/images/AFN/AFN-12.jpg" alt="img" style="zoom:65%;" /><p>如上图，我们来梳理一下整个流程：</p><ul><li>最上层的是<code>AFHTTPRequestOperationManager</code>,我们调用它进行get、post等等各种类型的网络请求</li><li>然后它去调用<code>AFURLRequestSerialization</code>做request参数拼装。然后生成了一个<code>AFHTTPRequestOperation</code>实例，并把request交给它。然后把<code>AFHTTPRequestOperation</code>添加到一个<code>NSOperationQueue</code>中。</li><li>接着<code>AFHTTPRequestOperation</code>拿到request后，会去调用它的父类<code>AFURLConnectionOperation</code>的初始化方法，并且把相关参数交给它，除此之外，当父类完成数据请求后，它调用了<code>AFURLResponseSerialization</code>把数据解析成我们需要的格式（json、XML等等）。</li><li>最后就是我们AF最底层的类<code>AFURLConnectionOperation</code>，它去数据请求，并且如果是https请求，会在请求的相关代理中，调用<code>AFSecurityPolicy</code>做https认证。最后请求到的数据返回。</li></ul><p>这就是AF2.x整个做网络请求的业务流程。</p><h2 id="6-7-遗留问题：一条常驻线程"><a href="#6-7-遗留问题：一条常驻线程" class="headerlink" title="6.7 遗留问题：一条常驻线程"></a>6.7 遗留问题：一条常驻线程</h2><p>我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？</p><p>首先如果我们用<code>NSURLConnection</code>，我们为了获取请求结果有以下三种选择：</p><ol><li>在主线程调异步接口</li><li>每一个请求用一个线程，对应一个runloop，然后等待结果回调。</li><li>只用一条线程，一个runloop，所有结果回调在这个线程上。</li></ol><p>很显然AF选择的是第3种方式，创建了一条常驻线程专门处理所有请求的回调事件，这个模型跟<code>nodejs</code>有点类似，我们来讨论讨论不选择另外两种方式的原因：</p><p>先说第一种。试想如果我们所有的请求都在主线程中异步调用，好像没什么不可以？那为什么AF不这么做呢…在这里有两点原因（楼主个人总结的，有不同意见，欢迎讨论）：</p><ol><li><p>第一，如果我们放到主线程去做，势必要这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>] </span><br></pre></td></tr></table></figure><p>这样NSURLConnection的回调会被放在主线程中<code>NSDefaultRunLoopMode</code>中，这样我们在其它类似<code>UITrackingRunLoopMode</code>模式下，我们是得不到网络请求的结果的，这显然不是我们想要的，那么我们势必需要调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>]; </span><br></pre></td></tr></table></figure><p>把它加入 <code>NSRunLoopCommonModes</code> 中，试想如果有大量的网络请求，同时回调回来，就会影响我们的UI体验了。</p></li><li><p>另外一点原因是，如果我们请求数据返回，势必要进行数据解析，解析成我们需要的格式，那么这些解析都在主线程中做，给主线程增加额外的负担。又或者我们回调回来开辟一个新的线程去做数据解析，那么我们有n个请求回来开辟n条线程带来的性能损耗，以及线程间切换带来的损耗，是不是一笔更大的开销。</p></li></ol><p>所以综述两点原因，我们并不适合在主线程中回调。</p><p>再说第二种。我们一开始就开辟n条线程去做请求，然后设置runloop保活住线程，等待结果回调。其实看到这，大家想想都觉得这个方法很傻，为了等待不确定的请求结果，阻塞住线程，白白浪费n条线程的开销。</p><p>综上所述，这就是<strong>AF2.x需要一条常驻线程的原因了</strong>。</p><p>至此我们把AF2.x核心流程分析完了。</p><h1 id="七、总结AFNetworking到底做了什么？"><a href="#七、总结AFNetworking到底做了什么？" class="headerlink" title="七、总结AFNetworking到底做了什么？"></a>七、总结AFNetworking到底做了什么？</h1><p>接着到我们本系列一个最终总结了: <strong>AFNetworking到底做了什么？</strong></p><p>相信如果从头看到尾的小伙伴，心里都有了一个属于自己的答案。其实在楼主心里，实在不想去总结它，因为<code>AFNetworking</code>中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。但是想想也知道，如果我说不总结，估计有些看到这的朋友杀人的心都有…所以我还是赶鸭子上架，来总结总结它。</p><p>AFNetworking的作用总结：</p><p>一、首先我们需要明确一点的是：<strong>相对于AFNetworking2.x，AFNetworking3.x确实没那么有用了。</strong>AFNetworking之前的核心作用就是为了帮我们去调度所有的请求。但是最核心地方却被苹果的<code>NSURLSession</code>给借鉴过去了，嗯…是借鉴。这些请求的调度，现在完全由<code>NSURLSession</code>给做了，AFNetworking3.x的作用被大大的削弱了。</p><p>二、但是除此之外，其实它还是很有用的：</p><ol><li><strong>首先它帮我们做了各种请求方式request的拼接。</strong>想想如果我们用<code>NSURLSession</code>，我们去做请求，是不是还得自己去考虑各种请求方式下，拼接参数的问题。</li><li><strong>它还帮我们做了一些公用参数（session级别的），和一些私用参数（task级别的）的分离</strong>。它用Block的形式，支持我们自定义一些代理方法，如果没有实现的话，AF还帮我们做了一些默认的处理。而如果我们用<code>NSURLSession</code>的话，还得参照AF这么一套代理转发的架构模式去封装。</li><li><strong>它帮我们做了自定义的https认证处理</strong>。看过楼主之前那篇<a href="https://www.jianshu.com/p/a84237b07611">AFNetworking之于https认证</a>的朋友就知道，如果我们自己用<code>NSURLSession</code>实现那几种自定义认证，需要多写多少代码…</li><li><strong>对于请求到的数据，AF帮我们做了各种格式的数据解析，并且支持我们设置自定义的code范围，自定义的数据方式</strong>。如果不在这些范围中，则直接调用失败block。如果用<code>NSURLSession</code>呢？这些都自己去写吧…（你要是做过各种除json外其他的数据解析,就会知道这里面坑有多少…）</li><li><strong>对于成功和失败的回调处理。</strong>AF帮我们在数据请求到，到回调给用户之间，做了各种错误的判断，保证了成功和失败的回调，界限清晰。在这过程中，AF帮我们做了太多的容错处理，而<code>NSURLSession</code>呢？只给了一个完成的回调，我们得多做多少判断，才能拿到一个确定能正常显示的数据？</li><li>……</li><li>…</li></ol><p>光是这些网络请求的业务逻辑，AF帮我们做的就太多太多，当然还远不仅于此。它用凝聚着许多大牛的经验方式，帮我在有些处理中做了最优的选择，比如我们之前说到的，回调线程数设置为1的问题…帮我们绕开了很多的坑，比如系统内部并行创建<code>task</code>导致id不唯一等等…</p><p>三、而如果我们需要一些UIKit的扩展，AF则提供了最稳定，而且最优化实现方式：</p><ul><li>就比如之前说到过得那个状态栏小菊花，如果是我们自己去做，得多写多少代码，而且实现的还没有AF那样质量高。</li><li>又或者<code>AFImageDownloader</code>，它对于组图片之间的下载协调，以及缓存使用的之间线程调度。对于线程，锁，以及性能各方面权衡，找出最优化的处理方式，试问小伙伴们自己基于<code>NSURLSession</code>去写，能到做几分…</li></ul><p>所以最后的结论是：<strong>AFNetworking虽然变弱了，但是它还是很有用的。</strong>用它真的不仅仅是习惯，而是因为它确实帮我们做了太多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F&quot;&gt;原文链接&lt;/a&gt;，有一些细节修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;im</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="AFN" scheme="https://tenloy.github.io/tags/AFN/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络相关知识汇总</title>
    <link href="https://tenloy.github.io/2021/09/09/computer-network-knowledge.html"/>
    <id>https://tenloy.github.io/2021/09/09/computer-network-knowledge.html</id>
    <published>2021-09-09T18:53:12.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程：是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</p><p>我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。</p><p>这些过程都发生了网络数据的交互：</p><ul><li>bs：browser server 浏览器和服务器的网络编程模型</li><li>cs：client server 客户端和服务器的网络编程模型</li></ul><p>强调：网络编程重在思想，node只是一个可以帮助我们网络编程的一个工具而已。使用其他编程语言或者操作系统进行网络编程，思想都是一样的。</p><h1 id="一、服务器与服务器容器"><a href="#一、服务器与服务器容器" class="headerlink" title="一、服务器与服务器容器"></a>一、服务器与服务器容器</h1><h2 id="1-1-服务器-server"><a href="#1-1-服务器-server" class="headerlink" title="1.1 服务器(server)"></a>1.1 服务器(server)</h2><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li>一个管理资源并为用户<font color='red'>提供服务</font>的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</li><li>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h3 id="1-1-1-作为硬件"><a href="#1-1-1-作为硬件" class="headerlink" title="1.1.1 作为硬件"></a>1.1.1 作为硬件</h3><p>服务器就是一台特殊的、功能强大、没有外接设备(屏幕、键盘、鼠标)的电脑。一个服务器一个IP，有些大公司，拥有成千上万个服务器，我们通过主机域名来访问资源，服务器是随机分配给我们的。</p><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li><li>服务器不需要比较复杂的可视化操作界面，因为比较耗资源。服务器一旦部署好服务后，一般动的比较少。</li></ul><h3 id="1-1-2-作为软件"><a href="#1-1-2-作为软件" class="headerlink" title="1.1.2 作为软件"></a>1.1.2 作为软件</h3><h4 id="1-常见分类"><a href="#1-常见分类" class="headerlink" title="1. 常见分类"></a>1. 常见分类</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，按提供的服务类型不同可分为：</p><ul><li><strong>应用程序服务器(application server/AP server)</strong></li><li>**网页服务器(Web server) ** —— Apache、Nginx、IIS、Tomcat、NodeJS等；</li><li>文件服务器(file server)或网络存储设备(network attached storage) —— Server-U、FileZilla、VsFTP等；</li><li>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</li><li>邮件服务器(mail server) —— Postfix、Sendmail等；</li><li>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</li><li>域名服务器（DNS server）—— 如BIND等</li><li>代理服务器（proxy server）—— 如Squid cache</li><li>其他，如Active Directory服务器、Minecraft游戏服务器等</li></ul><img src = "/images/ComNet/servers.jpg" width = '50%' align:left style='margin-left:10%'><h4 id="2-应用程序服务器"><a href="#2-应用程序服务器" class="headerlink" title="2. 应用程序服务器"></a>2. 应用程序服务器</h4><p><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</p><p>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong></p><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul><h4 id="3-网页服务器-Web-server"><a href="#3-网页服务器-Web-server" class="headerlink" title="3. 网页服务器(Web server)"></a>3. 网页服务器(Web server)</h4><p>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</p><p>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。如Apache（静态）、Apache Tomcat（静态、动态）、Node.js、lighttpd、nginx、微软的IIS等；</p><img src="/images/ComNet/web-server.jpg" alt="图片" style="zoom:90%;" /><h4 id="4-WEB应用服务器"><a href="#4-WEB应用服务器" class="headerlink" title="4. WEB应用服务器"></a>4. WEB应用服务器</h4><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p><h3 id="1-1-3-服务器的其它分类"><a href="#1-1-3-服务器的其它分类" class="headerlink" title="1.1.3 服务器的其它分类"></a>1.1.3 服务器的其它分类</h3><p><strong>按操作系统分</strong></p><ul><li>Linux服务器、Windows服务器等；</li></ul><p><strong>按照浏览器的访问权限来分</strong></p><ul><li><p>外网服务器<br>别名：远程服务器，<font color=red>任何网段的设备都能访问的服务器</font><br>应用场景：应用上线后使用的服务器<br>使用人群：供全体用户使用<br>速度：取决于服务器的性能、用户的网速</p></li><li><p>内网服务器<br>别名：本地服务器，<font color=red>只有连同样内网的设备才能访问到的服务器</font><br>应用场景：应用处于开发、测试阶段使用的服务器<br>使用人群：仅供公司内部的开发人员、测试人员使用<br>速度：由于是局域网，所以速度飞快，有助于提高开发测试效率</p></li><li><p>一般公司会有三套服务器：本地测试服务器、外网测试服务器、外网正式服务器<br>内网测试可以直接测试服务器的并发连接性能<br>外网的话首先要考验你的互联网导致的延时和掉包的因素</p></li></ul><h3 id="1-1-4-内网和外网的区别"><a href="#1-1-4-内网和外网的区别" class="headerlink" title="1.1.4 内网和外网的区别"></a>1.1.4 内网和外网的区别</h3><p><font color=red>内网可以访问外网服务器，也可以设置不能访问。</font></p><p><font color=red>外网肯定不能访问内网服务器。</font></p><h4 id="1-内网"><a href="#1-内网" class="headerlink" title="1. 内网"></a>1. 内网</h4><p>内网就是我们平常说的局域网。</p><p>局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组。</p><ul><li>它可以是邻居之间的2台电脑，也可以是一幢100层大楼里的1000台电脑。</li><li><font color=red>可以是独立封闭运行的</font>（配置了服务器，建立了内部的web网页，论坛等等，但时不能上QQ、MSN等等，不能与外部发生通信），也可以是和外网相连接的</li></ul><h4 id="2-外网"><a href="#2-外网" class="headerlink" title="2. 外网"></a>2. 外网</h4><p>外网就是与internet连接的网络，可以跟世界上任何地方取得联系，但不能访问人家的内网服务器。外网就不经路由器或交换机就可以上网的网络，可以直接被外界所访问到。无需经如何设备，直接连接电脑。</p><h4 id="3-区分内网与外网"><a href="#3-区分内网与外网" class="headerlink" title="3. 区分内网与外网"></a>3. 区分内网与外网</h4><ul><li>用猫、路由器连接的都是外网。内网只用交换机<br>但是：有些光纤到楼、小区宽带、教育网、有线电视Cable Modem上网虽然地域范围比较大但本质上还是基于以太网技术，所以仍然属于内网。</li><li>判断内网和外网最简单的方法：判断网段 (有专业的方法，不会)</li><li><font color=red>内网IP的网段</font><ul><li>10.0.0.0 / 8:10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 / 12.172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 / 16.192.168.0.0 ~ 192.168.255.255</li></ul></li></ul><h4 id="4-为什么生活中很多的局域网？"><a href="#4-为什么生活中很多的局域网？" class="headerlink" title="4. 为什么生活中很多的局域网？"></a>4. 为什么生活中很多的局域网？</h4><p>其实<font color=red>外网IP是比较紧张的，现在的电脑的普及使得外网IP根本不够用，根本做不到一台电脑一个外网IP</font>，内网的产生就是为了解决这个难题的！</p><p>路由器只需一个外网IP就可以供下面的N多电脑联网。因为不同的内网IP是可以重复使用（任何一台电脑要上网，都必须在网络上有一个唯一的IP地址。在局域网内，这个IP地址是唯一的。但是在另外一个局域网，这个IP地址仍然能够使用）。拿网吧举例，一个网吧N多台电脑，其实他只要一个外网IP就可以给下面的电脑提供上网</p><h2 id="1-2-服务器容器"><a href="#1-2-服务器容器" class="headerlink" title="1.2 服务器容器"></a>1.2 服务器容器</h2><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = "/images/ComNet/container_server.jpg" width = '40%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = "/images/ComNet/containers.jpg" width = '50%' align:left style='margin-left:10%'><h3 id="1-2-1-Servlet容器"><a href="#1-2-1-Servlet容器" class="headerlink" title="1.2.1 Servlet容器"></a>1.2.1 Servlet容器</h3><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h3 id="1-2-2-Java-WEB容器"><a href="#1-2-2-Java-WEB容器" class="headerlink" title="1.2.2 Java WEB容器"></a>1.2.2 Java WEB容器</h3><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h3 id="1-2-3-Java-EE容器"><a href="#1-2-3-Java-EE容器" class="headerlink" title="1.2.3 Java EE容器"></a>1.2.3 Java EE容器</h3><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h2 id="1-3-举例说明容器与服务器的联系"><a href="#1-3-举例说明容器与服务器的联系" class="headerlink" title="1.3 举例说明容器与服务器的联系"></a>1.3 举例说明容器与服务器的联系</h2><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h3 id="1-3-1-Apache、Nginx、IIS"><a href="#1-3-1-Apache、Nginx、IIS" class="headerlink" title="1.3.1 Apache、Nginx、IIS"></a>1.3.1 Apache、Nginx、IIS</h3><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><p>Nginx：</p><ul><li>代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>nginx除了是个web服务器还能够做反向代理服务器，反向代理服务器的作用，可以用来做负载均衡代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>也可以用nginx来做负载均衡</li></ul><h3 id="1-3-2-Node没有Web容器"><a href="#1-3-2-Node没有Web容器" class="headerlink" title="1.3.2 Node没有Web容器"></a>1.3.2 Node没有Web容器</h3><ul><li>.net平台的 ASP或者ASP.net 需要 <code>IIS</code> 作为服务器容器</li><li>PHP需要搭载 Apache 或者 <code>Nginx</code> 作为服务器容器</li><li>Java 的 JSP 需要 <code>Tomcat</code> 作为服务器容器</li><li>ruby 的 ruby on rails 需要 搭配 <code>Apache</code> 等作为自己的服务器容器。。。</li></ul><p>如果我用 js 写了一个 web 应用程序，那么 node 就是web服务器，Node，不需要服务器容器。</p><h3 id="1-3-3-Tomcat及常见的JavaEE应用服务器"><a href="#1-3-3-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="1.3.3 Tomcat及常见的JavaEE应用服务器"></a>1.3.3 Tomcat及常见的JavaEE应用服务器</h3><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h3 id="1-3-4-Nginx-Tomcat的WEB应用服务器-集群"><a href="#1-3-4-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="1.3.4 Nginx + Tomcat的WEB应用服务器(集群)"></a>1.3.4 Nginx + Tomcat的WEB应用服务器(集群)</h3><img src = "/images/ComNet/nginx_tomcat.jpg" width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="1-4-服务器开发"><a href="#1-4-服务器开发" class="headerlink" title="1.4 服务器开发"></a>1.4 服务器开发</h2><p>开发服务器的语言很多：Java、PHP、.net、node.js、python、go、ruby、erlang等等</p><p>不同语言开发的服务器，对应的配置电脑为服务器的软件也不一样(这里说的都是Windows系统的)</p><ul><li>java — Tomcat</li><li>php — wamp (w-windows、a-apache、m - mysql、p-php)</li><li>node.js — NodeJS</li></ul><h2 id="1-5-Apache服务器的配置"><a href="#1-5-Apache服务器的配置" class="headerlink" title="1.5 Apache服务器的配置"></a>1.5 Apache服务器的配置</h2><p>在iOS与前端的学习中，Apache使用起来最方便。所以这里主要说Web服务器：- http服务器： - Apache服务器</p><p>Apache服务器的配置</p><ul><li>Windows系统：wamp软件安装，然后修改一些配置信息</li><li>Mac系统：自带有Apache服务器，通过终端配置一些信息，然后打开即可</li></ul><p>在配置信息中，我们会<font color=red>指定一个文件夹，作为别人访问我们的电脑服务器时能获取到的文件 — 网站根目录</font></p><p>被访问的时候</p><ul><li>如果网站根目录中，<font color=red>有index命名的文件(不管是HTML文件，还是PHP文件)，会直接运行.</font></li><li>如果没有index命名的，那么就会将该文件夹内的文件，以列表形式展示出来.</li></ul><h2 id="1-6-PHP开发服务器是怎么工作的"><a href="#1-6-PHP开发服务器是怎么工作的" class="headerlink" title="1.6 PHP开发服务器是怎么工作的"></a>1.6 PHP开发服务器是怎么工作的</h2><p>PHP服务器，是怎么接收的？</p><h3 id="1-6-1-创建PHP文件"><a href="#1-6-1-创建PHP文件" class="headerlink" title="1.6.1 创建PHP文件"></a>1.6.1 创建PHP文件</h3><ul><li><p>.php文件，写PHP代码，也可以写HTML+CSS+JS代码，跟写在.html文件中，显示效果一模一样。</p><p>不过，PHP代码，需要写在 <?php ?> 标签中，而且标签内只能写PHP代码。</p></li><li><p>.html文件里，不能写PHP代码</p></li></ul><p><font color=red>要放在我们服务器里的根目录里，PHP代码只有放在服务器中，被访问的时候，才会执行</font></p><h3 id="1-6-2-取值"><a href="#1-6-2-取值" class="headerlink" title="1.6.2 取值"></a>1.6.2 取值</h3><p>别人根据URL，访问该PHP文件的时候，如果携带参数，那就会将参数，传值到该文件</p><p>取值：php中为我们预定义了几个 超全局对象</p><ul><li><p>GET取值：$_GET 是一个关系型数组 $_GET[‘key’]</p></li><li><p>POST取值：$_POST 也是一个关系型数组 $_POST[‘key’]</p></li><li><p>POST上传文件: $_FILES</p><p>获取 上传的文件信息 关系型数组 <code>$fileArr = $_FILES[&#39;upFile&#39;];</code></p><p>获取 上传的文件的原本名字 <code>$fileName = $fileArr[&#39;name&#39;];</code></p><p>获取保存在服务器的那个位置 <code>$filePath = $fileArr[&#39;tmp_name&#39;];</code></p><p>PHP将上传的文件，保存至指定位置</p><ul><li><p>参数1：是从上传的文件信息中，取的Path值</p></li><li><p>参数2：我们指定的存储位置</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(<span class="variable">$filePath</span>,’文件夹/‘.<span class="variable">$fileName</span>); <span class="comment">//注意：<span class="doctag">bug:</span> Mac本上，必须要设置一些指定路径文件夹的权限，设置为everyone可读写，否则，访问的时候，是写不进去东西的</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：key的值就是提交的参数名，需要保持一致</p><h3 id="1-6-3-返回访问结果"><a href="#1-6-3-返回访问结果" class="headerlink" title="1.6.3 返回访问结果"></a>1.6.3 返回访问结果</h3><p><font color=red>如果请求的是HTML文件：原封不动返回，服务器不会动这个HTML文件</font></p><p><font color=red>如果请求的是PHP文件：</font></p><ul><li><p>HTML部分的代码，原封不动的返回</p></li><li><p><code>&lt;?php ?&gt;</code>里的PHP代码，<font color=red>在服务器端执行</font>，只返回输出函数：echo、print_f 打印的结果</p></li></ul><h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><p>试想一下,如果一个网站的注册用户有1千万个那么应该使用什么格式,什么方式来保存这些数据呢?</p><h2 id="3-1-常规保存方式"><a href="#3-1-常规保存方式" class="headerlink" title="3.1 常规保存方式"></a>3.1 常规保存方式</h2><h3 id="3-1-1-txt文件"><a href="#3-1-1-txt文件" class="headerlink" title="3.1.1 .txt文件"></a>3.1.1 .txt文件</h3><p>因为内容是文本,所以直接使用文本文件保存肯定可以,但是当一个文本文件很大很大时,打开是异常缓慢的</p><h3 id="3-1-2-excel文件"><a href="#3-1-2-excel文件" class="headerlink" title="3.1.2 .excel文件"></a>3.1.2 .excel文件</h3><p>可以用来进行数据的统计,分析等操作,但是当很多个人需要访问同一个.excel文件时,性能也很差</p><h2 id="3-2-数据库"><a href="#3-2-数据库" class="headerlink" title="3.2 数据库"></a>3.2 数据库</h2><p>按照数据结构来组织,存储和管理数据的仓库,软件开发行业一般指的是数据库软件,常见的有:Oracle、MySQL、MSSQL等</p><p>特点:</p><ul><li>数据共享:多用户同时访问数据的稳定性</li><li>故障恢复:数据库软件提供了一套的方法,可以用来发现错误并且修复错误</li><li>减少数据冗余:由于大家都可以使用同一套数据,没有必要重复创建了</li></ul><h2 id="3-3-DBA"><a href="#3-3-DBA" class="headerlink" title="3.3 DBA"></a>3.3 DBA</h2><p>数据库管理员（Database Administrator，简称DBA）</p><p>从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支</p><p>工作是:</p><ol><li>主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</li><li>保证数据库的稳定性、安全性、完整性和高性能.</li></ol><p>在国外，也有公司把DBA称作数据库工程师(Database Engineer)，两者的工作内容基本相同，都是保证数据库服务7*24小时的稳定高效运转，但是需要区分一下DBA和数据库开发工程师(Database Developer)：</p><ol><li>数据库开发工程师的主要职责是设计和开发数据库管理系统和数据库应用软件系统，侧重于软件研发；</li><li>DBA的主要职责是运维和管理数据库管理系统，侧重于运维管理。</li></ol><h1 id="三、网络编程-—-BS-CS模式"><a href="#三、网络编程-—-BS-CS模式" class="headerlink" title="三、网络编程 — BS/CS模式"></a>三、网络编程 — BS/CS模式</h1><p>网络编程 是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：</p><ul><li>这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</li><li>无论是C/S，还是B/S都需要联网，所以不需要互联网的单机软件不在讨论范围内。</li></ul><h2 id="3-1-C-S架构-client-server"><a href="#3-1-C-S架构-client-server" class="headerlink" title="3.1 C/S架构(client/server)"></a>3.1 C/S架构(client/server)</h2><blockquote><p>指的是客户端，服务器架构的意思,很多常见的软件都是这种架构</p></blockquote><ul><li><strong>解释：</strong>对于C/S架构，最为常见的例子就是网络游戏，比如LOL、WOW如果不联网无法使用，你在软件内所做的所有操作通过互联网能够传递到其他的的玩家身上。</li><li><strong>优点:</strong><ul><li>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可</li><li>界面酷炫：客户端可以使用更多系统提供的效果(比如传感信息，浏览器就很难做到),做出更为炫目的效果</li></ul></li><li><strong>缺点:</strong><ul><li>更新软件：如果推出了新版本,不更新客户端无法登陆使用(一部分)</li><li>不同设备访问：如果使用其他的电脑,没有安装客户端的话就无法登陆软件(比如收发邮件)</li></ul></li></ul><h2 id="3-2-B-S架构-Browser-Server"><a href="#3-2-B-S架构-Browser-Server" class="headerlink" title="3.2 B/S架构(Browser/Server)"></a>3.2 B/S架构(Browser/Server)</h2><blockquote><p>指的是浏览器—服务器，是WEB兴起之后的一种架构</p></blockquote><ul><li><strong>解释：</strong>现在所有的网站都是B/S架构,较为常见的例子有百度,知乎,网易云音乐Web等等,所有只需要通过浏览器即可使用.</li><li><strong>优点:</strong><ul><li>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容,但是对用户而言只需要刷新浏览器即可</li><li>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用</li></ul></li><li><strong>缺点:</strong><ul><li>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小</li><li>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一,移动设备兼容性较好,ie6已经越来越少人用了</li></ul></li></ul><h1 id="四、网络通讯模型及协议"><a href="#四、网络通讯模型及协议" class="headerlink" title="四、网络通讯模型及协议"></a>四、网络通讯模型及协议</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>在都知道了浏览器、客户端、服务器、数据库是什么之后，接下来就是核心-重点：浏览器/客户端与服务器之间的网络通讯</p><p><strong>学习网络编程：</strong></p><ol><li>可以掌握实时更新数据的手段</li><li>是开发优秀应用的前提和基础</li></ol><p><strong>网络通讯三要素:传输协议、端口号、IP</strong></p><p>通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据</p><img src="/images/ComNet/网络通讯.png" alt="img" style="zoom:90%;" /><h2 id="4-2-OSI七层模型"><a href="#4-2-OSI七层模型" class="headerlink" title="4.2 OSI七层模型"></a>4.2 OSI七层模型</h2><p>要了解传输协议，首先需要知道传输过程中分为哪几层传输，每一层的传输协议是不一样的。</p><img src="/images/ComNet/OSI七层模型.png" alt="img" style="zoom:90%;" /><table><thead><tr><th>分层</th><th>功能及协议</th></tr></thead><tbody><tr><td>应用层</td><td>网络服务与最终用户的一个接口  HTTP/HTTPS超文本传输协议、FTP文件传输协议、SMTP邮件传输协议</td></tr><tr><td>表示层</td><td>数据的表示、安全、压缩。</td></tr><tr><td>会话层</td><td>建立、管理、终止会话</td></tr><tr><td></td><td>以上三层：http协议(所有的万维网文件都必须遵守)、HLS(渐进流式传输协议，苹果改造HTTP协议创建的流媒体协议)、RTMP/MMS(实时流式传输协议-微软出品)、XMPP/IMPP/PRIM/SIP(四种IM(即时消息通讯)协议，XMPP最灵活常用) 等等好多好多协议</td></tr><tr><td>传输层</td><td><font color=red>遵循TCP/UDP协议，定义传输数据的协议端口号</font> HTTP协议的端口号默认是80，我们可以根据自己实际情况改的</td></tr><tr><td>网络层</td><td>路由器 <font color=red>遵循IP协议，会给电脑分配IP</font>，进行逻辑地址寻址</td></tr><tr><td>数据链路层</td><td>网卡、网桥、交换机 建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）</td></tr><tr><td>物理层</td><td>光纤、电话线 建立、维护、断开物理连接。（由底层网络定义协议）</td></tr></tbody></table><p>注意：</p><ol><li>传输层和上面的三层就是在客户端里的了</li><li>会话层、表示层、应用层在五层模型中合并为应用层</li></ol><h3 id="OSI模型通讯"><a href="#OSI模型通讯" class="headerlink" title="OSI模型通讯"></a>OSI模型通讯</h3><img src="/images/ComNet/OSI模型通讯.png" alt="img" style="zoom:90%;" /><p>解析说明：计算机A -&gt; B，之所以叫封包/解包，是因为当我们应用层需要获取数据时</p><ul><li>会在应用层生成一个请求的数据包(是按照<font color=red>HTTP协议生成</font>的)</li><li>然后到了传输层，会按照TCP/UDP协议进行封装包装，<font color=red>加了个端口号</font></li><li>到了网络层进行IP协议的封装，<font color=red>加了个协议号</font></li><li>然后经过下两层传到服务器</li><li>服务器会进行一一相对应的解封，知道服务器的应用层，会按照请求，返回响应(响应返回去的过程与来时一样)</li></ul><h2 id="4-3-HTTP协议-定义数据格式"><a href="#4-3-HTTP协议-定义数据格式" class="headerlink" title="4.3 HTTP协议 - 定义数据格式"></a>4.3 HTTP协议 - 定义数据格式</h2><h3 id="4-3-1-HTTP协议概述"><a href="#4-3-1-HTTP协议概述" class="headerlink" title="4.3.1 HTTP协议概述"></a>4.3.1 HTTP协议概述</h3><blockquote><p>协议：经过双方或多方共同商量或谈判后取得的一致意见：双方达成协议｜根据协议办事 | 遵守这样的约束。</p></blockquote><ul><li>网络之间传输数据就需要协议。</li><li>所谓的协议就是双方约定好的一些数据格式。否则两台计算机之间如何识别对方发送过来的 0 1 数据。</li></ul><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>HTTP（Hyper Text Transfer Protocol），超文本(图片，视频，zip等)传输协议，是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。所以<strong>HTTP协议就是 浏览器 和 服务器 之间通信的一个数据格式规范</strong>。</li><li>HTTP 协议是网络编程使用最为广泛的协议，因为很简单</li><li>它是一个应用层协议，承载于TCP之上</li><li>HTTP协议用于客户端和服务器端之间的通信。由请求和响应构成，是一个标准的客户端服务器模型<ul><li>在两台计算机之间使用HTTP协议通信时，必定一端担任客户端角色，另一端担任服务器端角色</li></ul></li><li>通过请求和响应的交换达成通信。是问答式交互，客户端和服务器一问一答进行通信<ul><li>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回</li><li>也就是说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求时，<strong>不会主动向浏览器推送数据</strong>。这样是安全考虑，也是提高服务器性能的考虑。如果要服务器向浏览器推送数据，则需要使用Socket.IO等额外的技术来解决。</li></ul></li></ul><p>请求响应实例：请求访问某台HTTP服务器上的/index.htm页面资源：</p><ul><li>起始行开头的GET：表示请求访问服务器的类型，称为方法</li><li>随后的字符串/index.html：指明了请求访问的资源对象，也叫请求URI</li><li>最后的HTTP/1.1，即HTTP版本号用来提示客户端使用的HTTP协议的功能</li></ul><img src="/images/ComNet/http-reqres-example.png" style="zoom:80%"><h4 id="2-HTTP协议中的内容"><a href="#2-HTTP协议中的内容" class="headerlink" title="2. HTTP协议中的内容"></a>2. HTTP协议中的内容</h4><ul><li>规定URL的格式<ul><li>协议:// 主机地址: 端口号//路径</li><li><a href="http://www.baidu.com/">http://www.baidu.com</a>: 80//…… (http默认的端口号是80，可以省)</li></ul></li><li>规定客户端和服务器之间的数据传输格式，让客户端和服务器能有效地进行数据沟通<ul><li>规定请求怎么发</li><li>规定响应怎么发</li></ul></li></ul><h4 id="3-HTTP协议特点"><a href="#3-HTTP协议特点" class="headerlink" title="3. HTTP协议特点"></a>3. HTTP协议特点</h4><ol><li>简单快速。HTTP协议简单，所以 HTTP 服务器的程序规模小，通信速度快</li><li>灵活。HTTP 允许传输任意类型的数据</li></ol><h4 id="4-HTTP的版本"><a href="#4-HTTP的版本" class="headerlink" title="4. HTTP的版本"></a>4. HTTP的版本</h4><ul><li>HTTP 0.9 和 1.0 使用非持续连接：限制每次连接只处理一个请求，服务器对客户端的请求做出响应后，立刻断开连接，这种方式可以节省传输时间</li><li>HTTP 1.1 使用持续连接（如今最常用）：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，不会创建那么多的请求了</li></ul><h4 id="5-协议的请求、响应结构"><a href="#5-协议的请求、响应结构" class="headerlink" title="5. 协议的请求、响应结构"></a>5. 协议的请求、响应结构</h4><img src="/images/ComNet/http-structure.png" style="zoom:70%"><h3 id="4-3-2-请求报文的格式"><a href="#4-3-2-请求报文的格式" class="headerlink" title="4.3.2 请求报文的格式"></a>4.3.2 请求报文的格式</h3><blockquote><p>客户端向服务器索取数据的一种行为</p></blockquote><h4 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的由客户端发给服务器的 HTTP 请求报文 需要包含以下内容：</p><ul><li><p><strong>请求行</strong></p><ul><li>客户端给服务器的一些额外信息，指定 请求方法、请求资源路径 以及 HTTP协议版本</li><li>格式：<code>请求Method /路径(请求URI) 协议版本</code></li></ul></li><li><p><strong>请求头</strong></p><ul><li><font color=red>请求头中至少包含以下信息</font><ul><li>客户端要访问的服务器主机地址 Host: m.baidu.com</li></ul></li><li>请求头中还可以包含以下附加信息（<strong>可选的请求首部字段</strong>）<ul><li>客户端的类型，客户端的软件环境User-Agent: iPhone AppleWebKit</li><li>客户端所能接收的数据类型Accept: text/html, <em>/</em></li><li>客户端的语言环境Accept-Language: zh-cn</li><li>客户端支持的数据压缩格式Accept-Encoding: gzip</li><li>访问结束后，是否断开连接Connection: Close</li></ul></li></ul></li><li><p><strong>请求体(可选)</strong></p><ul><li>客户端发给服务器的具体数据，例如要上传的文件数据（<strong>内容实体</strong>）</li><li>请求格式<ul><li>每一项请求信息末尾使用 \r\n</li><li>最后一个请求项末尾使用 \r\n\r\n 表示请求结束</li></ul></li></ul></li></ul><img src="/images/ComNet/http-req-msg.png" style="zoom:70%"><h4 id="2-请求方法Method"><a href="#2-请求方法Method" class="headerlink" title="2. 请求方法Method"></a>2. 请求方法Method</h4><blockquote><p>HTTP 协议的请求行有一个请求方法, 它有 8 种, 但是我们只要了解五种 (GET,POST,HEAD,DELETE,PUT)。</p></blockquote><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p><p>方法的作用在于：可以指定请求的资源按期望产生某种行为。</p><img src="/images/ComNet/http-req-method.png" style="zoom:70%"><p>HTTP/1.0和HTTP/1.1支持的方法：(LINK和UNLINK已被HTTP/1.1废弃，不再支持)</p><img src="/images/ComNet/http-req-method2.png" style="zoom:70%"><h5 id="1-GET"><a href="#1-GET" class="headerlink" title="1) GET"></a>1) GET</h5><ol><li>GET 的本质是“得”，从服务器拿数据，效率更高。<font color=red>GET请求能够被缓存，保存在 Cache 目录中 \bundleId 下 Cache.db 中</font><ul><li>cfurl_cache_receiver_data，缓存所有的请求数据</li><li>cfurl_cache_response，缓存所有的响应</li></ul></li><li>在 HTTP 协议定义中，没有对 GET 请求的数据大小限制，不过因为浏览器不同，一般限制在 2~8K 之间</li><li>所有的参数包装在URL中，并且服务器的访问日志会记录，不要传递敏感信息</li></ol><p><font color=red>GET实现网址跳转的原理：</font></p><ul><li>拼接网址，然后跳转。在URL添加参数, 首先在URL 添加一个? , 表示要追加参数, 多个参数用&amp; 连接，然后跳转到这个拼接后的网址</li><li>格式:<a href="http://127.0.0.1/login.php">http://127.0.0.1/login.php</a> ? username = aaa &amp; password = bbb(username和password是服务器后台给我们的文档中固定的)</li><li>注意：<ul><li>http 默认的请求的方法就是GET，是网络访问使用频率最好的方法。</li><li>GET请求能够被缓存(存储在沙盒Cache中，电脑浏览器也可以缓存在历史记录，服务器也可以缓存)(一般来讲用get请求过的网页，下次可能会快点)</li><li><font color=red>如果URL中有中文或者空格，创建出来的URL是空的</font> ，程序会崩溃需要进行%号转义，对URL 进行编码<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[urlString stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-POST"><a href="#2-POST" class="headerlink" title="2) POST"></a>2) POST</h5><ol><li>POST 的本质是<font color=red>“给”</font>，向服务器发送数据，也可以获得服务器处理之后的结果，效率不如 GET</li><li>POST请求不能被缓存</li><li>POST提交数据比较大，大小靠服务器的设定值限制，PHP通常限定 <font color=red>2M</font></li><li>URL中，只有资源路径，但不包含参数，<font color=red>服务器日志不会记录参数</font>，相对更安全</li><li>参数被包装成二进制的数据体，<font color=red>放在请求体中</font>，格式与 GET 基本一致，只是不包含 ?</li></ol><p>所有设计用户隐私的数据（密码，银行卡号）一定记住使用 POST 方式传递</p><p><font color=red>POST代码中，要用NSMutableURLRequest，要设置HTTPMethod和HTTPBody</font></p><h5 id="3-GET-和-POST-的区别"><a href="#3-GET-和-POST-的区别" class="headerlink" title="3) GET 和 POST 的区别"></a>3) GET 和 POST 的区别</h5><p><strong>显示：</strong></p><ul><li>Post传输数据时，不需要在URL中显示出来，是写在请求体中的，格式一样，没有 ？号，而Get方法会在URL中显示参数值、文件名字。</li><li>get提交格式：url后跟着”?”，由于客户端可能向服务器提交多个键值对，键值对之间用”&amp;”进行分割，如果url中有汉字、特殊符号，则需要对url进行编码</li></ul><p><strong>大小：</strong></p><ul><li><font color=red>http 协议中的 get/post 并没有发送数据大小的限制</font>，对发送数据大小产生限制的是浏览器以及操作系统、服务器。<font color=red>http 本身并没有对 url 长度有所限制。</font></li><li>IE 对 URL 长度的限制是 2083字节（&lt;=IE 8）。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统以及服务器的支持。而 chrome 遇到长度很长的 URL 时，会直接 崩溃。URL 长了，对服务器处理本来也是一种负担</li></ul><p><strong>缓存：</strong></p><ul><li>GET会被手机端cache、web浏览器历史记录、服务器各种缓存，POST不会</li></ul><p><strong>规定：</strong></p><ul><li>根据HTTP规范：Post就是为了将数据传送到服务器段，Get就是为了从服务器段取得数据。而Get之所以也能传送数据，只是用来设计告诉服务器，你到底需要什么样的数据。Post的信息作为http请求的内容，而Get是在Http头部传输的。 </li></ul><p><strong>选择：</strong></p><ul><li>一般来讲：开发的时候，这个都是后台告诉我们的</li><li>而如果是自己写,前台后台都是由我们决定的，可以自由选取使用的方式，当某种方式无法实现需求时，再去进行更改，但就提交普通的文本数据而言get跟post是一致的，post所谓的安全性跟get相比也只是多一些而已</li></ul><p>在web中：</p><ul><li>如果要传递大数据量不能用get，必然要type=“file”上传文件，type:”password”传递密码或者<code>&lt;textarea&gt;</code>提交大量文本字段。</li><li>表单域只有设定了name属性的表单元素才会被提交给服务器</li><li>如果给submit按钮设定了name，那么按钮的value也会被提交到服务器</li><li>对于post的表单重新敲地址栏再刷新就不会提示重新提交了，因为重新敲地址就没有偷偷提交的数据了。</li></ul><h5 id="4-POST增强"><a href="#4-POST增强" class="headerlink" title="4) POST增强"></a>4) POST增强</h5><p>包括：</p><ul><li>上传单文件</li><li>上传多文件</li><li>POST JSON</li><li>POST 自定义对象(对象转字典)</li></ul><p>小文件上传</p><ul><li><p>大小一般都是有限制的 <font color=red>2-8k</font> ，php默认限制是 <font color=red>2M</font> ，超过2M的部分上传不上去的，新浪微博上传图片，单张最大允许 <font color=red>5M</font></p></li><li><p>单个小文件</p><p>应用场景：上传用户的头像</p></li><li><p>多个小文件</p><p>应用场景：微信朋友圈，微博</p></li></ul><h4 id="3-常见的其他请求头字段"><a href="#3-常见的其他请求头字段" class="headerlink" title="3. 常见的其他请求头字段"></a>3. 常见的其他请求头字段</h4><img src="/images/ComNet/请求.jpeg" style="zoom:75%;" /><ul><li>User-Agent<ul><li>浏览器的具体类型　　</li><li>如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0</li></ul></li><li>Accept<ul><li>浏览器支持哪些数据类型　　</li><li>如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;</li></ul></li><li>Accept-Charset<ul><li>浏览器采用的是哪种编码　　</li><li>如：Accept-Charset: ISO-8859-1</li></ul></li><li>Accept-Encoding<ul><li>浏览器支持解码的数据压缩格式　　</li><li>如：Accept-Encoding: gzip, deflate</li></ul></li><li>Accept-Language<ul><li>浏览器的语言环境　　</li><li>如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</li></ul></li><li>Host<ul><li>请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:<a href="http://www.baidu.com/">www.baidu.com</a></li></ul></li><li>Connection<ul><li>表示是否需要持久连接。Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive</li></ul></li><li>Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。</li><li>Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</li><li>Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</li><li>Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</li><li>Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: <a href="http://www.baidu.com/">http://www.baidu.com/</a></li></ul><h3 id="4-3-3-响应报文"><a href="#4-3-3-响应报文" class="headerlink" title="4.3.3 响应报文"></a>4.3.3 响应报文</h3><blockquote><p>服务器对客户端的请求做出的反应，一般指返回数据给客户端</p></blockquote><h4 id="1-格式-1"><a href="#1-格式-1" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的 HTTP 响应报文包含以下内容：</p><ul><li><strong>状态行</strong><ul><li>格式：<code>HTTP协议版本 状态码 用以解释状态码的原因短语</code>。</li></ul></li><li><strong>响应头</strong><ul><li>服务器返回给客户端的一些额外信息，包含了对服务器的描述、对返回数据的描述<ul><li>服务器的类型Server: Apache/2.4.10 (Unix) PHP/5.5.20</li><li>返回数据的类型Content-Type: text/html</li><li>返回数据的长度Content-Length: 660</li><li>响应时间Date: Thu, 04 Jun 2015 19:31:50 GMT</li><li>ETag(HASH值，用于检测本地资源和服务器资源是否一致)ETag: “294-4e1862f57e7c0”</li></ul></li></ul></li><li><strong>实体内容</strong><ul><li>服务器返回给客户端的具体二进制数据。如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。</li></ul></li></ul><img src="/images/ComNet/http-res-msg.png" style="zoom:65%"><h4 id="2-响应的状态码"><a href="#2-响应的状态码" class="headerlink" title="2. 响应的状态码"></a>2. 响应的状态码</h4><p>作用：当客户端向服务器发送请求时，描述请求的返回结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><table><thead><tr><th></th><th><strong>类别</strong></th><th><strong>原因短语</strong></th></tr></thead><tbody><tr><td>1XX</td><td>信息状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求，客户端的请求有错误</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table><img src="/images/ComNet/res-status-code.jpg" alt="图片" style="zoom:90%;" /><h4 id="3-响应的content-Type"><a href="#3-响应的content-Type" class="headerlink" title="3. 响应的content-Type"></a>3. 响应的content-Type</h4><ul><li>Content-Type：text/html; charset=utf-8表示返回数据的类型</li><li>服务器通过Content-Type告诉客户端<strong>响应的数据的类型</strong>，这样<strong>浏览器就根据返回数据的类型来进行不同的处理</strong>：<ul><li>如果是图片类型就显示：image/jpeg</li><li>如果是文本类型就直接显示内容：text/plain</li><li>如果是文本类型的html格式就用浏览器渲染该格式：text/html</li><li>……</li></ul></li><li>常用Content-Type：text/html、image/gif、image/jpeg、text/plain、text/javascript…</li><li>Content-Length:表示响应报文体的字节长度，报文头只是描述，返回的具体数据在两个回车之后的内容中</li></ul><p>默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；</p><p>比如，我们返回的是一段HTML，但是没有指定格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res1.jpg" alt="图片" style="zoom:100%;" /><p>但是，如果我们指定了格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf8&quot;</span>);</span><br><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res2.jpg" alt="图片" style="zoom:90%;" /><p>如果我们希望返回一段JSON数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-常见的其他响应头字段"><a href="#4-常见的其他响应头字段" class="headerlink" title="4) 常见的其他响应头字段"></a>4) 常见的其他响应头字段</h4><img src="/images/ComNet/响应.jpeg" alt="响应" style="zoom:90%;" /><ul><li><p>Cache-Control </p><ul><li>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 </li><li>下面的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。</li><li><code>Cache-Control: max-age=3600</code></li></ul></li><li><p>ETag</p><ul><li>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。</li><li><code>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></li></ul></li><li><p>Location</p><ul><li>我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：</li><li><code>Location: http://www.google.com.hk</code></li></ul></li><li><p>Set-Cookie</p><ul><li>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。</li><li><code>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</code></li></ul></li></ul><h3 id="4-3-4-HTTP—持久连接"><a href="#4-3-4-HTTP—持久连接" class="headerlink" title="4.3.4 HTTP—持久连接"></a>4.3.4 HTTP—持久连接</h3><p>早期的HTTP连接模型：每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销</p><img src="/images/ComNet/http-short-connect.png" style="zoom:70%"><p><strong>在 HTTP 1.0 中</strong>, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加<code>Connection: Keep-Alive</code>，然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中<code>Connection: Keep-Alive</code>。</p><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p><p><strong>HTTP持久连接</strong>（<strong>HTTP persistent connection</strong>，也称作<strong>HTTP keep-alive</strong>或<strong>HTTP connection reuse</strong>）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。</p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。然而， Apache 2.0 httpd 的<strong>默认连接过期时间</strong>是仅仅15秒，对于 Apache 2.2 只有5秒。短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。</p><img src="/images/ComNet/http-long-connect.png" style="zoom:70%"><p>特点：只要任意一端没有明确提出断开连接，则保持连接状态。</p><p>好处：</p><ul><li>减少了连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</li><li>减少开销的那部分时间，使HTTP请求和响应能够更早的结束，Web页面显示速度也响应提高</li></ul><h3 id="4-3-5-HTTP—无状态"><a href="#4-3-5-HTTP—无状态" class="headerlink" title="4.3.5 HTTP—无状态"></a>4.3.5 HTTP—无状态</h3><ul><li>HTTP协议是无状态的。使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前的一切的请求或响应报文的信息。</li><li>这是为了更快的处理大量事物，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。正因为HTTP协议本身非常简单，所以才被应用到各种场景</li><li><strong>如果让服务器管理全部客户端状态则会成为很大的负担。</strong>由于不必保存状态，自然可以减少服务器的CPU及内存资源的消耗</li><li>所以哪怕在同一个页面中的js、css、jpg也都要重复的提交Accept-Language、Accept-Encoding、Cookie等</li></ul><h3 id="4-3-6-Cookie"><a href="#4-3-6-Cookie" class="headerlink" title="4.3.6 Cookie"></a>4.3.6 Cookie</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的。</li><li>保留无状态优点的同时又要解决类似的矛盾问题，于是引入了Cookie技术。</li><li>Cookie(曲奇饼)，可以记录服务器与客户端之间的状态</li><li>Cookie是一个由浏览器和服务器共同协作实现的规范。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<ul><li>服务器向客户端发送Cookie<ul><li>是在响应头中</li><li>Set-Cookie:name=value; Path=/; Max-Age=; Domain=*.com<ul><li>name=value; 必须包含</li><li>Path=/; 表示Cookie影响的路径，当访问路径不匹配时，浏览器不会发送该Cookie。<code>/</code>表示该请求下所有路径都发送，也可以指定子路径。</li><li>Max-Age：告诉浏览器该Cookie多长时间过期，单位为秒</li><li>HttpOnly：告知浏览器不允许通过脚本document.cookie访问</li></ul></li></ul></li><li>浏览器将Cookie保存</li><li>之后在每一次请求中浏览器都会将Cookie发向服务器。此时服务器就知道是哪个客户端了。<ul><li>Cookie值的格式是 key=value; foo=bar的形式</li><li>客户端发送的Cookie在请求报文的Cookie字段中</li></ul></li></ul></li></ul><img src="/images/ComNet/http-cookie-no.png" style="zoom:60%"><img src="/images/ComNet/http-cookie-yes.png" style="zoom:60%"><p>Cookie-请求响应报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.客户端第一次请求报文</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">* 首部字段内没有Cookie的相关信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.服务器端响应报文（生成Cookie信息）</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, =&gt;10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.客户端请求报文（自动发送保存着Cookie的信息）</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure><h4 id="2-Cookie的问题"><a href="#2-Cookie的问题" class="headerlink" title="2. Cookie的问题"></a>2. Cookie的问题</h4><ul><li>不能存储太多内容。因为Cookie体积过大会造成请求和响应速度变慢，所以尽量不要再Cookie中存储大量数据</li><li>将静态资源存储在单独的机器上避免Cookie的无效传输</li><li>不安全。Cookie可以在前后端修改，数据容易被篡改和伪造。所以Cookie对于敏感数据的保护基本是无效的</li></ul><h3 id="4-3-7-Session"><a href="#4-3-7-Session" class="headerlink" title="4.3.7 Session"></a>4.3.7 Session</h3><ul><li>为了解决Cookie无法存储大量数据，以及不安全的问题，Session被设计出来了。</li><li>Session的数据是只保留在服务器端的，客户端无法修改。</li><li>Session不是什么新技术，是基于Cookie实现的。需要和cookie搭配来使用</li><li>服务器端保存key（口令）/value（数据）对象，客户端保存，key（口令），一旦口令被篡改，就丢失了映射关系。服务器端用cookie里面的key来查找对应的session值。</li><li>session可以存在内存或硬盘上都可以。<ul><li>将Session集中化，使用Redis、Memcached等高效的缓存服务器技术</li></ul></li></ul><p>Session的口令依旧保存在客户端，还是存在口令被盗用和伪造的情况，解决方案是将口令通过私钥加密进行签名，使得伪造成本更高</p><h3 id="4-3-8-HTTP-2-0"><a href="#4-3-8-HTTP-2-0" class="headerlink" title="4.3.8 HTTP 2.0"></a>4.3.8 HTTP 2.0</h3><p>HTTP2.0了解吗，相比之前的优化</p><ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送： <a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">HTTP/2 服务器推送（Server Push）教程</a> 也得先客户端发起请求，只不过服务器可以额外推送几个附带资源(不用请求)而已，是需要配置的。</li></ul><h2 id="4-4-TCP-UDP协议-端口号"><a href="#4-4-TCP-UDP协议-端口号" class="headerlink" title="4.4 TCP/UDP协议 - 端口号"></a>4.4 TCP/UDP协议 - 端口号</h2><h3 id="4-4-1-TCP-UDP协议"><a href="#4-4-1-TCP-UDP协议" class="headerlink" title="4.4.1 TCP/UDP协议"></a>4.4.1 TCP/UDP协议</h3><p><strong>TCP(传输控制协议) —生成流式Socket</strong></p><ul><li>建立连接，形成传输数据的通道，在连接中进行<font color=red>大数据传输</font>(数据大小不受限制)</li><li>通过三次握手完成连接，是<font color=red>可靠协议</font>，能安全送达，但是由于必须建立连接，所以<font color=red>效率会稍低</font>.</li></ul><p><strong>TCP三次握手</strong></p><ol><li>客户端向服务器发送一个包，然后等服务器确认 （在吗）</li><li>服务器收到包，确认，然后发送给客户端一个包 （在）</li><li>客服端收到确认，再想服务器发送一个包 （那我就发数据了）</li></ol><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据</p><p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>UDP(数据报协议) —生成数据报Socket</strong></p><ul><li>将数据源和目的封装成数据包中，<font color=red>不需要建立连接</font>，只管发送，不确认对方是否接收到因为无需连接，因此是不可靠协议。不需要建立连接，速度快</li><li>每个数据报的<font color=red>大小限制在64K之内</font></li><li>应用场景：多媒体教室／网络流媒体/直播平台/游戏</li></ul><p><strong>对比：</strong></p><ul><li>TCP只是网络七大层协议中的一种，需要封装七层的，</li><li>UDP 使用UDP协议，是不用使用七大层封装的，可以直接发出去，这样的坏处就是会丢包，但也有好处：速度更块，实时性更好<ul><li>应用场景：网络直播(即使丢了几帧也没事)</li></ul></li><li><font color=red>TCP和UDP的表现形式，可以比喻为打电话 比 对讲机</font><ul><li>前者可以听的同时也说(也就是发送的时候，也可以接受)</li><li>后者只能发或者接，不能同时接发</li></ul></li><li>像腾讯微信QQ，语音对讲表现形式虽然是UDP，但是因为丢包，所以实质上是使用的TCP(刚开始使用的是UDP，后来改的)，像好多大公司，一般都会自己写底层协议</li></ul><h3 id="4-4-2-端口号"><a href="#4-4-2-端口号" class="headerlink" title="4.4.2 端口号"></a>4.4.2 端口号</h3><p><strong>端口号</strong></p><ul><li>用于标示进程的逻辑地址，不同进程的标示。</li><li>一条进程一定程度上可以表示是一个应用程序，但是有区别：一个“应用程序”一定可以找到一个“进程”，但一个“进程”不一定会有一个“应用程序”与之对应，这些进程有可能是后台程序，用户看不到，感觉不到。</li></ul><p><strong>作用：</strong></p><ul><li>让应用层的各种应用进程都能将其数据通过端口向下交付给运输层。即<font color=red>连接应用层与网络层</font></li><li><font color=red>端口号存在于UDP和TCP报文的首部，而协议号则是存在这个IP数据报的首部.</font></li></ul><p><strong>有效端口：</strong></p><ul><li>0<code>~</code>65535，其中 0~1024由系统使用或者保留端口，开发中我们不要使用 1024 以下的端口，是可以省略的，不写表明使用协议默认的端口号。</li><li>浏览器网页浏览：<ul><li>http默认80</li><li>https默认443</li></ul></li><li>FTP默认20/21/990</li><li>QQ的端口号：由于QQ用的是UDP协议，默认通讯端口是4000，如果4000被占用的话，那么它就会自动改用4001端口，再被占用，以此类推。</li><li>在mac的活动监视器里可以看到一条条的进程对应的端口号</li></ul><h2 id="4-5-IP协议-协议号"><a href="#4-5-IP协议-协议号" class="headerlink" title="4.5 IP协议 - 协议号"></a>4.5 IP协议 - 协议号</h2><blockquote><p>IP协议是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据到了网络层都要经过IP协议的封装，以IP数据报格式传输。它的特点如下:</p></blockquote><p><strong>不可靠（unreliable）</strong></p><ul><li>意思是它不能保证 IP数据报能成功地到达目的地。</li><li>IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， IP有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li></ul><p><strong>无连接（connectionless）</strong></p><ul><li>意思是IP并不维护任何关于后续数据报的状态信息。</li><li>每个数据报的处理是相互独立的。这也说明， IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B） ，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li></ul><p><strong>协议号</strong></p><ul><li>其他，太深入的模块，在这里不做赘述，网络层，经过IP协议封装之后，会生成一个协议号：</li><li>协议号是存在于IP数据报的首部的20字节的固定部分，占有8bit.该字段是指出此数据报所携带的是数据是使用何种协议，以便目的主机的IP层知道将数据部分上交给哪个处理过程。也就是协议字段告诉IP层应当如何交付数据。</li><li><font color=red>简单来讲，协议号连接网络层与数据链路层</font></li></ul><h2 id="4-6-TCP-IP协议与socket"><a href="#4-6-TCP-IP协议与socket" class="headerlink" title="4.6 TCP/IP协议与socket"></a>4.6 TCP/IP协议与socket</h2><h3 id="4-6-1-TCP-IP协议"><a href="#4-6-1-TCP-IP协议" class="headerlink" title="4.6.1 TCP/IP协议"></a>4.6.1 TCP/IP协议</h3><p>是个名词，并不是TCP和IP放在一起说了，中文名叫做<font color=red>传输控制协议/互联网络协议</font>，是一种网络通信协议，它规范了网络上的所有通信设备，数据<font color=red>往来格式以及传送方式(传输)。</font></p><p><font color=red>TCP/IP协议是网络的基础，是Internet的语言。</font></p><p>关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p><blockquote><p>我们在<font color=red>传输数据时，可以只使用(传输层网络层)TCP/IP协议</font>，但是那样的话，没有应用层，便无法识别数据内容。</p><p>如果想要使传输的数据有意义，则必须使用到应用层HTTP协议。<font color=red>应用层提供了封装或者显示数据的具体形式</font></p></blockquote><h3 id="4-6-2-socket-套接字层、插座"><a href="#4-6-2-socket-套接字层、插座" class="headerlink" title="4.6.2 socket(套接字层、插座)"></a>4.6.2 socket(套接字层、插座)</h3><p>实际上socket就是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(<font color=red>API，内部按照TCP/IP协议对数据封包解包，并记录生成的端口号与IP地址</font>)。Socket的出现只是使我们程序员能够更方便的使用TCP/IP协议栈而已，是对TCP/IP的抽象。</p><p>通过Socket，我们能更好地使用TCP/IP协议。</p><p>通信的两端，也就是客户端和服务器都有 Socket(IP地址和端口号两部分)，所以可以说网络通信其实就是在 Socket 间的通信。数据在两个 Socket 间通过 IO 传输 (input/output，<font color=red>一个请求可以看做一次IO传输</font>)</p><p>Socket 是纯C语言的，是跨平台的<strong>使用socket替代HTTP做网络请求</strong></p><h4 id="1-socket通讯的原理"><a href="#1-socket通讯的原理" class="headerlink" title="1. socket通讯的原理"></a>1. socket通讯的原理</h4><p><img src="/images/ComNet/socket%E5%8E%9F%E7%90%86.jpg" alt="img"></p><h4 id="2-C版本的socket通讯"><a href="#2-C版本的socket通讯" class="headerlink" title="2. C版本的socket通讯"></a>2. C版本的socket通讯</h4><img src="/images/ComNet/socket移动端代码.png" alt="img" style="zoom:90%;" /><p>网络通讯链中，将应用层省去，用Socket做网络请求，HTTP的内容：设置服务器的信息等</p><ol><li><p>创建socket</p><p>使用socket函数。返回值是int ,&gt;0就表示成功</p></li><li><p>创建服务器，并将我们创建的socket连接到服务器</p><p>使用connect函数。返回值是int：0代表连接成功，其他失败)</p></li><li><p>向服务器发送消息</p><p>使用send函数。返回值：如果成功返回发送的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>接收服务器返回的数据</p><p>使用recv函数。返回值：如果成功返回数据的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>关闭连接</p><p>clock(创建的socket)</p></li></ol><p>iOS移动端有一个封装的很好的socket套接字库：GCDAsyncSocket</p><h2 id="4-7-长连接与短连接"><a href="#4-7-长连接与短连接" class="headerlink" title="4.7 长连接与短连接"></a>4.7 长连接与短连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p><strong>短连接</strong></p><p>数据请求结束后，立即断开连接，能够及时释放服务器资源</p><p>让服务器能够为更多的用户提供服务</p><p><strong>长连接</strong></p><p>一旦连接建立之后，始终保持连接状态，后续只需发送和接收数据即可，数据响应更及时</p><p>长连接对服务器资源占用比较大</p><p>对交互响应要求快的应用，例如即时通讯，需要使用长连接</p><p><strong>心跳包</strong></p><p>是检测长连接的重要技术手段</p><p>可以由服务器发送，定时向客户端发送小数据，根据回执判断客户端是否在线</p><p>也可以由客户端发送，定时向服务器发送小数据，报告客户端当前在线</p><h1 id="五、网络编程相关概念"><a href="#五、网络编程相关概念" class="headerlink" title="五、网络编程相关概念"></a>五、网络编程相关概念</h1><h2 id="5-1-URL"><a href="#5-1-URL" class="headerlink" title="5.1 URL"></a>5.1 URL</h2><ul><li>Uniform Resoure Locator：统一<strong>资源</strong>定位器</li><li>URL地址格式排列为：scheme://host:port/path<ul><li>Internet资源类型（scheme）：指出WWW 客户程序用来操作的工具。</li><li>服务器地址（host）：指出WWW 页所在的服务器域名</li><li>端口（port）：有时（并非总是这样），对某些资源的访问来说，需给出相应的服务器提供端口号</li><li>路径（path）：指明服务器上某资源的位置</li></ul></li></ul><h2 id="5-2-IP地址、域名与DNS服务器"><a href="#5-2-IP地址、域名与DNS服务器" class="headerlink" title="5.2 IP地址、域名与DNS服务器"></a>5.2 IP地址、域名与DNS服务器</h2><h3 id="5-2-1-IP地址"><a href="#5-2-1-IP地址" class="headerlink" title="5.2.1 IP地址"></a>5.2.1 IP地址</h3><p>ip唯一标识 一台设备</p><p>端口号标识一个设备上的应用</p><p>几个特殊的IP地址</p><table><thead><tr><th>IP地址</th><th>含义</th></tr></thead><tbody><tr><td>localhost</td><td>代表本机地址。不走网卡</td></tr><tr><td>127.0.0.1</td><td>代表本地回环地址。走网卡</td></tr><tr><td>192.168.xx.xx</td><td>代表局域网的IP地址。不管是否是本机，会通过网卡发请求给路由或交换机，在请求回来到指定的电脑</td></tr><tr><td>0.0.0.0</td><td>代表任意的IP地址</td></tr><tr><td>255.255.255.255</td><td>广播地址</td></tr></tbody></table><p><strong>协议域：（数字最大就是255）</strong></p><ul><li>IPV4：有四段</li><li>IPV6：有六段</li></ul><h3 id="5-2-2-域名"><a href="#5-2-2-域名" class="headerlink" title="5.2.2 域名"></a>5.2.2 域名</h3><ul><li>是一串用点分隔的名字组成的Internet上，一台计算机或者一个计算机组的名称，用来标识位置</li><li>.com国际域名 全世界都可以访问 </li><li>.cn中国域名</li></ul><p><strong>两者之间的关系？</strong></p><p>如果是前者，那么一个域名对应一个IP，如果是后者，例如百度这种大公司，肯定是个计算机组，那么这个域名下面就有好多个服务器，也就是好多个IP，并且我们通过访问主机域名，百度返回得到的IP是随机的</p><h3 id="5-2-3-DNS服务器"><a href="#5-2-3-DNS服务器" class="headerlink" title="5.2.3 DNS服务器"></a>5.2.3 DNS服务器</h3><p>注意：我们不是通过域名找到服务器的，而是通过IP地址找到的，</p><p>我们访问域名— <font color=red>DNS域名解析服务器帮我们把域名转换成IP地址</font>—DNS返回给我们的电脑— 电脑通过IP地址找到服务器</p><p>(我们一连接上网络，在网络信息中就可以看到我们的DNS服务器)</p><p>举例：如果我们的电脑网络能上QQ等软件，但是浏览器不能上，很有可能就是DNS服务器出问题了，这个时候：要么直接输入我们要访问的网站的IP地址，要么换一个DNS服务器，谷歌提供了一个8.8.8.8，我们可以使用。</p><h2 id="5-3-端口号"><a href="#5-3-端口号" class="headerlink" title="5.3 端口号"></a>5.3 端口号</h2><h3 id="5-3-1-端口的分类"><a href="#5-3-1-端口的分类" class="headerlink" title="5.3.1 端口的分类"></a>5.3.1 端口的分类</h3><ul><li>端口范围：0-65535之间。端口的意义：用来区分不同的进程。</li><li>端口分为以下三类：<ul><li>公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯 明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯,ftp21,smtp25,….。</li><li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于 这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li></ul></li><li>动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端 口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li></ul><h3 id="5-3-2-使用"><a href="#5-3-2-使用" class="headerlink" title="5.3.2 使用"></a>5.3.2 使用</h3><p>IP能够定位机器，端口号可以定位一个应用程序</p><ul><li>node 默认是3000 多了往上加</li><li>Apache服务器，访问资源<ul><li>部署：丢到服务器软件配置的根目录下</li><li>访问：ip+刚开始配的服务器根目录下的要访问的文件的路径</li></ul></li><li>node服务器，访问资源<ul><li>部署：不需要配置根目录，只需要一个js文件。<ul><li>这个js文件中必须配置了端口号，集成了http核心模块的功能。 </li><li>如果做了下面这些操作，node+文件名，命令行中会一直卡在这里，进程一直在开启着，别人可以访问<br>如果只是一个普通的js文件，node+文件名，一下子就执行完了。做不到一直开启的状态。</li></ul></li><li>访问：ip+端口号+此项目中文件名<ul><li>浏览器中访问，肯定是上面要齐全</li><li>如果是html中写url的时候，如果是访问的本项目中的文件(不管是后台文件 还是前端文件)，可以直接写相对路径，比如url: ‘./app.js’</li><li>端口号：默认3000，如果你开了好几个node项目，那就需要注意，端口号要一致。</li><li>文件名：如果不写，默认是会主动运行这个项目中的index.html文件，一般服务器都会做这个设置，到了nodejs中，因为所有请求都是这个js文件接收的，所以一般都会写这么个代码。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pathname == <span class="string">&#x27;/&#x27;</span> &amp;&amp; req.method == <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, <span class="string">&#x27;index.html&#x27;</span>), <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>注意：</p><ul><li>我们所有对这个端口的访问，都是这个js文件，接收，并处理的。与其他的服务器不一样。<ul><li>比如：Apache，就是我配置了根目录，你想访问什么文件，拿到那个文件的路径就可以，到时候，你的访问是这个文件进行处理。具体代码见笔记中两个js文件</li><li>但nodejs不一样，比如：你要通过这个端口号访问 :3000/public/index.html。这个时候，是js文件接收到这个请求，然后将public/index.html文件的内容readFild读出来，然后返给前端。</li></ul></li><li>一个js文件一个端口号，我们可以同时node + 文件名，同时开启好几个node项目，但是注意端口号要区分开</li></ul><h2 id="5-4-浏览器中跨域的场景"><a href="#5-4-浏览器中跨域的场景" class="headerlink" title="5.4 浏览器中跨域的场景"></a>5.4 浏览器中跨域的场景</h2><ul><li><p>域名不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.com</span><br><span class="line">www.liuxi.com 即为不同的域名</span><br></pre></td></tr></table></figure></li><li><p>二级域名相同，子域名不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.wu.com </span><br><span class="line">www.liuxi.wu.com 为子域不同</span><br></pre></td></tr></table></figure></li><li><p>端口不同，协议不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.wuyou.com </span><br><span class="line">https:&#x2F;&#x2F;www.wuyou.com</span><br><span class="line">www.wuyou.con:8888</span><br><span class="line">www.wuyou.con:8080</span><br></pre></td></tr></table></figure></li></ul><p>前端需要用到跨域的地方：</p><ul><li>加载图片，文件资源。很少会跨域，你用别人的网站图片是另一码事……</li><li>ajax请求。</li></ul><ol><li><p><code>使用ctn节点，进行动静资源分离</code>时，也就是说，我们的前端文件，与需要的后端文件，就没在一个项目里</p></li><li><p>我们后段需要请求别的端口号，或者说是别的服务器项目中的后台文件，这个时候，按理说不应该是前端的任务，正儿八经的，应该是前端文件所在项目中的后台文件，帮我们把数据请求回来，因为他们是不存在跨域的，</p></li></ol><p><font color='red'>跨域是浏览器限制的</font></p><p>但是，如果后台的人不给我们做这一步(它是个半瓶水，或者是个棒槌) 或者 说这个接口做了，用几天就不用了(比如双十一这种暂时的活动接口)，那就需要我们进行jsonp跨域请求了,</p><p>由上面可知，用到跨域的情形还是挺少的，而且我们前面讲过如何解决跨域：</p><ul><li>jsonp</li><li>自己写个php后台文件，请求数据做中转。</li><li>如果只是调试阶段有跨域，我们有浏览器插件</li></ul><h2 id="5-5-前后端分离"><a href="#5-5-前后端分离" class="headerlink" title="5.5 前后端分离"></a>5.5 前后端分离</h2><p>顾名思义，前后端分离就是把一个应用的前端代码和后端代码分开来写，为什么要这样做呢？先说说不分开会有什么问题，在传统的 Java Web 开发模式中，前端页面使用 JSP，而 JSP 代码的开发往往不是完全由后端程序猿来完成的。</p><p>JSP 页面的开发步骤是首先需要前端程序猿完成 HTML 代码，然后交给后端程序猿转为 JSP 再进行开发，后端如果遇到页面问题，就需要找前端来解决，但是此时前端看到的代码已经不是他之前写的 HTML 了，是混合了一大堆标签的 JSP 代码，而前端又不懂 JSP，场面就非常尴尬。</p><h2 id="5-6-网站的优化"><a href="#5-6-网站的优化" class="headerlink" title="5.6 网站的优化"></a>5.6 网站的优化</h2><ul><li>网页中如果有图片、css、js等外部文件的话，图片、css、js都在单独的请求中，也就是并不是页面的所有内容都在一个请求中完成，而是每个资源都有一个请求</li></ul><p>思想</p><ul><li>能压缩的压缩能合并的合并：少一个script也好，少一次请求  </li><li>少用js去遍历对象或者写for循环</li><li>能提前运算好的提前运算好，使用枚举法 <code>var a=1024*1024;</code>这么写一点都不好</li><li>流式(响应式)图片 — 图片压缩</li></ul><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td></tr><tr><td>请求带宽</td><td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td></tr><tr><td>缓存利用</td><td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免CSS表达式，避免重定向</td></tr></tbody></table><p>雅虎14条优化原则</p><ul><li>减少HTTP请求数<ul><li>合并脚本和样式表：分开时分开。就很多网站因为首页的访问量太大，将首页的css和js直接写在页面文件中而不是外部引用。</li><li>CSS Sprites：页面上的背景图片合并为一张，通过css的background-position属性定义不同的值来取背景。<a href="https://links.jianshu.com/go?to=http://www.csssprites.com/">http://www.csssprites.com/</a>可帮助将上传的图片合并并给出对应的background-position坐标。</li></ul></li><li>使用CDN（Content Delivery Network）：从最近的CDN节点请求数据</li><li>添加Expire头，或者Cache-control。通过缓存减少请求数</li><li>Gzip组件。<ul><li>通过压缩减少文件传输的大小。</li><li>所有的文件内容都应该被压缩。</li></ul></li><li>将CSS样式放在页面的上方。一次渲染</li><li>将script放在页面最下面<ul><li>防止脚本阻塞页面的下载，减少页面可视元素的加载时间。（防止页面加载中途去下载脚本）</li><li>防止脚本阻塞并行下载数量</li></ul></li><li>避免在CSS中使用Expressions</li><li>把javascript和css都放到外部文件中<ul><li>把css和js写在页面内容可减少两次请求，但也增大了页面的大小。使用外部文件，如果做了缓存，也不会有两次多余的http请求。</li><li>要视情况而定，参见第一点。</li></ul></li><li>减少DNS查询。减少DNS解析过程、加快页面加载速度。建议一个页面所包含的域名数量尽量控制在2-4个。</li><li>压缩JavaScript和CSS。<ul><li>通过压缩，减少页面字节数，从而提高加载速度，同时还可以起到一定的保护作用。</li><li>但是会丧失可读性，阿里巴巴是在发布的时候在服务器端进行压缩。</li></ul></li><li>避免重定向。增加一次冲重定向就会增加一次web请求。</li><li>移除重复的脚本</li><li>配置实体标签（ETags）</li><li>使AJAX缓存</li></ul><h2 id="5-7-在地址栏输入网址后页面是如何呈现的？"><a href="#5-7-在地址栏输入网址后页面是如何呈现的？" class="headerlink" title="5.7 在地址栏输入网址后页面是如何呈现的？"></a>5.7 在地址栏输入网址后页面是如何呈现的？</h2><ul><li>DNS 把域名转化成ip<ul><li>DNS服务器来做这个事情</li><li>运营商提供的dns服务器</li></ul></li><li>CDN 内容分发网络</li></ul><p>输入 URL：<a href="http://www.baidu.com/">http://www.baidu.com</a></p><ul><li>DNS 域名解析<ul><li>计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置</li><li>在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口）</li><li>158.12.25.652  域名就是为了好记</li><li>为了好记，所以我们的 万维网提供了 一个 域名这样的概念</li><li>当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器</li></ul></li><li>将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器<ul><li>浏览器将用户输入的 URL 地址根据HTTP协议 封装成了  http 请求报文（请求头+请求行+请求体）</li><li>该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器</li></ul></li><li>后台服务器接收到用户HTTP Request 请求报文<ul><li>后台服务器接收到 客户端发送给自己的数据（二进制数据）<ul><li>首先把二进制数据按照编码解析成字符（人类可以识别的）</li><li>解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来</li></ul></li></ul></li><li>后台服务器处理用户请求信息<ul><li>当得到用户请求报文之后，根据请求报文中的 get、post取出URL中的查询字符串 或者 请求体中的数据</li><li>根据用户的特定的请求数据做特定的处理</li></ul></li><li>后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端<ul><li>当我们解析和处理完用户请求报文消息之后</li><li>服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文</li><li>响应头、响应字段、响应体</li><li>该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端</li><li>发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单</li></ul></li><li>用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码<ul><li>当客户端解析到 服务器发送过来的 二进制数据</li><li>客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串</li><li>然后根据 HTTP 协议，解析服务器发送过来的 响应报文</li><li>然后根据响应报文中的报文内容（报文头、报文体）做具体的解析</li></ul></li><li>当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程：是指&lt;strong&gt;编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。&lt;/p&gt;
&lt;p&gt;我们处于互联网时代，我们可以随时随地通过 Interne</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端日志库设计</title>
    <link href="https://tenloy.github.io/2021/09/08/Log.html"/>
    <id>https://tenloy.github.io/2021/09/08/Log.html</id>
    <published>2021-09-08T18:53:12.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现存问题"><a href="#一、现存问题" class="headerlink" title="一、现存问题"></a>一、现存问题</h2><p>目前，业内移动端日志库大多都存在以下几个问题：</p><ul><li>卡顿，影响性能</li><li>日志丢失</li><li>安全性</li><li>日志分散</li></ul><p>首先，日志模块作为底层的基础库，对上层的性能影响必须尽量小，但是日志的写操作是非常高频的，频繁在Java堆里操作数据容易导致GC的发生，从而引起应用卡顿，而频繁的I/O操作也很容易导致CPU占用过高，甚至出现CPU峰值，从而影响应用性能。</p><p>其次，日志丢失的场景也很常见，例如当用户的App发生了崩溃，崩溃日志还来不及写入文件，程序就退出了，但本次崩溃产生的日志就会丢失。对于开发者来说，这种情况是非常致命的，因为这类日志丢失，意味着无法复现用户的崩溃场景，很多问题依然得不到解决。</p><p>第三点，日志的安全性也是至关重要的，绝对不能随意被破解成明文，也要防止网络被劫持导致的日志泄漏。</p><p>最后一点，对于移动应用来说，日志肯定不止一种，一般会包含端到端日志、代码日志、崩溃日志、埋点日志这几种，甚至会更多。不同种类的日志都具有各自的特点，会导致日志比较分散，查一个问题需要在各个不同的日志平台查不同的日志，例如端到端日志还存在日志采样，这无疑增加了开发者定位问题的成本。</p><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><p>作为一款基础日志库，在设计之初就必须考虑如何解决日志系统现存的一些问题。</p><h3 id="2-1-卡顿，影响性能"><a href="#2-1-卡顿，影响性能" class="headerlink" title="2.1 卡顿，影响性能"></a>2.1 卡顿，影响性能</h3><p>I/O是比较耗性能的操作，写日志需要大量的I/O操作，为了提升性能，首先要减少I/O操作，最有效的措施就是加缓存。先把日志缓存到内存中，达到一定大小的时候再写入文件。为了减少写入本地的日志大小，需要对数据进行压缩，为了增强日志的安全性，需要对日志进行加密。然而这样做的弊端是：</p><ul><li>对Android来说，对日志加密压缩等操作全部在Java堆里面。由于日志写入是一个高频的动作，频繁地堆内存操作，容易引发Java的GC，导致应用卡顿；</li><li>集中压缩会导致CPU短时间飙高，出现峰值；</li><li>由于日志是内存缓存，在杀进程、Crash的时候，容易丢失内存数据，从而导致日志丢失。</li></ul><p>Logan的解决方案是通过Native方式来实现日志底层的核心逻辑，也就是C编写底层库。这样做不光能解决Java GC问题，还做到了一份代码运行在Android和iOS两个平台上。同时在C层实现流式的压缩和加密数据，可以减少CPU峰值，使程序运行更加顺滑。而且先压缩再加密的方式压缩率比较高，整体效率较高，所以这个顺序不能变。</p><h3 id="2-2-日志丢失"><a href="#2-2-日志丢失" class="headerlink" title="2.2 日志丢失"></a>2.2 日志丢失</h3><p>加缓存之后，异常退出丢失日志的问题就必须解决，Logan为此引入了MMAP机制。MMAP是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。MMAP机制的优势是：</p><ul><li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件；</li><li>经过测试发现，操作MMAP的速度和操作内存的速度一样快，可以用MMAP来做数据缓存；</li><li>MMAP将日志回写时机交给操作系统控制。如内存不足，进程退出的时候操作系统会自动回写文件；</li><li>MMAP对文件的读写操作不需要页缓存，只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li></ul><p>引入MMAP机制之后，日志丢失问题得到了有效解决，同时也提升了性能。不过这种方式也不能百分百解决日志丢失的问题，MMAP存在初始化失败的情况，这时候Logan会初始化堆内存来做日志缓存。根据我们统计的数据来看，MMAP初始化失败的情况仅占0.002%，已经是一个小概率事件了。</p><h3 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3 安全性"></a>2.3 安全性</h3><p>日志文件的安全性必须得到保障，不能随意被破解，更不能明文存储。Logan采用了流式加密的方式，使用对称密钥加密日志数据，存储到本地。同时在日志上传时，使用非对称密钥对对称密钥Key做加密上传，防止密钥Key被破解，从而在网络层保证日志安全。</p><h3 id="2-4-日志分散"><a href="#2-4-日志分散" class="headerlink" title="2.4 日志分散"></a>2.4 日志分散</h3><p>针对日志分散的情况，为了保证日志全面，需要做本地聚合存储。Logan采用了自研的日志协议，对于不同种类的日志都会按照Logan日志协议进行格式化处理，存储到本地。当需要上报的时候进行集中上报，通过Logan日志协议进行反解，还原出不同日志的原本面貌。同时Logan后台提供了聚合展示的能力，全面展示日志内容，根据协议综合各种日志进行分析，使用时间轴等方式展示不同种日志的重要信息，使得开发者只需要通过Logan平台就可以查询到某一段时间App到底产生了哪些日志，可以快速复现问题场景，定位问题并处理。</p><p>关于Logan平台是如何展示日志的，下文会再进行说明。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>采集工具设计：</p><ul><li>性能：避免了CPU峰值，同时减少了CPU使用，避免卡顿情况发生。</li><li>丢失率：跨平台C库提供了日志协议数据的格式化处理，针对大日志的分片处理，引入了MMAP机制解决了日志丢失问题</li><li>安全性：使用AES进行日志加密确保日志安全性</li><li>侵入性</li><li>存储空间：<ul><li>采用“先压缩再加密”的顺序，使用流式的加密和压缩。</li><li>为了节约用户手机空间大小，日志文件只保留最近7天的日志，过期会自动删除。在Android设备上Logan将日志保存在沙盒中，保证了日志文件的安全性。</li></ul></li><li>用户流量：由于日志上报网络请求的频次相对较高，为了节省用户流量，日志通常不会太大。尤其是网络日志等这种实时性较高的日志。</li></ul><p>采集时机设计：</p><ul><li>进行预埋，在一些场景下上传，由于日志上报需要网络请求，对于移动App来说频繁网络请求会比较耗电，所以需要注意频率：<ul><li>在特定行为发生时进行上报（例如用户投诉）</li><li>在日志积累到一定程度</li><li>一定时间上报一次</li></ul></li><li>回捞上报：是由后端使用PushSDK向客户端发起回捞指令<ul><li>日志回捞平台需要有着严格的审核机制，确保开发者不会侵犯用户隐私，只关注问题场景。</li><li>日志回捞，依赖于Push。客户端被唤醒接收Push消息，受到一些条件影响：<ul><li>Android想要后台唤醒App，需要确保Push进程在后台存活；</li><li>iOS想要后台唤醒APP，需要确保用户开启后台刷新开关；</li><li>网络环境太差，Android上Push长连建立不成功。</li></ul></li></ul></li><li>主动上报：通过客服引导用户上报</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://tech.meituan.com/2018/02/11/logan.html">美团移动端基础日志库——Logan</a></li><li><a href="https://tech.meituan.com/2018/10/11/logan-open-source.html">Logan：美团开源移动端基础日志库</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、现存问题&quot;&gt;&lt;a href=&quot;#一、现存问题&quot; class=&quot;headerlink&quot; title=&quot;一、现存问题&quot;&gt;&lt;/a&gt;一、现存问题&lt;/h2&gt;&lt;p&gt;目前，业内移动端日志库大多都存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡顿，影响性能&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Log" scheme="https://tenloy.github.io/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃监控与分析</title>
    <link href="https://tenloy.github.io/2021/07/01/Crash-Monitor.html"/>
    <id>https://tenloy.github.io/2021/07/01/Crash-Monitor.html</id>
    <published>2021-07-01T16:24:21.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>常见的 crash 类型总结下来，分为三种：</p><ul><li>Mach kernel exceptions：是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。 <strong>很多内存错误、访问错误的地址造成的异常会以Mach异常、unix标准的signal机制的形式造成crash的现象。</strong></li><li>Unix Fatal signals：又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single。</li><li>应用级异常：<ul><li>Objective-C exceptions（NSException），它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。</li><li>C++ exceptions</li><li>Main thread deadlock (experimental)  主线程死锁</li><li>Custom crashes (e.g. from scripting languages) 自定义崩溃</li></ul></li></ul><h2 id="一、Darwin操作系统简单介绍"><a href="#一、Darwin操作系统简单介绍" class="headerlink" title="一、Darwin操作系统简单介绍"></a>一、Darwin操作系统简单介绍</h2><p>可以通过下面两张图，简单的看一下OS/iOS系统的分层结构</p><img src="/images/RunLoop/RunLoop_3.png" alt="os-structure" style="zoom:60%;" /><p>Darwin是macOS和iOS操作环境的操作系统部分。苹果公司于2000年把Darwin发布给开放源代码社区。</p><ul><li>既然是OS，那肯定要包括系统内核XNU、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</li><li>XNU是一个混合内核，它采用了来自OSF的OSFMK 7.3(Open Software Foundation Mach Kernel)和FreeBSD的各种要素(包括过程模型，网络堆栈和虚拟文件系统)，还有一个称为I/O Kit的面向对象的设备驱动程序API。</li><li>XNU将宏内核与微内核两者的特性兼收并蓄，以期同时拥有两种内核的优点。<strong>微内核的灵活性</strong>：比如在微内核中提高操作系统模块化程度以及让操作系统更多的部分接受内存保护的消息传递机制。<strong>宏内核的性能</strong>：宏内核在高负荷下表现的高性能。</li></ul><p>我们在深入看一下 Darwin 这个核心的架构：</p><img src="/images/RunLoop/RunLoop_4.png" alt="os-structure" style="zoom:70%;" /><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p><ul><li>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</li><li>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。(BSD是宏内核)</li><li>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</li></ul><p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 也是RunLoop的底层实现支持技术。</p><p>iOS中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的：</p><p><img src="/images/crash/os-structure2.png" alt="os-structure2"></p><h2 id="二、Mach异常与Unix信号的异常捕获"><a href="#二、Mach异常与Unix信号的异常捕获" class="headerlink" title="二、Mach异常与Unix信号的异常捕获"></a>二、Mach异常与Unix信号的异常捕获</h2><p>iOS系统自带的 Apple’s Crash Reporter 记录在设备中的Crash日志，Exception Type项通常会包含两个元素： Mach异常 和 Unix信号。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception Type:         EXC_BAD_ACCESS (SIGSEGV)    </span><br><span class="line">Exception Subtype:      KERN_INVALID_ADDRESS at 0x041a6f3</span><br></pre></td></tr></table></figure><p>Mach异常是什么？它又是如何与Unix信号建立联系的？</p><h3 id="2-1-Mach-kernel-exceptions"><a href="#2-1-Mach-kernel-exceptions" class="headerlink" title="2.1 Mach kernel exceptions"></a>2.1 Mach kernel exceptions</h3><h4 id="2-1-1-Mach异常的产生"><a href="#2-1-1-Mach异常的产生" class="headerlink" title="2.1.1 Mach异常的产生"></a>2.1.1 Mach异常的产生</h4><p>Mach异常是指最底层的内核级异常。</p><p>捕获方法：每个thread，task，host都有一个异常端口数组，Mach的部分API暴露给了用户态，用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常，抓取Crash事件。</p><img src="/images/crash/Mach-except-handle.jpg" alt="Mach-except-handle" style="zoom:60%;" /><h4 id="2-1-2-Mach异常的捕获"><a href="#2-1-2-Mach异常的捕获" class="headerlink" title="2.1.2 Mach异常的捕获"></a>2.1.2 Mach异常的捕获</h4><img src="/images/crash/1435544422851512.png" alt="" style="zoom:90%;" /><h3 id="2-2-Unix-BSD-Signals"><a href="#2-2-Unix-BSD-Signals" class="headerlink" title="2.2 Unix/BSD Signals"></a>2.2 Unix/BSD Signals</h3><h4 id="2-2-1-信号的产生"><a href="#2-2-1-信号的产生" class="headerlink" title="2.2.1 信号的产生"></a>2.2.1 信号的产生</h4><p>Unix信号，又称为BSD 信号。</p><ul><li>Mach异常如果没在Mach级别处理，那么都会在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。</li><li>因为硬件产生的信号（通过CPU陷阱）被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号（通过调用kill和pthread_kill）也首先沉下来被转换为Mach异常，再转换为Unix信号。</li><li>转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样不必了解Mach内核也可以通过Unix信号的方式来兼容开发。</li></ul><p>因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach层的EXC_BAD_ACCESS异常，在host层被转换成SIGSEGV信号投递到出错的线程。</p><img src="/images/crash/BSD-signals.jpg" alt="BSD-signals" style="zoom:60%;" /><h4 id="2-2-2-信号的捕获"><a href="#2-2-2-信号的捕获" class="headerlink" title="2.2.2 信号的捕获"></a>2.2.2 信号的捕获</h4><p>既然最终以信号的方式投递到出错的线程，那么就可以通过注册signalHandler来捕获信号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGSEGV,signalHandler);</span><br></pre></td></tr></table></figure><h4 id="2-2-3-系统中都有哪些信号"><a href="#2-2-3-系统中都有哪些信号" class="headerlink" title="2.2.3 系统中都有哪些信号"></a>2.2.3 系统中都有哪些信号</h4><p>默认情况下，大多数信号都是致命的（Fatal signals）。 任何具有“terminate终止”或“dump core核心转储”的默认操作的信号都是致命的，除非它被忽略或明确处理。查看方式：</p><ul><li><p><code>usr/include/sys/signal.h</code> 中，定义了31种</p></li><li><p>也可以使用命令 <code>kill -l</code> 查看，显示了25种</p></li><li><p>针对特定的信号，应用程序可以写对应的信号处理函数。如果不指定，则采取默认的处理方式</p></li><li><p>core dump：是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件(有的系统中将文件命名为 <code>core.进程号</code>，也有的命名为 <code>core-命令名-pid-时间戳</code>)。这种信息往往用于调试。</p></li></ul><h3 id="2-3-常见的Mach异常与Unix信号"><a href="#2-3-常见的Mach异常与Unix信号" class="headerlink" title="2.3 常见的Mach异常与Unix信号"></a>2.3 常见的Mach异常与Unix信号</h3><p>信号可以看做是对硬件异常跟软件异常的封装，常见的几种signals：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SIGSEGV, <span class="comment">// SEGV segmentation violation(段 违反) 非法访问地址，比如试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。比如：给已经release的对象发送消息</span></span><br><span class="line">SIGBUS,  <span class="comment">// 操作非法地址。比如修改只读数据区。</span></span><br><span class="line">SIGILL,  <span class="comment">// 执行非法指令, 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</span></span><br><span class="line">SIGFPE,  <span class="comment">// 算术运算错误</span></span><br><span class="line">SIGSYS,  <span class="comment">// 非法的系统调用</span></span><br><span class="line">SIGPIPE, <span class="comment">// 进程间通信产生，通信管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</span></span><br><span class="line">SIGABRT, <span class="comment">// 调用abort生成的信号，有可能是NSException也有可能是Mach</span></span><br><span class="line">SIGTRAP, <span class="comment">// 由断点指令或其它trap指令产生，一般出现在debug调试时</span></span><br></pre></td></tr></table></figure><ul><li><code>EXC_BAD_ACCESS</code>：is a Mach exception sent by the kernel to your application when you try to access memory that is not mapped for your application(访问没有映射到你APP的内存时). If not handled at the Mach level, it will be translated into a SIGBUS or SIGSEGV BSD signal.(如果没有在mach级别处理，就会被转换成这两种信号)      ——  Matt大神的<a href="https://links.jianshu.com/go?to=https://www.cocoawithlove.com/2010/05/handling-unhandled-exceptions-and.html">回答</a></li><li>SIGABRT is a BSD signal sent by an application to itself when an NSException or obj_exception_throw is not caught.</li></ul><p>Mach exception和Signal转换：</p><img src="/images/crash/mach-bsd.png" alt="mach-bsd" style="zoom:90%;" /><h3 id="2-4-Crash的收集实现"><a href="#2-4-Crash的收集实现" class="headerlink" title="2.4 Crash的收集实现"></a>2.4 Crash的收集实现</h3><p>如上述所说，通过捕获Mach异常或者Unix信号都可以抓到crash事件，于是总结起来实现方案就一共有3种。</p><p>**Q: 两种方式哪个更好呢？ **</p><p>优选Mach异常，因为Mach异常处理会先于Unix信号处理发生，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。</p><h4 id="2-4-1-Mach异常方式"><a href="#2-4-1-Mach异常方式" class="headerlink" title="2.4.1 Mach异常方式"></a>2.4.1 Mach异常方式</h4><h4 id="2-4-2-Unix信号方式"><a href="#2-4-2-Unix信号方式" class="headerlink" title="2.4.2 Unix信号方式"></a>2.4.2 Unix信号方式</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NWCrashSignalExceptionHandler.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NWCrashTool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(*SignalHandler)(<span class="keyword">int</span> signal, siginfo_t *info, <span class="keyword">void</span> *context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> SignalHandler previousABRTSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousBUSSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousFPESignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousILLSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousPIPESignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousSEGVSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousSYSSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousTRAPSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NWCrashSignalExceptionHandler</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)registerHandler &#123;</span><br><span class="line">    <span class="comment">// 将先前别人注册的handler取出并备份</span></span><br><span class="line">    [<span class="keyword">self</span> backupOriginalHandler];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> signalRegister];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)backupOriginalHandler &#123;</span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_abrt;</span><br><span class="line">    sigaction(SIGABRT, <span class="literal">NULL</span>, &amp;old_action_abrt);</span><br><span class="line">    <span class="keyword">if</span> (old_action_abrt.sa_sigaction) &#123;</span><br><span class="line">        previousABRTSignalHandler = old_action_abrt.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_bus;</span><br><span class="line">    sigaction(SIGBUS, <span class="literal">NULL</span>, &amp;old_action_bus);</span><br><span class="line">    <span class="keyword">if</span> (old_action_bus.sa_sigaction) &#123;</span><br><span class="line">        previousBUSSignalHandler = old_action_bus.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_fpe;</span><br><span class="line">    sigaction(SIGFPE, <span class="literal">NULL</span>, &amp;old_action_fpe);</span><br><span class="line">    <span class="keyword">if</span> (old_action_fpe.sa_sigaction) &#123;</span><br><span class="line">        previousFPESignalHandler = old_action_fpe.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_ill;</span><br><span class="line">    sigaction(SIGILL, <span class="literal">NULL</span>, &amp;old_action_ill);</span><br><span class="line">    <span class="keyword">if</span> (old_action_ill.sa_sigaction) &#123;</span><br><span class="line">        previousILLSignalHandler = old_action_ill.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_pipe;</span><br><span class="line">    sigaction(SIGPIPE, <span class="literal">NULL</span>, &amp;old_action_pipe);</span><br><span class="line">    <span class="keyword">if</span> (old_action_pipe.sa_sigaction) &#123;</span><br><span class="line">        previousPIPESignalHandler = old_action_pipe.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_segv;</span><br><span class="line">    sigaction(SIGSEGV, <span class="literal">NULL</span>, &amp;old_action_segv);</span><br><span class="line">    <span class="keyword">if</span> (old_action_segv.sa_sigaction) &#123;</span><br><span class="line">        previousSEGVSignalHandler = old_action_segv.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_sys;</span><br><span class="line">    sigaction(SIGSYS, <span class="literal">NULL</span>, &amp;old_action_sys);</span><br><span class="line">    <span class="keyword">if</span> (old_action_sys.sa_sigaction) &#123;</span><br><span class="line">        previousSYSSignalHandler = old_action_sys.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_trap;</span><br><span class="line">    sigaction(SIGTRAP, <span class="literal">NULL</span>, &amp;old_action_trap);</span><br><span class="line">    <span class="keyword">if</span> (old_action_trap.sa_sigaction) &#123;</span><br><span class="line">        previousTRAPSignalHandler = old_action_trap.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)signalRegister &#123;</span><br><span class="line">    NWSignalRegister(SIGABRT);</span><br><span class="line">    NWSignalRegister(SIGBUS);</span><br><span class="line">    NWSignalRegister(SIGFPE);</span><br><span class="line">    NWSignalRegister(SIGILL);</span><br><span class="line">    NWSignalRegister(SIGPIPE);</span><br><span class="line">    NWSignalRegister(SIGSEGV);</span><br><span class="line">    NWSignalRegister(SIGSYS);</span><br><span class="line">    NWSignalRegister(SIGTRAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Register Signal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWSignalRegister(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sigaction action;</span><br><span class="line">    action.sa_sigaction = NWSignalHandler;</span><br><span class="line">    action.sa_flags = SA_NODEFER | SA_SIGINFO;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask);</span><br><span class="line">    sigaction(signal, &amp;action, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark SignalCrash Handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWSignalHandler(<span class="keyword">int</span> signal, siginfo_t* info, <span class="keyword">void</span>* context) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mstr = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">    [mstr appendString:<span class="string">@&quot;Signal Exception:\n&quot;</span>];</span><br><span class="line">    [mstr appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Signal %@ was raised.\n&quot;</span>, signalName(signal)]];</span><br><span class="line">    [mstr appendString:<span class="string">@&quot;Call Stack:\n&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里过滤掉第一行日志</span></span><br><span class="line">    <span class="comment">// 因为注册了信号崩溃回调方法，系统会来调用，将记录在调用堆栈上，因此此行日志需要过滤掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">1</span>; index &lt; <span class="built_in">NSThread</span>.callStackSymbols.count; index++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSThread</span>.callStackSymbols objectAtIndex:index];</span><br><span class="line">        [mstr appendString:[str stringByAppendingString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [mstr appendString:<span class="string">@&quot;threadInfo:\n&quot;</span>];</span><br><span class="line">    [mstr appendString:[[<span class="built_in">NSThread</span> currentThread] description]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存崩溃日志到沙盒cache目录</span></span><br><span class="line">    [NWCrashTool saveCrashLog:[<span class="built_in">NSString</span> stringWithString:mstr] fileName:<span class="string">@&quot;Crash(Signal)&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    NWClearSignalRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用之前崩溃的回调函数</span></span><br><span class="line">    <span class="comment">// 在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递</span></span><br><span class="line">    previousSignalHandler(signal, info, context);</span><br><span class="line">    </span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Signal To Name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *signalName(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *signalName;</span><br><span class="line">    <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGABRT&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGBUS:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGBUS&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGFPE&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGILL:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGILL&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGPIPE&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGSEGV&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSYS:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGSYS&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTRAP:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGTRAP&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signalName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Previous Signal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> previousSignalHandler(<span class="keyword">int</span> signal, siginfo_t *info, <span class="keyword">void</span> *context) &#123;</span><br><span class="line">    SignalHandler previousSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            previousSignalHandler = previousABRTSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGBUS:</span><br><span class="line">            previousSignalHandler = previousBUSSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            previousSignalHandler = previousFPESignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGILL:</span><br><span class="line">            previousSignalHandler = previousILLSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">            previousSignalHandler = previousPIPESignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            previousSignalHandler = previousSEGVSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSYS:</span><br><span class="line">            previousSignalHandler = previousSYSSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTRAP:</span><br><span class="line">            previousSignalHandler = previousTRAPSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (previousSignalHandler) &#123;</span><br><span class="line">        previousSignalHandler(signal, info, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Clear</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWClearSignalRegister() &#123;</span><br><span class="line">    signal(SIGSEGV,SIG_DFL);</span><br><span class="line">    signal(SIGFPE,SIG_DFL);</span><br><span class="line">    signal(SIGBUS,SIG_DFL);</span><br><span class="line">    signal(SIGTRAP,SIG_DFL);</span><br><span class="line">    signal(SIGABRT,SIG_DFL);</span><br><span class="line">    signal(SIGILL,SIG_DFL);</span><br><span class="line">    signal(SIGPIPE,SIG_DFL);</span><br><span class="line">    signal(SIGSYS,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-Mach异常-Unix信号方式"><a href="#2-4-3-Mach异常-Unix信号方式" class="headerlink" title="2.4.3 Mach异常+Unix信号方式"></a>2.4.3 Mach异常+Unix信号方式</h4><p>Github上多数开源项目都采用的这种方式，即使在优选捕获Mach异常的情况下，也放弃捕获EXC_CRASH异常，而选择捕获与之对应的SIGABRT信号。著名开源项目<a href="https://github.com/plausiblelabs/plcrashreporter">plcrashreporter</a>在代码注释中给出了详细的解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We still need to use signal handlers to <span class="keyword">catch</span> SIGABRT in-process. The kernel sends an EXC_CRASH mach exception to denote SIGABRT termination. In that <span class="keyword">case</span>, catching the Mach exception in-process leads to process deadlock in an uninterruptable wait. Thus, we fall back on BSD signal handlers <span class="keyword">for</span> SIGABRT, <span class="keyword">and</span> <span class="keyword">do</span> <span class="keyword">not</span> <span class="keyword">register</span> <span class="keyword">for</span> EXC_CRASH.</span><br><span class="line">  <span class="comment">// 我们仍然需要使用信号处理程序来捕获进程内的SIGABRT。内核发送一个EXC_CRASH mach异常来表示SIGABRT终止。在这种情况下，在进程中捕获Mach异常会导致不可中断等待中的进程死锁。因此，我们对SIGABRT使用BSD信号处理程序，而不注册EXC_CRASH。</span></span><br></pre></td></tr></table></figure><h2 id="三、应用级异常与捕获"><a href="#三、应用级异常与捕获" class="headerlink" title="三、应用级异常与捕获"></a>三、应用级异常与捕获</h2><p>对于应用级异常，还需要单独的特殊处理。</p><h3 id="3-1-NSException"><a href="#3-1-NSException" class="headerlink" title="3.1 NSException"></a>3.1 NSException</h3><p>对于Objective-C异常，一般可通过try catch来捕获</p><p>未被<code>try catch</code> 的 NSException，会发出 <code>kill</code> 或 <code>pthread_kill</code> 信号-&gt; Mach异常-&gt; Unix信号（SIGABRT），但是如果通过捕获<code>SIGABRT</code>信号的方式，来抓取异常，那么在处理收集信息时，获取当前堆栈时获取不到，所以采用<code>NSSetUncaughtExceptionHandler</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSException.h 常见的几种异常名称</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSGenericException; <span class="comment">// 通用异常</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSRangeException;   <span class="comment">// 越界异常</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSInvalidArgumentException;  <span class="comment">// 非法参数，如nil、unrecognized selector send to instance</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSMallocException;  <span class="comment">// 内存分配异常</span></span><br><span class="line"><span class="comment">// ...等等</span></span><br></pre></td></tr></table></figure><p>参考图：</p><img src="/images/crash/2846924-a0cccb53e95db4d8.png" alt="" style="zoom:100%;" /><h4 id="3-1-1-举例"><a href="#3-1-1-举例" class="headerlink" title="3.1.1 举例"></a>3.1.1 举例</h4><p>以iOS开发常见的 NSException 为例，你是否见过崩溃在main函数的crash日志，但是函数栈里面没有你的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span> Crashed:</span><br><span class="line"><span class="number">0</span>       libsystem_kernel.dylib          <span class="number">0x3a61757c</span>   __semwait_signal_nocancel + <span class="number">0x18</span></span><br><span class="line"><span class="number">1</span>       libsystem_c.dylib               <span class="number">0x3a592a7c</span>   nanosleep$NOCANCEL + <span class="number">0xa0</span></span><br><span class="line"><span class="number">2</span>       libsystem_c.dylib               <span class="number">0x3a5adede</span>   usleep$NOCANCEL + <span class="number">0x2e</span></span><br><span class="line"><span class="number">3</span>       libsystem_c.dylib               <span class="number">0x3a5c7fe0</span>   <span class="built_in">abort</span> + <span class="number">0x50</span></span><br><span class="line"><span class="number">4</span>       libc++abi.dylib                 <span class="number">0x398f6cd2</span>   abort_message + <span class="number">0x46</span></span><br><span class="line"><span class="number">5</span>       libc++abi.dylib                 <span class="number">0x3990f6e0</span>   default_terminate_handler() + <span class="number">0xf8</span></span><br><span class="line"><span class="number">6</span>       libobjc.A.dylib                 <span class="number">0x3a054f62</span>   _objc_terminate() + <span class="number">0xbe</span></span><br><span class="line"><span class="number">7</span>       libc++abi.dylib                 <span class="number">0x3990d1c4</span>   <span class="built_in">std</span>::__terminate(<span class="keyword">void</span> (*)()) + <span class="number">0x4c</span></span><br><span class="line"><span class="number">8</span>       libc++abi.dylib                 <span class="number">0x3990cd28</span>   __cxa_rethrow + <span class="number">0x60</span></span><br><span class="line"><span class="number">9</span>       libobjc.A.dylib                 <span class="number">0x3a054e12</span>   objc_exception_rethrow + <span class="number">0x26</span></span><br><span class="line"><span class="number">10</span>      CoreFoundation                  <span class="number">0x2f7d7f30</span>   CFRunLoopRunSpecific + <span class="number">0x27c</span></span><br><span class="line"><span class="number">11</span>      CoreFoundation                  <span class="number">0x2f7d7c9e</span>   CFRunLoopRunInMode + <span class="number">0x66</span></span><br><span class="line"><span class="number">12</span>      GraphicsServices                <span class="number">0x346dd65e</span>   GSEventRunModal + <span class="number">0x86</span></span><br><span class="line"><span class="number">13</span>      UIKit                           <span class="number">0x32124148</span>   UIApplicationMain + <span class="number">0x46c</span></span><br><span class="line"><span class="number">14</span>      XXXXXX                          <span class="number">0x0003b1f2</span>   main + <span class="number">0x1f2</span></span><br><span class="line"><span class="number">15</span>      libdyld.dylib                   <span class="number">0x3a561ab4</span>   start + <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>可以看出是因为某个NSException导致程序Crash的，只有拿到这个NSException，获取它的reason，name，callStackSymbols信息才能确定出问题的程序位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NSException Class Reference */</span></span><br><span class="line">@property(readonly, copy) NSString *name;  </span><br><span class="line">@property(readonly, copy) NSString *reason;</span><br><span class="line">@property(readonly, copy) NSArray *callStackSymbols;</span><br><span class="line">@property(readonly, copy) NSArray *callStackReturnAddresses;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-NSException的捕获"><a href="#3-1-2-NSException的捕获" class="headerlink" title="3.1.2 NSException的捕获"></a>3.1.2 NSException的捕获</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录之前的崩溃回调函数</span></span><br><span class="line"><span class="keyword">static</span> NSUncaughtExceptionHandler *previousUncaughtExceptionHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_uncaught_exception_handler</span> <span class="params">(NSException *exception)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 异常的堆栈信息</span></span><br><span class="line">    NSArray * stackArray = [exception callStackSymbols];</span><br><span class="line">    <span class="comment">// 出现异常的原因</span></span><br><span class="line">    NSString * reason = [exception reason];</span><br><span class="line">    <span class="comment">// 异常名称</span></span><br><span class="line">    NSString * name = [exception name];</span><br><span class="line">    </span><br><span class="line">    NSString * exceptionInfo = [NSString stringWithFormat:@<span class="string">&quot;========uncaughtException异常错误报告========\nname:%@\nreason:\n%@\ncallStackSymbols:\n%@&quot;</span>, name, reason, [stackArray componentsJoinedByString:@<span class="string">&quot;\n&quot;</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存崩溃日志到沙盒cache目录</span></span><br><span class="line">    [NWCrashTool saveCrashLog:exceptionInfo fileName:@<span class="string">&quot;Crash(Uncaught)&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递</span></span><br><span class="line">    <span class="keyword">if</span> (previousUncaughtExceptionHandler) &#123;</span><br><span class="line">        previousUncaughtExceptionHandler(exception);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 杀掉程序，这样可以防止同时抛出的SIGABRT被SignalException捕获</span></span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)registerHandler &#123;</span><br><span class="line">    <span class="comment">//将先前别人注册的handler取出并备份</span></span><br><span class="line">    previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">  </span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;my_uncaught_exception_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拿到的NSException细节写入Crash日志，精准的定位出错程序位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Application Specific Information:</span><br><span class="line">*** Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key key.&#x27;</span><br><span class="line">Last Exception Backtrace:</span><br><span class="line"><span class="number">0</span> CoreFoundation <span class="number">0x2f8a3f7e</span>     __exceptionPreprocess + <span class="number">0x7e</span></span><br><span class="line"><span class="number">1</span> libobjc.A.dylib <span class="number">0x3a054cc</span>     objc_exception_throw + <span class="number">0x22</span></span><br><span class="line"><span class="number">2</span> CoreFoundation <span class="number">0x2f8a3c94</span>     -[NSException raise] + <span class="number">0x4</span></span><br><span class="line"><span class="number">3</span> Foundation <span class="number">0x301e8f1e</span>         -[NSObject(NSKeyValueCoding) setValue:forKey:] + <span class="number">0xc6</span></span><br><span class="line"><span class="number">4</span> DemoCrash <span class="number">0x00085306</span>          -[ViewController crashMethod] + <span class="number">0x6e</span></span><br><span class="line"><span class="number">5</span> DemoCrash <span class="number">0x00084ecc</span>          main + <span class="number">0x1cc</span></span><br><span class="line"><span class="number">6</span> DemoCrash <span class="number">0x00084cf8</span>          start + <span class="number">0x24</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-注意点"><a href="#3-1-3-注意点" class="headerlink" title="3.1.3 注意点"></a>3.1.3 注意点</h4><p><strong>Q: 是不是收到了大量crash在main函数却没有NSException信息的日志，就代表自己集成的Crash日志收集服务没有注册NSUncaughtExceptionHandler呢？</strong></p><p>不一定，还有另外一种可能，就是被同时存在的其他Crash日志收集服务给坑了。</p><p><strong>Q: 未设置NSSetUncaughtExceptionHandler的NSException最后会转成Unix信号吗？</strong></p><p>无论设置NSSetUncaughtExceptionHandler与否，只要未被try catch，最终都会被转成Unix信号，只不过设置了无法在其ExceptionHandler中无法获得最终发送的Unix信号类型</p><h3 id="3-2-ObjC野指针类的Crash"><a href="#3-2-ObjC野指针类的Crash" class="headerlink" title="3.2 ObjC野指针类的Crash"></a>3.2 ObjC野指针类的Crash</h3><p>收集Crash日志这个步骤没有问题的情况下，还是有很多全系统栈的日志的情况，没有自己一行代码，分析起来十分棘手，ObjC野指针类的Crash正是如此，这里推荐几篇好文章：</p><ul><li><a href="http://bugly.qq.com/blog/?p=200">如何定位Obj-C野指针随机Crash(一)：先提高野指针Crash率</a></li><li><a href="http://bugly.qq.com/blog/?p=308">如何定位Obj-C野指针随机Crash(二)：让非必现Crash变成必现</a></li><li><a href="http://bugly.qq.com/blog/?p=335">如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html">分析objc_msgSend()处崩溃的小技巧</a></li></ul><p>除此之外，在Crash日志中补充记录一些额外信息可以辅助定位，如切面标记线程出处、队列出处，记录用户操作轨迹等等……</p><h3 id="3-3-C-exceptions"><a href="#3-3-C-exceptions" class="headerlink" title="3.3 C++ exceptions"></a>3.3 C++ exceptions</h3><p>C++ exceptions使用系统封装好的函数<code>std::set_terminate(CPPExceptionTerminate)</code>来设置回调</p><h2 id="四、Crash的采集"><a href="#四、Crash的采集" class="headerlink" title="四、Crash的采集"></a>四、Crash的采集</h2><h3 id="4-1-采集工具"><a href="#4-1-采集工具" class="headerlink" title="4.1 采集工具"></a>4.1 采集工具</h3><p>崩溃日志收集服务，成熟的开源项目很多，如 <a href="https://github.com/kstenerud/KSCrash">KSCrash</a>，<a href="https://github.com/plausiblelabs/plcrashreporter">PLCrashReporter</a>，<a href="https://github.com/kaler/CrashKit">CrashKit</a> 等。追求方便省心，对于保密性要求不高的程序来说，也可以选择各种一条龙Crash统计产品，如 <a href="http://try.crashlytics.com/">Crashlytics</a>，<a href="http://hockeyapp.net/features/crashreports/">Hockeyapp</a> ，<a href="http://www.umeng.com/umeng30_error_type">友盟</a>，<a href="http://bugly.qq.com/">Bugly</a> 等等。</p><h4 id="4-1-1-官方CrashReporter"><a href="#4-1-1-官方CrashReporter" class="headerlink" title="4.1.1 官方CrashReporter"></a>4.1.1 官方CrashReporter</h4><p>iOS有自己的CrashReporter机制。在真机上产生的crash，在以下两个地方可以找到：</p><ul><li>Xcode－Window－Devices － View Device Logs中可以看到crash文件。</li><li>通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志。需要用户在设置-诊断与用量中允许将崩溃信息发送给开发者。然后在也可以在Xcode的Window - Organizer中可以看到对应的crash信息。（需要在Xcode中登录所属的开发者账号）</li></ul><p>关于各个字段的含义，以下仅供参考：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Incident Identifier</td><td>当前crash的 id，可以区分不同的crash事件</td></tr><tr><td>CrashReporter Key</td><td>当前设备的id，可以判断crash在某一设备上出现的频率</td></tr><tr><td>Hardware Model</td><td>设备型号</td></tr><tr><td>Process</td><td>当前应用的名称，后面中括号中为当前的应用在系统中的进程id</td></tr><tr><td>Path</td><td>当前应用在设备中的路径</td></tr><tr><td>Identifier</td><td>bundle id</td></tr><tr><td>Version</td><td>应用版本号</td></tr><tr><td>Code Type</td><td>还不清楚</td></tr><tr><td>Date/Time</td><td>crash事件 时间(后面跟的应该是时区)</td></tr><tr><td>OS Version</td><td>当前系统版本</td></tr><tr><td>Exception Type</td><td>异常类型</td></tr><tr><td>Exception Codes</td><td>异常出错的代码（常见代码有以下几种) <br />0x8badf00d：Watchdog超时，意为“ate bad food”。  <br />0xdeadfa11：用户强制退出，意为“dead fall”。 <br />0xbaaaaaad：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。 <br />0xbad22222：VoIP应用（因为太频繁？）被iOS干掉。 <br />0xc00010ff：因为太烫了被干掉，意为“cool off”。 <br />0xdead10cc：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock”。</td></tr><tr><td>Triggered by Thread</td><td>在某一个线程出了问题导致crash，Thread 0  为主线程、其它的都为子线程</td></tr><tr><td>Last Exception Backtrace</td><td>最后异常回溯，一般根据这个代码就能找到crash的具体问题</td></tr></tbody></table><h4 id="4-1-2-KSCrash"><a href="#4-1-2-KSCrash" class="headerlink" title="4.1.2 KSCrash"></a>4.1.2 KSCrash</h4><p>KSCrash 是 iOS 上一个知名的 crash 收集框架。包括腾讯刚开源的 APM 框架 Matrix，其中 crash 收集部分也是直接使用的 KSCrash。</p><h4 id="4-1-3-PLCrashReporter"><a href="#4-1-3-PLCrashReporter" class="headerlink" title="4.1.3 PLCrashReporter"></a>4.1.3 PLCrashReporter</h4><p>微软家的，<a href="https://github.com/microsoft/plcrashreporter">Github</a></p><h3 id="4-2-多个Crash日志收集服务共存的坑"><a href="#4-2-多个Crash日志收集服务共存的坑" class="headerlink" title="4.2 多个Crash日志收集服务共存的坑"></a>4.2 多个Crash日志收集服务共存的坑</h3><p>是的，在自己的程序里集成多个Crash日志收集服务实在不是明智之举。通常情况下，第三方功能性SDK都会集成一个Crash收集服务，以及时发现自己SDK的问题。当各家的服务都以保证自己的Crash统计正确完整为目的时，难免出现时序手脚，强行覆盖等等的恶意竞争，总会有人默默被坑。</p><h4 id="4-2-1-拒绝传递-UncaughtExceptionHandler"><a href="#4-2-1-拒绝传递-UncaughtExceptionHandler" class="headerlink" title="4.2.1 拒绝传递 UncaughtExceptionHandler"></a>4.2.1 拒绝传递 UncaughtExceptionHandler</h4><p>如果同时有多方通过NSSetUncaughtExceptionHandler注册异常处理程序，和平的作法是：后注册者通过NSGetUncaughtExceptionHandler将先前别人注册的handler取出并备份，在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递。不传递强行覆盖的后果是，在其之前注册过的日志收集服务写出的Crash日志就会因为取不到NSException而丢失Last Exception Backtrace等信息。（P.S. iOS系统自带的Crash Reporter不受影响）</p><p>在开发测试阶段，可以利用 <a href="https://github.com/facebook/fishhook">fishhook</a> 框架去hookNSSetUncaughtExceptionHandler方法，这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。不推荐利用调试器添加符号断点来检查，原因是一些Crash收集框架在调试状态下是不工作的。</p><p>检测代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*ori_NSSetUncaughtExceptionHandler)</span><span class="params">( NSUncaughtExceptionHandler * )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_NSSetUncaughtExceptionHandler</span><span class="params">( NSUncaughtExceptionHandler * handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">    <span class="keyword">if</span> (g_vaildUncaughtExceptionHandler != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;UncaughtExceptionHandler=%p&quot;</span>,g_vaildUncaughtExceptionHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ori_NSSetUncaughtExceptionHandler(handler);</span><br><span class="line">    NSLog(@<span class="string">&quot;%@&quot;</span>,[NSThread callStackSymbols]);</span><br><span class="line">    </span><br><span class="line">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">    NSLog(@<span class="string">&quot;UncaughtExceptionHandler=%p&quot;</span>,g_vaildUncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于越狱插件注入应用进程内部，恶意覆盖NSSetUncaughtExceptionHandler的情况，应用程序本身处理起来比较弱势，因为越狱环境下操作时序的玩法比较多权利比较大。</p><h4 id="4-2-2-Mach异常端口换出-信号处理Handler覆盖"><a href="#4-2-2-Mach异常端口换出-信号处理Handler覆盖" class="headerlink" title="4.2.2 Mach异常端口换出+信号处理Handler覆盖"></a>4.2.2 Mach异常端口换出+信号处理Handler覆盖</h4><p>和NSSetUncaughtExceptionHandler的情况类似，设置过的Mach异常端口和信号处理程序也有可能被干掉，导致无法捕获Crash事件。</p><h4 id="4-2-3-影响系统崩溃日志准确性"><a href="#4-2-3-影响系统崩溃日志准确性" class="headerlink" title="4.2.3 影响系统崩溃日志准确性"></a>4.2.3 影响系统崩溃日志准确性</h4><p>应用层参与收集Crash日志的服务方越多，越有可能影响iOS系统自带的Crash Reporter。由于进程内线程数组的变动，可能会导致系统日志中线程的Crashed 标签标记错位，可以搜索abort()等关键字来复查系统日志的准确性。</p><p>若程序因NSException而Crash，系统日志中的Last Exception Backtrace信息是完整准确的，不会受应用层的胡来而影响，可作为排查问题的参考线索。</p><h2 id="六、Crash的符号化"><a href="#六、Crash的符号化" class="headerlink" title="六、Crash的符号化"></a>六、Crash的符号化</h2><p>所谓的符号解析就是就是将崩溃日志中的地址映射成为可读的符号和源文件中的行号，方便开发者定位和修复问题。</p><h3 id="6-1-异常信息的查看"><a href="#6-1-异常信息的查看" class="headerlink" title="6.1 异常信息的查看"></a>6.1 异常信息的查看</h3><p>异常信息有三种类型</p><ol><li><p>已标记错误位置的，这种信息很明确了不用解析，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000109708aeb -[ViewController buttonClick:] + 43</span><br></pre></td></tr></table></figure></li><li><p>有模块地址的情况，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制库名（<span class="built_in">test</span>），调用方法的地址（0x00000001018157dc），模块地址（0x100064000）+偏移地址（24844252）</span></span><br><span class="line">test 0x00000001018157dc 0x100064000 + 24844252</span><br></pre></td></tr></table></figure></li><li><p>无模块地址的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法的地址-偏移地址，得到的就是模块地址  0x00000001018157dc - 24844252 = 0x100064000</span></span><br><span class="line">test 0x00000001018157dc test + 24844252</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-系统原生符号解析工具"><a href="#6-2-系统原生符号解析工具" class="headerlink" title="6.2 系统原生符号解析工具"></a>6.2 系统原生符号解析工具</h3><p>一般Xcode项目每次 release 编译后, 都会产生一个新的.dSYM文件和.app文件，这两者有一个共同的UUID.</p><ul><li><p>.dSYM文件是一个符号表文件, 这里面包含了一个16进制的保存函数地址映射信息的中转文件。</p></li><li><p>获取：xcode -&gt; window -&gt; organizer-&gt;右键你的应用 show finder-&gt;右键.xcarchive 显示包内容-&gt;dSYMs-&gt;test.app.dYSM</p></li><li><p>符号表是内存地址与函数名，文件名，行号的映射表。 符号表元素如下所示:</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</span><br></pre></td></tr></table></figure><h4 id="6-2-1-symbolicatecrash"><a href="#6-2-1-symbolicatecrash" class="headerlink" title="6.2.1 symbolicatecrash"></a>6.2.1 symbolicatecrash</h4><p>Xcode 提供的 <code>symbolicatecrash</code>。该命令位于：<code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code>，是一个perl 脚本，里面整合了逐步解析的操作（也可以将命令拷贝出来，直接进行调用）。</p><p>用法：<code>symbolicatecrash log.crash -d xxx.app.dSYM</code></p><p>优点：能非常方便的符号化整份 crash 日志。</p><p>缺点：</p><ol><li>耗时比较久。</li><li>粒度比较粗，无法符号化特定的某一行。</li></ol><h4 id="6-2-2-atos"><a href="#6-2-2-atos" class="headerlink" title="6.2.2 atos"></a>6.2.2 atos</h4><p>atos命令来符号化某个特定模块加载地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atos [-arch 架构名] [-o 符号表] [-l 模块地址] [方法地址]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如</span></span><br><span class="line">atos -o xxx.app.dSYM/Contents/Resources/DWARF/xxx -arch arm64/armv7 -l loadAddress runtimeAddress</span><br></pre></td></tr></table></figure><p>优点：速度快，可以符号化特定的某一行，方便上层做缓存。</p><p>上面的这两个工具都有两个最大的缺陷就是：</p><ol><li>都仅仅是单机的工具，无法作为在线服务提供。</li><li>必须依赖 macOS 系统，因 为字节服务端基建全部基于Linux，导致无法复用集团各种平台和框架，这就带来了非常高的机器成本，部署成本和运维成本。</li></ol><ul><li><a href="https://mp.weixin.qq.com/s/MIun-eV4_J1hXGDRjGoLaw">iOS 崩溃日志在线符号化实践</a></li><li><a href="https://mp.weixin.qq.com/s/TVRYXhiOXIsMmXZo9GmEVA">iOS 符号解析重构之路</a></li></ul><h2 id="七、Crash的分析"><a href="#七、Crash的分析" class="headerlink" title="七、Crash的分析"></a>七、Crash的分析</h2><ul><li>当我们拿到crash日志时，应首先从<code>crash Type</code>，<code>crash thread</code>  快速定位到造成crash的代码段。之所以首先要看这两个，是因为type能大致知道crash的类型，如果是OC类型的异常，那基本上处理起来比较简单，如果是mach signals类型的，通过查看造成crash的线程堆栈，也能快速定位到方法，举个实际项目中的例子：</li></ul><blockquote><p>线上有个偶现的crash，crash Type为SIGSEGV，且thread不定，子线程，主线程都会存在，但是代码段相同，由于SIGSEGV是野指针异常类型，且由于在多线程中都会触发，说明问题基本上是多线程的对象读写安全问题</p></blockquote><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="http://www.cocoachina.com/articles/12301">漫谈iOS Crash收集框架 - 念茜</a></p></li><li><p><a href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;常见的 crash 类型总结下来，分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mach kernel exceptions：是指最</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="CrashMonitor" scheme="https://tenloy.github.io/tags/CrashMonitor/"/>
    
  </entry>
  
  <entry>
    <title>iOS卡顿监控</title>
    <link href="https://tenloy.github.io/2021/06/30/Lag-Monitor.html"/>
    <id>https://tenloy.github.io/2021/06/30/Lag-Monitor.html</id>
    <published>2021-06-30T19:28:45.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、卡顿的难点"><a href="#一、卡顿的难点" class="headerlink" title="一、卡顿的难点"></a>一、卡顿的难点</h2><p>时不时会收到这样的卡顿反馈：“用户A 刚才碰到从后台切换前台卡了一下，最近偶尔会遇到几次”、“用户B 反馈点对话框卡了五六秒”、“现网有用户反馈切换 tab 很卡”。</p><p>这些反馈有几个特点，导致跟进困难：</p><ol><li>不易重现。可能是特定用户的手机上才有问题，由于种种原因这个手机不能拿来调试；也有可能是特定的时机才会出问题，过后就不能重现了（例如线程抢锁）。</li><li>操作路径长，日志无法准确打点</li></ol><p>对于这些界面卡顿反馈，通常我们拿用户日志作用不大，增加日志点也用处不大。只能不断重试希望能够重现出来，或者埋头代码逻辑中试图能找的蛛丝马迹。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>在开始之前，我们先思考一下，界面卡顿是由哪些原因导致的？</p><ul><li>死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。</li><li>抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。</li><li>主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。</li><li>主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。</li><li>大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。</li></ul><p>针对这些原因，我们可以怎么定位问题呢？</p><ul><li>死锁一般会伴随 crash，可以通过 crash report 来分析。</li><li>抢锁不好办，将锁等待时间打出来用处不大，我们还需要知道是<strong>谁占了锁</strong>。</li><li>大量 IO 可以在函数开始结束打点，将占用时间打到日志中。</li><li>大量计算同理可以将耗时打到日志中。</li><li>大量 UI 绘制一般是必现，还好办；如果是偶现的话，想加日志点都没地方，因为是<strong>慢在系统函数里面</strong>。</li></ul><p>如果可以将当时的线程堆栈捕捉下来，那么上述难题都迎刃而解。主线程在什么函数哪一行卡住、在等什么锁而这个锁又是被哪个子线程的哪个函数占用、是在进行I/O操作、或者是进行复杂计算，有了堆栈，我们都可以知道。自然也能知道是慢在UI绘制，还是慢在我们的代码。</p><p>所以，思路就是<strong>起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来</strong>。</p><p>流程图描述如下：</p><img src="/images/PerfOpt/lag-process.png" style="zoom:85%"><h2 id="三、细节"><a href="#三、细节" class="headerlink" title="三、细节"></a>三、细节</h2><p>原理一旦讲出来，好像也不复杂。魔鬼都是隐藏在细节中，效果好不好，完全由实现细节决定。具体到卡顿检测，有几个问题需要仔细处理：</p><ul><li>怎么知道主线程发生了卡顿？</li><li>子线程以什么样的策略和频率来检测主线程？这个是要发布到现网的，如果处理不好，带来明显的性能损耗（尤其是电量），就不能接受了。</li><li>堆栈上报了上来怎么分类？直接用 crash report 的分类不适合。</li><li>卡顿 dump 下来的堆栈会有多频繁？数据量会有多大？</li><li>全量上报还是抽样上报？怎么在问题跟进与节省流量直接平衡？</li></ul><h3 id="3-1-卡顿判断标准"><a href="#3-1-卡顿判断标准" class="headerlink" title="3.1 卡顿判断标准"></a>3.1 卡顿判断标准</h3><p>怎么判断主线程是不是发生了卡顿？一般来说，用户感受得到的卡顿大概有三个特征：</p><ul><li>FPS 降低</li><li>CPU 占用率很高</li><li>主线程 Runloop 执行了很久</li></ul><p>看起来 FPS 能够兼容后面两个特征，但是在实际操作过程中发现 FPS 并不适用，不好衡量：</p><ul><li>人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；</li><li>平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿；</li><li>游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上</li><li><strong>FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高</strong>。FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生。</li></ul><p>而对于抢锁或大量 IO 的情况，光有 CPU 是不行的。所以我们实际上用到的是下面两个准则：</p><ul><li>单核 CPU 的占用超过了 80%</li><li>主线程 Runloop 执行了超过2秒</li></ul><h3 id="3-2-卡顿检测实现"><a href="#3-2-卡顿检测实现" class="headerlink" title="3.2 卡顿检测实现"></a>3.2 卡顿检测实现</h3><p>在 iOS/macOS 平台应用中，主线程有一个 Runloop。Runloop 是一个 Event Loop 模型，让线程可以处于接收消息、处理事件、进入等待而不马上退出。在进入事件的前后，Runloop 会向注册的 Observer 通知相应的事件。</p><p>Runloop 的详细介绍可以参考：<a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>，一个简易的 Runloop 流程如下所示：</p><img src="/images/PerfOpt/simple-runloop-model.png" style="zoom:80%"><p>Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。</p><img src="/images/PerfOpt/main-thread-lag-check.png" style="zoom:80%"><p>目前微信使用的卡顿监控，主程序 Runloop 超时的阈值是 2 秒，子线程的检查周期是 1 秒。每隔 1 秒，子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照。</p><p>同时，我们也认为 CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。目前微信应用中认为，单核 CPU 的占用超过了 80%，此时的 CPU 占用就过高了。</p><p>代码示例：<a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMLagMonitor.m">SMLagMonitor.m</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程监控</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//子线程开启一个持续的 loop 用来进行监控</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">        <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">                timeoutCount = <span class="number">0</span>;</span><br><span class="line">                dispatchSemaphore = <span class="number">0</span>;</span><br><span class="line">                runLoopActivity = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿</span></span><br><span class="line">            <span class="keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                <span class="comment">//将堆栈信息上报服务器的代码放到这里</span></span><br><span class="line">            &#125; <span class="comment">//end activity</span></span><br><span class="line">        &#125;<span class="comment">// end semaphore wait</span></span><br><span class="line">        timeoutCount = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">// end while</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-检测策略—退火算法"><a href="#3-3-检测策略—退火算法" class="headerlink" title="3.3 检测策略—退火算法"></a>3.3 检测策略—退火算法</h3><p>为了降低检测带来的性能损耗，我们仔细设计了检测线程的策略：</p><ul><li>内存 dump：每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）；</li><li>文件 dump：将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对：<ul><li>如果堆栈不同，则获得当前的线程快照并写入文件中；</li><li>如果相同则会跳过，并按照斐波那契数列将<strong>检查时间递增</strong>（1，1，2，3，5，8…）直到没有遇到卡顿或者主线程卡顿堆栈不一样。</li></ul></li></ul><p>这样，可以避免同一个卡顿写入多个文件的情况；避免检测线程遇到主线程卡死的情况下，不断写线程快照文件。</p><h3 id="3-4-卡顿时堆栈获取"><a href="#3-4-卡顿时堆栈获取" class="headerlink" title="3.4 卡顿时堆栈获取"></a>3.4 卡顿时堆栈获取</h3><h4 id="3-4-1-直接调用系统函数"><a href="#3-4-1-直接调用系统函数" class="headerlink" title="3.4.1 直接调用系统函数"></a>3.4.1 直接调用系统函数</h4><p>获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。</p><p>直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signals[] = &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signal_num = <span class="keyword">sizeof</span>(s_fatal_signals) / <span class="keyword">sizeof</span>(s_fatal_signals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *exceptionArray = [exception callStackSymbols]; <span class="comment">//得到当前调用栈信息</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionReason = [exception reason];       <span class="comment">//非常重要，就是崩溃的原因</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionName = [exception name];           <span class="comment">//异常类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SignalHandler(<span class="keyword">int</span> code)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;signal handler = %d&quot;</span>,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InitCrashReport()&#123;</span><br><span class="line">    <span class="comment">//系统错误信号捕获</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//oc未捕获异常的捕获</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h4 id="3-4-2-PLCrashReporter三方库"><a href="#3-4-2-PLCrashReporter三方库" class="headerlink" title="3.4.2 PLCrashReporter三方库"></a>3.4.2 PLCrashReporter三方库</h4><p>PLCrashReporter是一个开源的第三方框架，用来做 crash 收集，可以直接用 PLCrashReporter 来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是我推荐的获取堆栈信息的方法。</p><p>具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">NSData</span> *lagData = [</span><br><span class="line">   [[PLCrashReporter alloc] initWithConfiguration:</span><br><span class="line">                     [[PLCrashReporterConfig alloc]</span><br><span class="line">                      initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]]</span><br><span class="line">                   generateLiveReport];</span><br><span class="line"><span class="comment">// 转换成 PLCrashReport 对象</span></span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="comment">// 进行字符串格式化处理</span></span><br><span class="line"><span class="built_in">NSString</span> *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"><span class="comment">//将字符串上传服务器</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;lag happen, detail below: \n %@&quot;</span>,lagReportString);</span><br></pre></td></tr></table></figure><h4 id="3-4-3-KSCrash"><a href="#3-4-3-KSCrash" class="headerlink" title="3.4.3 KSCrash"></a>3.4.3 KSCrash</h4><p>KSCrash 是 iOS 上一个知名的 crash 收集框架。包括腾讯开源的 APM 框架 Matrix，其中 crash 收集部分也是直接使用的 KSCrash。</p><p>KSCrash 可以处理以下类型的崩溃：</p><ul><li>Mach kernel exceptions Mac内核异常</li><li>Fatal signals</li><li>C++ exceptions</li><li>Objective-C exceptions</li><li>Main thread deadlock (experimental)  主线程死锁</li><li>Custom crashes (e.g. from scripting languages) 自定义崩溃</li></ul><h4 id="3-4-4-WCCrashBlockMonitorPlugin"><a href="#3-4-4-WCCrashBlockMonitorPlugin" class="headerlink" title="3.4.4 WCCrashBlockMonitorPlugin"></a>3.4.4 WCCrashBlockMonitorPlugin</h4><p>Matrix for iOS/macOS 是微信开源的一个工具，可以使用在 iOS、macOS 平台上。在日常开发中，微信iOS团队通过卡顿监控上报的堆栈，找到微信的代码不合理之处或者是一些性能瓶颈；通过卡顿监控的辅助，尽可能地提升微信的流畅性，给用户带来更加极致美好的体验。</p><p>工具监控范围包括：崩溃、卡顿和爆内存，包含以下两款插件：</p><ul><li>WCCrashBlockMonitorPlugin：基于 <a href="https://github.com/kstenerud/KSCrash">KSCrash</a> 框架开发，具有业界领先的卡顿堆栈捕获能力，同时兼备崩溃捕获能力。</li><li>WCMemoryStatPlugin：一款性能优化到极致的爆内存监控工具，能够全面捕获应用爆内存时的内存分配以及调用堆栈情况。</li></ul><h3 id="3-5-耗时堆栈提取"><a href="#3-5-耗时堆栈提取" class="headerlink" title="3.5 耗时堆栈提取"></a>3.5 耗时堆栈提取</h3><p>子线程检测到主线程 Runloop 时，会获得当前的线程快照当做卡顿文件。但是这个当前的主线程堆栈不一定是最耗时的堆栈，不一定是导致主线程超时的主要原因。</p><p>例如，主线程在绘制一个微信logo，过程如下：</p><img src="/images/PerfOpt/draw-wechat-logo.png" style="zoom:80%"><p>子线程在检测到超出阈值时获得的线程快照，主线程的当前任务是“画小气泡”。但其实“画大气泡”才是耗时操作，导致主线程超时的主要原因。<strong>Matrix 卡顿监控通过主线程耗时堆栈提取来解决这个问题。</strong></p><p>卡顿监控定时获取主线程堆栈，并将堆栈保存到内存的一个循环队列中。如下图，每间隔时间 t 获得一个堆栈，然后将堆栈保存到一个最大个数为 3 的循环队列中。有一个游标不断的指向最近的堆栈。</p><p>微信的策略是每隔 50 毫秒获取一次主线程堆栈，保存最近 20 个主线程堆栈。这个会增加 3% 的 CPU 占用，内存占用可以忽略不计。</p><img src="/images/PerfOpt/time-cost-stack-fetch.png" style="zoom:100%"><p>当主线程检测到卡顿时，通过对保存到循坏队列中的堆栈进行回溯，获取最近最耗时堆栈。</p><p>如下图，检测到卡顿时，内存的循环队列中记录了最近的20个主线程堆栈，需要从中找出最近最耗时的堆栈。Matrix 卡顿监控用如下特征找出最近最耗时堆栈：</p><ul><li>以栈顶函数为特征，认为栈顶函数相同的即整个堆栈是相同的；</li><li>取堆栈的间隔是相同的，堆栈的重复次数近似作为堆栈的调用耗时，重复越多，耗时越多；</li><li>重复次数相同的堆栈可能很有多个，取最近的一个最耗时堆栈。</li></ul><p>获得的最近最耗时堆栈会附带到卡顿文件中。</p><img src="/images/PerfOpt/stack-back.png" style="zoom:80%"><h3 id="3-6-卡死卡顿"><a href="#3-6-卡死卡顿" class="headerlink" title="3.6 卡死卡顿"></a>3.6 卡死卡顿</h3><p>Matrix 中内置了应用被杀原因的检测机制。这个机制从 <a href="https://code.fb.com/ios/reducing-fooms-in-the-facebook-ios-app">Facebook 的博文</a> 中获得灵感，在其基础上增加了系统强杀的判定。Matrix 检测应用被杀原因的具体机制如下图所示：</p><img src="/images/PerfOpt/why-app-killed.png" style="zoom:85%"><p><strong>Matrix 检测到应用卡死被强杀，会把应用上次存活时的最后一份卡顿日志标记为卡死卡顿。</strong></p><h3 id="3-7-性能损耗"><a href="#3-7-性能损耗" class="headerlink" title="3.7 性能损耗"></a>3.7 性能损耗</h3><p>Matrix 卡顿监控不打开耗时堆栈提取，性能损耗可以忽略不计。</p><p>打开耗时堆栈提取后，性能损耗和定时获取主线程堆栈的间隔有关。实测，每隔 50 毫秒不断获取主线程堆栈，会增加 3% 的 CPU 占用。</p><h3 id="3-8-分类方法"><a href="#3-8-分类方法" class="headerlink" title="3.8 分类方法"></a>3.8 分类方法</h3><p>直接用 crash report 的分类方法是不行的，这个很好理解：最终卡在 lock 函数的卡顿，外面可能是很多不同的业务，例如可能是读取消息，可能是读取联系人，等等。卡顿监控需要仔细定义自己的分类规则。可以是从调用堆栈的最外层开始归类，或者是取中间一部分归类，或者是取最里面一部分归类。各有优缺点：</p><ul><li>最外层归类：能够将同一入口的卡顿归类起来。缺点是层数不好定，可能外面十来层都是系统调用，也有可能第一层就是微信的函数了。</li><li>中间层归类：能够根据事先划分好的“特征值”来归类。缺点是“特征值”不好定，如果要做到自动学习生成的话，对后台分析系统要求太高了。</li><li>最内层归类：能够将同一原因的卡顿归类起来。缺点是同一分类可能包含不同的业务。</li></ul><p>综合考虑并一一尝试之后，我们采用了最内层归类的优化版，亦即进行二级归类。</p><ul><li>第一级：按照 <strong>最内倒数2层</strong> 归类，这样能够将 <strong>同一原因</strong> 的卡顿集中起来；<ul><li>第二级分类是从第一级点击进来，然后按照 <strong>最内层倒数4层</strong> 进行归类，这样能够将同一原因，根据 <strong>不同业务(不同入口)</strong> 分散归类起来。</li></ul></li></ul><h3 id="3-9-可运营"><a href="#3-9-可运营" class="headerlink" title="3.9 可运营"></a>3.9 可运营</h3><p>在正式发布之前，我们进行了灰度，以评估卡顿对用户的影响。收集到的结果是用户平均每天会产生30个 dump 文件，压缩上传大约要 300k 流量。预计正式发布的话会对后台有比较大的压力，对用户也有一定流量损耗。所以必须进行抽样上报。</p><ul><li>抽样上报：每天抽取不同的用户进行上报，抽样概率是5%。</li><li>文件上传：被抽中的用户1天仅上传前20个堆栈文件，并且每次上报会进行多文件压缩上传。</li><li>白名单：对于需要跟进问题的用户，可以在后台配置白名单，强制上报。</li></ul><p>另外，为了减少对用户存储空间的影响，卡顿文件仅保存最近7天的记录，过期删除。</p><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=4">微信 iOS 卡顿监控系统</a></li><li><a href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">微信 Matrix 卡顿监控工具</a> </li><li><a href="https://time.geekbang.org/column/article/89494">13 | 如何利用 RunLoop 原理去监控卡顿？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、卡顿的难点&quot;&gt;&lt;a href=&quot;#一、卡顿的难点&quot; class=&quot;headerlink&quot; title=&quot;一、卡顿的难点&quot;&gt;&lt;/a&gt;一、卡顿的难点&lt;/h2&gt;&lt;p&gt;时不时会收到这样的卡顿反馈：“用户A 刚才碰到从后台切换前台卡了一下，最近偶尔会遇到几次”、“用户B</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="LagMonitor" scheme="https://tenloy.github.io/tags/LagMonitor/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI</title>
    <link href="https://tenloy.github.io/2021/06/29/SwiftUI.html"/>
    <id>https://tenloy.github.io/2021/06/29/SwiftUI.html</id>
    <published>2021-06-29T22:30:43.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的<strong>声明式框架</strong>。该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发。</p><h3 id="一、UIKit的不足"><a href="#一、UIKit的不足" class="headerlink" title="一、UIKit的不足"></a>一、UIKit的不足</h3><p>从 iOS SDK 2.0 开始，UIKit 已经伴随广大 iOS 开发者经历了接近十年的风风雨雨。UIKit 的思想继承了成熟的 AppKit 和 MVC，在初出时，为 iOS 开发者提供了良好的学习曲线。</p><p>UIKit 提供的是一套符合直觉的，基于控制流的命令式的编程方式。最主要的思想是在确保 View 或者 View Controller 生命周期以及用户交互时，相应的方法 (比如 <code>viewDidLoad</code> 或者某个 target-action 等) 能够被正确调用，从而构建用户界面和逻辑。不过，不管是从使用的便利性还是稳定性来说，UIKit 都面临着巨大的挑战。</p><p>UIKit 的基本思想要求 View Controller 承担绝大部分职责，它需要协调 model，view 以及用户交互。这带来了巨大的 side effect 以及大量的状态，如果没有妥善安置，它们将在 View Controller 中混杂在一起，同时作用于 view 或者逻辑，从而使状态管理愈发复杂，最后甚至不可维护而导致项目失败。不仅是作为开发者我们自己写的代码，UIKit 本身内部其实也经常受困于可变状态，各种奇怪的 bug 也频频出现。</p><h3 id="二、声明式编程的崛起"><a href="#二、声明式编程的崛起" class="headerlink" title="二、声明式编程的崛起"></a>二、声明式编程的崛起</h3><p>近年来，随着编程技术和思想的进步，使用声明式或者函数式的方式来进行界面开发，已经越来越被接受并逐渐成为主流。最早的思想大概是来源于 <a href="https://elm-lang.org/">Elm</a>，之后这套方式被 <a href="https://reactjs.org/">React</a> 和 <a href="https://flutter.dev/">Flutter</a> 采用，这一点上 SwiftUI 也几乎与它们一致。</p><ol><li><p>使用各自的 DSL 来描述「UI 应该是什么样子」，而不是用一句句的代码来指导「要怎样构建 UI」。</p><p>比如传统的 UIKit，我们会使用这样的代码来添加一个 “Hello World” 的标签，它负责“创建 label”，“设置文字”，“将其添加到 view 上”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">     <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">     label.text <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">     view.addSubview(label)</span><br><span class="line">     <span class="comment">// 省略了布局的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而相对起来，使用 SwiftUI 我们只需要告诉 SDK 我们需要一个文字标签：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来，框架内部读取这些 view 的声明，负责将它们以合适的方式绘制渲染。</p><p>注意，这些 view 的声明只是纯数据结构的描述，而不是实际显示出来的视图，因此这些结构的创建和差分对比并不会带来太多性能损耗。相对来说，将描述性的语言进行渲染绘制的部分是最慢的，这部分工作将交由框架以黑盒的方式为我们完成。</p></li><li><p>如果 <code>View</code> 需要根据某个状态 (state) 进行改变，那我们将这个状态存储在变量中，并在声明 view 时使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">   <span class="type">Text</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态发生改变时，框架重新调用声明部分的代码，计算出新的 view 声明，并和原来的 view 进行差分，之后框架负责对变更的部分进行高效的重新绘制。</p></li></ol><p>SwiftUI 的思想也完全一样，而且实际处理也不外乎这几个步骤。使用描述方式开发，大幅减少了在 app 开发者层面上出现问题的机率。</p><p>由于 Swift ABI 已经稳定，SwiftUI 是一个搭载在用户 iOS 系统上的 Swift 框架。因此它的<strong>最低支持的版本是 iOS 13，可能想要在实际项目中使用，还需要等待一两年时间</strong>。</p><h3 id="三、SwiftUI语法"><a href="#三、SwiftUI语法" class="headerlink" title="三、SwiftUI语法"></a>三、SwiftUI语法</h3><p>常用功能点：</p><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">教程 1 - Creating and Combining Views</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">SwiftUI app 的启动</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">关于 some View</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view">预览 SwiftUI</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#combine-views-using-stacks">关于 ViewBuilder</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-custom-image-view">链式调用修改 View 的属性</a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation">教程 2 - Building Lists and Navigation</a></p><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#create-the-list-of-landmarks">静态 <code>List</code></a></p></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#make-the-list-dynamic">动态 <code>List</code> 和 <code>Identifiable</code></a></p></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/handling-user-input">教程 3 - Handling User Input</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/handling-user-input#add-a-control-to-toggle-the-state"><code>@State</code> 和 <code>Binding</code></a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions">教程 5 - Animating Views and Transitions</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions#customize-view-transitions">两种动画的方式</a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/working-with-ui-controls">教程 7 - Working with UI Controls</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/working-with-ui-controls#delay-edit-propagation">关于 <code>View</code> 的生命周期</a></li></ul></li></ul><h3 id="四、学习资料"><a href="#四、学习资料" class="headerlink" title="四、学习资料"></a>四、学习资料</h3><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">官网教程</a></p></li><li><p><a href="https://onevcat.com/categories/swiftui/">SwiftUI — OneV</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的&lt;strong&gt;声明式框架&lt;/strong&gt;。该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发。&lt;/p&gt;
&lt;h3 id=&quot;一、UIKit的不足&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://tenloy.github.io/categories/Swift/"/>
    
    
    <category term="SwiftUI" scheme="https://tenloy.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>Swift版本更新API介绍</title>
    <link href="https://tenloy.github.io/2021/06/29/Swift-Version-History.html"/>
    <id>https://tenloy.github.io/2021/06/29/Swift-Version-History.html</id>
    <published>2021-06-29T21:01:31.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift-ABI-稳定"><a href="#Swift-ABI-稳定" class="headerlink" title="Swift ABI 稳定"></a>Swift ABI 稳定</h3><p>历时5年发展，从Swift1.x发展到了Swift5.x版本，经历了多次重大改变，ABI终于稳定。</p><p>ABI 稳定就是 binary 接口稳定，意味着Swift语法基本不会再有太大的变动。也就是在运行的时候只要是用 Swift 5 (或以上) 的编译器编译出来的 binary，就可以跑在任意的 Swift 5 (或以上) 的 runtime 上。这样，我们就不需要像以往那样在 app 里放一个 Swift runtime 了，Apple 会把它弄到 iOS 和 macOS 系统里。</p><ul><li><p>Xcode 10.2 搭载的 Swift 5.0 版本的编译器</p></li><li><p>iOS 12.2 系统预装了 Swift 5 的 runtime</p></li></ul><h2 id="Swift-5-1"><a href="#Swift-5-1" class="headerlink" title="Swift 5.1"></a>Swift 5.1</h2><p>见《Swift编程从入门到精通》学习笔记</p><h2 id="Swift-5-2"><a href="#Swift-5-2" class="headerlink" title="Swift 5.2"></a>Swift 5.2</h2><p>从表面上看，Swift 5.2 在新语言特性方面绝对是一个次要版本，因为这个新版本的大部分重点是提高 Swift 底层基础设施的速度和稳定性——例如如何报告编译器错误，以及如何解决构建级别的依赖关系。</p><p>然而，虽然 Swift 5.2 的新语言特性<em>总数</em>可能相对较少，但它确实包含了几个新功能，它们可能会对 Swift 作为<em>函数式编程语言</em>的整体能力产生相当大的影响。</p><h4 id="1-callAsFunction"><a href="#1-callAsFunction" class="headerlink" title="1. callAsFunction"></a>1. callAsFunction</h4><p>在 <a href="https://swiftgg.gitbook.io/swift/yu-yan-can-kao/06_declarations#methods-with-special-names">特殊名称方法</a> 章节中新增了有关让类、结构体和枚举的实例作为函数调用语法糖的内容。</p><p>一些含有特殊名称的方法允许使用函数调用语法糖。如果一个类型定义了某个此类型的方法，那这些类型的实例对象都可以使用函数调用语法。这些函数调用会被解析为某个具有特殊名称的实例方法调用。</p><h5 id="dynamicCallable补充"><a href="#dynamicCallable补充" class="headerlink" title="dynamicCallable补充"></a>dynamicCallable补充</h5><p>之前的 <a href="https://swiftgg.gitbook.io/swift/yu-yan-can-kao/07_attributes#dynamicCallable">dynamicCallable</a> 特性中：只要定义了 <code>dynamicallyCall(withArguments:)</code> 方法或者 <code>dynamicallyCall(withKeywordArguments:)</code> 方法，一个类、结构体或者枚举类型都支持函数调用语法。</p><p>该特性用于类、结构体、枚举或协议，以将该类型的实例视为可调用的函数。该类型必须实现上面两个方法之一，或两者同时实现。</p><p>可以调用 <code>dynamicCallable</code> 特性的实例，就像是调用一个任意数量参数的函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamicCallable</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TelephoneExchange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dynamicallyCall</span>(<span class="params">withArguments</span> <span class="params">phoneNumber</span>: [<span class="type">Int</span>])</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> phoneNumber <span class="operator">==</span> [<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Get Swift help on forums.swift.org&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Unrecognized number&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dial <span class="operator">=</span> <span class="type">TelephoneExchange</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态方法调用</span></span><br><span class="line">dial(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 打印“Get Swift help on forums.swift.org”</span></span><br><span class="line"></span><br><span class="line">dial(<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment">// 打印“Unrecognized number”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用底层方法</span></span><br><span class="line">dial.dynamicallyCall(withArguments: [<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>定义了一个函数调用方法（call-as-function method）也可以达到上述效果。如果一个类型同时定义了一个函数调用方法和使用 <code>dynamicCallable</code> 属性的方法，那么在合适的情况下，编译器会优先使用函数调用方法。</p><p>函数调用方法的名称是 <code>callAsFunction()</code>，或者任意一个以 <code>callAsFunction(</code> 开头并跟随着一些已标签化或未标签化的参数——例如 <code>callAsFunction(_:_:)</code> 和 <code>callAsFunction(something:)</code> 都是合法的函数调用方法名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallableStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callAsFunction</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>, <span class="params">scale</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(scale <span class="operator">*</span> (number <span class="operator">+</span> value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> callable <span class="operator">=</span> <span class="type">CallableStruct</span>(value: <span class="number">100</span>)</span><br><span class="line">callable(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line">callable.callAsFunction(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 两次函数调用都会打印 208</span></span><br></pre></td></tr></table></figure><h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h4><ul><li>更新 <a href="">下标选项</a> 章节，现在下标支持形参默认值。</li><li>更新 <a href="">自身类型</a> 章节，现在 <code>Self</code> 可以在更多上下文中使用。</li></ul><h2 id="Swift-5-3"><a href="#Swift-5-3" class="headerlink" title="Swift 5.3"></a>Swift 5.3</h2><h4 id="1-多尾随闭包"><a href="#1-多尾随闭包" class="headerlink" title="1. 多尾随闭包"></a>1. 多尾随闭包</h4><p>Swift 5.3 之前即使有多个尾随闭包也只有最后一个能被写成精简的形式，这种写法一个闭包在圆括号内，另一个在外面。新的写法把这些闭包都放在圆括号外面，显得更加简洁。<strong>注意：尾随闭包中的第一个闭包的标签会被强制省略。</strong></p><h4 id="2-枚举可比较"><a href="#2-枚举可比较" class="headerlink" title="2. 枚举可比较"></a>2. 枚举可比较</h4><h4 id="3-异常catch多值处理"><a href="#3-异常catch多值处理" class="headerlink" title="3. 异常catch多值处理"></a>3. 异常catch多值处理</h4><p>异常catch 后面可以捕获多个异常的值，以逗号隔开</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> <span class="type">FileReadError</span>.<span class="type">FileISNull</span>, <span class="type">FileReadError</span>.<span class="type">FileNotFound</span> &#123; <span class="comment">// 同时处理</span></span><br></pre></td></tr></table></figure><h4 id="4-main"><a href="#4-main" class="headerlink" title="4. @main"></a>4. <code>@main</code></h4><p>作为声明程序的入口点，替换掉以前的<code>@UIApplicationMain</code>。</p><h4 id="5-self改变"><a href="#5-self改变" class="headerlink" title="5. self改变"></a>5. self改变</h4><p>以前闭包中引用当前范围的内容时必须带上<code>self.</code>，Swift 5.3 之后如果不产生循环引用可以省略<code>self.</code>。这个新特性对 SwiftUI 来说非常友好，因为 SwiftUI 中的 View 保存在值类型的结构体中，所以不会发生循环引用。</p><h4 id="6-didSet性能提升"><a href="#6-didSet性能提升" class="headerlink" title="6. didSet性能提升"></a>6. didSet性能提升</h4><p>以前在一个属性中使用 didSet 时，总是调用 getter 来获取该属性的 oldValue（即使没有用到），从而影响性能。Swift 5.3 之后只有在<code>didSet</code>中使用了<code>oldValue</code>参数时，getter 才会被调用。</p><h4 id="7-语法缩进改进"><a href="#7-语法缩进改进" class="headerlink" title="7. 语法缩进改进"></a>7. 语法缩进改进</h4><p>guard 和 if 语句中的条件可以按列对齐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> x <span class="operator">=</span> optionalX,</span><br><span class="line">      <span class="keyword">let</span> y <span class="operator">=</span> optionalY <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x <span class="operator">=</span> optionalX,</span><br><span class="line">   <span class="keyword">let</span> y <span class="operator">=</span> optionalY &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-新增浮点型Float16"><a href="#8-新增浮点型Float16" class="headerlink" title="8. 新增浮点型Float16"></a>8. 新增浮点型Float16</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number: <span class="type">Float16</span> <span class="operator">=</span> <span class="number">5.0</span></span><br></pre></td></tr></table></figure><h4 id="9-新增日志API"><a href="#9-新增日志API" class="headerlink" title="9. 新增日志API"></a>9. 新增日志API</h4><p>提供了 5 种级别：</p><ul><li>Debug：Debug时使用。</li><li>Info：可以在排查问题时使用。</li><li>Notice (default)：默认，可以在排查问题时使用。</li><li>Error：在程序执行出错时使用。</li><li>Fault：在程序出现bug时使用。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建Logger实例</span></span><br><span class="line"><span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">Logger</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用log函数</span></span><br><span class="line">logger.log(level: .debug, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .info, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .default, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .error, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .fault, <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h4><ul><li>Swift Package Manager 功能增强。</li><li>Swift 语言性能继续提升。</li></ul><h2 id="Swift-5-4"><a href="#Swift-5-4" class="headerlink" title="Swift 5.4"></a>Swift 5.4</h2><h4 id="1-改进隐式成员语法"><a href="#1-改进隐式成员语法" class="headerlink" title="1. 改进隐式成员语法"></a>1. 改进隐式成员语法</h4><p>在 UIKit 和 SwiftUI 中设置颜色时，无法直接通过<code>.</code>的方式进行颜色的书写，必须带上前缀<code>UIColor</code>或者<code>Color</code>，因为无法根据上下文进行成员推测，Swift 5.4 中改进了这个语法，可以省去前缀且支持链式调用。</p><ul><li>UIKit</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">view.backgroundColor <span class="operator">=</span> .red.withAlphaComponent(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><ul><li>SwiftUI</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Swift 5.4&quot;</span>)</span><br><span class="line">            .foregroundColor(.red.opacity(<span class="number">0.5</span>))</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-支持多个可变参数"><a href="#2-支持多个可变参数" class="headerlink" title="2. 支持多个可变参数"></a>2. 支持多个可变参数</h4><p>Swift 5.4 之前函数只能有一个参数为可变参数， 现在支持多个可变参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">score</span>(<span class="params">courses</span>: <span class="type">String</span>..., <span class="params">scores</span>: <span class="type">Int</span>...)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> courses.count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;《<span class="subst">\(courses[i])</span>》课程的成绩：<span class="subst">\(scores[i])</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">score(courses: <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;iOS开发&quot;</span>, <span class="string">&quot;SwiftUI&quot;</span>, scores: <span class="number">90</span>, <span class="number">95</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="3-嵌套函数支持重载"><a href="#3-嵌套函数支持重载" class="headerlink" title="3. 嵌套函数支持重载"></a>3. 嵌套函数支持重载</h4><p>Swift 5.4 之前普通函数可以重载，现在嵌套函数也支持重载。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 内嵌函数一</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数二</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>, <span class="params">num3</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2 <span class="operator">+</span> num3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数三</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Double</span>, <span class="params">num2</span>: <span class="type">Double</span>)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数四</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span> <span class="params">num1</span>: <span class="type">Int</span>, <span class="params">b</span> <span class="params">num2</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(num1: <span class="number">10</span>, num2: <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line">    add(num1: <span class="number">10</span>, num2: <span class="number">20</span>, num3: <span class="number">30</span>) <span class="comment">// 60</span></span><br><span class="line">    add(num1: <span class="number">10.0</span>, num2: <span class="number">20.0</span>) <span class="comment">// 30</span></span><br><span class="line">    add(a: <span class="number">10</span>, b: <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method()</span><br></pre></td></tr></table></figure><h4 id="4-Result-builders"><a href="#4-Result-builders" class="headerlink" title="4. Result builders"></a>4. Result builders</h4><ul><li>Swift 5.4 之前叫 <strong>Function builders</strong>，它使用一个<code>buildBlock</code>方法可以将<strong>多个内容</strong>构建为<strong>一个结果</strong>，该特性在 SwiftUI 广泛使用。</li><li>可以使用<code>@resultBuilder</code>自定义 Result builders。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// buildBlock中将多个值构建为一个结果</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">strs</span>: <span class="type">String</span>...)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 以换行符拼接多个字符串</span></span><br><span class="line">        strs.joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if逻辑分支</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;if <span class="subst">\(component)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// else逻辑分支</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;else <span class="subst">\(component)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@StringBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildString</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="string">&quot;静夜思&quot;</span></span><br><span class="line">    <span class="string">&quot;唐•李白&quot;</span></span><br><span class="line">    <span class="string">&quot;床前明月光，疑是地上霜。&quot;</span></span><br><span class="line">    <span class="string">&quot;举头望明月，低头思故乡。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="type">Bool</span>.random() &#123;</span><br><span class="line">        <span class="string">&quot;一首诗&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;一首词&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buildString())</span><br></pre></td></tr></table></figure><h4 id="5-局部变量支持属性包装"><a href="#5-局部变量支持属性包装" class="headerlink" title="5. 局部变量支持属性包装"></a>5. 局部变量支持属性包装</h4><p>Swift 5.4 将 Swift 5.1 中引入的属性包装支持到局部变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性包装</span></span><br><span class="line"><span class="keyword">@propertyWrapper</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trimmed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; value <span class="operator">=</span> newValue.trimmingCharacters(in: .whitespacesAndNewlines) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">initialValue</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        wrappedValue <span class="operator">=</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trimed</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="meta">@Trimmed</span> <span class="keyword">var</span> content: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;  Swift 5.4 Property Wrappers  &quot;</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> post <span class="operator">=</span> <span class="type">Post</span>()</span><br><span class="line">        post.trimed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SwiftUI 中的应用。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义View</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomView</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性包装定义内容</span></span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> content: () -&gt; <span class="type">Content</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span>(.horizontal) &#123;</span><br><span class="line">            <span class="type">HStack</span>(content: content)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">CustomView</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">10</span>) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;heart&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift-5-5"><a href="#Swift-5-5" class="headerlink" title="Swift 5.5"></a>Swift 5.5</h2><p>在 <a href="https://developer.apple.com/videos/">WWDC21</a> 上，Apple 推出了Swift 5.5第一个快照版本</p><h4 id="1-Async-Await"><a href="#1-Async-Await" class="headerlink" title="1. Async/Await"></a>1. Async/Await</h4><p>在众多新功能中，最令人期待的功能之一是使用和 actor<a href="https://developer.apple.com/documentation/swift/swift_standard_library/concurrency">更好地支持并发</a><code>aysnc/await</code>。</p><h4 id="2-throwing-properties"><a href="#2-throwing-properties" class="headerlink" title="2. throwing properties"></a>2. throwing properties</h4><p><a href="https://www.hackingwithswift.com/articles/233/whats-new-in-swift-5-5">What’s new in Swift 5.5? — hackingwithswift</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://swift.org/blog/">https://swift.org/blog/</a></li><li><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift/04_revision_history">Swift版本历史记录—SwiftGG</a></li><li><a href="https://www.hackingwithswift.com/articles">Hacking With Swift</a>、<a href="https://www.swiftbysundell.com/articles/">Swift By Sundell</a>这是两个个人网站，可以在文章中搜5.4 5.5等查看</li><li><a href="https://juejin.cn/post/6913699890472648712">Swift 5.3 新特性 — YungFan</a></li><li><a href="https://juejin.cn/post/6961964537197101064">Swift 5.4 新特性 — YungFan</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Swift-ABI-稳定&quot;&gt;&lt;a href=&quot;#Swift-ABI-稳定&quot; class=&quot;headerlink&quot; title=&quot;Swift ABI 稳定&quot;&gt;&lt;/a&gt;Swift ABI 稳定&lt;/h3&gt;&lt;p&gt;历时5年发展，从Swift1.x发展到了Swift5.x版本</summary>
      
    
    
    
    <category term="Swift" scheme="https://tenloy.github.io/categories/Swift/"/>
    
    
    <category term="Swift-Syntax" scheme="https://tenloy.github.io/tags/Swift-Syntax/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出GCD常用API</title>
    <link href="https://tenloy.github.io/2021/06/28/GCD.html"/>
    <id>https://tenloy.github.io/2021/06/28/GCD.html</id>
    <published>2021-06-28T19:12:21.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是多线程编程？"><a href="#一、什么是多线程编程？" class="headerlink" title="一、什么是多线程编程？"></a>一、什么是多线程编程？</h2><p>先来复习一下<code>操作系统</code>中线程相关的知识点：</p><h3 id="1-1-代码的运行"><a href="#1-1-代码的运行" class="headerlink" title="1.1 代码的运行"></a>1.1 代码的运行</h3><p><strong>首先，代码是怎么运行的？</strong></p><ul><li>源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。</li><li>CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的地址会远离当前的位置（位置迁移），但是由于一个CUP一次只能执行一个命令，不能执行某处分开的并列的两个命令，因此通过CPU执行的CPU命令列就好比一条无分叉的大道，其执行不会出现分歧。</li></ul><p><strong>一个CPU执行的CPU命令列尾一条无分叉的路径即为“线程”</strong></p><h3 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h3><blockquote><p>OS X和ios的核心XNU内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路经。执行中路经的状态，例如CPU的寄存器的信息保存到各自路经专用的内存块中，从切换目标路经专用的内存块中，复原CPU寄存器的信息，继续执行切换路经的CPU命令列，这被称为“上下文切换”</p></blockquote><p>上下文切换是并行（单处理器中进程被交替执行，表现出并发外部特征）`的核心关键。</p><p>单核中的多线程是并发，其实是顺序执行的，只不过CPU高速的切换，表面看起来像是并行。<br>多核中的多线程，在线程数小于 &lt; CPU核数时，是真正的并行。</p><p>关于并发和并行的区别，可以看<a href="https://www.jianshu.com/p/446bf121ff8f">上一篇中的介绍</a></p><p><strong>iOS和OS X的核心 — XNU内核决定应当使用的线程数，并只生成所需的线程执行处理，另外，当处理结束，应当执行的处理数减少时，XNU内核会结束不再需要的线程，XNU内核仅使用并行队列便可完美的管理并行执行处理的线程</strong></p><h3 id="1-3-多线程编程的优缺点"><a href="#1-3-多线程编程的优缺点" class="headerlink" title="1.3 多线程编程的优缺点"></a>1.3 多线程编程的优缺点</h3><ul><li><p><strong>优点：</strong>保证应用程序的响应性能</p></li><li><p><strong>缺点</strong>：是易发生各种问题，比如：数据竞争、死锁，而且使用太多线程会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</p></li></ul><h3 id="1-4-主线程"><a href="#1-4-主线程" class="headerlink" title="1.4 主线程"></a>1.4 主线程</h3><p>应用程序启动时。通过最先执行的线程，即‘主线程’来描绘用户界面、处理触摸屏幕的事件，如果在该线程中进行长时间的处理，会造成主线程阻塞，会妨碍主线程中被称为RunLoop的主循环执行，从而导致不能更新用户界面、应用程序画面长时间停滞等问题</p><p><strong>GCD大大简化了偏于复杂的多线程编程的源代码，与Block结合使用，只需要将要执行的任务并追加到适当的Dispatch Queue</strong></p><h2 id="二、GCD基础篇"><a href="#二、GCD基础篇" class="headerlink" title="二、GCD基础篇"></a>二、GCD基础篇</h2><p>Grand Central Dispatch(GCD)</p><ul><li>是Apple推出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要再管理线程的生命周期，只需要关注于要执行的任务即可。</li><li>是异步执行任务的技术之一，用非常简洁的技术方法，实现了极为复杂繁琐的多线程编程</li></ul><p>GCD的源码libdispatch版本很多，源代码风格各版本都有不同，但大体逻辑没有太大变化。libdispatch的源码下载地址<a href="https://opensource.apple.com/tarballs/libdispatch/">在这里</a>。</p><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><p>阅读GCD的源码之前，先了解一些相关知识，方便后面的理解。</p><h4 id="2-1-1-DISPATCH-DECL"><a href="#2-1-1-DISPATCH-DECL" class="headerlink" title="2.1.1 DISPATCH_DECL"></a>2.1.1 DISPATCH_DECL</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure><p>GCD中的变量大多使用了这个宏，比如<code>DISPATCH_DECL(dispatch_queue)</code>展开后是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>；</span></span><br></pre></td></tr></table></figure><p>它的意思是定义一个<code>dispatch_queue_t</code>类型的指针，指向了一个<code>dispatch_queue_s</code>类型的结构体。</p><h4 id="2-1-2-fastpath-vs-slowpath"><a href="#2-1-2-fastpath-vs-slowpath" class="headerlink" title="2.1.2 fastpath vs slowpath"></a>2.1.2 fastpath vs slowpath</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span></span><br></pre></td></tr></table></figure><p><code>__builtin_expect</code>是编译器用来优化执行速度的函数，fastpath表示条件更可能成立，slowpath表示条件更不可能成立。我们在阅读源码的时候可以做忽略处理。</p><h4 id="2-1-3-TSD"><a href="#2-1-3-TSD" class="headerlink" title="2.1.3 TSD"></a>2.1.3 TSD</h4><p>Thread Specific Data(TSD)是指线程私有数据。在多线程中，会用全局变量来实现多个函数间的数据共享，局部变量来实现内部的单独访问。TSD则是能够在同一个线程的不同函数中被访问，在不同线程时，相同的键值获取的数据随线程不同而不同。可以通过pthread的相关api来实现TSD:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *, <span class="keyword">void</span> (* _Nullable)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* _Nullable <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> , <span class="keyword">const</span> <span class="keyword">void</span> * _Nullable)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-常用数据结构"><a href="#2-2-常用数据结构" class="headerlink" title="2.2 常用数据结构"></a>2.2 常用数据结构</h3><h4 id="2-2-1-dispatch-object-s结构体"><a href="#2-2-1-dispatch-object-s结构体" class="headerlink" title="2.2.1 dispatch_object_s结构体"></a>2.2.1 dispatch_object_s结构体</h4><p>dispatch_object_s是GCD最基础的结构体，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD的基础结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(object);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//os object头部宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OS_OBJECT_HEADER(isa, ref_cnt, xref_cnt) \</span></span><br><span class="line">        isa; <span class="comment">/* must be pointer-sized */</span> \  <span class="comment">//isa</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \             <span class="comment">//引用计数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt               <span class="comment">//外部引用计数，两者都为0时释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> struct dispatch_#<span class="meta">#x##_vtable_s *do_vtable, \  <span class="comment">//vtable结构体</span></span></span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \   <span class="comment">//下一个do</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \         <span class="comment">//目标队列</span></span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \                               <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *do_finalizer; \                          <span class="comment">//销毁时调用函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> do_suspend_cnt;                   <span class="comment">//suspend计数，用作暂停标志</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-dispatch-continuation-s结构体"><a href="#2-2-2-dispatch-continuation-s结构体" class="headerlink" title="2.2.2 dispatch_continuation_s结构体"></a>2.2.2 dispatch_continuation_s结构体</h4><p>dispatch_continuation_s结构体主要封装block和function，<code>dispatch_async</code>中的block最终都会封装成这个数据类型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_CONTINUATION_HEADER</span>(continuation);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continuation结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable, \                            do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                                 <span class="comment">//_OS_OBJECT_HEADER定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \                  <span class="comment">//执行内容</span></span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \                                <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *dc_data; \                                <span class="comment">//相关数据</span></span><br><span class="line">    <span class="keyword">void</span> *dc_other;                                 <span class="comment">//其他</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-dispatch-object-t联合体"><a href="#2-2-3-dispatch-object-t联合体" class="headerlink" title="2.2.3 dispatch_object_t联合体"></a>2.2.3 dispatch_object_t联合体</h4><p>dispatch_object_t是个union的联合体，可以用dispatch_object_t代表这个联合体里的所有数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span>             <span class="comment">//object结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span>       <span class="comment">//任务,dispatch_aync的block会封装成这个数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>              <span class="comment">//队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>        <span class="comment">//队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>              <span class="comment">//群组操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span>             <span class="comment">//source结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_aggregate_s</span> *_<span class="title">dta</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span>       <span class="comment">//source属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>       <span class="comment">//信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> __attribute__((__transparent_union__));</span><br></pre></td></tr></table></figure><h4 id="2-2-4-DISPATCH-VTABLE-HEADER宏"><a href="#2-2-4-DISPATCH-VTABLE-HEADER宏" class="headerlink" title="2.2.4 DISPATCH_VTABLE_HEADER宏"></a>2.2.4 DISPATCH_VTABLE_HEADER宏</h4><p>GCD中常见结构体（比如queue、semaphore等）的vtable字段中定义了很多函数回调，在后续代码分析中会经常看到，定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch vtable的头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_VTABLE_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> do_type; \     <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> do_kind; \       <span class="comment">//种类，比如:group/queue/semaphore</span></span><br><span class="line">    <span class="built_in">size_t</span> (*<span class="keyword">const</span> do_debug)(struct dispatch_#<span class="meta">#x##_s *, char *, size_t); \ <span class="comment">//debug用</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_invoke)(struct dispatch_#<span class="meta">#x##_s *); \    <span class="comment">//invoke回调</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in"><span class="keyword">long</span></span> (*<span class="keyword">const</span> do_probe)(struct dispatch_#<span class="meta">#x##_s *); \   <span class="comment">//probe回调</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_dispose)(struct dispatch_#<span class="meta">#x##_s *);     <span class="comment">//dispose回调，销毁时调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dx_xxx开头的宏定义，后续文章会用到，本质是调用vtable的do_xxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_type(x) (x)-&gt;do_vtable-&gt;do_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_metatype(x) ((x)-&gt;do_vtable-&gt;do_type &amp; _DISPATCH_META_TYPE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_kind(x) (x)-&gt;do_vtable-&gt;do_kind</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_debug(x, y, z) (x)-&gt;do_vtable-&gt;do_debug((x), (y), (z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_dispose(x) (x)-&gt;do_vtable-&gt;do_dispose(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_invoke(x) (x)-&gt;do_vtable-&gt;do_invoke(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-dispatch-queue-s-队列结构"><a href="#2-2-5-dispatch-queue-s-队列结构" class="headerlink" title="2.2.5 dispatch_queue_s(队列结构)"></a>2.2.5 dispatch_queue_s(队列结构)</h4><p>dispatch_queue_s是队列的结构体，也是GCD中开发者接触最多的结构体了，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(queue);    <span class="comment">//基础header</span></span><br><span class="line">    DISPATCH_QUEUE_HEADER;            <span class="comment">//队列头部，见下面的定义</span></span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; <span class="comment">// for static queues only</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列自己的头部定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_HEADER \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_running; \                       <span class="comment">//队列运行的任务数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> \   <span class="comment">//链表头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> \   <span class="comment">//链表尾部节点</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq_specific_q; \                     <span class="comment">//specific队列</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dq_width; \                                  <span class="comment">//队列并发数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dq_is_thread_bound:<span class="number">1</span>; \                  <span class="comment">//是否线程绑定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; \                         <span class="comment">//队列的序列号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dq_label; \                               <span class="comment">//队列名</span></span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_LIST;</span><br></pre></td></tr></table></figure><p>队列的do_table中有很多函数指针，阅读queue的源码时会遇到dx_invoke或者dx_probe等函数，它们其实就是调用vtable中定义的函数。下面看一下相关定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main-queue和普通queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_INSTANCE</span>(queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,    <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,      <span class="comment">//invoke函数</span></span><br><span class="line">    .do_probe = _dispatch_queue_probe,        <span class="comment">//probe函数</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,         <span class="comment">//debug回调</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//global-queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,  <span class="comment">//global-queue销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,              <span class="comment">//_dispatch_wakeup时会调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                    <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="三、GCD的API"><a href="#三、GCD的API" class="headerlink" title="三、GCD的API"></a>三、GCD的API</h2><h3 id="3-1-Dispatch-Queue-调度队列"><a href="#3-1-Dispatch-Queue-调度队列" class="headerlink" title="3.1 Dispatch Queue(调度队列)"></a>3.1 Dispatch Queue(调度队列)</h3><p><code>dispatch_queue</code>可以说是GCD编程中使用频率最高的API，这一节主要讲一下queue的相关用法和原理，关于queue的数据结构和常用定义见上节。</p><ul><li>Dispatch Queue按照追加的顺序（先进先出FIFO）执行处理</li><li>Dispatch Queue分两种：<ul><li>一种是等待现在执行中处理结束的 Serial Dispatch Queue(串行调度队列)</li><li>一种是不等待现在执行中处理结束的 Concurrent Dispatch Queue(并行调度队列)</li></ul></li><li>Dispatch Queue实例：<ul><li>库内置了两个队列：<ul><li>Main Dispatch Queue(串行队列)：追加到Main Dispatch Queue中的处理在主线程的RunLoop中执行</li><li>Global Dispatch Queue(并行队列)</li></ul></li><li>也可以用 dispatch_queue_create 来创建串行、并行队列</li></ul></li></ul><h4 id="3-1-1-使用"><a href="#3-1-1-使用" class="headerlink" title="3.1.1 使用"></a>3.1.1 使用</h4><h5 id="1-Global-Dispatch-Queue-并行队列"><a href="#1-Global-Dispatch-Queue-并行队列" class="headerlink" title="1. Global Dispatch Queue(并行队列)"></a>1. Global Dispatch Queue(并行队列)</h5><p>Global Dispatch Queue有4个执行优先级</p><ul><li>最高优先级（High Priority）</li><li>默认优先级（Default Priority）</li><li>低优先级（Low Priority）</li><li>后台优先级（Background Priority）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"></span><br><span class="line">dispatch_get_global_queue(优先级变量, unsigned long flags)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Global</span> Dispatch Quene有如下<span class="number">8</span>种:</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Overcommit Priority)</span><br></pre></td></tr></table></figure><ul><li><p>优先级中附有 Overcommit 的 Global Dispatch Quene 使用在 Serial Dispatch Quene中。</p><p>不管系统状态如何，都会强制生成线程的 Dispatch Quene。所以这也是不要大量生成串行队列的原因。对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现大量创建线程的状况。</p></li><li><p>同XNU内核用于 Global Dispatch Queue 的线程并<strong>不能保证实时性</strong>，所以优先级只是个大致判断。</p></li><li><p><strong>XNU内核管理，会将各自使用的队列的执行优先级，作为线程的执行优先级使用，所以添加任务时，需要选择与处理的任务对应优先级的队列。</strong></p></li><li><p>对上面两种队列执行 dispatch_retain 函数和 dispatch_release 函数无效，开发者无需关心这两者的保留、释放</p></li></ul><h5 id="2-dispatch-queue-create-创建队列"><a href="#2-dispatch-queue-create-创建队列" class="headerlink" title="2. dispatch_queue_create(创建队列)"></a>2. dispatch_queue_create(创建队列)</h5><ul><li><p>1个并行队列 + 多个异步任务(dispatch_async) = 会开启多线程</p></li><li><p>多个(1个串行队列+1个(同步/异步)任务(dispatch_sync)) = 多线程</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @参数1 指定Dispatch Queue名称（推荐使用应用程序ID这种逆序全程域名，该名称便于Xcode和Instruments调试，会出现在CrashLog中）</span></span><br><span class="line"><span class="comment"> * @参数2 Serial Dispatch Queue指定为NULL；Concurrent Dispatch Queue指定为DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 为表示Dispatch Queue的&quot;dispatch_queue_t类型&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create (<span class="string">&quot;com.example.MySerialDispatchQueue&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(mySerialDispatchQueue)</span><br></pre></td></tr></table></figure><ul><li><p>dispatch_queue_t 类型变量，必须程序员自己负责释放，像OC的引用计数式内存管理一样，需要通过 <code>dispatch_retain</code> 函数和 <code>dispatch_release</code> 函数的引用计数来管理内存。</p></li><li><p>在 <code>dispatch_async</code>、<code>diapatch_sync</code> 函数中追加 Block 到 Dispatch Queue（该 Block 通过 dispatch_retain 函数持有 Dispatch Queue）</p></li><li><p>一旦 Block 执行结束，就要通过 dispatch_release 函数函数释放该 Block 持有的 Dispatch Queue。</p></li></ul><p><strong>释放时机：</strong></p><ul><li><p>在 dispatch_async 函数中追加 Block 到 Dispatch Queue 后，即是立刻释放 Dispatch Queue，该 Dispatch Queue 由于被 Block 持有也不会废弃，因而 Block 能够执行，Block 执行结束后释放该 Block 持有的 Dispatch Queue，这时谁都不持有 Dispatch Queue，因此它被废弃。</p></li><li><p>在通过函数或方法名获取 Dispatch Queue 以及其他名称中包含 <code>creat</code> 的API生成的对象时，有必要通过 dispatch_retain 函数持有，并在不需要时通过 dispatch_release 函数释放。</p></li></ul><p>系统对于一个串行队列，就只生成并使用一个线程，所以串行队列的生成个数应当仅限所必需的数量，不能大量生成。</p><p>对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现串行队列那种问题。</p><h5 id="3-dispatch-set-target-queue"><a href="#3-dispatch-set-target-queue" class="headerlink" title="3. dispatch_set_target_queue"></a>3. dispatch_set_target_queue</h5><p>dispatch_queue_create函数生成的队列，生成的线程优先级为 Global Dispatch Queue 的默认优先级。</p><p>变更生成的Dispatch Queue的执行优先级要使用dispatch_set_target_queue函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalDispatchQueueBackground = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_PRIORITY_BACKGROUND ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指定要变更执行优先级的Dispatch Queue为dispatch_set_target_queue函数的第一个参数</span></span><br><span class="line"><span class="comment"> * 指定与要使用的执行优先级相同优先级的Dispatch Queue为第二个参数（目标）</span></span><br><span class="line"><span class="comment"> * Main Dispatch Queue和Global Dispatch Queue不可指定为第一个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_set_target_queue</span>(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>变更执行优先级</li><li>目标队列会变成第一个参数队列中任务的执行阶层<ul><li>多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理（可防止 Serial Dispatch Queue 处理并行执行）</li><li>使多个serial队列变并行为串行</li></ul></li></ul><h5 id="4-dispatch-async与dispatch-sync"><a href="#4-dispatch-async与dispatch-sync" class="headerlink" title="4. dispatch_async与dispatch_sync"></a>4. dispatch_async与dispatch_sync</h5><p>当我们处理耗时操作时，比如读取数据库、请求网络数据，为了避免这些耗时操作卡住UI,可将耗时任务放到子线程中，执行完成后再通知主线程更新UI。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Submits a block for asynchronous execution on a dispatch queue and returns immediately.</span></span><br><span class="line"><span class="comment">  在分派队列上提交一个用于异步执行的块，然后立即返回。如果不是主队列就会开启新的线程，但不管开启不开启，都是马上返回的，不会阻塞！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  dispatch_sync：Submits a block object for execution and returns after that block finishes executing.</span></span><br><span class="line"><span class="comment">  即在当前线程同步执行任务，执行完毕才能继续往下执行。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">         <span class="comment">//更新UI</span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-1-2-原理"><a href="#3-1-2-原理" class="headerlink" title="3.1.2 原理"></a>3.1.2 原理</h4><h5 id="1-dispatch-get-global-queue"><a href="#1-dispatch-get-global-queue" class="headerlink" title="1. dispatch_get_global_queue"></a>1. dispatch_get_global_queue</h5><p>dispatch_get_global_queue用于获取一个全局队列，先看一下它的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_get_global_queue</span><span class="params">(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装调用_dispatch_get_root_queue函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(priority,</span><br><span class="line">            flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">long</span> priority, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (overcommit) <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列优先级有八个，分别为低、默认、高、后台以及对应的overcommit。枚举定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY = <span class="number">0</span>,                <span class="comment">//低优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY,         <span class="comment">//低优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY,                <span class="comment">//默认优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY,     <span class="comment">//默认优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY,                   <span class="comment">//高优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY,        <span class="comment">//高优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY,             <span class="comment">//后台</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY,  <span class="comment">//后台+overcomit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_dispatch_get_root_queue</code>从_dispatch_root_queues结构体中获取对应优先级的队列。最后1bit为1的代表overcommit，带有overcommit标记的队列会在任务提交时新创建一个线程处理它。</p><p><code>_dispatch_root_queues</code>取出的<code>dispatch_queue_s</code>队列的do_ctxt字段表示queue的线程池，定义于<code>_dispatch_root_queue_contexts</code>结构体中，每个线程池的最大线程数限制是255。</p><p>下面看一下global queue的do_vtable结构体，它比较重要的是do_probe的调用函数<code>_dispatch_root_queue_probe</code>,这个函数在后续的分析中会用到。结构体定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose, <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,             <span class="comment">//重要，唤醒队列时调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                   <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-get-main-queue"><a href="#2-dispatch-get-main-queue" class="headerlink" title="2. dispatch_get_main_queue"></a>2. dispatch_get_main_queue</h5><p>该API的使用主要是在更新UI时获取<code>dispatch_get_main_queue()</code>并把任务提交到主队列中。它的源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义，返回到是_dispatch_main_q</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_get_main_queue() \</span></span><br><span class="line">        <span class="built_in">DISPATCH_GLOBAL_OBJECT</span>(<span class="keyword">dispatch_queue_t</span>, _dispatch_main_q)</span><br><span class="line"></span><br><span class="line"><span class="comment">//main_queue结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_main_q</span> =</span> &#123;</span><br><span class="line">    .do_vtable = <span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">    .do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],  <span class="comment">//目标队列</span></span><br><span class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,   </span><br><span class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,  </span><br><span class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,   <span class="comment">//队列名</span></span><br><span class="line">    .dq_running = <span class="number">1</span>,          </span><br><span class="line">    .dq_width = <span class="number">1</span>,            <span class="comment">//最大并发数是1，串行队列</span></span><br><span class="line">    .dq_is_thread_bound = <span class="number">1</span>,  <span class="comment">//线程绑定</span></span><br><span class="line">    .dq_serialnum = <span class="number">1</span>,        <span class="comment">//序列号为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main queue设置了并发数为1，即串行队列,并且将targetq指向com.apple.root.default-overcommit-priority队列。</p><h5 id="3-dispatch-queue-create"><a href="#3-dispatch-queue-create" class="headerlink" title="3. dispatch_queue_create"></a>3. dispatch_queue_create</h5><p><code>dispatch_queue_create</code>主要用来创建自定义的队列，流程图和源码如下：</p><img src="/images/GCD/dispatch_queue-1.png" alt="img" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用dispatch_queue_create_with_target</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dispatch_queue_create_with_target</span>(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_queue_create具体实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create_with_target</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_queue_attr_t</span> attr, <span class="keyword">dispatch_queue_t</span> tq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">   <span class="comment">//申请内存空间</span></span><br><span class="line">    dq = _dispatch_alloc(<span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">            <span class="built_in"><span class="keyword">sizeof</span></span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">  <span class="comment">//初始化，设置自定义队列的基本属性，方法实现见下面</span></span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">       <span class="comment">//设置队列名</span></span><br><span class="line">        dq-&gt;dq_label = <span class="built_in">strdup</span>(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attr == DISPATCH_QUEUE_CONCURRENT) &#123;</span><br><span class="line">       <span class="comment">//并行队列设置dq_width为UINT32_MAX</span></span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY</span></span><br><span class="line">            <span class="comment">// Default target queue is overcommit!</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置自定义队列的目标队列，dq队列的任务会放到目标队列执行</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列初始化方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;dq_running = <span class="number">0</span>;      <span class="comment">//队列当前运行时初始为0</span></span><br><span class="line">    dq-&gt;dq_width = <span class="number">1</span>;        <span class="comment">//队列并发数默认为1，串行队列</span></span><br><span class="line">    dq-&gt;dq_serialnum = <span class="built_in">dispatch_atomic_inc_orig</span>(&amp;_dispatch_queue_serial_numbers,</span><br><span class="line">            relaxed);          <span class="comment">//序列号,在_dispatch_queue_serial_numbers基础上原子性加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码介绍了自定义队列是如何创建的，初始化时会将dq_width默认设置为1，即串行队列。如果外部设置attr为DISPATCH_QUEUE_CONCURRENT，将并发数改为UINT32_MAX；<br>自定义队列的serialnum是在_dispatch_queue_serial_numbers基础上原子性加一，即从12开始累加。1到11被保留的序列号定义如下（后续版本有改动，自定义序列从16开始累加）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip zero        //跳过0</span></span><br><span class="line"><span class="comment">// 1 - main_q       //主队列</span></span><br><span class="line"><span class="comment">// 2 - mgr_q        //管理队列</span></span><br><span class="line"><span class="comment">// 3 - mgr_root_q   //管理队列的目标队列</span></span><br><span class="line"><span class="comment">// 4,5,6,7,8,9,10,11 - global queues   //全局队列</span></span><br><span class="line"><span class="comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">volatile</span> _dispatch_queue_serial_numbers = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>同时还会设置队列的target_queue，向队列提交的任务，都会被放到它的目标队列来执行。串行队列的target_queue是一个支持overcommit的全局队列，而全局队列的底层则是一个线程池。</p><p>借用一张队列的图片：</p><img src="/images/GCD/dispatch_queue-2.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-async"><a href="#4-dispatch-async" class="headerlink" title="4. dispatch_async"></a>4. dispatch_async</h5><p><code>dispatch_async</code>用来异步执行任务，它的代码比较复杂，我们可以分成三个阶段来看，第一阶段是更新队列链表，第二部分是从队列取任务，第三部分则是执行任务。每个阶段都有一张流程图表示，觉得代码多的话可以直接看每个阶段对应的流程图。</p><p>首先看一下<code>dispatch_async</code>的入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_async封装调用了dispatch_async_f函数，先将block拷贝到堆上，避免block执行前被销毁，同时传入_dispatch_call_block_and_release来保证block执行后会执行Block_release。下面看一下dispatch_async_f的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//如果是串行队列，执行dispatch_barrier_async_f，和当前函数的不同点在于</span></span><br><span class="line">       <span class="comment">//.do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务封装到dispatch_continuation_t结构体中</span></span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;  <span class="comment">//将vtable设置为ASYNC标志位</span></span><br><span class="line">    dc-&gt;dc_func = func; </span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;do_targetq) &#123;</span><br><span class="line">       <span class="comment">//如果有do_targetq，将任务放到目标队列执行</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务压入队列(FIFO)</span></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析一下_dispatch_queue_push，这是一个宏定义，展开后的调用栈如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push</span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br></pre></td></tr></table></figure><p>看一下_dispatch_queue_push的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> =</span> _tail._do;</span><br><span class="line">    <span class="comment">//判断链表中是否已经存在节点，有的话返回YES,否则返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(_dispatch_queue_push_list2(dq, tail, tail))) &#123;</span><br><span class="line">       <span class="comment">//将任务放到链表头部</span></span><br><span class="line">        _dispatch_queue_push_slow(dq, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断链表中是否已经存在节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_queue_push_list2(<span class="keyword">dispatch_queue_t</span> dq, struct dispatch_object_s *head,</span><br><span class="line">        struct dispatch_object_s *tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">    tail-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将tail原子性赋值给dq-&gt;dq_items_tail，同时返回之前的值并赋给prev</span></span><br><span class="line">    prev = <span class="built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail, release);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(prev)) &#123;</span><br><span class="line">       <span class="comment">//如果prev不等于NULL，直接在链表尾部添加节点</span></span><br><span class="line">        prev-&gt;do_next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中之前有元素返回YES，否则返回NO</span></span><br><span class="line">    <span class="keyword">return</span> (prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点放到链表开头</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push_slow(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dx_type</span>(dq) == DISPATCH_QUEUE_ROOT_TYPE &amp;&amp; !dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">       <span class="comment">//原子性的将head存储到链表头部</span></span><br><span class="line">        <span class="built_in">dispatch_atomic_store2o</span>(dq, dq_items_head, obj, relaxed);</span><br><span class="line">        <span class="comment">//唤醒global queue队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将obj放到链表头部并执行_dispatch_wakeup函数里的dx_probe()函数</span></span><br><span class="line">    _dispatch_queue_push_list_slow2(dq, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出<code>_dispatch_queue_push</code>分为两种情况：</p><ul><li>如果队列的链表不为空，将节点添加到链表尾部，即dq-&gt;dq_item_tail=dc。然后队列会按先进先出(FIFO)来处理任务。</li><li>如果队列此时为空，进入到<code>_dispatch_queue_push_slow</code>函数。<ul><li>如果队列是全局队列会进入if分支，原子性的将节点添加到队列开头，并执行<code>_dispatch_queue_wakeup_global</code>唤醒全局队列；</li><li>如果队列是主队列或自定义串行队列if分支判断不成立，执行<code>_dispatch_queue_push_list_slow2</code>函数，它会将节点添加到队列开头并执行<code>_dispatch_wakeup</code>函数唤醒队列。</li></ul></li></ul><p><code>dispatch_async</code>第一阶段的工作主要是封装外部任务并添加到队列的链表中，可以用下图来表示：</p><img src="/images/GCD/dispatch_queue-3.png" alt="img" style="zoom:80%;" /><p>接着来看队列唤醒的逻辑，主要分成主队列和全局队列的唤醒和任务执行逻辑：</p><p>1、如果是主队列，会先调用<code>_dispatch_wakeup</code>唤醒队列，然后执行<code>_dispatch_main_queue_wakeup</code>函数来唤醒主线程的Runloop，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_wakeup(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_dispatch_queue_probe判断dq_items_tail是否为空，if分支不成立</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dx_probe</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果dou._do-&gt;do_suspend_cnt==0，返回YES,否则返回NO；</span></span><br><span class="line">    <span class="comment">//同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="number">0</span>,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_LOCK, release)) &#123;</span><br><span class="line">            <span class="comment">//因为主线程do_suspend_cnt非0，所以主线程if分支判断成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">        <span class="keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">            <span class="comment">//主队列的任务执行和Runloop关联，唤醒主队列</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_main_queue_wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到目标队列中，重新走_dispatch_queue_push方法</span></span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> tq = dou._do-&gt;do_targetq;</span><br><span class="line">    _dispatch_queue_push(tq, dou._do);</span><br><span class="line">    <span class="keyword">return</span> tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒主线程Runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_main_queue_wakeup(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">    <span class="keyword">if</span> (!dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只初始化一次mach_port_t</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, dq,</span><br><span class="line">            _dispatch_runloop_queue_port_init);</span><br><span class="line">    _dispatch_runloop_queue_wakeup_thread(dq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_wakeup_thread(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> mp = (<span class="keyword">mach_port_t</span>)dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">if</span> (!mp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒主线程的runloop</span></span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (kr) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。用Xcode在block处打断点就会看到下图中的调用栈:</p><img src="/images/GCD/dispatch_queue-4.png" alt="img" style="zoom:80%;" /><p>2、如果是全局队列，调用_dispatch_queue_wakeup_global函数，它封装调用了核心函数<code>_dispatch_queue_wakeup_global_slow</code>，调用栈和核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global_slow</span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_wakeup_global_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">unsigned</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="comment">//初始化dispatch_root_queue_context_s</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;pred, <span class="literal">NULL</span>, _dispatch_root_queues_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--i) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测线程池可用大小，如果还有，则将线程池减一</span></span><br><span class="line">    <span class="keyword">uint32_t</span> j, t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!t_count) &#123;</span><br><span class="line">          <span class="comment">//线程池已达到最大使用量</span></span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;pthread pool is full for root queue: &quot;</span></span><br><span class="line">                    <span class="string">&quot;%p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i &gt; t_count ? t_count : i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="built_in">dispatch_atomic_cmpxchgvw2o</span>(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">            t_count - j, &amp;t_count, relaxed));</span><br><span class="line">   <span class="comment">//创建新的线程，入口函数是_dispatch_worker_thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        _dispatch_retain(dq);</span><br><span class="line">        <span class="keyword">while</span> ((r = <span class="built_in">pthread_create</span>(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_temporary_resource_shortage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!attr) &#123;</span><br><span class="line">            r = <span class="built_in">pthread_detach</span>(*pthr);</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_USE_PTHREAD_POOL</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的线程后执行<code>_dispatch_worker_thread</code>函数，代码简化后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _dispatch_worker_thread(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> timeout = (pqc ? <span class="number">5ull</span> : <span class="number">65ull</span>) * NSEC_PER_SEC;</span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//取出一个任务并执行</span></span><br><span class="line">        _dispatch_root_queue_drain(dq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_wait</span>(qc-&gt;dgq_thread_mediator,</span><br><span class="line">            <span class="built_in">dispatch_time</span>(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将线程池加一</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_inc2o</span>(qc, dgq_thread_pool_size, relaxed);</span><br><span class="line">    _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    _dispatch_release(dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列取任务的入口是_dispatch_root_queue_drain函数，简化的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">// ensure that high-level memory management techniques do not leak/crash</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_begin_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_begin_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//autoreleasepool的push操作</span></span><br><span class="line">    <span class="keyword">void</span> *pool = _dispatch_autorelease_pool_push();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="comment">//取出队列的头部节点(FIFO)</span></span><br><span class="line">    <span class="keyword">while</span> ((item = <span class="built_in">fastpath</span>(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="comment">//对取出的内容进行处理，核心函数</span></span><br><span class="line">        _dispatch_continuation_pop(item);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_perfmon_end();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">//autoreleasepool的pop操作</span></span><br><span class="line">    _dispatch_autorelease_pool_pop(pool);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_end_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_end_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列唤醒后的工作主要是用线程池(全局队列)或者唤醒Runloop(主队列)的方式从队列的链表中依次取出要执行的任务，流程图如下：</p><img src="/images/GCD/dispatch_queue-5.png" alt="img" style="zoom:80%;" /><p>队列的任务取出之后就是核心的执行逻辑了，也就是<code>_dispatch_continuation_pop</code>函数的逻辑，代码和流程图如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line"></span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断传入的内容是不是队列，如果是的话执行_dispatch_queue_invoke函数，否的话就是block型的</span></span><br><span class="line">    <span class="comment">//任务，直接执行block即可</span></span><br><span class="line">    <span class="comment">//dispatch_barrier_async到自定义并行队列时,dou._do是用户创建的自定义queue，此时会执行</span></span><br><span class="line">    <span class="comment">//_dispatch_queue_invoke，并且用信号量保证barrier的任务不会和其他任务同时执行，后续分析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dx_invoke</span>(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否带有DISPATCH_OBJ_ASYNC_BIT标志位</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">        dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是group</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行dc-&gt;dc_func(dc-&gt;ctxt)</span></span><br><span class="line">    <span class="comment">//本质是调用Block_layout结构体的invoke执行block的实现代码</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//如果是群组执行dispatch_group_leave</span></span><br><span class="line">        <span class="built_in">dispatch_group_leave</span>(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">     _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/GCD/dispatch_queue-6.png" alt="img" style="zoom:80%;" /><p>总结一下：<code>dispatch_async</code>的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。</p><h5 id="5-dispatch-sync"><a href="#5-dispatch-sync" class="headerlink" title="5. dispatch_sync"></a>5. dispatch_sync</h5><p>了解了dispatch_async的逻辑后，再来看下dispatch_sync的实现和流程。<code>dispatch_sync</code>主要封装调用了<code>dispatch_sync_f</code>函数，看一下具体代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">//串行队列执行同步方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">       <span class="comment">//global queue不要求执行顺序，直接执行具体的block</span></span><br><span class="line">        <span class="comment">// the global concurrent queues do not need strict ordering</span></span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并发队列压入同步方法</span></span><br><span class="line">    _dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，后续逻辑主要分为两种情况：</p><p>1、向串行队列提交同步任务，执行dispatch_barrier_sync_f函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>, acquire))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。<code>_dispatch_barrier_sync_f_invoke</code>代码逻辑展开后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="comment">//任务执行核心逻辑，将当前线程的dispatch_queue_key设置为dq，然后执行block，</span></span><br><span class="line">    <span class="comment">//执行完之后再恢复到之前的old_dq</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f2(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_dec2o</span>(dq, dq_running, release) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列存在其他任务或者被挂起，调用<code>_dispatch_barrier_sync_f_slow</code>函数，等待该队列的任务执行完之后用信号量通知队列继续执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dc</span> =</span> &#123;</span><br><span class="line">        .dc_data = dq,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dbss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_BARRIER_BIT |</span><br><span class="line">                DISPATCH_OBJ_SYNC_SLOW_BIT),</span><br><span class="line">        .dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">        .dc_ctxt = &amp;dc,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用信号量等待其他任务执行完成</span></span><br><span class="line">    _dispatch_queue_push(dq, &amp;dbss);</span><br><span class="line">    _dispatch_thread_semaphore_wait(sema); <span class="comment">// acquire</span></span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//收到signal信号，继续执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、向并发队列提交同步任务，执行<code>_dispatch_sync_f2</code>函数。如果队列存在其他任务，或者队列被挂起，或者有正在执行的任务，则调用<code>_dispatch_sync_f_slow</code>函数，使用信号量等待，否则直接调用<code>_dispatch_sync_f_invoke</code>执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> running = <span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">    <span class="comment">// re-check suspension after barrier check &lt;rdar://problem/15242126&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(running &amp; <span class="number">1</span>) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq))) &#123;</span><br><span class="line">        running = <span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, running == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列存在其他任务|队列被挂起|有正在执行的任务，信号等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">        <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span>*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push_wakeup(dq, &amp;dss, wakeup);</span><br><span class="line">    <span class="comment">//信号等待</span></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//信号唤醒，执行同步任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_sync</code>的逻辑主要是将任务放入队列，并用线程专属信号量做等待，保证每次只会有一个block在执行。流程图如下：</p><img src="/images/GCD/dispatch_queue-7.png" alt="img" style="zoom:80%;" /><h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><p>dispatch_async将任务添加到队列的链表中并唤醒队列，全局队列唤醒时中会从线程池里取出可用线程，如果没有则会新建线程，然后在线程中执行队列取出的任务;主队列会唤醒主线程的Runloop，然后在Runloop循环中通知GCD执行主队列提交的任务。</p><p>dispatch_sync一般都在当前线程执行,如果是主队列的任务还是会切换到主线程执行。它使用线程信号量来实现串行执行的功能。</p><h3 id="3-2-Dispatch-Semaphore"><a href="#3-2-Dispatch-Semaphore" class="headerlink" title="3.2 Dispatch Semaphore"></a>3.2 Dispatch Semaphore</h3><h4 id="3-2-1-API介绍"><a href="#3-2-1-API介绍" class="headerlink" title="3.2.1 API介绍"></a>3.2.1 API介绍</h4><p>Dispatch Semaphore是持有计数的信号，该信号是多线程编程中的计数类型信号。所谓信号，类似过马路时常用的手旗，可以通过时举起手旗，不可以通过时放下手旗。</p><p>在Dispatch Semaphore中，使用计数来实现该功能：<strong>计数为0时等待，计数为1或大于1时，减去1而不等待</strong>。</p><p>信号量的使用比较简单，主要就三个API：<code>create</code>、<code>wait</code>和<code>signal</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使用dispatch_semaphore_create函数生成Dispatch Semaphore</span></span><br><span class="line"><span class="comment"> * 参数value是信号量计数的初始值</span></span><br><span class="line"><span class="comment"> * 函数名称中包含create，必须自己通过dispatch_release函数释放，和dispatch_retain函数持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">intptr_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值大于等于1，或者待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值为0时会等待(直到超时)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout：等待时间 dispatch_time_t类型。DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="comment"> * @return 返回值与dispatch_group_wait函数相同，0表示执行完；超时时返回非0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让信号量值加一，如果有通过dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值增加的线程，会由系统唤醒最先等待的线程执行。</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 </span></span><br><span class="line"><span class="built_in">dispatch_release</span>(semaphore);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-原理"><a href="#3-2-2-原理" class="headerlink" title="3.2.2 原理"></a>3.2.2 原理</h4><h5 id="1-dispatch-semaphore-t"><a href="#1-dispatch-semaphore-t" class="headerlink" title="1.dispatch_semaphore_t"></a>1.dispatch_semaphore_t</h5><p>首先看一下<code>dispatch_semaphore_s</code>的结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> &#123;</span></span><br><span class="line">    DISPATCH_STRUCT_HEADER(semaphore);</span><br><span class="line">    <span class="keyword">semaphore_t</span> dsema_port;    <span class="comment">//等同于mach_port_t信号</span></span><br><span class="line">    <span class="keyword">long</span> dsema_orig;           <span class="comment">//初始化的信号量值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_value; <span class="comment">//当前信号量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_sent_ksignals;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_group_waiters;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_head</span>;</span> <span class="comment">//notify的链表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_tail</span>;</span> <span class="comment">//notify的链表尾部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-semaphore-create"><a href="#2-dispatch-semaphore-create" class="headerlink" title="2. dispatch_semaphore_create"></a>2. dispatch_semaphore_create</h5><p><code>dispatch_semaphore_create</code>用来创建信号量，创建时需要指定value，内部会将value的值存储到dsema_value(当前的value)和dsema_orig(初始value)中，value的值必须大于或等于0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//value值需大于或等于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//申请dispatch_semaphore_t的内存</span></span><br><span class="line">    dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_semaphore_s) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_head) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_tail));</span><br><span class="line">    <span class="comment">//调用初始化函数</span></span><br><span class="line">    _dispatch_semaphore_init(value, dsema);</span><br><span class="line">    <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化结构体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_semaphore_init(<span class="keyword">long</span> value, <span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line">    dsema-&gt;do_next = (<span class="keyword">dispatch_semaphore_t</span>)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dsema-&gt;do_targetq = dispatch_get_global_queue(</span><br><span class="line">            DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dsema-&gt;dsema_value = value; <span class="comment">//设置信号量的当前value值</span></span><br><span class="line">    dsema-&gt;dsema_orig = value;  <span class="comment">//设置信号量的初始value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着来看Dispatch Semaphore很容易忽略也是最容易造成App崩溃的地方，即信号量的释放。</strong></p><p>创建Semaphore的时候会将do_vtable指向_dispatch_semaphore_vtable，_dispatch_semaphore_vtable的结构定义了信号量销毁的时候会执行<code>_dispatch_semaphore_dispose</code>方法，相关代码实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore的vtable定义</span></span><br><span class="line">DISPATCH_VTABLE_INSTANCE(semaphore,</span><br><span class="line">    .do_type = DISPATCH_SEMAPHORE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;semaphore&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_semaphore_dispose,  <span class="comment">//销毁时执行的回调函数</span></span><br><span class="line">    .do_debug = _dispatch_semaphore_debug,      <span class="comment">//debug函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放信号量的函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_semaphore_dispose(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">       <span class="comment">//Warning:信号量还在使用的时候销毁会造成崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Semaphore/group object deallocated while in use&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_port) &#123;</span><br><span class="line">        kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_port);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果销毁时信号量还在使用，那么dsema_value会小于dsema_orig，则会引起崩溃，这是一个特别需要注意的地方。这里模拟一下信号量崩溃的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semephore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">dispatch_semaphore_wait(semephore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//重新赋值或者将semephore = nil都会造成崩溃,因为此时信号量还在使用中</span></span><br><span class="line">semephore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="3-dispatch-semaphore-wait"><a href="#3-dispatch-semaphore-wait" class="headerlink" title="3. dispatch_semaphore_wait"></a>3. dispatch_semaphore_wait</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>先将信号量的dsema值原子性减一，并将新值赋给value。如果value大于等于0就立即返回，否则调用<code>_dispatch_semaphore_wait_slow</code>函数，等待信号量唤醒或者timeout超时。<code>_dispatch_semaphore_wait_slow</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">        <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    orig = dsema-&gt;dsema_sent_ksignals;</span><br><span class="line">    <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">                orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_semaphore_wait_slow</code>函数根据timeout的类型分成了三种情况处理：</p><ol><li>DISPATCH_TIME_NOW：若<code>desma_value</code>小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT，原子性加一是为了抵消<code>dispatch_semaphore_wait</code>函数开始的减一操作。</li><li>DISPATCH_TIME_FOREVER：调用系统的<code>semaphore_wait</code>方法，直到收到<code>signal</code>调用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = semaphore_wait(dsema-&gt;dsema_port);</span><br></pre></td></tr></table></figure><ol start="3"><li>default：调用内核方法<code>semaphore_timedwait</code>计时等待，直到有信号到来或者超时了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>的流程图可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-1.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-semaphore-signal"><a href="#4-dispatch-semaphore-signal" class="headerlink" title="4. dispatch_semaphore_signal"></a>4. dispatch_semaphore_signal</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">       <span class="comment">//Warning：value值有误会造成崩溃，详见下篇dispatch_group的分析</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将dsema_value调用原子方法加1，如果大于零就立即返回0，否则进入<code>_dispatch_semaphore_signal_slow</code>方法，该函数会调用内核的<code>semaphore_signal</code>函数唤醒在<code>dispatch_semaphore_wait</code>中等待的线程。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _dispatch_semaphore_signal_slow(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    _dispatch_retain(dsema);</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals, relaxed);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"></span><br><span class="line">    _dispatch_release(dsema);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_signal</code>的流程比较简单，可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-2.png" alt="img" style="zoom:80%;" /><h5 id="5-总结篇"><a href="#5-总结篇" class="headerlink" title="5. 总结篇"></a>5. 总结篇</h5><p>Dispatch Semaphore信号量主要是<code>dispatch_semaphore_wait</code>和<code>dispatch_semaphore_signal</code>函数，<code>wait</code>会将信号量值减一，如果大于等于0就立即返回，否则等待信号量唤醒或者超时；<code>signal</code>会将信号量值加一，如果value大于0立即返回，否则唤醒某个等待中的线程。</p><p>需要注意的是信号量在销毁或重新创建的时候如果还在使用则会引起崩溃，详见上面的分析。</p><h4 id="3-2-3-应用"><a href="#3-2-3-应用" class="headerlink" title="3.2.3 应用"></a>3.2.3 应用</h4><p>1、信号量常用于对资源进行加锁操作，防止多线程访问修改数据出现结果不一致甚至崩溃的问题，代码示例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在init等函数初始化</span></span><br><span class="line">_lock = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="comment">//修改Array或字典等数据的信息</span></span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(_lock);</span><br></pre></td></tr></table></figure><p>2、信号量也可用于链式请求，比如用来限制请求频次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式请求，限制网络请求串行执行，第一个请求成功后再开始第二个请求</span></span><br><span class="line">- (<span class="keyword">void</span>)chainRequestCurrentConfig &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSArray *<span class="built_in">list</span> = @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        [<span class="built_in">list</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            [self fetchConfigurationWithCompletion:^(NSDictionary *dict) &#123;</span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fetchConfigurationWithCompletion:(<span class="keyword">void</span>(^)(NSDictionary *dict))completion &#123;</span><br><span class="line">    <span class="comment">//AFNetworking或其他网络请求库</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//模拟网络请求</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        !completion ? nil : completion(nil);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Dispatch-Group"><a href="#3-3-Dispatch-Group" class="headerlink" title="3.3 Dispatch Group"></a>3.3 Dispatch Group</h3><p>dispatch_group可以将GCD的任务合并到一个组里来管理。可以指定当追加到Dispatch Queue中的多个处理全部结束时，执行某种操作。</p><p>无论是串行还是并行队列，Dispatch Group都可监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可将结束的处理追加到Dispatch Queue中。</p><h4 id="3-3-1-dispatch-group-create"><a href="#3-3-1-dispatch-group-create" class="headerlink" title="3.3.1 dispatch_group_create"></a>3.3.1 dispatch_group_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建与block相关联的新group。 因为函数名中含有create，所以在使用结束后需要过&quot;dispatch_release&quot;函数释放。</span></span><br><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>Dispatch Group的本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_group_t</span> <span class="title">dispatch_group_create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_alloc(</span><br><span class="line">            DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">    <span class="comment">//使用LONG_MAX初始化信号量结构体</span></span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当value等于LONG_MAX时表示所有任务已完成。</strong></p><h4 id="3-3-2-dispatch-group-enter"><a href="#3-3-2-dispatch-group-enter" class="headerlink" title="3.3.2 dispatch_group_enter"></a>3.3.2 dispatch_group_enter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示一个block已进入group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_enter</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值减一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Too many nested calls to dispatch_group_enter()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-dispatch-group-leave"><a href="#3-3-3-dispatch-group-leave" class="headerlink" title="3.3.3 dispatch_group_leave"></a>3.3.3 dispatch_group_leave</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示group中的某个block已完成</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_leave</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值加一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MAX)) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当value等于LONG_MAX时表示所有任务已完成，调用<code>_dispatch_group_wake</code>唤醒group，因此<code>dispatch_group_leave</code>与<code>dispatch_group_enter</code>需成对出现。</p><ul><li><p>当调用了<code>dispatch_group_enter</code>而没有调用<code>dispatch_group_leave</code>时，会造成value值不等于LONG_MAX而不会走到唤醒逻辑，<code>dispatch_group_notify</code>函数的block无法执行或者<code>dispatch_group_wait</code>收不到<code>semaphore_signal</code>信号而卡住线程。</p></li><li><p>当<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多调用了一次时，dispatch_semaphore_t的value会等于LONGMAX+1（2147483647+1），即long的负数最小值 LONG_MIN(–2147483648)。因为此时value小于0，所以会出现”Unbalanced call to dispatch_group_leave()”的崩溃，这是一个特别需要注意的地方。</p></li></ul><h4 id="3-3-4-dispatch-group-async"><a href="#3-3-4-dispatch-group-async" class="headerlink" title="3.3.4 dispatch_group_async"></a>3.3.4 dispatch_group_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将block提交到调度队列，并将block与给定的调度group关联。相比dispatch_async函数不同的是通过第一个参数，指定Block属于指定的Dispatch Group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//封装调用dispatch_group_async_f函数</span></span><br><span class="line">    dispatch_group_async_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    _dispatch_retain(dg);</span><br><span class="line">    <span class="comment">//先调用dispatch_group_enter操作</span></span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">//DISPATCH_OBJ_GROUP_BIT会在_dispatch_continuation_pop方法中用来判断是否为group，如果为group会执行dispatch_group_leave</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width != <span class="number">1</span> &amp;&amp; dq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_async</code> 的原理和 <code>dispatch_async</code> 比较类似，区别点在于group操作会带上DISPATCH_OBJ_GROUP_BIT标志位。添加group任务时会先执行 <code>dispatch_group_enter</code> ，然后在任务执行时会对带有该标记的执行 <code>dispatch_group_leave</code> 操作。</p><p><code>dispatch_group_async_f </code>与 <code>dispatch_async_f</code>代码类似，主要执行了以下操作：</p><ol><li><p>调用dispatch_group_enter</p></li><li><p>将block和queue等信息记录到dispatch_continuation_t中，并将它加入到group的链表中。</p></li><li><p>_dispatch_continuation_pop执行时会判断任务是否为group，是的话执行完任务再调用dispatch_group_leave以达到信号量value的平衡。</p></li></ol><p><code>_dispatch_continuation_pop</code>简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断是否为队列，是的话执行队列的invoke函数</span></span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx_invoke(dou._do);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行具体任务</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//这是group操作，执行leave操作对应最初的enter</span></span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-dispatch-group-wait"><a href="#3-3-5-dispatch-group-wait" class="headerlink" title="3.3.5 dispatch_group_wait"></a>3.3.5 dispatch_group_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 同步地等待，直到与一个group相关联的所有block都完成，或者直到指定的超时已经过去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout 指定等待时间 dispatch_time_t类型的值 (DISPATCH_TIME_FOREVER 一直)</span></span><br><span class="line"><span class="comment"> * @returrn  如果返回值不为0，表示经过等待，任务还在执行中; 如果为0，全部执行结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">intptr_t</span> </span><br><span class="line">dispatch_group_wait(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_time_t</span> timeout);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前value的值为初始值，表示任务都已经完成，直接返回0，如果timeout为0的话返回超时。其余情况会调用_dispatch_group_wait_slow方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_group_waiters, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_group_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_group_waiters, orig,</span><br><span class="line">                    orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到跟dispatch_semaphore的<code>_dispatch_semaphore_wait_slow</code>方法很类似，不同点在于等待完之后调用的again函数会调用<code>_dispatch_group_wake</code>唤醒当前group。</p><h4 id="3-3-6-dispatch-group-notify"><a href="#3-3-6-dispatch-group-notify" class="headerlink" title="3.3.6 dispatch_group_notify"></a>3.3.6 dispatch_group_notify</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 当与一个group相关联的所有block都完成时，将一个block提交到队列中。不管指定什么样的Dispatch Queue，在追加指定的Block时，之前与Dispatch Group相关联的block都已执行结束。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param queue/block 在追加到该Dispatch Group中的全部处理执行结束时，将第三个参数的Block追加到第二个参数的Dispatch Queue中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装调用dispatch_group_notify_f函数</span></span><br><span class="line">    dispatch_group_notify_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="comment">//封装结构体</span></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> prev, dsn = _dispatch_continuation_alloc();</span><br><span class="line">    dsn-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dc_func = func;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="comment">//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span></span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;do_next = dsn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        dispatch_atomic_store2o(dsema, dsema_notify_head, dsn, seq_cst);</span><br><span class="line">        dispatch_atomic_barrier(seq_cst); <span class="comment">// &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_load2o(dsema, dsema_value, seq_cst) == LONG_MAX) &#123;</span><br><span class="line">            _dispatch_group_wake(dsema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_group_notify的具体实现在dispatch_group_notify_f函数里，逻辑就是将block和queue封装到dispatch_continuation_t里，并将它加到链表的尾部，如果链表为空同时还会设置链表的头部节点。如果dsema_value的值等于初始值，则调用_dispatch_group_wake执行唤醒逻辑。</p><h4 id="3-3-7-dispatch-group-wake-内部API"><a href="#3-3-7-dispatch-group-wake-内部API" class="headerlink" title="3.3.7 dispatch_group_wake(内部API)"></a>3.3.7 dispatch_group_wake(内部API)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>, dc;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line">   <span class="comment">//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span></span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span></span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = (<span class="keyword">long</span>)dispatch_atomic_xchg2o(dsema, dsema_group_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// wake group waiters</span></span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">// async group notify blocks</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = fastpath(head-&gt;do_next);</span><br><span class="line">            <span class="keyword">if</span> (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!(next = fastpath(head-&gt;do_next))) &#123;</span><br><span class="line">                    dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            dc = _dispatch_continuation_free_cacheonly(head);</span><br><span class="line">            <span class="comment">//执行dispatch_group_notify的block，见dispatch_queue的分析</span></span><br><span class="line">            dispatch_async_f(dsn_queue, head-&gt;dc_ctxt, head-&gt;dc_func);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(dc)) &#123;</span><br><span class="line">                _dispatch_continuation_free_to_cache_limit(dc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        _dispatch_release(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_wake</code>首先会循环调用<code>semaphore_signal</code>唤醒等待group的信号量，使<code>dispatch_group_wait</code>函数中等待的线程得以唤醒；然后依次获取链表中的元素并调用<code>dispatch_async_f</code>异步执行<code>dispatch_group_notify</code>函数中注册的回调，使得notify中的block得以执行。</p><h4 id="3-3-8-dispatch-release"><a href="#3-3-8-dispatch-release" class="headerlink" title="3.3.8 dispatch_release"></a>3.3.8 dispatch_release</h4><p>与追加 Block 到 Dispatch Queue 时同样，Block 通过 dispatch_retain 函数持有 Dispatch Group，从而使得该 Block 属于 Dispatch Group，这样如果 Block 执行结束，该 Block 就通过 dispatch_release 函数释放持有的Dispatch Group。</p><p>一旦Dispatch Group使用结束，不用考虑属于该Dispatch Group的Block，立即通过dispatch_release函数释放即可。</p><h4 id="3-3-9-原理小结"><a href="#3-3-9-原理小结" class="headerlink" title="3.3.9 原理小结"></a>3.3.9 原理小结</h4><p>dispatch_group本质是个初始值为LONG_MAX的信号量，等待group中的任务完成其实是等待value恢复初始值。<br> <code>dispatch_group_enter </code> 和 <code>dispatch_group_leave</code> 必须成对出现：</p><ul><li>如果前者比后者多一次，则wait函数等待的线程不会被唤醒和注册notify的回调block不会执行；</li><li>如果后者比前者多一次，则会引起崩溃。</li></ul><h3 id="3-4-dispatch-barrier-async"><a href="#3-4-dispatch-barrier-async" class="headerlink" title="3.4 dispatch_barrier_async"></a>3.4 dispatch_barrier_async</h3><h4 id="3-4-1-使用"><a href="#3-4-1-使用" class="headerlink" title="3.4.1 使用"></a>3.4.1 使用</h4><p>变无序为有序。</p><p>当多线程并发读写同一个资源时，为了保证资源读写的正确性，可以用Barrier Block解决该问题。<br>Dispatch Barrier会确保队列中先于Barrier Block提交的任务都完成后再执行它，并且执行时队列不会同步执行其它任务，等Barrier Block执行完成后再开始执行其他任务。代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建自定义并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.gcdTest.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;  <span class="comment">//第一步：执行dispatch_barrier_async之前的任务</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_barrier_async</span>(queue, ^&#123;  <span class="comment">//第二步：执行dispatch_barrier_async函数添加的任务</span></span><br><span class="line">    <span class="comment">//barrier block,可用于写操作</span></span><br><span class="line">    <span class="comment">//确保资源更新过程中不会有其他线程读取</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work2&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 第三步：队列恢复为一般的动作，追加到Concurrent Dispatch Queue的处理又开始并行执行</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里有个需要注意也是官方文档上提到的一点，如果我们调用dispatch_barrier_async时将Barrier blocks提交到一个global queue，barrier blocks执行效果与dispatch_async()一致；</p><p><strong>只有将 Barrier blocks 提交到使用 DISPATCH_QUEUE_CONCURRENT 属性创建的并行queue时它才会表现的如同预期。</strong></p><h4 id="3-4-2-原理"><a href="#3-4-2-原理" class="headerlink" title="3.4.2 原理"></a>3.4.2 原理</h4><p><code>dispatch_barrier_async</code>是开发中解决多线程读写同一个资源比较好的方案，接下来看一下它的实现。<br>该函数封装调用了<code>dispatch_barrier_async_f</code>，它和dispatch_async_f类似，不同点在于vtable多了DISPATCH_OBJ_BARRIER_BIT标志位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置do_vtable的标志位，从队列中取任务时会用到</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_barrier_async</code>如果传入的是global queue，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，故执行效果同<code>dispatch_async</code>一致，验证了使用篇中的备注内容；<br><code>dispatch_barrier_async</code>传的queue为自定义队列时，<code>_dispatch_continuation_pop</code>参数是自定义的queue，然后在<code>_dispatch_continuation_pop</code>中执行自定义队列的dx_invoke函数，即<code>dispatch_queue_invoke</code>。它的调用栈是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_invoke</span><br><span class="line">└──_dispatch_queue_class_invoke</span><br><span class="line">    └──dispatch_queue_invoke2</span><br><span class="line">        └──_dispatch_queue_drain</span><br></pre></td></tr></table></figure><p>重点看一下_dispatch_queue_drain函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_dispatch_thread_semaphore_t</span> _dispatch_queue_drain(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq, orig_tq, old_dq;</span><br><span class="line">    old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = <span class="number">0</span>;</span><br><span class="line">    orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        dc = _dispatch_queue_head(dq);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &#123;</span><br><span class="line">               <span class="comment">//barrier block执行时修改了do_suspend_cnt导致此时为YES</span></span><br><span class="line">               <span class="comment">//保证barrier block执行时其他block不会同时执行</span></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq-&gt;dq_running &gt; dq-&gt;dq_width) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> redirect = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dc) &amp;&amp;</span><br><span class="line">                        (<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dq-&gt;dq_running &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    redirect = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//barrier block之前的block已经执行完，开始执行barrier block</span></span><br><span class="line">            <span class="keyword">if</span> ((sema = _dispatch_barrier_sync_f_pop(dq, dc, <span class="literal">true</span>))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_continuation_pop(dc);</span><br><span class="line">            _dispatch_perfmon_workitem_inc();</span><br><span class="line">        &#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">    <span class="keyword">return</span> sema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中依次取出任务并调用<code>_dispatch_continuation_redirect</code>函数，使得block并发执行。当遇到DISPATCH_OBJ_BARRIER_BIT标记时，会修改do_suspend_cnt标志以保证后续while循环时直接goto out。barrier block的任务执行完之后<code>_dispatch_queue_class_invoke</code>会将do_suspend_cnt重置回去，所以barrier block之后的任务会继续执行。</p><p><code>dispatch_barrier_async</code>的流程见下图：</p><img src="/images/GCD/dispatch_queue-8.png" alt="img" style="zoom:80%;" /><h3 id="3-5-dispatch-apply"><a href="#3-5-dispatch-apply" class="headerlink" title="3.5 dispatch_apply"></a>3.5 dispatch_apply</h3><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数 <strong>按指定的次数</strong> 将指定的Block追加到指定的队列中，并等待全部处理执行结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：重复次数</span></span><br><span class="line"><span class="comment"> * 参数2：执行队列</span></span><br><span class="line"><span class="comment"> * 参数3：任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_apply</span>(<span class="number">10</span>, queue, ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(@<span class="string">&quot;%zu&quot;</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog（@<span class="string">&quot;done&quot;</span>）;</span><br></pre></td></tr></table></figure><ul><li><p>Global Dispatch Queue中执行，所以各个处理的执行时间不定，但是输出结果的最后必定是done，这是因为dispatch_apply函数会等待全部处理执行结束。</p></li><li><p>dispatch_apply和dispatch_sync函数一样，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Global Dispatch Queue中非同步执行</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Global Dispatch Queue,等待dispatch_apply函数中全部处理执行结束</span></span><br><span class="line">    dispatch_apply([array count], queue, ^(size_t index)&#123;   </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//并列处理包含在NSArray对象的全部对象  index为0-10</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu ：%@&quot;</span>,index,[array objectAtIndex:index]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//dispatch_apply函数中的处理全部执行结束</span></span><br><span class="line">   <span class="comment">//在Main Dispatch Queue中非同步执行</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),^&#123;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//在Main Dispatch Queue中执行处理</span></span><br><span class="line">     <span class="built_in">NSLog</span>（<span class="string">@&quot;done&quot;</span>）;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-6-dispatch-suspend-dispatch-resume"><a href="#3-6-dispatch-suspend-dispatch-resume" class="headerlink" title="3.6 dispatch_suspend/dispatch_resume"></a>3.6 dispatch_suspend/dispatch_resume</h3><p>队列的挂起与恢复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_suspend函数挂起指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_suspend</span>(queue)</span><br><span class="line"><span class="comment">//dispatch_suspend函数恢复指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(queue)</span><br></pre></td></tr></table></figure><p>函数<strong>对已经执行的处理没有影响</strong>。</p><ul><li>挂起后，追加到Dispatch Queue中但尚未执行的处理，在此之后停止执行</li><li>恢复后使得这些处理能继续执行</li></ul><h3 id="3-7-dispatch-once"><a href="#3-7-dispatch-once" class="headerlink" title="3.7 dispatch_once"></a>3.7 dispatch_once</h3><p>dispatch_once函数时保证在应用程序执行中只执行一次指定处理的API，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能。</p><h4 id="3-7-1-API介绍"><a href="#3-7-1-API介绍" class="headerlink" title="3.7.1 API介绍"></a>3.7.1 API介绍</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//创建单例、method swizzled或其他任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-原理"><a href="#3-7-2-原理" class="headerlink" title="3.7.2 原理"></a>3.7.2 原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用dispatch_once_f来处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_once</code>封装调用了<code>dispatch_once_f</code>函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">        ((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure><p>接着看一下具体的实现函数<code>dispatch_once_f</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> * <span class="title">volatile</span> *<span class="title">vval</span> =</span></span><br><span class="line">            (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> *<span class="title">tail</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchg</span>(vval, <span class="literal">NULL</span>, &amp;dow, acquire)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_atomic_maximally_synchronizing_barrier</span>();</span><br><span class="line">        <span class="comment">// above assumed to contain release barrier</span></span><br><span class="line">        tmp = <span class="built_in">dispatch_atomic_xchg</span>(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                <span class="built_in">dispatch_hardware_pause</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        tmp = *vval;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchgvw</span>(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可知<code>dispatch_once</code>的流程图大致如下：</p><img src="/images/GCD/dispatch_once.png" alt="img" style="zoom:80%;" /><p>首先看一下<code>dispatch_once</code>中用的的原子性操作<code>dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)</code>，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。</p><p>接着结合上面的流程图来看下<code>dispatch_once</code>的代码逻辑：</p><p>首次调用<code>dispatch_once</code>时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用<code>_dispatch_client_callout</code>执行block，然后在block执行完成之后将vval的值更新成<code>DISPATCH_ONCE_DONE</code>表示任务已完成。最后遍历链表的节点并调用<code>_dispatch_thread_semaphore_signal</code>来唤醒等待中的信号量；</p><p>当其他线程同时也调用<code>dispatch_once</code>时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用<code>_dispatch_thread_semaphore_wait</code>阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。</p><h4 id="3-7-3-总结"><a href="#3-7-3-总结" class="headerlink" title="3.7.3 总结"></a>3.7.3 总结</h4><p><code>dispatch_once</code>用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p><p><code>dispatch_once</code>常被用于创建单例、swizzeld method等功能。</p><h3 id="3-8-Dispatch-I-O与Dispatch-Data对象"><a href="#3-8-Dispatch-I-O与Dispatch-Data对象" class="headerlink" title="3.8 Dispatch I/O与Dispatch Data对象"></a>3.8 Dispatch I/O与Dispatch Data对象</h3><p>通过 Dispatch I/O 读写文件，使用 Global Dispatch Queue 将一个文件按大小 read/write。提升读取、写入速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">pipe_q = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;PipeQ&quot;</span>,<span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Dispatch I/O对象</span></span><br><span class="line">pipe_channel = <span class="built_in">dispatch_io_create</span>(DISPATCH_IO_STREAM,fd,pipe_q,^(<span class="keyword">int</span> err)&#123;</span><br><span class="line">   <span class="built_in">close</span>(fd);   <span class="comment">//发生错误时执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*out_fd = fdpair[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最大字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_high_water</span>(pipe_channel, SIZE_MIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最小字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_low_water</span>(pipe_channel,SIZE_MAX);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始异步读取</span></span><br><span class="line"><span class="built_in">dispatch_io_read</span>(pipe_channel,<span class="number">0</span>,SIZE_MAX,pipe_q, ^(<span class="keyword">bool</span> done,<span class="keyword">dispatch_data_t</span> pipe data,<span class="keyword">int</span> err)&#123;</span><br><span class="line"><span class="comment">//每当各个分割的文件快读取结束时，将含有文件块数据的Dispatch Data传递给dispatch_io_read函数指定的读取结束时回调用的Block。回调用的Block分析传递过来的Dispatch Data并进行结合处理</span></span><br><span class="line">   <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">size_t</span> len = <span class="built_in">dispatch_data_get_size</span>(pipe data);</span><br><span class="line">       <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="keyword">char</span> *encoded;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">dispatch_data_t</span> md = <span class="built_in">dispatch_data_create_map</span>(pipe data,(<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes,&amp;len);</span><br><span class="line">          <span class="built_in">asl_set</span>((aslmsg)merged_msg,ASL_KEY_AUX_DATA,encoded);</span><br><span class="line">          <span class="built_in">free</span>(encoded);</span><br><span class="line">          _asl_send_message(<span class="literal">NULL</span>,merged_msg,<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">          <span class="built_in">asl_msg_release</span>(merged_msg);</span><br><span class="line">          <span class="built_in">dispatch_release</span>(md);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(done)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">dispatch_semaphore_signal</span>(sem);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_channel);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_q);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-9-dispatch-source"><a href="#3-9-dispatch-source" class="headerlink" title="3.9 dispatch_source"></a>3.9 dispatch_source</h3><p>Dispatch Source是BSD系统内核惯有功能kqueue的包装，kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。它的CPU负荷非常小，尽量不占用资源。当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p><h4 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1 使用"></a>3.9.1 使用</h4><p>dispatch_source最常见的用法就是用来实现定时器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_source_t</span> source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>), <span class="number">3</span> * NSEC_PER_SEC, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">//定时器触发时执行</span></span><br><span class="line">   NSLog(@<span class="string">&quot;timer响应了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动timer</span></span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure><p><code>Dispatch Source</code>定时器的代码看似很简单，但其实是GCD中坑最多的API了，如果处理不好很容易引起Crash。关于<code>Dispatch Source</code>定时器需要注意的知识点请参考文章最后的总结篇。</p><h4 id="3-9-2-原理"><a href="#3-9-2-原理" class="headerlink" title="3.9.2 原理"></a>3.9.2 原理</h4><h5 id="1-dispatch-source-create"><a href="#1-dispatch-source-create" class="headerlink" title="1. dispatch_source_create"></a>1. dispatch_source_create</h5><p><code>dispatch_source_create</code>函数用来创建dispatch_source_t对象，简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_source_t</span> <span class="title">dispatch_source_create</span><span class="params">(<span class="keyword">dispatch_source_type_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_queue_t</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    ds = _dispatch_alloc(DISPATCH_VTABLE(source),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_source_s));</span><br><span class="line">    <span class="comment">//初始化ds</span></span><br><span class="line">    _dispatch_queue_init((<span class="keyword">dispatch_queue_t</span>)ds);</span><br><span class="line">    ds-&gt;dq_label = <span class="string">&quot;source&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// the reference the manager queue holds</span></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// since source is created suspended</span></span><br><span class="line">    <span class="comment">//默认处于暂状态，需要手动调用resume</span></span><br><span class="line">    ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;</span><br><span class="line">    ds-&gt;do_targetq = &amp;_dispatch_mgr_q;</span><br><span class="line">    <span class="comment">// First item on the queue sets the user-specified target queue</span></span><br><span class="line">    <span class="comment">//设置事件回调的队列</span></span><br><span class="line">    dispatch_set_target_queue(ds, q);</span><br><span class="line">    _dispatch_object_debug(ds, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-source-set-timer"><a href="#2-dispatch-source-set-timer" class="headerlink" title="2. dispatch_source_set_timer"></a>2. dispatch_source_set_timer</h5><p>dispatch_source_set_timer实际上调用了_dispatch_source_set_timer，看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_source_set_timer(<span class="keyword">dispatch_source_t</span> ds, <span class="keyword">dispatch_time_t</span> start,</span><br><span class="line">        <span class="keyword">uint64_t</span> interval, <span class="keyword">uint64_t</span> leeway, <span class="keyword">bool</span> source_sync) &#123;</span><br><span class="line">    <span class="comment">//首先屏蔽非timer类型的source</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!ds-&gt;ds_is_timer) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">ds_timer</span>(ds-&gt;ds_refs).flags &amp; DISPATCH_TIMER_INTERVAL)) &#123;</span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Attempt to set timer on a non-timer source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建dispatch_set_timer_params结构体绑定source和timer参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span>;</span></span><br><span class="line">    params = _dispatch_source_timer_params(ds, start, interval, leeway);</span><br><span class="line">    _dispatch_source_timer_telemetry(ds, params-&gt;ident, &amp;params-&gt;values);</span><br><span class="line">    <span class="built_in">dispatch_retain</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (source_sync) &#123;</span><br><span class="line">       <span class="comment">//将source当做队列使用，执行dispatch_barrier_async_f压入队列，</span></span><br><span class="line">       <span class="comment">//核心函数为_dispatch_source_set_timer2</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, params,</span><br><span class="line">                _dispatch_source_set_timer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_source_set_timer2(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer</code>实际上是调用了<code>_dispatch_source_set_timer2</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the source queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="comment">//暂停队列，避免修改过程中定时器被触发了。</span></span><br><span class="line">    <span class="built_in">dispatch_suspend</span>(params-&gt;ds);</span><br><span class="line">    <span class="comment">//在_dispatch_mgr_q队列上执行_dispatch_source_set_timer3(params)</span></span><br><span class="line">    <span class="built_in">dispatch_barrier_async_f</span>(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer2</code>函数的逻辑是在_dispatch_mgr_q队列执行<code>_dispatch_source_set_timer3(params)</code>，接下来的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer3(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the _dispatch_mgr_q</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = params-&gt;ds;</span><br><span class="line">    ds-&gt;ds_ident_hack = params-&gt;ident;</span><br><span class="line">    <span class="built_in">ds_timer</span>(ds-&gt;ds_refs) = params-&gt;values;</span><br><span class="line">    ds-&gt;ds_pending_data = <span class="number">0</span>;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_or2o</span>(ds, ds_atomic_flags, DSF_ARMED, release);</span><br><span class="line">    <span class="comment">//恢复队列，对应着_dispatch_source_set_timer2函数中的dispatch_suspend</span></span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">    <span class="comment">// Must happen after resume to avoid getting disarmed due to suspension</span></span><br><span class="line">    <span class="comment">//根据下一次触发时间将timer进行排序</span></span><br><span class="line">    _dispatch_timers_update(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (params-&gt;values.flags &amp; DISPATCH_TIMER_WALL_CLOCK) &#123;</span><br><span class="line">        _dispatch_mach_host_calendar_change_register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行提交到_dispatch_mgr_q队列的block时，会调用&amp;_dispatch_mgr_q-&gt;do_invoke函数，即&amp;_dispatch_mgr_q的vtable中定义的<code>_dispatch_mgr_thread</code>。接下来会走到<code>_dispatch_mgr_invoke</code>函数。在这个函数里用I/O多路复用功能的select来实现定时器功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="built_in">select</span>(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, <span class="literal">NULL</span>,</span><br><span class="line">            poll ? (struct timeval*)&amp;timeout_immediately : <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>当内层的 <code>_dispatch_mgr_q</code> 队列被唤醒后，还会进一步唤醒外层的队列(当初用户指定的那个)，并在指定队列上执行 timer 触发时的 block。</p><h5 id="3-dispatch-source-set-event-handler"><a href="#3-dispatch-source-set-event-handler" class="headerlink" title="3. dispatch_source_set_event_handler"></a>3. dispatch_source_set_event_handler</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_event_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_event_handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_event_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_handler_is_block &amp;&amp; dr-&gt;ds_handler_ctxt) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_handler_ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置上下文，保存提交的block等信息</span></span><br><span class="line">    dr-&gt;ds_handler_func = context ? _dispatch_Block_invoke(context) : <span class="literal">NULL</span>;</span><br><span class="line">    dr-&gt;ds_handler_ctxt = context;</span><br><span class="line">    ds-&gt;ds_handler_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-dispatch-source-set-cancel-handler"><a href="#4-dispatch-source-set-cancel-handler" class="headerlink" title="4. dispatch_source_set_cancel_handler"></a>4. dispatch_source_set_cancel_handler</h5><p><code>dispatch_source_set_cancel_handler</code>与<code>dispatch_source_set_event_handler</code>功能类似，保存一下取消事件处理的上下文信息。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_cancel_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_cancel_handler2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_cancel_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_cancel_is_block &amp;&amp; dr-&gt;ds_cancel_handler) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_cancel_handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存事件取消的信息</span></span><br><span class="line">    dr-&gt;ds_cancel_handler = context;</span><br><span class="line">    ds-&gt;ds_cancel_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-dispatch-resume-dispatch-suspend"><a href="#5-dispatch-resume-dispatch-suspend" class="headerlink" title="5. dispatch_resume/dispatch_suspend"></a>5. dispatch_resume/dispatch_suspend</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_resume</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_resume, dou);</span><br><span class="line">    <span class="comment">// Global objects cannot be suspended or resumed.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性减二，并返回之前存储的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_cnt = <span class="built_in">dispatch_atomic_sub_orig2o</span>(dou._do,</span><br><span class="line">             do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt &gt; DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt == DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        _dispatch_wakeup(dou._do);</span><br><span class="line">     <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Over-resume of an object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_suspend</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_suspend, dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性加二</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dou._do, do_suspend_cnt,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队列是否暂停的依据是do_suspend_cnt是否大于等于2,全局队列和主队列默认都是小于2的，即处于启动状态。<br>而dispatch_source_create方法中，do_suspend_cnt初始为DISPATCH_OBJECT_SUSPEND_INTERVAL，即默认处于暂停状态，需要手动调用resume开启。<br>代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_LOCK        1u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPENDED(x) \</span></span><br><span class="line">        ((x)-&gt;do_suspend_cnt &gt;= DISPATCH_OBJECT_SUSPEND_INTERVAL)</span><br></pre></td></tr></table></figure><h4 id="3-9-3-总结"><a href="#3-9-3-总结" class="headerlink" title="3.9.3 总结"></a>3.9.3 总结</h4><p>Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用<code>dispatch_resume</code>启动定时器。<code>dispatch_after</code>只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p><p>Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p><ol><li>循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</li><li><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让<code>dispatch_resume</code>代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</li><li>source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</li></ol><h3 id="3-10-dispatch-after-延迟执行"><a href="#3-10-dispatch-after-延迟执行" class="headerlink" title="3.10 dispatch_after(延迟执行)"></a>3.10 dispatch_after(延迟执行)</h3><h4 id="3-10-1-使用"><a href="#3-10-1-使用" class="headerlink" title="3.10.1 使用"></a>3.10.1 使用</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取精确时间点</span></span><br><span class="line"><span class="comment">typedef uint64_t dispatch_time_t;</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_NOW (0ull)</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_FOREVER (~0ull)</span></span><br><span class="line"><span class="comment">* 参数1:  开始时间  DISPATCH_TIME_NOW(现在的时间)</span></span><br><span class="line"><span class="comment">* 参数2：多久后  数值和NSEC_PER_SEC的乘积得到单位为毫微秒的数值，ull是C语言的数值字面量，是显示表明类型时使用的字符串（表示‘unsigned long long’） ，NSEC_PER_MSEC表示毫秒单位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW , <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：指定时间用的dispatch_time_t类型的值，dispatch_time_t类型的值使用dispatch_time函数或者dispatch _walltime函数生成</span></span><br><span class="line"><span class="comment"> * 参数2：指定要追加处理的Dispatch Queue</span></span><br><span class="line"><span class="comment"> * 参数3：指定记述要执行处理的Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_after(time , dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;waited at least three seconds &quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue，上述代码与3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 的相同。</li><li>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔 1/60 秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在 3秒+1/60秒 后执行，并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟是，这个时间会更长。</li></ul><p>dispatch_walltime 函数由 POSLX 中使用的 struct timespec 类型的时间得到 dispatch _time_t 类型的值。</p><p>dispatch _time函数通常用于计算相对时间。</p><p>dispatch_walltime函数用于计算绝对时间，需要指定精确时间参数，可作为粗略的闹钟功能使用。</p><h4 id="3-10-2-原理"><a href="#3-10-2-原理" class="headerlink" title="3.10.2 原理"></a>3.10.2 原理</h4><p><code>dispatch_after</code>是基于Dispatch Source的定时器实现的，函数内部直接调用<code>dispatch_after_f</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_after_f</span><span class="params">(<span class="keyword">dispatch_time_t</span> when, <span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> delta, leeway;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds;</span><br><span class="line">    <span class="comment">//屏蔽DISPATCH_TIME_FOREVER类型</span></span><br><span class="line">    <span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(</span><br><span class="line">                <span class="string">&quot;dispatch_after_f() called with &#x27;when&#x27; == infinity&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_async_f</span>(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    leeway = delta / <span class="number">10</span>; <span class="comment">// &lt;rdar://problem/13447496&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (leeway &lt; NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;</span><br><span class="line">    <span class="keyword">if</span> (leeway &gt; <span class="number">60</span> * NSEC_PER_SEC) leeway = <span class="number">60</span> * NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">    <span class="comment">//创建dispatch_source</span></span><br><span class="line">    ds = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = ds;</span><br><span class="line">    <span class="comment">//将dispatch_continuation_t存储到上下文中</span></span><br><span class="line">    <span class="built_in">dispatch_set_context</span>(ds, dc);</span><br><span class="line">    <span class="comment">//设置timer并启动</span></span><br><span class="line">    <span class="built_in">dispatch_source_set_event_handler_f</span>(ds, _dispatch_after_timer_callback);</span><br><span class="line">    <span class="built_in">dispatch_source_set_timer</span>(ds, when, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timer到时之后，会调用<code>_dispatch_after_timer_callback</code>函数，在这里取出上下文里的block并执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_after_timer_callback(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = ctxt, dc1;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = dc-&gt;dc_data;</span><br><span class="line">    dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">//执行任务的block并执行</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="comment">//清理数据</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、GCD的实现补充"><a href="#四、GCD的实现补充" class="headerlink" title="四、GCD的实现补充"></a>四、GCD的实现补充</h2><h3 id="4-1-Dispatch-Quene"><a href="#4-1-Dispatch-Quene" class="headerlink" title="4.1 Dispatch Quene"></a>4.1 Dispatch Quene</h3><h4 id="4-1-1-Dispatch-Quene实现所需"><a href="#4-1-1-Dispatch-Quene实现所需" class="headerlink" title="4.1.1 Dispatch Quene实现所需"></a>4.1.1 Dispatch Quene实现所需</h4><p>GCD的实现会使用下面这些工具，但不仅仅只有这些：</p><ul><li>用于管理追加的Block的C语言实现的FIFO队列；</li><li>Atomic函数中实现的用于排他控制的轻量级信号；</li><li>用于管理线程的C语言实现的一些容器。</li></ul><p><strong>GCD 是在系统级即iOS和OS X的核心XNU内核级上实现，所以开发者无论如何努力编写线程关系代码，<code>性能</code>都不可能胜过XNU内核级所实现的GCD。</strong></p><p>用于实现Dispatch Queue的几个软件组件框架：</p><ul><li>组件libdispatch提供Dispatch Quene技术；</li><li>组件Libc(pthreads)提供pthread_workquene技术；</li><li>组件XNU内核提供workquene技术。</li></ul><h4 id="4-1-2-执行上下文"><a href="#4-1-2-执行上下文" class="headerlink" title="4.1.2  执行上下文"></a>4.1.2  执行上下文</h4><p>Dispatch Quene通过结构体和链表，被实现为FIFO队列。</p><p>Block并不是直接加入FIFO队列，而是先加入 <code>Dispatch Continuation</code> 这一 <code>dispatch_continuation_t类型</code> 结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记忆 Block 所属的 Dispatch Group 和其他一些信息，相当于一般常说的**<code>执行上下文</code>**。</p><p>上一节在讲 <code>Global Dispatch Queue</code> 的时候，我们介绍过8种类型，这8种 Global Dispatch Quene 各使用一个pthread_workquene。GCD初始化时，使用 <code>pthread_workquene_creat_np</code> 函数生成 pthread_workquene。</p><p>pthread_workquene包含在Libc提供的pthreads API 中。其使用bsdthread_register和workq_open系统调用，<strong>在初始化XNU内核的workquene之后获取workquene信息</strong>。</p><p>XNU内核持有4种workquene：</p><ul><li>WORKQUENE_HIGH_PRIOQUENE</li><li>WORKQUENE_Default_PRIOQUENE</li><li>WORKQUENE_Low_PRIOQUENE</li><li>WORKQUENE_BG_PRIOQUENE</li></ul><p>以上4种执行优先级的workqueue，其执行优先级与Global Dispatch Quene的四种执行优先级相同。</p><p><strong>Global Dispatch Queue → Libc pthread_wordqueue → XNU workqueue</strong></p><img src="/images/GCD/gcd-imp-1.jpg" style="zoom:80%"><h4 id="4-1-3-Dispatch-Queue执行Block的过程"><a href="#4-1-3-Dispatch-Queue执行Block的过程" class="headerlink" title="4.1.3  Dispatch Queue执行Block的过程"></a>4.1.3  Dispatch Queue执行Block的过程</h4><ol><li><p>在Global Dispatch Queue 中执行Block时，libdispatch 从Global Dispatch Queue自身的FIFO队列取出<code>Dispatch Continuation</code></p></li><li><p>调用<code>pthread_workqueue_additem_np</code>函数将该Global Dispatch Queue 本身、符合其优先级的workqueue信息以及执行Dispatch Continuation的回调函数等传递给参数。</p></li><li><p>pthread_workqueue_additem_np函数使用<code>workq_kernreturn系统调用</code>，通知workqueue增加应当执行的项目。</p><p>根据该通知，XNU内核基于系统状态判断是否要生成线程。如果是<code>Overcommit优先级</code>的Global Dispatch Queue ，workqueue则始终生成线程(该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用)。</p><p>因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，他的<code>上下文切换(shift context)</code>与普通的线程有很大的不同。这也是我们使用GCD的原因。</p></li><li><p>workqueue的线程 –&gt; 执行pthread_workqueue函数 –&gt; 该函数调用libdispatch的回调函数。在该回调函数中执行加入到Global Dispatch Queue中的下一个Block。</p></li><li><p>Block执行结束后，进行通知Dispatch Group结束、释放Dispatch Continuation等处理，开始准备执行加入到Global Dispatch Queue中的下一个Block</p></li></ol><h3 id="4-2-Dispatch-Source"><a href="#4-2-Dispatch-Source" class="headerlink" title="4.2 Dispatch Source"></a>4.2 Dispatch Source</h3><p>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。它是BSD系内核惯有功能<code>kqueue的包装</code>。</p><p><strong>kqueue是XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。</strong></p><p>Dispatch Source可处理以下事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD   变量增加</span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR    变量OR</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND  MACH端口发送</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV  MACH端口接收</span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC   检测到与进程相关的事件</span><br><span class="line">DISPATCH_SOURCE_TYPE_READ   可读取文件映像</span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL 接收信号</span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER  定时器</span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE  文件系统有变更</span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE  可写入文件映像</span><br></pre></td></tr></table></figure><p>事件发生时，在指定的Dispatch Queue中可执行事件的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatc_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  基于READ事件作成Dispatch Source</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">dispatch_source_t</span> source = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_READ, sockfd, <span class="number">0</span> , queuq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定发生READ事件时执行的处理 */</span>    </span><br><span class="line"><span class="built_in">dispatch_source_set_event_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">// 处理结束，取消Dispatch Source</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定取消Dispatch Source时的处理 */</span></span><br><span class="line"><span class="built_in">dispatch_source_set_cancel_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">/* 释放Dispatch Source(自身) */</span></span><br><span class="line">    <span class="built_in">dispatch_release</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动Dispatch Source */</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(source);</span><br></pre></td></tr></table></figure><p>与上面代码非常相似的代码，使用在了Core Foundation框架的用于异步网络的<code>API CFSocket</code>中。因为<strong>Foundation框架的异步网络API是通过CFSocket实现</strong>的，所以可享受到仅使用Foundation框架的Dispatch Source(即GCD)带来的好处。</p><p>一旦将任务追加到Dispatch Queue中，就没有办法将任务取消，也没有办法在执行中取消任务。Dispatch Source是可以取消的，而且取消时的处理可以block的形式作为参数配置。<strong>在必须使用kqueue的情况下，推荐大家使用Dispatch Source，比较简单</strong>。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://xiaozhuanlan.com/iOSDevNotes">iOS开发笔记 — 小专栏</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是多线程编程？&quot;&gt;&lt;a href=&quot;#一、什么是多线程编程？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是多线程编程？&quot;&gt;&lt;/a&gt;一、什么是多线程编程？&lt;/h2&gt;&lt;p&gt;先来复习一下&lt;code&gt;操作系统&lt;/code&gt;中线程相关的知识点：&lt;</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="GCD" scheme="https://tenloy.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/06/28/AutoreleasePool.html"/>
    <id>https://tenloy.github.io/2021/06/28/AutoreleasePool.html</id>
    <published>2021-06-28T16:19:21.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> autorelease]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootAutorelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootAutorelease2()</span><br><span class="line">        └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">            └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                └── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="AutoreleasePool" scheme="https://tenloy.github.io/tags/AutoreleasePool/"/>
    
  </entry>
  
  <entry>
    <title>[转] 深入理解RunLoop—ibireme</title>
    <link href="https://tenloy.github.io/2021/06/26/RunLoop-Reposted-From-ibireme.html"/>
    <id>https://tenloy.github.io/2021/06/26/RunLoop-Reposted-From-ibireme.html</id>
    <published>2021-06-26T16:19:21.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p><blockquote><p>本文是结合着底层CFRunLoop的源码，对RunLoop机制进行了深入分析，如果感觉枯燥，难以消化。可以先看一下孙源的一个线下分享《RunLoop》，对RunLoop的整体有个了解。</p></blockquote><h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模型通常被称作 <a href="http://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p><p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p><p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p><ul><li><p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p></li><li><p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。</p></li></ul><p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E7%A0%81%E5%8F%AF%E8%83%BD%E5%92%8C%E7%8E%B0%E6%9C%89">https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有</a> iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。)</p><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份[文档](<a href="http://www.fenestrated.net/~macman/mirrors/Apple">http://www.fenestrated.net/~macman/mirrors/Apple</a> Technotes (As of 2002)/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p><p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="/images/RunLoop/RunLoop_0.png" alt="RunLoop_0" style="zoom:60%;" /></p><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p><p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p><ul><li><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p></li><li><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p></li></ul><p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p><p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p><p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p><p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure><p>Mode 暴露的管理 mode item 的接口有下面几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p><p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p><p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p><h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p><img src="/images/RunLoop/RunLoop_1.png" alt="RunLoop_0" style="zoom:65%;" /><p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="/images/RunLoop/RunLoop_3.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>苹果官方将整个系统大致划分为上述4个层次：</p><ul><li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li><li>应用框架层即开发人员接触到的 Cocoa 等框架。</li><li>核心框架层包括各种核心框架、OpenGL 等内容。</li><li>Darwin是macOS和iOS操作环境的操作系统部分。苹果公司于2000年把Darwin发布给开放源代码社区。<ul><li>既然是OS，那肯定要包括系统内核XNU、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</li><li>XNU是一个混合内核，它采用了来自OSF的OSFMK 7.3(Open Software Foundation Mach Kernel)和FreeBSD的各种要素(包括过程模型，网络堆栈和虚拟文件系统)，还有一个称为I/O Kit的面向对象的设备驱动程序API。</li><li>XNU将宏内核与微内核两者的特性兼收并蓄，以期同时拥有两种内核的优点。<strong>微内核的灵活性</strong>：比如在微内核中提高操作系统模块化程度以及让操作系统更多的部分接受内存保护的消息传递机制。<strong>宏内核的性能</strong>：宏内核在高负荷下表现的高性能。</li></ul></li></ul><p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="/images/RunLoop/RunLoop_4.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p><ul><li><p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p></li><li><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。(BSD是宏内核)</p></li><li><p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p></li></ul><p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p><p>Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure><p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port。</p><p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mach_msg_return_t</span> <span class="title">mach_msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify)</span></span>;</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：<br><img src="/images/RunLoop/RunLoop_5.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing)">Trap_(computing)</a>。</p><p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p><p>关于具体的如何利用 mach port 发送信息，可以看看<a href="http://nshipster.com/inter-process-communication/"> NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p><p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p><h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，系统默认注册了5个Mode:</p><ol><li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li><li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li></ol><p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p><p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><p>这个函数内部的调用栈大概是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure><ul><li>CFSocket 是最底层的接口，只负责 socket 通信。</li><li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li><li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li><li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li></ul><p>下面主要介绍下 NSURLConnection 的工作过程。</p><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><img src="/images/RunLoop/RunLoop_network.png" alt="RunLoop_0" style="zoom:65%;" /><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><p>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer的基本介绍</title>
    <link href="https://tenloy.github.io/2021/06/24/Protocol-Buffer.html"/>
    <id>https://tenloy.github.io/2021/06/24/Protocol-Buffer.html</id>
    <published>2021-06-24T17:48:19.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式一样，也可用于通信协议，数据存储等。</p><ul><li>Protocol buffers 在序列化数据方面，它是<strong>灵活的</strong>，<strong>高效的</strong>(快)。<ul><li>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</li><li>一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</li></ul></li><li>相比于 XML、JSON 来说，Protocol buffers 更加<strong>小巧</strong>，更加<strong>简单</strong>。<ul><li>XML和JSON的描述信息太多了，导致消息要大；</li><li>此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</li></ul></li></ul><p><strong>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</strong>。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><h3 id="1-1-优势"><a href="#1-1-优势" class="headerlink" title="1.1 优势"></a>1.1 优势</h3><p>JSON 和 XML 可能是目前开发者们用来存储和传输数据的标准方案，而 protocol buffers 与之相比有以下优势：</p><ul><li><strong>快速且小巧</strong>：按照 Google 所描述的，protocol buffers 的体积要小<strong>3-10</strong>倍，速度比XML要快<strong>20-100</strong>倍。可以在这篇<a href="https://damienbod.com/2014/01/09/comparing-protobuf-json-bson-xml-with-net-for-file-streams/">文章</a> ，它的作者是 Damien Bod，文中比较了一些主流文本格式的读写速度。</li><li><strong>类型安全</strong>：Protocol buffers 像 Swift 一样是类型安全的，使用 protocol buffers 时 你需要指定每一个属性的类型。</li><li><strong>自动反序列化</strong>：你不需要再去编写任何的解析代码，只需要更新 <strong>.proto</strong> 文件就行了。 file and regenerate the data access classes.</li><li><strong>分享就是关心</strong>：因为支持多种语言，因此可以在不同的平台中共享数据模型，这意味着跨平台的工作会更轻松。</li></ul><h3 id="1-2-局限性"><a href="#1-2-局限性" class="headerlink" title="1.2 局限性"></a>1.2 局限性</h3><p>Protocol buffers 虽然有着诸多优势，但是它也不是万能的:</p><ul><li><strong>时间成本</strong>：在老项目中去使用 protocol buffers 可能会不太高效，因为需要转换成本。同时，项目成员还需要去学习一种新的语法。</li><li><strong>可读性</strong>：XML 和 JSON 的描述性更好，并且易于阅读。Protocol buffers 的原数据无法阅读(类似txt没有样式，不方便阅读)，并且在没有 <strong>.proto</strong> 文件的情况下没办法解析。</li><li><strong>仅仅是不适合而已</strong>：当你想要使用类似于<a href="http://www.w3schools.com/xml/xml_xslt.asp">XSLT</a>这样的样式表时，XML是最好的选择。所以 protocol buffers 并不总是最佳工具。</li><li><strong>不支持</strong>：编译器可能不支持你正在进行中的项目所使用的语言和平台。</li></ul><h2 id="二、iOS中的单独使用"><a href="#二、iOS中的单独使用" class="headerlink" title="二、iOS中的单独使用"></a>二、iOS中的单独使用</h2><h3 id="2-1-定义-proto文件"><a href="#2-1-定义-proto文件" class="headerlink" title="2.1 定义.proto文件"></a>2.1 定义.proto文件</h3><p>首先要定义一个 Person**.proto** 文件。在这个文件中指定了你的数据结构信息。下面以一个Person模型类为例</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  <span class="comment">// 在第一行声明，我们使用的protobuf语法是proto3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> uid = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-转换为源代码文件"><a href="#2-2-转换为源代码文件" class="headerlink" title="2.2 转换为源代码文件"></a>2.2 转换为源代码文件</h3><p>使用 protocol buffers 的编译器，会根据选择的语言创建好一个数据类(Swift 中的 struct)。可以直接在项目中使用这个类/结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc *.proto --objc_out=../Class  <span class="comment"># objc_out指定了生成程序的目录，如果是Java，那么是java_out</span></span><br><span class="line"><span class="comment"># 产物是：</span></span><br><span class="line"><span class="comment"># Class/Pro_out/Person.pbobjc.h  Person.pbobjc.m</span></span><br><span class="line"><span class="comment"># Class/Pro_source/Person.proto</span></span><br></pre></td></tr></table></figure><h3 id="2-3-iOS工程中引入Protobuf库"><a href="#2-3-iOS工程中引入Protobuf库" class="headerlink" title="2.3 iOS工程中引入Protobuf库"></a>2.3 iOS工程中引入Protobuf库</h3><ul><li>通过Cocoapods</li><li>通过手动导入</li></ul><h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.pbobjc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Person *person = [Person new];</span><br><span class="line">person.name = <span class="string">@&quot;weiCL&quot;</span>;</span><br><span class="line">person.uid = <span class="number">20170810</span>;</span><br><span class="line">person.email = <span class="string">@&quot;cl9000@126.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为Data</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [person data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;NSData= %@&quot;</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化为对象</span></span><br><span class="line">Person *person2 = [Person parseFromData:data error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name:%@ uid:%d email:%@&quot;</span>,person2.name,person2.uid,person2.email);</span><br></pre></td></tr></table></figure><h2 id="三、用在与服务端交互中"><a href="#三、用在与服务端交互中" class="headerlink" title="三、用在与服务端交互中"></a>三、用在与服务端交互中</h2><p>在与服务端交互时，通常使用 JSON 或者 XML 来发送和接收数据，然后根据这些数据生成结构并解析。现在使用 <code>protocol buffers</code> 也类似：</p><ul><li>服务端返回的数据要为pb格式</li><li>移动端使用pb数据的解析配置</li></ul><p>参考链接：<a href="https://juejin.cn/post/6844903622266847246">Protocol Buffers 在 iOS 中的使用</a></p><h2 id="四、编码原理-序列化与反序列化"><a href="#四、编码原理-序列化与反序列化" class="headerlink" title="四、编码原理(序列化与反序列化)"></a>四、编码原理(序列化与反序列化)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可读数据 &#x3D;&#x3D;&#x3D;&#x3D;序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&gt; 二进制</span><br><span class="line">可读数据 &lt;&#x3D;&#x3D;&#x3D;反序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&#x3D; 二进制</span><br></pre></td></tr></table></figure><h3 id="4-1-编码-序列化"><a href="#4-1-编码-序列化" class="headerlink" title="4.1 编码/序列化"></a>4.1 编码/序列化</h3><ul><li><p>Protocol Buffer 序列化采用 Varint、Zigzag 方法，压缩 int 型整数和带符号的整数。对浮点型数字不做压缩（这里可以进一步的压缩，Protocol Buffer 还有提升空间）。</p></li><li><p>对 <code>.proto</code> 文件，会对 option 和 repeated 字段进行检查，若 optional 或 repeated 字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不进行序列化（少编码一个字段）。</p></li><li><p>上面这两点做到了压缩数据，使得序列化工作量减少。</p></li><li><p>Protocol Buffer 是 Tag - Value (TLV)的编码方式的实现</p><ul><li><blockquote><p>在通信协议中，TLV（type-length-value或tag-length-value）是一种用于某种协议中可选信息元素的编码方案。TLV 编码的数据流包含记录类型的代码，然后是记录值长度，最后是值本身。</p></blockquote></li><li><p>数据都以 tag - length - value (或者 tag - value)的形式存在二进制数据流中</p></li><li><p>减少了分隔符的使用（比 JSON 和 XML 少了 <code>&#123; &#125; :</code> 这些符号）</p></li><li><p>没有这些分隔符，使得数据存储更加紧凑，也算是再一次减少了数据的体积。</p></li></ul></li><li><p>综上，pb 体积相对较小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。</p></li></ul><h3 id="4-2-反序列化"><a href="#4-2-反序列化" class="headerlink" title="4.2 反序列化"></a>4.2 反序列化</h3><ul><li>反序列化的实现完全是序列化实现/encode的逆过程。反序列化直接读取二进制字节数据流，同样是一些二进制操作。</li><li>反序列化的时候，通常只需要用到 length。tag 值只是用来标识类型的，Properties 的 setEncAndDec() 方法里面已经把每个类型对应的 decode 解码器初始化好了，所以反序列化的时候，tag 值可以直接跳过，从 length 开始处理。</li><li>XML 的解析过程就复杂一些。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</li></ul><h3 id="4-3-性能"><a href="#4-3-性能" class="headerlink" title="4.3 性能"></a>4.3 性能</h3><ul><li><p>如果很少用到整型数字，浮点型数字，全部都是字符串数据，那么 JSON 和 protocol buffers 性能不会差太多。纯前端之间交互的话，选择 JSON 或者 protocol buffers 差别不是很大。</p></li><li><p>与后端交互过程中，用到 protocol buffers 比较多，笔者认为选择 protocol buffers 除了性能强以外，完美兼容 RPC 调用也是一个重要因素。</p></li></ul><h3 id="4-4-其它特性"><a href="#4-4-其它特性" class="headerlink" title="4.4 其它特性"></a>4.4 其它特性</h3><ol><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol><p>参考链接：<a href="https://halfrost.com/protobuf_encode/">高效的数据压缩编码方式 Protobuf — halfrost</a>、<a href="https://halfrost.com/protobuf_decode/">Protobuf的序列化/反序列化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式</summary>
      
    
    
    
    <category term="Data" scheme="https://tenloy.github.io/categories/Data/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) 动态规划算法</title>
    <link href="https://tenloy.github.io/2021/06/22/dynamic-programming.html"/>
    <id>https://tenloy.github.io/2021/06/22/dynamic-programming.html</id>
    <published>2021-06-22T14:40:13.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、术语介绍"><a href="#一、术语介绍" class="headerlink" title="一、术语介绍"></a>一、术语介绍</h2><p>先来说几个动态规划问题中的术语。</p><p>动态规划(<code>dynamic programming</code>)是运筹学的一个分支，是求解决策过程(<code>decision process</code>)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出了著名的最优化原理(<code>principle of optimality</code>)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p><img src="/images/algorithm/dp-1.jpg" alt="多阶段决策问题的图示"></p><h3 id="1-1-阶段"><a href="#1-1-阶段" class="headerlink" title="1.1 阶段"></a>1.1 阶段</h3><ul><li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同。</li><li>描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用 <code>k</code> 表示。</li><li>此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</li></ul><p><strong>在前面的图中，第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。</strong></p><h3 id="1-2-状态"><a href="#1-2-状态" class="headerlink" title="1.2 状态"></a>1.2 状态</h3><p>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它<strong>既是该阶段某路的起点，同时又是前一阶段某支路的终点。</strong></p><p><strong>前面的例子(图)中，初始状态即A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。</strong></p><p>过程的状态通常可以用一个或一组数来描述，称为<code>状态变量</code>，用<code>x(k)</code>表示。一般，状态是离散的，但有时为了方便也将状态取成连续的。</p><p>而且在每个阶段的状态维数可以不同。状态变量当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为<code>状态集合</code>。</p><h3 id="1-3-无后效性"><a href="#1-3-无后效性" class="headerlink" title="1.3 无后效性"></a>1.3 无后效性</h3><p>我们要求状态具有下面的性质：如果某阶段的状态一旦确定，则在这一阶段以后过程的发展变化仅与此阶段的状态有关，不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。</p><p>换句话说，过程的每一次实现可以用一个状态序列表示。<strong>在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。</strong></p><p>也就是说，<code>未来与过去无关</code>，当前的状态是此前历史（以往决策）的一个完整总结，过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。（简单点说：过去只能通过影响现在，进而影响未来）</p><h3 id="1-4-决策"><a href="#1-4-决策" class="headerlink" title="1.4 决策"></a>1.4 决策</h3><ul><li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为<code>决策</code>。在最优控制中，也称为控制。</li><li><strong>每一个阶段都有若干个决策可供选择。</strong></li><li>在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。</li><li>描述决策的变量称<code>决策变量</code>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。</li></ul><p>决策变量的范围称为<code>允许决策集合</code>。</p><img src="/images/algorithm/dp-3.png" style="zoom:70%"><h3 id="1-5-多阶段决策问题与策略"><a href="#1-5-多阶段决策问题与策略" class="headerlink" title="1.5 多阶段决策问题与策略"></a>1.5 多阶段决策问题与策略</h3><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为<code>多阶段决策问题</code>。</p><ul><li><strong>策略</strong>：由每个阶段的决策组成的一个决策序列称为<strong>策略</strong>。<ul><li>每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取。</li></ul></li><li><strong>允许策略集合</strong>：对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为<strong>允许策略集合</strong>。</li><li><strong>最优策略</strong>：允许策略集合中达到最优效果的策略称为<strong>最优策略</strong>。<ul><li>对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li></ul></li></ul><h3 id="1-6-状态转移方程"><a href="#1-6-状态转移方程" class="headerlink" title="1.6 状态转移方程"></a>1.6 状态转移方程</h3><p>给定k阶段状态变量 <code>x(k)</code> 的值后，如果这一阶段的决策变量一经确定，第 <code>k+1</code> 阶段的状态变量 <code>x(k+1)</code> 也就完全确定，即 <code>x(k+1)</code> 的值随 <code>x(k)</code> 和第 <code>k</code> 阶段的决策 <code>u(k)</code> 的值变化而变化。</p><p>那么可以把这一关系看成 <code>(x(k),u(k))</code> 与 <code>x(k+1)</code> 确定的对应关系，用 <code>x(k+1) = Tk(x(k),u(k))</code> 表示。这是从 <code>k</code> 阶段到 <code>k+1</code> 阶段状态转移方程的状态转移规律，称为状态转移方程。</p><h3 id="1-7-最优化原理-最优子结构性质"><a href="#1-7-最优化原理-最优子结构性质" class="headerlink" title="1.7 最优化原理/最优子结构性质"></a>1.7 最优化原理/最优子结构性质</h3><ul><li>最优性原理：要求问题的<code>最优策略的子策略也是最优</code>。可以通俗地理解为子问题的局部最优将导致整个问题的全局最优，即<code>一个问题的最优解只取决于其子问题的最优解</code>，子问题的非最优解对问题的求解没有影响。</li><li>最优子结构性质：当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。</li></ul><p>一个问题 <code>满足最优化原理</code>也称其 <code>拥有最优子结构性质</code>。</p><p>动态规划引出：</p><p><strong>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决<code>多阶段决策最优化问题</code>的方法为动态规划方法。</strong></p><h2 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h2><blockquote><p>动态规划算法通常用于<code>求解最优性问题</code>：在这类问题中，可能会有许多可行解，每一个解都对应于一个值，我们希望找到具有最优值的解。  </p></blockquote><p><strong>动态规划</strong>(DP：Dynamic Programming)是一种重要的程序设计手段，其基本思想是在对一个<strong>多阶段决策</strong>的问题，按照某一顺序，根据每一步所选决策的不同会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>动态规划</strong>是一种把多阶段过程转化为一系列单阶段问题，逐个求解的方法泛应用于生产调度、工程技术和最优控制等领域。</p><p>动态规划与分治法的异同：</p><ul><li>相同点：都是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>不同点：分治法是将问题划分成相互独立的子问题，因此部分子问题会被重复计算；动态规划方法分解得到的<code>子问题往往不互相独立</code>，而是相互重叠的，从而避免了大量重复计算。</li></ul><p>动态规划的实质是分治思想和解决冗余的结合：</p><ul><li><p>将问题实例分解为更小的、相似的子问题</p></li><li><p>存储子问题的解，在需要时再找出已求得的答案，来避免计算重复的子问题，从而得到多项式时间算法。</p><p>用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的<code>填表格式</code>。</p></li></ul><p>一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解(即满足最优化原理)，则可以考虑用动态规划解决。</p><p>动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。</p><h2 id="三、适用情况"><a href="#三、适用情况" class="headerlink" title="三、适用情况"></a>三、适用情况</h2><p>一般具有以下3个特征：</p><ul><li><p>满足最优化原理(或称：问题具有最优子结构的性质。<code>是动态规划的基础</code>)</p><p>怎么分析问题是否满足？反证法</p><p><strong>先假设由问题的最优解导出的子问题的解不是最优的 → 然后证明在这个假设下可构造出比原问题最优解更好的解 → 从而导致矛盾，证明最优化原理</strong></p></li><li><p>无后效性</p></li><li><p>有重叠子问题：递归地分解问题时，产生的子问题并不总是独立的（很多子问题重复），一个子问题在下一阶段中可能被多次使用到。<strong>该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</strong></p><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。<code>其中的关键在于解决冗余</code>，这是动态规划算法的根本目的。动态规划实质上是一种 <code>以空间换时间</code>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ul><h2 id="四、基本步骤"><a href="#四、基本步骤" class="headerlink" title="四、基本步骤"></a>四、基本步骤</h2><h3 id="4-1-书面版"><a href="#4-1-书面版" class="headerlink" title="4.1 书面版"></a>4.1 书面版</h3><p>1、分析最优解的性质，并刻画其结构特征。(确定满足最优化原理、划分阶段、确定状态)</p><p>2、递归地定义最优解。(确定状态转移方程(递推方程))</p><p>3、以自底向上或自顶向下(备忘录)的方式计算出最优值</p><p>4、根据计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解</p><p>步骤1-3是动态规划算法的基本步骤。在只需求出最优值的情形下，步骤4可以省略，步骤3中记录的信息也较少； 若需要求出问题的一个最优解，则必须执行步骤4，步骤3中记录的信息必须足够多，以便构造最优解。</p><p>【问题描述】：给定两个字符串A[m]、B[n]，求它们的最长公共子序列C。</p><p>1、刻画最优解的结构特征</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果temp=A[m]=B[n]，C=temp+max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...,n<span class="number">-1</span>])；</span><br><span class="line">如果A[m]!=B[n]，则C=maxLen(max_common_len(A[<span class="number">1</span>,...,m],B[<span class="number">1</span>,...,n<span class="number">-1</span>])，max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...n]))。</span><br></pre></td></tr></table></figure><p>2、递归的定义最优解的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设C[i,j]表示两个串A[i]与B[j]的最长公共子序列的长度，则</span><br><span class="line"><span class="keyword">if</span> i=j=<span class="number">0</span>, C[i,j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]==B[j], C[i,j]=<span class="number">1</span>+C[i<span class="number">-1</span>,j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]!=B[j], C[i,j]=max(C[i<span class="number">-1</span>,j],C[i,j<span class="number">-1</span>]).</span><br></pre></td></tr></table></figure><p>3、计算最优解</p><h3 id="4-2-个人理解版本"><a href="#4-2-个人理解版本" class="headerlink" title="4.2 个人理解版本"></a>4.2 个人理解版本</h3><p><strong>第一步：将原问题分解为子问题 — 划分阶段</strong></p><ul><li>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。</li><li>子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</li><li>按照问题的时间或空间特征，把问题分为若干个子问题。划分时，需要注意<strong>划分后的子问题一定要是有序的或者是可排序的</strong>，否则问题就无法求解。(多阶段决策问题)</li></ul><p><strong>第二步：确定状态 — 确定状态、状态空间</strong></p><ul><li>在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。当然，状态的选择要<code>满足无后效性</code>。</li><li>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。</li><li><em>比如：求课件中的最大子段和。有n个状态，即状态空间大小为n，每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。因此，用动态规划算法通常只需要多项式时间。</em></li></ul><p><strong>第三步：确定一些初始状态的值</strong></p><ul><li>初始状态，也会被称为边界状态、叶节点状态(对应一个子问题)</li></ul><p><strong>第四步：确定状态转移方程</strong></p><ul><li>定义出什么是状态、在该状态下的值后，就要找出不同的状态之间如何迁移 —— <strong>怎么从本阶段状态(“值”已知)递推到下一阶段的未解状态，直到最终状态</strong>。(递推型)</li><li>状态的迁移可以用递推公式表示，此递推公式也可被称作<strong>状态转移方程</strong>。</li></ul><p><strong>第五步：开始计算</strong></p><ul><li>以 <code>自底向上</code> 或 <code>自顶向下的记忆化方式（备忘录法</code> 计算出最优值，根据计算最优值时得到的信息，构造问题的最优解。</li></ul><img src="/images/algorithm/dp-2.png" style="zoom:70%"><h3 id="4-3-个人总结"><a href="#4-3-个人总结" class="headerlink" title="4.3 个人总结"></a>4.3 个人总结</h3><ul><li>相比动态规划，分治法与贪心法就简单许多。(首先后两者都不用记录前面状态(子问题)的值)</li><li>分治法：先一分为二…然后合二为一… </li><li>贪心法：也算是多阶段决策问题。找出子问题分解思路、确定状态空间、初始状态值。确定状态转移方程这一步有差异，贪心法是自顶向下一层一层分解，遵守贪心选择原则，得出一系列子问题的局部最优解，直到最小子问题，即可组合出原问题的解。</li></ul><h3 id="4-4-备忘录算法"><a href="#4-4-备忘录算法" class="headerlink" title="4.4 备忘录算法"></a>4.4 备忘录算法</h3><p>备忘录方法是动态规划算法的变形，它通过分治思想对原问题进行分解，以<code>存储子问题的解</code>的方式解决冗余计算，并采用自顶向下的递归方式获取问题的最终解。</p><p><strong>备忘录算法与动态规划算法</strong></p><ul><li><p>相同之处：都会对子问题的计算结果进行存储，解决冗余计算</p></li><li><p>不同之处：动态规划算法是<code>自底向上递推</code>求解，而备忘录方法是<code>自顶向下递归</code>求解。</p></li><li><p>当子问题空间中的大量子问题无需求解时，使用备忘录方法较省时。</p></li><li><p>但当无需计算的子问题只有少部分或全部都要计算时，使用动态规划算法，节省递归带来的额外消耗。</p></li></ul><p>比如：求LCS(最长公共子序列)问题中：</p><ul><li>动态规划算法求算，就是自底向上，将所有会出现的子问题都计算并记录下来，而其实有一些子问题在后续的计算中，并不会被用到。</li><li>而备忘录算法求解，就是自顶向下递归，只计算使用到的子问题并记录，</li></ul><p><strong>备忘录算法与直接递归（备忘录方法 = 递归 + 记录表）</strong></p><ul><li>备忘录方法的控制结构与直接递归方法的控制相同(<strong>递归也是分解子问题，自顶向下求解</strong>)，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同的子问题的重复求解</li><li>备忘录：初始化为每个子问题的记录存入一个特殊的值，表示并未求解。在求解过程中，查看相应记录如果是特殊值，表示未求解，否则只要取出该子问题的解答即可。</li></ul><h2 id="五、程序设计-可只看这部分"><a href="#五、程序设计-可只看这部分" class="headerlink" title="五、程序设计(可只看这部分)"></a>五、程序设计(可只看这部分)</h2><h3 id="5-1-三要素"><a href="#5-1-三要素" class="headerlink" title="5.1 三要素"></a>5.1 三要素</h3><p>动态规划的主要难点在于理论上的设计，也就是上面几个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li>问题的阶段(子问题划分)</li><li>每个阶段的状态</li><li>从前一个阶段转化到后一个阶段之间的递推关系</li></ul><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为<code>递推可以充分利用前面保存的子问题的解来减少重复计算</code>，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><h3 id="5-2-确定状态转移方程"><a href="#5-2-确定状态转移方程" class="headerlink" title="5.2 确定状态转移方程"></a>5.2 确定状态转移方程</h3><p><img src="/images/algorithm/dp-1.jpg" alt="仍以该图为例"></p><ul><li><strong>阶段</strong>：描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。<ul><li>第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。 </li></ul></li><li><strong>状态</strong>：状态通常可以用一个或一组数来描述，称为状态变量，记为x(k)。 <ul><li>初始状态为A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。 </li></ul></li><li><strong>决策</strong>：每一个阶段都有若干个决策可供选择，描述决策的变量称决策变量。记为u(k)。</li><li><strong>每个阶段状态的值：</strong>为演变到该状态的前一阶段的状态值F(k) + 决策对应的值。如果发现更优解，覆盖之前的(最优常指耗费最小/路径最短，或是收益最大)。</li></ul><p>以凑零钱问题为例，<strong>如何列出正确的状态转移方程</strong>？(<a href="https://labuladong.gitee.io/algo/1/3/">动态规划详解 — labuladong</a>)</p><ol><li><p><strong>确定</strong> <strong>base case</strong>，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p><strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p></li><li><p><strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p></li><li><p><strong>明确 dp 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。</p></li></ol><p>就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p><img src="/images/algorithm/dp-4.png" style="zoom:100%"><p>更简单一些的：最长公共子序列问题，dp中没有自变量。</p><img src="/images/algorithm/dp-5.png" style="zoom:100%"><p>更复杂一些的：如投资问题</p><img src="/images/algorithm/dp-6.png" style="zoom:100%"><ul><li>已知：$f_k(x)$为投资项目k x元钱，所得到的收益</li><li>$F_k(x)$：x元钱投给前k个项目最大效益</li><li>$x_k$：投给项目k的钱数</li></ul><h3 id="5-3-最优决策表"><a href="#5-3-最优决策表" class="headerlink" title="5.3 最优决策表"></a>5.3 最优决策表</h3><p>确定了动态规划的这三要素，整个求解过程就可以用一个<code>最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态</code>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的<code>最优值</code>（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">max</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="operator">-</span><span class="variable">w</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">+</span><span class="variable">P</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-一般的算法设计模式如下"><a href="#5-4-一般的算法设计模式如下" class="headerlink" title="5.4 一般的算法设计模式如下"></a>5.4 一般的算法设计模式如下</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、经典运用"><a href="#六、经典运用" class="headerlink" title="六、经典运用"></a>六、经典运用</h2><ul><li>矩阵连乘</li><li>走金字塔</li><li>最长公共子序列(LCS)</li><li>最长递增子序列(LIS)</li><li>凸多边形最优三角剖分</li><li>背包问题</li><li>双调欧几里得旅行商问题</li><li>求全路径最短路径的Floyd算法</li><li>…</li></ul><h3 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0-1背包问题"></a>6.1 0-1背包问题</h3><p>【问题描述】<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1.我们设物品i的装入状态为xi,xi∈ (0,1)，此问题称为0-11背包问题。</p><p>【数据】<br>物品个数n=5，物品重量$w[n] = {0,2,2,6,5,4}$，物品价值$V[n] = {0,6,3,5,4,6}$（第0位，置为0，不参与计算，只是便于与后面的下标进行统一，无特别用处，也可不这么处理）。总重量$c=10$。背包的最大容量为10，那么在设置数组m大小时，可以设行列值为6和11，那么，对于$m(i,j)$就表示可选物品为$i…n$背包容量为j(总重量)时背包中所放物品的最大价值。</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ol><li><p>看了好多，<a href="https://blog.csdn.net/baidu_28312631/article/details/47418773">这一篇博客</a>尤为通俗易懂</p></li><li><p>如果要看备忘录算法、动态规划算法之间的差异，可以看<a href="https://blog.csdn.net/u013309870/article/details/75193592">这篇博客</a>，并做一下<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">求LCS</a>这道题，搜一下它的两种解法</p></li><li><p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin">动态规划 — 百度百科</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、术语介绍&quot;&gt;&lt;a href=&quot;#一、术语介绍&quot; class=&quot;headerlink&quot; title=&quot;一、术语介绍&quot;&gt;&lt;/a&gt;一、术语介绍&lt;/h2&gt;&lt;p&gt;先来说几个动态规划问题中的术语。&lt;/p&gt;
&lt;p&gt;动态规划(&lt;code&gt;dynamic programming</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://tenloy.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://tenloy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>前端各种模块化方案总结</title>
    <link href="https://tenloy.github.io/2021/06/18/Web-Module.html"/>
    <id>https://tenloy.github.io/2021/06/18/Web-Module.html</id>
    <published>2021-06-18T11:09:27.000Z</published>
    <updated>2021-09-09T02:40:14.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>那么，到底什么是模块化开发呢？</p><blockquote><p>模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。</p></blockquote><ul><li>现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋</li><li>代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统</li></ul><p><strong>模块化：</strong></p><ul><li>模块化开发就是<strong>将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来</strong>；</li><li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li><li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li><li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li></ul><p><strong>模块化的好处：</strong></p><ol><li>防止命名冲突</li><li>代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题）</li><li>高维护性（模块之间有高耦合低内聚的特点）</li></ol><h3 id="1-2-JavaScript设计缺陷"><a href="#1-2-JavaScript设计缺陷" class="headerlink" title="1.2 JavaScript设计缺陷"></a>1.2 JavaScript设计缺陷</h3><p>无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在<em>Brendan Eich</em>用了10天写出JavaScript的时候，它都有很多的缺陷：</p><ul><li>比如var定义的变量作用域问题；</li><li>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；</li><li>比如JavaScript没有模块化的问题；</li></ul><p><em>Brendan Eich</em>本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。</p><ul><li>JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；</li></ul><p>在网页开发的早期，<em>Brendan Eich</em>开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：</p><ul><li>这个时候我们只需要讲JavaScript代码写到<code>&lt;script&gt;</code>标签中即可；</li><li>并没有必要放到多个文件中来编写；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：</p><ul><li>ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；</li><li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；</li><li>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求。</p><h3 id="1-3-没有模块化的JavaScript"><a href="#1-3-没有模块化的JavaScript" class="headerlink" title="1.3 没有模块化的JavaScript"></a>1.3 没有模块化的JavaScript</h3><h4 id="1-3-1-技术方案"><a href="#1-3-1-技术方案" class="headerlink" title="1.3.1 技术方案"></a>1.3.1 技术方案</h4><p>演变过程：</p><ul><li><p>全局函数</p><ul><li>”污染”了全局变量，无法保证不与其它模块发生变量名冲突</li><li>没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块</li></ul></li><li><p>将函数封装到对象命名空间下</p><ul><li>从代码级别可以明显的区分出哪些函数属于同一个模块</li><li>从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突</li><li>会暴露所有的模块成员，内部状态可以被外部改写，不安全</li><li>命名空间越来越长</li></ul></li><li><p>立即函数调用表达式(<strong>IIFE</strong>，Immediately Invoked Function Expression)</p><ul><li><p>将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露</p></li><li><p>会有人强调<strong>职责单一性</strong>，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">add</span>:add &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params">cal,$</span>)</span>&#123;</span><br><span class="line">  cal.add2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> v1=$(<span class="string">&#x27;#v1&#x27;</span>).val();</span><br><span class="line">      <span class="keyword">var</span> v2= $(<span class="string">&#x27;#v2&#x27;</span>).val();</span><br><span class="line">     <span class="keyword">return</span> (v1-<span class="number">0</span>)+(v2-<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cal;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.calculator||&#123;&#125;,<span class="built_in">window</span>.$)</span><br><span class="line"><span class="comment">//在这告诉我要jquery</span></span><br><span class="line"><span class="comment">//依赖注入</span></span><br><span class="line"><span class="comment">//很牵强的解决文件依赖问题的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IIFE也是有很大缺陷的，见下方代码举例</p></li></ul><h4 id="1-3-2-问题举例"><a href="#1-3-2-问题举例" class="headerlink" title="1.3.2 问题举例"></a>1.3.2 问题举例</h4><p>我们先来简单体会一下没有模块化代码的问题。</p><p>我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：</p><ul><li>我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小丽开发了bbb.js文件，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显出现了一个问题：</p><ul><li>大家都喜欢使用flag来存储一个boolean类型的值；</li><li>但是一个人赋值了true，一个人赋值了false；</li><li>如果之后都不再使用，那么也没有关系；</li></ul><p>但是，小明又开发了ccc.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了：小明发现ccc中的flag值不对</p><ul><li>对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；</li><li>但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？</li></ul><p>备注：引用路径如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ccc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，没有模块化对于一个大型项目来说是灾难性的。</p><h4 id="1-3-3-IIFE的缺陷"><a href="#1-3-3-IIFE的缺陷" class="headerlink" title="1.3.3 IIFE的缺陷"></a>1.3.3 IIFE的缺陷</h4><p>使用IIFE解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">flag</span>: flag &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> moduleB = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="keyword">const</span> moduleC = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flag = moduleA.flag;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名冲突的问题，有没有解决呢？解决了。</p><p>但是，我们其实带来了新的问题：</p><ul><li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；</li><li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li><li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；</li></ul><p><strong>所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。</strong></p><ul><li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；</li><li>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；</li></ul><h3 id="1-4-JavaScript中模块化方案"><a href="#1-4-JavaScript中模块化方案" class="headerlink" title="1.4 JavaScript中模块化方案"></a>1.4 JavaScript中模块化方案</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有：</p><p>先有规范，后有实现：</p><ul><li>服务器端规范 <a href="http://www.commonjs.org/">CommonJS</a> =&gt; <a href="https://nodejs.org/">NodeJS</a>、 Browserify</li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">AMD</a> =&gt; <a href="http://requirejs.org/">RequireJS</a></li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">CMD</a> =&gt; <a href="http://seajs.org/">SeaJS</a></li></ul><h2 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h2><h3 id="2-1-CommonJS和Node"><a href="#2-1-CommonJS和Node" class="headerlink" title="2.1 CommonJS和Node"></a>2.1 CommonJS和Node</h3><p>我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为<strong>ServerJS</strong>，后来为了体现它的广泛性，修改为<strong>CommonJS</strong>，平时我们也会简称为CJS。</p><ul><li>Node是CommonJS在服务器端一个具有代表性的实现；</li><li>Browserify是CommonJS在浏览器中的一种实现；</li><li>webpack打包工具具备对CommonJS的支持和转换（后面会讲到）；</li></ul><p>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><h3 id="2-2-Node模块化语法"><a href="#2-2-Node模块化语法" class="headerlink" title="2.2 Node模块化语法"></a>2.2 Node模块化语法</h3><h4 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1 模块"></a>2.2.1 模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的代码会报错：</span></span><br><span class="line"><span class="comment"> - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；</span></span><br><span class="line"><span class="comment"> - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>在node中每一个文件都是一个独立的模块，有自己的作用域</strong>。在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</p><p>为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</p><p>每个模块(文件)中都包括CommonJS规范的核心变量：exports、module、require；</p><ul><li><p>module：是一个全局对象，代表当前模块。里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.id           <span class="comment">//带有绝对路径的模块文件名</span></span><br><span class="line"><span class="built_in">module</span>.filename      <span class="comment">//模块的文件名，带有绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.loaded       <span class="comment">//表示模块是否已经完成加载</span></span><br><span class="line"><span class="built_in">module</span>.parent     <span class="comment">//返回一个对象，表示调用该模块的模块。</span></span><br><span class="line"><span class="built_in">module</span>.children      <span class="comment">//返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line"><span class="built_in">module</span>.exports     <span class="comment">//模块对外输出的值。需要打破模块封装性曝露的方法和属性，都要挂载到module.exports上。其它文件加载该模块,实际上就是读取module.exports属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module);</span></span><br><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/Users/computer/Desktop/ccc&#x27;</span>,</span><br><span class="line">  <span class="built_in">exports</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">&#x27;/Users/computer/Desktop/ccc/main.js&#x27;</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [</span><br><span class="line">    Module &#123;...&#125;</span><br><span class="line">  ],</span><br><span class="line">  paths: [ <span class="comment">//查找路径</span></span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/ccc/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>exports是module.exports的引用。一起负责对模块中的内容进行导出；</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p></li></ul><p>在Node.js中，模块分为两类：</p><ul><li><p>第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。</p><ul><li>fs(file system)：与文件系统交互</li><li>http：提供http服务器功能</li><li>os：提供了与操作系统相关的实用方法和属性</li><li>path：处理文件路径</li><li>querystring：解析url查询字符串</li><li>url：解析url</li><li>util：提供一系列实用小工具</li><li>Buffer </li><li>等等很多，见<a href="http://api.nodejs.cn/">官方文档</a></li><li><strong>核心模块的源码都在Node的lib子目录中。为了提高运行速度，它们安装的时候都会被编译成二进制文件</strong></li></ul></li><li><p>第二类，文件模块，也称自定义模块。用路径加载。</p><p>有一种特殊的文件模块 — 包，被管理在<code>node_modules</code>文件夹中的包，也可以直接用名字加载。</p></li></ul><h4 id="2-2-2-exports导出"><a href="#2-2-2-exports导出" class="headerlink" title="2.2.2 exports导出"></a>2.2.2 exports导出</h4><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出内容</span></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 导入内容</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码意味着什么呢？</p><ul><li>意味着main中的bar变量等于exports对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main中的bar = bar中的<span class="built_in">exports</span></span><br></pre></td></tr></table></figure><p>所以，我可以编写下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = bar.name;</span><br><span class="line"><span class="keyword">const</span> age = bar.age;</span><br><span class="line"><span class="keyword">const</span> sayHello = bar.sayHello;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br></pre></td></tr></table></figure><p>模块之间的引用关系：</p><img src="/images/webmodule/moduleref.jpg" alt="图片" style="zoom:70%;" /><p>为了进一步论证，bar和exports是同一个对象：</p><ul><li>所以，bar对象是exports对象的浅拷贝；</li><li>浅拷贝的本质就是一种引用的赋值而已；</li></ul><p>定时器修改对象：</p><img src="/images/webmodule/settimeoutmod.jpg" alt="图片" style="zoom:80%;" /><h4 id="2-2-3-module-exports"><a href="#2-2-3-module-exports" class="headerlink" title="2.2.3 module.exports"></a>2.2.3 module.exports</h4><p>但是Node中我们经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p><ul><li>CommonJS中是没有module.exports的概念的；</li><li>但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</li><li><strong>module才是导出的真正实现者；</strong></li><li>所以在Node中<strong>真正用于导出的其实根本不是exports，而是module.exports</strong>。只是为了实现CommonJS的规范，也为了使用方便，Node为每个模块提供了一个exports对象，让其对module.exports有一个引用而已。</li><li>相当于在每个模块头部，有这样一行命令：<code>var exports = module.exports;</code></li></ul><img src="/images/webmodule/export1.jpg" alt="图片" style="zoom:67%;" /><p><strong>不能直接给exports、module.exports赋值，这样等于切断了exports和module.exports的联系。最终输出的结果只会是module.exports的值</strong>。比如代码这样修改了：</p><img src="/images/webmodule/export2.jpg" alt="图片" style="zoom:67%;" /><img src="/images/webmodule/moduleexports.jpg" alt="moduleexports" style="zoom:68%;" /><h4 id="2-2-4-require"><a href="#2-2-4-require" class="headerlink" title="2.2.4 require"></a>2.2.4 require</h4><h5 id="1-require的加载原理"><a href="#1-require的加载原理" class="headerlink" title="1. require的加载原理"></a>1. require的加载原理</h5><p>前面已经说过，CommonJS 的一个模块，就是一个脚本文件。</p><ul><li><p>CommonJS是同步加载。模块加载的顺序，按照其在代码中出现的顺序</p></li><li><p><code>require</code>命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码，返回该模块的module.exports接口数据。会在内存生成一个该模块对应的module对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>); <span class="comment">// aaa.js中的代码在引入时会被运行一次</span></span><br></pre></td></tr></table></figure><p>生成的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">&#x27;...&#x27;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">  <span class="built_in">exports</span>: &#123; ... &#125;,  <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  loaded: <span class="literal">true</span>,   <span class="comment">// 是一个布尔值，为false表示还没有加载，为true表示已经加载完毕。这是保证每个模块只加载、运行一次的关键。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。</p></li><li><p>模块被多次引入时（多次执行<code>require</code>命令），CommonJS 模块<strong>只会在第一次加载时运行一次</strong>，以后再加载，会去缓存中取出第一次加载时生成的module对象并返回module.exports。除非手动清除系统缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ccc被加载&#x27;</span>);  <span class="comment">// ccc中的代码只会运行一次。</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-require的查找规则"><a href="#2-require的查找规则" class="headerlink" title="2. require的查找规则"></a>2. require的查找规则</h5><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。</p><p>那么，require的查找规则是怎么样的呢？<a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">官方文档</a></p><p><strong>这里我总结比较常见的查找规则：</strong>导入格式如下：require(X)</p><ul><li><p>情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找</p><ul><li>加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。</li></ul></li><li><p>情况二：X是以 <code>./</code> 或 <code>../</code> 或 <code>/</code>（根目录）开头的</p><ul><li>在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径</li><li>第一步：将X当做一个文件在对应的目录下查找；<ul><li>如果有后缀名，按照后缀名的格式查找对应的文件</li><li>如果没有后缀名，会按照如下顺序：<ol><li>直接查找文件X</li><li>查找X.js文件：当做JavaScript脚本文件解析</li><li>查找X.json文件：以JSON格式解析。<ul><li>如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。</li><li>json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象</li></ul></li><li>查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块</li></ol></li></ul></li><li>第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件<ol><li>查找X/index.js文件</li><li>查找X/index.json文件</li><li>查找X/index.node文件</li></ol></li><li>如果没有找到，那么报错：<code>not found</code></li></ul></li><li><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li> 比如在<code>/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js</code>中</li></ul><p>  编写 <code>require(&#39;why&#39;)</code></p><ul><li><p>查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取… 一直找到全局 node_modules 目录。</p><img src="/images/webmodule/require1.jpg" alt="图片" style="zoom:70%;" /></li><li><p>这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就<strong>默认取文件夹下的 index.js</strong>。</p><p>由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。</p></li><li><p>如果上面的路径中都没有找到，那么报错：<code>not found</code></p></li></ul></li></ul><p>流程图：</p><img src="/images/webmodule/image1.jpg" alt="Alt text" style="zoom:80%;" /><ul><li><p>Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错</p></li><li><p>优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports <a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/">参考文献</a></p></li></ul><h5 id="3-require的加载顺序"><a href="#3-require的加载顺序" class="headerlink" title="3. require的加载顺序"></a>3. require的加载顺序</h5><p><strong>如果有多个模块的引入，那么加载顺序是什么？</strong></p><p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p><ul><li>这个其实是一种数据结构：图结构；</li><li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li><li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li></ul><p>多个模块的引入关系：</p><img src="/images/webmodule/multiMoudlesinclude.jpg" alt="multiMoudlesinclude" style="zoom:80%;" /><h3 id="2-3-Node的源码解析"><a href="#2-3-Node的源码解析" class="headerlink" title="2.3 Node的源码解析"></a>2.3 Node的源码解析</h3><p>Module类</p><img src="/images/webmodule/moduleclssource.jpg" alt="图片" style="zoom:80%;" /><p>Module.prototype.require函数</p><img src="/images/webmodule/requiremethodsource.jpg" alt="图片" style="zoom:80%;" /><p>Module._load函数</p><img src="/images/webmodule/loadmethodsource.jpg" alt="图片" style="zoom:80%;" /><h2 id="三、ES6-Module"><a href="#三、ES6-Module" class="headerlink" title="三、ES6 Module"></a>三、ES6 Module</h2><h3 id="4-1-认识ES6-Module"><a href="#4-1-认识ES6-Module" class="headerlink" title="4.1 认识ES6 Module"></a>4.1 认识ES6 Module</h3><h4 id="4-1-1-ES6-Module的优势"><a href="#4-1-1-ES6-Module的优势" class="headerlink" title="4.1.1 ES6 Module的优势"></a>4.1.1 ES6 Module的优势</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。</p><p>由于 ES6 模块是编译时加载：</p><ul><li><p>可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高</p></li><li><p>使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></li></ul><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><h4 id="4-1-2-自动启动严格模式"><a href="#4-1-2-自动启动严格模式" class="headerlink" title="4.1.2 自动启动严格模式"></a>4.1.2 自动启动严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><ul><li>其中，尤其需要注意<code>this</code>的限制。<font color=red>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></font>。</li><li>参考链接：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式—MDN</a></li><li><a href="https://tenloy.github.io/pnote/web_note/05-JS%E9%AB%98%E7%BA%A7/Sources/3.6_ES5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html">严格模式—阮一峰</a></li></ul></li></ul><h4 id="4-1-3-浏览器中加载ES6-Module"><a href="#4-1-3-浏览器中加载ES6-Module" class="headerlink" title="4.1.3 浏览器中加载ES6 Module"></a>4.1.3 浏览器中加载ES6 Module</h4><h5 id="1-加载普通js文件"><a href="#1-加载普通js文件" class="headerlink" title="1. 加载普通js文件"></a>1. 加载普通js文件</h5><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="javascript"> <span class="comment">// code </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="javascript"> <span class="comment">//code... </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p></li><li><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。</p></li></ul><p>下面就是两种异步加载的语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：</p><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</li><li>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</li></ul><h5 id="2-加载ES6-Module"><a href="#2-加载ES6-Module" class="headerlink" title="2. 加载ES6 Module"></a>2. 加载ES6 Module</h5><p>浏览器内嵌、外链 ES6 模块代码，也使用<code>&lt;script&gt;</code>标签，但是都要加入<code>type=&quot;module&quot;</code>属性。</p><p><code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于下面代码。如果网页有多个 &lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;script&gt;标签的async属性也可以打开：</span></span><br><span class="line"><span class="comment">这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 </span></span><br><span class="line"><span class="comment">同样的：一旦使用了此属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="built_in">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-本地浏览的报错"><a href="#4-1-4-本地浏览的报错" class="headerlink" title="4.1.4 本地浏览的报错"></a>4.1.4 本地浏览的报错</h4><p>代码结构如下（个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── modules</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.html中引入两个js文件作为模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接在浏览器中运行代码，会报如下错误：</p><img src="/images/webmodule/modulerunerror.jpg" alt="图片" style="zoom:80%;" /><p>这个在MDN上面有给出解释：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></li><li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。</li><li>你需要通过一个服务器来测试。</li></ul><p>我这里使用的VSCode，VSCode中有一个插件：Live Server</p><ul><li>通过插件运行，可以将我们的代码运行在一个本地服务中；</li></ul><img src="/images/webmodule/liveserver.jpg" alt="图片" style="zoom:80%;" /><h3 id="4-2-ES6-Module的语法"><a href="#4-2-ES6-Module的语法" class="headerlink" title="4.2 ES6 Module的语法"></a>4.2 ES6 Module的语法</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>：</p><ul><li><code>export</code>命令用于规定模块的对外接口</li><li><code>import</code>命令用于输入其他模块提供的功能。</li></ul><h4 id="4-2-1-模块与CommonJS模块的区别"><a href="#4-2-1-模块与CommonJS模块的区别" class="headerlink" title="4.2.1 模块与CommonJS模块的区别"></a>4.2.1 模块与CommonJS模块的区别</h4><h5 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h5><p>与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h5 id="2-导出的不同"><a href="#2-导出的不同" class="headerlink" title="2. 导出的不同"></a>2. 导出的不同</h5><p><strong>CommonJS通过module.exports导出的是一个对象，是<code>module.exports</code>属性浅拷贝后导出：</strong></p><ul><li><p>该对象只有在脚本运行完才会生成。</p></li><li><p>导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p><strong>ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用：</strong></p><p>说法1：</p><ul><li>它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错)</li><li>所以，<code>import</code>命令叫做“连接” binding 其实更合适。</li></ul><p>说法2：</p><ul><li><p>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>（module environment record）；</p></li><li><p><strong>模块环境记录</strong>会和变量进行 <code>绑定</code>（binding），并且这个绑定是实时的；</p></li><li><p>而在导入的地方，我们是可以实时的获取到绑定的最新值的；</p></li></ul><p><strong>export和import绑定的过程：</strong></p><img src="/images/webmodule/bindingProcedure.jpg" alt="图片" style="zoom:70%;" /><p>还是举上面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><h5 id="3-导入的不同"><a href="#3-导入的不同" class="headerlink" title="3. 导入的不同"></a>3. 导入的不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码实质会整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码实质只是从<code>fs</code>模块加载 3 个方法，其他方法不加载。</p><h4 id="4-2-2-export"><a href="#4-2-2-export" class="headerlink" title="4.2.2 export"></a>4.2.2 export</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p><h5 id="1-export-lt-decl-gt"><a href="#1-export-lt-decl-gt" class="headerlink" title="1. export &lt;decl&gt;"></a>1. <code>export &lt;decl&gt;</code></h5><p>方式一：分别导出。在<strong>语句声明</strong>的前面直接加上export关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> message = <span class="string">&quot;my name is why&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export需要指定对外暴露的接口，所以不能直接输出一个值</span></span><br><span class="line"><span class="comment">// export 40; //error</span></span><br></pre></td></tr></table></figure><h5 id="2-export"><a href="#2-export" class="headerlink" title="2. export {}"></a>2. <code>export &#123;&#125;</code></h5><p>方式二：统一导出。将所有需要导出的标识符，放到export后面的 <code>&#123;&#125;</code>中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。</p><ul><li>注意：这里的 <code>&#123;&#125;</code>里面不是ES6的对象字面量的增强写法，<code>&#123;&#125;</code>也不是表示一个对象的；</li><li>所以：<code>export &#123;name: name&#125;</code>，是错误的写法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-export-lt-gt-as-lt-gt"><a href="#3-export-lt-gt-as-lt-gt" class="headerlink" title="3. export {&lt;&gt; as &lt;&gt;}"></a>3. <code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></h5><p>方式三：通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字在导出时给<code>标识符</code>起一个别名：<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fName,</span><br><span class="line">  age <span class="keyword">as</span> fAge,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello1,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello2, <span class="comment">// 重命名后，sayHello可以用不同的名字输出两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-export导出的是标识符的地址"><a href="#4-export导出的是标识符的地址" class="headerlink" title="4. export导出的是标识符的地址"></a>4. export导出的是标识符的地址</h5><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p><h5 id="5-export导出同一个实例"><a href="#5-export导出同一个实例" class="headerlink" title="5. export导出同一个实例"></a>5. export导出同一个实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变</p><h5 id="6-export书写位置"><a href="#6-export书写位置" class="headerlink" title="6. export书写位置"></a>6. export书写位置</h5><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;bar&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h5 id="7-export书写次数"><a href="#7-export书写次数" class="headerlink" title="7. export书写次数"></a>7. export书写次数</h5><p>一个模块中：<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</p><h4 id="4-2-3-import"><a href="#4-2-3-import" class="headerlink" title="4.2.3 import"></a>4.2.3 import</h4><p>import关键字负责从另外一个模块中导入内容。</p><p><strong><code>import</code>语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。</strong></p><p><strong>导入内容的方式也有多种：</strong></p><h5 id="1-import-from-39-39"><a href="#1-import-from-39-39" class="headerlink" title="1. import {} from &#39;&#39;"></a>1. <code>import &#123;&#125; from &#39;&#39;</code></h5><p>方式一：选择导入。<code>import &#123;标识符列表&#125; from &#39;模块&#39;</code>；</p><p>注意：</p><ul><li>大括号里面的变量名，必须与被导入模块对外接口的名称相同。</li><li>这里的<code>&#123;&#125;</code>也不是一个对象，里面只是存放导入的标识符列表内容；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>name</code>和<code>age</code>在两个语句中加载，但是它们对应的是同一个<code>foo.js</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p><h5 id="1-import-39-39-的含义"><a href="#1-import-39-39-的含义" class="headerlink" title="1. import &#39;&#39;的含义"></a>1. <code>import &#39;&#39;</code>的含义</h5><p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; </span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不导入任何值。</p><p>同样的，如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">// 代码加载了两次`lodash`，但是只会执行一次。</span></span><br></pre></td></tr></table></figure><h5 id="2-import-lt-gt-as-lt-gt-from-39-39"><a href="#2-import-lt-gt-as-lt-gt-from-39-39" class="headerlink" title="2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;"></a>2.  <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></h5><p>方式二：导入时给标识符起别名： <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, sayHello <span class="keyword">as</span> wSayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="3-import-as-lt-gt-from-39-39"><a href="#3-import-as-lt-gt-from-39-39" class="headerlink" title="3.  import * as &lt;&gt; from &#39;&#39;"></a>3.  <code>import * as &lt;&gt; from &#39;&#39;</code></h5><p>方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用<code>*</code>指定： <code>import * as &lt;&gt; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line">foo.sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.n = &quot;add&quot;; // Type Error: object is not extensible</span></span><br><span class="line"><span class="comment">// foo.f = function () &#123;&#125;; </span></span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。</p><h5 id="4-import导入为只读"><a href="#4-import导入为只读" class="headerlink" title="4. import导入为只读"></a>4. import导入为只读</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">name = <span class="string">&quot;mod&quot;</span>; <span class="comment">// Syntax Error : &#x27;name&#x27; is read-only;</span></span><br></pre></td></tr></table></figure><p><code>name</code>是只读的。但是，如果<code>name</code>是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p><h5 id="5-import-from后的路径"><a href="#5-import-from后的路径" class="headerlink" title="5. import from后的路径"></a>5. import from后的路径</h5><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<font color=red>后缀名不能省略</font>。</p><p>如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><h5 id="6-import命令的提升"><a href="#6-import命令的提升" class="headerlink" title="6. import命令的提升"></a>6. import命令的提升</h5><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="7-import中不能使用表达式和变量"><a href="#7-import中不能使用表达式和变量" class="headerlink" title="7. import中不能使用表达式和变量"></a>7. import中不能使用表达式和变量</h5><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><h4 id="4-2-4-export-default"><a href="#4-2-4-export-default" class="headerlink" title="4.2.4 export default"></a>4.2.4 export default</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p><ul><li>在导出export时指定了名字；</li><li>在导入import时需要知道具体的名字；</li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li>默认导出export时可以不需要指定名字；</li><li>在导入时不需要使用 <code>&#123;&#125;</code>，并且可以自己来指定名字；</li><li>它也方便我们和现有的CommonJS等规范相互操作；</li></ul><h5 id="2-导出与导入格式"><a href="#2-导出与导入格式" class="headerlink" title="2. 导出与导入格式"></a>2. 导出与导入格式</h5><p>也是可以导出变量、函数、类的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出格式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式2：用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式3：用在函数变量前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;sub&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式1：常用及推荐</span></span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.default.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式3</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h5 id="3-export-default的本质"><a href="#3-export-default的本质" class="headerlink" title="3. export default的本质"></a>3. export default的本质</h5><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;  <span class="comment">// 等同于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>; <span class="comment">// 等同于 import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// export default var a = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// export 42; // export后面得跟声明，或者&#123;标识符&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-export-default与export"><a href="#4-export-default与export" class="headerlink" title="4. export default与export"></a>4. export default与export</h5><p>注意：在一个模块中，export default是可以与export同时使用的：</p><ul><li>export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。</li><li>export是没有限制的。<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&quot;module1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 在一条`import`语句中，同时输入默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> m, &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">//m.sub、name</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.default.sub、m.name</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m, name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.sub、name</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-export和import结合"><a href="#4-2-5-export和import结合" class="headerlink" title="4.2.5 export和import结合"></a>4.2.5 export和import结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出一个sum函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js做一个中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js直接从foo中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js 导入，但是只是做一个中转</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> barSum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 甚至在foo.js中导出时，我们可以变化它的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入和导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口的写法如下：</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口：</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。</span></span><br></pre></td></tr></table></figure><p>为什么要这样做呢？</p><ul><li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li><li>这样方便指定统一的接口规范，也方便阅读；</li><li>这个时候，我们就可以使用export和import结合使用；</li></ul><h4 id="4-2-6-import"><a href="#4-2-6-import" class="headerlink" title="4.2.6 import()"></a>4.2.6 import()</h4><h5 id="1-import-的背景"><a href="#1-import-的背景" class="headerlink" title="1. import()的背景"></a>1. import()的背景</h5><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，<code>import</code>和<code>export</code>命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在<code>if</code>代码块之中，或在函数之中）的。下面的代码会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;./&#x27;</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path); </span><br><span class="line"><span class="comment">// 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;<span class="comment">// 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数.</span></span><br><span class="line"><span class="comment">//.then(&#123;export1, export2&#125; =&gt; &#123;     // 可以使用对象解构赋值的语法，获取输出接口。</span></span><br><span class="line"><span class="comment">//.then(&#123;default: theDefault&#125; =&gt; &#123;  // 如果是default，那么需要解构重命名</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">module</span>.loadPageInto(main); <span class="comment">// module.default来使用默认导出</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是Promise对象，所以也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h5 id="3-适用场合"><a href="#3-适用场合" class="headerlink" title="3. 适用场合"></a>3. 适用场合</h5><ul><li><p>按需加载。</p><p><code>import()</code>可以在需要的时候，再加载某个模块。比如放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p></li><li><p>条件加载</p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p></li><li><p>动态的模块路径</p><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f()).then(...);  <span class="comment">// 根据函数`f`的返回结果，加载不同的模块。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-7-应用-公共头文件"><a href="#4-2-7-应用-公共头文件" class="headerlink" title="4.2.7 应用: 公共头文件"></a>4.2.7 应用: 公共头文件</h4><p>介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  admin_username: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  admin_password: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-与CommonJS模块化的差异"><a href="#4-2-8-与CommonJS模块化的差异" class="headerlink" title="4.2.8 与CommonJS模块化的差异"></a>4.2.8 与CommonJS模块化的差异</h4><ul><li><p>CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。</p><ul><li><p>运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用</p></li><li><p>编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li><li>所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；</li></ul></li></ul></li><li><p>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</p><ul><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li><li>异步的意味着：不会阻塞主线程继续执行；<ul><li>JS引擎在遇到<code>import</code>时会去获取这个js文件的过程是异步的</li><li>设置了 <code>type=module</code> 的script标签，相当于加上了 <code>async</code> 属性；</li><li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；</li></ul></li></ul></li></ul><p>CommonJS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main代码执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// 同步加载foo文件，并且执行一次内部的代码</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;if语句继续执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES Module代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、CommonJS模块与ES6模块的混编"><a href="#四、CommonJS模块与ES6模块的混编" class="headerlink" title="四、CommonJS模块与ES6模块的混编"></a>四、CommonJS模块与ES6模块的混编</h2><h3 id="4-3-CommonJS模块加载ES6模块"><a href="#4-3-CommonJS模块加载ES6模块" class="headerlink" title="4.3 CommonJS模块加载ES6模块"></a>4.3 CommonJS模块加载ES6模块</h3><p>通常情况下，CommonJS不能加载ES Module</p><ul><li>因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；</li><li>但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；</li></ul><p>可以使用<code>import()</code>这个方法加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><h3 id="4-2-ES6模块加载CommonJS模块"><a href="#4-2-ES6模块加载CommonJS模块" class="headerlink" title="4.2 ES6模块加载CommonJS模块"></a>4.2 ES6模块加载CommonJS模块</h3><p>多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。</p><ul><li>ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；</li><li>这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;foo的address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.address);</span><br></pre></td></tr></table></figure><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><h3 id="4-3-使模块同时支持两种模块化导入"><a href="#4-3-使模块同时支持两种模块化导入" class="headerlink" title="4.3 使模块同时支持两种模块化导入"></a>4.3 使模块同时支持两种模块化导入</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.foo;</span><br></pre></td></tr></table></figure><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>如果是Node.js中，还有一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><h2 id="五、Node-js开发中的模块化"><a href="#五、Node-js开发中的模块化" class="headerlink" title="五、Node.js开发中的模块化"></a>五、Node.js开发中的模块化</h2><h3 id="5-1-Node中支持-ES6-Module"><a href="#5-1-Node中支持-ES6-Module" class="headerlink" title="5.1 Node中支持 ES6 Module"></a>5.1 Node中支持 ES6 Module</h3><p>JavaScript 现在常用的有两种模块。</p><ul><li>ES6 模块，简称 ESM；</li><li>CommonJS 模块，简称 CJS。</li></ul><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作：</p><ul><li>方式一：文件以 <code>.mjs</code> 结尾，表示使用的是ES Module；</li><li>方式二：在package.json中配置字段 <code>type: module</code>，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。<ul><li>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。</li></ul></li><li>如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</li></ul><p>在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告：</p><img src="/images/webmodule/lstwarning.jpg" alt="图片" style="zoom:80%;" /><p>Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p>总结为一句话：</p><ul><li><code>.mjs</code>文件总是以 ES6 模块加载</li><li><code>.cjs</code>文件总是以 CommonJS 模块加载</li><li><code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</li></ul><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><h3 id="5-2-Node-js包模块的入口文件设置"><a href="#5-2-Node-js包模块的入口文件设置" class="headerlink" title="5.2 Node.js包模块的入口文件设置"></a>5.2 Node.js包模块的入口文件设置</h3><h4 id="5-2-1-package-json-的-main-字段"><a href="#5-2-1-package-json-的-main-字段" class="headerlink" title="5.2.1 package.json 的 main 字段"></a>5.2.1 package.json 的 main 字段</h4><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p><h5 id="举例：指定入口文件，格式为ESM"><a href="#举例：指定入口文件，格式为ESM" class="headerlink" title="举例：指定入口文件，格式为ESM"></a>举例：指定入口文件，格式为ESM</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><h4 id="5-2-2-package-json-的-exports-字段"><a href="#5-2-2-package-json-的-exports-字段" class="headerlink" title="5.2.2 package.json 的 exports 字段"></a>5.2.2 package.json 的 exports 字段</h4><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p><h5 id="1-给脚本或子目录起别名"><a href="#1-给脚本或子目录起别名" class="headerlink" title="1. 给脚本或子目录起别名"></a>1. 给脚本或子目录起别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>,  <span class="comment">//给脚本文件 src/submodule.js 起别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span>，<span class="comment">// 给子目录 ./src/features/ 起别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过别名加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-main-的别名"><a href="#2-main-的别名" class="headerlink" title="2. main 的别名."></a>2. main 的别名<code>.</code></h5><p><code>exports</code>字段的别名如果是<code>.</code> 就代表了是模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><h5 id="3-条件加载"><a href="#3-条件加载" class="headerlink" title="3. 条件加载"></a>3. 条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口）</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法可以简写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Node-js原生模块完全支持ES6-Module"><a href="#5-3-Node-js原生模块完全支持ES6-Module" class="headerlink" title="5.3 Node.js原生模块完全支持ES6 Module"></a>5.3 Node.js原生模块完全支持ES6 Module</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">readFile(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-4-加载路径"><a href="#5-4-加载路径" class="headerlink" title="5.4 加载路径"></a>5.4 加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><h3 id="5-5-内部变量"><a href="#5-5-内部变量" class="headerlink" title="5.5 内部变量"></a>5.5 内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><h2 id="六、循环加载"><a href="#六、循环加载" class="headerlink" title="六、循环加载"></a>六、循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="6-1-CommonJS-模块的循环加载"><a href="#6-1-CommonJS-模块的循环加载" class="headerlink" title="6.1 CommonJS 模块的循环加载"></a>6.1 CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;   <span class="comment">// 先输出一个`done`变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done); <span class="comment">// b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span></span><br><span class="line"><span class="comment"> 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。</span></span><br></pre></td></tr></table></figure><p>我们写一个脚本main.js，验证这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事：</p><ol><li>在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。</li><li><code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行<code>exports.done = true;</code></li></ol><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p><p>另外，<strong>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h3 id="6-2-ES6-模块的循环加载"><a href="#6-2-ES6-模块的循环加载" class="headerlink" title="6.2 ES6 模块的循环加载"></a>6.2 ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的：</p><ul><li>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。</li><li>接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。</li><li>执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</li></ul><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;   <span class="comment">// const foo = () =&gt; &#x27;foo&#x27;; 仍然会执行报错。函数表达式，就不具有提升作用</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为<strong>函数具有提升作用</strong>，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。</p><p>这也意味着，<strong>如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p><h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.counter = counter;</span><br><span class="line"><span class="built_in">exports</span>.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h2 id="七、了解：AMD和CMD规范"><a href="#七、了解：AMD和CMD规范" class="headerlink" title="七、了解：AMD和CMD规范"></a>七、了解：AMD和CMD规范</h2><h3 id="7-1-CommonJS规范缺点"><a href="#7-1-CommonJS规范缺点" class="headerlink" title="7.1. CommonJS规范缺点"></a>7.1. CommonJS规范缺点</h3><p>CommonJS加载模块是同步的：</p><ul><li>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；</li><li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；</li></ul><p>如果将它应用于浏览器呢？</p><ul><li>浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；</li><li>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；</li></ul><p>所以在浏览器中，我们通常不使用CommonJS规范：</p><ul><li>当然在webpack中使用CommonJS是另外一回事；</li><li>因为它会将我们的代码转成浏览器可以直接执行的代码；</li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：</p><ul><li>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；</li><li>AMD和CMD已经使用非常少了，所以这里我们进行简单的演练；</li></ul><h3 id="7-2-AMD规范"><a href="#7-2-AMD规范" class="headerlink" title="7.2. AMD规范"></a>7.2. AMD规范</h3><h4 id="7-2-1-AMD与Require-js"><a href="#7-2-1-AMD与Require-js" class="headerlink" title="7.2.1 AMD与Require.js"></a>7.2.1 AMD与Require.js</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li>AMD是Asynchronous Module Definition（异步模块定义）的缩写；</li><li>它采用的是异步加载模块；</li><li>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；</li></ul><p>我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js；</li></ul><h4 id="7-2-2-Require-js的使用"><a href="#7-2-2-Require-js的使用" class="headerlink" title="7.2.2 Require.js的使用"></a>7.2.2 Require.js的使用</h4><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件； </li></ul><p>第二步：定义HTML的script标签引入require.js和定义入口文件：</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：编写如下目录和代码(<strong>个人习惯</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── require.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      foo: <span class="string">&#x27;./modules/foo&#x27;</span>,</span><br><span class="line">      bar: <span class="string">&#x27;./modules/bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 开始加载执行foo模块的代码</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>modules/bar.js</p><ul><li>如果一个模块不依赖其他，那么直接使用define(function)即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age, </span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>modules/foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-3-CMD规范"><a href="#7-3-CMD规范" class="headerlink" title="7.3 CMD规范"></a>7.3 CMD规范</h3><h4 id="7-3-1-CMD与SeaJS"><a href="#7-3-1-CMD与SeaJS" class="headerlink" title="7.3.1 CMD与SeaJS"></a>7.3.1 CMD与SeaJS</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li>CMD 是Common Module Definition（通用模块定义）的缩写；</li><li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li><li>但是目前CMD使用也非常少了；</li></ul><p>CMD也有自己比较优秀的实现方案：</p><ul><li>SeaJS</li></ul><h4 id="7-3-2-SeaJS的使用"><a href="#7-3-2-SeaJS的使用" class="headerlink" title="7.3.2 SeaJS的使用"></a>7.3.2 SeaJS的使用</h4><h5 id="1-下载SeaJS"><a href="#1-下载SeaJS" class="headerlink" title="1. 下载SeaJS"></a>1. 下载SeaJS</h5><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul><h5 id="2-引入sea-js和启动模块"><a href="#2-引入sea-js和启动模块" class="headerlink" title="2. 引入sea.js和启动模块"></a>2. 引入sea.js和启动模块</h5><ul><li><code>seajs</code>是指定主入口文件的，也称为启动模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!--在调用 seajs 之前，必须先引入 sea.js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./index.js&#x27;</span>);  </span></span><br><span class="line">  /*</span><br><span class="line">   通过 seajs.use() 函数可以启动模块</span><br><span class="line"><span class="javascript">- (<span class="string">&#x27;模块id&#x27;</span> [,callback])加载一个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- ([<span class="string">&#x27;模块1&#x27;</span>, <span class="string">&#x27;模块2&#x27;</span>] [,callback])加载多个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- callback 参数是可选的。格式为：<span class="function"><span class="keyword">function</span>(<span class="params"> 模块对象 </span>)</span>&#123; 业务代码 &#125;;</span></span><br><span class="line"></span><br><span class="line"> - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里</span><br><span class="line"><span class="javascript"> - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 <span class="built_in">window</span>.onload 或者 $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span></span><br><span class="line">   */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-编写如下目录和代码-个人习惯"><a href="#3-编写如下目录和代码-个人习惯" class="headerlink" title="3. 编写如下目录和代码(个人习惯)"></a>3. 编写如下目录和代码(<strong>个人习惯</strong>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── sea.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><h5 id="4-定义模块define"><a href="#4-定义模块define" class="headerlink" title="4. 定义模块define"></a>4. 定义模块define</h5><ul><li>在CMD规范中，一个模块就是一个js文件</li></ul><p>module是一个对象，存储了模块的元信息，具体如下：</p><ul><li><p>module.id——模块的ID。</p></li><li><p>module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。</p></li><li><p>module.exports——与exports指向同一个对象。</p></li><li><p>module.uri</p></li></ul><p>define 是一个全局函数，用来定义模块：<code>define( factory )</code></p><ul><li>对象<code>&#123;&#125;</code>：这种方式，外部会直接获取到该对象</li><li>字符串<code>&quot;&quot;</code>： 同上</li><li>函数：<code>define(function(require, exports, module)&#123; 模块代码 &#125;);</code>  为了减少出错，定义函数的时候直接把这三个参数写上</li></ul><h5 id="5-导出接口exports和module-exports"><a href="#5-导出接口exports和module-exports" class="headerlink" title="5. 导出接口exports和module.exports"></a>5. 导出接口exports和module.exports</h5><ul><li><p>功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口</p></li><li><p>exports 等价于 module.exports。exports能做什么，module.exports就能做什么</p></li><li><p>可以通过多次给exports 挂载属性向外暴露</p></li><li><p>不能直接给 exports 赋值</p></li><li><p>如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可</p></li></ul><h5 id="6-依赖模块require"><a href="#6-依赖模块require" class="headerlink" title="6. 依赖模块require"></a>6. 依赖模块require</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 模块标识/模块id</span></span><br><span class="line"><span class="comment">    - 模块标识就是一个`字符串`，用来`标识模块`</span></span><br><span class="line"><span class="comment">    - 模块标识 可以不包含后缀名.js</span></span><br><span class="line"><span class="comment">    - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径</span></span><br><span class="line"><span class="comment">    - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base）</span></span><br><span class="line"><span class="comment">    - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">requeire(<span class="string">&#x27;模块id&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.用于根据一个模块id加载/依赖该模块</span></span><br><span class="line"><span class="comment"> 2.参数必须是一个字符串</span></span><br><span class="line"><span class="comment"> 3.该方法会得到 要加载的模块中的 module.exports 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>只能在模块环境define中使用，define(factory)的构造方法第一个参数<strong>必须命名为 require</strong></li><li>不要重命名require函数或者在任何作用域中给 require 重新赋值</li><li>在一个模块系统中，<code>require</code> 加载过的模块会被缓存</li><li>默认 <code>require</code> 是同步加载模块的</li></ul><p><strong>require.async</strong></p><p>SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.async(<span class="string">&#x27;/path/to/module/file&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code of callback...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。</p><h5 id="SeaJS高级配置"><a href="#SeaJS高级配置" class="headerlink" title="SeaJS高级配置"></a>SeaJS高级配置</h5><ul><li><strong>alias：别名配置</strong></li><li><strong>paths：路径配置</strong></li><li>vars：变量配置</li><li>map：映射配置</li><li>preload：预加载项</li><li>debug：调试模式</li><li><strong>base：基础路径</strong></li><li>charset：文件编码</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./modules/foo&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>bar.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;lilei&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="https://es6.ruanyifeng.com/#docs/module">Module的语法和加载实现 — 阮一峰</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDAzNzkwNA==&mid=2247484285&idx=1&sn=bc37c00b5c58ff42355b1b01ad9b9c0d&chksm=cfe3f082f8947994b5475d365c4460ac0d4b36d6eec68b5dd7c15fc3a0ef1b88f33b776f3f05&scene=178&cur_album_id=1567316742547226629#rd">彻底掌握前端模块化 — codewhy</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、模块化&quot;&gt;&lt;a href=&quot;#一、模块化&quot; class=&quot;headerlink&quot; title=&quot;一、模块化&quot;&gt;&lt;/a&gt;一、模块化&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是模块化&quot;&gt;&lt;a href=&quot;#1-1-什么是模块化&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Web" scheme="https://tenloy.github.io/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] 最通俗的 React Fiber(时间分片)</title>
    <link href="https://tenloy.github.io/2021/05/27/Fiber.html"/>
    <id>https://tenloy.github.io/2021/05/27/Fiber.html</id>
    <published>2021-05-27T16:51:02.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903975112671239#heading-13">原文链接</a> Fiber 不是一个新的东西，来看一下单处理进程调度</p><h2 id="一、单处理器进程调度"><a href="#一、单处理器进程调度" class="headerlink" title="一、单处理器进程调度"></a>一、单处理器进程调度</h2><img width = "60%" alt="" align=center src="/images/Fiber/16deecc2160c5d19.jpg"/><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS"><code>DOS</code></a> 是一个<code>单任务操作系统</code>， 也称为’单工操作系统‘。这种操作系统同一个时间只允许运行一个程序。 <a href="https://www.zhihu.com/people/s.invalid">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为： ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><h3 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h3><p>现代操作系统都是<strong>多任务操作系统</strong>。进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><ul><li><p>“龙珠”中的分身术，实质上是一个人，只不过是他运动速度太快，看起来就像分身了。这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p></li><li><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p></li></ul><p>所以说<strong>并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a></p><h3 id="1-2-进程调度策略"><a href="#1-2-进程调度策略" class="headerlink" title="1.2 进程调度策略"></a>1.2 进程调度策略</h3><h4 id="1-2-1-先到先得-First-Come-First-Served-FCFS"><a href="#1-2-1-先到先得-First-Come-First-Served-FCFS" class="headerlink" title="1.2.1 先到先得(First-Come-First-Served, FCFS)"></a>1.2.1 先到先得(First-Come-First-Served, FCFS)</h4><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队)。</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程。</p><p>举例：可以用饭堂排队来比喻: 在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被选择。 </p><p>举例：ZF部门办业务: 假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><h4 id="1-2-2-轮转"><a href="#1-2-2-轮转" class="headerlink" title="1.2.2 轮转"></a>1.2.2 轮转</h4><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>。</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><h4 id="1-2-3-最短进程优先-Shortest-Process-Next-SPN"><a href="#1-2-3-最短进程优先-Shortest-Process-Next-SPN" class="headerlink" title="1.2.3 最短进程优先(Shortest Process Next, SPN)"></a>1.2.3 最短进程优先(Shortest Process Next, SPN)</h4><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><h4 id="1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT"><a href="#1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT" class="headerlink" title="1.2.4 最短剩余时间(Shortest Remaining Time, SRT)"></a>1.2.4 最短剩余时间(Shortest Remaining Time, SRT)</h4><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><h4 id="1-2-5-最高响应比优先-HRRN"><a href="#1-2-5-最高响应比优先-HRRN" class="headerlink" title="1.2.5 最高响应比优先(HRRN)"></a>1.2.5 最高响应比优先(HRRN)</h4><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应比 &#x3D; （等待执行时间 + 进程执行时间） &#x2F; 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><h4 id="1-2-6-反馈法"><a href="#1-2-6-反馈法" class="headerlink" title="1.2.6 反馈法"></a>1.2.6 反馈法</h4><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc24dfd080c.png"/><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569">《Linux进程调度策略的发展和演变》</a>。</p><h2 id="二、浏览器JavaScript执行环境"><a href="#二、浏览器JavaScript执行环境" class="headerlink" title="二、浏览器JavaScript执行环境"></a>二、浏览器JavaScript执行环境</h2><p>JavaScript 是<a href="https://juejin.im/post/6844903553795014663">单线程运行</a>的(就像单行道)，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个<code>渲染线程</code>，GUI 渲染和 Javascript执行 两者是互斥的。 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecc35b99001e.jpg"/><p><em>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering">Rendering Performance</a></em></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ol><li>优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>尝试 Worker 多线程</li></ol><p>Vue 选择的是第1种, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2种。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, **在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)**。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc366f124be.png"/><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 1</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p>同步模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc3acaf5689.gif" /><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc385cc0286.gif" /><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源。 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/6844903938894872589#heading-1">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 也提到：<strong>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>。</li></ul><p>这就是为什么React 需要 Fiber 。</p><h2 id="三、何为-Fiber"><a href="#三、何为-Fiber" class="headerlink" title="三、何为 Fiber"></a>三、何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a>。</p><p><strong>其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React Fiber 的思想和协程的概念是契合的: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>浏览器没有抢占的条件, 所以React只能用让出机制?</p><p><strong>答: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/6844903874692661255#heading-7"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc37fdd60d7.png"/><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 … 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>怎么确定有高优先任务要处理，即什么时候让出？</p><p><strong>答: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"><code>requestIdleCallback</code></a> API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback(</span><br><span class="line">  callback: (dealine: IdleDeadline) &#x3D;&gt; void,</span><br><span class="line">  option?: &#123;timeout: number&#125;</span><br><span class="line">  )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IdleDealine &#123;</span><br><span class="line">  didTimeout: boolean &#x2F;&#x2F; 表示任务执行是否超过约定时间</span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp &#x2F;&#x2F; 任务可供执行的剩余时间</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecd81f16c6f2.png"/><p><em>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</em></p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc428fb4c0b.png"/><p><em>图片来源: <a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></em></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc43c710e16.png"/><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><img width = "100%" alt="" align=center src="/images/Fiber/16deecc5839a3974.png"/><p>简单看一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>React 那为什么不使用 Generator？</p><p><strong>答: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘：<strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123;  // 2. 循环取出updateQueue中的任务  while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;    workLoop(deadline);  &#125;  // 3. 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度  if (updateQueue.length &gt; 0) &#123;    requestIdleCallback(performWork);  &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><img width = "65%" alt="" align=center src="/images/Fiber/16deed1711f281b3.png"/><h2 id="四、React-的Fiber改造"><a href="#四、React-的Fiber改造" class="headerlink" title="四、React 的Fiber改造"></a>四、React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><img width = "65%" alt="" align=center src="/images/Fiber/16deecc72bc9a14c.png"/><p><em>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</em></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/6844903861434449933">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解…, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图片来展示这种关系会更直观一些：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc6db5530be.png"/><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack">Wiki</a>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc9a904099b.png"/><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecca7850a24d.png"/><p><em>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</em></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><img width = "85%" alt="" align=center src="/images/Fiber/16deecd830671a70.png"/><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/6844903946016784392">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><strong>协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：<ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><strong>提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)<strong>一次性执行了。</strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:<ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。</p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161">这里</a>有更详细的解释。</p><h3 id="3-Reconcilation"><a href="#3-Reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><strong>副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记). 那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</li><li><strong>替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</li></ul><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宿主节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件节点比对也差不多:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/6844903582622285831">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecce3162b355.png"/><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf3468b00b.png"/><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后了，将所有副作用提交了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;  <span class="keyword">let</span> next = fiber  <span class="keyword">while</span>(next) &#123;    <span class="keyword">if</span> (fiber.effectTag) &#123;      <span class="comment">// 提交，偷一下懒，这里就不展开了      commitWork(fiber)    &#125;    next = fiber.nextEffect  &#125;  // 清理现场  pendingCommit = nextUnitOfWork = topWork = null&#125;</span></span><br></pre></td></tr></table></figure><h2 id="五、中断和恢复"><a href="#五、中断和恢复" class="headerlink" title="五、中断和恢复"></a>五、中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf96dac168.png"/><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd05f86b375.png"/><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd121a8657a.png"/><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd19b1362c0.png"/><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img width = "35%" alt="" align=center src="/images/Fiber/16deecd21336ca41.jpg"/><p><em>同样来自Link Clark 的 Slider</em></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd2d4124b05.png"/><p><em>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode?</a></em></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现：</strong></p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu">anu</a> <a href="https://github.com/RubyLouvre">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre">Fre</a> <a href="https://www.zhihu.com/people/132yse">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy">Luy</a></li><li><a href="https://github.com/pomber/didact">didact</a></li></ul><p><strong>优秀的文章 &amp; 演讲：</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多。如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&q=requestIdleCallback">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/">Scheduling in React</a></li><li><a href="https://juejin.im/post/6844903874692661255">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/6844903608488558599#heading-12">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/6844903582622285831">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/">Accurately measuring layout on the web</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903975112671239#heading-13&quot;&gt;原文链接&lt;/a&gt; Fiber 不是一个新的东西，来看一下单处理进程调度&lt;/p&gt;
&lt;h2 id=&quot;一、单处理器进程调度&quot;&gt;&lt;a href=&quot;#一、单</summary>
      
    
    
    
    <category term="React" scheme="https://tenloy.github.io/categories/React/"/>
    
    
    <category term="Fiber" scheme="https://tenloy.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>[转] 什么是协程</title>
    <link href="https://tenloy.github.io/2021/05/27/Coroutine.html"/>
    <id>https://tenloy.github.io/2021/05/27/Coroutine.html</id>
    <published>2021-05-27T10:42:19.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p><strong>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p><ul><li><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p></li><li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p></li></ul><p><strong>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</strong></p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.<span class="built_in">next</span>()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p><ol><li>首先调用c.next()启动生成器；</li><li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li><li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li><li>produce拿到consumer处理的结果，继续生产下一条消息；</li><li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li></ol><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><p>“子程序就是协程的一种特例。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;
&lt;p&gt;协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。&lt;/p&gt;
&lt;p&gt;子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tenloy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="协程" scheme="https://tenloy.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>工程化、动态化、容器化、组件化</title>
    <link href="https://tenloy.github.io/2021/04/29/Engineering.html"/>
    <id>https://tenloy.github.io/2021/04/29/Engineering.html</id>
    <published>2021-04-29T19:43:56.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工程化"><a href="#一、工程化" class="headerlink" title="一、工程化"></a>一、工程化</h2><h3 id="2-1-几个概念"><a href="#2-1-几个概念" class="headerlink" title="2.1 几个概念"></a>2.1 几个概念</h3><p>工程</p><blockquote><p>泛指某项需要投入巨大人力和物力的工作。</p></blockquote><blockquote><p>工程是科学和数学的某种应用，通过这一应用，使自然界的物质和能源的特性能够通过各种结构、机器、产品、系统和过程，是以 <code>最短的时间</code> 和 <code>最少的人力、物力</code> 做出 <code>高效、可靠</code> 且对人类有用的东西。</p></blockquote><p>软件工程</p><blockquote><p>将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。</p><p>它借鉴传统工程的原则、方法创建软件，以达到提高质量，降低成本的目的。</p></blockquote><p>软件工程是一门指导计算机软件开发和维护的工程学科。是一门交叉性学科(需要用到多种学科的方法支持和指导)，如：</p><ul><li>计算机科学、数学用于构造模型与算法</li><li>工程科学用于制定规范、设计范型、评估成本及确定权衡</li><li>管理科学用于计划、资源、质量、成本等管理</li></ul><h3 id="2-2-工程化"><a href="#2-2-工程化" class="headerlink" title="2.2 工程化"></a>2.2 工程化</h3><p>工程化就是指将软件工程的技术和方法运用在开发中，目的是实现<strong>高效开发(降低难度、有效协同)，降低成本，质量可控</strong>。</p><p>工程化包括环境搭建、开发、测试、构建、部署(发布)等一系列流程：</p><ul><li><strong>环境搭建</strong>：项目创建(脚手架)、框架选型、基础工具(请求库、路由库、基础视图组件等)选型等</li><li><strong>开发</strong>：版本管理(分支、commit、review等)规范、动态化方案、组件化方案等</li><li><strong>构建、部署</strong>：CI/CD(自动化持续集成发布)</li><li><strong>测试</strong>：测试用例，自动化测试</li></ul><p><strong>工程化不是指某个工具，工具化只是实现工程化的方式</strong></p><img src="/images/Engineering/web-engineering.jpg" style="zoom:60%"><h2 id="二、跨平台"><a href="#二、跨平台" class="headerlink" title="二、跨平台"></a>二、跨平台</h2><p>跨平台（英语：cross-platform software、multi-platform software、platform-independent software）泛指编程语言、软件或硬件设备可以在多种操作系统或不同硬件架构的电脑上运作。</p><h2 id="三、动态化"><a href="#三、动态化" class="headerlink" title="三、动态化"></a>三、动态化</h2><h3 id="3-1-什么是动态化？"><a href="#3-1-什么是动态化？" class="headerlink" title="3.1 什么是动态化？"></a>3.1 什么是动态化？</h3><p>移动动态化：移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！</p><h3 id="3-2-移动端动态化方案"><a href="#3-2-移动端动态化方案" class="headerlink" title="3.2 移动端动态化方案"></a>3.2 移动端动态化方案</h3><p>从「支持动态化的程度」、「与原生体验的差异」、「方案集成与功能开发成本的高低」三个维度出发，将市面上的移动端动态化方案分成三个方向（为了节约成本，移动端的动态化方案一般也会<strong>兼顾跨平台</strong>）：</p><img src="/images/Engineering/plans.jpg" style="zoom:80%"><ul><li><p><code>Web增强(Web+)</code>：方向主要基于 WebView 实现，能够进行快速的迭代。不过在性能和稳定性上略差，使用场景有限。</p></li><li><p>GPL  和 DSL 可以看作 <code>Native 增强(Native+)</code> 方向的子方向，Native+ 方向基于 App 内自带的语言解析器，独立于 WebView 实现动态化逻辑的解析、布局和渲染。</p><ul><li><p><code>基于GPL的 Native增强(GPL)</code>：</p><ul><li>这个方向是移动端动态化的热门方向。React Native、Flutter、NativeScript 等等，实现原理各不相同；</li><li>共同的特点是利用了通用编程语言器，可以是系统提供的（如 Javascript），或者是集成到 App 的（如 Dart），再辅以某个布局系统和渲染方案，由于语言是图灵完备的，可以提供完美的动态化解决方案；</li><li>GPL 方案虽然在动态化能力、渲染性能方面效果出色，但 Framework 体积、学习和开发成本等方面却也是相当高。于是产生了基于领域专用语言的解决方案。</li></ul></li><li><p><code>基于DSL的 Native增强(DSL)</code> ：</p><ul><li>此类方案通过采用适合专业场景的的 DSL 解析云端下发的逻辑结构，舍弃一部分动态化灵活性，换取其他方面的优势。</li></ul></li></ul></li></ul><img src="/images/Engineering/plans2.jpg" style="zoom:90%"><h2 id="四、容器化"><a href="#四、容器化" class="headerlink" title="四、容器化"></a>四、容器化</h2><p>伴随着上面的动态化方案诞生，容器化这个词在移动端也频繁的出现。</p><p>容器在不同场景下的含义</p><ul><li><p>字面意思，容器就是指容纳小物品的事物，比如：</p><ul><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ul></li><li><p>代码/数据的运行环境，完成代码的解释/数据的解析。比如(从小到大)：</p><ul><li><p>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</p><p>动态化是整个外卖业务的发展方向。提单页的动态化建立在容器化的基础之上，在完成容器化之后，就具备了动态化的基础。当前提单页的动态化，所指的主要是模块层级的动态化，提单页的各模块展示顺序、展示与否，都可以完全由根据服务端下发的数据决定，各模块可以自由地进行组合、拼装，实现提单页的动态配置。</p></li><li><p>RN。在一定程度上，React Native和NodeJS有异曲同工之妙。它们都是通过扩展JavaScript Engine, 使它具备强大的本地资源和原生接口调用能力，然后结合JavaScript丰富的库和社区和及其稳定的跨平台能力，把javascript的魔力在浏览器之外的地方充分发挥出来。</p><ul><li><p><code>JavaScriptCore</code>负责JS代码解释执行</p></li><li><p><code>ReactJS</code>负责描述和管理<code>VirtualDom</code>，指挥原生组件进行绘制和更新，同时很多计算逻辑也在js里面进行。ReactJS自身是不直接绘制UI的，UI绘制是非常耗时的操作，原生组件最擅长这事情。</p></li><li><p><code>Bridges</code>用来翻译ReactJS的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给<code>ReactJS</code>。</p><p>要在不同的平台实现不同的效果就可以通过定制<code>Bridges</code>来实现</p></li></ul></li><li><p>上面的Docker容器</p></li><li><p>服务器容器</p></li></ul></li></ul><p>容器化是个很大的概念，在移动端中，常见其应用于：</p><ul><li>跨平台</li><li>动态化</li><li>如WebView容器、Weex容器、RN容器、自定义DSL容器等</li></ul><p><strong>跨平台与动态化是功能实现。容器化是一种软件开发方法，其可以实现，但不仅仅只能实现跨平台与动态化等。</strong></p><h2 id="五、模块化和组件化"><a href="#五、模块化和组件化" class="headerlink" title="五、模块化和组件化"></a>五、模块化和组件化</h2><h3 id="5-1-模块化"><a href="#5-1-模块化" class="headerlink" title="5.1 模块化"></a>5.1 模块化</h3><h4 id="5-1-1-什么是模块"><a href="#5-1-1-什么是模块" class="headerlink" title="5.1.1 什么是模块"></a>5.1.1 什么是模块</h4><blockquote><p>模块化编程是一种软件设计技术，它强调将程序的功能分成独立的、可互换的模块，这样每个模块都包含执行所需功能的一个方面所需的一切。—— <a href="https://en.wikipedia.org/wiki/Modular_programming">Modular programming</a></p></blockquote><p>模块：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。</p><ul><li>将一个大的系统模块化之后，每个模块都可以被高度复用。</li><li>但是值得注意的是模块不等于功能，二者的关系大概为：功能 &gt; 模块。一个功能可能包含多个模块。</li></ul><h4 id="5-1-2-横向拆分业务、功能模块"><a href="#5-1-2-横向拆分业务、功能模块" class="headerlink" title="5.1.2 横向拆分业务、功能模块"></a>5.1.2 横向拆分业务、功能模块</h4><img src="/images/Engineering/modular_and_component_summary_1.jpg" style="zoom:80%"><h4 id="5-1-3-纵向拆分技术、架构模块"><a href="#5-1-3-纵向拆分技术、架构模块" class="headerlink" title="5.1.3 纵向拆分技术、架构模块"></a>5.1.3 纵向拆分技术、架构模块</h4><img src="/images/Engineering/modular_and_component_summary_2.jpg" style="zoom:80%"><h3 id="5-2-组件化"><a href="#5-2-组件化" class="headerlink" title="5.2 组件化"></a>5.2 组件化</h3><h4 id="5-2-1-什么是组件？"><a href="#5-2-1-什么是组件？" class="headerlink" title="5.2.1 什么是组件？"></a>5.2.1 什么是组件？</h4><blockquote><p>基于组件的软件工程(CBSE)，也称为基于组件的开发(CBD)，是软件工程的一个分支，它强调对整个给定软件系统中可用的广泛功能的关注分离。它是一种 <strong>基于重用(reuse-based)</strong> 的方法，用来定义、实现松散耦合的独立组件，并将它们组合成系统。—— <a href="https://en.wikipedia.org/wiki/Component-based_software_engineering">Component-based software engineering</a></p><p>定义与模块化很相似，都是主要为了对一个系统做拆分。</p></blockquote><p>组件：通俗点就是组件化就是基于可重用的目的，将一个大的软件系统按照<strong>分离关注点</strong>的形式，拆分成多个独立的组件。</p><ul><li>组件的出现是为了解决全局工程中有很多重复代码的问题，是为了复用，而且划分力度是相对较小的模块。      </li><li>组件化的另一个目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</li></ul><p>组件的特性：</p><ul><li><strong>通过接口访问</strong>：组件通过接口相互通信。 当一个组件向系统的其余部分提供服务时，它采用一个提供的接口，指定其他组件可以使用的服务，以及它们如何使用。这个接口可以看作是组件的签名(signature)——客户端不需要知道组件的内部工作（实现）来使用它。 这个原理导致组件被称为封装。</li><li><strong>可替换的</strong>(<em>substitutable</em>)：组件是可替换的，因此如果后续组件满足初始组件的需求(通过接口表示)，则组件可以替换另一个组件(在设计时或运行时)。因此，可以用更新版本或替代版本替换组件，而不会破坏组件运行的系统。</li><li><strong>可重用性</strong>(<em>Reusability</em>)：可重用性是高质量软件组件的一个重要特征。 程序员应该以许多不同的程序可以重用它们的方式来设计和实现软件组件。</li></ul><h4 id="5-2-2-从界面入手，拆分可视化组件"><a href="#5-2-2-从界面入手，拆分可视化组件" class="headerlink" title="5.2.2 从界面入手，拆分可视化组件"></a>5.2.2 从界面入手，拆分可视化组件</h4><img src="/images/Engineering/modular_and_component_summary_3.jpg" style="zoom:80%"><h4 id="5-2-3-从数据入手，拆分数据加工组件"><a href="#5-2-3-从数据入手，拆分数据加工组件" class="headerlink" title="5.2.3 从数据入手，拆分数据加工组件"></a>5.2.3 从数据入手，拆分数据加工组件</h4><img src="/images/Engineering/modular_and_component_summary_4.jpg" style="zoom:80%"><p>大部分时候，拆分模块、组件都是以清晰的流程、逻辑为基础的，就如上图的过程，当流程清晰后，可以拆分复用的组件也就出来了。</p><h3 id="5-3-插件化"><a href="#5-3-插件化" class="headerlink" title="5.3 插件化"></a>5.3 插件化</h3><p>插件：可以理解为是封装了一层对外调用的接口的组件。</p><p>插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口（这里所说的接口只是概念上的接口，即调用方法及参数等）。而组件是不存在这个相同接口的。</p><p>插件和组件的实质区别就在于：通过统一接口隔绝业务代码对于组件的直接依赖。</p><p>Android中对组件化、插件化有不太一样的定义：</p><ul><li>组件化：开发模式下面module本来就是一个独立app，只是发布模式下变成library。</li><li>插件化：就是不存在发布模式开发模式，每个组件业务就是一个独立apk开发，然后通过主工程app动态加载部署业务组件apk。</li></ul><h3 id="5-4-总结-异同"><a href="#5-4-总结-异同" class="headerlink" title="5.4 总结(异同)"></a>5.4 总结(异同)</h3><h4 id="5-4-1-三者小结"><a href="#5-4-1-三者小结" class="headerlink" title="5.4.1 三者小结"></a>5.4.1 三者小结</h4><p>模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。</p><p>组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。</p><p>插件：近乎组件，有统一接口，可以说是封装了一层对外调用的接口的组件。</p><h4 id="5-4-2-组件和模块的异同"><a href="#5-4-2-组件和模块的异同" class="headerlink" title="5.4.2 组件和模块的异同"></a>5.4.2 组件和模块的异同</h4><p>相同点：</p><ul><li>组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</li></ul><p>区别：</p><ul><li><p>模块化开发是横向分块，组件化开发是纵向分层。(说法都不绝对，一般来讲)</p></li><li><p>模块化强调的是<strong>拆分</strong>，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。</p></li><li><p>组件化则着重于<strong>可重用性</strong>，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。</p></li><li><p>进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。(<strong>并不是说模块就不能被复用！</strong>)</p></li><li><p>一般来讲，模块的体量会大于组件。不过，大的组件也可以称为模块，小的模块也可以称为组件，所以，在我看来组件和模块的划分并没有那么的泾渭分明。随意两者的粒度的大小改变，两者是可以转换的。</p></li></ul><p>这三个概念是经常同时出现在一个项目中的，我们往往对复杂大项目进行模块化划分的时候，也会进行组件化，而且插件化的本质是面向接口编程，对于组件化和模块化都是适用的，可实现随意插拔的灵活和高扩展性，属于项目架构的高端设计。</p><h3 id="5-5-前端与iOS中的组件化"><a href="#5-5-前端与iOS中的组件化" class="headerlink" title="5.5 前端与iOS中的组件化"></a>5.5 前端与iOS中的组件化</h3><p>在前端、iOS、Android中，都会有组件化的说法(Android先不讨论)。不过与上面的组件概念都稍微有所出入。</p><blockquote><p><em>以复用为基础，定义、实现许多松耦合的独立组件（Component），再将组件组合成为系统</em>。</p></blockquote><p>前端中的组件化：</p><ul><li><p>横向划分模块、纵向划分组件</p></li><li><p>前端中的组件 <code>Component </code>可以简单理解为<strong>页面组成部件</strong>：页面组成部件(header、footer、nav、search等)。不是以重用为基础定义组件</p></li><li><p>前端中数据加工一般不称为组件，更倾向于<code>utils</code>。</p></li></ul><p>iOS中的组件化：以蘑菇街的组件化文章图为例：</p><img src="/images/Engineering/mgj-component.jpg" style="zoom:50%"><ul><li><p>大到业务模块，小到视图、数据加工组件，都统称为了组件。可以简单理解为<strong>APP组成部件</strong>。</p></li><li><p>这个叫法在起初接触组件化概念的时候给我造成了很大的困惑。一度怀疑自己的理解狭隘了….，直到看到Bang的文章，找到了同感。</p></li></ul><blockquote><p>首先我觉得”组件”在这里不太合适，因为按我理解组件是指比较小的功能块，这些组件不需要多少组件间通信，没什么依赖，也就不需要做什么其他处理，面向对象就能搞定。而这里提到的是较大粒度的业务功能，我们习惯称为”模块”。为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。 —— <a href="http://blog.cnbang.net/tech/3080/">iOS 组件化方案探索 — Bang’s blog</a></p></blockquote><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li>工程化<ul><li><a href="https://www.mengfansheng.com/2020/01/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li></ul></li><li>动态化<ul><li><a href="https://zhuanlan.zhihu.com/p/64968076">「Morph」知乎移动端动态化方案全览</a></li></ul></li><li>模块化、组件化<ul><li><a href="https://cloud.tencent.com/developer/article/1336167">聊聊工程级别的组件化、插件化 以及 模块化</a></li><li><a href="http://tutuge.me/2016/03/29/modular-and-component-summary/">对组件化与模块化的思考与总结</a></li></ul></li><li>IOS组件化方案<ul><li><a href="https://www.oschina.net/action/GoToLink?url=http://casatwy.com/iOS-Modulization.html">《iOS应用架构谈 组件化方案》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://limboy.me/ios/2016/03/10/mgj-components.html?utm_source=tuicool&utm_medium=referral">《蘑菇街 App 的组件化之路》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://limboy.me/ios/2016/03/14/mgj-components-continued.html">《蘑菇街 App 的组件化之路·续》</a></li><li><a href="https://www.oschina.net/action/GoToLink?url=http://blog.cnbang.net/tech/3080/">《iOS 组件化方案探索》</a> from Bang</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工程化&quot;&gt;&lt;a href=&quot;#一、工程化&quot; class=&quot;headerlink&quot; title=&quot;一、工程化&quot;&gt;&lt;/a&gt;一、工程化&lt;/h2&gt;&lt;h3 id=&quot;2-1-几个概念&quot;&gt;&lt;a href=&quot;#2-1-几个概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="工程化" scheme="https://tenloy.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</title>
    <link href="https://tenloy.github.io/2021/04/29/DSL.html"/>
    <id>https://tenloy.github.io/2021/04/29/DSL.html</id>
    <published>2021-04-29T16:42:44.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://draveness.me/dsl/">谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）</a></p></blockquote><blockquote><p>因为 DSL 以及 DSL 的界定本身就是一个比较模糊的概念，所以难免有与他人观点意见相左的地方，如果有不同的意见，我们可以具体讨论。</p></blockquote><p>这次文章的题目虽然是谈谈 DSL 以及 DSL 的应用，不过文章中主要侧重点仍然是 DSL，会简单介绍 DSL 在 iOS 开发中（CocoaPods）是如何应用的。</p><h2 id="没有银弹？"><a href="#没有银弹？" class="headerlink" title="没有银弹？"></a>没有银弹？</h2><p>1987 年，IBM 大型电脑之父 Fred Brooks 发表了一篇关于软件工程中的论文 [No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering) 文中主要围绕这么一个观点：没有任何一种技术或者方法能使软件工程的生产力在十年之内提高十倍。</p><blockquote><p>There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.</p></blockquote><p>时至今日，我们暂且不谈银弹在软件工程中是否存在（<del>这句话在老板或者项目经理要求加快项目进度时，还是十分好用的</del>），作为一个开发者也不是很关心这种抽象的理论，我们更关心的是开发效率能否有实质的提升。</p><img src="/images/DSL/2016-10-03-silver-bullet.jpg" style="zoom:70%"><p>而今天要介绍的 DSL 就可以真正的提升生产力，减少不必要的工作，在一些领域帮助我们更快的实现需求。</p><h2 id="DSL-是什么？"><a href="#DSL-是什么？" class="headerlink" title="DSL 是什么？"></a>DSL 是什么？</h2><blockquote><p>笔者是在两年以前，在大一的一次分享上听到 DSL 这个词的，但是当时并没有对这个名词有多深的理解与认识，听过也就忘记了，但是最近做的一些开源项目让我重新想起了 DSL，也是这次分享题目的由来。</p></blockquote><p>DSL 其实是 Domain Specific Language 的缩写，中文翻译为<em>领域特定语言</em>（下简称 DSL）；而与 DSL 相对的就是 GPL，这里的 GPL 并不是我们知道的开源许可证，而是 General Purpose Language 的简称，即<em>通用编程语言</em>，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。</p><p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Wikipedia</a> 对于 DSL 的定义还是比较简单的：</p><blockquote><p>A specialized computer language designed for a specific task.</p><p>为了解决某一类任务而专门设计的计算机语言。</p></blockquote><p>与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的<strong>可被计算</strong>的逻辑，同时也是 <a href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a> 的。</p><blockquote><p>在可计算性理论，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟任何图灵机，那么它是图灵完备的。图灵完全(图灵完备)意味着可以计算任何图灵-可计算函数。</p><p>没有任何物理系统可以拥有无限内存；如果忽略有限内存的限制，大多数编程语言在其他方面都是图灵完备的。</p></blockquote><blockquote><p>这一小节中的 DSL 指外部 DSL，下一节中会介绍 <a href="https://draveness.me/dsl/#embedded-dsl%E5%B5%8C%E5%85%A5%E5%BC%8F-dsl">内部 DSL/嵌入式 DSL</a></p></blockquote><p>但是在里所说的 DSL 并不是图灵完备的，它们的<strong>表达能力有限</strong>，只是在特定领域解决特定任务的。</p><blockquote><p>A computer programming language of limited expressiveness focused on a particular domain.</p></blockquote><p>另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，<strong>DSL 通过在表达能力上做的妥协换取在某一领域内的高效</strong>。</p><p>而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限。</p><h3 id="几个栗子"><a href="#几个栗子" class="headerlink" title="几个栗子"></a>几个栗子</h3><p>最常见的 DSL 包括 Regex 以及 HTML &amp; CSS，在这里会对这几个例子进行简单介绍</p><ul><li><p>Regex</p><ul><li><p>正则表达式仅仅指定了字符串的 pattern，其引擎就会根据 pattern 判断当前字符串跟正则表达式是否匹配。</p><img src="/images/DSL/2016-10-03-regex.jpg" style="zoom:70%"></li></ul></li><li><p>SQL</p><ul><li>SQL 语句在使用时也并没有真正的执行，我们输入的 SQL 语句最终还要交给数据库来进行处理，数据库会从 SQL 语句中<strong>读取</strong>有用的信息，然后从数据库中返回使用者期望的结果。</li></ul></li><li><p>HTML &amp; CSS</p><ul><li>HTML 和 CSS 只是对 Web 界面的结构语义和样式进行描述，虽然它们在构建网站时非常重要，但是它们并非是一种编程语言，正相反，我们可以认为 HTML 和 CSS 是在 Web 中的领域特定语言。</li></ul></li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>上面的几个🌰明显的缩小了通用编程语言的概念，但是它们确实在自己领域表现地非常出色，因为这些 DSL 就是根据某一个特定领域的特点塑造的；而通用编程语言相比领域特定语言，在设计时是为了解决更加抽象的问题，而关注点并不只是在某一个领域。</p><p>上面的几个例子有着一些共同的特点：</p><ul><li>没有计算和执行的概念；</li><li>其本身并不需要直接表示计算；</li><li>使用时只需要声明规则、事实以及某些元素之间的层级和关系；</li></ul><p>虽然了解了 DSL 以及 DSL 的一些特性，但是，到目前为止，我们对于如何构建一个 DSL 仍然不是很清楚。</p><h3 id="构建-DSL"><a href="#构建-DSL" class="headerlink" title="构建 DSL"></a>构建 DSL</h3><p>DSL 的构建与编程语言其实比较类似，想想我们在重新实现编程语言时，需要做那些事情；<font color=red>实现编程语言的过程可以简化为定义语法与语义，然后实现编译器或者解释器的过程</font>，而 DSL 的实现与它也非常类似，我们也需要对 DSL 进行语法与语义上的设计。</p><img src="/images/DSL/2016-10-03-compiler.png" style="zoom:70%"><p>总结下来，实现 DSL 总共有这么两个需要完成的工作：</p><ol><li>设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思</li><li>实现 parser，对 DSL 解析，最终通过解释器来执行</li></ol><p>以 HTML 为例，HTML 中所有的元素都是包含在尖括号 <code>&lt;&gt;</code> 中的，尖括号中不同的元素代表了不同的标签，而这些标签会被浏览器<strong>解析</strong>成 DOM 树，再经过一系列的过程调用 Native 的图形 API 进行绘制。</p><img src="/images/DSL/2016-10-03-dom-tree.png" style="zoom:70%"><p>再比如，我们使用下面这种方式对一个模型进行定义，实现一个 ORM 领域的 DSL：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define <span class="symbol">:article</span> <span class="keyword">do</span></span><br><span class="line">  attr <span class="symbol">:name</span></span><br><span class="line">  attr <span class="symbol">:content</span></span><br><span class="line">  attr <span class="symbol">:upvotes</span>, <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  has_many <span class="symbol">:comments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的 DSL 中，使用 <code>define</code> 来定义一个新的模型，使用 <code>attr</code> 来为模型添加属性，使用 <code>has_many</code> 建立数据模型中的一对多关系；我们可以使用 DSL 对这段“字符串”进行解析，然后交给代码生成器来生成代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> content: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> createdAt: <span class="type">Date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">new</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">content</span>: <span class="type">String</span>, <span class="params">createdAt</span>: <span class="type">Date</span>)</span> -&gt; <span class="type">Article</span>?</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建的 DSL 中的元素数量非常少，只有 <code>define</code> <code>attr</code> 以及 <code>has_many</code> 等几个关键字，但是通过这几个关键字就可以完成在模型层需要表达的绝大部分语义。</p><h3 id="设计原则和妥协"><a href="#设计原则和妥协" class="headerlink" title="设计原则和妥协"></a>设计原则和妥协</h3><p>DSL 最大的设计原则就是<strong>简单</strong>，通过简化语言中的元素，降低使用者的负担；无论是 Regex、SQL 还是 HTML 以及 CSS，其说明文档往往只有几页，非常易于学习和掌握。但是，由此带来的问题就是，DSL 中缺乏抽象的概念，比如：模块化、变量以及方法等。</p><blockquote><p>抽象的概念并不是某个领域所关注的问题，就像 Regex 并不需要有模块、变量以及方法等概念。</p></blockquote><p>由于抽象能力的缺乏，在我们的项目规模变得越来越大时，DSL 往往满足不了开发者的需求；我们仍然需要编程语言中的模块化等概念对 DSL 进行补充，以此解决 DSL 并不是真正编程语言的问题。</p><img src="/images/DSL/2016-10-03-css-sass.jpg" style="zoom:70%"><p>在当今的 Web 前端项目中，我们在开发大规模项目时往往不会直接手写 CSS 文件，而是会使用 Sass 或者 Less 为 CSS 带来更强大的抽象能力，比如嵌套规则，变量，混合以及继承等特性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">li</span> &#123; <span class="attribute">display</span>: inline-block; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在使用 DSL 的项目规模逐渐变大时，开发者会通过增加抽象能力的方式，对已有的 DSL 进行拓展；但是这种扩展往往需要重新实现通用编程语言中的特性，所以一般情况下都是比较复杂的。</p><h2 id="Embedded-DSL（嵌入式-DSL）"><a href="#Embedded-DSL（嵌入式-DSL）" class="headerlink" title="Embedded DSL（嵌入式 DSL）"></a>Embedded DSL（嵌入式 DSL）</h2><p>那么，是否有一种其它的方法为 DSL 快速添加抽象能力呢？而这也就是这一小节的主题，嵌入式 DSL。</p><p>在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。</p><p>这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。</p><img src="/images/DSL/2016-10-03-cocoapods.png" style="zoom:70%"><p>CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。</p><p>嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。</p><blockquote><p>我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。</p></blockquote><h3 id="Rails-和-Embedded-DSL"><a href="#Rails-和-Embedded-DSL" class="headerlink" title="Rails 和 Embedded DSL"></a>Rails 和 Embedded DSL</h3><p>最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。</p><img src="/images/DSL/2016-10-03-rails.jpg" style="zoom:70%"><h2 id="Ruby、-DSL-和-iOS"><a href="#Ruby、-DSL-和-iOS" class="headerlink" title="Ruby、 DSL 和 iOS"></a>Ruby、 DSL 和 iOS</h2><p>笔者同时作为 iOS 和 Rails 开发者接触了非常多的 DSL，而在 iOS 开发中最常见的 DSL 就是 CocoaPods 了，而这里我们以 CocoaPods 为例，介绍如何使用 Ruby 创造一个嵌入式 DSL。</p><h3 id="Why-Ruby？"><a href="#Why-Ruby？" class="headerlink" title="Why Ruby？"></a>Why Ruby？</h3><p>看到这里有人可能会问了，为什么使用 Ruby 创造嵌入式 DSL，而不是使用 C、Java、Python 等等语言呢，这里大概有四个原因：</p><ul><li>一切皆对象的特性减少了语言中的元素，不存在基本类型、操作符；</li><li>向 Ruby 方法中传入代码块非常方便；</li><li>作为解释执行的语言，eval 模糊了数据和代码的边界；</li><li>不对代码的格式进行约束，同时一些约定减少了代码中的噪音。</li></ul><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><p>在许多语言，比如 Java 中，数字与其他的基本类型都不是对象，而在 Ruby 中所有的元素，包括基本类型都是对象，同时也不存在运算符的概念，所谓的 <code>1 + 1</code>，其实只是 <code>1.+(1)</code> 的语法糖而已。</p><p>得益于一切皆对象的概念，在 Ruby 中，你可以向任意的对象发送 <code>methods</code> 消息，在运行时自省，所以笔者在每次忘记方法时，都会直接用 <code>methods</code> 来“查阅文档”：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.3.1 :003 &gt;</span> <span class="number">1</span>.methods</span><br><span class="line"> =&gt; [<span class="symbol">:%</span>, <span class="symbol">:&amp;</span>, <span class="symbol">:*</span>, <span class="symbol">:+</span>, <span class="symbol">:-</span>, <span class="symbol">:/</span>, <span class="symbol">:&lt;</span>, <span class="symbol">:&gt;</span>, <span class="symbol">:^</span>, <span class="symbol">:|</span>, <span class="symbol">:~</span>, <span class="symbol">:-@</span>, <span class="symbol">:**</span>, <span class="symbol">:&lt;=&gt;</span>, <span class="symbol">:&lt;&lt;</span>, <span class="symbol">:&gt;&gt;</span>, <span class="symbol">:&lt;=</span>, <span class="symbol">:&gt;=</span>, <span class="symbol">:==</span>, <span class="symbol">:===</span>, <span class="symbol">:[]</span>, <span class="symbol">:inspect</span>, <span class="symbol">:size</span>, <span class="symbol">:succ</span>, <span class="symbol">:to_s</span>, <span class="symbol">:to_f</span>, <span class="symbol">:div</span>, <span class="symbol">:divmod</span>, <span class="symbol">:fdiv</span>, <span class="symbol">:modulo</span>, ...]</span><br></pre></td></tr></table></figure><p>比如在这里向对象 <code>1</code> 调用 <code>methods</code> 就会返回它能响应的所有方法。</p><p>一切皆对象不仅减少了语言中类型的数量，消灭了基本数据类型与对象之间的边界；这一概念同时也简化了组成语言的元素，这样 Ruby 中只有对象和方法，这两个概念，极大降低了这门语言的复杂度：</p><ul><li>使用对象存储状态</li><li>对象之间通过方法通信</li></ul><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>Ruby 对函数式编程范式的支持是通过 block，这里的 block 和 Objective-C 中的 block 有些不同。</p><p>首先 Ruby 中的 block 也是一种对象，即 <code>Proc</code> 类的实例，也就是所有的 block 都是 first-class 的，可以作为参数传递，返回。</p><p>下面的代码演示了两种向 Ruby 方法中传入代码块的方式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span><span class="params">(&amp;<span class="built_in">proc</span>)</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="built_in">proc</span>.call() &#125; <span class="keyword">if</span> <span class="built_in">proc</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twice</span></span></span><br><span class="line"><span class="number">2</span>.times &#123; <span class="keyword">yield</span> &#125; <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>yield</code> 会调用外部传入的 block，<code>block_given?</code> 用于判断当前方法是否传入了 <code>block</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">twice <span class="keyword">do</span></span><br><span class="line">puts <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">twice &#123; puts <span class="string">&quot;hello&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>向 <code>twice</code> 方法传入 block 也非常简单，使用 <code>do</code>、<code>end</code> 或者 <code>&#123;</code>、<code>&#125;</code> 就可以向任何的 Ruby 方法中传入代码块。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>早在几十年前的 Lisp 语言就有了 <code>eval</code> 这个方法，这个方法会将字符串当做代码来执行，也就是说 <code>eval</code> 模糊了代码与数据之间的边界。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval <span class="string">&quot;1 + 2 * 3&quot;</span></span><br><span class="line"> =&gt; <span class="number">7</span></span><br></pre></td></tr></table></figure><p>有了 <code>eval</code> 方法，我们就获得了更加强大的动态能力，在运行时，使用字符串来改变控制流程，执行代码并可以直接利用当前语言的解释器；而不需要去手动解析字符串然后执行代码。</p><h4 id="格式和约定"><a href="#格式和约定" class="headerlink" title="格式和约定"></a>格式和约定</h4><p>编写 Ruby 脚本时并不需要像 Python 一样对代码的格式有着严格的规定，没有对空行、Tab 的要求，完全可以想怎么写就怎么写，这样极大的增加了 DSL 设计的可能性。</p><p>同时，在一般情况下，Ruby 在方法调用时并不需要添加括号：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;Wello World!&quot;</span></span><br><span class="line">puts(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这样减少了 DSL 中的噪音，能够帮助我们更加关心语法以及语义上的设计，降低了使用者出错的可能性。</p><p>最后，Ruby 中存在一种特殊的数据格式 <code>Symbol</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="symbol">:symbol</span>.to_s</span><br><span class="line"> =&gt; <span class="string">&quot;symbol&quot;</span></span><br><span class="line">&gt; <span class="string">&quot;symbol&quot;</span>.to_sym</span><br><span class="line"> =&gt; <span class="symbol">:symbol</span></span><br></pre></td></tr></table></figure><p>Symbol 可以通过 Ruby 中内置的方法与字符串之间无缝转换。那么作为一种字符串的替代品，它的使用也能够降低使用者出错的成本并提升使用体验，我们并不需要去写两边加上引号的字符串，只需要以 <code>:</code> 开头就能创建一个 Symbol 对象。</p><h3 id="Podfile-是什么"><a href="#Podfile-是什么" class="headerlink" title="Podfile 是什么"></a>Podfile 是什么</h3><p>对 Ruby 有了一些了解之后，我们就可以再看一下使用 CocoaPods 的工程中的 Podfile 到底是什么了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>如果不了解 iOS 开发后者没有使用过 CocoaPods，笔者在这里简单介绍一下这个文件中的一些信息。</p><p><code>source</code> 可以看作是存储依赖元信息（包括依赖的对应的 GitHub 地址）的源地址；</p><p><code>target</code> 表示需要添加依赖的工程的名字；</p><p><code>pod</code> 表示依赖，<code>Mantle</code> 为依赖的框架，后面是版本号。</p></blockquote><p>上面是一个使用 Podfile 定义依赖的一个例子，不过 Podfile 对约束的描述其实是这样的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source(<span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&#x27;Demo&#x27;</span>) <span class="keyword">do</span></span><br><span class="line">pod(<span class="string">&#x27;Mantle&#x27;</span>, <span class="string">&#x27;~&gt; 1.5.1&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Podfile 中对于约束的描述，其实都可以看作是代码的简写，在解析时会当做 Ruby 代码来执行。</p><h3 id="简单搞个-Embedded-DSL"><a href="#简单搞个-Embedded-DSL" class="headerlink" title="简单搞个 Embedded DSL"></a>简单搞个 Embedded DSL</h3><p>使用 Ruby 实现嵌入式 DSL 一般需要三个步骤，这里以 CocoaPods 为例进行简单介绍：</p><ul><li>创建一个 Podfile 中“代码”执行的上下文，也就是一些方法；</li><li>读取 Podfile 中的内容到脚本中；</li><li>使用 <code>eval</code> 在上下文中执行 Podfile 中的“代码”；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CocoaPods 对于 DSL 的实现基本上就是我们创建一个 DSL 的过程，定义一系列必要的方法，比如 <code>source</code>、<code>pod</code> 等等，创造一个执行的上下文；然后去读存储 DSL 的文件，并且使用 <code>eval</code> 执行。</p><p><strong>信息的传递一般都是通过参数</strong>来进行的，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span></span><br></pre></td></tr></table></figure><p><code>source</code> 方法的参数就是依赖元信息 <code>Specs</code> 的 Git 地址，在 <code>eval</code> 执行时就会被读取到 CocoaPods 中，然后进行分析。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面是一个非常常见的 Podfile 内容：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&#x27;http://source.git&#x27;</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;Demo&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pod <span class="string">&#x27;AFNetworking&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;SDWebImage&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Masonry&#x27;</span></span><br><span class="line">    pod <span class="string">&quot;Typeset&quot;</span></span><br><span class="line">    pod <span class="string">&#x27;BlocksKit&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;Mantle&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQKeyboardManager&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;IQDropDownTextField&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因为这里的 <code>source</code>、<code>platform</code>、<code>target</code> 以及 <code>pod</code> 都是方法，所以在这里我们需要构建一个包含上述方法的上下文：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval_pod.rb</span></span><br><span class="line"><span class="variable">$hash_value</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用一个全局变量 <code>hash_value</code> 存储 Podfile 中指定的依赖，并且构建了一个 Podfile 解析脚本的骨架；我们先不去完善这些方法的实现细节，先尝试一下读取 Podfile 中的内容并执行 <code>eval</code> 看看会不会有问题。</p><p>在 <code>eval_pod.rb</code> 文件的最下面加入这几行代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content = File.read <span class="string">&#x27;./Podfile&#x27;</span></span><br><span class="line">eval content</span><br><span class="line">p <span class="variable">$hash</span>_value</span><br></pre></td></tr></table></figure><p>这里读取了 Podfile 文件中的内容，并把其中的内容当做字符串执行，最后打印 <code>hash_value</code> 的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br></pre></td></tr></table></figure><p>运行这段 Ruby 代码虽然并没有什么输出，但是并没有报出任何的错误，接下来我们就可以完善这些方法了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">(url)</span></span></span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;source&#x27;</span>] = url</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">(target)</span></span></span><br><span class="line">    targets = <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>]</span><br><span class="line">    targets = [] <span class="keyword">if</span> targets == <span class="literal">nil</span></span><br><span class="line">    targets &lt;&lt; target</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;targets&#x27;</span>] = targets</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">platform</span><span class="params">(platform, version)</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pod</span><span class="params">(pod)</span></span></span><br><span class="line">    pods = <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>]</span><br><span class="line">    pods = [] <span class="keyword">if</span> pods == <span class="literal">nil</span></span><br><span class="line">    pods &lt;&lt; pod</span><br><span class="line">    <span class="variable">$hash_value</span>[<span class="string">&#x27;pods&#x27;</span>] = pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在添加了这些方法的实现之后，再次运行脚本就会得到 Podfile 中的依赖信息了，不过这里的实现非常简单的，很多情况都没有处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby eval_pod.rb</span><br><span class="line">&#123;<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;http://source.git&quot;</span>, <span class="string">&quot;targets&quot;</span>=&gt;[<span class="string">&quot;Demo&quot;</span>], <span class="string">&quot;pods&quot;</span>=&gt;[<span class="string">&quot;AFNetworking&quot;</span>, <span class="string">&quot;SDWebImage&quot;</span>, <span class="string">&quot;Masonry&quot;</span>, <span class="string">&quot;Typeset&quot;</span>, <span class="string">&quot;BlocksKit&quot;</span>, <span class="string">&quot;Mantle&quot;</span>, <span class="string">&quot;IQKeyboardManager&quot;</span>, <span class="string">&quot;IQDropDownTextField&quot;</span>]&#125;</span><br></pre></td></tr></table></figure><p>不过使用 Ruby 构建一个嵌入式 DSL 的过程大概就是这样，使用语言内建的特性来进行创作，创造出一个在使用时看起来并不像代码的 DSL。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>在最后，笔者想说的是，当我们在某一个领域经常需要解决重复性问题时，可以考虑实现一个 DSL 专门用来解决这些类似的问题。</p><p>而使用嵌入式 DSL 来解决这些问题是一个非常好的办法，我们并不需要重新实现解释器，也可以利用宿主语言的抽象能力。</p><p>同时，在嵌入式 DSL 扩展了 DSL 的范畴之后，不要纠结于某些东西到底是框架还是领域特定语言，这些都不重要，重要的是，在遇到了某些问题时，我们能否跳出来，使用文中介绍的方法减轻我们的工作量。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[No Silver Bullet—Essence and Accidents of Software Engineering](No Silver Bullet—Essence and Accidents of Software Engineering)</li><li><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific language</a></li><li><a href="http://martinfowler.com/bliki/DomainSpecificLanguage.html">DomainSpecificLanguage</a></li><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How browsers work</a></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><blockquote><p>GitHub Repo：<a href="https://github.com/draveness/iOS-Source-Code-Analyze">iOS-Source-Code-Analyze</a></p></blockquote><blockquote><p>Source: <a href="https://draveness.me/dsl">https://draveness.me/dsl</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://draveness.me/dsl/&quot;&gt;谈谈 DSL 以及 DSL 的应用（以 CocoaPods 为例）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 DSL 以及 D</summary>
      
    
    
    
    <category term="DSL" scheme="https://tenloy.github.io/categories/DSL/"/>
    
    
    <category term="DSL" scheme="https://tenloy.github.io/tags/DSL/"/>
    
  </entry>
  
  <entry>
    <title>常见的容器概念：Linux容器、Docker容器、服务器容器</title>
    <link href="https://tenloy.github.io/2021/04/26/Containers.html"/>
    <id>https://tenloy.github.io/2021/04/26/Containers.html</id>
    <published>2021-04-26T14:42:44.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>汉语释义：</p><blockquote><p>容器(Container)是一种基础工具。泛指任何可以用于容纳其它物品的工具。</p></blockquote><p>容器的特性：</p><ul><li><p>可以部分或完全封闭。— 隔离性</p></li><li><p>被用于容纳、储存、运输物品。 — 便携性、换到程序的概念就是可移植性</p></li><li><p>物体可以被放置在容器中，而容器则可以保护内容物。— 安全</p></li></ul><h2 id="二、Linux容器与Docker容器"><a href="#二、Linux容器与Docker容器" class="headerlink" title="二、Linux容器与Docker容器"></a>二、Linux容器与Docker容器</h2><h3 id="2-1-诞生背景—环境配置的难题"><a href="#2-1-诞生背景—环境配置的难题" class="headerlink" title="2.1 诞生背景—环境配置的难题"></a>2.1 诞生背景—环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h3 id="2-2-虚拟机"><a href="#2-2-虚拟机" class="headerlink" title="2.2 虚拟机"></a>2.2 虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="2-3-Linux容器"><a href="#2-3-Linux容器" class="headerlink" title="2.3 Linux容器"></a>2.3 Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><ul><li><p>Linux 容器技术能够让您对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。 —  <a href="https://www.redhat.com/zh/topics/containers">Red Hat官网</a></p></li><li><p>容器是包含在任何环境中运行所需的所有元素的软件包。是轻量级应用代码包，还包含了依赖项，例如编程语言运行时的特定版本和运行软件服务所需的库。 —  <a href="https://cloud.google.com/learn/what-are-containers?hl=zh-cn#section-1"> Google Cloud官网</a></p></li><li><p>Linux 容器，又称Linux软件容器，是一种操作系统层虚拟化技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库。</p><p>Linux 容器透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。— <a href="https://zh.wikipedia.org/wiki/LXC">维基百科</a></p></li></ul><p>总之：容器就是代码/应用程序+运行时环境</p><p>LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境。</p><p>容器虚拟化操作系统，可以在任何地方运行，不管目标环境是私有数据中心、公有云，还是开发者的个人笔记本电脑。</p><p>容器也是保障 IT 安全的一个重要组成部分。将安全性内置于容器管道，可以为基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</p><h4 id="2-3-2-优势"><a href="#2-3-2-优势" class="headerlink" title="2.3.2 优势"></a>2.3.2 优势</h4><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><p>LXC的使用：</p><ul><li><p>Proxmox VE: 它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术。</p></li><li><p>Docker：它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境。</p><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></li></ul><h3 id="2-4-Docker容器"><a href="#2-4-Docker容器" class="headerlink" title="2.4 Docker容器"></a>2.4 Docker容器</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></p><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><ul><li>最初实现是基于 LXC</li><li>从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer</li><li>从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。</li></ul><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 6 万 多个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，dotCloud 公司决定改名为 Docker。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><h4 id="2-4-2-用途"><a href="#2-4-2-用途" class="headerlink" title="2.4.2 用途"></a>2.4.2 用途</h4><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h4 id="2-4-3-镜像Image"><a href="#2-4-3-镜像Image" class="headerlink" title="2.4.3 镜像Image"></a>2.4.3 镜像Image</h4><p>镜像Image于Docker容器（本质上还是程序与进程的区别？）</p><h5 id="1-引自Docker网站"><a href="#1-引自Docker网站" class="headerlink" title="1) 引自Docker网站"></a>1) 引自Docker网站</h5><p>镜像/映像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器映像</strong>：包含创建容器所需的所有依赖项和信息的包。 映像包括所有依赖项（例如框架），以及容器运行时使用的部署和执行配置。 通常情况下，映像派生自多个基础映像，这些基础映像是堆叠在一起形成容器文件系统的层。 创建后，映像不可变。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><h5 id="2-引自阮一峰"><a href="#2-引自阮一峰" class="headerlink" title="2) 引自阮一峰"></a>2) 引自阮一峰</h5><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h3 id="2-5-容器与虚拟机的区别"><a href="#2-5-容器与虚拟机的区别" class="headerlink" title="2.5 容器与虚拟机的区别"></a>2.5 容器与虚拟机的区别</h3><p>虚拟机：一种运行在主机操作系统之上，可以访问底层硬件的客机操作系统，例如Linux 或 Windows。</p><p>容器常常被拿来和虚拟机 (VM) 比较。与虚拟机相似，容器也可以让您将应用与库和其他依赖项打包，提供独立环境来运行您的软件服务。</p><p>但是两者的相似性仅此而已，因为容器为开发者和 IT 运营团队提供了更加轻型、具有众多优势的运营单元。</p><ul><li>容器比虚拟机更加轻量化</li><li>容器在操作系统级别进行虚拟化，而虚拟机在硬件级别进行虚拟化</li><li>容器共享操作系统内核，其占用的内存与虚拟机相比微乎其微</li></ul><h3 id="2-6-容器化的优势"><a href="#2-6-容器化的优势" class="headerlink" title="2.6 容器化的优势"></a>2.6 容器化的优势</h3><p>容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。 <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/">参考链接</a></p><p>容器在整个应用程序生命周期工作流中提供以下优点：</p><ul><li><p><strong>责任分离</strong>：容器化使开发者和 IT 运营团队的责任泾渭分明，开发者专注于应用逻辑和依赖项，而 IT 运营团队可以专注于部署和管理，不必为应用细节分心，例如具体的软件版本和配置。</p></li><li><p><strong>工作负载可移植性</strong>：</p><ul><li>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</li><li>容器几乎能在任何地方运行，极大减轻了开发和部署工作量：在 Linux、Windows 和 Mac 操作系统中；在虚拟机或物理服务器上；在开发者的机器或本地数据中心的机器上；当然还有在公有云上。</li><li>就像船只、火车或卡车运输集装箱而不管其内部是什么货物一样。</li></ul></li><li><p><strong>应用隔离/隔离性</strong>：容器会在操作系统级别虚拟化 CPU、内存、存储和网络资源，为开发者提供在逻辑上与其他应用相隔离的操作系统接口，即在共享 OS 上将应用程序彼此隔离开。</p></li><li><p><strong>灵活性</strong>：轻量级。容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。 因此，容器的占用比虚拟机 (VM) 映像小得多。</p><p>每个容器可以运行整个 Web 应用或服务，如下图所示，在一个容器主机上运行多个容器。 在此示例中，Docker 主机是容器主机，而 App1、App2、Svc 1 和 Svc 2 是容器化应用程序或服务。</p></li></ul><img src = '/images/Docker/multiple-containers-single-host.png' width = '50%'><ul><li><p><strong>可伸缩性</strong>：通过为短期任务创建新容器，可以快速扩大。 从应用程序的角度来看，实例化映像（创建容器）类似于实例化 服务或 Web 应用等进程。 </p><p>但出于可靠性考虑，在多个主机服务器上运行同一映像的多个实例时，通常要使每个容器（映像实例）在不同容错域中的不同主机服务器或 VM 中运行。</p></li></ul><h2 id="三、服务器与容器"><a href="#三、服务器与容器" class="headerlink" title="三、服务器与容器"></a>三、服务器与容器</h2><h3 id="3-1-服务器-server"><a href="#3-1-服务器-server" class="headerlink" title="3.1 服务器(server)"></a>3.1 服务器(server)</h3><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li><p>一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</p></li><li><p>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</p></li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h4 id="3-1-1-作为硬件"><a href="#3-1-1-作为硬件" class="headerlink" title="3.1.1 作为硬件"></a>3.1.1 作为硬件</h4><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li></ul><h4 id="3-1-2-作为软件"><a href="#3-1-2-作为软件" class="headerlink" title="3.1.2 作为软件"></a>3.1.2 作为软件</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，常用的包括：</p><ul><li><p>文件服务器(file server)或网络存储设备(network attached storage)</p></li><li><p>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</p></li><li><p>应用程序服务器(application server/AP server)</p><ul><li><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</li><li>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul></li></ul></li><li><p>网页服务器(Web server) </p><ul><li>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</li><li>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。</li><li>如Apache、lighttpd、nginx、微软的IIS等；</li></ul></li><li><p>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</p></li><li><p>邮件服务器(mail server)</p></li><li><p>域名服务器（DNS server）—— 如BIND等</p></li><li><p>代理服务器（proxy server）—— 如Squid cache</p></li><li><p>其他，如Active Directory服务器、Minecraft游戏服务器等</p></li><li><p>补充：WEB应用服务器</p><ul><li><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p></li><li><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p></li></ul></li></ul><img src = '/images/Docker/servers.jpg' width = '70%' align:left style='margin-left:10%'><h3 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h3><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = '/images/Docker/container_server.jpg' width = '50%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = '/images/Docker/containers.jpg' width = '70%' align:left style='margin-left:10%'><h4 id="3-2-1-Servlet容器"><a href="#3-2-1-Servlet容器" class="headerlink" title="3.2.1 Servlet容器"></a>3.2.1 Servlet容器</h4><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h4 id="3-2-2-Java-WEB容器"><a href="#3-2-2-Java-WEB容器" class="headerlink" title="3.2.2 Java WEB容器"></a>3.2.2 Java WEB容器</h4><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h4 id="3-2-3-Java-EE容器"><a href="#3-2-3-Java-EE容器" class="headerlink" title="3.2.3 Java EE容器"></a>3.2.3 Java EE容器</h4><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h3 id="3-3-举例说明容器与服务器的联系"><a href="#3-3-举例说明容器与服务器的联系" class="headerlink" title="3.3 举例说明容器与服务器的联系"></a>3.3 举例说明容器与服务器的联系</h3><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h4 id="3-3-1-Apache、Nginx、IIS"><a href="#3-3-1-Apache、Nginx、IIS" class="headerlink" title="3.3.1 Apache、Nginx、IIS"></a>3.3.1 Apache、Nginx、IIS</h4><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><h4 id="3-3-2-Tomcat及常见的JavaEE应用服务器"><a href="#3-3-2-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="3.3.2 Tomcat及常见的JavaEE应用服务器"></a>3.3.2 Tomcat及常见的JavaEE应用服务器</h4><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h4 id="3-3-3-Nginx-Tomcat的WEB应用服务器-集群"><a href="#3-3-3-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="3.3.3 Nginx + Tomcat的WEB应用服务器(集群)"></a>3.3.3 Nginx + Tomcat的WEB应用服务器(集群)</h4><img src = '/images/Docker/nginx_tomcat.jpg' width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="五、iOS的容器化"><a href="#五、iOS的容器化" class="headerlink" title="五、iOS的容器化"></a>五、iOS的容器化</h2><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>容器在不同场景下的含义</p><ol><li><p>字面意思，容器就是指容纳小物品的事物，比如：</p><ol><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ol></li><li><p>代码/数据的运行环境，完成代码的解释/数据解析。比如：</p><ol><li><p>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</p></li><li><p>上面的Docker容器</p></li><li><p>服务器容器</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、容器&quot;&gt;&lt;a href=&quot;#一、容器&quot; class=&quot;headerlink&quot; title=&quot;一、容器&quot;&gt;&lt;/a&gt;一、容器&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] Docker入门教程</title>
    <link href="https://tenloy.github.io/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html"/>
    <id>https://tenloy.github.io/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html</id>
    <published>2021-04-24T15:10:28.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">原文链接 — 《Docker 入门教程》</a></p><p>2013年发布至今， <a href="https://www.docker.com/">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p><p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p><img src='/images/Docker/docker_logo.png' width = '60%'><h2 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h2 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h2 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h2><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h2><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><blockquote><ul><li><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li></ul></blockquote><p>安装完成后，运行下面的命令，验证是否安装成功。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure></blockquote><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></blockquote><p>Docker 是服务器—-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、image-文件"><a href="#六、image-文件" class="headerlink" title="六、image 文件"></a>六、image 文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="七、实例：hello-world"><a href="#七、实例：hello-world" class="headerlink" title="七、实例：hello world"></a>七、实例：hello world</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/">hello world”</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、容器文件"><a href="#八、容器文件" class="headerlink" title="八、容器文件"></a>八、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="九、Dockerfile-文件"><a href="#九、Dockerfile-文件" class="headerlink" title="九、Dockerfile 文件"></a>九、Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="十、实例：制作自己的-Docker-容器"><a href="#十、实例：制作自己的-Docker-容器" class="headerlink" title="十、实例：制作自己的 Docker 容器"></a>十、实例：制作自己的 Docker 容器</h2><p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-1-编写-Dockerfile-文件"><a href="#10-1-编写-Dockerfile-文件" class="headerlink" title="10.1 编写 Dockerfile 文件"></a>10.1 编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="10-2-创建-image-文件"><a href="#10-2-创建-image-文件" class="headerlink" title="10.2 创建 image 文件"></a>10.2 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-3-生成容器"><a href="#10-3-生成容器" class="headerlink" title="10.3 生成容器"></a>10.3 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-4-CMD-命令"><a href="#10-4-CMD-命令" class="headerlink" title="10.4 CMD 命令"></a>10.4 CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></blockquote><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-5-发布-image-文件"><a href="#10-5-发布-image-文件" class="headerlink" title="10.5 发布 image 文件"></a>10.5 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></blockquote><p>最后，发布 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></blockquote><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="十一、其他有用的命令"><a href="#十一、其他有用的命令" class="headerlink" title="十一、其他有用的命令"></a>十一、其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot;&gt;原文链接 — 《Docker 入门教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2013年发布至今， &lt;a href=&quot;https://www.do</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Docker" scheme="https://tenloy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>同步和异步解读及编程中的使用场景</title>
    <link href="https://tenloy.github.io/2021/04/20/Sync-Async.html"/>
    <id>https://tenloy.github.io/2021/04/20/Sync-Async.html</id>
    <published>2021-04-20T20:05:13.000Z</published>
    <updated>2021-09-09T02:40:14.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、同步"><a href="#一、同步" class="headerlink" title="一、同步"></a>一、同步</h2><blockquote><p>协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/约束关系(这个关系分很多种：可以是两者 <code>同时</code>做指定的事、也可以是两者 <code>先后</code>做指定的事等)。</p></blockquote><p>比如：</p><ul><li>音画同步、动作同步等。指某人/事 <code>同时</code>产生，同时进行。</li><li>云同步等。在时间上保持一致性与统一化的现象。</li><li>同步。两部分任务之间按照 <code>先后</code>顺序进行。<ul><li>线程同步：一者暂停(在时域中是一个横线)，等另一者执行完成，再继续</li></ul></li></ul><p>注意：</p><blockquote><p>简单来说：同步就是一段时间内，规定<code>同一时间标准的每一刻</code>（注解1），每个模块(设备/部件/线程)分别应该完成什么(变化)，且各模块的<code>变化之间有一定的相对/约束关系</code>(注解2)</p></blockquote><ol><li><code>当两个设备需要有同步关系的时候，需要在两个设备之间规定一个共同的时间参考(时钟)。</code>即由同宽同距(同频同相)的时钟信号控制每个设备(部件/线程)，分别完成相应的操作</li><li>这两(多)个量的变化之间 <code>可能</code>没有联系，突出的是这两(多)个量<code>一段时间段内随时间的变化过程之间的对应关系</code>。比如上述第一个例子中两者的变化没有联系，而第二个例子中是一者的变化引起另一者的变化</li></ol><h2 id="二、异步"><a href="#二、异步" class="headerlink" title="二、异步"></a>二、异步</h2><blockquote><p>与同步概念相反，两(多)者在随时间变化过程中没有相对/约束关系</p></blockquote><p>比如：</p><ul><li>异步：多线程异步、进程异步</li><li>异步传输：一种通讯方式，对设备需求简单，异步双方不需要共同的时钟。</li></ul><h2 id="三、编程中的使用"><a href="#三、编程中的使用" class="headerlink" title="三、编程中的使用"></a>三、编程中的使用</h2><p>在操作系统中：同步执行的代码的执行过程有顺序性。而并发带来的异步性，每个进(线)程的代码都以其相对独立的不可预知的速度向前推进。</p><p>在计算机中，同步异步常见的两处使用场景：</p><ul><li>线程同步、异步</li><li>同步通信、异步通信(指的是计算机内部件之间的通信)</li><li>同步传输、异步传输(指的是计算机网络中的数据传输，原理基本上与上相同，增加了一些内容，详见下文)</li></ul><h3 id="3-1-线程同步、异步"><a href="#3-1-线程同步、异步" class="headerlink" title="3.1 线程同步、异步"></a>3.1 线程同步、异步</h3><h4 id="3-1-1-同步"><a href="#3-1-1-同步" class="headerlink" title="3.1.1 同步"></a>3.1.1 同步</h4><p>线程之间存在一定的约束关系，在执行过程中，存在一定的<code>前后顺序</code>。可能是出于临界资源的占用，也可能是等待另一条线程执行结果的返回等原因，需要执行完前一个，才能再执行下一个，<code>需要等待、协调运行</code></p><h4 id="3-1-1-异步"><a href="#3-1-1-异步" class="headerlink" title="3.1.1 异步"></a>3.1.1 异步</h4><p>紧贴上面的概念，异步可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><p><code>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是我们实现异步的一种手段</code>。异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p><h3 id="3-2-同步通信、异步通信"><a href="#3-2-同步通信、异步通信" class="headerlink" title="3.2 同步通信、异步通信"></a>3.2 同步通信、异步通信</h3><p>总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合，通常用4种方式：同步通信、异步通信、半同步通信、分离式通信。</p><ul><li><p>同步通信中通信双方由统一时标控制数据传送。即双方按统一的传输周期进行信息传输，双方按约定好的时序进行联络，在规定的时钟周期内分别完成相应的操作。</p></li><li><p>异步通信中没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式(又称握手方式)，即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。</p></li><li><p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型。不互锁方式通信双方没有相互制约关系；半互锁方式通信双方有简单的制约关系；全互锁方式通信双方有完全的制约关系。其中全互锁通信可靠性最高；</p></li></ul><p>详见总线通信控制 ——《计组》</p><h3 id="3-3-同步、异步传输"><a href="#3-3-同步、异步传输" class="headerlink" title="3.3 同步、异步传输"></a>3.3 同步、异步传输</h3><p>在网络通信过程中，通信双方要交换数据，需要高度的协同工作。为了正确的解释信号，接收方必须确切地知道信号应当何时接收和处理，因此定时是至关重要的。</p><p>在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。</p><p>通常可以采用同步或异步的传输方式对位进行同步处理。</p><p>首先是两者的不同</p><table><thead><tr><th></th><th>同步传输</th><th>异步传输</th></tr></thead><tbody><tr><td><code>同步</code></td><td><code>外同步</code></td><td><code>自同步</code>（见底部总结）</td></tr><tr><td>传输格式</td><td>面向 <code>比特</code>的传输，每个信息帧中包含若干个字符( <code>单位是帧</code>)</td><td>面向 <code>字符</code>的传输，每个字符帧只包含一个字符( <code>单位是字符</code>)</td></tr><tr><td>时钟</td><td>要求接收时钟和发送时钟同频同相，通过特定的时钟线路协调时序</td><td>不要求接收时钟和发送时钟完全同步，对时序的要求较低</td></tr><tr><td>数据流</td><td>发送端发送<code>连续</code>的比特流</td><td>发送端发送完一个字节后，可经过任意长的时间间隔再发送</td></tr></tbody></table><p>是否拥有同一个时钟序列进行工作，或者是以数据块为单位进行数据传输，是同步传输和异步传输之间的差别；</p><p>同步效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高，硬件更复杂。</p><h4 id="3-3-1-位同步"><a href="#3-3-1-位同步" class="headerlink" title="3.3.1 位同步"></a>3.3.1 位同步</h4><p>要求接收端根据发送端发送数据的起止时间和时钟频率，来校正自己的时间基准和时钟频率，这个过程叫位同步。可见，位同步的目的是使接收端接收的每一位信息都与发送端保持同步。</p><img src = '/images/OS/bit_sync.png' width = '80%'><h4 id="3-3-2-同步通信"><a href="#3-3-2-同步通信" class="headerlink" title="3.3.2 同步通信"></a>3.3.2 同步通信</h4><p>同步通信是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，当接收端确认接收到同步字符后，发收双方建立同步，此后便在 <code>同步时钟的控制下</code>逐位发送/接收。</p><p>同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息，<code>由同步字符、数据字符和校验字符（CRC）组成。(见上图)</code></p><ul><li>同步字符：位于帧的开头，用于确认数据字符的开始；</li><li>数据字符：在同步字符之后，个数没有限制，由所需传输的数据块长度来决定；</li><li>校验字符：有1到2个，用于接收端对接收到的字符序列进行正确性的校验</li></ul><p>同步这种方式中因为分组相比异步大得多，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p><p>随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。</p><p>另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p><blockquote><p>“同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地发送和接收连续的同步比特流。但这时还有两种不同的同步方式。一种是使用全网同步，用一个非常精确的主时钟对全网所有结点上的时钟进行同步。另一种是使用准同步，各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输。</p></blockquote><h4 id="3-3-3-异步通信"><a href="#3-3-3-异步通信" class="headerlink" title="3.3.3 异步通信"></a>3.3.3 异步通信</h4><blockquote><p>异步通信指两个互不同步的设备通过计时机制或其他技术进行数据传输。异步通信中两个字符之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。基本上，发送方可以随时传输数据，而接收方必须在信息到达时准备好接收。</p></blockquote><p>这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。</p><p>异步通信，是以字符或者字节为单位组成字符帧进行传输。<code>字符帧格式中包括空闲位、起始位、资料位、奇偶校验位、停止位。(见上图)</code></p><p>以RS232协议规定为例，异步通信一个字符一个字符地传输，每个字符一位一位地传输，并且传输一个字符时：</p><ul><li>总是以“起始位”开始（低电平，逻辑值0），以“停止位”结束，字符之间没有固定的时间间隔要求。</li><li>字符数据本身由5~8位数据位组成，接着字符后面是一位校验位（也可以没有校验位）</li><li>最后是一位或一位半或二位停止位</li><li>停止位后面是不定长的空闲位(处于逻辑“1”状态，表示当前线路上没有资料传送)。</li><li>停止位和空闲位都规定为高电平（逻辑值１），这样就保证起始位开始处一定有一个下跳沿。</li></ul><p>异步通信是按字符传输的，接收设备在收到起始信号之后只要在一个字符的传输时间内能和发送设备保持同步就能正确接收。下一个字符起始位的到来又使同步重新校准(<code>依靠检测起始位来实现发送与接收方的时钟 自同步的</code>)。这样，只要发送端和接收端协商好字符帧格式和波特率，就可以由各自的时钟来控制数据的发送和接收。</p><p>举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式</p><p>用于异步通信的连接在OSI(开放系统互连)参考模型的物理层中被定义。</p><blockquote><p>“异步通信”是一种很常用的通信方式。</p><p>异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。</p></blockquote><p>异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。</p><p>异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为 <code>帧定界</code>。</p><p>帧定界还包含确定帧的结束位置，这有两种方法：</p><ul><li>一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束</li><li>在帧首部中设有帧长度的字段</li></ul><p>需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。</p><h4 id="3-3-4-总结"><a href="#3-3-4-总结" class="headerlink" title="3.3.4 总结"></a>3.3.4 总结</h4><h5 id="1-异步通信方式的特点"><a href="#1-异步通信方式的特点" class="headerlink" title="1.异步通信方式的特点"></a>1.异步通信方式的特点</h5><p>异步通信是按字符传输的。每传输一个字符就用起始位来进行收、发双方的同步。不会因收发双方的时钟频率的小的偏差导致错误。</p><p>这种传输方式利用每一帧的起、止信号来建立发送与接收之间的同步。特点是：<code>每帧内部各位均采用固定的时间间隔，而帧与帧之间的间隔时随即的</code>。接收机完全靠每一帧的起始位和停止位来识别字符时正在进行传输还是传输结束。</p><p>（使用串口USART中的串行异步通信是一个代表）</p><h5 id="2-同步通信方式的特点"><a href="#2-同步通信方式的特点" class="headerlink" title="2.同步通信方式的特点"></a>2.同步通信方式的特点</h5><p>进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。</p><p>优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。</p><p>（SPI总线是一个典型代表）</p><h5 id="3-对比："><a href="#3-对比：" class="headerlink" title="3.对比："></a>3.对比：</h5><p>可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是 <code>自同步</code>，后者是 <code>外同步</code>。同时，同步要求收发两端对时间的精确度要求很高，异步没有同步要求那么高。</p><p>自同步、外同步：</p><ul><li>同步传输：是发送端的发送、接收端的接收是同步的，在统一的时钟信号下进行，发一位，接一位。同步传输的数据格式是一种外同步方式所采用的数据格式。对这种方式，在发送的一帧数据中不包含同步字符。同步信号SYNC通过专门的控制线加到串行的接口上。当SYNC一到达，表明数据部分开始，接口就连续接收数据和CRC校验码。    </li><li>异步传输：发送端的发送、接收端的接收不用时钟同步。发送端发一个字符，接收端等接收到之后按字符的始、止位来实现自同步，处理一个字符。</li></ul><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h5><p>在大量使用异步与同步传输的大型机/终端环境中</p><ul><li>异步传输用于传输来自用户周期性按键的终端的字符。接收系统知道等待下一次按键，即使这会花费较多的时间。</li><li>相反，同步传输用作定期传输大量信息的大型系统之间的数据链路。协议为在公用电话系统上利用慢速链路而进行了优化，因此无关位将从传输中删除，并且时钟用于隔开字符。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、同步&quot;&gt;&lt;a href=&quot;#一、同步&quot; class=&quot;headerlink&quot; title=&quot;一、同步&quot;&gt;&lt;/a&gt;一、同步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tenloy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="多线程" scheme="https://tenloy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
