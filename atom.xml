<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-12-03T08:23:35.437Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转] 位运算实现加、减、乘、除运算</title>
    <link href="https://tenloy.github.io/2021/11/22/bit-calculation.html"/>
    <id>https://tenloy.github.io/2021/11/22/bit-calculation.html</id>
    <published>2021-11-22T16:35:03.000Z</published>
    <updated>2021-12-03T08:23:35.437Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原理的理解。</p><p>今天就来看看怎么不使用显式“ + - * /”运算符来实现加减乘除运算。</p><p>下面我们一个一个来看。</p><h2 id="一、加法运算"><a href="#一、加法运算" class="headerlink" title="一、加法运算"></a>一、加法运算</h2><h3 id="1-1-十进制-举例"><a href="#1-1-十进制-举例" class="headerlink" title="1.1 十进制 举例"></a>1.1 十进制 举例</h3><p>先来个我们最熟悉的十进制的加法运算：</p><blockquote><p>13 + 9 = 22</p></blockquote><p>我们像这样来拆分这个运算过程：分别对各位数进行相加</p><ol><li><p>不考虑进位(要进位的值丢弃)：结果为sum：个位数3加上9为2；十位数1加上0为1； 最终结果为12；</p></li><li><p>只考虑进位(只保留进位的值)，结果为carry： 3 + 9 有进位，进位的值为10；</p></li><li><p>如果步骤2所得进位结果carry不为0。那么把步骤1所得sum、步骤2所得carry当成操作数重复步骤1、 2、3；</p><p>如果carry为0则结束，最终结果为步骤1所得sum：</p><p>这里即是对sum = 12 和carry = 10重复以上三个步骤：</p><p>a. 不考虑进位，分别对各位数进行相加:sum = 22; </p><p>b. 只考虑进位: 上一步没有进位，所以carry = 0； </p><p>c. 步骤2carry = 0，结束，结果为sum = 22.</p></li></ol><h3 id="1-2-二进制-举例"><a href="#1-2-二进制-举例" class="headerlink" title="1.2 二进制 举例"></a>1.2 二进制 举例</h3><p>我们发现这三板斧行得通！那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。</p><p>13的二进制为0000 1101，9的二进制为0000 1001:</p><ol><li><p>不考虑进位：分别对各位数进行相加：sum = 0000 1101 + 0000 1001 = 0000 0100</p></li><li><p>只考虑进位： 有两处进位，第0位和第3位，只考虑进位的结果为：carry = 0001 0010</p></li><li><p>步骤2 carry == 0 ?，不为0，重复步骤1 、2 、3；本例中，</p><p> a. 不考虑进位sum = 0001 0110;</p><p> b. 只考虑进位carry  = 0;</p><p> c. carry == 0？为0，结束，结果为sum = 0001 0110。转换成十进制刚好是22.</p></li></ol><h3 id="1-3-结论"><a href="#1-3-结论" class="headerlink" title="1.3 结论"></a>1.3 结论</h3><p>我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，其实：</p><ul><li>第一步不考虑进位的加法其实就是<font color=red>异或运算</font>；</li><li>第二步只考虑进位就是<font color=red>与运算并左移一位</font>；</li><li>第三步就是<strong>重复前面两步操作直到第二步进位结果为0</strong>。</li></ul><p>这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0011</span>, b = <span class="number">1001</span>;</span><br><span class="line">start;</span><br><span class="line"></span><br><span class="line">first loop;</span><br><span class="line"> <span class="number">1.1</span> sum = <span class="number">1010</span></span><br><span class="line"> <span class="number">1.2</span> carry = <span class="number">0010</span></span><br><span class="line"> <span class="number">1.3</span> carry != <span class="number">0</span> , go on;</span><br><span class="line"></span><br><span class="line">second loop;</span><br><span class="line"> <span class="number">2.1</span> sum = <span class="number">1000</span>;</span><br><span class="line"> <span class="number">2.2</span> carry = <span class="number">0100</span>;</span><br><span class="line"> <span class="number">2.3</span> carry != <span class="number">0</span>, go on;</span><br><span class="line"></span><br><span class="line">third loop;</span><br><span class="line"> <span class="number">3.1</span> sum = <span class="number">1100</span>;</span><br><span class="line"> <span class="number">3.2</span> carry = <span class="number">0000</span>;</span><br><span class="line"> <span class="number">3.3</span> carry == <span class="number">0</span>, stop; result = sum;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。</p><h3 id="1-4-代码"><a href="#1-4-代码" class="headerlink" title="1.4 代码"></a>1.4 代码</h3><p>有了上面的分析，我们不难写出如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">add</span>(sum, carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = sum;</span><br><span class="line">        <span class="built_in">int</span> b = carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！</p><h2 id="二、减法运算"><a href="#二、减法运算" class="headerlink" title="二、减法运算"></a>二、减法运算</h2><p>我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把减法运算11 - 6变形为加法运算11 + (-6)，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。</p><p>怎么实现呢？</p><p>刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。</p><p>+8在计算机中表示为二进制的1000，那-8怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实计算机是通过2的补码来表示负数的，那什么是2的补码（同补码，英文是2’s complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：</p><ul><li>第一步，每一个二进制位都取相反值，0变成1，1变成0（即反码）。</li><li>第二步，将上一步得到的值（反码）加1。</li></ul><p>简单来说就是取反加一！</p><p>关于补码更详细的内容可参<a href="https://link.jianshu.com/?t=!https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">维基百科-补码</a>，这里不再赘述。</p><p>其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。</p><p>以上，我们很容易写出了位运算做减法运算的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* num1: 减数</span></span><br><span class="line"><span class="comment">* num2: 被减数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">substract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> subtractor = <span class="keyword">add</span>(~num2, <span class="number">1</span>);<span class="comment">// 先求减数的补码（取反加一）</span></span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">add</span>(num1, subtractor); <span class="comment">// add()即上述加法运算　　</span></span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、乘法运算"><a href="#三、乘法运算" class="headerlink" title="三、乘法运算"></a>三、乘法运算</h2><p>我们知道了加法运算的位运算实现，那很容易想到乘法运算可以转换成加法运算，被乘数加上乘数倍的自己不就行了么。这里还有一个问题，就是乘数和被乘数的正负号问题，我们这样处理，先处理乘数和被乘数的绝对值的乘积，然后根据它们的符号确定最终结果的符号即可。步骤如下：</p><blockquote><p>(1) 计算绝对值得乘积<br> (2) 确定乘积符号（同号为证，异号为负）</p></blockquote><p>有了这个思路，代码就不难写了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a: 被乘数</span></span><br><span class="line"><span class="comment">* b: 乘数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 取绝对值　　    </span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a;    </span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;<span class="comment">// 如果为负则取反加一得其补码，即正数　　    </span></span><br><span class="line">    <span class="comment">// 计算绝对值的乘积　　    </span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(count &lt; multiplier) &#123;        </span><br><span class="line">        product = <span class="keyword">add</span>(product, multiplicand);        </span><br><span class="line">        count = <span class="keyword">add</span>(count, <span class="number">1</span>);<span class="comment">// 这里可别用count++，都说了这里是位运算实现加法　　    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定乘积的符号　　    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;<span class="comment">// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        </span></span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的思路在步骤上没有问题，但是第一步对绝对值作乘积运算我们是通过不断累加的方式来求乘积的，这在乘数比较小的情况下还是可以接受的，但在乘数比较大的时候，累加的次数也会增多，这样的效率不是最高的。我们可以思考，如何优化求绝对值的乘积这一步。</p><p>考虑我们现实生活中手动求乘积的过程，这种方式同样适用于二进制，下面我以13*14为例，向大家演示如何用手动计算的方式求乘数和被乘数绝对值的乘积。</p><img src="/images/bit-cal/01.png" alt="01" style="zoom:95%;" /><p>从上图的计算过程可以看出，如果乘数当前位为1，则取被乘数左移一位的结果加到最终结果中；如果当前位为0，则取0加到乘积中（加0也就是什么也不做）；</p><p>整理成算法步骤：</p><blockquote><p>(1) 判断乘数是否为0，为0跳转至步骤(4)</p><p>(2) 将乘数与1作与运算，确定末尾位为1还是为0，如果为1，则相加数为当前被乘数；如果为0，则相加数为0；将相加数加到最终结果中；</p><p>(3) 被乘数左移一位，乘数右移一位；回到步骤(1)</p><p>(4) 确定符号位，输出结果；</p></blockquote><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;　　</span><br><span class="line">    <span class="comment">//将乘数和被乘数都取绝对值　</span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a; 　　</span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;　　</span><br><span class="line">    　</span><br><span class="line">    <span class="comment">//计算绝对值的乘积　　</span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;　　</span><br><span class="line">    <span class="keyword">while</span>(multiplier &gt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span>((multiplier &amp; <span class="number">0x1</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">// 每次考察乘数的最后一位　　　　</span></span><br><span class="line">            product = <span class="keyword">add</span>(product, multiplicand);　　　　</span><br><span class="line">        &#125; 　　　　</span><br><span class="line">        multiplicand = multiplicand &lt;&lt; <span class="number">1</span>;<span class="comment">// 每运算一次，被乘数要左移一位　　　　</span></span><br><span class="line">        multiplier = multiplier &gt;&gt; <span class="number">1</span>;<span class="comment">// 每运算一次，乘数要右移一位（可对照上图理解）　　</span></span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="comment">//计算乘积的符号　　</span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);　　</span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，第二种求乘积的方式明显要优于第一种。</p><h2 id="四、除法运算"><a href="#四、除法运算" class="headerlink" title="四、除法运算"></a>四、除法运算</h2><p>除法运算很容易想到可以转换成减法运算，即不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。这里需要注意的是符号的确定，商的符号和乘法运算中乘积的符号确定一样，即取决于除数和被除数，同号为证，异号为负；余数的符号和被除数一样。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a : 被除数</span></span><br><span class="line"><span class="comment">* b : 除数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="comment">// 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span></span><br><span class="line">    <span class="keyword">while</span>(dividend &gt;= divisor)&#123;<span class="comment">// 直到商小于被除数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span>);        </span><br><span class="line">        dividend = substract(dividend, divisor);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;<span class="comment">// 如果除数和被除数异号，则商为负数  </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有和简单版乘法运算一样的问题，如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？</p><p>上面的代码之所以比较慢是因为步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？</p><p>计算机是一个二元的世界，所有的int型数据都可以用[2^0, 2^1, … , 2^31]这样一组基来表示（int型最高31位）。不难想到用除数的2^31, 2^30, … , 2^2, 2^1, 2^0 倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。</p><p>2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide_v2</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span> &#123;   </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//比较dividend是否大于divisor的(1&lt;&lt;i)次方，不要将dividend与(divisor&lt;&lt;i)比较，而是用(dividend&gt;&gt;i)与divisor比较，</span></span><br><span class="line">        <span class="comment">//效果一样，但是可以避免因(divisor&lt;&lt;i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       </span></span><br><span class="line">        <span class="keyword">if</span>((dividend &gt;&gt; i) &gt;= divisor) &#123;            </span><br><span class="line">            quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span> &lt;&lt; i);            </span><br><span class="line">            dividend = substract(dividend, divisor &lt;&lt; i);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果除数和被除数异号，则商为负数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Git的使用总结</title>
    <link href="https://tenloy.github.io/2021/11/10/git-use.html"/>
    <id>https://tenloy.github.io/2021/11/10/git-use.html</id>
    <published>2021-11-10T11:06:05.000Z</published>
    <updated>2021-12-03T08:23:35.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来交换修改。</li><li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。两个人的电脑之间可以相互推送修改。不过， 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li><li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB。(Microsoft的Word格式是二进制格式)。</li><li>文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</li></ul><h2 id="二、Git的安装"><a href="#二、Git的安装" class="headerlink" title="二、Git的安装"></a>二、Git的安装</h2><p>首先，试着输入<code>git</code>，看看系统有没有安装Git。</p><p>Mac OS X上安装Git：</p><h3 id="2-1-通过homebrew安装"><a href="#2-1-通过homebrew安装" class="headerlink" title="2.1 通过homebrew安装"></a>2.1 通过homebrew安装</h3><blockquote><p>引用官方的一句话：Homebrew是Mac OS 不可或缺的套件管理器。 </p><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p></blockquote><p>安装homebrew，然后通过homebrew安装Git。</p><h3 id="2-2-通过Command-Line-Tools安装"><a href="#2-2-通过Command-Line-Tools安装" class="headerlink" title="2.2 通过Command Line Tools安装"></a>2.2 通过Command Line Tools安装</h3><p>安装Xcode IDE附带的命令行工具—Command Line Tools(需要自己安装 <code>xcode-select--install</code> )</p><blockquote><p>Command Line Tools就是一个小型独立包，为mac终端用户提供了许多常用的命令行工具（实用程序、编译器等）。包括svn，git，make，GCC，clang，perl，size，strip，strings，libtool，cpp，what以及其他很多能够在Linux默认安装中找到的有用的命令。</p><p>安装目录： /Library/Developer/CommandLineTools/</p></blockquote><h2 id="三、Git的配置"><a href="#三、Git的配置" class="headerlink" title="三、Git的配置"></a>三、Git的配置</h2><h3 id="3-1-配置远程仓库"><a href="#3-1-配置远程仓库" class="headerlink" title="3.1 配置远程仓库"></a>3.1 配置远程仓库</h3><p>常见的本地、远程仓库几种模式：</p><ul><li><p>从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p></li><li><p>在GitHub上，可以任意Fork开源仓库(点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone)</p><ul><li>自己拥有Fork后的仓库的读写权限； </li><li>可以推送pull request给官方仓库来贡献代码( 当然，对方是否接受你的pull request就不一定了 )。</li></ul></li><li><p>将已存在的文件夹，变成 Git 仓库，并创建关联的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 本地文件夹名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把这个目录变成Git可以管理的仓库 ，会多一个.git的目录，是Git来跟踪管理版本库的，如非必要不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 </span></span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后，远程库的名字一般就是origin，这是Git默认的叫法，也可以改成别的，只不过origin这个名字一看就知道是远程库。</span></span><br><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url(ssh/https)&gt; </span><br><span class="line"><span class="comment"># 一个本地仓库是可以关联多个远程库的，多次执行上面命令即可，但不能重名</span></span><br><span class="line"><span class="comment"># 查看远程库信息（如果没有推送权限，就不会看到push的地址）</span></span><br><span class="line">git remote [-v/--verbose]</span><br><span class="line"><span class="comment"># 删除已有的远程库</span></span><br><span class="line">git remote rm &lt;remoteName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的master分支内容推送的远程新的master分支，并建立本地master与远程仓库的master分支的关联，详见git push命令</span></span><br><span class="line">git push -u &lt;remote-name&gt; master </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-配置忽略文件"><a href="#3-2-配置忽略文件" class="headerlink" title="3.2 配置忽略文件"></a>3.2 配置忽略文件</h3><h4 id="3-2-1-全局与局部忽略"><a href="#3-2-1-全局与局部忽略" class="headerlink" title="3.2.1 全局与局部忽略"></a>3.2.1 全局与局部忽略</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦。</p><p>此时，可以把要忽略的文件名填入忽略文件，Git就会自动忽略这些文件。可以定义忽略是全局的，还是局限于一个仓库。</p><ul><li>全局忽略文件：<code>/User/用户名/.gitignore_global</code> ;</li><li>仓库忽略文件：Git工作区的根目录下有一个特殊的 <code>.gitignore</code> 文件。</li></ul><h4 id="3-2-2-忽略文件的编写"><a href="#3-2-2-忽略文件的编写" class="headerlink" title="3.2.2 忽略文件的编写"></a>3.2.2 忽略文件的编写</h4><p>忽略文件的格式：</p><ul><li><p>注释格式同shell脚本： #注释；</p></li><li><p>忽略精确的文件名：文件名；</p></li><li><p>忽略所有此扩展名的文件：如 *.pbxuser 表示要忽略后缀名为.pbxuser的文件；</p></li><li><p>忽略文件夹下面的一切：如 build/ 表示要忽略 build 文件夹下的所有内容；</p></li><li><p><code>*</code> 表示通配符：如 fastlane/screenshots/<code>**/*.png</code>；</p></li><li><p><code>!</code> 表示取反：如 *.pbxuser 表示忽略所有后缀名为.pbxuser的文件，如果加上!default.pbxuser则表示，除了default.pbxuse忽略其它后缀名为pbxuse的文件。</p></li></ul><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件，比如IDE的一些个人偏好设置。</li></ul><p>不需要从头写.gitignore文件，<a href="https://github.com/github/gitignore">github/gitignore </a> 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。</p><p>如 iOS 项目忽略文件的几项配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## User settings</span></span><br><span class="line">xcuserdata/</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)</span></span><br><span class="line">*.xcscmblueprint</span><br><span class="line">*.xccheckout</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)</span></span><br><span class="line">build/</span><br><span class="line">DerivedData/</span><br><span class="line"></span><br><span class="line"><span class="comment">## App packaging</span></span><br><span class="line">*.ipa</span><br><span class="line">*.dSYM.zip</span><br><span class="line">*.dSYM</span><br></pre></td></tr></table></figure><h4 id="3-2-3-忽略文件的检查"><a href="#3-2-3-忽略文件的检查" class="headerlink" title="3.2.3 忽略文件的检查"></a>3.2.3 忽略文件的检查</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：The following paths are ignored by one of your .gitignore files，可以使用<code>git add -f &lt;file&gt;</code>强制添加。</p><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore -v &lt;file&gt;</code>命令检查， Git会告诉我们，.gitignore的第几行规则忽略了该文件。</p><h3 id="3-3-git-config配置"><a href="#3-3-git-config配置" class="headerlink" title="3.3 git config配置"></a>3.3 git config配置</h3><h4 id="3-3-1-三种优先级的配置"><a href="#3-3-1-三种优先级的配置" class="headerlink" title="3.3.1 三种优先级的配置"></a>3.3.1 三种优先级的配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config [--global | --system] &lt;oo&gt;.&lt;kk&gt; &lt;vv&gt;</span><br><span class="line"><span class="comment"># 如配置用户信息    git config user.name/email xx</span></span><br><span class="line"><span class="comment"># 如配置编辑器      git config core.editor emacs</span></span><br><span class="line"><span class="comment"># 如配置别名       git config alias.st status</span></span><br><span class="line"><span class="comment"># 如配置输出的着色  git config color.ui false</span></span><br></pre></td></tr></table></figure><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： </p><ul><li><code>/etc/gitconfig</code>：包含系统上每一个用户及他们仓库的通用配置，使用带有 <code>--system</code> 选项的git config时，会从此文件读写配置变量；</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。 </li><li>仓库目录下 <code>/.git/config</code>：只针对该仓库，在仓库中使用带有 <code>--local(默认)</code> 选项的git config时，会读写该文件；<br>在优先级方面，从上往下依次上升。</li></ul><p>git config 的配置项有很多，详细可以看 <a href="https://github.com/git/git/tree/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config">git文档</a>。下面只是列出常见的几种。</p><h4 id="3-3-2-配置用户信息"><a href="#3-3-2-配置用户信息" class="headerlink" title="3.3.2 配置用户信息"></a>3.3.2 配置用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面已经说过，用了--global参数表示这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</span></span><br><span class="line">git config --global user.name “Your Name”</span><br><span class="line">git config --global user.email “email@example.com”</span><br></pre></td></tr></table></figure><p>用户名和邮箱地址的作用：</p><ul><li><p>每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改；</p></li><li><p>github 的 contributions 统计就是按邮箱来统计的。</p></li><li><p>注意：<strong>name、email是不用作git权限校验的，只为commit时做记录，随便怎么改都行</strong>。</p><p>亲证：误操作，用了一个全局配置的git name/email(公司的)用户名和邮箱，成功推送到了我的私人仓库</p></li></ul><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h4 id="3-3-3-配置文本编辑器"><a href="#3-3-3-配置文本编辑器" class="headerlink" title="3.3.3 配置文本编辑器"></a>3.3.3 配置文本编辑器</h4><p>当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</p></blockquote><h4 id="3-3-4-配置Git别名"><a href="#3-3-4-配置Git别名" class="headerlink" title="3.3.4 配置Git别名"></a>3.3.4 配置Git别名</h4><p>别名可以使你的 Git 体验更简单、容易、熟悉。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout </span><br><span class="line">git config --global alias.ci commit </span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span>  <span class="comment">#使用git last查看最后一次提交</span></span><br></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-配置权限校验缓存"><a href="#3-3-5-配置权限校验缓存" class="headerlink" title="3.3.5 配置权限校验缓存"></a>3.3.5 配置权限校验缓存</h4><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>了解更多关于不同验证缓存的可用选项，查看 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</p><h4 id="3-3-6-配置Git的着色"><a href="#3-3-6-配置Git的着色" class="headerlink" title="3.3.6 配置Git的着色"></a>3.3.6 配置Git的着色</h4><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。</p><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.diff.meta <span class="string">&quot;blue black bold&quot;</span></span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="3-3-7-查看配置信息"><a href="#3-3-7-查看配置信息" class="headerlink" title="3.3.7 查看配置信息"></a>3.3.7 查看配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h2 id="四、服务器上的Git"><a href="#四、服务器上的Git" class="headerlink" title="四、服务器上的Git"></a>四、服务器上的Git</h2><h3 id="4-1-Git-的四种传输协议"><a href="#4-1-Git-的四种传输协议" class="headerlink" title="4.1 Git 的四种传输协议"></a>4.1 Git 的四种传输协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="4-1-1-哑协议与智能协议之分"><a href="#4-1-1-哑协议与智能协议之分" class="headerlink" title="4.1.1 哑协议与智能协议之分"></a>4.1.1 哑协议与智能协议之分</h4><p><a href="https://www.progit.cn/#_%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">原文链接</a> Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><blockquote><p>现在已经很少使用哑协议了。 使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。 一般情况下都建议使用智能协议。</p></blockquote><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><ul><li>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</li><li>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</li></ul><h4 id="4-1-2-本地协议"><a href="#4-1-2-本地协议" class="headerlink" title="4.1.2 本地协议"></a>4.1.2 本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /opt/git/project.git</span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><h4 id="4-1-3-SSH-协议"><a href="#4-1-3-SSH-协议" class="headerlink" title="4.1.3 SSH 协议"></a>4.1.3 SSH 协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@server/project.git</span></span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> user@server:project.git</span></span><br></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><h5 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h5><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="4-1-4-Git-协议"><a href="#4-1-4-Git-协议" class="headerlink" title="4.1.4 Git 协议"></a>4.1.4 Git 协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h4 id="4-1-5-HTTP-协议"><a href="#4-1-5-HTTP-协议" class="headerlink" title="4.1.5 HTTP 协议"></a>4.1.5 HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h5 id="1-智能（Smart）-HTTP-协议"><a href="#1-智能（Smart）-HTTP-协议" class="headerlink" title="1. 智能（Smart） HTTP 协议"></a>1. 智能（Smart） HTTP 协议</h5><p><a href="https://www.progit.cn/#_smart_http">Smart HTTP</a>：我们一般通过 SSH 进行授权访问，通过 git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>)，和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h5 id="2-哑（Dumb）-HTTP-协议"><a href="#2-哑（Dumb）-HTTP-协议" class="headerlink" title="2. 哑（Dumb） HTTP 协议"></a>2. 哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://www.progit.cn/#_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><h5 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h5><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><h5 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h5><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h3 id="4-2-搭建Git服务器"><a href="#4-2-搭建Git服务器" class="headerlink" title="4.2 搭建Git服务器"></a>4.2 搭建Git服务器</h3><p>搭建Git服务器非常简单，通常10分钟即可完成； </p><ul><li><p>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>； </p></li><li><p>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite">Gitolite</a>。</p></li></ul><p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器</a></p><h3 id="4-3-error：hung-up-unexpectedly"><a href="#4-3-error：hung-up-unexpectedly" class="headerlink" title="4.3 error：hung up unexpectedly"></a>4.3 error：hung up unexpectedly</h3><p>使用场景：clone、push的时候报错<code>The remote end hung up unexpectedly</code>时</p><ul><li>git <code>config http.postBuffer 524288000 </code>(stackOverFlow上有人说好像对SSH协议报这个错时也有效)</li><li>也可能是：接口不通(Git默认端口22，可能运维改了)，或者网络不好</li><li>可以试试，具体还是以<code>“error: ...信息”</code>为准（ 如果改了postBuffer，问题解决之后，建议改回去 ）</li></ul><p>我当时因为传输了大量大文件，修改了http.postBuffer没用；</p><p>还有说修改http.lowSpeedLimit=0、http.lowSpeedTime=999999；设置允许的最低速度，最低速度时间(没试，我是SSH协议push的！）</p><p>修改了SSH的重连ServerAliveInterval=30、ServerAliveCountMax=5没用；</p><p>后来无奈，只能分批次上传。</p><h4 id="4-3-1-配置http-postBuffer"><a href="#4-3-1-配置http-postBuffer" class="headerlink" title="4.3.1 配置http.postBuffer"></a>4.3.1 配置http.postBuffer</h4><blockquote><p><a href="https://github.com/git/git/blob/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config/http.txt#L195-L209">官方链接</a></p><p>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally.  Default is 1 MiB, which is sufficient for most requests.</p><p>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard.  Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</p></blockquote><p>个人认为：这个参数是用来设置HTTP传输发送buffer池的大小(池子满了，或者数据已写入完毕就发送)</p><ul><li>客户端、服务端会根据这个参数来申请内存当做buffer池(所以如果太大了，会消耗内存，而且如果块太大，并不是所有的服务器系统都能正常接收处理的)</li><li>客户端推送的大小如果超过这个可能会失败(至于说是本地发送失败，还是因为服务端根据这个设置的接收buffer池大小，结果接收到的数据太大，缓冲区溢出造成的失败就不清楚了)</li><li>服务端应答的大小如果超过这个会分块传输</li><li>仅对禁用分块传输编码有效（因此仅在远程服务器或代理仅支持HTTP/1.0或不符合HTTP标准的情况下才应使用），意思是分块传输编码时，有自己的分块传输(块多大)策略，而且优先级更高</li></ul><p>服务端程序在接收客户端表单提交的数据时，需要先将数据存储到一个内存空间，然后做解析等后续工作，这个内存空间一般称之为接收缓冲区。对于post数据因为有Content-Length标记，服务端可以按标记的长度创建一个等于或稍大于提交数据的缓冲区；对于get，因为事先不知道提交的数据有多少，需要估计缓冲区长度，如果缓冲区很大而接收数据很小会造成内存浪费，而如果缓冲区小于接收数据，就可能造成缓冲区溢出。</p><p>“聪明的”黑客，会在溢出部分放置特殊的代码来攻陷你的服务器。<a href="https://www.cnblogs.com/meilibao/archive/2012/10/29/2744525.html">博客</a></p><h4 id="4-3-2-补充：Transfer-Encoding-chunked"><a href="#4-3-2-补充：Transfer-Encoding-chunked" class="headerlink" title="4.3.2 补充：Transfer-Encoding:chunked"></a>4.3.2 补充：Transfer-Encoding:chunked</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">维基百科</a></p><p>表示输出的内容长度不能确定， 通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度， 先把整个要输出的数据写到一个很大的字节数组里(如 ByteArrayOutputStream)，然后得到数组大小 -&gt; Content-Length。 </p><p>如果结合Transfer-Encoding: chunked使用，就不必申请一个很大的字节数组了，可以一块一块的输出，更科学，占用资源更少。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。</p><h2 id="五、Git的两种鉴权方式"><a href="#五、Git的两种鉴权方式" class="headerlink" title="五、Git的两种鉴权方式"></a>五、Git的两种鉴权方式</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是：</p><ul><li><p>前者采用账号密码进行校验；</p></li><li><p>后者采用SSH秘钥对进行校验。</p></li></ul><h3 id="5-1-SSH"><a href="#5-1-SSH" class="headerlink" title="5.1 SSH"></a>5.1 SSH</h3><p><a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">GitHub官网配置步骤指导</a></p><p>只要选择正确的密钥，本地的私钥加密，对应的远程仓库账号中事先添加的公钥能解开就能提交成功。</p><p>生成公钥时，需要指定GitHub的邮箱地址，配置在GitHub中的公钥串中也包含邮箱，GitHub是校验的这个邮箱账号。</p><h4 id="5-1-1-ssh-agent"><a href="#5-1-1-ssh-agent" class="headerlink" title="5.1.1 ssh-agent"></a>5.1.1 ssh-agent</h4><p>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。参考链接：<a href="https://www.zsythink.net/archives/2407">了解ssh代理：ssh-agent</a>。</p><p>个人理解： 类似VPN代理软件吧，会拦截我们的请求并针对性地加以处理。还有一点相同的是： 将私钥加入ssh-agent后，即使删除私钥文件，本地计算机仍可以正常访问 GitHub 代码仓库。</p><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p>https 除了速度慢以外，还有个最大的麻烦是每次与远程仓库交互时，都必须输入账号(可以是git用户名，也可以是邮箱地址)、口令进行校验。</p><p>可以记住密码：</p><ul><li><p>Mac中可以存储在keychain中，<strong>在开启Keychain机制的情况下，进行权限校验后会自动将账号密码保存至Keychain Access</strong>。</p></li><li><p>Mac、Windows共用—— git 提供的 credential helper机制：可以将账号密码以 cache 的形式在内存中缓存一段时间（默认 15 分钟），或者以文件的形式存储起来（~/.git-credentials）。</p></li></ul><h3 id="5-3-配置不同账号访问不同仓库"><a href="#5-3-配置不同账号访问不同仓库" class="headerlink" title="5.3 配置不同账号访问不同仓库"></a>5.3 配置不同账号访问不同仓库</h3><p>当一台计算机中需要以不同账号访问不同的仓库时：</p><ul><li>SSH：如果不同的仓库配置了不同的公钥，那么在使用本地私钥时，就要加以区分。(当然也可以所有仓库都使用一套公钥、私钥，理论上私钥只有自己知道)。</li><li>HTTPS：如果不记住账号密码，即每次都输入账号密码，那就不需要配置。<ul><li>如果使用Keychain记住了密码，此时会根据仓库的 host 去 Keychain 中寻找账户密码，因为 Keychain 中针对这个host 存储了多个账号、密码，那找出的可能是错误的，此时就会权限校验失败。此时我们需要处理一下我们的仓库URL。</li></ul></li></ul><h4 id="5-3-1-SSH的处理"><a href="#5-3-1-SSH的处理" class="headerlink" title="5.3.1 SSH的处理"></a>5.3.1 SSH的处理</h4><p>以SSH方式：通过远程仓库的url（clone之后存储在repo/.git/config中）的host </p><ul><li>找到host配置的对应SSH-Key(SSH-Key一般都存在~/.ssh文件夹中)<ul><li>当只有一个SSH账号时，/etc/ssh/ssh_config配置文件，默认直接指向~/.ssh/id_rsa</li><li>当有多个SSH账号时，<del>/.ssh/config配置文件中，分别配置每个host对应的</del>/.ssh中的SSH-Key</li></ul></li><li>通过密钥进行权限校验</li></ul><p>两个文件的影响范围：</p><ul><li><p>/etc/ssh/ssh_config下的配置是针对当前系统所有用户</p></li><li><p>~/.ssh/config(/User/用户名/.ssh/config)只针对当前用户(默认是没有该文件的，只有当有多个用户，需要做映射时，才创建、配置)</p></li></ul><p>如果两个仓库host不相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host github.com <span class="comment"># Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span></span><br><span class="line">Port 22         <span class="comment"># 端口号（如果不是默认22号端口则需要指定） </span></span><br><span class="line">HostName github.com  <span class="comment"># 是代码仓库服务器的主机(此处是github)</span></span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa  <span class="comment"># 指明User对应的identityFile路径，即SSH-Key</span></span><br><span class="line">User loten   <span class="comment"># 登录名（如gitlab的username） </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个同上，如 smartgit</span></span><br></pre></td></tr></table></figure><p>如果两个仓库host也相同，则需要在Host中进行区分，然后经过 <code>CNAME</code> 映射到 <code>HostName</code>（<code>Host相当于是HostName的别名</code>），然后分别指向不同的SSH-key，即IdentityFile，从而实现了对两个 GitHub 账号的分离。（<code>HostName才是真正指定 GitHub 服务器主机的字段</code>）</p><p>在config文件修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debugtalk</span></span><br><span class="line">Host debugtalk</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># DJI</span></span><br><span class="line">Host djileolee</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/dji_id_rsa</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>此处改了还没完，还需要在各个项目中分别进行修改配置：代码提交、拉取时远程仓库的地址。 即<code>repo/.git/config</code>文件：可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将原先的远程仓库的URL  git@github.com:debugtalk/DroidMeter.git中的host改成我们刚设置的host(别名)</span></span><br><span class="line">git remote add origin git@debugtalk:debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure><h4 id="5-3-2-HTTPS的处理"><a href="#5-3-2-HTTPS的处理" class="headerlink" title="5.3.2 HTTPS的处理"></a>5.3.2 HTTPS的处理</h4><p>以HTTPS方式：通过远程仓库的url（clone之后存储在repo/.git/config中）。</p><p>比如：本来的HTTPS URL为 <code>https://github.com/loten/RSAHandle.git</code> 手动改为：<code>https://loten@github.com/loten/RSAHandle.git</code>。</p><p>注意：loten是GitHub的用户名，不能打错。在第一次拉取/推送的时候(钥匙串keychain中还没存储账号、密码)，会要求输入该用户名对应的密码：Password Required For user Roten8 on host github.com. 输入成功后，即可成功拉取/推送。</p><p>配置原理很容易理解，即将 GitHub 用户名添加到仓库的 Git 地址中，这样在执行 git 命令的时候，系统就会采用指定的 GitHub 用户名去<code>Keychain</code> 或 <code>~/.git-credentials</code> 中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p><p>然后可以发现使用这种方式修改之后，可以看到keychain中的存储信息的<code>账号</code>：<code>由邮箱号变为了Git用户名</code>。即不再仅仅通过host来寻找账号密码，而是找到keychain中，这个host下指定的用户名对应的密码，来使用。</p><p>参考链接： <a href="https://ruby-china.org/topics/30298">Git深入浅出 Git 权限校验 (最熟悉的陌生概念)</a></p><h2 id="六、从仓库目录角度了解Git工作原理"><a href="#六、从仓库目录角度了解Git工作原理" class="headerlink" title="六、从仓库目录角度了解Git工作原理"></a>六、从仓库目录角度了解Git工作原理</h2><h3 id="6-1-目录结构"><a href="#6-1-目录结构" class="headerlink" title="6.1 目录结构"></a>6.1 目录结构</h3><img src="/images/git/dir.png" alt="dir" style="zoom:70%;" /><ul><li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间。</li><li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间/工作区/工作目录，除了 .git 之外的都属于工作区。<ul><li>工作目录下的文件有两种状态：已跟踪tracked或未跟踪untracked（新创建的文件，没有被add到暂存区就是untracked状态）</li></ul></li><li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD 会只是当前的开发分支（branch）。</li><li>Stash：是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li></ul><blockquote><p>一个 modification 的提交要经历工作区——add到暂存区(staged)——commit到本地仓库——push到远程仓库</p></blockquote><p>文件的状态改变：</p><img src="/images/git/lifecycle.png" alt="lifecycle" style="zoom:70%;" /><h3 id="6-2-git文件夹-版本库"><a href="#6-2-git文件夹-版本库" class="headerlink" title="6.2 .git文件夹(版本库)"></a>6.2 .git文件夹(版本库)</h3><h4 id="6-2-1-index"><a href="#6-2-1-index" class="headerlink" title="6.2.1 index"></a>6.2.1 index</h4><p>暂存区是Git相比SVN的特色；</p><p>当修改了工作区里的一个文件时，这些修改一开始是<code>unstaged</code>状态，为了提交这些修改，你需要使用<code>git add</code>把它加入到index，使它成为<code>staged</code>状态。当你提交一个commit时，index里面的修改被提交；</p><p>当在工作区新增一个文件，文件是<code>untracked</code>状态，<code>git add &lt;file&gt;</code>添加到index，变为<code>tracked</code>状态。</p><h4 id="6-2-2-objects"><a href="#6-2-2-objects" class="headerlink" title="6.2.2 objects/"></a>6.2.2 objects/</h4><p>该文件夹下存储了所有数据内容。主要有四大对象：数据对象、树对象、提交对象、标签对象。</p><h5 id="1-数据对象-对应-文件"><a href="#1-数据对象-对应-文件" class="headerlink" title="1. 数据对象(对应 文件)"></a>1. 数据对象(对应 文件)</h5><p>Git 是一个内容寻址文件系统，即Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 </p><p>可以通过底层命令hash-object来<strong>演示</strong>上述效果——该命令可将任意数据保存于.git目录，并返回相应的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> | git hash-object -w --stdin</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span><br><span class="line">git hash-object -w test.txt</span><br></pre></td></tr></table></figure><ul><li>-w选项指示hash-object命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。</li><li>–stdin选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 </li><li>该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</li><li>可以在objects目录下看到一个文件， <strong>校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名</strong>。</li></ul><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据，这个命令简直就是一把剖析 Git 对象的瑞士军刀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 打印其内部存储的对象类型（SHA-1 值为目录名+文件名）：输出为：`blob`、`tree`、`commit`</span></span><br><span class="line">git cat-file -t &lt;SHA-1&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 打印对象里的内容  </span></span><br><span class="line">git cat-file -p &lt;SHA-1&gt;  <span class="comment"># -p: Pretty-print 自动判断内容的类型，并为我们显示格式友好的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - blob对象，打印出是可视化的，我们做的修改</span></span><br><span class="line"><span class="comment"># - tree对象，打印出其包含的数据对象和子树对象的SHA-1指针</span></span><br><span class="line"><span class="comment"># - commit对象，打印出：tree对象、parent父提交对象、author(name、email、时间戳)、commiter、留空一行、注释</span></span><br></pre></td></tr></table></figure><p><strong>每当一个文件修改时，就会生成一个数据对象。数据对象的内容是源文件当前的全部内容</strong>(<strong>而非存储的修改内容，保证了每次切换节点时，快速恢复！</strong>)。</p><p>不过， 记住文件的每一个版本所对应的 SHA-1 值并不现实。另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）</p><h5 id="2-树对象-对应-目录"><a href="#2-树对象-对应-目录" class="headerlink" title="2. 树对象(对应 目录)"></a>2. 树对象(对应 目录)</h5><p>树对象（tree object）能解决文件名保存的问题，也允许我们将多个文件组织到一起。 <strong>Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化</strong>：</p><ul><li><p>所有内容均以树对象和数据对象的形式存储，其中<font color='red'>树对象对应了 UNIX 中的目录项</font><strong>，</strong><font color='red'>数据对象则大致上对应了 inodes 或文件内容</font>；</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Inode">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p><strong>一、inode是什么？</strong></p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p><strong>二、inode的内容</strong></p><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li><p>文件的字节数</p></li><li><p>文件拥有者的User ID</p></li><li><p>文件的Group ID</p></li><li><p>文件的读、写、执行权限</p></li><li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li><li><p>链接数，即有多少文件名指向这个inode</p></li><li><p>文件数据block的位置</p></li></ul><p>可以用stat命令，查看某个文件的inode信息：<code>stat example.txt</code></p></blockquote></li><li><p>一个树对象包含了一条或多条树对象记录（tree entry）；</p></li><li><p>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><ul><li>文件模式为 <code>100644</code>，表明这是一个普通文件。 </li><li><code>100755</code>，表示一个可执行文件；</li><li><code>120000</code>，表示一个符号链接。</li><li> 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</li></ul></li></ul><p>通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p><p>可以通过<code>write-tree</code>命令将暂存区内容写入一个树对象。</p><p>例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master^&#123;tree&#125;语法表示 master 分支上最新的提交所指向的树对象</span></span><br><span class="line">git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，lib子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象</span></span><br><span class="line">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件、以及一个目录：</p><img src="/images/git/data-model-1.png" alt="data-model-3" style="zoom:70%;" /><p>下面是个（非常规操作…）举例，你可以将一个旧的树对象加入新的树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><img src="/images/git/data-model-2.png" alt="data-model-3" style="zoom:70%;" /><h5 id="3-提交对象"><a href="#3-提交对象" class="headerlink" title="3. 提交对象"></a>3. 提交对象</h5><p><strong>树对象代表了我们想要跟踪的不同项目快照</strong>。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><ul><li>可以通过调用<code>commit-tree</code>命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</li><li>提交对象的格式很简单：<ul><li>它先指定一个顶层树对象，代表当前项目快照；<strong>这个树对象记录了此刻工作目录所有文件的状态，这也是Git切换快速便捷的原理</strong>。</li><li>然后是作者/提交者信息（依据你的user.name和user.email配置来设定，外加一个时间戳）；</li><li>留空一行，最后是提交注释。(重要的两点：顶层树对象、父提交对象)</li></ul></li><li>提交对象的<strong>SHA-1值即为commit id</strong></li></ul><p><strong>提交对象对应的这个最顶层的树对象就对应了我们的工作目录，下面的每一个tree对象对应我们项目中的文件夹，每一个的blob对象就是此时该文件的最新全部内容</strong>。比如下面是一个大项目的master分支上最新提交对应的树对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob 17eb1b55d91525217c8615813a702207d038eec8.DS_Store</span><br><span class="line">100755 blob 47acf8552d011d70d98b1805a1f2fd00ca060356.gitignore</span><br><span class="line">040000 tree 7b19b9ca1fece9c204770f7ddfa3a362f12dbf2eLLBaseKit</span><br><span class="line">040000 tree 8f826ece85e875c00af345ab4b40c6661a512eb5LLIDCard</span><br><span class="line">040000 tree 3f96965ac93c24a71a4bff9bbfbc587d5889bc92LLLiveDetection</span><br><span class="line">100644 blob a42e52ed334aa15800dca69d256d0e340494551fPodfile</span><br><span class="line">100644 blob f0430fd46587a9c29a5385001adb89c6ae9ef759Podfile.lock</span><br><span class="line">040000 tree 44e5dd79ef5a0435e1f3a0ea112cbaf8b6b48071Pods</span><br><span class="line">040000 tree dd706fe8898be1a2a7ccdfc3fb61115a0aef4b01RTSu.xcodeproj</span><br><span class="line">040000 tree 65ac1588391931d47e65f7fc7c2032f6a738a819RTSu.xcworkspace</span><br><span class="line">040000 tree 221347dd21123109ffa63300c4003de34cfec8f4RTSu</span><br><span class="line">040000 tree bd7d6129ab1bbf677aaaab85f493ed437c976493RTSuJPush</span><br><span class="line">040000 tree 40152f8dc68864e779104a782278ee2bd3dcd9e4RTSuTests</span><br><span class="line">040000 tree b8397ded7e7b5efa1cc83bddc69a93fc2c6cc1c7RTSuUITests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 git cat-file -p 打印上面的树对象，打印出来即是我们的源文件</span></span><br></pre></td></tr></table></figure><h5 id="4-三种对象的关系图"><a href="#4-三种对象的关系图" class="headerlink" title="4. 三种对象的关系图"></a>4. 三种对象的关系图</h5><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><img src="/images/git/data-model-3.png" alt="data-model-3" style="zoom:70%;" /><h5 id="5-对象的存储"><a href="#5-对象的存储" class="headerlink" title="5. 对象的存储"></a>5. 对象的存储</h5><p>Git在存储内容时，会有个头部信息一并被保存</p><ul><li>以对象类型作为开头来构造一个头部信息：比如“blob”字符串，接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）<code>&quot;blob #&#123;content.length&#125;\0&quot;</code></li><li>将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和</li><li>通过 zlib 压缩这条新内容</li><li>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在则创建它。</li><li>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</li></ul><h4 id="6-2-3-refs"><a href="#6-2-3-refs" class="headerlink" title="6.2.3 refs/"></a>6.2.3 refs/</h4><p>存储指向数据（分支）的提交对象的指针；</p><p>GIT引用概述：由于一些地方需要用到SHA-1值，而SHA-1不易记录， 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><ul><li>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；可以在.git/refs目录下找到这类含有 SHA-1 值的文件。(<strong>帮助我们记忆最新提交所在的位置</strong>)；</li><li>这基本就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>， 当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</li></ul><img src="/images/git/data-model-4.png" alt="data-model-4" style="zoom:80%;" /><h5 id="1-heads-—-HEAD引用"><a href="#1-heads-—-HEAD引用" class="headerlink" title="1. heads/ — HEAD引用"></a>1. heads/ — HEAD引用</h5><p>现在的问题是，当你执行<code>git branch (branchname)</code>时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针：</p><ul><li>如果查看 HEAD 文件的内容，一般而言我们看到的类似这样： <code>ref: refs/heads/master(或者当前分支名)</code>；</li><li>当我们执行<code>git commit</code>时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</li></ul><p>/refs/heads/ 记录<code>本地</code>每个分支的提交之首</p><h5 id="2-tags-—-Tag引用"><a href="#2-tags-—-Tag引用" class="headerlink" title="2. tags/ — Tag引用"></a>2. tags/ — Tag引用</h5><p>标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 </p><p>主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><ul><li>轻量标签： 只是一个特定提交的固定引用</li><li>附注标签：Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象</li></ul><p>标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象(比如数据、树对象)打标签</p><h5 id="3-remotes-—-远程引用-remote-reference"><a href="#3-remotes-—-远程引用-remote-reference" class="headerlink" title="3. remotes/ — 远程引用(remote reference)"></a>3. remotes/ — 远程引用(remote reference)</h5><p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下每一个分支最近一次推送操作时所对应的SHA-1值，并保存在refs/remotes目录下(文件名为远程分支名)</p><ul><li>远程引用和分支（位于refs/heads目录下的引用）之间最主要的区别在于，远程引用是只读的（本地仓库的commit可以reset来修改HEAD的指向，但是remote repo的是不能的）</li></ul><p><strong>子文件夹为远程仓库的名称（如果有多个远程仓库(config文件中有多个[remote xxx])就有多个子文件夹），文件夹中的文件名称是远程仓库中执行过推送操作的远程分支名</strong>。</p><h5 id="4-for-—-Gerrit"><a href="#4-for-—-Gerrit" class="headerlink" title="4. for/ — Gerrit"></a>4. for/ — Gerrit</h5><p>如果我们使用的是Gerrit（一种开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件开发者，可以在评审网页上相互审阅彼此修改后的代码，决定是否能够提交，回退或是继续修改。它使用版本控制系统Git作为底层）</p><ul><li>Gerrit为了保证每次代码提交都强制开启代码评审，要求研发人员在提交代码的时候统一使用: git push [remote_name] HEAD:refs/for/[branch_name]，执行后会在评审界面创建一条新的code review，只有通过review之后才可以合入远程仓库。</li><li>此时如果执行<code>git push origin HEAD:refs/head/master</code>，那么就会有“! [remote rejected] master -&gt; master (prohibited by Gerrit)”的错误信息，命令失效。</li><li>对于那些希望将Code Review粒度控制在单次提交级别的研发团队，使用基于Gerrit机制的工具是比较合适的。( <a href="https://cloud.baidu.com/product/xly.html">百度效率云的iCode</a>就是基于Gerrit机制开发的 )</li></ul><img src="/images/git/gerrit.png" alt="gerrit" style="zoom:80%;" /><p>下面一段是对“refs/for”更详细的描述：</p><blockquote><p>The documentation for Gerrit explains that you push to the “magical refs/for/‘branch’ ref using any Git client tool”.</p><p>This image is taken from the Intro to Gerrit. When you push to Gerrit, you do git push gerrit HEAD:refs/for/<code>&lt;BRANCH&gt;</code>. This pushes your changes to the staging area (in the diagram, “Pending Changes”). Gerrit doesn’t actually have a branch called <code>&lt;BRANCH&gt;</code>; it lies to the git client.</p><p>Internally, Gerrit has it’s own implementation for the Git and SSH stacks. This allows it to provide the “magical” refs/for/<code>&lt;BRANCH&gt;</code> refs.</p><p>When a push request is received to create a ref in one of these namespaces Gerrit performs its own logic to update the database, and then lies to the client about the result of the operation. A successful result causes the client to believe that Gerrit has created the ref, but in reality Gerrit hasn’t created the ref at all.  </p><p>After a successful patch (i.e, the patch has been pushed to Gerrit, [putting it into the “Pending Changes” staging area], reviewed, and the review has passed), Gerrit pushes the change from the “Pending Changes” into the “Authoritative Repository”, calculating which branch to push it into based on the magic it did when you pushed to refs/for/<code>&lt;BRANCH&gt;</code>. This way, successfully reviewed patches can be pulled directly from the correct branches of the Authoritative Repository.</p></blockquote><h4 id="6-2-4-HEAD"><a href="#6-2-4-HEAD" class="headerlink" title="6.2.4 HEAD"></a>6.2.4 HEAD</h4><p>指向当前分支的当前提交；</p><h4 id="6-2-5-config"><a href="#6-2-5-config" class="headerlink" title="6.2.5 config"></a>6.2.5 config</h4><p>文件包含项目特有的配置选项，覆盖Git的全局配置</p><h4 id="6-2-6-description"><a href="#6-2-6-description" class="headerlink" title="6.2.6 description"></a>6.2.6 description</h4><p>仅供 GitWeb 程序使用，我们无需关心</p><h4 id="6-2-7-hooks"><a href="#6-2-7-hooks" class="headerlink" title="6.2.7 hooks/"></a>6.2.7 hooks/</h4><p>包含客户端或服务端的钩子脚本（hook scripts）, hook用户操作，拦截一些不合理的行为命令</p><h4 id="6-2-8-info"><a href="#6-2-8-info" class="headerlink" title="6.2.8 info/"></a>6.2.8 info/</h4><p>目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</p><h2 id="七、常用命令"><a href="#七、常用命令" class="headerlink" title="七、常用命令"></a>七、常用命令</h2><h3 id="7-1-提交、撤销与查看"><a href="#7-1-提交、撤销与查看" class="headerlink" title="7.1 提交、撤销与查看"></a>7.1 提交、撤销与查看</h3><h4 id="1-git-checkout-工作区的撤销"><a href="#1-git-checkout-工作区的撤销" class="headerlink" title="1. git checkout  工作区的撤销"></a>1. git checkout  工作区的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销文件在工作区的修改(处于暂存区的修改不受影响)</span></span><br><span class="line">git checkout -- &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果不加<code>--</code>，就变成了“切换到另一个分支”的命令</li><li>untracked的文件修改不受影响</li></ul><h4 id="2-git-add-暂存区的提交"><a href="#2-git-add-暂存区的提交" class="headerlink" title="2. git add 暂存区的提交"></a>2. git add 暂存区的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><p>是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区。</li><li>还能用于合并时把有冲突的文件标记为已解决状态</li></ul><h4 id="3-git-rm-暂存区的提交"><a href="#3-git-rm-暂存区的提交" class="headerlink" title="3. git rm 暂存区的提交"></a>3. git rm 暂存区的提交</h4><p>删除文件，并将这个删除添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt;</span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="4-git-commit-本地仓库的提交"><a href="#4-git-commit-本地仓库的提交" class="headerlink" title="4. git commit 本地仓库的提交"></a>4. git commit 本地仓库的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span></span><br><span class="line">git commit -am(-a -m) <span class="string">&#x27;commit message&#x27;</span> <span class="comment"># 将tracked状态的文件的修改`add+commit`(该命令对未跟踪状态的文件修改不生效)</span></span><br></pre></td></tr></table></figure><p>将暂存区里所有的修改提交到本地仓库的当前分支：</p><ul><li>会显示： file changed(文件修改)、insertions(插入行)、deletions(删除行)</li><li>可以多次add，一次commit</li></ul><p>commit id解释说明： 看到的一串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><h4 id="5-git-reset-暂存区与本地仓库的撤销"><a href="#5-git-reset-暂存区与本地仓库的撤销" class="headerlink" title="5. git reset 暂存区与本地仓库的撤销"></a>5. git reset 暂存区与本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><p>将当前分支的HEAD指向给定的版本，并根据模式的不同决定是否修改index和working tree。</p><ul><li><p>–soft模式</p><ul><li>指定commit id之后的所有commit的修改、目前index中暂存的修改都被保留在index中；</li><li>working tree中还没暂存的修改保持原样。</li></ul></li><li><p>–mixed(默认)</p><ul><li>清空index</li><li>指定commit id之后的所有commit的修改、目前index中暂存的修改、目前working tree中还没暂存的修改都被保留在工作区中</li><li>可以巧用<code>git reset</code>来<strong>撤销添加到暂存区中的修改</strong>(放入了工作区)，即<code>git reset HEAD &lt;file&gt;</code></li></ul></li><li><p>–hard：</p><ul><li>清空index、workingtree，指定commit id之后的所有提交修改也不会保留。</li></ul></li></ul><p>需要注意：</p><ul><li><p>reset是<strong>操作的本地仓库</strong>，所以只能reset那些未push到remote仓库的commit。</p></li><li><p>Git的版本回退速度非常快，因为Git会保存所有修改，而reset实质上是重置本地仓库的HEAD到指定的commit id，即当你回退版本的时候，Git仅仅是在改变HEAD指向。</p></li><li><p>想从3回滚到1，可以使用<code>git log</code>来查看提交日志，获取commit id；比如reset从commit3回滚到1之后，想再回滚回3，仍然可以使用git reset，此时可以使用 <a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">git reflog</a> 查看命令日志，获取3对应的commit id。</p></li><li><p>如果commit已经push到远程仓库，那么origin/HEAD是不受影响的(<code>提交的修改仍保留在远程仓库</code>)，还是指向最新的commit id，此时sourceTree会提示有提交未拉取。</p><p>如果在这个本地仓库的版本上做修改，提交的时候会失败：<code>Updates were rejected because the tip of your current branch is behind its remote counterpart</code>，即告诉你需要先pull再push。</p></li></ul><h4 id="6-git-revert-本地仓库的撤销"><a href="#6-git-revert-本地仓库的撤销" class="headerlink" title="6. git revert 本地仓库的撤销"></a>6. git revert 本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>回滚指定的提交，并产生一条新的commit。</p><p>在指定commit id的时候，除了通过<code>git log</code>、<code>git reflog</code>来查看，还可以指定通过HEAD(大写)来指定，<code>HEAD</code>表示当前分支当前版本， 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="7-git-status"><a href="#7-git-status" class="headerlink" title="7. git status"></a>7. git status</h4><p>查看仓库当前的状态：</p><ul><li>changes to be committed: 将要被提交的修改包括以下</li><li>no changes added to commit：没有被暂存修改要提交</li><li>changes not staged for commit：以下修改没有被暂存</li><li>no thing to commit, working tree clean：没有需要提交的修改，而且工作目录是干净的</li></ul><h4 id="8-git-log"><a href="#8-git-log" class="headerlink" title="8. git log"></a>8. git log</h4><p>显示从最近到最远的提交日志。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p><ul><li>–graph：显示 ASCII 图形表示的分支合并历史</li><li>–abbrev-commit：仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</li><li>–pretty：使用其他格式显示历史提交信息。可用的选项包括 oneline(简写一行)，short，full，fuller 和 format（后跟指定格式）</li><li>-<code>&lt;num&gt;</code>：显示几条</li><li><a href="https://www.progit.cn/#_viewing_history">等等</a></li></ul><p>常用的git log命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --decorate --oneline --simplify-by-decoration --all</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>–decorate 标记会让git log显示每个commit的引用(如:分支、tag等) </li><li>–simplify-by-decoration 只显示被branch或tag引用的commit(如果去掉该参数，分支图与GUI显示的基本一致了)</li><li>–all 表示显示所有的branch，这里也可以选择，比如我指向显示分支ABC的关系，则将–all替换为branchA branchB branchC</li></ul><p>感觉再怎么着也没GUI清晰…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> [branch_name] <span class="comment"># 打印指定分支的提交。如git log dev/3.27.0 --oneline</span></span><br></pre></td></tr></table></figure><h4 id="9-git-reflog"><a href="#9-git-reflog" class="headerlink" title="9. git reflog"></a>9. git reflog</h4><p>显示命令历史，记录每一次命令</p><h4 id="10-git-push"><a href="#10-git-push" class="headerlink" title="10. git push"></a>10. git push</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [-u | --set-upstream] [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;]  [&lt;:远程分支名&gt;] </span><br></pre></td></tr></table></figure><p>将当前分支的修改推送到远程分支，如果没有该远程分支则创建；</p><p>远程分支名可以写为<code>refs/heads/xx</code>或直接写为<code>xx</code>，好像没区别。</p><ul><li>如果只省略<code>&lt;:远程分支&gt;</code>：将指定的本地分支上的修改推送到同名的远程主机分支上；</li><li>如果只省略<code>&lt;本地分支名&gt;</code>：表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 <code>git push origin --delete master</code>。注意：不会影响本地分支；</li><li>如果当前分支是某个远程仓库中某个分支的跟踪分支，且两者同名，git push后省略远程仓库名、本地分支名、远程分支名等一切参数；</li><li>不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式。如果想更改设置，可以使用git config命令。<code>git config --global push.default matching</code> OR <code>git config --global push.default simple</code>；可以使用<code>git config -l </code>查看配置</li><li>Tag对象与Commit对象十分相似，所以上面一些用法，在推送、删除tag对象时同样适用，比如git push origin :tagName 删除远程tag。</li></ul><h4 id="11-冲突处理"><a href="#11-冲突处理" class="headerlink" title="11. 冲突处理"></a>11. 冲突处理</h4><p><strong>执行git push之前，养成git pull的好习惯</strong>，如果有冲突，先处理冲突。</p><p>如果远程分支有别人的提交，而本地没有拉取，git push的时候，会失败</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27; hint: Updates were rejected because the remote contains work that you do not have locally.</span><br></pre></td></tr></table></figure><p>此时，应先拉取，再push，push之后发现，提交分支图上，出现了分叉，这是因为你的commit及远程他人的提交的父提交对象都是同一个commit对象，所以图谱上当然有分叉。且额外创建了一个新的commit：<code> Merge branch ‘&lt;branch&gt;’ of github.com...</code>，如果不想要这种情况可以使用<code>git rebase</code>。</p><h4 id="12-git-rebase"><a href="#12-git-rebase" class="headerlink" title="12. git rebase"></a>12. git rebase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch&gt;  <span class="comment"># 操作当前分支变基</span></span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>将当前分支(分叉)上的一系列提交的基(父提交)改为指定分支的最新提交</li><li>视觉效果：消除了分支、push的时候远程有提交未拉取造成的分叉</li><li>注意：只能变基本地的分支，如果commit已经推到了远程，就不要再在本地操作了，会弄混乱：此时操作之后根据rebase的工作原理，相当于本地分支新增了数个commit，然后远程仓库中的几个老commit因为被本地分支上删除就会被认成是未拉取的commit。可以先删除远程分支，再变基，再推送。</li></ul><img src="/images/git/rebase.png" alt="rebase" style="zoom:80%;" /><p>本质是：</p><ol><li>把当前分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中)</li><li>然后把当前分支的根commit更新为指定分支的最新commit</li><li>最后把保存的这些补丁重新应用到当前分支上</li><li>更新之后，老的commit会丢弃，而&lt;当前分支&gt;引用指向新创建的最新commit</li></ol><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h4 id="13-git-pull"><a href="#13-git-pull" class="headerlink" title="13. git pull"></a>13. git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [远程仓库名] [远程分支名] [:&lt;本地分支名&gt;]</span><br></pre></td></tr></table></figure><ul><li>[:&lt;本地分支名&gt;] 可以省略，表示拉取并与当前分支合并；</li><li>如果当前分支是跟踪分支，那么可以直接<code>git pull</code>；</li><li>实质上，这等同于先做<code>git fetch</code>（从远程获取最新版本(即对象和引用)到本地，不会自动合并），再执行<code>git merge</code>；</li></ul><p>避免与本地的改动冲突：</p><ul><li>如果本地仓库没有commit：先stash，再pull，再应用stash；</li><li>如果本地仓库中有commit：加<code>--rebase</code>参数：与git rebase功能类似，表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到 <code>.git/rebase</code> 目录中)，然后把本地当前分支更新为最新的”origin”分支，最后把保存的这些补丁应用到本地当前分支上。 </li></ul><h3 id="7-2-分支-平行宇宙"><a href="#7-2-分支-平行宇宙" class="headerlink" title="7.2 分支(平行宇宙)"></a>7.2 分支(平行宇宙)</h3><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 </p><p>但Git的分支是与众不同的，无论创建、切换和删除分支都很快。</p><p>前面已经提到，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支，默认有一条分支叫主分支，即master分支。</p><h4 id="1-git-branch-创建-删除-查看分支"><a href="#1-git-branch-创建-删除-查看分支" class="headerlink" title="1. git branch 创建/删除/查看分支"></a>1. git branch 创建/删除/查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支。如果一个分支还没被合并，会删除失败， 提示：如果删除，将丢失掉修改，可以使用大写的-D参数强行删除</span></span><br><span class="line">git branch -d &lt;branch&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push &lt;remote&gt; &lt;:remote-branch&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有分支，当前分支前面会标一个*号</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><h4 id="2-git-checkout-切换"><a href="#2-git-checkout-切换" class="headerlink" title="2. git checkout 切换"></a>2. git checkout 切换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;    <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch&gt; <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>前面讲过，撤销修改是 <code>git checkout -- &lt;file&gt;</code>，为了避免混淆，最新版本的Git提供了新的git switch命令来切换分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;branch&gt;    <span class="comment"># 切换</span></span><br><span class="line">git switch -c &lt;branch&gt; <span class="comment"># 创建并切换</span></span><br></pre></td></tr></table></figure><h4 id="3-跟踪分支"><a href="#3-跟踪分支" class="headerlink" title="3. 跟踪分支"></a>3. 跟踪分支</h4><p>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入git pull、git push，Git 能自动地识别去<code>哪个服务器(仓库名指定的)</code>上的<code>哪个分支</code>pull、push。</p><h5 id="1-跟踪分支的设置"><a href="#1-跟踪分支的设置" class="headerlink" title="1) 跟踪分支的设置"></a>1) 跟踪分支的设置</h5><ul><li><p>从一个远程跟踪分支检出本地分支时，选择<strong>本地分支是否跟踪远程分支</strong>；</p></li><li><p>当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支；</p></li><li><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或–set-upstream-to选项运行git branch来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/mybranch1 mybranch1</span><br></pre></td></tr></table></figure><ul><li>后者可省略，表示当前本地分支</li><li>一定要加origin，否则表示本地分支，而且还能跟踪成功，表示当前本地分支跟踪了另一个本地分支</li></ul></li><li><p>git push的时候设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u/--set-upstream origin localBranch:remoteBranch  <span class="comment"># 后者可省略，表示远程同名分支</span></span><br></pre></td></tr></table></figure><p>表示把localBranch分支上的修改提交到remoteBranch上，并建立跟踪关联。相比之下这种方式比上面那种使用的更普遍，因为上面那个首先需要有那个远程分支才可以用。</p></li><li><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch -vv</code>： 会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p></li></ul><h5 id="2-如果未设置跟踪分支"><a href="#2-如果未设置跟踪分支" class="headerlink" title="2) 如果未设置跟踪分支"></a>2) 如果未设置跟踪分支</h5><p>无论是否存在同名的远程分支，git push、git pull时都要加上<code>&lt;远程主机名&gt; &lt;本地分支名&gt;</code></p><p>不然前者报错： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch &lt;localBranch&gt; has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use `git push --set-upstream origin &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><p>后者报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. </span><br><span class="line">`git pull &lt;remote&gt; &lt;branch&gt;`</span><br><span class="line">If you wish to set tracking information for this branch you can do so with: `git branch --set-upstream-to=origin/&lt;remoteBranch&gt; &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><h5 id="3-如果设置了跟踪分支"><a href="#3-如果设置了跟踪分支" class="headerlink" title="3) 如果设置了跟踪分支"></a>3) 如果设置了跟踪分支</h5><p>设置成功后，会提示：Branch ‘testBranch’ set up to track remote branch ‘testBranch’ from ‘origin’.</p><p>本地分支与跟踪的远程分支是否同名：</p><ul><li><p>是：可以直接使用git push、git pull，省略之后的参数</p></li><li><p>否：依然可以使用git pull。不能直接使用git push，省略之后报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match the name of your current branch.  </span><br><span class="line">To push to the upstream branch on the remote, use `git push origin HEAD:remoteBranch`</span><br><span class="line">To push to the branch of the same name on the remote, use `git push origin HEAD`</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-git-merge-合并"><a href="#4-git-merge-合并" class="headerlink" title="4. git merge 合并"></a>4. git merge 合并</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式：</p><ul><li>当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</li><li>举例：比如从master上创建分支A，在A上有了数个commit，master上没有提交，此时将A合并到master，实质是将master直接指向A的最新commit（将master引用指向的SHA-1值改为A最新的commit对象的SHA-1值）。</li><li>普通模式的合并有分叉，可以看出曾经做过合并，而fast forward合并看不出来曾经做过合并。</li></ul><p><strong>如果不是fast-forward模式，Git就会在merge时生成一个新的commit。</strong></p><p>可以强制禁用Fast forward模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &lt;“merge”&gt; &lt;branch&gt;   <span class="comment"># 要加commit message，因为会生成一个新commit对象</span></span><br></pre></td></tr></table></figure><p>如果合并发生冲突(两个分支都对一个文件进行修改)，需要解决冲突后，再手动commit。</p><ul><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交</li></ul><h4 id="5-git-log-查看"><a href="#5-git-log-查看" class="headerlink" title="5. git log 查看"></a>5. git log 查看</h4><p>显示分支合并图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="6-git-cherry-pick"><a href="#6-git-cherry-pick" class="headerlink" title="6. git cherry-pick"></a>6. git cherry-pick</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得在另一个分支中单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。</span></span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移多个提交</span></span><br><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt; <span class="comment"># 将 A 和 B 两个提交应用到当前分支</span></span><br><span class="line">git cherry-pick A..B  <span class="comment"># 转移从 A 到 B 的所有提交</span></span><br><span class="line"><span class="comment"># 提交 A 必须早于提交 B，否则命令将失败，但不会报错。</span></span><br><span class="line"><span class="comment"># 提交 A 将不会包含在 Cherry pick 中，即(A, B]</span></span><br><span class="line">git cherry-pick A^..B <span class="comment"># 包含A，即[A, B]</span></span><br></pre></td></tr></table></figure><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><ul><li><p>–continue </p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。 </p><p><code>git cherry-pick --continue</code></p></li><li><p>–abort </p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p></li><li><p>–quit </p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p></li></ul><h4 id="7-分支管理策略"><a href="#7-分支管理策略" class="headerlink" title="7. 分支管理策略"></a>7. 分支管理策略</h4><ul><li>master：master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li><li>dev：dev分支是不稳定的， 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<ul><li>到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</li></ul></li></ul><img src="/images/git/Snip20200423_10.png" alt="Snip20200423_10" style="zoom:90%;" /><ul><li>bug：软件开发中，bug就像家常便饭一样，有了bug就需要修复。由于Git分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<ul><li>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支。</li></ul></li><li>feature：软件开发中，总有无穷无尽的新的功能要不断添加进来。一般是在dev分支上新建feature分支， feature分支和bug分支是类似的，合并，然后删除。</li></ul><p>哪些分支需要推送：</p><ul><li>master分支是主分支，因此要时刻与远程同步； </li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； </li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； </li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 </li><li>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</li></ul><p>美团的命名示意图：</p><img src="/images/git/Snip20200423_11.png" alt="Snip20200423_11" style="zoom:90%;" /><h3 id="7-3-stash"><a href="#7-3-stash" class="headerlink" title="7.3 stash"></a>7.3 stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 将更改储藏在脏工作目录中，clean目前工作区</span></span><br><span class="line"></span><br><span class="line">git stash list <span class="comment"># 查看所有stash</span></span><br><span class="line"><span class="comment"># stash@&#123;0&#125;: WIP on master: 049d078 added the index file </span></span><br><span class="line"><span class="comment"># stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span></span><br><span class="line"></span><br><span class="line">git stash apply [&lt;stash&gt;]  <span class="comment"># 恢复，但是恢复后，stash内容并不删除</span></span><br><span class="line"><span class="comment"># 可以通过名字指定它，像这样：git stash apply stash@&#123;2&#125;。</span></span><br><span class="line"><span class="comment"># 如果不指明，Git 默认使用最近的储藏并尝试应用它</span></span><br><span class="line"></span><br><span class="line">git stash drop [&lt;stash&gt;]   <span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">git stash pop [&lt;stash&gt;]    <span class="comment"># 恢复的同时把stash内容也删掉</span></span><br></pre></td></tr></table></figure><h3 id="7-4-tag"><a href="#7-4-tag" class="headerlink" title="7.4 tag"></a>7.4 tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; [commit]    <span class="comment"># 打一个轻量标签，如果省略&lt;commit&gt;，则表示最新提交</span></span><br><span class="line"></span><br><span class="line">git tag -a &lt;name&gt; -m &lt;<span class="string">&quot;message&quot;</span>&gt; [commit]  <span class="comment"># 打附注标签(带有说明)，用-a指定标签名，-m指定说明文字</span></span><br><span class="line"></span><br><span class="line">git tag <span class="comment"># 查看所有标签， 标签不是按时间顺序列出，而是按字母排序</span></span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 推送标签到远程</span></span><br><span class="line">git push origin --tags    <span class="comment"># 一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line"></span><br><span class="line">git tag -d &lt;name&gt;  <span class="comment"># 删除标签</span></span><br><span class="line">git push &lt;remote&gt; &lt;:tagname | refs/tags/&lt;tagname&gt;&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>如果tag与分支同名，在/refs/heads/、/refs/tags/下都能找到文件名为这个名字的文件，此时操作时如果直接写标签名，可能会报错：<code>...match more than one</code>。</p><h3 id="7-5-补丁的创建与应用"><a href="#7-5-补丁的创建与应用" class="headerlink" title="7.5 补丁的创建与应用"></a>7.5 补丁的创建与应用</h3><p>Git 提供了两种补丁方案</p><ul><li>用 <code>git diff</code> 生成的UNIX标准补丁.diff文件： .diff文件只是记录文件改变的内容，不带有commit记录信息，多个commit可以合并成一个diff文件。 </li><li>用 <code>git format-patch</code> 生成的Git专用.patch 文件:  .patch文件带有记录文件改变的内容，也带有commit记录信息。每个commit对应一个patch文件。</li></ul><p><strong>在Git下，我们可以使用.diff文件也可以使用.patch 文件来打补丁，主要应用场景有：CodeReview、代码迁移等。</strong></p><h4 id="7-5-1-创建补丁git-diff"><a href="#7-5-1-创建补丁git-diff" class="headerlink" title="7.5.1 创建补丁git diff"></a>7.5.1 创建补丁git diff</h4><p>顾名思义就是查看<code>已跟踪tracked文件</code>的difference：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [--cached] [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [查看文件名] [&gt; diff补丁文件名]</span><br></pre></td></tr></table></figure><ul><li><p>不加参数即默认比较工作区与暂存区；</p></li><li><p>如果加了一个commit id，表示比较目前代码与指定commit的差异 = 当前工作区+暂存区+指定commit后的commit修改；</p></li><li><p>如果加了两个commit id，表示比较后者与前者两次提交之间的差异；</p></li><li><p>如果加了–cached（后面即使没有commit id，默认相当于有个HEAD），意义是在上条的基础上忽略工作区的改动，即差异 = 当前暂存区 + 指定commit后的commit修改；</p></li><li><p>在上面的基础上，后面如果加了 <code>&gt; 文件名</code>，表示将上面比较出的差异，导出一个补丁，可以拷贝到另一机器或者另一个马甲项目中应用。</p></li></ul><h4 id="7-5-2-创建补丁git-patch"><a href="#7-5-2-创建补丁git-patch" class="headerlink" title="7.5.2 创建补丁git patch"></a>7.5.2 创建补丁git patch</h4><p>会将指定commit id 后的每一个commit分别单独生成patch文件。</p><p>patch文件按照commit的先后顺序从1开始编号。</p><p>patch文件会生成到当前目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [-n] [&gt; patch补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>commitId 如果省略，表示HEAD指针指向的commit</li><li>-n 表示为HEAD后的n个 commit 生成 patch</li></ul><h4 id="7-5-3-补丁应用git-apply"><a href="#7-5-3-补丁应用git-apply" class="headerlink" title="7.5.3 补丁应用git apply"></a>7.5.3 补丁应用git apply</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查patch/diff是否能正常打入。如果没有任何输出，那么表示可以顺利接受这个补丁</span></span><br><span class="line">git apply --check patch/diff文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用补丁</span></span><br><span class="line">git apply patch/diff文件名</span><br><span class="line"><span class="comment"># apply patch 成功后会自动commit，并且保留原来commit的comments，submittor等信息。但是commit id会新生成</span></span><br><span class="line"><span class="comment"># apply diff 成功后，会将修改放入工作区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</span></span><br><span class="line">git apply --reject patch/diff文件名</span><br></pre></td></tr></table></figure><p>此外，patch补丁文件，还可以使用git am命令来应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am &lt;path/to/xxx.patch&gt; </span><br></pre></td></tr></table></figure><p>补丁冲突解决：</p><p>在打补丁过程中有时候会出现冲突的情况，有冲突时会打入失败。此时需要解决冲突： </p><ol><li>首先使用 以下命令行，自动合入 patch 中不冲突的代码改动，同时保留冲突的部分： git apply –reject xxxx.patch . 此时会在终端中显示出冲突的大致代码， 同时会生成后缀为 .rej 的文件，保存没有合并进去的部分的内容，可以参考这个进行冲突解决。</li><li>解决完冲突后删除后缀为 .rej 的文件，并执行 <code>git add .</code> 添加改动到暂存区. </li><li>接着执行 <code>git am --resolved</code> 或者 <code>git am --continue</code></li></ol><p>说明：在打入patch冲突时，可以执行git am –skip跳过此次冲突，也可以执行git am –abort回退打入patch的动作，还原到操作前的状态。</p><h4 id="7-5-4-手动修改补丁文件"><a href="#7-5-4-手动修改补丁文件" class="headerlink" title="7.5.4 手动修改补丁文件"></a>7.5.4 手动修改补丁文件</h4><img src="/images/git/patch.png" alt="patch" style="zoom:90%;" /><p>有时候patch apply遇到问题，可以根据当前上下文，手动修改patch再进行apply。</p><p>上图就是修改前的patch。patch格式说明，其格式为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -[起始行号],[修改前的行数] +[起始行号],[修改后的行数]</span><br></pre></td></tr></table></figure><p>在新增或删除一行时，记得修改 [修改后的行数]</p><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="https://www.progit.cn/#_pro_git">《Pro Git》</a></p></li><li><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 — 廖雪峰</a></p></li></ul><p>GUI工具：</p><ul><li><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 </p></li><li><p>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;一、Git&quot;&gt;&lt;/a&gt;一、Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来</summary>
      
    
    
    
    <category term="Git" scheme="https://tenloy.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Objc Runtime总结</title>
    <link href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html"/>
    <id>https://tenloy.github.io/2021/10/11/runtime-data-structure.html</id>
    <published>2021-10-11T14:26:09.000Z</published>
    <updated>2021-12-03T08:23:35.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内容骨架来自戴铭老师文章<a href="https://ming1016.github.io/2015/04/01/objc-runtime/">Objc Runtime 总结</a>，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。</p><p>更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。</p></blockquote><h1 id="一、Runtime概述"><a href="#一、Runtime概述" class="headerlink" title="一、Runtime概述"></a>一、Runtime概述</h1><h2 id="1-1-Runtime做了什么？"><a href="#1-1-Runtime做了什么？" class="headerlink" title="1.1 Runtime做了什么？"></a>1.1 Runtime做了什么？</h2><p>Objective-C跟C、C++等语言有着很大的不同，是一门动态性比较强的编程语言。允许很多操作推迟到程序运行时再进行，其可以在运行过程中修改之前编译好的行为，比如程序运行时创建，检查，修改类、对象和它们的方法。</p><blockquote><p>维基：<strong>动态编程语言</strong>是高级编程语言的一个类别，是一类在运行时可以改变其结构的语言，或者说可以在运行时执行静态编程语言在编译期间执行的许多常见编程行为。例如：程序的扩展、添加新代码，已有的函数可以被删除或修改、扩展对象、定义或修改类型系统等。</p></blockquote><p>而Objective-C的动态性是由Runtime来支撑和实现的。</p><blockquote><p>很久之前孙源老师的一篇文章中说道：objc = C + objc编译器 + runtime</p></blockquote><p>Runtime做了什么：</p><ul><li>建立了支持objc语言的数据结构。使得C具有了面向对象能力</li><li>建立了消息机制</li></ul><img src="/images/runtime/04.jpg" alt="04" style="zoom:60%;" /><h2 id="1-2-学习链接"><a href="#1-2-学习链接" class="headerlink" title="1.2 学习链接"></a>1.2 学习链接</h2><ul><li>Runtime是C和汇编编写的，是开源的，<a href="https://opensource.apple.com/source/objc4/">下载地址</a>；</li><li>GNU也有一个开源的runtime版本，他们都努力的保持一致。</li><li>苹果官方的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a>。</li><li>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。可以在苹果官方文档<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C Runtime Reference</a>中查看 Runtime 库函数的详细解释。<ul><li>当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，如果发现没有代码提示，函数里面的参数和描述也没有了。可以在 <code>Build Setting</code> 中设置 <code>Enable Strict Checking of objc_msgSend Calls</code> 为 NO。</li></ul></li></ul><p>写在前面：</p><ul><li>后缀 <code>_t</code> 意味着 type/typedef(类型) ，是一种命名规范，类似于全局变量加前缀 <code>g_</code>。</li><li><code>_np</code>表示不可移植(np意指non portable, 不可移植)。</li></ul><h1 id="二、Object、Class与MetaClass"><a href="#二、Object、Class与MetaClass" class="headerlink" title="二、Object、Class与MetaClass"></a>二、Object、Class与MetaClass</h1><h2 id="关系简图"><a href="#关系简图" class="headerlink" title="关系简图"></a>关系简图</h2><img src="/images/compilelink/36.png" alt="36" style="zoom:88%;" /><p>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容。</p><p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p><p>objc_class 1.0和2.0的差别示意图：</p><img src="/images/runtime/08.png" alt="08" style="zoom:67%;" /><h2 id="2-1-objc-object与id"><a href="#2-1-objc-object与id" class="headerlink" title="2.1 objc_object与id"></a>2.1 objc_object与id</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 类的实例结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">//方法略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class. id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><h3 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h3><p><strong>看到 objc_object 的结构后，此处有个结论：任何结构体，只要以一个指向 Class 结构体的指针开始，都可以视为一个 objc_object (对象)。</strong></p><blockquote><ul><li><strong>32位中，只要一个数据结构的前4个字节，是个指针(Class isa)，就是个对象。</strong></li><li><strong>64位中，只要一个数据结构的前8个字节，是个isa_t类型的变量(isa_t isa)，就是个对象。</strong></li></ul></blockquote><p><strong>反之，Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;my name&#x27;s %@&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];  </span><br><span class="line">    <span class="comment">// obj的前8个字节是指向Class Sark的数据，所以其能视为Sark类对象的。</span></span><br><span class="line">    <span class="comment">// 但是在-speak中，取obj的name，本质是取obj后偏移的第9-16字节的数据，此处会取出-viewDidLoad函数栈中的数据，错乱掉。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br></pre></td></tr></table></figure><h2 id="2-2-objc-class"><a href="#2-2-objc-class" class="headerlink" title="2.2 objc_class"></a>2.2 objc_class</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Objc的类的本身也是一个Object，类的类型我们称为元类Meta Class，记录类方法、属性。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 指向父类的指针，用于组织类的继承链；</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// 缓存调用过的method。对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。(以前缓存指针pointer和vtable)</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line">       <span class="comment">// class_rw_t * plus custom rr/alloc flags. </span></span><br><span class="line">       <span class="comment">// 表示class_data_bits_t其实是class_rw_t* 加上自定义的rr/alloc标志，rr/alloc标志是指含有的retain/release/autorelease/retainCount/alloc等</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">// class_data_bits_t结构体主要用于记录，保存类的数据的`class_rw_t`结构体的内存地址。通过`date()`方法访问`bits`的有效位域指向的内存空间，返回`class_rw_t`结构体；`setData(class_rw_t *newData)`用于设置`bits`的值；</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-成员-isa-t-isa"><a href="#2-2-1-成员-isa-t-isa" class="headerlink" title="2.2.1 成员: isa_t isa"></a>2.2.1 成员: isa_t isa</h3><p>在arm64架构之前，isa就是一个普通的指针(Class _Nonnull isa)，存储着Class、Meta-Class对象的内存地址 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从arm64架构开始：</p><ul><li><p>明确的将objc_class定义为一个Object，继承自struct objc_object。</p></li><li><p>对isa进行了优化，变成了一个共用体（union）结构，使用位域来存储了更多的信息。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;   <span class="comment">// isa(is a)指向它的类。当向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;    // class的isa指针指向class的类(术语称为Meta Class)，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL  取类指针值的掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL  取MAGIC值的掩码</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 代表是否开启isa指针优化。0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否设置或曾经过关联对象(associatedObject)，如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++ 或者 Objc的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类指针。存储着Class、Meta-Class对象的内存地址信息。源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 对象被指向或者曾经指向一个 ARC 的弱变量。如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 里面存储的值是引用计数器减1（比如对象引用计数器是1，这里就是0）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure><h4 id="关于Tagged-Pointer"><a href="#关于Tagged-Pointer" class="headerlink" title="关于Tagged Pointer"></a>关于Tagged Pointer</h4><p>在2013年9月，苹果推出了<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/IPhone_5S">iPhone5s</a>，与此同时，iPhone5s配备了首个采用64位架构的<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Apple_A7">A7双核处理器</a>，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p><p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer用于优化NSNumber、NSDate、NSString等小对象的存储，其存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p><p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。</p><p>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。如下图所示：</p><img src="/images/runtime/05.png" alt="05" style="zoom:75%;" /><h3 id="2-2-2-成员-cache-t-cache"><a href="#2-2-2-成员-cache-t-cache" class="headerlink" title="2.2.2 成员: cache_t cache"></a>2.2.2 成员: cache_t cache</h3><blockquote><p>cache: 用于缓存调用过的method</p></blockquote><p>Cache的作用主要是为了优化方法调用的性能。</p><p>假如，当对象receiver调用方法message时：</p><ol><li>首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法；</li><li>如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。</li></ol><p>这样查找方式效率就太低了，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>  <span class="comment">// 是一个散列表，用来存储Method的链表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;               <span class="comment">// 分配用来缓存bucket的总数。散列表的长度 - 1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;           <span class="comment">// 目前实际占用的缓存bucket的个数。因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uintptr_t</span> _imp;  <span class="comment">// 函数指针，指向了一个方法的具体实现</span></span><br><span class="line">  SEL _sel;        <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_hash</span><span class="params">(SEL sel, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(<span class="keyword">uintptr_t</span>)sel &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul><li><p><strong>不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存。</strong>详见4.3节</p></li><li><p>关于缓存的扩容以及限制：</p><ul><li>初始大小为4；</li><li>当缓存使用达到3/4后，进行缓存扩容，扩容系数为2；</li><li>扩容时，会清空缓存，否则hash值就不对了；</li><li>旧版本中，类的方法缓存大小是有没有限制的，在新的runtime中增加了限制；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br><span class="line">    MAX_CACHE_SIZE_LOG2  = <span class="number">16</span>,</span><br><span class="line">    MAX_CACHE_SIZE       = (<span class="number">1</span> &lt;&lt; MAX_CACHE_SIZE_LOG2),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        capacity = MAX_CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>);   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？这个问题么，我觉得有以下三个原因：</p><ul><li>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。</li><li>list的方法还保存了除了selector和imp之外其他很多属性</li><li>散列表是有空槽的，会浪费空间</li></ul></li></ul><h3 id="2-2-3-成员-class-data-bits-t-bits"><a href="#2-2-3-成员-class-data-bits-t-bits" class="headerlink" title="2.2.3 成员: class_data_bits_t bits"></a>2.2.3 成员: class_data_bits_t bits</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><blockquote><p><code>bits</code>：<code>class_data_bits_t</code>结构体类型，该结构体主要用于记录，保存类的数据的<code>class_rw_t</code>结构体的内存地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;  <span class="comment">// 仅有一个成员 bits 指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取类的数据。获取 bits 成员的 4~47 位域(FAST_DATA_MASK)中保存的 class_rw_t 结构体地址。</span></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 仅在类注册、构建阶段才允许调用setData</span></span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">data</span>()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        <span class="built_in">atomic_thread_fence</span>(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-class-rw-t与class-ro-t简介"><a href="#2-class-rw-t与class-ro-t简介" class="headerlink" title="2. class_rw_t与class_ro_t简介"></a>2. class_rw_t与class_ro_t简介</h4><p><code>class_rw_t</code>、<code>class_ro_t</code>结构体名中，<code>rw</code>是 read write 的缩写，<code>ro</code>是 read only 的缩写，可见<code>class_ro_t</code>的保存类的只读信息，这些信息在类完成注册后不可改变。</p><p>即分类等运行期添加的数据保存在<code>class_rw_t</code>结构体中，编译时期就能确定的部分保存在<code>ro</code>指针指向的<code>class_ro_t</code>结构体中。</p><p>以类的成员变量列表为例（成员变量列表保存在<code>class_ro_t</code>结构体中）。若应用类注册到内存后，使用类构建了若干实例，此时若能够添加成员变量，那必然需要对内存中的这些类重新分配内存，这个操作的花销是相当大的。若考虑再极端一些，为根类<code>NSObject</code>添加成员变量，则内存中基本所有 Objective-C 对象都需要重新分配内存，如此庞大的计算量在运行时是不可接受的。</p><h4 id="3-bits在编译、运行期间值的改变"><a href="#3-bits在编译、运行期间值的改变" class="headerlink" title="3. bits在编译、运行期间值的改变"></a>3. bits在编译、运行期间值的改变</h4><p>注意：<strong>在编译期，类的结构中的 class_data_bits_t的 class_rw_t</strong> *<strong>data() 取出的是一个指向 class_ro_t 的指针。</strong></p><img src="/images/runtime/06.png" alt="06" style="zoom:80%;" /><p>在运行时调用 realizeClass方法，会做以下3件事情：</p><ol><li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针；</li><li>初始化一个 class_rw_t结构体；</li><li>设置结构体 ro的值以及 flag；</li><li>最后设置正确的 <code>data</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;<span class="built_in">setData</span>(rw);</span><br></pre></td></tr></table></figure><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><img src="/images/runtime/07.png" alt="06" style="zoom:80%;" /><p>更加详细的分析，请看<a href="https://link.jianshu.com/?t=https://github.com/Draveness">@Draveness</a> 的这篇文章<a href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a>。</p><h3 id="2-2-4-方法-类加载过程中，状态读写"><a href="#2-2-4-方法-类加载过程中，状态读写" class="headerlink" title="2.2.4 方法: 类加载过程中，状态读写"></a>2.2.4 方法: 类加载过程中，状态读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class结构体中与类的加载过程相关的方法：</span></span><br><span class="line"><span class="comment">// 查询是否正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记为正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已完成初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class metacls;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    cls = (Class)<span class="keyword">this</span>;</span><br><span class="line">    metacls = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于alloc/dealloc/Retain/Release等特殊方法的判断及处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    metacls-&gt;<span class="built_in">changeInfo</span>(RW_INITIALIZED, RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取load方法的IMP</span></span><br><span class="line"><span class="function">IMP <span class="title">objc_class::getLoadMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的基础方法列表中查询load方法的IMP</span></span><br><span class="line">    mlist = <span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">&quot;load&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime是否已认识/实现类</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否future class</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFuture</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_FUTURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-方法-类状态获取"><a href="#2-2-5-方法-类状态获取" class="headerlink" title="2.2.5 方法: 类状态获取"></a>2.2.5 方法: 类状态获取</h3><p><code>objc_class</code>结构体中类的基本状态查询的函数代码如下。注意<code>Class getMeta()</code>获取元类时：对于元类，<code>getMeta()</code>返回的结果与<code>ISA()</code>返回的结果不相同，对于非元类，两者则是相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMetaClass</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> superclass == nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRealized</span>()  ||  <span class="built_in">isFuture</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)<span class="built_in">data</span>())-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">demangledName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-方法-内存分配"><a href="#2-2-6-方法-内存分配" class="headerlink" title="2.2.6 方法: 内存分配"></a>2.2.6 方法: 内存分配</h3><p>根据类的信息构建对象时，需要根据类的继承链上的所有成员变量的内存布局为成员变量数据分配内存空间，分配内存空间的大小固定的，并按 WORD 对齐，调用<code>size_t class_getInstanceSize(Class cls)</code>实际是调用了<code>objc_class</code>结构体的<code>uint32_t alignedInstanceSize()</code>函数。</p><p>成员变量在实例内存空间中偏移量同样也是固定的，同样也是按 WORD 对齐。实例的第一个成员变量内存空间的在实例空间中的偏移量，实际是通过调用<code>objc_class</code>结构体的<code>uint32_t alignedInstanceStart()</code>函数获取。</p><p><code>objc_class</code>结构体中涉及内存分配的函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类的实例的成员变量起始地址可能不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例的成员变量起始地址按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的实例大小可能因为ivar的alignment值而不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes. （TODO：不懂为啥）</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="keyword">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">if</span> (newSize != <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(&amp;<span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        bits.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-class-rw-t"><a href="#2-3-class-rw-t" class="headerlink" title="2.3 class_rw_t"></a>2.3 class_rw_t</h2><p>类的主要数据保存在<code>bits</code>中，<code>bits</code>以位图保存<code>class_rw_t</code>结构体，用于记录类的关键数据，如成员变量列表、方法列表、属性列表、协议列表等等，<code>class_rw_t</code>仅包含三个基本的位操作方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;       <span class="comment">// 标记类的状态;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;     <span class="comment">// 标记类的类型，0表示类为非元类，7表示类为元类；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro; <span class="comment">// 保存类的只读数据，注册类后ro中的数据标记为只读，成员变量列表保存在ro中；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_array_t</span> methods;      <span class="comment">// 方法列表，其类型method_array_t  为二维数组容器；</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">// 属性列表，其类型property_array_t为二维数组容器；</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;  <span class="comment">// 协议列表，其类型protocol_array_t为二维数组容器；</span></span><br><span class="line">    </span><br><span class="line">    Class firstSubclass;    <span class="comment">// 类的首个子类，与nextSiblingClass记录所有类的继承链组织成的继承树；</span></span><br><span class="line">    Class nextSiblingClass; <span class="comment">// 类的下一个兄弟类；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *demangledName;    <span class="comment">// 类名，来自Swift的类会包含一些特别前缀，demangledName是处理后的类名；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;      <span class="comment">// 标记类的对象的isa是否为index类型；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置set指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">uint32_t</span> set)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicOr32Barrier</span>(set, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearFlags</span><span class="params">(<span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicXor32Barrier</span>(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置set指定的位，清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlags</span><span class="params">(<span class="keyword">uint32_t</span> set, <span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | set) &amp; ~clear;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">OSAtomicCompareAndSwap32Barrier</span>(oldf, newf, (<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-class-ro-t"><a href="#2-4-class-ro-t" class="headerlink" title="2.4 class_ro_t"></a>2.4 class_ro_t</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标记类的状态。需要注意class_ro_t的flags的值和前面介绍的class_rw_t的flags的值是完全不同的；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart; <span class="comment">// 类的成员变量，在实例的内存空间中的起始偏移量；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// 类的实例占用的内存空间大小；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;     <span class="comment">// strong成员变量内存布局。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;              <span class="comment">// 类名；</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 基础方法列表，在类定义时指定的方法列表；</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;<span class="comment">// 协议列表；</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;      <span class="comment">// 成员变量列表；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; <span class="comment">// weak成员变量布局；</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;<span class="comment">// 基础属性列表，在类定义时指定的属性列表；</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_ro_t</span> *<span class="title">duplicate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>) + <span class="built_in"><span class="keyword">sizeof</span></span>(_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-ivarLayout与weakIvarLayout"><a href="#2-4-1-ivarLayout与weakIvarLayout" class="headerlink" title="2.4.1 ivarLayout与weakIvarLayout"></a>2.4.1 ivarLayout与weakIvarLayout</h3><h4 id="1-值的存储格式"><a href="#1-值的存储格式" class="headerlink" title="1. 值的存储格式"></a>1. 值的存储格式</h4><p>ivarLayout 和 weakIvarLayout 这两个编码值，结合起来，就可以确定<strong>自上而下</strong>，哪些 ivar 是strong、weak，确定了这两种之后，剩余的就都是基本类型和 __unsafe_unretained 的对象类型。</p><p>这两者都是 <code>const uint8_t *</code> 类型，但读取值的时候，需要注意，不是以char(1字节)为单位来读取的，而是：</p><ul><li><strong>4bit为一位，1字节为一对</strong>，即<strong>从两者首地址开始，1字节分为一对</strong>来读取</li><li>以两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li></ul><p>ivarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 strong</strong> 成员变量、多少个 <strong>strong</strong> 成员变量…(<strong>循环</strong>)…直到最后一个strong出现的位置(后面的就不记录了)。</p><p>weakIvarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 weak</strong> 成员变量、多少个 <strong>weak</strong> 成员变量…(<strong>循环</strong>)…直到最后一个weak出现的位置(后面的就不记录了)。</p><h4 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h4><p>这两个值可以通过 runtime 提供的几个 API 来访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getWeakIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br></pre></td></tr></table></figure><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar5;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar6;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar7;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> ivv;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> ivv1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> uint8_t * strongLayout = class_getIvarLayout(Foo.class);</span><br><span class="line"><span class="keyword">const</span> uint8_t * weakLayout = class_getWeakIvarLayout(Foo.class);</span><br><span class="line"></span><br><span class="line">(lldb) p strongLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">0</span> = <span class="number">0x000000010d6c1246</span> <span class="string">&quot;\U00000011!#&quot;</span></span><br><span class="line">(lldb) p weakLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">1</span> = <span class="number">0x000000010d6c124a</span> <span class="string">&quot;\U00000001!\U000000121&quot;</span></span><br><span class="line">(lldb) x/<span class="number">4</span>xb $<span class="number">0</span></span><br><span class="line"><span class="number">0x10d6c1246</span>: <span class="number">0x11</span> <span class="number">0x21</span> <span class="number">0x23</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x11: 1个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x21: 2个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x23: 2个非strong、3个strong （后面还有个weak就不记录了）</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">(lldb) x/<span class="number">5</span>xb $<span class="number">1</span></span><br><span class="line"><span class="number">0x10d6c124a</span>: <span class="number">0x01</span> <span class="number">0x21</span> <span class="number">0x12</span> <span class="number">0x31</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x01: 0个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x21: 2个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x12: 1个非weak、2个weak</span></span><br><span class="line"><span class="comment">   0x31: 3个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><p><a href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">原文链接：Objective-C Class Ivar Layout 探索</a></p><p>当我们定义一个类的实例变量的时候，可以指定其修饰符：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> _gayFriend; <span class="comment">// 无修饰符的对象默认会加 __strong</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> _girlFriend;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> _company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。</p><p>那么问题来了，假如这个类是动态生成的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>该如何像上面一样来添加 ivar 的属性修饰符呢？假如依次设置strong、weak、strong修饰符</p><p>第一步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在objc_registerClassPair(class);前加上这么两句</span></span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br></pre></td></tr></table></figure><p>第二步：</p><p>此时，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixup_class_arc</span><span class="params">(Class class)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Class isa;</span><br><span class="line">        Class superclass;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">void</span> *_buckets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint32_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint32_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint16_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; cache;</span><br><span class="line">        <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    &#125; *objcClass = (__bridge <span class="built_in">typeof</span>(objcClass))class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        <span class="keyword">uint32_t</span> version;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        &#125; *ro;</span><br><span class="line">    &#125; *objcRWClass = (<span class="built_in">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARR 1&lt;&lt;7    </span></span><br><span class="line">    objcRWClass-&gt;ro-&gt;flags |= RO_IS_ARR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了。</p><p>完整的示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br><span class="line">fixup_class_arc(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> sark = [<span class="keyword">class</span> new];</span><br><span class="line">Ivar strongIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>);</span><br><span class="line">Ivar weakIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>);</span><br><span class="line">Ivar strongIvar2 = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> boy = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> girl = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> boy2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    object_setIvar(sark, strongIvar, boy);</span><br><span class="line">    object_setIvar(sark, weakIvar, girl);</span><br><span class="line">    object_setIvar(sark, strongIvar2, boy2);</span><br><span class="line">&#125; <span class="comment">// ARC 在这里会对大括号内的 girl、boy、boy2 做一次release</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@, %@&quot;</span>, object_getIvar(sark, strongIvar),  <span class="comment">//&lt;NSObject: 0x600000934660&gt;</span></span><br><span class="line">                     object_getIvar(sark, weakIvar),    <span class="comment">//nil</span></span><br><span class="line">                     object_getIvar(sark, strongIvar2));<span class="comment">//&lt;NSObject: 0x6000009346a0&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-几点总结"><a href="#2-4-2-几点总结" class="headerlink" title="2.4.2 几点总结"></a>2.4.2 几点总结</h3><ul><li>property在编译期会生成 _propertyName 的ivar，和相应的get/set方法。</li><li>ivars在编译期确定，但不完全确定，offset属性在运行时会修改。</li><li>对象的大小是由ivars决定的，当有继承体系时，父类的ivars永远放在子类之前。</li><li>class_ro_t 的 instanceStart 和 instanceSize 会在运行时调整。</li><li>class_ro_t 的 ivarLayout 和 weakIvarLayout 存放的是强ivar和弱ivar的存储规则。</li></ul><h2 id="2-5-元类-Meta-Class"><a href="#2-5-元类-Meta-Class" class="headerlink" title="2.5 元类(Meta Class)"></a>2.5 元类(Meta Class)</h2><h3 id="2-5-1-为什么存在元类？"><a href="#2-5-1-为什么存在元类？" class="headerlink" title="2.5.1 为什么存在元类？"></a>2.5.1 为什么存在元类？</h3><p><strong>在调用类方法的时候，为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</strong></p><ul><li>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</li><li>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</li></ul><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有自己独一无二的meta-class，因为每个类的类方法基本不可能完全相同。</p><blockquote><p>以下元类的相关内容，都来自 <a href="https://link.jianshu.com/?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a> 这篇文章。</p></blockquote><h3 id="2-5-2-元类的isa-—-类"><a href="#2-5-2-元类的isa-—-类" class="headerlink" title="2.5.2 元类的isa — 类"></a>2.5.2 元类的isa — 类</h3><p>元类，和类的结构是一样的 objc_class，所以也是一个对象。这表示你能够对元类调用方法。自然的，这表示它必须也有一个类指针。</p><ul><li>类创建对象，调用的是实例方法</li><li>元类创建类对象，调用的是类方法。</li></ul><p>所有元类使用基类的元类（即继承链顶端的类的元类）作为它们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为它的类。</p><p>根据规则所有元类使用基类的元类作为它们的类，那么基类的元类就是它自己的类（它们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是它自己（它是一个它自己的实例）。</p><h3 id="2-5-3-元类的superclass-—-父类"><a href="#2-5-3-元类的superclass-—-父类" class="headerlink" title="2.5.3 元类的superclass — 父类"></a>2.5.3 元类的superclass — 父类</h3><p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。</p><p>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己 (<strong>NSObject-&gt;isa-&gt;superclass = NSObject</strong>)。</p><p>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p><h3 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4 总结"></a>2.5.4 总结</h3><p>所有这些用文字描述起来可能比较容易让人困惑。<a href="https://link.jianshu.com/?t=http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Greg Parker的文章</a>中有一张附图描述了实例、类和元类以及他们的super class是如何完美的共存的。</p><img src="/images/runtime/01.png" alt="01" style="zoom:85%;" /><p>可以看到，所有的meta class 与 Root class 的 isa 都指向 Root class 的meta class，这样能够形成一个闭环。</p><p>实现了：</p><ul><li>所有 NSObject 的实例方法，都能够被 <strong>任何实例、类、元类</strong> 来使用；</li><li>所有 NSObject 的类方法，都能够被 <strong>任何类、元类</strong> 来使用。</li></ul><p>即实现了<strong>Objc中的任意 objc_object 对象，都继承自NSObject。NSObject为所有的对象定义了一些相同的特性</strong>。</p><h2 id="2-6-类与对象操作函数"><a href="#2-6-类与对象操作函数" class="headerlink" title="2.6 类与对象操作函数"></a>2.6 类与对象操作函数</h2><p>runtime有很多的函数可以操作类和对象。通常，操作类的是class为前缀，操作对象的是objc或object_为前缀(因为class也是一种Object，所以有的objc或object为前缀的函数也可以操作类对象)。</p><h3 id="2-6-1-类型获取和判断函数"><a href="#2-6-1-类型获取和判断函数" class="headerlink" title="2.6.1 类型获取和判断函数"></a>2.6.1 类型获取和判断函数</h3><h4 id="1-类型获取"><a href="#1-类型获取" class="headerlink" title="1. 类型获取"></a>1. 类型获取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  传入字符串类名，返回对应的类对象</span></span><br><span class="line"><span class="comment">  Return the id of the named class.  If the class does not exist, call _objc_classLoader and then objc_classHandler, either of which may create a new class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">look_up_class</span>(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 传入的obj可能是instance对象、class对象、meta-class对象</span></span><br><span class="line"><span class="comment"> 返回:</span></span><br><span class="line"><span class="comment">  a) 如果是instance对象，返回class对象</span></span><br><span class="line"><span class="comment">  b) 如果是class对象，返回meta-class对象</span></span><br><span class="line"><span class="comment">  c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回的就是类对象</span></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">&#125;</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类型判断"><a href="#2-类型判断" class="headerlink" title="2. 类型判断"></a>2. 类型判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类</span></span><br><span class="line"><span class="comment">    id person = [[MJPerson alloc] init];</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[NSObject class]]);  // 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:object_getClass([MJPerson class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:[NSObject class]]); // 0 类对象的类怎么可能还是class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类、或者cls子类</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[NSObject class]]);  // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls、或者cls子类。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:object_getClass([NSObject class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[NSObject class]]); // 1 特殊的NSObject，NSObject是所有元类的最顶部父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="built_in">object_getClass</span>((id)self); tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-判断是否是元类"><a href="#3-判断是否是元类" class="headerlink" title="3. 判断是否是元类"></a>3. 判断是否是元类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-类相关操作函数"><a href="#2-6-2-类相关操作函数" class="headerlink" title="2.6.2 类相关操作函数"></a>2.6.2 类相关操作函数</h3><h4 id="1-获取name"><a href="#1-获取name" class="headerlink" title="1. 获取name"></a>1. 获取name</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getName</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span>;</span><br><span class="line">    <span class="comment">// fixme lldb calls class_getName() on unrealized classes (rdar://27258517)</span></span><br><span class="line">    <span class="comment">// ASSERT(cls-&gt;isRealized()  ||  cls-&gt;isFuture());</span></span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">demangledName</span>(<span class="comment">/* needs lock */</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>名字修饰</strong>（name decoration），也称为<strong>名字重整</strong>、<strong>名字改编</strong>（name mangling），是现代计算机程序设计语言的编译器用于解决由于程序实体的名字必须唯一而导致的问题的一种技术。</p><p>demangledName: 去除修饰的名称。</p></blockquote><h4 id="2-获取super-class"><a href="#2-获取super-class" class="headerlink" title="2. 获取super_class"></a>2. 获取super_class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取instance-size"><a href="#3-获取instance-size" class="headerlink" title="3. 获取instance_size"></a>3. 获取instance_size</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">alignedInstanceSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-成员变量-ivars-操作"><a href="#4-成员变量-ivars-操作" class="headerlink" title="4. 成员变量(ivars)操作"></a>4. 成员变量(ivars)操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !name) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> _class_getVariable(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getInstanceVariable</span>(cls-&gt;<span class="built_in">ISA</span>(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量(这个只能够向在runtime时创建的类添加成员变量)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint8_t</span> alignment, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取整个成员变量列表(必须使用free()来释放这个数组)</span></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h4 id="5-方法操作"><a href="#5-方法操作" class="headerlink" title="5. 方法操作"></a>5. 方法操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span> <span class="params">( Class cls, SEL name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span> <span class="params">( Class cls, SEL name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function">Method * <span class="title">class_copyMethodList</span> <span class="params">( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法. (和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替代方法的实现(内部也是调用的_method_setImplementation)</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回方法的具体实现</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation_stret</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_respondsToSelector</span><span class="params">(Class cls, SEL sel)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="6-协议操作"><a href="#6-协议操作" class="headerlink" title="6. 协议操作"></a>6. 协议操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span><span class="params">(Class cls, Protocol *protocol_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span><span class="params">(Class cls, Protocol *proto_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line"><span class="function">Protocol * <span class="title">class_copyProtocolList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-获取版本号"><a href="#7-获取版本号" class="headerlink" title="7. 获取版本号"></a>7. 获取版本号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号 0表示类为非元类，7表示类为元类；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">data</span>()-&gt;version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-示例"><a href="#8-示例" class="headerlink" title="8. 示例"></a>8. 示例</h4><p>通过示例来消化下上面的那些函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</span><br><span class="line"><span class="built_in">NSInteger</span> _instance1;</span><br><span class="line"><span class="built_in">NSString</span> * _instance2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;call method method1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123; &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 : %ld, arg2 : %@&quot;</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// main.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MySubClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">          MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">          Class cls = myClass.class;</span><br><span class="line">          <span class="comment">// 类名</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));    </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 父类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;super class name: %s&quot;</span>, class_getName(class_getSuperclass(cls)));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 是否是元类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is %@ a meta-class&quot;</span>, (class_isMetaClass(cls) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot;not&quot;</span>));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&#x27;s meta-class is %s&quot;</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 变量实例大小</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;instance size: %zu&quot;</span>, class_getInstanceSize(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 成员变量</span></span><br><span class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Ivar ivar = ivars[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instance variable&#x27;s name: %s at index: %d&quot;</span>, ivar_getName(ivar), i);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(ivars);</span><br><span class="line"></span><br><span class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">&quot;_string&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instace variable %s&quot;</span>, ivar_getName(string));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 属性操作</span></span><br><span class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               objc_property_t property = properties[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property&#x27;s name: %s&quot;</span>, property_getName(property));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(properties);</span><br><span class="line"></span><br><span class="line">          objc_property_t array = class_getProperty(cls, <span class="string">&quot;array&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property %s&quot;</span>, property_getName(array));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 方法操作</span></span><br><span class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Method method = methods[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method&#x27;s signature: %s&quot;</span>, method_getName(method));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(methods);</span><br><span class="line"></span><br><span class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method %s&quot;</span>, method_getName(method1));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</span><br><span class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;class method : %s&quot;</span>, method_getName(classMethod));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>);</span><br><span class="line"></span><br><span class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          imp();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 协议</span></span><br><span class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">          Protocol * protocol;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               protocol = protocols[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;protocol name: %s&quot;</span>, protocol_getName(protocol));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsed to protocol %s&quot;</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>, protocol_getName(protocol));</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.452</span> RuntimeTest <span class="keyword">class</span> name: MyClass</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.453</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest <span class="keyword">super</span> <span class="keyword">class</span> name: <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass is not a meta-<span class="keyword">class</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass<span class="string">&#x27;s meta-class is MyClass</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance size: 48</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _instance1 at index: <span class="number">0</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _instance2 at index: 1</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _array at index: <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _string at index: 3</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest instance variable&#x27;</span>s name: _integer at index: <span class="number">4</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest instace variable _string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest property<span class="string">&#x27;s name: array</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest property&#x27;</span>s name: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest property<span class="string">&#x27;s name: integer</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest property array</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest method<span class="string">&#x27;s signature: method2</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method3WithArg1:arg2:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: integer</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setInteger:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: array</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: setString:</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setArray:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest method<span class="string">&#x27;s signature: .cxx_destruct</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest method method1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest class method : classMethod1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest MyClass is responsd to selector: method3WithArg1:arg2:</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest call method method1</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest =====================================================</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCopying</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCoding</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest MyClass is responsed to protocol NSCoding</span></span><br><span class="line"><span class="string">19:41:37.468 RuntimeTest ======================================</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-动态创建类和对象"><a href="#2-6-3-动态创建类和对象" class="headerlink" title="2.6.3 动态创建类和对象"></a>2.6.3 动态创建类和对象</h3><h4 id="1-动态创建类"><a href="#1-动态创建类" class="headerlink" title="1. 动态创建类"></a>1. 动态创建类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个新类和元类。Creates a new class and metaclass.</span></span><br><span class="line"><span class="comment"> * @prama superclass 如果创建的是root class，则superclass为Nil</span></span><br><span class="line"><span class="comment"> * @prama sextraBytes 通常为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新类后，使用class_addMethod，class_addIvar函数为新类添加方法、实例变量和属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类。再之后就能够用了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类。在运行中还存在或存在子类实例，就不能够调用这个。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>问题：什么是”class pair（类对）”？函数 objc_allocateClassPair 只返回一个值：类。那么这个”class pair（类对）”的另一半呢？从方法注释可以看出来，是元类。</p></blockquote><p>使用示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">&quot;MySubClass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_addIvar(cls, <span class="string">&quot;_ivar1&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; <span class="string">&quot;V&quot;</span>, <span class="string">&quot;_ivar1&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty(cls, <span class="string">&quot;property2&quot;</span>, attrs, <span class="number">3</span>);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-动态创建对象"><a href="#2-动态创建对象" class="headerlink" title="2. 动态创建对象"></a>2. 动态创建对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例。会在heap里给类分配内存。这个方法和+alloc方法类似。</span></span><br><span class="line"><span class="function">id <span class="title">class_createInstance</span><span class="params">(Class cls, <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在指定位置创建类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在bytes所指向的位置创建cls的实例。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * bytes必须至少指向对齐的零填充内存的class_getInstanceSize(cls)字节。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 设置新对象的isa。调用任何c++构造函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果成功返回bytes。如果cls或bytes为nil，或c++构造函数失败，则返回nil。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 注意: class_createInstance()和class_createInstances()对此进行了预检。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_constructInstance</span><span class="params">(Class cls, <span class="keyword">void</span> *bytes)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 销毁实例而不释放内存。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 C++ 析构函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 ARC ivar 清理。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 移除除关联引用。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回obj。如果obj为nil，则什么都不做。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>; <span class="comment">//不会释放移除任何相关引用</span></span><br></pre></td></tr></table></figure><p>测试下效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></span><br><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></span><br><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</span><br></pre></td></tr></table></figure><h3 id="2-6-4-实例对象相关操作函数"><a href="#2-6-4-实例对象相关操作函数" class="headerlink" title="2.6.4 实例对象相关操作函数"></a>2.6.4 实例对象相关操作函数</h3><p>这些函数是针对创建的实例对象的一系列操作函数。</p><h4 id="1-操作-整个对象-的函数"><a href="#1-操作-整个对象-的函数" class="headerlink" title="1. 操作 整个对象 的函数"></a>1. 操作 整个对象 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="function">id <span class="title">object_copy</span><span class="params">(id oldObj, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span></span>;</span><br></pre></td></tr></table></figure><p>应用场景</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></span><br><span class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</span><br><span class="line">object_setClass(newB, MyClass.class);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure><h4 id="2-操作-对象的类-的函数"><a href="#2-操作-对象的类-的函数" class="headerlink" title="2. 操作 对象的类 的函数"></a>2. 操作 对象的类 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">object_getClassName</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-5-获取类定义"><a href="#2-6-5-获取类定义" class="headerlink" title="2.6.5 获取类定义"></a>2.6.5 获取类定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表。返回值为已注册类的总数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span><span class="params">(Class *buffer, <span class="keyword">int</span> bufferLen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span></span><br><span class="line"><span class="function">Class *<span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定类的类定义</span></span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>; <span class="comment">// 与objc_getClass相同，但如果没有找到类，则终止进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br></pre></td></tr></table></figure><p>演示如何使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numClasses;</span><br><span class="line">Class * classes = <span class="literal">NULL</span>;</span><br><span class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">     numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;number of classes: %d&quot;</span>, numClasses);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">          Class cls = classes[i];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));</span><br><span class="line">     &#125;</span><br><span class="line">     free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] number of classes: <span class="number">1282</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: DDTokenRegexp</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _PFRoutines</span><br><span class="line">......还有大量输出</span><br></pre></td></tr></table></figure><h1 id="三、成员变量、属性与关联对象"><a href="#三、成员变量、属性与关联对象" class="headerlink" title="三、成员变量、属性与关联对象"></a>三、成员变量、属性与关联对象</h1><h2 id="3-1-实例变量类型Ivar"><a href="#3-1-实例变量类型Ivar" class="headerlink" title="3.1 实例变量类型Ivar"></a>3.1 实例变量类型Ivar</h2><blockquote><p>实例变量是指在类的声明中，属性是用变量来表示的。 这种变量就称为实例变量，也叫对象变量、类成员变量；</p></blockquote><h3 id="3-1-1-Ivar结构"><a href="#3-1-1-Ivar结构" class="headerlink" title="3.1.1 Ivar结构"></a>3.1.1 Ivar结构</h3><p>Ivar是指向 ivar_t 结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">ivar_getOffset</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar ivar)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-Ivar的获取"><a href="#3-1-2-Ivar的获取" class="headerlink" title="3.1.2 Ivar的获取"></a>3.1.2 Ivar的获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-实例变量操作函数"><a href="#3-1-3-实例变量操作函数" class="headerlink" title="3.1.3 实例变量操作函数"></a>3.1.3 实例变量操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_setInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_getInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **value)</span></span>;</span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">object_getIndexedIvars</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对象中实例变量的值</span></span></span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-2-属性类型property-t"><a href="#3-2-属性类型property-t" class="headerlink" title="3.2 属性类型property_t"></a>3.2 属性类型property_t</h2><h3 id="3-2-1-property-t结构和objc-property-t"><a href="#3-2-1-property-t结构和objc-property-t" class="headerlink" title="3.2.1 property_t结构和objc_property_t"></a>3.2.1 property_t结构和objc_property_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">// property的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// property的属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure><p>属性attributes是一个字符串：该字符串以T开头，后面跟着@encode类型和一个逗号，以V结尾，后面跟着后台实例变量的名称。在这些属性之间，由以下描述符指定，以逗号分隔。官方文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24">Declared Properties</a>。</p><img src="/images/runtime/02.png" alt="02" style="zoom:90%;" /><p>获取name、attributes的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-property的获取"><a href="#3-2-2-property的获取" class="headerlink" title="3.2.2 property的获取"></a>3.2.2 property的获取</h3><p>获取类和协议的属性列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回一个包含类中声明的属性的堆块(heap block)，如果类没有声明属性，则返回nil。呼叫者必须释放区块。</span></span><br><span class="line"><span class="comment"> * 不复制任何超类的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">class_copyPropertyList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><p>通过给出的名称来在类和协议中获取属性的引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">class_getProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-property的特性attributes"><a href="#3-2-3-property的特性attributes" class="headerlink" title="3.2.3 property的特性attributes"></a>3.2.3 property的特性attributes</h3><p>objc_property_attribute_t也是结构体，定义属性的attribute</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">property_copyAttributeValue</span><span class="params">(<span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span></span>;</span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_attribute_t</span> *<span class="title">property_copyAttributeList</span><span class="params">(<span class="keyword">objc_property_t</span> prop, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-示例"><a href="#3-2-4-示例" class="headerlink" title="3.2.4 示例"></a>3.2.4 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Lender : NSObject &#123;</span><br><span class="line">     <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line">@property <span class="keyword">float</span> alone;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性列表</span></span><br><span class="line">id LenderClass = <span class="built_in">objc_getClass</span>(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line"><span class="keyword">objc_property_t</span> *properties = <span class="built_in">class_copyPropertyList</span>(LenderClass, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, <span class="built_in">property_getName</span>(property), <span class="built_in">property_getAttributes</span>(property)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount2, j;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> * attries = <span class="built_in">property_copyAttributeList</span>(property, &amp;outCount2);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; outCount2; j++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_attribute_t</span> attr = attries[j];</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, attr.name, attr.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">log: ======= alone Tf,V_alone</span><br><span class="line">log: ======= T f</span><br><span class="line">log: ======= V _alone</span><br></pre></td></tr></table></figure><h2 id="3-3-关联对象"><a href="#3-3-关联对象" class="headerlink" title="3.3 关联对象"></a>3.3 关联对象</h2><p>关联对象是在运行时添加的类似成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置对象 的一个关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取对象 指定的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//移除对象 所有关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="built_in"><span class="keyword">void</span></span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">     UITapGestureRecognizer *gesture = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!gesture)</span><br><span class="line">     &#123;</span><br><span class="line">          gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@<span class="built_in">selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">          [self addGestureRecognizer:gesture];</span><br><span class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></span><br><span class="line">          <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手势识别对象的target和action</span></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (gesture.state == UIGestureRecognizerStateRecognized)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in"><span class="keyword">void</span></span>(^action)(<span class="keyword">void</span>) = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (action)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">action</span>();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Method和消息"><a href="#四、Method和消息" class="headerlink" title="四、Method和消息"></a>四、Method和消息</h1><h2 id="4-1-method-t、SEL和IMP"><a href="#4-1-method-t、SEL和IMP" class="headerlink" title="4.1 method_t、SEL和IMP"></a>4.1 method_t、SEL和IMP</h2><h3 id="4-1-1-method-t结构和Method"><a href="#4-1-1-method-t结构和Method" class="headerlink" title="4.1.1 method_t结构和Method"></a>4.1.1 method_t结构和Method</h3><p>method_t结构，用于表示类定义中的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 编码，是个char指针，存储着方法的返回值类型、参数类型</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向函数实现的指针(函数地址)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   v16@0:8</span></span><br><span class="line"><span class="comment">   v - 返回值void</span></span><br><span class="line"><span class="comment">   @ - 参数1: id self</span></span><br><span class="line"><span class="comment">   : - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)test:(<span class="keyword">int</span>)age height:(<span class="keyword">float</span>)height;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   i24@0:8i16f20</span></span><br><span class="line"><span class="comment">   i  - 返回值</span></span><br><span class="line"><span class="comment">   24 - 表示接下来的参数总共占多少个字节</span></span><br><span class="line"><span class="comment">   @  - 参数1: id self</span></span><br><span class="line"><span class="comment">   0  - 对应参数1，表示参数1的数据是从第几个字节开始的。后面的8 16 20分别对应参数234对应的开始位置</span></span><br><span class="line"><span class="comment">   :  - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">   i  - 参数3: int</span></span><br><span class="line"><span class="comment">   f  - 参数4: float</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-SEL"><a href="#4-1-2-SEL" class="headerlink" title="4.1.2 SEL"></a>4.1.2 SEL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似.(可以简单的理解为是个字符串).</span></span><br><span class="line">  <span class="comment">// 可以通过@selector()和sel_registerName()获得.</span></span><br><span class="line">  <span class="comment">// 可以通过sel_getName()和NSStringFromSelector()转成字符串.</span></span><br><span class="line">  <span class="comment">// 不同类中相同名字的方法，所对应的方法选择器是相同的.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></span><br><span class="line">SEL sel1 = @<span class="built_in">selector</span>(load);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;sel : %p&quot;</span>, sel1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52</span>:<span class="number">46</span>] sel : <span class="number">0x7fff606203c3</span></span><br></pre></td></tr></table></figure><h3 id="4-1-3-IMP"><a href="#4-1-3-IMP" class="headerlink" title="4.1.3 IMP"></a>4.1.3 IMP</h3><p>是函数指针，指向方法的首地址，得到了IMP，就可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMP代表函数的具体实现</span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><h2 id="4-2-Method相关操作函数"><a href="#4-2-Method相关操作函数" class="headerlink" title="4.2 Method相关操作函数"></a>4.2 Method相关操作函数</h2><h3 id="4-2-1-获取Method的信息"><a href="#4-2-1-获取Method的信息" class="headerlink" title="4.2.1 获取Method的信息"></a>4.2.1 获取Method的信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法名。如果希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串：通过引用返回，这种参数又称为传出参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getReturnType</span><span class="params">(Method m, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串：通过引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">method_getDescription</span><span class="params">(Method m)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-获取和设置Method的IMP"><a href="#4-2-2-获取和设置Method的IMP" class="headerlink" title="4.2.2 获取和设置Method的IMP"></a>4.2.2 获取和设置Method的IMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span>;</span><br></pre></td></tr></table></figure><p>NSObject提供了一个methodForSelector:方法可以获得Method的IMP指针，通过指针调用实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel;</span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel;</span><br><span class="line">- (IMP)methodForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-3-直接调用Method"><a href="#4-2-3-直接调用Method" class="headerlink" title="4.2.3 直接调用Method"></a>4.2.3 直接调用Method</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></span><br><span class="line"><span class="function">id <span class="title">method_invoke</span><span class="params">(id receiver, Method m, ... )</span></span>;</span><br><span class="line"><span class="comment">// 调用 (返回一个数据结构的) 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_invoke_stret</span><span class="params">(id receiver, Method m, ...)</span> </span></span><br></pre></td></tr></table></figure><h3 id="4-2-4-SEL的操作函数"><a href="#4-2-4-SEL的操作函数" class="headerlink" title="4.2.4 SEL的操作函数"></a>4.2.4 SEL的操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_getUid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="function">BOOL <span class="title">sel_isEqual</span><span class="params">(SEL lhs, SEL rhs)</span></span>; <span class="comment">// Lhs --&gt; Left Hand Side，也就是算式左边的意思</span></span><br></pre></td></tr></table></figure><h2 id="4-3-Method调用流程objc-msgSend"><a href="#4-3-Method调用流程objc-msgSend" class="headerlink" title="4.3 Method调用流程objc_msgSend"></a>4.3 Method调用流程objc_msgSend</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。</p><p>OC中的方法调用，其实都是转换为下面几个函数的调用。编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。</p><ul><li>如果是传递给超类就会调用带super的函数；</li><li>如果返回是数据结构而不是一个值就会调用带stret的函数；</li><li>在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将消息接收者和方法名(选择器)作为基础参数。</span></span><br><span class="line">   <span class="comment">// 使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入</span></span><br><span class="line">   <span class="comment">// 还有方法选择器</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span></span><br></pre></td></tr></table></figure><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>objc_msgSend的执行流程可以分为3大阶段：消息发送、动态方法解析、消息转发</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息发送阶段</span></span><br><span class="line"><span class="comment">//在objc-msg-arm64.s中</span></span><br><span class="line">▼ _objc_msgSend</span><br><span class="line">  ▼ CacheLookup  <span class="comment">// 缓存查找</span></span><br><span class="line">    ▼ CheckMiss <span class="comment">// 如果缓存没有命中</span></span><br><span class="line">      ▼ __objc_msgSend_uncached</span><br><span class="line">        ▼ MethodTableLookup</span><br><span class="line">        <span class="comment">// 其中有一行 bl __class_lookupMethodAndLoadCache3. 此时在objc-msg-arm64.s已经查不到该方法了。前缀减去</span></span><br><span class="line">        <span class="comment">// 一个_（符号修饰）然后全局搜索，可以在objc-runtime-new.mm中找到该方法_class_lookupMethodAndLoadCache3</span></span><br><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line">  ▼ _class_lookupMethodAndLoadCache3</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   // 仅用于汇编中的方法查找。其他代码应该使用lookUpImp()。这种查找避免了乐观的缓存扫描，因为汇编中已经尝试过。</span></span><br><span class="line"><span class="comment">   IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;</span></span><br><span class="line"><span class="comment">        // NO是cache. cache==NO跳过乐观的解锁查找(但在其他地方使用缓存);</span></span><br><span class="line"><span class="comment">          return lookUpImpOrForward(cls, sel, obj, YES, NO, YES);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ▼ lookUpImpOrForward</span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找当前类的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找当前类的methods</span></span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找父类(父类的父类...)的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找父类(父类的父类...)的methods</span></span><br><span class="line">        ▼ search_method_list</span><br><span class="line">          ▶ findMethodInSortedMethodList  <span class="comment">//若有序，二分查找</span></span><br><span class="line">          ▶ <span class="comment">//若无序，线性查找</span></span><br><span class="line">      ▼ log_and_fill_cache  <span class="comment">// 不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存</span></span><br><span class="line">        ▼ cache_fill</span><br><span class="line">          ▶ cache_fill_nolock</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 动态方法解析</span></span><br><span class="line">      ▼ _class_resolveMethod      <span class="comment">// 动态方法解析. 在运行时(动态)向特定类添加特定方法实现。</span></span><br><span class="line">        ▶ _class_resolveClassMethod    <span class="comment">// 如果是元类对象，调用类的该类方法(需要自己实现)，在该方法中，将要调用的方法添加到class/meta-class中。见MJPerson.m</span></span><br><span class="line">        ▶ _class_resolveInstanceMethod <span class="comment">// 如果是类对象，同上...</span></span><br><span class="line">        <span class="comment">//..动态解析过后，会重新走“消息发送”的流程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息转发</span></span><br><span class="line">      ▶ _objc_msgForward_impcache <span class="comment">// 消息转发. No implementation found, and method resolver didn&#x27;t help. Use forwarding.</span></span><br></pre></td></tr></table></figure><p>大致流程图如下：</p><img src="/images/runtime/03.png" alt="03" style="zoom:80%;" /><h3 id="4-3-1-消息发送"><a href="#4-3-1-消息发送" class="headerlink" title="4.3.1 消息发送"></a>4.3.1 消息发送</h3><ul><li>消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行</li><li>没找到就在分发列表里查找方法的selector</li><li>没找到就通过objc_class结构体中指向父类的指针找到父类，然后在父类分发列表找</li><li>直到root class（NSObject）</li></ul><p>如果root class仍然找不到方法，不会直接报错，会进入以下两个补救阶段。不过安全起见，一些场景中，可以先添加方法能否响应的判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</span><br><span class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-动态方法解析"><a href="#4-3-2-动态方法解析" class="headerlink" title="4.3.2 动态方法解析"></a>4.3.2 动态方法解析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %p&quot;</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@&quot;method1&quot;</span>]) &#123;</span><br><span class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">&quot;@:&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。</span></span><br><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果是对象方法找不到，动态方法解析 会调用+(BOOL)resolveInstanceMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> 如果是类方法找不到， 动态方法解析 会调用+(BOOL)resolveClassMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></span><br><span class="line">        <span class="comment">// 最后用class_addMethod完成添加特定方法实现的操作</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-消息转发"><a href="#4-3-3-消息转发" class="headerlink" title="4.3.3 消息转发"></a>4.3.3 消息转发</h3><h4 id="1-重定向接收者"><a href="#1-重定向接收者" class="headerlink" title="1. 重定向接收者"></a>1. 重定向接收者</h4><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这个方法通常在对象内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实例方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 将消息转发给alternateObject来处理</span></span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">          <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是类方法</span></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">   <span class="comment">// 这个return，不仅限于类对象，也可以是实例对象，前提是这个实例对象有名为aSelector的实例方法。因为前面已经说了，底层代码得到return的对象后，就会调用objc_msgSend，如果返回的实例对象，就相当于objc_msgSend(obj, @selector(test))，最后是能完成消息发送的</span></span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最后进行转发"><a href="#2-最后进行转发" class="headerlink" title="2. 最后进行转发"></a>2. 最后进行转发</h4><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。如果没有实现，或者返回nil，消息转发结束。</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:_helper];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-消息转发和多继承"><a href="#4-3-4-消息转发和多继承" class="headerlink" title="4.3.4 消息转发和多继承"></a>4.3.4 消息转发和多继承</h3><p>OC是否支持多继承？有没有模拟多继承特性的办法？</p><p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p><p>消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p><p>虽然转发可以实现继承功能，但是NSObject还是必须表面上很严谨，像<code>respondsToSelector:</code>和<code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。</p><h3 id="4-3-5-Message消息的参考文章"><a href="#4-3-5-Message消息的参考文章" class="headerlink" title="4.3.5 Message消息的参考文章"></a>4.3.5 Message消息的参考文章</h3><ul><li><a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html">Message forwarding</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html">objectivec messaging</a></li><li><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html">The faster objc_msgSend</a></li></ul><h2 id="4-4-super和objc-msgSendSuper"><a href="#4-4-super和objc-msgSendSuper" class="headerlink" title="4.4 super和objc_msgSendSuper"></a>4.4 super和objc_msgSendSuper</h2><p><code>NSStringFromClass([self class])</code> 和 <code>NSStringFromClass([super class])</code> 输出都是self的类名。原因如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[super message]的底层实现:</span></span><br><span class="line"><span class="comment">//super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></span><br><span class="line">         id receiver;         <span class="comment">// receiver是self，表示消息接收者仍然是子类对象</span></span><br><span class="line">         Class current_class; <span class="comment">// 会从父类current_class.superclass开始查找方法的实现</span></span><br><span class="line">     &#125;;</span><br><span class="line">     SEL</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param super 指向objc_super数据结构的指针。传递消息发送的上下文的值，包括要接收消息的类的实例和开始搜索方法实现的超类。including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由此可知，消息仍然是receiver来处理，superclass指定了`消息发送`阶段，方法从isa-&gt;superclass-&gt;superclass.superclass...-&gt;NSObject链中superclass为起点开始向上寻找。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param op SEL类型的指针。传递将处理消息的方法的选择器。</span></span><br><span class="line"><span class="comment"> * @param ... A variable argument list containing the arguments to the method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return The return value of the method identified by \e op.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see objc_msgSend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper2</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>结论：super只是改变了方法查找链的起始位置，调用者是不变的。</p><h2 id="4-5-Method-Swizzling"><a href="#4-5-Method-Swizzling" class="headerlink" title="4.5 Method Swizzling"></a>4.5 Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p><h3 id="4-5-1-使用method-swizzling需要注意的问题"><a href="#4-5-1-使用method-swizzling需要注意的问题" class="headerlink" title="4.5.1 使用method swizzling需要注意的问题"></a>4.5.1 使用method swizzling需要注意的问题</h3><ul><li>Swizzling应该总在+load中执行：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载。</li><li>Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。</li><li>Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。</li></ul><h3 id="4-5-2-实现一"><a href="#4-5-2-实现一" class="headerlink" title="4.5.2 实现一"></a>4.5.2 实现一</h3><p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">          <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></span><br><span class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line"></span><br><span class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">               originalSelector,</span><br><span class="line">               method_getImplementation(swizzledMethod),</span><br><span class="line">               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></span><br><span class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">               class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                    swizzledSelector,</span><br><span class="line">                    method_getImplementation(originalMethod),</span><br><span class="line">               method_getTypeEncoding(originalMethod));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;viewWillAppear: %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>method_exchangeImplementations做的事情和如下代码是一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = <span class="built_in">method_getImplementation</span>(m1);</span><br><span class="line">IMP imp2 = <span class="built_in">method_getImplementation</span>(m2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m1, imp2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m2, imp1);</span><br></pre></td></tr></table></figure><h3 id="4-5-3-实现二"><a href="#4-5-3-实现二" class="headerlink" title="4.5.3 实现二"></a>4.5.3 实现二</h3><p>另一种Method Swizzling的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     SEL originalSelector = <span class="keyword">@selector</span>(ReceiveMessage:);</span><br><span class="line">     SEL overrideSelector = <span class="keyword">@selector</span>(replacementReceiveMessage:);</span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">     Method overrideMethod = class_getInstanceMethod(<span class="keyword">self</span>, overrideSelector);</span><br><span class="line">     <span class="keyword">if</span> (class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">self</span>, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replacementReceiveMessage:(<span class="keyword">const</span> <span class="keyword">struct</span> BInstantMessage *)arg1 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 is %@&quot;</span>, arg1);</span><br><span class="line">     [<span class="keyword">self</span> replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关于Method Swizzling的资源可以参考</p><ul><li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?</a></li><li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li><li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec">What are the Dangers of Method Swizzling in Objective C?</a></li><li><a href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></li></ul><h1 id="五、Category和Protocol"><a href="#五、Category和Protocol" class="headerlink" title="五、Category和Protocol"></a>五、Category和Protocol</h1><h2 id="5-1-分类Category"><a href="#5-1-分类Category" class="headerlink" title="5.1 分类Category"></a>5.1 分类Category</h2><h3 id="5-1-1-分类概述"><a href="#5-1-1-分类概述" class="headerlink" title="5.1.1 分类概述"></a>5.1.1 分类概述</h3><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">1</a></p><ul><li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li><li>声明私有方法</li></ul><p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p><ul><li>模拟多继承</li><li>把framework的私有方法公开</li></ul><p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p><h3 id="5-1-2-category-t结构和Category"><a href="#5-1-2-category-t结构和Category" class="headerlink" title="5.1.2 category_t结构和Category"></a>5.1.2 category_t结构和Category</h3><p>指向分类的结构体的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;    <span class="comment">// 指向扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>     <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">// category中添加的所有属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></span><br></pre></td></tr></table></figure><p>从category的定义也可以看出category的：</p><ul><li>可为 (可以添加实例方法，类方法，甚至可以实现协议，添加属性(属性添加、使用，编译是能通过的，运行会crash))</li><li>不可为 (无法添加实例变量）<ul><li>编译后的类已经注册在runtime中，类结构体中的 ivars (实例变量的链表) 和 instance_size (实例变量的内存大小) 已经确定。</li><li>category_t 中并没有空间来存放类的成员变量Ivar。</li></ul></li></ul><p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数<code>_objc_init</code>就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，<code>_read_images</code>开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。</p><h3 id="5-1-3-示例：分类的编译"><a href="#5-1-3-示例：分类的编译" class="headerlink" title="5.1.3 示例：分类的编译"></a>5.1.3 示例：分类的编译</h3><p>Lender+TT.h</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender.h&quot;</span></span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * lxyname;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Lender+TT.m</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender+TT.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用clang的命令去看看category到底会变成什么(主要是看一下分类中的属性底层是什么)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(_objc_method),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">&quot;test&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_I_Lender_TT_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">_prop_t</span>),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;<span class="string">&quot;lxyname&quot;</span>,<span class="string">&quot;T@\&quot;NSString\&quot;,&amp;,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">Lender</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Lender_</span>$_<span class="title">TT</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Lender&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Lender,</span></span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Lender_$_TT,  <span class="comment">//属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时期给分类结构的.cls赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Lender_$_TT(<span class="keyword">void</span> ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Lender_$_TT.cls = &amp;OBJC_CLASS_$_Lender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))=</span> &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到：</p><ol><li><p>首先编译器生成了实例方法列表 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT</code> 和属性列表 <code>_OBJC_$_PROP_LIST_Lender_$_TT</code>，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在 <code>TT</code> 这个category里面写的方法 <code>test</code>，而属性列表里面填充的也正是我们在 <code>TT</code> 里添加的 <code>lxyname</code> 属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p></li><li><p>其次，编译器生成了category本身 <code>_OBJC_$_CATEGORY_Lender_$_TT</code>，并用前面生成的列表来初始化category本身。</p></li><li><p>最后，编译器在<strong>DATA segment(段)下的objc_catlist section(节)</strong> 里保存了一个大小为1的category_t的数组<code>L_OBJC_LABEL_CATEGORY_$</code>（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。</p></li></ol><h3 id="5-1-4-分类的运行时处理"><a href="#5-1-4-分类的运行时处理" class="headerlink" title="5.1.4 分类的运行时处理"></a>5.1.4 分类的运行时处理</h3><p>见<a href="https://tenloy.github.io/2021/09/28/dyld-objc.html#4-2-loadAllCategories-%E5%88%86%E7%B1%BB%E5%8A%A0%E8%BD%BD">dyld与Objc—_objc_init、map_images、load_images的4.2小节：分类的加载</a></p><h2 id="5-2-类扩展-Extension"><a href="#5-2-类扩展-Extension" class="headerlink" title="5.2 类扩展(Extension)"></a>5.2 类扩展(Extension)</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>）</p><p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p><h2 id="5-3-Protocol"><a href="#5-3-Protocol" class="headerlink" title="5.3 Protocol"></a>5.3 Protocol</h2><p>Protocol其实就是一个对象结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Protocol</span>;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-操作函数"><a href="#5-4-操作函数" class="headerlink" title="5.4 操作函数"></a>5.4 操作函数</h2><h3 id="5-4-1-Category操作函数"><a href="#5-4-1-Category操作函数" class="headerlink" title="5.4.1 Category操作函数"></a>5.4.1 Category操作函数</h3><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试objc_class中的方法列表是否包含分类中的方法&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     Method method = methodList[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;RuntimeCategoryClass&#x27;s method: %s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;分类方法method2在objc_class的方法列表中&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.213</span> [<span class="number">561</span>:<span class="number">151847</span>] 测试objc_class中的方法列表是否包含分类中的方法</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] RuntimeCategoryClass<span class="string">&#x27;s method: method2</span></span><br><span class="line"><span class="string">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&#x27;</span>s method: method1</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] 分类方法method2在objc_class的方法列表中</span><br></pre></td></tr></table></figure><h3 id="5-4-2-Protocol操作函数"><a href="#5-4-2-Protocol操作函数" class="headerlink" title="5.4.2 Protocol操作函数"></a>5.4.2 Protocol操作函数</h3><p>Runtime提供了Protocol的一系列函数操作，函数包括：</p><h4 id="1-获取协议"><a href="#1-获取协议" class="headerlink" title="1. 获取协议"></a>1. 获取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_getProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line"><span class="function">Protocol **<span class="title">objc_copyProtocolList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-查询协议的信息"><a href="#2-查询协议的信息" class="headerlink" title="2. 查询协议的信息"></a>2. 查询协议的信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">protocol_getName</span><span class="params">(Protocol *proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_isEqual</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法描述数组</span></span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">protocol_copyMethodDescriptionList</span><span class="params">(Protocol *p, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   BOOL isRequiredMethod,BOOL isInstanceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="function">struct objc_method_description <span class="title">protocol_getMethodDescription</span><span class="params">(Protocol *p, SEL aSel, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *p, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"><span class="comment">// 获取协议遵守的协议</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">protocol_copyProtocolList</span><span class="params">(Protocol *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否遵守了另一个协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_conformsToProtocol</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-动态创建协议"><a href="#3-动态创建协议" class="headerlink" title="3. 动态创建协议"></a>3. 动态创建协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_allocateProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addMethodDescription</span><span class="params">(Protocol *proto_gen, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProperty</span><span class="params">(Protocol *proto_gen, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attrs, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加一个已注册的协议。proto必须正在构造中。addition则不能，必须是已注册的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProtocol</span><span class="params">(Protocol *proto, Protocol *addition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议。</span></span><br><span class="line"><span class="comment">// 创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerProtocol</span><span class="params">(Protocol *proto_gen)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="六、Block"><a href="#六、Block" class="headerlink" title="六、Block"></a>六、Block</h1><p>runtime中一些支持block操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@&quot;hello world!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</span><br></pre></td></tr></table></figure><h1 id="七、Runtime的应用"><a href="#七、Runtime的应用" class="headerlink" title="七、Runtime的应用"></a>七、Runtime的应用</h1><h2 id="7-1-获取系统提供的库相关信息"><a href="#7-1-获取系统提供的库相关信息" class="headerlink" title="7.1 获取系统提供的库相关信息"></a>7.1 获取系统提供的库相关信息</h2><p>主要函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的objectivec框架和动态库的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyImageNames</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getImageName</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyClassNamesForImage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：通过这些函数获取某个类所有的库，以及某个库中包含哪些类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定类所在动态库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;UIView&#x27;s Framework: %s&quot;</span>, <span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定库或框架中所有类的类名&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = <span class="built_in">objc_copyClassNamesForImage</span>(<span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)), &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(@<span class="string">&quot;class name: %s&quot;</span>, classes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.689</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] UIView<span class="number">&#x27;</span>s Framework: /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTopFrame</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIOnePartImageView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewSelectionBar</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerWheelView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTestParameters</span><br></pre></td></tr></table></figure><h2 id="7-2-对App的用户行为进行追踪"><a href="#7-2-对App的用户行为进行追踪" class="headerlink" title="7.2 对App的用户行为进行追踪"></a>7.2 对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来实现swizzle方法</span></span><br><span class="line"><span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></span><br><span class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></span><br><span class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (gOriginalViewDidAppear)(id, SEL, BOOL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newViewDidAppear</span><span class="params">(UIViewController *self, SEL _cmd, BOOL animated)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     <span class="built_in">gOriginalViewDidAppear</span>(self, _cmd, animated); <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     Method originalMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:));</span><br><span class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)<span class="built_in">method_getImplementation</span>(originalMethod);</span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">class_addMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:), (IMP) newViewDidAppear, <span class="built_in">method_getTypeEncoding</span>(originalMethod))) &#123;</span><br><span class="line">          <span class="built_in">method_setImplementation</span>(originalMethod, (IMP) newViewDidAppear);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做<a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">Cross Cutting Concerns</a>。</p><p>用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>。</p><p>目前有些第三方库可以很方便的使用AOP，比如<a href="https://github.com/steipete/Aspects">Aspects</a>。这里是使用<a href="https://github.com/okcomp/AspectsDemo">Aspects的范例</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;内容骨架来自戴铭老师文章&lt;a href=&quot;https://ming1016.github.io/2015/04/01/objc-runtime/&quot;&gt;Objc Runtime 总结&lt;/a&gt;，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>(七) dyld与Objc—_objc_init、map_images、load_images</title>
    <link href="https://tenloy.github.io/2021/09/28/dyld-objc.html"/>
    <id>https://tenloy.github.io/2021/09/28/dyld-objc.html</id>
    <published>2021-09-28T14:26:09.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前文回顾"><a href="#一、前文回顾" class="headerlink" title="一、前文回顾"></a>一、前文回顾</h2><p>上一篇<a href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html">(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>，大概梳理了dyld的加载流程，这一次主要展开<strong>“第八步 执行初始化方法”</strong>，其是我们日常紧密接触的OBJC Runtime初始化启动的上文。</p><p>先简单回顾一下Runtime的初始化之前的流程：</p><ol><li>内核XNU加载Mach-O</li><li>从XNU内核态将控制权转移到dyld用户态</li><li>dyld：<ol><li>设置运行环境</li><li>实例化ImageLoader加载所需的动态库、并进行链接(符号绑定、重定位)。每个image对应一个ImageLoader实例</li><li>进行images的初始化：先初始化动态库，再初始化可执行文件。这步过程中，<strong>Runtime会向dyld中注册回调函数。dyld会在每个image加载、初始化、移除时分别调用Runtime的回调函数：map_images、load_images、unmap_images</strong>. </li><li>最后找到主程序的入口main()函数并返回。</li></ol></li></ol><p>可以在程序中，通过符号断点的形式<code>Debug → breakpoints → create symbolic breakpoint</code>来看这几个函数的调用堆栈：</p><p>添加符号断点：</p><img src="/images/compilelink/35.png" alt="35" style="zoom:90%;" /><p>load_images的调用堆栈(之一)：</p><img src="/images/compilelink/31.png" alt="35" style="zoom:90%;" /><p>在进入 <code>libobjc</code> 之前，我们必须要先了解 OC 中类的底层结构，可以先阅读<a href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html">下篇</a>(如果已经熟悉，那略过)。</p><h2 id="二、-objc-init"><a href="#二、-objc-init" class="headerlink" title="二、_objc_init()"></a>二、_objc_init()</h2><p>通过方法的文档注释，可以大概了解它的作用：启动初始化，注册dyld中image相关的回调通知，由libSystem在库(image)的初始化之前调用。</p><h3 id="2-1-objc-init-源码实现"><a href="#2-1-objc-init-源码实现" class="headerlink" title="2.1 _objc_init()源码实现"></a>2.1 _objc_init()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init()"></a>2.2 tls_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程局部/本地存储(Thread Local Storage, TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</span></span><br><span class="line"><span class="comment">// 线程私有数据(Thread Specific Data, TSD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc&#x27;s key for pthread_getspecific</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _objc_pthread_key TLS_DIRECT_KEY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">tls_key_t</span> _objc_pthread_key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> tls init：线程本地存储的初始化。</span></span><br><span class="line"><span class="comment"> _objc_pthread_destroyspecific 是线程的销毁函数。以 TLS_DIRECT_KEY 为 Key，在线程的本地存储空间中保存线程对应对销毁函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="built_in">pthread_key_init_np</span>(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = <span class="built_in">tls_create</span>(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_key_init_np</code> 是属于 <code>libpthread</code> 库中的方法了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为静态键设置析构函数，因为它不是用pthread_key_create()创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_init_np</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配用于表示进程中线程特定数据的键，键对进程中的所有线程来说是全局的。</span></span><br><span class="line"><span class="comment"> * 创建线程特定数据时，所有线程最初都具有与该键关联的NULL值。</span></span><br><span class="line"><span class="comment"> * @param key 指向从进程中已分配的键</span></span><br><span class="line"><span class="comment"> * @param destructor 指向析构函数，destuctor的形参是线程与键关联的数据。在线程终止时调用该函数，以达到释放内存的目的</span></span><br><span class="line"><span class="comment"> * @return 成功返回0.其他任何返回值都表示出现了错误。如果出现下列任一情况，pthread_key_create()将失败并返回相应的值</span></span><br><span class="line"><span class="comment">       EAGAIN：key名称空间已用完</span></span><br><span class="line"><span class="comment">       ENOMEM：此进程中虚拟内存不足，无法创建新键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-runtime-init"><a href="#2-3-runtime-init" class="headerlink" title="2.3 runtime_init()"></a>2.3 runtime_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> objc &#123;</span><br><span class="line">  <span class="comment">// 主要用来为类统计分类、追加分类到类、清除分类数据、清除类数据。</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnattachedCategories</span> :</span> <span class="keyword">public</span> ExplicitInitDenseMap&lt;Class, category_list&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> UnattachedCategories unattachedCategories; </span><br><span class="line">  <span class="comment">// allocatedClasses 是已使用 objc_allocateClassPair allocated 过的所有类（和元类）的表</span></span><br><span class="line">  <span class="keyword">static</span> ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">init</span>(<span class="number">32</span>); <span class="comment">// 初始化分类的存储容器, 是Map</span></span><br><span class="line">    objc::allocatedClasses.<span class="built_in">init</span>(); <span class="comment">// 初始化类的存储容器，是Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-cache-t-init"><a href="#2-4-cache-t-init" class="headerlink" title="2.4 cache_t::init()"></a>2.4 cache_t::init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/restartable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述用户空间的可恢复范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_vm_address_t</span> location;     <span class="comment">// 指向可重启动section开头的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    length;       <span class="comment">// 锚定在location的section的长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    recovery_offs;<span class="comment">// 应该用于恢复的初始位置的偏移量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      flags;</span><br><span class="line">&#125; <span class="keyword">task_restartable_range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">  <span class="comment">// mach_msg_type_number_t 当前是 unsigned int 的别名，定义别名利于不同的平台做兼容</span></span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// kern_return_t 当前是 int 的别名</span></span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计objc_restartableRanges数组中location成员值不为空的task_restartable_range_t的数量</span></span><br><span class="line">  <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前任务注册一组可重启范围。Register a set of restartable ranges for the current task.</span></span><br><span class="line">  kr = <span class="built_in">task_restartable_ranges_register</span>(<span class="built_in">mach_task_self</span>(),</span><br><span class="line">                                        objc_restartableRanges, count);</span><br><span class="line">  <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册失败则停止运行</span></span><br><span class="line">  _objc_fatal(<span class="string">&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;</span>,</span><br><span class="line">              kr, <span class="built_in">mach_error_string</span>(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索 <code>objc_restartableRanges</code> 可看到，在 <code>_collecting_in_critical</code> 函数中有看到有对其的遍历读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 第一次申请或扩容；扩容时，会清空现有数据. 扩容系数不同平台有3/4、7/8 */</span></span></span><br><span class="line">  ▼ void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld);</span><br><span class="line">  <span class="comment">// 或 void cache_t::eraseNolock(const char *func); // 将整个缓存重置为未缓存查找</span></span><br><span class="line">    <span class="comment">/* 将指定的malloc的内存添加到稍后要释放的内存列表中。</span></span><br><span class="line"><span class="comment">       size用于收集的阈值。它不必精确地与块的大小相同。*/</span></span><br><span class="line">    ▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::collect_free</span><span class="params">(<span class="keyword">bucket_t</span> *data, <span class="keyword">mask_t</span> capacity)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* 尝试释放累积的失效缓存. collectALot更努力地释放内存 */</span></span></span><br><span class="line">      ▼ void cache_t::collectNolock(bool collectALot); </span><br><span class="line">          <span class="comment">/* 用于判断当前是否可以对旧的方法缓存（扩容后的旧的方法缓存表）进行收集释放</span></span><br><span class="line"><span class="comment">             返回 true 表示objc_msgSend（或其他缓存读取器(cache reader)）当前正在缓存中查找，并</span></span><br><span class="line"><span class="comment">             且可能仍在使用某些garbage。返回 false 的话表示 garbage 中的 bucket_t 没有被在使用。</span></span><br><span class="line"><span class="comment">             即当前有其它线程正在读取使用我们的旧的方法缓存表时，此时不能对旧的方法缓存表进行内存释放*/</span></span><br><span class="line">        ▼ <span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>);  <span class="comment">//(critical 危急的；临界的；关键的)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-dyld-objc-notify-register"><a href="#2-5-dyld-objc-notify-register" class="headerlink" title="2.5 _dyld_objc_notify_register()"></a>2.5 _dyld_objc_notify_register()</h3><p><code>_dyld_objc_notify_register</code> 函数仅供 objc runtime 使用，注册当 mapped、unmapped 和 initialized objc images 时要调用的处理程序。Dyld 将使用包含 <code>objc-image-info</code> section 的 images 数组回调 <code>mapped</code> 函数。</p><blockquote><p>在iOS 13系统中，iOS将全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p></blockquote><p>在 dyld3 中，<code>_dyld_objc_notify_register</code> 函数的实现逻辑有一些改变，此处不再赘述了。</p><ul><li>map_images : dyld 将 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : dyld 初始化 image 会触发该方法，进行+load的调用</li><li>unmap_image : dyld 将 image 移除时 , 会触发该函数</li></ul><h2 id="三、map-images"><a href="#三、map-images" class="headerlink" title="三、map_images()"></a>三、map_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped(映射、加载) in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-map-images-nolock"><a href="#3-1-map-images-nolock" class="headerlink" title="3.1 map_images_nolock()"></a>3.1 map_images_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理由dyld映射的给定图像。</span></span><br><span class="line"><span class="comment"> * 执行所有的类注册和修复(或延迟查找丢失的超类等)，并调用+load方法。</span></span><br><span class="line"><span class="comment"> * Info[]是自底向上的顺序，即libobjc将在数组中比任何链接到libobjc的库更早。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态变量，表示第一次调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hList 是统计 mhdrs 中的每个 mach_header 对应的 header_info</span></span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有必要，执行首次初始化。</span></span><br><span class="line">    <span class="comment">// 此函数在 ordinary library 初始化程序之前调用。</span></span><br><span class="line">    <span class="comment">// 延迟初始化，直到找到使用 objc 的图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是第一次加载，则准备初始化环境</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="built_in">preopt_init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 OBJC_PRINT_IMAGES 环境变量时，启动时则打印 images 数量。</span></span><br><span class="line">    <span class="comment">// 如：objc[10503]: IMAGES: processing 296 newly-mapped images... </span></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 class 的数量。根据总数调整各种表格的大小。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// typedef struct mach_header_64 headerType;</span></span><br><span class="line">            <span class="comment">// 取得指定 image 的 header 指针</span></span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 以 mdr 构建其 header_info，并添加到全局的 header 列表中（是一个链表，大概看源码到现在还是第一次看到链表的使用）。</span></span><br><span class="line">            <span class="comment">// 且通过 GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;); 读取 __objc_classlist 区中的 class 数量添加到 totalClasses 中，</span></span><br><span class="line">            <span class="comment">// 以及未从 dyld shared cache 中找到 mhdr 的 header_info 时，添加 class 的数量到 unoptimizedTotalClasses 中。</span></span><br><span class="line">            <span class="keyword">auto</span> hi = <span class="built_in">addHeader</span>(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里有两种情况下 hi 为空：</span></span><br><span class="line">            <span class="comment">// 1. mhdr 的 magic 不是既定的 MH_MAGIC、MH_MAGIC_64、MH_CIGAM、MH_CIGAM_64 中的任何一个</span></span><br><span class="line">            <span class="comment">// 2. 从 dyld shared cache 中找到了 mhdr 的 header_info，并且 isLoaded 为 true（）</span></span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #define MH_EXECUTE 0x2 /* demand paged executable file demand 分页可执行文件 */ </span></span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable&#x27;s size</span></span><br><span class="line">                <span class="comment">// 根据主要可执行文件的大小调整一些数据结构的大小</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">size_t</span> count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ⬇️ GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">                <span class="comment">// 获取 __objc_selrefs 区中的 SEL 的数量</span></span><br><span class="line">                _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// GETSECT(_getObjc2MessageRefs, message_ref_t, &quot;__objc_msgrefs&quot;); </span></span><br><span class="line">                <span class="comment">// struct message_ref_t &#123;</span></span><br><span class="line">                <span class="comment">//     IMP imp;</span></span><br><span class="line">                <span class="comment">//     SEL sel;</span></span><br><span class="line">                <span class="comment">// &#125;;</span></span><br><span class="line">                <span class="comment">// ⬇️ 获取 __objc_msgrefs 区中的 message 数量</span></span><br><span class="line">                _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                <span class="comment">// 打印 image 信息</span></span><br><span class="line">                <span class="comment">// 如：objc[10565]: IMAGES: loading image for /usr/lib/system/libsystem_blocks.dylib (has class properties) (preoptimized)</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, </span><br><span class="line">                             hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>() ? <span class="string">&quot; (has class properties)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">optimizedByDyld</span>()?<span class="string">&quot; (preoptimized)&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️</span></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until the executable itself is found. </span></span><br><span class="line">    <span class="comment">// 执行 one-time runtime initialization，必须推迟到找到可执行文件本身。</span></span><br><span class="line">    <span class="comment">// This needs to be done before further initialization.</span></span><br><span class="line">    <span class="comment">// 这需要在进一步初始化之前完成。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The executable may not be present in this infoList if the executable does not contain</span></span><br><span class="line">    <span class="comment">// Objective-C code but Objective-C is dynamically loaded later.</span></span><br><span class="line">    <span class="comment">// 如果可执行文件不包含 Objective-C 代码但稍后动态加载 Objective-C，则该可执行文件可能不会出现在此 infoList 中。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="comment">// 初始化 selector 表并注册内部使用的 selectors。</span></span><br><span class="line">        <span class="built_in">sel_init</span>(selrefCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️⬇️⬇️ 这里的 arr_init 函数超重要，可看到它内部做了三件事：</span></span><br><span class="line">        <span class="comment">// 1. 自动释放池的初始化（实际是在 TLS 中以 AUTORELEASE_POOL_KEY 为 KEY 写入 tls_dealloc 函数（自动释放池的销毁函数：内部所有 pages pop 并 free））</span></span><br><span class="line">        <span class="comment">// 2. SideTablesMap 初始化，也可理解为 SideTables 的初始化（为 SideTables 这个静态全局变量开辟空间）</span></span><br><span class="line">        <span class="comment">// 3. AssociationsManager 的初始化，即为全局使用的关联对象表开辟空间</span></span><br><span class="line">        <span class="comment">// void arr_init(void) </span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     AutoreleasePoolPage::init();</span></span><br><span class="line">        <span class="comment">//     SideTablesMap.init();</span></span><br><span class="line">        <span class="comment">//     _objc_associations_init();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">arr_init</span>();</span><br><span class="line">        </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在较低版本下 DYLD_MACOSX_VERSION_10_13 之前的版本中禁用 +initialize fork safety，大致看看即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dyld_get_program_sdk_version</span>() &lt; DYLD_MACOSX_VERSION_10_13) &#123;</span><br><span class="line">            DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                             <span class="string">&quot;safety enforcement because the app is &quot;</span></span><br><span class="line">                             <span class="string">&quot;too old (SDK version &quot;</span> SDK_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                             <span class="built_in">FORMAT_SDK</span>(<span class="built_in">dyld_get_program_sdk_version</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;<span class="built_in">mhdr</span>();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getsectiondata</span>(hi-&gt;<span class="built_in">mhdr</span>(), <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                                 <span class="string">&quot;safety enforcement because the app has &quot;</span></span><br><span class="line">                                 <span class="string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️ 下面就来到了最核心的地方</span></span><br><span class="line">    <span class="comment">// 以 header_info *hList[mhCount] 数组中收集到的 images 的 header_info 为参，直接进行 image 的读取</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把开始时初始化的静态局部变量 firstTime 置为 NO</span></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️</span></span><br><span class="line">    <span class="comment">// _read_images 看完再看下面的 loadImageFuncs 函数  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="comment">// 一切设置完毕后调用 image 加载函数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            <span class="built_in">func</span>(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_images_nolock</code> 就是：</p><ul><li>对 <code>const struct mach_header * const mhdrs[]</code> 参数的处理，把数组中的 <code>mach_header</code> 转换为 <code>header_info</code> 并存在 <code>header_info *hList[mhCount]</code> 数组中。</li><li>并统计 <code>totalClasses</code> 和 <code>unoptimizedTotalClasses</code> 的数量</li><li>然后调用下面的 <code>_read_images</code> 函数</li></ul><blockquote><p>在阅读_read_images()函数前，先来了解一下class在加载过程都有哪些状态，在objc中以怎样的数据结构来记录的。</p></blockquote><h3 id="3-2-class加载过程中的flag标志"><a href="#3-2-class加载过程中的flag标志" class="headerlink" title="3.2 class加载过程中的flag标志"></a>3.2 class加载过程中的flag标志</h3><p>当调用 runtime API 动态创建类的过程，包括三个步骤：</p><ul><li>调用<code>Class objc_allocateClassPair(...)</code>构建类；</li><li>添加必要的成员变量、方法等元素；</li><li>调用<code>void objc_registerClassPair(Class cls)</code>注册类；</li></ul><p>然而，runtime 从镜像（image）加载类的过程会更加精细，在加载类的不同阶段会被标记为不同的类型（还是<code>objc_class</code>结构体，只是<code>flags</code>不同），例如：</p><ul><li><strong>future class</strong>（未来要解析的类，也称懒加载类）<ul><li>named class（已确定名称类）：将<code>cls</code>标记为 named class，以<code>cls-&gt;mangledName()</code>类名为关键字添加到全局记录的<code>gdb_objc_realized_classes</code>哈希表中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>allocated class（已分配内存类）：将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的<code>allocatedClasses</code>哈希表中（无需关键字），表示已为类分配固定内存空间；</li></ul></li><li><strong>remapped class</strong>（已重映射类）</li><li><strong>realized class</strong>（已认识/实现类）</li><li>loaded class（已加载类）：已执行<code>load</code>方法的类</li><li>initialized class（已初始化类）：已执行<code>initialize()</code>方法的类</li></ul><blockquote><p>realized: adj. 已实现的; v. 意识到，认识到，理解；实现；把（概念等）具体表现出来.</p><p>OC 类在被使用之前（譬如调用类方法），需要进行一系列的初始化，譬如：指定 <code>superclass</code>、指定 <code>isa</code> 指针、<code>attach categories</code> 等等；libobjc 在 runtime 阶段就可以做这些事情，但是有些过于浪费，更好的选择是懒处理，这一举措极大优化了程序的执行速度。而 runtime 把对类的惰性初始化过程称为「realize」。</p><p>利用已经被 <code>realize</code> 的类含有 <code>RW_REALIZED</code> 和 <code>RW_REALIZING</code> 标记的特点，可以为项目找出无用类；因为没有被使用的类，一定没有被 <code>realized</code>。</p></blockquote><h4 id="3-2-1-class-rw-t-gt-flags"><a href="#3-2-1-class-rw-t-gt-flags" class="headerlink" title="3.2.1 class_rw_t-&gt;flags"></a>3.2.1 class_rw_t-&gt;flags</h4><p><code>class_rw_t</code>的<code>flags</code>为可读写。其中比较重要的一些值定义列举如下，均以RW_为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类是已实现/已认识/已初始化处理过的类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// 该类是尚未解析的unresolved future class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// 该类已经初始化。完成执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZED        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// 该类正在初始化。正在执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZING       (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// class_rw_t-&gt;ro是class_ro_t的堆拷贝。此时类的class_rw_t-&gt;ro是可写入的，拷贝之前ro的内存区域锁死不可写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_COPIED_RO          (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// class allocated but not yet registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTING       (1&lt;&lt;26)</span></span><br><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">// 该类的load方法已经调用过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOADED             (1&lt;&lt;23)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="comment">// 该类的实例可能存在关联对象。默认编译选项下，无需定义该位，因为都可能有关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类的实例具有特定的GC layout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_INSTANCE_SPECIFIC_LAYOUT      (1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">// 该类禁止在其实例上使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FORBIDS_ASSOCIATED_OBJECTS        (1&lt;&lt;20)</span></span><br><span class="line"><span class="comment">// 该类正在实现，但是未实现完成</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZING          (1&lt;&lt;19)</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-class-ro-t-gt-flags"><a href="#3-2-2-class-ro-t-gt-flags" class="headerlink" title="3.2.2 class_ro_t-&gt;flags"></a>3.2.2 class_ro_t-&gt;flags</h4><p><code>class_ro_t</code>的<code>flags</code>成员为只读。其中比较重要的一些值定义列举如下，均以<code>RO_</code>为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类是元类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_META               (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// 类是根类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_ROOT               (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// 类有CXX构造/析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_STRUCTORS  (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// 类有实现load方法</span></span><br><span class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3)</span></span><br><span class="line"><span class="comment">// 隐藏类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HIDDEN             (1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION          (1&lt;&lt;5)</span></span><br><span class="line"><span class="comment">// class has ro field for Swift metadata initializer callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)</span></span><br><span class="line"><span class="comment">// 类使用ARC选项编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARC             (1&lt;&lt;7)</span></span><br><span class="line"><span class="comment">// 类有CXX析构函数，但没有CXX构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_DTOR_ONLY  (1&lt;&lt;8)</span></span><br><span class="line"><span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)</span></span><br><span class="line"><span class="comment">// 类禁止使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FROM_BUNDLE        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is unrealized future class - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is realized - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure><h3 id="3-3-read-images"><a href="#3-3-read-images" class="headerlink" title="3.3 _read_images()"></a>3.3 _read_images()</h3><p>观看下面内容之前，如果对 OC 中 <code>Class</code>、<code>Category</code>、<code>Protocol</code>的实现结构(底层的结构体实现及成员变量)不熟悉，建议先看一下<a href="">Runtime(一)：面向对象(Class和Object)的基本数据结构</a>、<a href="">Runtime(二)：Category、Protocol的实现与加载</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 headerList 开头的链表中的 headers 进行初始处理</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    </span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态局部变量，如果是第一次调用 _read_images 则 doneOnce 值为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> launchTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测量 image 加载步骤的持续时间</span></span><br><span class="line">    <span class="comment">// 对应 objc-env.h 中的 OPTION( PrintImageTimes, OBJC_PRINT_IMAGE_TIMES, &quot;measure duration of image loading steps&quot;)</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EACH_HEADER 是给下面的 for 循环使用的宏，遍历 hList 数组中的 header_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><h4 id="1-是否是第一次加载"><a href="#1-是否是第一次加载" class="headerlink" title="1. 是否是第一次加载"></a>1. 是否是第一次加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1⃣️</span></span><br><span class="line"><span class="comment">// 第一次调用 _read_images 时，doneOnce 值为 NO，会进入 if 执行里面的代码 </span></span><br><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">    <span class="comment">// 把静态局部变量 doneOnce 置为 YES，之后调用 _read_images 都不会再进来</span></span><br><span class="line">    <span class="comment">// 第一次调用 _read_images 的时候，class、protocol、selector、category 都没有，</span></span><br><span class="line">    <span class="comment">// 需要创建容器来保存这些东西，此 if 内部，最后是创建一张存 class 的表。</span></span><br><span class="line">    doneOnce = YES;</span><br><span class="line">    </span><br><span class="line">    launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在低版本（swifit3 之前、OS X 10.11 之前）下禁用 non-pointer isa 时的一些打印信息，</span></span><br><span class="line"><span class="comment">// 为了减少我们的理解负担，这里直接进行了删除，想要学习的同学可以去看一下源码</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointers, OBJC_DISABLE_TAGGED_POINTERS, &quot;disable tagged pointer optimization of NSNumber et al.&quot;)</span></span><br><span class="line">    <span class="comment">// 禁用 NSNumber 等的 Tagged Pointers 优化时</span></span><br><span class="line">    <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">        <span class="comment">// 内部直接把 Tagged Pointers 用到的 mask 全部置为 0</span></span><br><span class="line">        <span class="built_in">disableTaggedPointers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION, &quot;disable obfuscation of tagged pointers&quot;)</span></span><br><span class="line">    <span class="comment">// 可开启 OBJC_DISABLE_TAG_OBFUSCATION，禁用 Tagged Pointer 的混淆。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机初始化 objc_debug_taggedpointer_obfuscator。</span></span><br><span class="line">    <span class="comment">// tagged pointer obfuscator 旨在使攻击者在存在缓冲区溢出或其他对某些内存的写控制的情况下更难将特定对象构造为标记指针。</span></span><br><span class="line">    <span class="comment">// 在设置或检索有效载荷值（payload values）时， obfuscator 与 tagged pointers 进行异或。</span></span><br><span class="line">    <span class="comment">// 它们在第一次使用时充满了随机性。</span></span><br><span class="line">    <span class="built_in">initializeTaggedPointerObfuscator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OPTION( PrintConnecting, OBJC_PRINT_CLASS_SETUP, &quot;log progress of class and category setup&quot;)</span></span><br><span class="line">    <span class="comment">// objc[26520]: CLASS: found 25031 classes during launch 在 objc-781 下在启动时有 25031 个类（包含所有的系统类和自定义类）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// namedClasses</span></span><br><span class="line">    <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">    <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPreoptimized 如果我们有一个有效的优化共享缓存（valid optimized shared cache），则返回 YES。</span></span><br><span class="line">    <span class="comment">// 然后是不管三目运算符返回的是 unoptimizedTotalClasses 还是 totalClasses，它都会和后面的 4 / 3 相乘，</span></span><br><span class="line">    <span class="comment">// 注意是 4 / 3</span></span><br><span class="line">    <span class="keyword">int</span> namedClassesSize = (<span class="built_in">isPreoptimized</span>() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// gdb_objc_realized_classes 是一张全局的哈希表，虽然名字中有 realized，但是它的名字其实是一个误称，</span></span><br><span class="line">    <span class="comment">// 实际上它存放的是不在 dyld shared cache 中的 class，无论该 class 是否 realized。</span></span><br><span class="line">    gdb_objc_realized_classes = <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 objc-781 下执行到这里时，会有如下打印:</span></span><br><span class="line">    <span class="comment">// objc[19881]: 0.04 ms: IMAGE TIMES: first time tasks</span></span><br><span class="line">    <span class="comment">// 这个过程花了 0.04 毫秒</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修复预编译时-selector-错乱问题"><a href="#2-修复预编译时-selector-错乱问题" class="headerlink" title="2. 修复预编译时 @selector 错乱问题"></a>2. 修复预编译时 @selector 错乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 注册并修正 selector references. Fix up @selector references</span></span><br><span class="line">  <span class="comment">//（其实就是把 image 的 __objc_selrefs 区中的 selector 放进全局的 selector 集合中，修改其中不一致的地址）</span></span><br><span class="line"><span class="comment">// 也就是当 SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); 中的 SEL 和通过 SEL sel = sel_registerNameNoLock(name, isBundle); 注册返回的 SEL 不同时，就把 sels 中的 SEL 修正为 sel_registerNameNoLock 中返回的地址。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 加锁 selLock</span></span><br><span class="line">      <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历 header_info **hList 中的 header_info</span></span><br><span class="line">      <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 如果指定的 hi 不需要预优化则跳过</span></span><br><span class="line">          <span class="keyword">if</span> (hi-&gt;<span class="built_in">hasPreoptimizedSelectors</span>()) <span class="keyword">continue</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 根据 mhdr()-&gt;filetype 判断 image 是否是 MH_BUNDLE 类型</span></span><br><span class="line">          <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">          <span class="comment">// 获取 __objc_selrefs 区中的 SEL</span></span><br><span class="line">          SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 记录数量</span></span><br><span class="line">          UnfixedSelectors += count;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// static objc::ExplicitInitDenseSet&lt;const char *&gt; namedSelectors;</span></span><br><span class="line">          <span class="comment">// 是一个静态全局 set，用来存放 Selector（名字，Selector 本身就是字符串）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历把 sels 中的所有 selector 放进全局的 selector 集合中   </span></span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          </span><br><span class="line">              <span class="comment">// sel_cname 函数内部实现是返回：(const char *)(void *)sel; 即把 SEL 强转为 char 类型</span></span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(sels[i]);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 注册 SEL，并返回其地址</span></span><br><span class="line">              SEL sel = <span class="built_in">sel_registerNameNoLock</span>(name, isBundle);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 如果 SEL 地址发生变化，则把它设置为相同</span></span><br><span class="line">              <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                  sels[i] = sel;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里打印注册并修正 selector references 用的时间</span></span><br><span class="line">  <span class="comment">// 在 objc-781 下打印：objc[27056]: 0.44 ms: IMAGE TIMES: fix up selector references</span></span><br><span class="line">  <span class="comment">// 耗时 0.44 毫秒</span></span><br><span class="line">  ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-readClass-读取类信息，修复future-classes"><a href="#3-readClass-读取类信息，修复future-classes" class="headerlink" title="3. readClass()读取类信息，修复future classes"></a>3. readClass()读取类信息，修复future classes</h4><p>通过 readClass 读取出来类的信息，修复未解析的future classes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="comment">// 发现 classes。修复 unresolved future classes。标记 bundle classes。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if any OS dylib has overridden its copy in the shared cache</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exists in iPhoneOS 3.1 and later </span></span><br><span class="line"><span class="comment">// Exists in Mac OS X 10.10 and later</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = <span class="built_in">dyld_shared_cache_some_image_overridden</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">mustReadClasses</span>(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="comment">// Image 已充分优化，我们无需调用 readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 __objc_classlist 区中的 classref_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从编译后的类列表中取出所有类，获取到的是一个 classref_t 类型的指针 </span></span><br><span class="line">    <span class="comment">// classref_t is unremapped class_t* ➡️ classref_t 是未重映射的 class_t 指针</span></span><br><span class="line">    <span class="comment">// typedef struct classref * classref_t; // classref_t 是 classref 结构体指针</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点 ⚠️⚠️⚠️⚠️ 在这里：readClass。</span></span><br><span class="line">        <span class="comment">// 我们留在下面单独分析。</span></span><br><span class="line">        Class newCls = <span class="built_in">readClass</span>(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// 类被移动但未被删除。目前，这种情况只发生在新类解析未来类时。</span></span><br><span class="line">            <span class="comment">// 非惰性地实现下面的类</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// realloc 原型是 extern void *realloc(void *mem_address, unsigned int newsize);</span></span><br><span class="line">            <span class="comment">// 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，</span></span><br><span class="line">            <span class="comment">// 如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，</span></span><br><span class="line">            <span class="comment">// 而后释放原来 mem_address 所指内存区域（注意：原来指针是自动释放，不需要使用 free），</span></span><br><span class="line">            <span class="comment">// 同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。</span></span><br><span class="line">            </span><br><span class="line">            resolvedFutureClasses = (Class *)<span class="built_in">realloc</span>(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现 classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 3.17 ms: IMAGE TIMES: discover classes</span></span><br><span class="line"><span class="comment">// 耗时 3.17 毫秒（和前面的 0.44 毫秒比，多出不少）</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-future-class的生成"><a href="#1-future-class的生成" class="headerlink" title="1) future class的生成"></a>1) future class的生成</h5><p><code>objc_class</code>的<code>isFuture()</code>函数，用于判断类是否为 future class。future class 对理解类的加载过程有重要作用。</p><p>首先看 <strong>future class 是如何生成的</strong> — <code>addFutureNamedClass()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 安装cls作为类结构，用于命名类(如果之后出现)。 </span></span><br><span class="line"><span class="comment"> 将传入的 cls 参数，配置为类名为 name的 future class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配 cls 所需的 class_rw_t、class_ro_t 的内存空间；</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 将 cls 的类名置为 name；</span></span><br><span class="line">    ro-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">// 3. 将 class_rw_t 的 RO_FUTURE 位置为1，RO_FUTURE 等于 RW_FUTURE；</span></span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RO_FUTURE; </span><br><span class="line"><span class="comment">// 4. 以 name 为关键字(key)，将 cls 添加到一个全局的哈希表 futureNamedClasses；</span></span><br><span class="line">    old = <span class="built_in">NXMapKeyCopyingInsert</span>(<span class="built_in">futureNamedClasses</span>(), name, cls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="comment">/* 返回一个map，key为 classname, value 为 unrealized future classes(Class实例)*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF’s classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为给定的类名分配一个未解析的未来类 unresolved future class</span></span><br><span class="line"><span class="comment"> * 如果已经分配，则返回任何现有分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *map = <span class="built_in">futureNamedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)<span class="built_in">NXMapGet</span>(map, name))) &#123;</span><br><span class="line">        <span class="comment">// 存在名为name的future class</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分配用于保存objc_class的内存空间</span></span><br><span class="line">    cls = _calloc_class(<span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构建名为name的future class并全局记录到 futureNamedClasses 哈希表</span></span><br><span class="line">    <span class="built_in">addFutureNamedClass</span>(name, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> Return the id of the named class.</span></span><br><span class="line"><span class="comment"> 如果该类不存在，则返回一个未初始化的类结构，该结构将在类加载时使用。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Class look_up_class(const char *name, </span></span><br><span class="line"><span class="comment">              bool includeUnconnected __attribute__((unused)), </span></span><br><span class="line"><span class="comment">              bool includeClassHandler __attribute__((unused))) // unconnected is OK，因为总有一天它会成为真正的class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cls = <span class="built_in">look_up_class</span>(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;FUTURE: found %p already in use for %s&quot;</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还没有名为name的class或future class。做一个。</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链向上追溯到 <code>Class objc_getFutureClass</code>，该函数并没有在 runtime 源代码中被调用到。而用于从 <code>namedFutureClasses</code> 哈希表中获取 future class 的<code>popFutureClass(...)</code> 函数是有间接通过<code>readClass(...)</code>函数被广泛调用。因此，<strong>构建 future class 的逻辑大多隐藏在 runtime 的内部实现中未公布，只有使用 future class 的逻辑是开源的</strong>。</p><h5 id="2-future-class的获取"><a href="#2-future-class的获取" class="headerlink" title="2) future class的获取"></a>2) future class的获取</h5><p> <code>popFutureNamedClass</code> 用于从 <code>futureNamedClasses</code> 哈希表中弹出类名为<code>name</code>的 future class，这是获取全局记录的 future class 的唯一入口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Removes the named class from the unrealized future class list, because it has been realized.</span></span><br><span class="line"><span class="comment"> * Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)<span class="built_in">NXMapKeyFreeingRemove</span>(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; <span class="built_in">NXCountMapTable</span>(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NXFreeMapTable</span>(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-future-class的使用-—-readClass"><a href="#3-future-class的使用-—-readClass" class="headerlink" title="3) future class的使用 — readClass"></a>3) future class的使用 — readClass</h5><p>readClass 用于读取<code>cls</code>中的类数据，关键处理逻辑表述如下：</p><ul><li>若 <code>futureNamedClasses</code> 哈希表中存在 <code>cls-&gt;mangledName()</code> 类名的 future class，则将<code>cls</code>重映射（remapping）到新的类 <code>newCls</code>（具体重映射过程在下面4小节中详细讨论），然后将 <code>newCls</code> 标记为 remapped class，以<code>cls</code>为关键字添加到全局记录的 <code>remappedClasses()</code> 哈希表中；</li><li>将<code>cls</code>标记为 named class，以 <code>cls-&gt;mangledName()</code> 类名为关键字添加到全局记录的 <code>gdb_objc_realized_classes</code> 哈希map中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的 <code>allocatedClasses</code> 哈希set中，表示已为类分配固定内存空间；</li></ul><blockquote><p>注意：传入<code>readClass(...)</code>的<code>cls</code>参数是<code>Class</code>类型，而函数返回结果也是<code>Class</code>，为什么读取类信息是“从类中读取类信息”这样怪异的过程呢？</p><p>其实是因为<code>cls</code>参数来源于 runtime 未开源的、从镜像（image）中读取类的过程。该过程输出的<code>objc_class</code>存在特殊之处：要么输出 future class，要么输出正常(normal)类但是其<code>bits</code>指向的是<code>class_ro_t</code>结构体而非<code>class_rw_t</code>，之所以如此是因为从镜像读取的是编译时决议的静态数据，本来就应该保存在<code>class_ro_t</code>结构体中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;<span class="built_in">nonlazyMangledName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的继承链上，存在既不是根类（RO_ROOT位为0）又没有超类的类，则为missingWeakSuperclass</span></span><br><span class="line">    <span class="comment">// 注意：这是唯一的向remappedClasses中添加nil值的入口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">missingWeakSuperclass</span>(cls)) &#123;</span><br><span class="line">        <span class="built_in">addRemappedClass</span>(cls, nil);</span><br><span class="line">        cls-&gt;<span class="built_in">setSuperclass</span>(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容旧版本libobjc的配置，可忽略</span></span><br><span class="line">    cls-&gt;<span class="built_in">fixupBackwardDeployingStableSwift</span>();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// 这个name已经被分配为future class，全局记录。</span></span><br><span class="line">            <span class="comment">// 将cls的内容拷贝到newCls(也就是future class)中，保存future class的rw中的数据。将cls-&gt;data设置为rw-&gt;ro</span></span><br><span class="line">            <span class="comment">// 以cls为关键字将构建的newCls添加到全局记录的remappedClasses哈希表中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;<span class="built_in">isAnySwift</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot;</span></span><br><span class="line">                            <span class="string">&quot;because the real class is too big.&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;<span class="built_in">setSuperclass</span>(cls-&gt;<span class="built_in">getSuperclass</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">initIsa</span>(cls-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line"></span><br><span class="line">            rw-&gt;<span class="built_in">set_ro</span>((<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">            <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;<span class="built_in">getName</span>());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// 已存在该类名的named class</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(mangledName == <span class="literal">nullptr</span> || <span class="built_in">getClassExceptSomeSwift</span>(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">// 一些Swift泛型类可以惰性地生成它们的名称</span></span><br><span class="line">            <span class="comment">// 将类添加到 named classes</span></span><br><span class="line">            <span class="built_in">addNamedClass</span>(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() &amp;&amp; <span class="string">&quot;Metaclass with lazy name must have a pointer to the corresponding nonmetaclass.&quot;</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() == cls &amp;&amp; <span class="string">&quot;Metaclass nonmetaclass pointer must equal the original class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将类添加到 allocated classes</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="comment">// 设置RO_FROM_BUNDLE位</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-future-class小结"><a href="#4-future-class小结" class="headerlink" title="4) future class小结"></a>4) future class小结</h5><p>从上文<code>readClass(...)</code>代码<code>if (Class newCls = popFutureNamedClass(mangledName))</code>分支内<code>free((void *)old_ro)</code>语句，得出在<code>cls</code>映射到<code>newCls</code>过程中，完全丢弃了 future class 的<code>ro</code>数据。最后，结合以上所有代码，可以归纳以下结论：</p><ul><li><p>Future class 类的有效数据实际上仅有：类名和<code>rw</code>。<code>rw</code>中的数据作用也非常少，仅使用<code>flags</code>的<code>RO_FUTURE</code>（实际上就是<code>RW_FUTURE</code>）标记类是 future class；</p></li><li><p>Future class 的作用是为指定类名的类，提前分配好内存空间，调用<code>readClass(...)</code>函数读取类时，才正式写入类的数据。 Future class 是用于支持类的懒加载机制；</p></li></ul><h4 id="4-remapped-重新映射-classes"><a href="#4-remapped-重新映射-classes" class="headerlink" title="4. remapped(重新映射) classes"></a>4. remapped(重新映射) classes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class list 和 nonlazy class list 仍未映射。</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    <span class="comment">// Class refs 和 super refs 被重新映射为消息调度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是修复重映射 classes，!noClassesRemapped() 在这里为 false，所以一般走不进来，</span></span><br><span class="line">    <span class="comment">// 将未映射 class 和 super class 重映射，被 remap 的类都是非懒加载的类</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">noClassesRemapped</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2ClassRefs, Class, &quot;__objc_classrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_classrefs 区中的类引用</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历 classrefs 中的类引用，如果类引用已被重新分配或者是被忽略的弱链接类，</span></span><br><span class="line">            <span class="comment">// 就将该类引用重新赋值为从重映射类表中取出新类</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// Fix up a class ref, in case the class referenced has been reallocated or is an ignored weak-linked class.</span></span><br><span class="line">                <span class="comment">// 修复 class ref，以防所引用的类已 reallocated 或 is an ignored weak-linked class。</span></span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2SuperRefs, Class, &quot;__objc_superrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_superrefs 区中的父类引用</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里打印修复重映射 classes 用的时间</span></span><br><span class="line">    <span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: remap classes</span></span><br><span class="line">    <span class="comment">// 耗时 0 毫秒，即 Fix up remapped classes 并没有执行 </span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> cacheSupportsProtocolRoots = <span class="built_in">sharedCacheSupportsProtocolRoots</span>();</span><br></pre></td></tr></table></figure><h5 id="1-future-class-的重映射"><a href="#1-future-class-的重映射" class="headerlink" title="1) future class 的重映射"></a>1) future class 的重映射</h5><p>在上面 <code>readClass()</code> 中有提到类的重映射，重映射的类被标记为 remapped class，并以映射前的类为关键字，添加到全局的<code>remappedClass</code>哈希表中。回顾<code>readClass()</code>函数中，类的重映射代码如下，关于处理过程的详细描述已注释到代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 若该类名已被标记为future class，则弹出该类名对应的future class 赋值给newCls</span></span><br><span class="line"><span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">    <span class="comment">// 2. rw记录future class的rw</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 3. future class的ro记为old_ro，后面释放其占用的内存空间并丢弃</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line">    <span class="comment">// 4. 将cls中的数据拷贝到newCls，主要是要沿用cls的isa、superclass和cache数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">    <span class="comment">// 5. rw记录cls的ro</span></span><br><span class="line">    rw-&gt;ro = (<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 6. 沿用future class的rw、cls的ro</span></span><br><span class="line">    newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    <span class="comment">// 7. 释放future class的ro占用的空间</span></span><br><span class="line">    <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 将newCls以cls为关键字添加到remappedClasses哈希表中</span></span><br><span class="line">    <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line">    </span><br><span class="line">    replacing = cls;</span><br><span class="line">    cls = newCls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合上面代码的详细注释，可知<code>cls</code>重映射到<code>newCls</code>后，<code>newCls</code>的数据保留了<code>cls</code>中的<code>superclass</code>、<code>cache</code>成员，但是<code>bits</code>中指向<code>class_rw_t</code>结构体地址的位域（<code>FAST_DATA_MASK</code>）指向了<strong>新的<code>class_rw_t</code>结构体</strong>。该结构体的<code>ro</code>指针指向<code>cls-&gt;data()</code>所指向的内存空间中保存的<code>class_ro_t</code>结构体，其他数据则是直接沿用 从<code>namedFutureClasses</code>哈希表中弹出的 future class 的<code>class_rw_t</code>结构体（通过future class 的<code>data()</code>方法返回）中数据。</p><blockquote><p>注意：虽然<code>objc_class</code>的<code>data()</code>方法声明为返回<code>class_rw_t *</code>，但是究其本质，它只是返回了<code>objc_class</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>标记的位域中保存的内存地址，该内存地址实际上可以保存任何类型的数据。在<code>Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)</code>函数中，传入的<code>cls</code>所指向的<code>objc_class</code>结构体有其特殊之处：<code>cls</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>位域，指向的内存空间保存的是<code>class_ro_t</code>结构体，并不是通常的<code>class_rw_t</code>。</p></blockquote><h5 id="2-通用类的重映射"><a href="#2-通用类的重映射" class="headerlink" title="2) 通用类的重映射"></a>2) 通用类的重映射</h5><p>通用的类重映射调用<code>static class remapClass(Class cls)</code>，注意当传入的<code>cls</code>类不在<code>remappedClasses</code>哈希表中时，直接返回<code>cls</code>本身；<code>static void remapClassRef(Class *clsref)</code>可对传入的<code>Class* clsref</code>重映射（改变<code>*clsref</code>的值），返回时<code>clsref</code>将 指向<code>*clsref</code>重映射后的类。类的重映射相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取remappedClasses，保存已重映射的所有类的全局哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">remappedClasses</span><span class="params">(<span class="keyword">bool</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态的全局哈希表，没有找到remove接口，只会无限扩张</span></span><br><span class="line">    <span class="keyword">static</span> NXMapTable *remapped_class_map = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remapped_class_map) <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">    <span class="keyword">if</span> (!create) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remapped_class_map is big enough to hold CF’s classes and a few others</span></span><br><span class="line">    <span class="built_in">INIT_ONCE_PTR</span>(remapped_class_map, </span><br><span class="line">                  <span class="built_in">NXCreateMapTable</span>(NXPtrValueMapPrototype, <span class="number">32</span>), </span><br><span class="line">                  <span class="built_in">NXFreeMapTable</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将oldcls重映射得到的newcls，以oldcls为关键字插入到remappedClasses哈希表中</span></span><br><span class="line"><span class="comment">// 注意：从代码透露出来的信息是，remappedClasses中只保存 future class 重映射的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRemappedClass</span><span class="params">(Class oldcls, Class newcls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;FUTURE: using %p instead of %p for %s&quot;</span>, </span><br><span class="line">                     (<span class="keyword">void</span>*)newcls, (<span class="keyword">void</span>*)oldcls, oldcls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = <span class="built_in">NXMapInsert</span>(<span class="built_in">remappedClasses</span>(YES), oldcls, newcls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cls的重映射类</span></span><br><span class="line"><span class="comment">// 注意：当remappedClasses为空或哈希表中不存在`cls`关键字，是返回`cls`本身，否则返回`cls`重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *map = <span class="built_in">remappedClasses</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (!map  ||  <span class="built_in">NXMapMember</span>(map, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Class的指针的重映射，返回时传入的clsref将 指向*clsref重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remapClassRef</span><span class="params">(Class *clsref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class newcls = <span class="built_in">remapClass</span>(*clsref);    </span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) *clsref = newcls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remap小结"><a href="#3-remap小结" class="headerlink" title="3) remap小结"></a>3) remap小结</h5><p>最后归纳出以下结论：</p><ul><li>Future class 进行重映射后，会返回新的类，保存在<code>remappedClasses</code>全局哈希表中；</li><li>正常类重映射返回类本身；</li><li>重映射的真正的目的是支持类的懒加载，懒加载类暂存为 future class 只记录类名及 future class 属性，在调用<code>readClass</code>才正式载入类数据。</li></ul><h4 id="5-类中如果有协议，读取协议"><a href="#5-类中如果有协议，读取协议" class="headerlink" title="5. 类中如果有协议，读取协议"></a>5. 类中如果有协议，读取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="comment">// 发现 protocols，修正 protocol refs。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个长度是 16 的 NXMapTable</span></span><br><span class="line">    NXMapTable *protocol_map = <span class="built_in">protocols</span>();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedProtocols</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache and we support roots</span></span><br><span class="line">    <span class="comment">// 如果这是来自 shared cache 的 image 并且我们 support roots，则跳过 reading protocols</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol in the shared cache is marked with isCanonical()</span></span><br><span class="line">    <span class="comment">// and that may not be true if some non-shared cache binary was chosen as the canonical definition</span></span><br><span class="line">    <span class="comment">// 启动后，我们确实需要遍历协议，因为 shared cache 中的协议用 isCanonical() 标记，如果选择某些非共享缓存二进制文件作为规范定义，则可能不是这样</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized &amp;&amp; cacheSupportsProtocolRoots) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>, hi-&gt;<span class="built_in">fname</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolList, protocol_t * const, &quot;__objc_protolist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protolist 区下的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Read a protocol as written by a compiler.</span></span><br><span class="line">        <span class="built_in">readProtocol</span>(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现并修正 protocols 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 5.45 ms: IMAGE TIMES: discover protocols</span></span><br><span class="line"><span class="comment">// 耗时 05.45 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-映射协议"><a href="#6-映射协议" class="headerlink" title="6. 映射协议"></a>6. 映射协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right answer already but we don&#x27;t know for sure.</span></span><br><span class="line"><span class="comment">// Preoptimized images 可能已经有了正确的答案，但我们不确定。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the shared cache definition of a protocol.</span></span><br><span class="line">    <span class="comment">// 在启动时，我们知道 preoptimized image refs 指向协议的 shared cache 定义。</span></span><br><span class="line">    <span class="comment">// We can skip the check on launch, but have to visit @protocol refs for shared cache images loaded later.</span></span><br><span class="line">    <span class="comment">// 我们可以跳过启动时的检查，但必须访问 @protocol refs 以获取稍后加载的 shared cache images。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; cacheSupportsProtocolRoots &amp;&amp; hi-&gt;<span class="built_in">isPreoptimized</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolRefs, protocol_t *, &quot;__objc_protorefs&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protorefs 区的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Fix up a protocol ref, in case the protocol referenced has been reallocated.</span></span><br><span class="line">        <span class="comment">// 修复 protocol ref，以防 protocol referenced 已重新分配。</span></span><br><span class="line">        <span class="built_in">remapProtocolRef</span>(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 @protocol references 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: fix up @protocol references</span></span><br><span class="line"><span class="comment">// 因为是第一次启动，则并不进行</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-加载分类"><a href="#7-加载分类" class="headerlink" title="7. 加载分类"></a>7. 加载分类</h4><p>把 category 的数据追加到原类中去！很重要。</p><p>这里并不会执行，didInitialAttachCategories 是一个静态全局变量，默认是 false，对于启动时出现的 categories，discovery 被推迟到 <code>_dyld_objc_notify_register</code> 调用完成后的第一个 <code>load_images</code> 调用。所以这里 if 里面的 Discover categories 是不会执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. 发现类别。</span></span><br><span class="line"><span class="comment">// 仅在完成 initial category attachment 后才执行此操作。</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// didInitialAttachCategories 是一个静态全局变量，默认是 false，</span></span><br><span class="line"><span class="comment">// static bool didInitialAttachCategories = false; 在load_images()函数体中，才会置为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Discover categories. 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: discover categories</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 所以这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其他线程在该线程完成其修复(thread finishes its fixups)之前调用新的category代码时，category discovery必须延迟以避免潜在的竞争。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +load 由 prepare_load_methods() 处理</span></span><br></pre></td></tr></table></figure><h4 id="8-realize非懒加载类-—-realized-class"><a href="#8-realize非懒加载类-—-realized-class" class="headerlink" title="8. realize非懒加载类 — realized class"></a>8. realize非懒加载类 — realized class</h4><p>懒加载：类没有实现 +load 函数，在使用的第一次才会加载，当我们给这个类的发送消息时，如果是第一次，在消息查找的过程中就会判断这个类是否加载，没有加载就会加载这个类。懒加载类在首次调用方法的时候，才会去调用 <code>realizeClassWithoutSwift</code> 函数去进行加载。</p><p>非懒加载：类的内部实现了 +load 函数，类的加载就会提前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="comment">// 实现非懒加载类（为了+load调用、静态实例）</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_nlclslist 区中的非懒加载类（即实现了 +load 函数的类）</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重映射类， 获取正确的类指针</span></span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// static void addClassTableEntry(Class cls, bool addMeta = true) &#123; ... &#125;</span></span><br><span class="line">        <span class="comment">// 将一个类添加到用来存储所有类的全局的 set 中（auto &amp;set = objc::allocatedClasses.get();）。</span></span><br><span class="line">        <span class="comment">// 如果 addMeta 为 true（默认为 true），也自动添加类的元类到这个 set 中。</span></span><br><span class="line">        <span class="comment">// 这个类可以通过 shared cache 或 data segments 成为已知类，但不允许已经在 dynamic table 中。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// allocatedClasses 是 objc 命名空间中的一个静态变量。</span></span><br><span class="line">        <span class="comment">// A table of all classes (and metaclasses) which have been allocated with objc_allocateClassPair.</span></span><br><span class="line">        <span class="comment">// 已使用 objc_allocateClassPair 分配空间的存储所有 classes（和 metaclasses）的 Set。</span></span><br><span class="line">        <span class="comment">// namespace objc &#123;</span></span><br><span class="line">        <span class="comment">//     static ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把 cls 放入 allocatedClasses 中，然后递归把 metaclass 放入 allocatedClasses 中</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 cls 是否是来自稳定的 Swift ABI 的 Swift 类</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">swiftMetadataInitializer</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class %s with a metadata initializer &quot;</span></span><br><span class="line">                            <span class="string">&quot;is not allowed to be non-lazy&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes We can&#x27;t disallow all Swift classes because of classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">            <span class="comment">// 也禁止 relocatable classes 我们不能因为像 Swift.__EmptyArrayStorage 这样的类而禁止所有 Swift 类</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现 Swift 之外的 classes</span></span><br><span class="line">        <span class="comment">// 对类 cls 执行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回类的真实类结构。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 大概是设置 ro rw 和一些标识位的过程，也包括递归实现父类（supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass), nil);）</span></span><br><span class="line">        <span class="comment">// 和元类（metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);），</span></span><br><span class="line">        <span class="comment">// 然后更新 cls 的父类和元类（cls-&gt;superclass = supercls; cls-&gt;initClassIsa(metacls);），</span></span><br><span class="line">        <span class="comment">// 将 cls 连接到其父类的子类列表（addSubclass(supercls, cls);）（操作 class_rw_t 的 Class firstSubclass; 和 Class nextSiblingClass; 两个成员变量），</span></span><br><span class="line">        <span class="comment">// 修正 cls 的方法列表、协议列表和属性列表，</span></span><br><span class="line">        <span class="comment">// 以及最后的附加任何未完成的 categories（主要包含 method list、protocol list、property list）</span></span><br><span class="line">        <span class="comment">//（objc::unattachedCategories.attachToClass）。</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Realize non-lazy classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.23 ms: IMAGE TIMES: realize non-lazy classes</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-realizeClassWithoutSwift"><a href="#1-realizeClassWithoutSwift" class="headerlink" title="1) realizeClassWithoutSwift()"></a>1) realizeClassWithoutSwift()</h5><p>调用<code>readClass(...)</code>读取类数据只是载入了类的<code>class_ro_t</code>静态数据，因此仍需要进一步配置<code>objc_class</code>的<code>class_rw_t</code>结构体的数据。这个过程为 class realizing，姑且称之为认识/实现类。具体包括：</p><ul><li>配置<code>class_rw_t</code>的<code>RW_REALIZED</code>、<code>RW_REALIZING</code>位；</li><li>根据<code>class_ro_t</code>的<code>RO_META</code>位的值，配置<code>class_rw_t</code>的<code>version</code>；</li><li>因为静态载入的父类、元类有可能被重映射，因此要保证类的父类、元类完成class realizing；</li><li>配置<code>class_rw_t</code>的<code>superclass</code>；</li><li>初始化<code>objc_class</code>的<code>isa</code>指针；</li><li>配置<code>ivarLayout</code>、<code>instanceSize</code>、<code>instanceStart</code>。该步骤非常重要，新版本 runtime 支持 non-fragile instance variables，类的<code>instanceStart</code>、<code>instanceSize</code>会根据父类的<code>instanceSize</code>动态调整，且需要按 WORD 对齐（TODO：后续在独立的文章中详细介绍）；</li><li>配置<code>class_rw_t</code>的<code>RO_HAS_CXX_STRUCTORS</code>、<code>RO_HAS_CXX_DTOR_ONLY</code>、<code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>；</li><li>添加子类/根类；</li><li>将<code>class_ro_t</code>中的基本方法列表、属性列表、协议列表，类的分类（category）中的方法列表等信息添加到<code>class_rw_t</code>中（TODO：后续在独立的文章中详细介绍）；</li></ul><p>实现 class realizing 的代码主要在<code>static Class realizeClassWithoutSwift(Class cls)</code>函数中，只需要知道其大致过程即可。具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* 对类 cls 执行首次初始化，包括分配其读写(read-write)数据。</span></span><br><span class="line"><span class="comment">* 不执行任何 Swift 端初始化。</span></span><br><span class="line"><span class="comment">* 返回类的真实类结构(real class structure)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        <span class="built_in">validateAlreadyRealizedClass</span>(cls);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls == <span class="built_in">remapClass</span>(cls));  <span class="comment">// // 传入的类必须存在于remappedClasses全局哈希表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 曾经是 a future class. 所以 rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        ro = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();  <span class="comment">// cls的rw指向class_rw_t结构体，ro指向class_ro_t结构体，维持原状</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(!isMeta);</span><br><span class="line">        cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常类(Normal class). 需要为rw分配内存，并将ro指针指向 传入的cls-&gt;data()所指向的内存空间</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmptyOrPreoptimizedInDisguise</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) cls-&gt;cache.<span class="built_in">setBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose an index for this class.</span></span><br><span class="line">    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现父类和元类，如果它们还没有实现。</span></span><br><span class="line">    <span class="comment">//   对于根类，这需要在上面设置RW_REALIZED之后完成。</span></span><br><span class="line">    <span class="comment">//   对于根元类，这需要在选择类索引之后完成。</span></span><br><span class="line">    <span class="comment">// (假设这些类都没有 Swift 内容，或者 Swift 的初始化程序(initializers)已经被调用)</span></span><br><span class="line">    <span class="comment">// (如果我们添加对 Swift 类的 ObjC 子类的支持，请修复这个假设是错误的。)</span></span><br><span class="line">    supercls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">getSuperclass</span>()), nil); <span class="comment">// 父类 realizing</span></span><br><span class="line">    metacls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()), nil);  <span class="comment">// 元类 realizing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// 元类不需要来自non pointer ISA 的任何特性</span></span><br><span class="line">        <span class="comment">// 这允许在objc_retain/objc_release中为类提供一个faspath。</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(); <span class="comment">// 配置RW_REQUIRES_RAW_ISA位。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为一些类或平台禁用 non-pointer isa</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;<span class="built_in">getName</span>(), <span class="string">&quot;OS_object&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;<span class="built_in">getSuperclass</span>()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;<span class="built_in">instancesRequireRawIsa</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这也是通过addSubclass()传播的</span></span><br><span class="line">            <span class="comment">// 但是 nonpointer isa 设置需要更早.</span></span><br><span class="line">            <span class="comment">// 特殊情况：instancerequirerawisa不从根类传播到根元类</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 配置RW_REQUIRES_RAW_ISA位</span></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于存在class remapping的可能性，因此需要更新父类及元类</span></span><br><span class="line">    cls-&gt;<span class="built_in">setSuperclass</span>(supercls);</span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整ivarLayout —— Reconcile(协调) instance variable offsets / layout</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整instanceSize —— Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 ro 或从父类传播关联对象禁止标志。</span></span><br><span class="line">    <span class="keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||</span><br><span class="line">        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))</span><br><span class="line">    &#123;</span><br><span class="line">        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此类连接到其父类的子类列表</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);  <span class="comment">// 添加父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rw中需要保存ro中的一些数据，例如ro中的基础方法列表、属性列表、协议列表</span></span><br><span class="line">    <span class="comment">// rw还需要载入分类的方法列表</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="built_in">methodizeClass</span>(cls, previously);  <span class="comment">// methodize: vt. 使…有条理；为…定顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-methodizeClass"><a href="#2-methodizeClass" class="headerlink" title="2) methodizeClass"></a>2) methodizeClass</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls&#x27;s method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;<span class="built_in">ext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装类自己实现的方法和属性。Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 将ro中的基本方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *list = ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, &amp;list, <span class="number">1</span>, YES, <span class="built_in">isBundleClass</span>(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.<span class="built_in">attachLists</span>(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的属性列表添加到rw的属性列表中</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的协议列表添加到rw的协议列表中</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类特殊处理。</span></span><br><span class="line">    <span class="comment">// 根类可以获得额外的方法实现(如果它们还没有的话). 这些适用于类别替换(category replacements)之前。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRootMetaclass</span>()) &#123;</span><br><span class="line">        <span class="built_in">addMethod</span>(cls, @<span class="built_in">selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories. 将分类中的方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当类重定位时，带有类方法的类别categories可能会注册在类本身而不是元类metaclass上。告诉attachToClass去查找这些。</span></span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-处理没有使用的类"><a href="#9-处理没有使用的类" class="headerlink" title="9. 处理没有使用的类"></a>9. 处理没有使用的类</h4><p>第一次启动时并不会执行，我们也可以看到 <code>resolvedFutureClasses</code> 中并没有记录到需要执行 <code>realizeClassWithoutSwift</code> 的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="comment">// 实现 newly-resolved future classes，以防 CF 操作它们</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class is not allowed to be future&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将此类及其所有子类标记为需要原始 isa 指针</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc[56474]: 0.00 ms: IMAGE TIMES: realize future classes</span></span><br><span class="line"><span class="comment">// 打印时间为 0.00 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( DebugNonFragileIvars, OBJC_DEBUG_NONFRAGILE_IVARS, &quot;capriciously rearrange non-fragile ivars&quot;)</span></span><br><span class="line"><span class="comment">//（反复无常地重新排列非脆弱的 ivars）</span></span><br><span class="line"><span class="comment">// 如果开启了 OBJC_DEBUG_NONFRAGILE_IVARS 这个环境变量，则会执行 realizeAllClasses() 函数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-lazily realizes 所有已知 image 中所有未实现的类。(即对已知的 image 中的所有类：懒加载和非懒加载类全部进行实现)</span></span><br><span class="line"><span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">    <span class="built_in">realizeAllClasses</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print preoptimization statistics</span></span><br><span class="line"><span class="comment">// 打印预优化统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)</span></span><br><span class="line"><span class="comment">// 日志预优化由 dyld shared cache 提供</span></span><br></pre></td></tr></table></figure><h4 id="10-log输出"><a href="#10-log输出" class="headerlink" title="10. log输出"></a>10. log输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (PrintPreopt) &#123;</span><br><span class="line">        <span class="comment">// 一些 log 输出...</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、load-images"><a href="#四、load-images" class="headerlink" title="四、load_images()"></a>四、load_images()</h2><h3 id="4-1-load-images-源码实现"><a href="#4-1-load-images-源码实现" class="headerlink" title="4.1 load_images()源码实现"></a>4.1 load_images()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 处理 dyld 映射的 images 中的 +load </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// didInitialAttachCategories 标记加载分类的，默认值为 false，</span></span><br><span class="line">    <span class="comment">// didCallDyldNotifyRegister 标记 _dyld_objc_notify_register 是否调用完成</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">loadAllCategories</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mh 中不包含 +load 就直接不加锁 return（且 without taking locks）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hasLoadMethods 函数是根据 `headerType *mhdr` 的 `__objc_nlclslist` 区和 `__objc_nlcatlist` 区中是否有数据，来判断是否有 +load 函数要执行。(即是否包含非懒加载类和非懒加载分类) </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loadMethodLock 是一把递归互斥锁（加锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现(Discover) +load 方法</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// runtimeLock 加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有要调用的 +load 方法(Class、SuperClass、Category中的)</span></span><br><span class="line">        <span class="built_in">prepare_load_methods</span>((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 调用获取到的所有 +load 方法：从调用中，可以看到依次调用父类、子类、分类的load方法</span></span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-loadAllCategories-分类加载"><a href="#4-2-loadAllCategories-分类加载" class="headerlink" title="4.2 loadAllCategories() 分类加载"></a>4.2 loadAllCategories() 分类加载</h3><h4 id="4-2-1-loadAllCategories"><a href="#4-2-1-loadAllCategories" class="headerlink" title="4.2.1 loadAllCategories()"></a>4.2.1 loadAllCategories()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAllCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-load-categories-nolock"><a href="#4-2-2-load-categories-nolock" class="headerlink" title="4.2.2 load_categories_nolock()"></a>4.2.2 load_categories_nolock()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">isStubClass</span>()) &#123;</span><br><span class="line">                <span class="comment">// Stub(桩) classes永远不会实现(realized)。Stub classes在初始化之前不知道它们的元类，因此我们必须将带</span></span><br><span class="line">                <span class="comment">// 有类方法或属性的类别添加到Stub classes本身。methodizeClass() 将找到它们并将它们适当地添加到元类中。</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 首先，将category注册到其目标类(target class)。</span></span><br><span class="line">                <span class="comment">// 然后，如果class is realized，则重建类的方法列表（等）。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，实例方法、协议、属性添加到类.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  </span><br><span class="line">                    cat-&gt;protocols ||  </span><br><span class="line">                    cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，类方法、协议添加到元类</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  </span><br><span class="line">                    cat-&gt;protocols  ||  </span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对应</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList2, category_t * const, &quot;__objc_catlist2&quot;);</span></span><br><span class="line">    <span class="comment">// _getObjc2CategoryList 取得 DATA 段 &quot;__objc_catlist&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">    <span class="comment">// _getObjc2CategoryList2 取得 DATA 段 &quot;__objc_catlist2&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist2</span>(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-attachCategories"><a href="#4-2-3-attachCategories" class="headerlink" title="4.2.3 attachCategories()"></a>4.2.3 attachCategories()</h4><ul><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中。后面参与编译的Category数据，会在数组的前面。</p></li><li><p>将合并后的分类数据(方法、属性、协议)，插入到类原来数据的前面。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将方法列表、属性和协议从categories附加到class。</span></span><br><span class="line"><span class="comment">// 假设cats_list中的所有categories都已加载，并按加载顺序排序，最老的类别优先。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">attachCategories</span>(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintReplacedMethods)) &#123;</span><br><span class="line">        <span class="built_in">printReplacements</span>(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在发布期间，只有少数类的类别超过 64 个。</span></span><br><span class="line"><span class="comment"> 这使用了一个小stack，避免了 malloc。</span></span><br><span class="line"><span class="comment"> Categories 必须以正确的顺序添加，即从后到前。为了通过分块(chunking)来做到这一点，我们从前到后迭代cats_list，向后构建本地缓冲区，</span></span><br><span class="line"><span class="comment"> 并在块上调用attachLists。 attachLists将列表放在前面，因此最终结果按预期顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                <span class="built_in">prepareMethodLists</span>(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                           NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">            <span class="built_in">flushCaches</span>(cls, __func__, [](Class c)&#123;</span><br><span class="line">                <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">                <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">                <span class="keyword">return</span> !c-&gt;cache.<span class="built_in">isConstantOptimizedCache</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-hasLoadMethods"><a href="#4-3-hasLoadMethods" class="headerlink" title="4.3 hasLoadMethods()"></a>4.3 hasLoadMethods()</h3><p>根据 <code>headerType *mhdr</code> 的 <code>__objc_nlclslist</code> 区和 <code>__objc_nlcatlist</code> 区中是否有数据，来判断是否有 <code>+load</code> 函数要执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn&#x27;t take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 1. 首先去看类列表中，有没有load方法</span></span><br><span class="line">    <span class="comment">// 读取__DATA段(Segment)中的__objc_nlclslist区(section)中的非懒加载类的列表。判断count是否大于1，大于1说明有load方法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 去所有的category中看，是否有load方法</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 读取__DATA段中的__objc_nlcatlist区中非懒加载分类的列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-prepare-load-methods"><a href="#4-3-prepare-load-methods" class="headerlink" title="4.3 prepare_load_methods()"></a>4.3 prepare_load_methods()</h3><p>获取所有要调用的 +load 方法（父类、子类、分类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlclslist 区的数据，即获取所有非懒加载类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23) // class +load has been called</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span></span><br><span class="line">    <span class="comment">// 需要调用 +load 的 classes 列表</span></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span></span><br><span class="line">    <span class="comment">// 用于下面 call_load_methods 函数调用 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部会递归调用，从传入的cls依次向上查找superClass，并调用add_class_to_loadable_list方法，将实现了load方法的类的：Class cls、IMP method收集</span></span><br><span class="line">        <span class="comment">// 父类、子类都通过该方法收集出来，父类们先被收集，即先被调用</span></span><br><span class="line">        <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlcatlist 区的数据，即获取所有非懒加载分类</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历这些分类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// weak-linked class：</span></span><br><span class="line">        <span class="comment">//   如果我们在一个库中使用新版本系统的一些特性API，但又想程序可以在低版本系统上运行，这个时候对这些符号使用弱引用就好。</span></span><br><span class="line">        <span class="comment">//   使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL。</span></span><br><span class="line">        <span class="comment">//   有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用(weak link)整个framework就好</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果分类所属的类没有实现就先去实现</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要调用 +load 的 categories 列表</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          static struct loadable_category *loadable_categories = nil;</span></span><br><span class="line"><span class="comment">          struct loadable_category &#123;</span></span><br><span class="line"><span class="comment">              Category cat;  // may be nil</span></span><br><span class="line"><span class="comment">              IMP method;</span></span><br><span class="line"><span class="comment">          &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历这些分类，并将Category cat、IMP method收集到 loadable_categories 数组中保存</span></span><br><span class="line">        <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-1-schedule-class-load"><a href="#4-3-1-schedule-class-load" class="headerlink" title="4.3.1 schedule_class_load"></a>4.3.1 schedule_class_load</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule_class_load 将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法。（用于后续 call_load_methods 函数调用）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class +load has been called</span></span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RW_LOADED 是 class +load 已被调用的掩码</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">// 优先处理 superclass 的 +load 函数</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line">    <span class="comment">// struct loadable_class &#123;</span></span><br><span class="line">    <span class="comment">//    Class cls;  // may be nil</span></span><br><span class="line">    <span class="comment">//    IMP method;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span></span><br><span class="line">    <span class="comment">// loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span></span><br><span class="line">    <span class="comment">// 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 RW_LOADED 设置到类的 Flags 中</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class cls has just become connected. Schedule it for +load if it implements a +load method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 class 中获取 load 方法</span></span><br><span class="line">    method = cls-&gt;<span class="built_in">getLoadMethod</span>();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 判断当前 loadable_classes 这个数组是否已经被全部占用</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 3. 在当前数组的基础上扩大数组的大小：realloc</span></span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="built_in"><span class="keyword">sizeof</span></span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 把传入的 class 以及对应的方法的实现IMP加到列表中</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-call-load-methods"><a href="#4-4-call-load-methods" class="headerlink" title="4.4 call_load_methods()"></a>4.4 call_load_methods()</h3><p><code>+load</code> 函数的调用顺序：父类 -&gt; 子类 -&gt; 分类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment"> * Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment"> * Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="comment">// 重入调用什么都不做；最外层的调用将完成工作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果正在 loading 则 return，</span></span><br><span class="line">    <span class="comment">// 保证当前 +load 方法同时只有一次被调用</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自动释放池</span></span><br><span class="line">    <span class="keyword">void</span> *pool = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 不停调用类的 + load 方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span></span><br><span class="line">            <span class="built_in">call_class_loads</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 分类中的 +load 函数， 只调用一次 call_category_loads</span></span><br><span class="line">        <span class="comment">// 因为上面的 call_class_loads 函数内部，已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，否则循环就结束了。 </span></span><br><span class="line">        more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    <span class="comment">// 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动释放池进行 pop</span></span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记处理完成了，可以进行下一个了</span></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-关于-load-方法的几个QA"><a href="#4-5-关于-load-方法的几个QA" class="headerlink" title="4.5 关于 +load 方法的几个QA"></a>4.5 关于 +load 方法的几个QA</h3><p>Q: +load的应用？</p><p>A: <code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p><p>由于它的调用<em>不是惰性</em>(non-lazy)的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>的绝佳时机。</p><p>因为 load 调用时机过早，并且当多个 Class 没有关联（继承与派生），我们无法知道 Class 中 load 方法的优先调用关系，所以一般不会在 load 方法中引入其他的类，这是在开发当中需要注意的。</p><p>不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p><p>Q: 重载自己 Class 的 +load 方法时需不需要调父类？</p><p>A: runtime 负责按继承顺序递归调用，所以我们不能调 super</p><p>Q: 在自己 Class 的 +load 方法时能不能替换系统 framework（比如 UIKit）中的某个类的方法实现</p><p>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p><p>Q: 重载 +load 时需要手动添加 @autoreleasepool 么？</p><p>A: 不需要，在 runtime 调用 +load 方法前后是加了 objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop() 的。</p><p>Q: 想让一个类的 +load 方法被调用是否需要在某个地方 import 这个文件</p><p>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，+load 方法就会被调用（Reveal SDK 就是利用这一点，只要引入到工程中就能工作）</p><h2 id="五、类的加载过程总结"><a href="#五、类的加载过程总结" class="headerlink" title="五、类的加载过程总结"></a>五、类的加载过程总结</h2><p>类存在懒加载机制，懒加载类先标记为 future class，正式加载 future class 数据需要调用<code>readClass(...)</code>方法，对 future class 进行重映射（remapping）；</p><p>截止至完成 class realizing，类的加载过程大致如下图所示。</p><ul><li>future class列是懒加载类（future class）的流程，经过了“添加懒加载类-&gt;加载懒加载类信息-&gt;懒加载类重映射-&gt;实现懒加载类”四步；</li><li>normal class列是普通的非懒加载类的加载流程，只经过“加载类信息-&gt;实现类”两个步骤。</li></ul><img src="/images/compilelink/37.png" alt="36" style="zoom:88%;" /><p>类完成 class realizing 后，还需要执行类及分类中的<code>load()</code>方法，最后在程序运行过程中第一次调用类的方法时（实现逻辑在<code>IMP lookUpImpOrForward(...)</code>函数中）触发<code>isInitialized()</code>检查，若未初始化，则需要先执行类的<code>initialize()</code>方法。至此，类正式加载完成。</p><blockquote><p>注意：最后的 class initializing 严格意义上应该不属于类的加载过程，可以将其归为独立的类初始化阶段。类的加载在<code>load()</code>方法执行后就算是完成了。</p></blockquote><h2 id="六、unmap-images"><a href="#六、unmap-images" class="headerlink" title="六、unmap_images()"></a>六、unmap_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Process the given image which is about to be unmapped by dyld.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="built_in">unmap_image_nolock</span>(mh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-unmap-image-nolock"><a href="#6-1-unmap-image-nolock" class="headerlink" title="6.1 unmap_image_nolock()"></a>6.1 unmap_image_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image_nolock</span>(<span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing 1 newly-unmapped image...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find the runtime&#x27;s header_info struct for the image</span></span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;<span class="built_in">mhdr</span>() == (<span class="keyword">const</span> headerType *)mh) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: unloading image for %s%s%s\n&quot;</span>, </span><br><span class="line">                     hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                     hi-&gt;<span class="built_in">mhdr</span>()-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _unload_image(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove header_info from header list</span></span><br><span class="line">    <span class="built_in">removeHeader</span>(hi);</span><br><span class="line">    <span class="built_in">free</span>(hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-unload-image"><a href="#6-2-unload-image" class="headerlink" title="6.2 _unload_image()"></a>6.2 _unload_image()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _unload_image</span></span><br><span class="line"><span class="comment">* Only handles MH_BUNDLE for now.</span></span><br><span class="line"><span class="comment">* Locking: write-lock and loadMethodLock acquired by unmap_image</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _unload_image(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload unattached categories and categories waiting for +load.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore __objc_catlist2. We don&#x27;t support unloading Swift</span></span><br><span class="line">    <span class="comment">// and we never will.</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist = hi-&gt;<span class="built_in">catlist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme for MH_DYLIB cat&#x27;s class may have been unloaded already</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// unattached list</span></span><br><span class="line">        objc::unattachedCategories.<span class="built_in">eraseCategoryForClass</span>(cat, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +load queue</span></span><br><span class="line">        <span class="built_in">remove_category_from_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload classes.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather classes from both __DATA,__objc_clslist </span></span><br><span class="line">    <span class="comment">// and __DATA,__objc_nlclslist. arclite&#x27;s hack puts a class in the latter</span></span><br><span class="line">    <span class="comment">// only, and we need to unload that class if we unload an arclite image.</span></span><br><span class="line"></span><br><span class="line">    objc::DenseSet&lt;Class&gt; classes&#123;&#125;;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classlist = hi-&gt;<span class="built_in">nlclslist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First detach classes from each other. Then free each class.</span></span><br><span class="line">    <span class="comment">// This avoid bugs where this loop unloads a subclass before its superclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">remove_class_from_loadable_list</span>(cls);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls-&gt;<span class="built_in">ISA</span>(), YES);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">free_class</span>(cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        <span class="built_in">free_class</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX FIXME -- Clean up protocols:</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/9033191&gt; Support unloading protocols at dylib/image unload time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme DebugUnload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903965201530888#heading-0">Runtime源代码解读2（类和对象）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前文回顾&quot;&gt;&lt;a href=&quot;#一、前文回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前文回顾&quot;&gt;&lt;/a&gt;一、前文回顾&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://tenloy.github.io/2021/09/27/compil</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</title>
    <link href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html"/>
    <id>https://tenloy.github.io/2021/09/27/compile-dynamic-link.html</id>
    <published>2021-09-27T14:26:09.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、动态链接"><a href="#一、动态链接" class="headerlink" title="一、动态链接"></a>一、动态链接</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个个单独的可执行文件。</p><p>动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前主流的操作系统几乎都支持动态链接这种方式。</p><p>link 这个过程就是将加载进来的二进制变为可用状态的过程。简单来说就是：<code>rebase =&gt; binding</code>。先来介绍动态链接中的几个概念：</p><h3 id="1-1-rebase"><a href="#1-1-rebase" class="headerlink" title="1.1 rebase"></a>1.1 rebase</h3><p>rebase就是指针修正的过程。</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。而<strong>data</strong>段中的数据也会存在<strong>引用</strong>关系。 我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(相对于text段开始的偏移)。 </p><p>当二进制加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。 这个过程就是rebase的过程。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h3 id="1-2-bind"><a href="#1-2-bind" class="headerlink" title="1.2 bind"></a>1.2 bind</h3><blockquote><p>“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。</p></blockquote><p>bind就是符号绑定的过程。</p><p>为什么要bind? 因为符号在不同的库里面。</p><p>举个简单的例子，我们代码里面调用了 <code>NSClassFromString</code>. 但是<code>NSClassFromString</code>的代码和符号都是在 <code>Foundation.framework</code> 这个动态库里面。而在程序未加载之前，我们的代码是不知道<code>NSLog</code>在哪里的，于是编译器就编译了一个 <strong>stub</strong> 来调用 <code>NSClassFromString</code>:</p><img src="/images/compilelink/39.png" alt="39" style="zoom:97%;" /><p>可以看到，我们的代码里面直接从 pc + 0x3701c的地方取出来一个值，然后直接br， 也就是认为这个值就是 <code>NSClassFromString</code>的真实地址了。我们再看看这个位置的值是啥：</p><img src="/images/compilelink/40.png" alt="40" style="zoom:100%;" /><p>也就是说，这块地址的8个字节会在<strong>bind</strong>之后存入的就是 <code>NSClassFromString</code>的代码地址， 那么就实现了真正调用 <code>NSClassFromString</code>的过程。</p><p>上面我们知道了为啥要<strong>bind</strong>. 那是如何bind的呢？ bind又分为哪些呢？</p><h4 id="1-2-1-怎么bind"><a href="#1-2-1-怎么bind" class="headerlink" title="1.2.1 怎么bind"></a>1.2.1 怎么bind</h4><p>首先 mach-o 的 LoadCommand里面的会有一个cmd来描述 dynamic loader info，数据结构与示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下的偏移量是相对于目标文件/可执行文件的起始地址，注意后者的起始地址一般不会是0，寻址时要加上</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dyld_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmd;            <span class="comment">/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmdsize;        <span class="comment">/* sizeof(struct dyld_info_command) */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_off;     <span class="comment">/* file offset to rebase info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_size;    <span class="comment">/* size of rebase info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_off;       <span class="comment">/* file offset to binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_size;      <span class="comment">/* size of binding info  */</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Some C++ programs require dyld to unique symbols so that all images in the process use the same copy of some code/data. </span></span><br><span class="line"><span class="comment">    This step is done after binding. </span></span><br><span class="line"><span class="comment">    The content of the weak_bind info is an opcode stream like the bind_info. But it is sorted alphabetically by symbol name. This enable dyld to walk all images with weak binding information in order and look for collisions. </span></span><br><span class="line"><span class="comment">    If there are no collisions, dyld does no updating. That means that some fixups are also encoded in the bind_info. </span></span><br><span class="line"><span class="comment">    For instance, all calls to &quot;operator new&quot; are first bound to libstdc++.dylib using the information in bind_info. Then if some image overrides operator new that is detected when the weak_bind information is processed and the call to operator new is then rebound.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_off;  <span class="comment">/* file offset to weak binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_size; <span class="comment">/* size of weak binding info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_off;  <span class="comment">/* file offset to lazy binding info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_size; <span class="comment">/* size of lazy binding infs */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_off;     <span class="comment">/* file offset to export info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_size;    <span class="comment">/* size of export infs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析出来会得到这样的信息：</p><ul><li><code>rebase</code>：就是针对 “mach-o在加载到虚拟内存中不是固定的首地址” 这一现象做数据修正的过程。一般可执行文件在没有ASLR造成的首地址不固定的情况下，装载进虚拟地址中的首地址都是固定的，比如：Linux下一般都是<code>0x08040000</code>，Windows下一般都是<code>0x0040000</code>，Mach-O的TEXT地址在__PageZero之后的<code>0x100000000</code>地址.</li><li><code>binding</code>：就是将这个二进制调用的外部符号进行绑定的过程。 比如我们objc代码中需要使用到NSObject，即符号<code>_OBJC_CLASS_$_NSObject</code>，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</li><li><code>lazyBinding</code>：就是在加载动态库的时候不会立即binding，当时当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。 lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。</li><li><code>weakBinding</code>：OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</li></ul><img src="/images/compilelink/41.png" alt="41" style="zoom:90%;" /><p>可以看到，这里面记录了二进制data段里面哪些是 rebase信息，哪些是binding信息：</p><img src="/images/compilelink/42.png" alt="42" style="zoom:78%;" /><p>可以看到binding info的数据结构，bind的过程根据不同的opcode解析出不同的信息，在opcode为<code>BIND_OPCODE_DO_BIND</code>的时候，会执行<code>bindLocation</code>来进行bind。</p><p>截取了 bindLocation 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">ImageLoaderMachO::bindLocation</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context,...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// do actual update</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>* locationToFix = (<span class="keyword">uintptr_t</span>*)location;</span><br><span class="line">    <span class="keyword">uint32_t</span>* loc32;</span><br><span class="line">    <span class="keyword">uintptr_t</span> newValue = value+addend;</span><br><span class="line">    <span class="keyword">uint32_t</span> value32;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_POINTER:</span><br><span class="line">            <span class="comment">// test first so we don&#x27;t needless dirty pages</span></span><br><span class="line">            <span class="keyword">if</span> ( *locationToFix != newValue )</span><br><span class="line">                *locationToFix = newValue;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_ABSOLUTE32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)newValue;</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_PCREL32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)(newValue - (((<span class="keyword">uintptr_t</span>)locationToFix) + <span class="number">4</span>));</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad bind type %d&quot;</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， bind过程也不是单纯的就是把符号地址填过来就好了， 还有type和addend的逻辑。不过一般不多见，大部分都是<code>BIND_TYPE_POINTER</code>.</p><p>addend 一般用于要bind某个数组中的某个子元素时，记录这个子元素在数组的偏移。</p><h4 id="1-2-2-Lazy-Bind"><a href="#1-2-2-Lazy-Bind" class="headerlink" title="1.2.2 Lazy Bind"></a>1.2.2 Lazy Bind</h4><p>延迟加载是为了启动速度。上面看到bind的过程，发现bind的过程需要查到对应的符号再进行bind. 如果在启动的时候，所有的符号都立即bind成功，那么势必拖慢启动速度。</p><p>其实很多符号都是LazyBind的。就是第一次调用到才会真正的bind.</p><p>其实刚才截图的 <code>imp___la_symbol_ptr__objc_getClass</code> 就是一个 LazyBind 的符号。 图中的 0x10d6e8 指向了 <code>stub_helper</code> 这个section中的代码。</p><img src="/images/compilelink/43.png" alt="43" style="zoom:90%;" /><p>如上图中</p><ul><li>先取了 <code>0x10d6f0</code> 的 4个字节数据存入 w16. 这个数据其实是 lazy bind info段的偏移</li><li>然后走到 0x10d6d0, 取出 ImageLoader cache, 存入 x17</li><li>把 lazy bind info offset 和 ImageLoaderCache 存入栈上。</li><li>然后取出 dyld_stub_binder的地址，存入x16. 跳转 dyld_stub_binder</li><li>dyld_stub_binder 会根据传入的 lazy bind info的 offset来执行真正的bind. bind结束后，刚才看到的 <code>0x10d6e8</code> 这个地址就变成了 <code>NSClassFromString</code>。就完成了LazyBind的过程。</li></ul><p><code>dyld_stub_binder</code>的源码此处不再展示。</p><h4 id="1-2-3-Weak-Bind"><a href="#1-2-3-Weak-Bind" class="headerlink" title="1.2.3 Weak Bind"></a>1.2.3 Weak Bind</h4><p>OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</p><h2 id="二、库-静态库和动态库"><a href="#二、库-静态库和动态库" class="headerlink" title="二、库: 静态库和动态库"></a>二、库: 静态库和动态库</h2><p>库(Library)，是我们在开发中的重要角色，库的作用在于代码共享、模块分割以及提升良好的工程管理实践。说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p><p>为什么要用库？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件(<strong>静态库和动态库的共同点就是不会暴露内部具体的代码信息</strong>)。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p><p>根据库在使用的时候 Link 时机或者说方式(静态链接、动态链接)，库分为静态库和动态库。</p><h3 id="2-1-静态库"><a href="#2-1-静态库" class="headerlink" title="2.1 静态库"></a>2.1 静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，linux 下的.a，Mac 下的 .a .framework）。之所以叫做静态，是因为静态库在<code>链接时</code>会被完整地拷贝一份到可执行文件中(会使最终的可执行文件体积增大)。被多个程序使用就会有多份冗余拷贝。如果更新静态库，需要重新编译一次可执行文件，重新链接新的静态库。</p><h3 id="2-2-动态库"><a href="#2-2-动态库" class="headerlink" title="2.2 动态库"></a>2.2 动态库</h3><p>动态库即动态链接库。与静态库相反，动态库在编译时并不会被拷贝到可执行文件中，可执行文件中只会存储指向动态库的引用(使用了动态库的符号、及对应库的路径等)。等到程序<code>运行时</code>，动态库才会被真正加载进来，此时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。</p><p>动态库的优点是：</p><ul><li><strong>减少可执行文件体积</strong>：相比静态链接，动态链接在编译时不需要打进去(不需要拷贝到每个可执行文件中)，所以可执行文件的体积要小很多。</li><li><strong>代码共用</strong>：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份(因为这个原因，动态库也被称作<strong>共享库</strong>)。</li><li><strong>易于维护</strong>：使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</li></ul><p>常见的可执行文件的形式：</p><ul><li>Linux系统中，ELF动态链接文件被称为<strong>动态共享对象</strong>(<code>DSO，Dynamic SharedObjects</code>)，简称共享对象，一般都是以 <code>.so</code> 为扩展名的一些文件；</li><li>Windows系统中，动态链接文件被称为<strong>动态链接库</strong>(<code>Dynamical Linking Library</code>)，通常就是我们平时很常见的以 <code>.dll</code> 为扩展名的文件；</li><li>OS X 和其他 UN*X 不同，它的库不是“共享对象(.so)”，因为 OS X 和 ELF 不兼容，而且这个概念在 Mach-O 中不存在。OS 中的动态链接文件一般称为<strong>动态库</strong>文件，带有 <code>.dylib</code>、<code>.framework</code>及链接符号<code>.tbd</code>。可以在 <code>/usr/lib</code> 目录下找到(这一点和其他所有的 UN*X 一样，不同的是在OS X 和 iOS 中没有/lib目录)</li><li>OS X 与其他 UN*X 另一点不同是：没有<code>libc</code>。开发者可能熟悉其他 UN*X 上的C运行时库(或Windows上的MSVCRT) 。但是在 OS X 上对应的库<code>/usr/lib/libc.dylib</code>只不过是指向<code>libSystem.B.dylib</code>的符号链接。</li><li>以C语言运行库为例，补充一下<strong>运行库</strong>的概念：任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。这样的一个代码集合称之为运行时库（Runtime Library）。而C语言的运行库，即被称为C运行库（CRT）。<strong>运行库顾名思义是让程序能正常运行的一个库。</strong></li></ul><h3 id="2-3-两个非常重要的库-LibSystem、libobjc"><a href="#2-3-两个非常重要的库-LibSystem、libobjc" class="headerlink" title="2.3  两个非常重要的库 LibSystem、libobjc"></a>2.3  两个非常重要的库 LibSystem、libobjc</h3><p>libSystem 提供了 LibC(运行库) 的功能，还包含了在其他 UN*X 上原本由其他一些库提供的功能，列几个熟知的：</p><ul><li>GCD libdispatch</li><li>C语言库 libsystem_c</li><li>Block libsystem_blocks</li><li>加密库(比如常见的md5函数) libcommonCrypto</li></ul><p>还有些库(如数学库 libm、线程库 libpthread)虽然在/usr/lib中看到虽然有这些库的文件，但都是libSystem.B.dylib的替身/快捷方式，即都是指向libSystem的符号链接。</p><p>libSystem 库是系统上所有二进制代码的绝对先决条件，即所有的二进制文件都依赖这个库，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。这个库还是/usr/ib/system目录下一些库的保护伞库(通过<code>LC_REEXPORT_LIB</code>加载命令重新导出了符号) 。</p><p>总结来说：<strong>libSystem在运行库的基础上，增加了一些对底层系统调用和内核服务的抽象接口。</strong>所以在下面的流程中，会发现<strong>libSystem是先于其他动态库初始化</strong>的。</p><p><strong>libobjc</strong>与libsystem一样，都是默认添加的lib，包含iOS开发天天接触的objc runtime.</p><h3 id="2-4-补充两个概念-模块与image"><a href="#2-4-补充两个概念-模块与image" class="headerlink" title="2.4 补充两个概念: 模块与image"></a>2.4 补充两个概念: 模块与image</h3><ul><li><code>程序模块</code>：从本质上讲，普通可执行程序和动态库中都包含指令和数据，这一点没有区别。在使用动态库的情况下，程序本身被分为了程序主要模块(<code>Program1</code>)和动态链接文件(<code>Lib.so</code> <code>Lib.dylib</code> <code>Lib.dll</code>)，但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程序模块时可以指程序主模块也可以指动态链接库。</li><li><code>映像(image)</code> ，通常也是指这两者。可执行文件/动态链接文件，在装载时被直接映射到进程的虚拟地址空间中运行，它是进程的虚拟空间的映像，所以很多时候，也被叫做映像/镜像文件(Image File)。</li></ul><h3 id="2-5-a-dylib与-framework的区别"><a href="#2-5-a-dylib与-framework的区别" class="headerlink" title="2.5 .a/.dylib与.framework的区别"></a>2.5 .a/.dylib与.framework的区别</h3><p>前者是纯二进制文件，文件不能直接使用，需要有.h文件的配合(我们在使用系统的.dylib动态库时，经常发现没有头文件，其实这些库的头文件都位于一个已知位置，如<code>usr/include</code>(新系统中这个文件夹由SDK附带了，见 <a href="https://apple.stackexchange.com/questions/372032/usr-include-missing-on-macos-catalina-with-xcode-11">[/usr/include missing on macOS Catalina (with Xcode 11)]</a> )，库文件位于<code>usr/lib</code>，使得这些库全局可用)，后者除了二进制文件、头文件还有资源文件，代码可以直接导入使用(<code>.a + .h + sourceFile = .framework</code>)。</p><p>Framework 是苹果公司的 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件（nib/xib、图片、国际化文本）、说明文档等集中在一起，方便开发者使用。<strong>Framework 其实是资源打包的方式，和静态库动态库的本质是没有什么关系</strong>(<strong>所以framework文件可以是静态库也可以是动态库，iOS 中用到的所有系统 framework 都是动态链接的</strong>)。</p><p>在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。但是iOS平台在 iOS 8 之前，苹果不允许第三方框架使用动态方式加载，开发者可以使用的动态 Framework 只有苹果系统提供的 UIKit.Framework，Foundation.Framework 等。开发者要进行模块化，只能打包成静态库文件：<code>.a + 头文件</code>、<code>.framework</code>(这时候的 Framework 只支持打包成静态库的 Framework)，前种方式打包不够方便，使用时也比较麻烦，没有后者的便捷性。</p><p>iOS 8/Xcode 6 推出之后，允许开发者有条件地创建和使用动态库，支持了动态 Framework。开发者打包的动态 Framework 和系统的 UIKit.Framework 还是有很大区别。后者不需要拷贝到目标程序中，是一个链接。而前者在打包和提交 app 时会<strong>被放到 app  main bundle 的根目录中，运行在沙盒里</strong>，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载，因此苹果又把这种 Framework 称为 Embedded Framework(可植入性 Framework)。</p><p>不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p><p>数量上，苹果公司建议最多使用6个非系统动态库。</p><p>然后就是，在上传App Store打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有Embedded 的动态库，所以如果是动态从服务器更新的动态库，是签名不了的，sandbox验证动态库的签名非法时，就会造成crash。因此应用插件化、软件版本实时模块升级等功能在iOS上无法实现。不过在 in house(企业发布) 包和develop 包中可以使用。</p><h2 id="三、Mach-O-文件的动态链接-—-dyld"><a href="#三、Mach-O-文件的动态链接-—-dyld" class="headerlink" title="三、Mach-O 文件的动态链接 — dyld"></a>三、Mach-O 文件的动态链接 — dyld</h2><h3 id="3-1-dyld2与dyld3"><a href="#3-1-dyld2与dyld3" class="headerlink" title="3.1 dyld2与dyld3"></a>3.1 dyld2与dyld3</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。</p></blockquote><p>在2017WWDC，Apple推出了Dyld3。在iOS 13系统中，iOS全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p><p>Dyld2是从程序开始时才开始执行的，而Dyld3则将Dyld2的一些过程进行了分解。</p><img src="/images/compilelink/44.png" alt="44" style="zoom:60%;" /><p>Dyld3最大的特点是部分进程外的，分为out-of-process，和in-process。即操作系统在当前app进程之外完成了一部分dyld2在进程内的工作。以达到提升app启动性能和增强安全的目的。</p><p>out-process会做：</p><ul><li>分析Mach-O Headers</li><li>分析以来的动态库</li><li>查找需要的Rebase和Bind的符号</li><li>将上面的分析结果写入缓存。</li></ul><p>in-process会做：</p><ul><li>读取缓存的分析结果</li><li>验证分析结果</li><li>加载Mach-O文件</li><li>Rebase&amp;Bind</li><li>Initializers</li></ul><p>使用了Dyld3后，App的启动速度会进一步提高。</p><p>而WWDC2019 苹果宣布针对Dyld3做了以下优化：</p><ul><li><strong>避免链接无用的framework；</strong></li><li><strong>避免在app启动时链接动态库；</strong></li><li><strong>硬链接所有依赖项</strong></li></ul><h3 id="3-2-dyld的工作机制"><a href="#3-2-dyld的工作机制" class="headerlink" title="3.2 dyld的工作机制"></a>3.2 dyld的工作机制</h3><p>在<a href="https://www.jianshu.com/p/bff19e0a80d4">Mach-O 文件的装载</a>完成，即内核加载器做完相关的工作后，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DYLINKER</code>加载命令指定的动态链接器在用户态完成的。通常情况下，使用的是 <code>/usr/lib/dyld</code> 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。</p><p>链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。</p><blockquote><p>dyld是一个用户态的进程。dyld不属于内核的一部分，而是作为一个单独的开源项目由苹果进行维护的(当然也属于Darwin的一部分) ，点击查看<a href="http://www.opensource.apple.com/source/dyld">项目网址</a>。从内核的角度看，dyld是一个可插入的组件，可以替换为第三方的链接器。dyld对应的二进制文件有两个，分别是<code>/usr/lib/dyld</code>、<code>/urs/lib/system/libdyld.dylib</code>，前者<code>通用二进制格式(FAT)</code>，filetype为<code>MH_DYLINKER</code>，后者是普通的动态链接库格式(Mach-O)。</p></blockquote><img src="/images/compilelink/30.png" style="zoom:80%;" /><p>从调用堆栈上看dyld、libdyld.dylib的作用：</p><img src="/images/compilelink/31.png" style="zoom:90%;" /><p>前者<code>dyld</code>是<strong>一段可执行的程序</strong>，内核将其映射至进程地址空间，将控制权交给它进行执行，递归加载所需的动态库，其中也会将动态链接器的另一种形式的<code>libdyld.dylib</code>加载，因为动态链接器dyld其不但在应用的装载阶段起作用，在主程序运行的时候，其充当<strong>一个库</strong>的角色，还提供了<code>dlopen</code>、<code>dlsym</code>等api，可以让主程序<strong>显式运行时链接</strong>(见下文)。(关于这一点，没有找到明确的文档说明。如果有人有正确的理解，请一定要评论区告诉我一下，感激不尽)</p><blockquote><p>Linux中，动态链接库的存在形式稍有不同，Linux动态链接器本身是一个共享对象(动态库)，它的路径是/lib/ld-linux.so.2，这实际上是个软链接，它指向/lib/ld-x.y.z.so， 这个才是真正的动态连接器文件。共享对象其实也是ELF文件，它也有跟可执行文件一样的ELF文件头（包括e_entry、段表等）。动态链接器是个非常特殊的共享对象，它不仅是个共享对象，还是个可执行的程序，可以直接在命令行下面运行。因为ld.so是共享对象，又是动态链接器，所以本来应由动态链接器进行的共享对象的重定位，就要靠自己来，又称“自举”。自举完成后ld.so以一个共享对象的角色，来实现动态链接库的功能。</p></blockquote><p>我们需要了解一下<code>LC_LOAD_DYLIB</code>这个加载命令，这个命令会告诉链接器在哪里可以找到这些符号，即动态库的相关信息(ID、时间戳、版本号、兼容版本号等)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> <span class="title">name</span>;</span>              <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;             <span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;       <span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version; <span class="comment">/* library&#x27;s compatibility vers number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;         <span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;     <span class="comment">/* includes pathname string */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> <span class="title">dylib</span>;</span>   <span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接器要加载每一个指定的库，并且搜寻匹配的符号。每个被链接的库(Mach-O格式)都有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过<code>LC_SYMTAB</code>加载命令指定的 symoff 找到。对应的符号名称在 stroff， 总共有 nsyms 条符号信息。</p><p>下面是<code>LC_SYMTAB</code>的load_command：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 &lt;mach-o/dyld.h&gt; 动态库头文件中，也为我们提供了查询所有动态库 image 的方法(也可以使用<code>otool -L 文件路径</code>命令来查看，但看着没代码全)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listImages</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> ic = _dyld_image_count();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %d images\n&quot;</span>, ic);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %p\t%s\t(slide: %p)\n&quot;</span>,</span><br><span class="line">               i,</span><br><span class="line">               _dyld_get_image_header(i),</span><br><span class="line">               _dyld_get_image_name(i),</span><br><span class="line">               _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listImages();  <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: </span><br><span class="line">  ...</span><br><span class="line">  <span class="number">45</span>: <span class="number">0x1ab331000</span>/usr/lib/libobjc.A.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  <span class="number">46</span>: <span class="number">0x1e1767000</span>/usr/lib/libSystem.B.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br><span class="line">  <span class="number">70</span>: <span class="number">0x107220000</span>/usr/lib/system/introspection/libdispatch.dylib(slide: <span class="number">0x107220000</span>)</span><br><span class="line">  <span class="number">71</span>: <span class="number">0x1ab412000</span>/usr/lib/system/libdyld.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="四、dyld工作流程详解"><a href="#四、dyld工作流程详解" class="headerlink" title="四、dyld工作流程详解"></a>四、dyld工作流程详解</h2><p>通过源码来看一下dyld的工作流程，只是部分片段，详细的可以下载源码。</p><h3 id="4-1-dyld-start"><a href="#4-1-dyld-start" class="headerlink" title="4.1 __dyld_start"></a>4.1 __dyld_start</h3><p>下面的汇编代码很简单，如果不清楚，可以看一下这篇汇编入门文章<a href="https://www.jianshu.com/p/23a9110cff96">iOS需要了解的ARM64汇编</a>。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if __arm64__</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.align</span> <span class="number">2</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line"><span class="symbol">__dyld_start:</span></span><br><span class="line"><span class="comment">; 操作fp栈帧寄存器，sp栈指针寄存器，配置函数栈帧</span></span><br><span class="line"><span class="keyword">mov</span> x28, <span class="built_in">sp</span></span><br><span class="line"><span class="keyword">and</span>     <span class="built_in">sp</span>, x28, #~<span class="number">15</span><span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line"><span class="keyword">mov</span>x0, <span class="number">#0</span></span><br><span class="line"><span class="keyword">mov</span>x1, <span class="number">#0</span></span><br><span class="line">stpx1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!<span class="comment">// make aligned terminating frame</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">fp</span>, <span class="built_in">sp</span><span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line"><span class="keyword">sub</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="comment">; L(long 64位) P(point)，在前面的汇编一文中，我们已经知道：r0 - r30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 </span></span><br><span class="line"><span class="comment">; 当使用 x0 - x30访问时，它就是一个64位的数。</span></span><br><span class="line"><span class="comment">; 当使用 w0 - w30访问时，访问的是这些寄存器的低32位</span></span><br><span class="line"><span class="comment">#if __LP64__       </span></span><br><span class="line"><span class="keyword">ldr</span>     x0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     x1, [x28, <span class="number">#8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     x2, x28, <span class="number">#16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="keyword">ldr</span>     w0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     w1, [x28, <span class="number">#4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     w2, w28, <span class="number">#8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="keyword">adrp</span>x3,___dso_handle<span class="comment">@page</span></span><br><span class="line"><span class="keyword">add</span> x3,x3,___dso_handle<span class="comment">@pageoff // get dyld&#x27;s mh in to x4</span></span><br><span class="line"><span class="keyword">mov</span>x4,<span class="built_in">sp</span>                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"><span class="comment">; 从上面的汇编代码可以看到，主要是在设置dyldbootstrap::start函数调用栈的配置，在前面的汇编一文中，我们已经知道函数的参数，主要通过x0-x7几个寄存器来传递</span></span><br><span class="line"><span class="comment">; 可以看到函数需要的几个参数app_mh，argc，argv，dyld_mh，&amp;startGlue分别被放置到了x0 x1 x2 x4 x5寄存器上</span></span><br><span class="line">    <span class="comment">; call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line"><span class="keyword">bl</span>__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line"><span class="keyword">mov</span>x16,x0                  <span class="comment">// save entry point address in x16</span></span><br></pre></td></tr></table></figure><h3 id="4-2-dyldbootstrap-start"><a href="#4-2-dyldbootstrap-start" class="headerlink" title="4.2 dyldbootstrap::start()"></a>4.2 dyldbootstrap::start()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//  主要做的是dyld的引导工作，一般这个工作通常由 dyld 和 crt(C运行时库 C Run-Time Libray )来完成。但dyld自身加载的时候，只能由自己来做。</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有slide，那么需要重定位，必须在使用任何全局变量之前，进行该操作</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader); </span><br><span class="line">    <span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">    ++apple;</span><br><span class="line">    <span class="comment">// 为stack canary设置一个随机值</span></span><br><span class="line">    <span class="comment">// stack canary：栈的警惕标志(stack canary)，得名于煤矿里的金丝雀，用于探测该灾难的发生。具体办法是在栈的返回地址的存储位置之前放置一个整形值，该值在装入程序时随机确定。栈缓冲区攻击时从低地址向高地址覆盖栈空间，因此会在覆盖返回地址之前就覆盖了警惕标志。返回返回前会检查该警惕标志是否被篡改。</span></span><br><span class="line">    __guard_setup(apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">    <span class="comment">// 执行 dyld 中所有的C++初始化函数。run all C++ initializers inside dyld</span></span><br><span class="line">    runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 完成所有引导工作，调用dyld::main(). now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">    <span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-dyld-main"><a href="#4-3-dyld-main" class="headerlink" title="4.3 dyld::_main()"></a>4.3 dyld::_main()</h3><p>dyld也是Mach-O文件格式的，文件头中的 filetype 字段为<code>MH_DYLINKER</code>，区别与可执行文件的 <code>MH_EXECUTE</code>，所以dyld也是有main()函数的(默认名称是mian()，也可以自己修改入口地址的)。</p><p>因为这个函数太长，写在一起不好阅读，所以按照流程功能点，自上而下分为一个个代码片段。关键的函数会在代码中注释说明</p><h4 id="方法名及说明"><a href="#方法名及说明" class="headerlink" title="方法名及说明"></a>方法名及说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld的入口指针，内核加载dyld，跳转到__dyld_start函数：进行了一些寄存器设置，然后就调用了该函数。Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">// 返回主程序模块的mian()函数地址，__dyld_start中会跳到该地址。Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h4 id="第一步-配置上下文信息，设置运行环境，处理环境变量"><a href="#第一步-配置上下文信息，设置运行环境，处理环境变量" class="headerlink" title="第一步 配置上下文信息，设置运行环境，处理环境变量"></a>第一步 配置上下文信息，设置运行环境，处理环境变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第一步，设置运行环境</span></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">hexToBytes</span>(_simple_getenv(apple, <span class="string">&quot;executable_cdhash&quot;</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace dyld&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">&quot;dyld_file&quot;</span>));</span><br><span class="line"><span class="comment">// Trace the main executable&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>(mainExecutableMH, _simple_getenv(apple, <span class="string">&quot;executable_file&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">    ......</span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch started&quot;</span>);</span><br><span class="line"><span class="comment">// 传入Mach-O头部以及一些参数设置上下文信息</span></span><br><span class="line"><span class="built_in">setContext</span>(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getcwd</span>(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 获取进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式</span></span><br><span class="line">    <span class="built_in">configureProcessRestrictions</span>(mainExecutableMH, envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line"><span class="built_in">checkEnvironmentVariables</span>(envp);</span><br><span class="line"><span class="comment">// 在DYLD_FALLBACK为空时设置默认值</span></span><br><span class="line"><span class="built_in">defaultUninitializedFallbackPaths</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line"><span class="built_in">printOptions</span>(argv);</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line"><span class="built_in">printEnvironmentVariables</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 获取当前程序架构</span></span><br><span class="line"><span class="built_in">getHostInfo</span>(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure><h4 id="第二步-加载共享缓存"><a href="#第二步-加载共享缓存" class="headerlink" title="第二步 加载共享缓存"></a>第二步 加载共享缓存</h4><p>在iOS系统中，UIKit，Foundation等基础库是每个程序都依赖的，需要通过dyld（位于/usr/lib/dyld）一个一个加载到内存，然而如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。iOS的dyld采用了一个共享库预链接缓存，苹果从iOS 3.0开始将所有的基础库都移到了这个缓存中，合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下(OS X中是在/private/var/db/dyld目录)，按不同的架构保存分别保存着，如dyld_shared_cache_armv7。而且在OS X中还有一个辅助的.map文件，而iOS中没有。</p><p>如果在iOS上搜索大部分常见的库，比如所有二进制文件都依赖的libSystem，是搜索不到的，这个库的文件不在文件系统中，而是被缓存文件包含。关于如何从共享缓存中提取我们想看的库，可以参考链接<a href="https://www.dllhook.com/post/238.html#toc_1">dyld详解第一部分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第二步，加载共享缓存 <span class="comment">// load shared cache</span></span></span><br><span class="line">   <span class="comment">// 检查共享缓存是否开启，iOS必须开启</span></span><br><span class="line"><span class="built_in">checkSharedRegionDisable</span>((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * mapSharedCache加载共享缓存库，其中调用loadDyldCache函数，展开loadDyldCache，有这么几种情况：</span></span><br><span class="line"><span class="comment">        * 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程）</span></span><br><span class="line"><span class="comment">        * 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide</span></span><br><span class="line"><span class="comment">        * 共享缓存不是第一次被加载，那么就不做任何处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="built_in">mapSharedCache</span>();</span><br><span class="line">&#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="built_in">addDyldImageToUUIDList</span>();</span><br></pre></td></tr></table></figure><h4 id="第三步-实例化主程序image"><a href="#第三步-实例化主程序image" class="headerlink" title="第三步 实例化主程序image"></a>第三步 实例化主程序image</h4><h5 id="1-源码解读"><a href="#1-源码解读" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>ImageLoader：前面已经提到image(映像文件)常见的有可执行文件、动态链接库。ImageLoader 作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载。</strong></p><p>从下面可以看到大概的顺序：先将动态链接的 image 递归加载，再依次进行可执行文件的链接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 展开 instantiateFromLoadedImage 函数, 可以看到主要分三步:</span></span><br><span class="line"><span class="comment"> * isCompatibleMachO()：检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line"><span class="comment"> * instantiateMainExecutable()： 就是实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line"><span class="comment"> * addImage()： 添加到 allImages中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">gLinkContext.mainExecutableCodeSigned = <span class="built_in">hasCodeSignatureLoadCommand</span>(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line"><span class="built_in">checkVersionedPaths</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">proc_regionfilename</span>(<span class="built_in">getpid</span>(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = <span class="built_in">strdup</span>(dyldPathBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-instantiateFromLoadedImage"><a href="#2-instantiateFromLoadedImage" class="headerlink" title="2. instantiateFromLoadedImage"></a>2. instantiateFromLoadedImage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">//if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="built_in">addImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw &quot;main executable not a known format&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中，我们大致可以看到加载有三步：</p><ul><li><code>isCompatibleMachO</code> 是检查mach-o的subtype是否是当前cpu可以支持； </li><li><code>instantiateMainExecutable</code> 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </li><li><code>addImage</code> 添加到 allImages中。</li></ul><h4 id="第四步-加载插入的动态库"><a href="#第四步-加载插入的动态库" class="headerlink" title="第四步 加载插入的动态库"></a>第四步 加载插入的动态库</h4><p>通过遍历 DYLD_INSERT_LIBRARIES 环境变量，调用 loadInsertedDylib 加载。</p><p>在三方App的Mach-O文件中通过修改DYLD_INSERT_LIBRARIES的值来加入我们自己的动态库，从而注入代码，hook别人的App。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第四步 加载插入的动态库</span></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line"><span class="built_in">loadInsertedDylib</span>(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库数量</span></span><br><span class="line">sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="第五步-链接主程序-重点link"><a href="#第五步-链接主程序-重点link" class="headerlink" title="第五步 链接主程序(重点link())"></a>第五步 链接主程序(重点link())</h4><h5 id="1-源码解读-1"><a href="#1-源码解读-1" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第五步 链接主程序</span></span><br><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line"><span class="keyword">if</span> ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line"><span class="comment">// previous link() on main executable has already adjusted its internal pointers for ASLR </span></span><br><span class="line">    <span class="comment">// work around that by rebasing by inverse amount</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">rebase</span>(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        link() 函数的递归调用函数堆栈形式</span></span><br><span class="line"><span class="comment">          ▼ ImageLoader::link() //启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line"><span class="comment">            ▼ recursiveLoadLibraries() //进行所有需求动态库的加载</span></span><br><span class="line"><span class="comment">              ▶︎ //确定所有需要的库</span></span><br><span class="line"><span class="comment">              ▼ context.loadLibrary() //来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line"><span class="comment">                ▼ load() // 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line"><span class="comment">                  ▶︎ loadPhase0() → loadPhase1() → ... → loadPhase5() → loadPhase5load() → loadPhase5open() → loadPhase6() 递归调用  //每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line"><span class="comment">                  ▼ loadPhase6() // 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">sMainExecutable-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line"><span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-ImageLoader-link"><a href="#2-ImageLoader-link" class="headerlink" title="2. ImageLoader::link()"></a>2. ImageLoader::link()</h5><blockquote><p>加载二进制的过程： instantiate(实例化) –&gt; addImage –&gt; link –&gt; runInitializers </p><p>其中link就是动态链接的过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t0 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">  <span class="comment">// 1. recursiveLoadLibraries 这一步就是根据 LoadCommand 中的 LC_LOAD_DYLIB 把依赖的动态库和Framework加载进来。也就是对这些动态库 instantiate 的过程。 只是动态库不会用instantiateMainExecutable方法来加载了，最终用的是 instantiateFromFile 来加载。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only do the loading step for preflights</span></span><br><span class="line"><span class="keyword">if</span> ( preflightOnly )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">context.<span class="built_in">clearAllDepths</span>();</span><br><span class="line">  <span class="comment">// 2. recursiveUpdateDepth 刷新depth, 就是库依赖的层级。层级越深，depth越大。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  unsigned int ImageLoader::updateDepth(unsigned int maxDepth)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    STACK_ALLOC_ARRAY(ImageLoader*, danglingUpwards, maxDepth);</span></span><br><span class="line"><span class="comment">    unsigned int depth = this-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    for (auto&amp; danglingUpward : danglingUpwards) &#123;</span></span><br><span class="line"><span class="comment">      if ( danglingUpward-&gt;fDepth != 0)</span></span><br><span class="line"><span class="comment">        continue;</span></span><br><span class="line"><span class="comment">      danglingUpward-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return depth;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">updateDepth</span>(context.<span class="built_in">imageCount</span>());</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::<span class="built_in">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="comment">// 3. recursiveRebase rebase的过程，recursiveRebase就会把主二进制和依赖进来的动态库全部rebase.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void ImageLoader::recursiveRebaseWithAccounting(const LinkContext&amp; context)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      this-&gt;recursiveRebase(context);</span></span><br><span class="line"><span class="comment">      vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveRebaseWithAccounting</span>(context);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">t3 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 4. 主二进制和依赖进来的动态库全部执行 bind</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      void ImageLoader::recursiveBindWithAccounting(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;recursiveBind(context, forceLazysBound, neverUnload, nullptr);</span></span><br><span class="line"><span class="comment">        vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 5. weakBind. 执行weakBind，这里看到如果是主二进制在link的话，是不会在这个时候执行weak bind的，在dyld::_main里面可以看到，是在link完成之后再执行的weakBind.</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">weakBind</span>(context);</span><br><span class="line">t5 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 6. recursiveApplyInterposing. (主二进制link时候也不执行)</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveApplyInterposing</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t6 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveGetDOFSections</span>(context, dofs);</span><br><span class="line">    <span class="comment">// 7. registerDOFs. 注册DTrace Object Format。DTrace(Dynamic Trace)是一个提供了 zero disable cost 的动态追踪框架，也就是说当代码中的探针关闭时，不会有额外的资源消耗 - 即使在生产版本中我们也可以将探针留在代码中。只有使用的时候才产生消耗。</span></span><br><span class="line">    <span class="comment">// DTrace 是动态的，也就是说我们可以将它附加在一个已经在运行的程序上，也可以不打断程序将它剥离。不需要重新编译或启动。</span></span><br><span class="line">context.<span class="built_in">registerDOFs</span>(dofs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> t7 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with initial dylib loads</span></span><br><span class="line">fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-反向依赖"><a href="#3-反向依赖" class="headerlink" title="3. 反向依赖"></a>3. 反向依赖</h5><p>每个库之间的符号并非只能单向依赖。即库与库之间是可以相互依赖符号的。</p><blockquote><p>单向依赖：即 A.dylib 依赖 B.dylib。那么B中就不能依赖A中的符号。</p></blockquote><blockquote><p>一次dyld加载进来的二进制之间可以相互依赖符号。</p></blockquote><p>原因很简单，就是因为上面看到动态链接过程中，并不是完全加载完一个被依赖的动态库，再加载下一个的。而是 recursiveLoadLibraies，recursiveRebase，recursiveBind。 所有的单步操作都会等待前一步所有的库完成。因此当 recursiveBind的时候，所有的动态库二进制已经加载进来了，符号就可以互相找了。</p><p>一次dyld的过程只会一次动态link，这次link的过程中的库符号可以互相依赖的，但是如果你通过<code>dlopen</code>、<code>-[NSBundle loadBundle]</code>的方式来延迟加载的动态库就不能反向依赖了，必须单向依赖，因为这是另外一次dyld的过程了。</p><p>反向依赖还要有个条件，条件就是符号必须存在，如果因为编译优化把符号给strip了，那就没法bind了，还是会加载失败的。</p><h4 id="第六步-链接插入的动态库"><a href="#第六步-链接插入的动态库" class="headerlink" title="第六步 链接插入的动态库"></a>第六步 链接插入的动态库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第六步 链接插入的动态库</span></span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;<span class="built_in">inSharedCache</span>() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sImageRoots[i]-&gt;<span class="built_in">applyInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">gLinkContext.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">recursiveBind</span>(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第七步-弱符号绑定weakBind"><a href="#第七步-弱符号绑定weakBind" class="headerlink" title="第七步 弱符号绑定weakBind"></a>第七步 弱符号绑定weakBind</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第七步 执行弱符号绑定。weakBind: 从代码中可以看出这一步会对所有含有弱符号的镜像合并排序进行bind。OC中没发现应用场景，可能是C++的吧</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(gLinkContext);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch, running initializers&quot;</span>);</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h4 id="第八步-执行初始化方法initialize"><a href="#第八步-执行初始化方法initialize" class="headerlink" title="第八步 执行初始化方法initialize"></a>第八步 执行初始化方法initialize</h4><h5 id="1-源码解读-2"><a href="#1-源码解读-2" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>dyld会优先初始化动态库，然后初始化主程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第八步 执行初始化方法initialize() </span></span><br><span class="line">      <span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">//attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line"><span class="comment">//与之对应的是attribute((destructor))修饰的函数, 是主程序 main() 执行之后的一些全局函数析构操作, 也是记录在一个Section __mod_term_func中.</span></span><br><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有的监视进程，本进程要进入main()函数了。 notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="built_in">notifyMonitoringDyldMain</span>();</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h5 id="2-initializeMainExecutable"><a href="#2-initializeMainExecutable" class="headerlink" title="2. initializeMainExecutable()"></a>2. initializeMainExecutable()</h5><p>调用函数堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先初始化动态库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123; </span><br><span class="line">   sImageRoots[i]-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]); </span><br><span class="line">&#125;  <span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line"><span class="comment">// 再初始化可执行文件 </span></span><br><span class="line">  <span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line">▼ sMainExecutable-&gt;<span class="built_in">runInitializers</span>() </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">    ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()      <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">      ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()      <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doImageInit</span>()         <span class="comment">// 解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">        <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">      ▼ context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ▶︎ (*sNotifyObjCInit)(image-&gt;<span class="built_in">getRealPath</span>(), image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">        <span class="comment">// 通知objc, 该image已经完成初始化。objc会调用load_images()</span></span><br><span class="line">▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br></pre></td></tr></table></figure><p>在上面的<code>doImageInit</code>、<code>doModInitFunctions</code>函数中，会发现都有判断<code>libSystem</code>库是否已加载的代码，即<strong>libSystem要首先加载、初始化</strong>。在上文中，我们已经强调了这个库的重要性。之所以在这里又提到，是因为这个库也起到了将dyld与objc关联起来的作用：</p><img src="/images/compilelink/32.png" style="zoom:80%;" /><h5 id="2-dyld到objc的流程-详细见下篇"><a href="#2-dyld到objc的流程-详细见下篇" class="headerlink" title="2. dyld到objc的流程(详细见下篇)"></a>2. dyld到objc的流程(详细见下篇)</h5><p>可以从上面的调用堆栈中看到，从dyld到objc的流程：</p><ol><li><p><code>libSystem</code> 库的初始化</p></li><li><p><code>libdispatch</code> 库的初始化：<code>libdispatch</code> 是实现 GCD 的核心用户空间库。在 <code>void libdispatch_init(void)</code> 方法中会调用 <code>void _os_object_init(void)</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_include(<span class="meta-string">&lt;objc/objc-internal.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                                  <span class="comment">// __asm__ 使函数调用编译为“调用_objc_retain”</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> id _Nullable <span class="title">objc_retain</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_retain&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">objc_release</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_release&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_prepare(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_parent(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_child(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __has_include(&lt;objc/objc-internal.h&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>*_os_objc_destructInstance(id obj) &#123;</span><br><span class="line">    <span class="comment">// noop if only Libystem is loaded</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _os_object_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    Block_callbacks_RR callbacks = &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(Block_callbacks_RR),</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">    &#125;;</span><br><span class="line">    _Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v = <span class="built_in">getenv</span>(<span class="string">&quot;OBJC_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;DISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;LIBDISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后就是 <a href="https://opensource.apple.com/tarballs/objc4/">objc的源码</a> <code>objc-os.mm</code>中的 <code>_object_init</code> 函数了：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载，该方法是dyld提供的，内部调用了dyld::registerObjCNotifiers这个方法，记录了这三个分别对应map，init，unmap事件的回调函数。会在相应时机触发</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dyld_objc_notify_register</code> 这个方法在苹果开源的dyld里面可以找到，然后看到调用了<code>dyld::registerObjCNotifiers</code>这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// record functions to call</span></span><br><span class="line">  sNotifyObjCMapped   = mapped;</span><br><span class="line">  sNotifyObjCInit     = init;</span><br><span class="line">  sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class="line">       <span class="comment">// 第一次先触发一次ObjCMapped</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">notifyBatchPartial</span>(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//内部会触发sNotifyObjCMapped的调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">      <span class="comment">// ignore request to abort during registration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字面意思可以明白，传进来的分别是 map, init, unmap事件的回调。 dyld的事件通知有以下几种，分别会在特定的时机发送：(注意：map、init、unmap对应到下面枚举中的名称并不一致)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dyld_image_state_mapped                 = <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">  dyld_image_state_dependents_mapped      = <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">  dyld_image_state_rebased                = <span class="number">30</span>, </span><br><span class="line">  dyld_image_state_bound                  = <span class="number">40</span>,</span><br><span class="line">  dyld_image_state_dependents_initialized = <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">  dyld_image_state_initialized            = <span class="number">50</span>,</span><br><span class="line">  dyld_image_state_terminated             = <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个函数就很熟悉了，位于<code>objc-runtime-new.mm</code>中，objc运行时老生常谈的几个方法(关于OBJC的部分，内容太多，这里简单介绍，下篇细谈)，每次有新的镜像加载时都会在指定时机触发这几个方法：</p><ul><li>map_images : 每当 dyld 将一个 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : 每当 dyld 初始化一个 image 会触发该方法，会对该 image 进行+load的调用</li><li>unmap_image : 每当 dyld 将一个 image 移除时 , 会触发该函数</li></ul><img src="/images/compilelink/33.png" style="zoom:75%;" /><p>值得说明的是，这个初始化的过程远比写出来的要复杂，这里只提到了 runtime 这个分支，还有像 GCD、XPC 等重头的系统库初始化分支没有提及（当然，有缓存机制在，也不会重复初始化），总结起来就是 main 函数执行之前，系统做了非常多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p><p>然后，从上面最后的代码(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); 以及注释<code>register cxa_atexit() handler to run static terminators in all loaded images when this process exits</code>可以看出注册了<code>cxa_atexit()</code>函数，当此进程退出时，该处理程序会运行所有加载的image中的静态终止程序(static terminators)。</p><h4 id="第九步-查找主程序入口点并返回，-dyld-start会跳转进入"><a href="#第九步-查找主程序入口点并返回，-dyld-start会跳转进入" class="headerlink" title="第九步 查找主程序入口点并返回，__dyld_start会跳转进入"></a>第九步 查找主程序入口点并返回，__dyld_start会跳转进入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第九步 查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">    <span class="comment">// find entry point for main executable</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line"><span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_UNIXTHREAD</span>();</span><br><span class="line">*startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="built_in">syncAllImages</span>();</span><br><span class="line"><span class="built_in">halt</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: launch failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>引自<a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a>一文中的片段，<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html">《 Mike Ash 这篇 blog 》</a>对 dyld 作用顺序的概括：</p><ol><li> 从 kernel 留下的原始调用栈引导和启动自己</li><li> 将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li><li> non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li><li> Runs static initializers for the executable</li><li> 找到可执行文件的 main 函数，准备参数并调用</li><li> 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li><li> 程序main函数 return 后执行 static terminator</li><li> 某些场景下 main 函数结束后调 libSystem 的 <strong>_exit</strong> 函数</li></ol><p>然后，使用调用堆栈，来看下dyld的工作流程，只注释了认为重要的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 内核XNU加载Mach-O</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 从 XNU内核态 将控制权转移到 dyld用户态</span></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start   <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::<span class="built_in">start</span>()   <span class="comment">//dyldInitialization.cpp，负责dyld的引导工作</span></span><br><span class="line">      ▼ dyld::_main()   <span class="comment">// dyld.cpp</span></span><br><span class="line">    ▶︎ <span class="comment">// 第一步，设置运行环境</span></span><br><span class="line">    ▶︎ <span class="comment">// 第二步，加载共享缓存</span></span><br><span class="line">    ▶︎ <span class="comment">// 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line">    ▼ <span class="built_in">instantiateFromLoadedImage</span>()  </span><br><span class="line">        ▶︎ <span class="built_in">isCompatibleMachO</span>()  <span class="comment">// 检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line">        ▶︎ <span class="built_in">instantiateMainExecutable</span>()  <span class="comment">// 实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line">        ▶︎ <span class="built_in">addImage</span>()  <span class="comment">// 将可执行文件这个image，添加到 allImages中</span></span><br><span class="line">    ▶︎ <span class="comment">// 第四步，循环调用该函数，加载插入的动态库</span></span><br><span class="line">    ▶︎ <span class="built_in">loadInsertedDylib</span>()  </span><br><span class="line">    ▶︎ <span class="comment">// 第五步，调用link()函数，链接主程序</span></span><br><span class="line">    ▼ <span class="built_in">link</span>()  </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">link</span>() <span class="comment">//启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line">▼ <span class="built_in">recursiveLoadLibraries</span>() <span class="comment">//进行所有需求动态库的加载</span></span><br><span class="line">  ▶︎ <span class="comment">//确定所有需要的库</span></span><br><span class="line">  ▼ context.<span class="built_in">loadLibrary</span>() <span class="comment">//来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line">    ▼ <span class="built_in">load</span>() <span class="comment">// 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line">      ▶︎ <span class="built_in">loadPhase0</span>() → <span class="built_in">loadPhase1</span>() → ... → <span class="built_in">loadPhase5</span>() → <span class="built_in">loadPhase5load</span>() → <span class="built_in">loadPhase5open</span>() → <span class="built_in">loadPhase6</span>() 递归调用  <span class="comment">//每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line">      ▼ <span class="built_in">loadPhase6</span>() <span class="comment">// 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line">    ▶︎ <span class="comment">// 第六步，调用link()函数，链接插入的动态库</span></span><br><span class="line">    ▶︎ <span class="comment">// 第七步，对主程序进行弱符号绑定weakBind</span></span><br><span class="line">    ▶︎ sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">    ▶︎ <span class="comment">// 第八步，执行初始化方法 initialize。attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line">    ▼ <span class="built_in">initializeMainExecutable</span>()  <span class="comment">// dyld会优先初始化动态库，然后初始化主程序。</span></span><br><span class="line">          ▼ sMainExecutable-&gt;<span class="built_in">runInitializersrunInitializers</span>()  <span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">            ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">              ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()  <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">                ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()  <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doImageInit</span>()  <span class="comment">//解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">                  <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">          ▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">    ▶︎ <span class="comment">// 第九步，查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▶︎ (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br></pre></td></tr></table></figure><img src="/images/compilelink/34.png" style="zoom:80%;" /><p>关于更多的理论知识，可以阅读下<a href="https://juejin.im/post/6844903922654511112#heading-23">iOS程序员的自我修养-MachO文件动态链接（四）</a>、<a href="https://juejin.im/post/6844903926051897358">实践篇—fishhook原理</a>(：程序运行期间通过修改符号表(nl_symbol_ptr和la_symbol_ptr)，来替换要hook的符号对应的地址)，将《程序员的自我修养》中的理论结合iOS系统中的实现机制做了个对比介绍。</p><h2 id="五、加载动态库方式二-dlopen"><a href="#五、加载动态库方式二-dlopen" class="headerlink" title="五、加载动态库方式二: dlopen"></a>五、加载动态库方式二: dlopen</h2><blockquote><p>加载动态库的另一种方式：显式运行时链接dlopen</p></blockquote><p>上面的这种动态链接，其实还可以称为<strong>装载时链接</strong>，与静态链接相比，其实都是属于在程序运行之前进行的链接。还有另一种动态链接称为<strong>显式运行时链接</strong>(<strong>Explicit Runtime Linking</strong>)。</p><p>装载时链接：是在程序开始运行时(前)<strong>通过dyld动态加载</strong>。通过dyld加载的动态库需要在编译时进行链接，链接时会做标记，绑定的地址在加载后再决定。</p><p>显式运行时链接：即在运行时<strong>通过动态链接器dyld提供的API dlopen 和 dlsym 来加载</strong>。这种方式，在编译时是不需要参与链接的。</p><ul><li>dlopen会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。</li><li>dlopen也可以选择是立刻解析所有引用还是滞后去做。</li><li>dlopen打开动态库后返回的是模块的指针(句柄/文件描述符(FD))</li><li>dlsym的作用就是通过dlopen返回的动态库指针和函数的符号，得到函数的地址然后使用。</li></ul><p><strong>不过，通过这种运行时加载远程动态库的 App，苹果公司是不允许上线 App Store 的，所以只能用于线下调试环节。</strong></p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="https://www.cnblogs.com/guohai-stronger/p/11915571.html">MachO文件详解–逆向开发</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">Dyld之二: 动态链接过程</a></li><li><a href="https://www.dllhook.com/post/238.html#toc_14">dyld详解</a></li><li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li><li><a href="https://juejin.cn/post/6844904068867948552">iOS探索 浅尝辄止dyld加载流程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、动态链接&quot;&gt;&lt;a href=&quot;#一、动态链接&quot; class=&quot;headerlink&quot; title=&quot;一、动态链接&quot;&gt;&lt;/a&gt;一、动态链接&lt;/h2&gt;&lt;p&gt;动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</title>
    <link href="https://tenloy.github.io/2021/09/26/compile-vm-asrl.html"/>
    <id>https://tenloy.github.io/2021/09/26/compile-vm-asrl.html</id>
    <published>2021-09-26T14:26:04.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ASLR引入"><a href="#一、ASLR引入" class="headerlink" title="一、ASLR引入"></a>一、ASLR引入</h2><p>进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方式。然而，这意味着某个给定程序在某个给定架构上的进程初始虚拟内存镜像都是基本一致的。而且更严重的问题在于，即使是在进程正常运行的生命周期中，大部分内存分配的操作都是按照同样的方式进行的，因此使得内存中的地址分布具有非常强的可预测性。</p><p>尽管这有助于调试，但是也给黑客提供了更大的施展空间。黑客主要采用的方法是代码注入：通过重写内存中的函数指针，黑客就可以将程序的执行路径转到自己的代码，将程序的输入转变为自己的输入。重写内存最常用的方法是采用缓冲区溢出(即利用未经保护的内存复制操作越过上数组的边界)，可参考<a href="https://www.jianshu.com/p/4703ad3efbb9">缓冲区溢出攻击</a>，将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏printf()格式化字符串以及基于堆的缓冲区溢出。此外，任何用户指针甚至结构化的异常处理程序都可以导致代码注入。这里的关键问题在于判断重写哪些指针，也就是说，可靠地判断注入的代码应该在内存中的什么位置。</p><p>不论被破解程序的薄弱环节在哪里：缓冲区溢出、格式化字符串攻击或其他方式，黑客都可以花大力气破解一个不安全的程序，找到这个程序的地址空间布局，然后精心设计一种方法，这种方法可以可靠地重现程序中的薄弱环节，并且可以在类似的系统上暴露出一样的薄弱环节。</p><p>现在大部分操作系统中都采用了一种称为地址空间布局随机化(ASLR) 的技术，这是一种避免攻击的有效保护。进程每一次启动时，地址空间都会被简单地随机化：<strong>只是偏移，而不是搅乱</strong>。基本的布局(程序文本、数据和库)仍然是一样的。然而，这些部分具体的地址都不同了——区别足够大，可以阻挡黑客对地址的猜测。<strong>实现方法是通过内核将Mach-O的段“平移”某个随机系数</strong>。</p><h2 id="二、ASLR"><a href="#二、ASLR" class="headerlink" title="二、ASLR"></a>二、ASLR</h2><p>地址空间布局随机化(Address Space Layout Randomization，ASLR)是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。iOS4.3开始引入了ASLR技术。</p><p>下面分别来看一下，未使用ASLR、使用了ASLR下，进程虚拟地址空间内的分布。下图中左侧是mach-O可执行文件，右侧是链接之后的虚拟地址空间，如果对<code>__TEXT</code>、<code>__DATA</code>等Segment概念不清楚的地方，可以看一些第二篇关于Mach-O文件结构的介绍。</p><h3 id="2-1-未使用ASLR"><a href="#2-1-未使用ASLR" class="headerlink" title="2.1 未使用ASLR"></a>2.1 未使用ASLR</h3><ul><li>函数代码存放在__TEXT段中</li><li>全局变量存放在__DATA段中</li><li>可执行文件的内存地址是0x0</li><li>代码段（__TEXT）的内存地址就是LC_SEGMENT(__TEXT)中的VM Address：arm64设备下，为<code>0x100000000</code>；非arm64下为<code>0x4000</code></li><li>可以使用<code>size -l -m -x</code>来查看Mach-O的内存分布</li></ul><img src="/images/compilelink/26.png" alt="26" style="zoom:55%;" /><h3 id="2-2-使用了ASLR"><a href="#2-2-使用了ASLR" class="headerlink" title="2.2 使用了ASLR"></a>2.2 使用了ASLR</h3><ul><li>LC_SEGMENT(__TEXT)的VM Address为<code>0x100000000</code></li><li>ASLR随机产生的Offset（偏移）为<code>0x5000</code></li></ul><img src="/images/compilelink/27.png" alt="26" style="zoom:55%;" /><h3 id="2-3-符号地址计算"><a href="#2-3-符号地址计算" class="headerlink" title="2.3 符号地址计算"></a>2.3 符号地址计算</h3><blockquote><p>函数(变量)符号的内存地址、可执行文件地址计算</p></blockquote><h4 id="2-3-1-函数内存地址计算"><a href="#2-3-1-函数内存地址计算" class="headerlink" title="2.3.1 函数内存地址计算"></a>2.3.1 函数内存地址计算</h4><ul><li><strong>File Offset:</strong> 在当前架构(MachO)文件中的偏移量。</li><li> <strong>VM Address:</strong> 编译链接后，射到虚拟地址中的内存起始地址。 <code>VM Address = File Offset + __PAGEZERO Size</code>(__PAGEZERO段在MachO文件中没有实际大小，在VM中展开)</li><li><strong>Load Address:</strong> 在运行时加载到虚拟内存的起始位置。Slide是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同。<code>Load Address = VM Address + Slide(ASLR Offset)</code></li></ul><p>由于dsym符号表是编译时生成的地址，crash堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash日志里的符号地址被称为Stack Address，而编译后的符号地址被称为Symbol Address，他们之间的关系如下：<code>Stack Address = Symbol Address + Slide</code></p><p>符号化就是通过Stack Address到dsym文件中寻找对应符号信息的过程。</p><p>Hopper、IDA图形化工具中的地址都是未使用ASLR前的VM Address</p><h4 id="2-3-2-ASLR-Offset的获取"><a href="#2-3-2-ASLR-Offset的获取" class="headerlink" title="2.3.2 ASLR Offset的获取"></a>2.3.2 ASLR Offset的获取</h4><p>ASLR Offset有的地方也叫做<code>slide</code>，获取方法：</p><ul><li><p>在运行时由API <code>dyld_get_image_vmaddr_slide()</code>，来获取image虚拟地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型如下：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">intptr_t</span>   _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> image_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般使用方法如下：</span></span><br><span class="line"><span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> index  = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>lldb</code>命令<code>image list -o -f</code> 进行获取（本地、远程<code>debugserver</code>调试都可以），如下图：</p><img src="/images/compilelink/28.png" alt="26" style="zoom:80%;" /></li><li><p>根据运行时crash中的 <code>binary image</code>信息 和 ELF 文件的 <code>load command</code> 计算的到。比如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是crash信息，其中包括了抛出异常的线程的函数调用栈信息，日志下方有binary image信息，都只摘取了部分：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一列，调用顺序</span></span><br><span class="line"><span class="comment"> 第二列，对应函数所属的 binary image</span></span><br><span class="line"><span class="comment"> 第三列，stack address</span></span><br><span class="line"><span class="comment"> 第四列，地址的符号＋偏移的表示法，运算结果等于第三列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Last Exception Backtrace:  </span><br><span class="line"><span class="number">0</span>   CoreFoundation                <span class="number">0x189127100</span> __exceptionPreprocess + <span class="number">132</span>  </span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib               <span class="number">0x1959e01fc</span> objc_exception_throw + <span class="number">60</span>  </span><br><span class="line"><span class="number">2</span>   CoreFoundation                <span class="number">0x189127040</span> +[NSException raise:format:] + <span class="number">128</span>  </span><br><span class="line"><span class="number">3</span>   CrashDemo                     <span class="number">0x100a8666c</span> <span class="number">0x10003c000</span> + <span class="number">10790508</span>  </span><br><span class="line"><span class="number">4</span>   libsystem_platform.dylib      <span class="number">0x19614bb0c</span> _sigtramp + <span class="number">56</span>  </span><br><span class="line"><span class="number">5</span>   CrashDemo                     <span class="number">0x1006ef164</span> <span class="number">0x10003c000</span> + <span class="number">7024996</span>  </span><br><span class="line"><span class="number">6</span>   CrashDemo                     <span class="number">0x1006e8580</span> <span class="number">0x10003c000</span> + <span class="number">6997376</span>  </span><br><span class="line"><span class="number">7</span>   CrashDemo                     <span class="number">0x1006e8014</span> <span class="number">0x10003c000</span> + <span class="number">6995988</span>  </span><br><span class="line"><span class="number">8</span>   CrashDemo                     <span class="number">0x1006e7c94</span> <span class="number">0x10003c000</span> + <span class="number">6995092</span>  </span><br><span class="line"><span class="number">9</span>   CrashDemo                     <span class="number">0x1006f2460</span> <span class="number">0x10003c000</span> + <span class="number">7038048</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 第一列，虚拟地址空间区块；</span></span><br><span class="line"><span class="comment"> 第二列，映射文件名；</span></span><br><span class="line"><span class="comment"> 第三列：加载的image的UUID；</span></span><br><span class="line"><span class="comment"> 第四列，映射文件路径 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Binary Images:  </span><br><span class="line"><span class="number">0x10003c000</span> - <span class="number">0x100f7bfff</span> CrashDemo arm64  &lt;b5ae3570a013386688c7007ee2e73978&gt; /var/mobile/Applications/<span class="number">05</span>C398CE<span class="number">-21E9</span><span class="number">-43</span>C2<span class="number">-967F</span><span class="number">-26</span>DD0A327932/CrashDemo.app/CrashDemo  </span><br><span class="line"><span class="number">0x12007c000</span> - <span class="number">0x1200a3fff</span> dyld arm64  &lt;<span class="number">628</span>da833271c3f9bb8d44c34060f55e0&gt; /usr/lib/dyld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是使用 otool 工具查看到的 MedicalRecordsFolder（我的程序）的 加载命令 。</span></span><br><span class="line">$otool -l CrashDemo.app/CrashDemo   </span><br><span class="line">CrashDemo.app/CrashDemo:  </span><br><span class="line">Load command <span class="number">0</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">72</span>  </span><br><span class="line">  segname __PAGEZERO  </span><br><span class="line">   vmaddr <span class="number">0x0000000000000000</span>  </span><br><span class="line">   vmsize <span class="number">0x0000000100000000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">0</span>  </span><br><span class="line">  maxprot <span class="number">0x00000000</span>  </span><br><span class="line"> initprot <span class="number">0x00000000</span>  </span><br><span class="line">   nsects <span class="number">0</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">Load command <span class="number">1</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">792</span>  </span><br><span class="line">  segname __TEXT  </span><br><span class="line">   vmaddr <span class="number">0x0000000100000000</span>  </span><br><span class="line">   vmsize <span class="number">0x000000000000c000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">49152</span>  </span><br><span class="line">  maxprot <span class="number">0x00000005</span>  </span><br><span class="line"> initprot <span class="number">0x00000005</span>  </span><br><span class="line">   nsects <span class="number">9</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">……  </span><br><span class="line">Load command <span class="number">2</span> </span><br><span class="line">……  </span><br></pre></td></tr></table></figure><p>在 binary image 第一行可以看出进程空间的 0x10003c000 - 0x100f7bfff 这个区域在运行时被映射为 CrashDemo 内的内容，也就是我们的 ELF 文件(区域起始地址为0x10003c000)。<br>而在 Load Command 中看到的<code>__TEXT</code>的段起始地址却是 0x0000000100000000。<br>显而易见：slide = 0x10003c000(Load Address) - 0x100000000(VM Address) = 0x3c000；之后，就可以通过公式<code>symbol address = stack address - slide;</code> 来计算stack address 在crash log 中已经找到了。</p></li></ul><h4 id="2-3-3-Symbol-Address符号化"><a href="#2-3-3-Symbol-Address符号化" class="headerlink" title="2.3.3 Symbol Address符号化"></a>2.3.3 Symbol Address符号化</h4><ul><li><p>利用<code>dwarfdump</code>可以从dsym文件中得到symbol Address对应的内容：</p><ul><li>拿到crash日志后，我们要先确定dsym文件是否匹配。可以使用下面命令查看dsym文件所有架构的UUID：<code>dwarfdump --uuid CrashDemo.app.dSYM </code>，然后跟crash日志中Binary Images中的UUID相比对。</li><li>用得到的Symbol Address去 dsym 文件中查询，命令如下：<code>dwarfdump --arch arm64 --lookup [Symbol Address] CrashDemo.app.dSYM</code>，就可以定位下来具体的代码、函数名、所处的文件、行等信息了</li></ul></li><li><p>如果只是简单的获取符号名，可以用<code>atos</code>来符号化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -o [dsym file path] -l [Load Address] -arch [arch <span class="built_in">type</span>] [Stack Address]</span><br></pre></td></tr></table></figure><ul><li>不需要指定Symbol Address，只需要Load Address、Stack Address即可。</li></ul></li></ul><h2 id="三、进程地址空间"><a href="#三、进程地址空间" class="headerlink" title="三、进程地址空间"></a>三、进程地址空间</h2><p>由于ASLR的作用，进程的地址空间变得流动性非常大。但是尽管具体的地址会随机“滑动”某个小的偏移量，但整体布局保持不变。</p><p>内存空间分为以下几个段：</p><ul><li><strong>__PAGEZERO</strong>：在32位的系统中，这是内存中单独的一个页面(4KB)，而且这个页面所有的访问权限都被撤消了。在 64 位系统上，这个段对应了一个完整的32位地址空间(即前4GB)。这个段有助于捕捉空指针引用(因为空指针实际上就是 0)，或捕捉将整数当做指针引用(因为32位平台下的 4095 以下的值，以及64位平台下4GB以下的值都在这个范围内)。由于这个范围内所有访问权限(读、写和执行)都被撤消了，所以在这个范围内的任何解引用操作都会引发来自 MMU 的硬件页错误， 进而产生一个内核可以捕捉的陷阱。内核将这个陷阱转换为C++异常或表示总线错误的POSIX信号(SIGBUS) 。</li></ul><blockquote><p>PAGEZERO不是设计给进程使用的，但是多少成为了恶意代码的温床。想要通过“额外”代码感染Mach-O的攻击者往往发现可以很方便地通过PAGEZERO实现这个目的。PAGEZERO通常不属于目标文件的一部分(其对应的加载指令LC_SEGMENT将filesize指定为0)，但是对此并没有严格的要求.</p></blockquote><ul><li><strong>__TEXT</strong>：这个段存放的是程序代码。和其他所有操作系统一样，文本段被设置为r-x，即只读且可执行。这不仅可以防止二进制代码在内存中被修改，还可以通过共享这个只读段优化内存的使用。通过这种方式，同一个程序的多个实例可以仅使用一份TEXT副本。文本段通常包含多个区，实际的代码在_text区中。文本段还可以包含其他只读数据，例如常量和硬编码的字符串。</li><li><strong>__LINKEDIT</strong>：由dyld使用，这个区包含了字符串表、符号表以及其他数据。</li><li><strong>__IMPORT</strong>：用于 i386 的二进制文件的导入表。</li><li><strong>__DATA</strong>：用于可读/可写的数据。</li><li><strong>__MALLOC_TINY</strong>：用于小于一个页面大小的内存分配。</li><li><strong>__MALLOC_SMALL</strong>：用于几个页面大小的内存分配。</li></ul><p>下面是使用<code>vmmap(1)</code>输出的一个实例<code>程序a</code>在<code>32位</code>硬件设备上运行的进程地址空间，显示了区域的名称、地址范围、权限(当前权限和最高权限)以及映射的名称(通常对应的是Mach-O目标文件，如果有的话)。</p><p>32位进程的虚拟地址空间布局：</p><img src="/images/compilelink/29.png" alt="26" style="zoom:90%;" /><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>应该注意的是，尽管ASLR是很显著的改进，但也不是万能药。黑客仍然能找到聪明的方法破解程序。事实上，目前臭名昭著的“Star 3.0”漏洞就攻破了ASLR，这个漏洞越狱了 iPad 2 上的iOS 4.3。这种破解使用了Retum-Oriented Programming(ROP)攻击技术，通过缓冲区溢出破坏栈，以设置完整的栈帧， 模拟对libSystem的调用。同样的技术也用在iOS 5.0.1的“corona”漏洞中，这个漏洞成功地攻入了所有的苹果设备，包括当时最新的iPhone 4S。</p><p>预防攻击的唯一之道就是编写更加安全的代码，并且采用严格的代码审查，既要包含自动的技术，也要有人工的介入。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li>《深入解析Mac OS X &amp; iOS 操作系统》</li><li><a href="https://blog.csdn.net/zhongad007/article/details/90022617">动态调试之ASLR</a></li><li><a href="https://blog.csdn.net/xiaofei125145/article/details/50456614">iOS crash log 解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ASLR引入&quot;&gt;&lt;a href=&quot;#一、ASLR引入&quot; class=&quot;headerlink&quot; title=&quot;一、ASLR引入&quot;&gt;&lt;/a&gt;一、ASLR引入&lt;/h2&gt;&lt;p&gt;进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(四) Mach-O 文件的装载</title>
    <link href="https://tenloy.github.io/2021/09/25/compile-load.html"/>
    <id>https://tenloy.github.io/2021/09/25/compile-load.html</id>
    <published>2021-09-25T14:26:00.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/compilelink/25.png" alt="25" style="zoom:80%;" /><p>先附上源码地址：结合 <a href="https://opensource.apple.com/tarballs/xnu/">XNU</a> 源码(应该不是最新的，且不怎么全，不过用来分析学习也差不多了)，来看加载器的流程，效果更好。重要的两个类：</p><ul><li><code>bsd/kern/kern_exec.c</code>：进程执行的相关操作：线程创建、数据初始化等。</li><li><code>bsd/kern/mach_loader.c</code>：Mach-O文件解析加载相关。第二节中提到的Mach-O文件中的内核加载器负责处理的load command 对应的内核中处理的函数都在该文件中，比如处理<code>LC_SEGMET</code>命令的<code>load_segment</code>函数、处理<code>LC_LOAD_DYLINKER</code>命令的<code>load_dylinker</code>函数(负责调用命令指定的动态链接器)。</li></ul><h2 id="一、装载概述"><a href="#一、装载概述" class="headerlink" title="一、装载概述"></a>一、装载概述</h2><p>在链接完成之后，应用开始运行之前，有一段装载过程，我们都知道程序执行时所需要的指令和数据必须在内存中才能够被正常运行。</p><p>最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的<code>静态装入</code>的办法。</p><p>但是很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量不够时，根本的解决办法就是添加内存。相对于磁盘来说，内存是昂贵且稀有的，这种情况自计算机磁盘诞生以来一直如此。所以人们想尽各种办法，希望能够在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。后来研究发现，程序运行时是有<code>局部性原理</code>的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是<code>动态装入</code>的基本原理。（这也是<code>虚拟地址空间</code>机制要解决的问题，这里不再赘述，大学都学过）</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><h2 id="二、装载理论篇"><a href="#二、装载理论篇" class="headerlink" title="二、装载理论篇"></a>二、装载理论篇</h2><p>在虚拟存储中，现代的硬件MMU都提供地址转换的功能。有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。</p><p>事实上，从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那么我们就来看看这种最通常的情形：<strong>创建一个进程，然后装载相应的可执行文件并且执行</strong>。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间。</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><p><strong>首先是创建虚拟地址空间</strong>。一个虚拟空间由<code>一组页映射函数</code>将<code>虚拟空间的各个页</code>映射至相应的<code>物理空间</code>，所以创建一个虚拟空间实际上并不是创建空间而是<code>创建映射函数所需要的相应的数据结构</code>，在i386 的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</p><p><strong>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</strong>。上面那一步的<code>页映射关系函数是虚拟空间到物理内存的映射关系</code>，这一步所做的是<code>虚拟空间与可执行文件的映射关系</code>。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。</p><p>但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p><blockquote><p>由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。</p></blockquote><p>很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做<strong>虚拟内存区域</strong>（VMA, Virtual Memory Area）；在Windows中将这个叫做<strong>虚拟段</strong>（Virtual Section），其实它们都是同一个概念。</p><blockquote><p>VMA是一个很重要的概念，它对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。</p></blockquote><p>操作系统在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以<code>通过查找这样的一个数据结构来定位错误页在可执行文件中的位置</code>。</p><p><strong>将CPU指令寄存器设置成可执行文件入口，启动运行</strong>。第三步其实也是最简单的一步，操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址(通常是text区的地址)。</p><ul><li>ELF文件头中，有<code>e_entry</code>字段保存入口地址</li><li>Mach-O文件中的<code>LC_MAIN</code>加载指令作用就是设置程序主程序的入口点地址和栈大小)</li></ul><h2 id="三、Mach-O文件的装载"><a href="#三、Mach-O文件的装载" class="headerlink" title="三、Mach-O文件的装载"></a>三、Mach-O文件的装载</h2><p><a href="https://www.jianshu.com/p/332b183c055a">(二) Mach-O 文件结构</a> 介绍 <code>Mach Heade</code> 中的 <code>Load Command</code> 加载命令，结合其用途，就可以简单看出可执行文件的装载流程：</p><ul><li><p>首先，是由内核加载器(定义在<code>bsd/kern/mach_loader.c</code>文件中)来处理一些需要由内核加载器直接使用的加载命令。<strong>内核的部分(内核加载器)负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作</strong>。（这也是本篇内容主要讲的）</p></li><li><p>接着，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DY LINKER</code>命令指定的<code>动态链接器</code>在用户态完成的。（下一篇文章再细讲<code>dyld</code>及<code>动态链接</code>）</p></li></ul><p>下面通过代码来看一下具体的过程。下面通过一个调用栈图来说明， 这里面每个方法都做了很多事情，这里只注释了到_dyld_start的关键操作，很简略。有兴趣可以详细看源码<code>kern_exec.c</code>、<code>mach_loader.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">▼ execve       <span class="comment">// 用户点击了app，用户态会发送一个系统调用 execve 到内核</span></span><br><span class="line">  ▼ __mac_execve  <span class="comment">// 主要是为加载镜像进行数据的初始化，以及资源相关的操作，以及创建线程</span></span><br><span class="line">    ▼ exec_activate_image <span class="comment">// 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。</span></span><br><span class="line">      <span class="comment">// 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 该方法为Mach-o Binary对应的执行方法；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Fat Binary，对应方法为exec_fat_imgact；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Interpreter Script，对应方法为exec_shell_imgact</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ▼ exec_mach_imgact   </span><br><span class="line">        ▶︎ <span class="comment">// 首先对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，判断魔数、cputype、cpusubtype等信息。如果image无效，会直接触发assert(exec_failure_reason == OS_REASON_NULL); 退出。</span></span><br><span class="line">          <span class="comment">// 拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载。然后把Mach-O映射到内存中去，调用load_machfile()</span></span><br><span class="line">        ▼ load_machfile</span><br><span class="line">          ▶︎ <span class="comment">// load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。</span></span><br><span class="line">            <span class="comment">// 真正负责对加载命令解析的是parse_machfile()</span></span><br><span class="line">          ▼ parse_machfile  <span class="comment">//解析主二进制macho</span></span><br><span class="line">            ▶︎ <span class="comment">/* </span></span><br><span class="line"><span class="comment">               * 首先，对image头中的filetype进行分析，可执行文件MH_EXECUTE不允许被二次加载(depth = 1)；动态链接编辑器MH_DYLINKER必须是被可执行文件加载的(depth = 2)</span></span><br><span class="line"><span class="comment">               * 然后，循环遍历所有的load command，分别调用对应的内核函数进行处理</span></span><br><span class="line"><span class="comment">               *   LC_SEGMET：load_segment函数：对于每一个段，将文件中相应的内容加载到内存中：从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。</span></span><br><span class="line"><span class="comment">               *   LC_UNIXTHREAD：load_unixthread函数，见下文</span></span><br><span class="line"><span class="comment">               *   LC_MAIN：load_main函数</span></span><br><span class="line"><span class="comment">               *   LC_LOAD_DYLINKER：获取动态链接器相关的信息，下面load_dylinker会根据信息，启动动态链接器</span></span><br><span class="line"><span class="comment">               *   LC_CODE_SIGNATURE：load_code_signature函数，进行验证，如果无效会退出。理论部分，回见第二节load_command `LC_CODE_SIGNATURE `部分。</span></span><br><span class="line"><span class="comment">               *   其他的不再多说，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            ▼ load_dylinker <span class="comment">// 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span></span><br><span class="line">              ▼ parse_machfile <span class="comment">// 开始解析 dyld 这个mach-o文件</span></span><br><span class="line">                ▼ load_unixthread <span class="comment">// 解析 dyld 的 LC_UNIXTHREAD 命令，这个过程中会解析出entry_point</span></span><br><span class="line">                  ▼ load_threadentry  <span class="comment">// 获取入口地址</span></span><br><span class="line">                    ▶︎ thread_entrypoint  <span class="comment">// 里面只有i386和x86架构的，没有arm的，但是原理是一样的</span></span><br><span class="line">                  ▶︎ <span class="comment">//上一步获取到地址后，会再加上slide，ASLR偏移，到此，就获取到了dyld的入口地址，也就是 _dyld_start 函数的地址</span></span><br><span class="line">        ▼ activate_exec_state</span><br><span class="line">          ▶︎ thread_setentrypoint <span class="comment">// 设置entry_point。直接把entry_point地址写入到用户态的寄存器里面了。</span></span><br><span class="line">          <span class="comment">//这一步开始，_dyld_start就真正开始执行了。</span></span><br><span class="line"></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start() </span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▼ 这是下篇内容</span><br></pre></td></tr></table></figure><h2 id="四、Linux-ELF文件的装载（了解）"><a href="#四、Linux-ELF文件的装载（了解）" class="headerlink" title="四、Linux ELF文件的装载（了解）"></a>四、Linux ELF文件的装载（了解）</h2><p>首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用 <code>execve()</code>系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 execve() 系统调用被定义在unistd.h，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三个参数分别是被执行的程序文件名、执行参数和环境变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </span><br></pre></td></tr></table></figure><p>Glibc对该系统调用进行了包装，提供了 execl()、execlp()、execle()、execv()、execvp()等5个不同形式的exec系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到 execve() 这个系统中。</p><p>在进入 execve() 系统调用之后，Linux内核就开始进行真正的装载工作。</p><ul><li><p><code>sys_execve()</code>，在内核中，该函数是execve()系统调用相应的入口，定义在arch\i386\kernel\Process.c。 该函数进行一些参数的检查复制之后，调用 do_execve()。</p></li><li><p><code>do_execve()</code>，该函数会首先查找被执行的文件，如果找到文件，则读取文件的前128个字节。目的是判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做<code>魔数</code>（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如：</p><ul><li>ELF的可执行文件格式的头4个字节为0x7F、’e’、’l’、’f’；</li><li>Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’；</li><li>如果被执行的是Shell脚本或perl、python等这种解释型语言的脚本，那么它的第一行往往是 “#!/bin/sh” 或 “#!/usr/bin/perl” 或 “#!/usr/bin/python” ，这时候前两个字节<code>&#39;#&#39;</code>和<code>&#39;!&#39;</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</li></ul><p>当do_execve()读取了这128个字节的文件头部之后，然后调用search_binary_handle()。</p></li><li><p><code>search_binary_handle()</code>，该函数会去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，此函数会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如：</p><ul><li>ELF可执行文件的装载处理过程叫做 load_elf_binary()； </li><li>a.out可执行文件的装载处理过程叫做 load_aout_binary()；</li><li>装载可执行脚本程序的处理过程叫做 load_script()。</li></ul></li><li><p><code>load_elf_binary()</code>，这个函数被定义在fs/Binfmt_elf.c，代码比较长，它的主要步骤是：</p><ol><li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li><li>寻找动态链接的“.interp”段，设置动态链接器路径。</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是 DT_FINI 的地址（动态链接相关）。</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中 <code>e_entry</code> 所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li></ol></li></ul><p>当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时， 上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序(或动态链接器)的入口地址了。所以当 <code>sys_execve()</code>系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/">Dyld系列之一：_dyld_start之前</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/compilelink/25.png&quot; alt=&quot;25&quot; style=&quot;zoom:80%;&quot; /&gt;

&lt;p&gt;先附上源码地址：结合 &lt;a href=&quot;https://opensource.apple.com/tarballs/xnu/&quot;&gt;XNU&lt;</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(三) Mach-O 文件的静态链接</title>
    <link href="https://tenloy.github.io/2021/09/24/compile-static-link.html"/>
    <id>https://tenloy.github.io/2021/09/24/compile-static-link.html</id>
    <published>2021-09-24T14:25:56.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接概述"><a href="#一、链接概述" class="headerlink" title="一、链接概述"></a>一、链接概述</h2><p>链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？</p><p>很久以前，人们编写程序时，将所有源代码都写在同一个文件中，发展到后来一个程序源代码的文件长达数百万行，以至于人们没有能力维护这个程序。</p><p>后来，出现了模块化。现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。</p><p>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。<code>模块之间如何组合的问题可以归结为模块之间如何通信的问题</code>，最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的<strong>函数调用</strong>，另外一种是模块间的<strong>变量访问</strong>。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是<code>模块间符号的引用</code>。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼接刚好完美组合。这个模块的拼接过程就是：<strong>链接</strong></p><img src="/images/compilelink/18.jpg" alt="18" style="zoom:100%;" /><p>综上所述，链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。现代的高级语言的诸多特性和功能，使得编译器、链接器更为复杂，功能更为强大，但从原理上来讲，链接器的工作无非就是把一些指令对其他符号地址的引用加以修正。<strong>链接过程主要包括了地址和空间分配（Address and StorageAllocation）、符号决议（Symbol Resolution）和重定位 （Relocation）等这些步骤。</strong>（<code>符号可以理解为函数名和变量名</code>）</p><p>链接分为静态链接、动态链接。本篇只讲静态链接及静态链接器。</p><ul><li>静态链接是把目标文件（一个或多个）和需要的静态库链接成可执行文件。</li><li>动态链接是在可执行文件<code>装载</code>、<code>运行</code>时进行的文件的链接。</li></ul><h2 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h2><h3 id="2-1-链接器"><a href="#2-1-链接器" class="headerlink" title="2.1 链接器"></a>2.1 链接器</h3><p>lld链接器是LLVM的一个子项目，旨在为LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。</p><p>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p><h3 id="2-2-静态链接过程"><a href="#2-2-静态链接过程" class="headerlink" title="2.2 静态链接过程"></a>2.2 静态链接过程</h3><h4 id="2-2-1-两步链接"><a href="#2-2-1-两步链接" class="headerlink" title="2.2.1 两步链接"></a>2.2.1 两步链接</h4><p>我们知道，可执行文件中的代码段和数据段都是由输入的目标文件中合并而成的。那么链接过程就产生了第一个问题：对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p><ol><li><p><strong>按序叠加</strong>：一个最简单的方案就是将输入的目标文件按照次序叠加起来。（比如按照编译顺序，先编译的在前）。</p><p><strong>缺点</strong>：在有很多输入文件的情况下，输出文件将会有很多零散的段。假如有数百个目标文件，且都分别有.text段、.data段、.bss段，那最后的输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都须要有一定的地址和空间对齐要求(<strong>x86中，段的装载地址和空间的对齐单位是页，也就是4096字节</strong>)。</p></li><li><p><strong>相似段合并</strong>：将相同性质的段合并到一起。</p></li></ol><img src="/images/compilelink/19.jpg" alt="18" style="zoom:90%;" /><p>现在的链接器空间分配的策略基本上都会使相似段(Section)合并，使用这种方法的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。也就是说整个链接过程分两步：</p><h4 id="2-2-2-符号表与符号"><a href="#2-2-2-符号表与符号" class="headerlink" title="2.2.2 符号表与符号"></a>2.2.2 符号表与符号</h4><p>以下示例来自<a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a>，过程很简单，就是对于目标文件、可执行文件的MachOView的分析，目标文件、可执行文件是链接过程的输入、输出，通过对两个文件中的<code>符号表Symbols</code>、<code>代码段__TEXT.__text</code>来看一下引用符号的空间与地址分配、地址绑定过程。关于目标文件、可执行文件的生成上一篇文章已经讲过，本篇文章就直接看分析结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_var;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    func(a+global_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="keyword">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    global_var = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成a.o b.o</span></span><br><span class="line">xcrun -sdk iphoneos clang -c a.c b.c -target arm64-apple-ios12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o和b.o链接成可执行文件ab</span></span><br><span class="line">xcrun -sdk iphoneos clang a.o b.o -o ab -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure><p>请注意，生成的a.o和b.o目标文件，都是基于arm64。a.o和b.o目标文件通过静态链接后生成可执行文件ab。（由于基于arm64，其实链接过程，也有动态链接库libSystem.B.dylib(系统库)参与,但本文忽略动态链接的参与，只讨论静态链接）。</p><img src="/images/compilelink/20.png" alt="18" style="zoom:80%;" /><p>在可执行文件ab中，之所以<code>__TEXT.text</code>段的虚拟地址为<code>0x100000000</code>，而在文件中的位置(偏移)为<code>0</code>，是因为在链接生成可执行文件时，产生的一个特殊的段<code>__PAGEZERO</code>，这个段，在可执行文件中不占空间<code>File Offest</code>、<code>File Size</code>都为0，而在虚拟地址空间中，占用了很大的空间，<code>VMSize</code>为<code>0x100000000(4G)</code>.</p><p>在进入重定位之前，这里还需要再介绍一下符号表相关的知识点：符号表的加载命令、符号表的结构。</p><h5 id="1-符号表的加载命令"><a href="#1-符号表的加载命令" class="headerlink" title="1. 符号表的加载命令"></a>1. 符号表的加载命令</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2. 符号表"></a>2. 符号表</h5><p>符号表也是一个数组，里面元素是结构体nlist_64。符号表示意图见下方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> n_strx;   <span class="comment">/* 字符串表的index，可以找到符号对应的字符串（index into the string table） */</span></span><br><span class="line">    &#125; n_un;                <span class="comment">/* 历史原因，忽略 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_type;       <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_sect;       <span class="comment">/* section的编号或NO_SECT（section number or NO_SECT） */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* 符号的地址值（value of this symbol (or stab offset)） */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它先不管，要是有兴趣，可以去头文件&lt;mach-o/nlist.h&gt;查看。</span></span><br></pre></td></tr></table></figure><p>左侧是a.o的符号表，右侧是可执行文件的(全局)符号表：</p><img src="/images/compilelink/21.png" alt="18" style="zoom:80%;" /><p>相比于<code>a.o</code>、<code>b.o</code>目标文件，此时，可执行文件<code>ab</code>中的全局符号表中，每个符号都有了对应的(虚拟空间)地址，这是重定位的前提。</p><h5 id="3-符号表中符号的几种类型"><a href="#3-符号表中符号的几种类型" class="headerlink" title="3. 符号表中符号的几种类型"></a>3. 符号表中符号的几种类型</h5><blockquote><p><a href="https://www.jianshu.com/p/bda60193808d">引自-符号和符号表</a></p></blockquote><p>每个可重定位模块都有一个符号表，它包含了在本模块中定义和引用的符号，有三种链接器符号：</p><table><thead><tr><th>类型</th><th>特征</th><th>举例</th></tr></thead><tbody><tr><td><strong>Global symbols</strong>（模块内部定义的<strong>全局符号</strong>）</td><td>由本模块定义并能被其他模块引用的符号</td><td>例如，非static C函数和非 static的C全局变量（指不带static的全局变量）</td></tr><tr><td><strong>External symbols</strong>（外部定义的<strong>全局符号</strong>）</td><td>由其他模块定义并被本模块引用了的全局符号</td><td>例如，在本模块中extern声明的其它模块中定义的符号</td></tr><tr><td><strong>Local symbols</strong>（本模块的<strong>局部符号</strong>）</td><td>仅由本模块内定义和引用的本地符号</td><td>例如，在本模块中定义的带static 的C函数和全局变量。</td></tr></tbody></table><p><strong>注意：链接器局部符号</strong></p><ul><li><strong>不是指程序中的局部变量</strong>（分配在栈中的临时性变量），链接器是不关心这种局部变量的。</li><li><strong>个人理解</strong>：局部符号在本模块内定义并引用，按照符号解析的功能来看，其是不参与符号解析的。这也是为什么多个目标文件中出现同名的局部符号，在链接时，却不会报<code>符号重定义</code>的原因。并且查看链接后的可执行文件，符号表中，是可以同时存在多个同名局部符号的。</li></ul><h4 id="2-2-3-第一步-空间与地址分配"><a href="#2-2-3-第一步-空间与地址分配" class="headerlink" title="2.2.3 第一步 空间与地址分配"></a>2.2.3 第一步 空间与地址分配</h4><p>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：</p><ul><li>第一个是在输出的可执行文件中的空间；</li><li>第二个是在装载后的虚拟地址中的虚拟地址空间。</li></ul><p>对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接过程关系并不是很大。</p><h5 id="1-相似段合并"><a href="#1-相似段合并" class="headerlink" title="1. 相似段合并"></a>1. 相似段合并</h5><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<code>全局符号表</code>。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p><p>应该说地址与空间分配，地址：分配到哪；空间：分配多大。链接器的地址与空间分配，既是指在可执行文件中的分配，也指在虚拟地址空间中的分配。</p><ul><li><code>可执行文件的地址空间</code>与目标文件中一样，地址从0开始。</li><li><code>虚拟地址空间</code>中的地址并非从0开始，比如Linux下，ELF可执行文件中的数据，在进程虚拟地址空间中，默认从0x08048000开始分配。</li></ul><p>我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到下一步重定位中，关于地址计算的步骤(重定位中，地址修正是修正为符号的虚拟地址空间中的地址)，而且可执行文件本身的空间分布、分配与链接过程关系并不是很大。</p><p>这一步过程：</p><ul><li>会将多个输入模块(目标文件)的数据收集，相似段进行合并，见上图。</li><li>重新计算段在可执行文件中的偏移、大小。</li><li>重新计算段在虚拟地址空间中的偏移、大小。</li></ul><p>这些信息在<code>LC_SEGMENT_64</code>中看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 初始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* segment包含的section的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号地址的确定-rebase"><a href="#2-符号地址的确定-rebase" class="headerlink" title="2. 符号地址的确定(rebase)"></a>2. 符号地址的确定(rebase)</h5><p>当前面一步完成之后，链接器开始计算各个符号的虚拟地址。(这一步修正地址的符号是本文件内定义的(数据、函数)符号，关于外部符号的引用重定位在第二步)</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(<strong>目标文件中符号表中的符号的地址，都是相对于text段起始的偏移</strong>)。</p><p>当目标文件、动态库文件等二进制文件加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h4 id="2-2-4-第二步-符号解析与重定位"><a href="#2-2-4-第二步-符号解析与重定位" class="headerlink" title="2.2.4 第二步 符号解析与重定位"></a>2.2.4 第二步 符号解析与重定位</h4><p>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。</p><h5 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1. 符号解析"></a>1. 符号解析</h5><p>符号解析：解析每个模块中<code>引用的符号</code>，将其与某个目标模块中的<code>符号定义</code>建立关联。</p><ul><li>每个定义的符号在代码段或数据段中都被分配了存储空间，将符号引用与符号定义建立关联后，就可在重定位时将引用的符号的地址重定位为相关联的定义的符号的地址。</li><li>如果没找到定义，会给出一个类似<code>“undefined reference to &#39;xxx&#39;”</code>、<code> “Undefined symbols”</code>类似的链接错误。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库、输入目标文件路径不正确、符号的声明与定义不一样等。</li><li>如果找到了，进行符号决议(绑定)：<ul><li>如果找到了一个，直接绑定；</li><li>如果链接器在输入模块中找到了一个以上的外部符号定义，会按照它的规则选择其中一个符号定义或者报错。<code>强弱符号</code>规则：<ul><li>对于C/C++语言来说，编译器默认函数和已初始化的全局变量为强符号，未初始化的全局变量为弱符号。</li><li>强符号只能被定义一次，否则报符号重复定义错误。符号的重复定义错误与类型无关，只要经过符号修饰机制后产生的符号相同，就报符号重复<code>“ld: dumplicate symbols”</code></li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选强符号。(Xcode中默认设置了clang编译参数，遇到强弱符号会报重复定义错误)</li><li>如果一个符号在所有目标文件中都是弱符号，会选择占用空间最大的一个（《程序员的自我修养》）</li></ul></li><li>动态库链接中还有<code>全局符号介入</code>规则(如果相同符号名的符号已存在，则后加入的符号被忽略))。</li></ul></li></ul><blockquote><p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定 （Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的。</p><p>大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p></blockquote><p><strong>符号解析时会选择一个确切的定义，即每个全局符号仅占一处存储空间。</strong></p><p><strong>编码建议：</strong></p><ul><li>尽量避免使用全局变量</li><li>一定要用时：<ul><li>尽量使用内部链接定义，如用static修饰</li><li>全局变量要赋初值，<strong>避免潜在的强弱符号造成的不可知错误</strong>，赋初值后，编译器检测到重复定义会报错，提醒开发者修正。</li></ul></li><li><strong>头文件中，不能写<code>Global symbols</code>的定义</strong>(否则若头文件若被多处<code>#include</code>，预处理后展开，文件内容替换该行，就相当于直接在多个源文件中出现全局符号定义，会报错)。如果要定义全局变量，一定要用static修饰，设置为<code>Local symbols</code>。</li></ul><p>符号解析完成，全局符号表中符号都有对应的定义处的地址。接下来就是重定位工作：<strong>根据重定位表<code>Relocations</code>中符号信息，在全局符号表<code>Symbols</code>中找到符号的<code>定义地址</code>，然后找到符号在代码段<code>__TEXT.text</code>中的使用地址，进行指令的地址修正。</strong></p><h5 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2. 重定位"></a>2. 重定位</h5><p>重定位就是指针修正的过程。</p><p>假设有A、B两个目标文件，B中引用了A中的一个变量并对其进行赋值，对应AT&amp;T汇编为<code>movl $0x2a, var</code>。</p><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为 0，等待链接器在将目标文件A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relocation Entry）</strong>。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p><p>从上面的示例中，可以看到：a文件使用了B文件中的global_var和func两个符号，那是怎么知道这两个符号的地址呢？</p><p>在a.o目标文件中：</p><img src="/images/compilelink/22.png" alt="18" style="zoom:70%;" /><ul><li>global_var（地址0）和func（地址0x2c，这条指令本身地址）都是假地址。编译器暂时用0x0和0x2c替代着，把真正地址计算工作留给链接器。</li><li>通过前面的空间与地址分配可以得知，链接器在完成地址与空间分配后，就可以确定所有符号的虚拟地址了。</li><li>此时，链接器根据符号的地址对每个需要重定位的指令进行地址修正。</li></ul><p>在链接后的ab可执行文件中：</p><img src="/images/compilelink/23.png" alt="18" style="zoom:70%;" /><p>可以看到global_var（地址0x100008000，指向data段，值为1）和func（地址0x100007f90，指向func函数地址）都是真正的地址。</p><p>链接器是怎么知道a模块里哪些指令要被调整，这些指令如何调整。事实上a.o里，有一个重定位表，专门保存这些与重定位相关的信息。而且每个section的section_64的header的reloff（重定位入口的文件偏移，即在重定位表里的偏移）和nreloc（几个需要重定位的符号），让链接器知道a模块的哪个section里的指令需要调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-重定位表"><a href="#3-重定位表" class="headerlink" title="3. 重定位表"></a>3. 重定位表</h5><p>重定位表可以认为是一个数组，数组里的元素为结构体relocation_info。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/reloc.h&gt;里</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> &#123;</span></span><br><span class="line">   <span class="keyword">int32_t</span>    r_address;<span class="comment">/* 重定位的符号在自己所在section中的偏移(地址)；offset in the section to what is being relocated */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   r_symbolnum:<span class="number">24</span>,<span class="comment">/* 如果r_extern == 0(外部符号)，则表示符号在符号表中的索引，如果r_extern == 0，则表示section的序数；symbol index if r_extern == 1 or section ordinal if r_extern == 0 */</span></span><br><span class="line">              r_pcrel:<span class="number">1</span>, <span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">              r_length:<span class="number">2</span>,<span class="comment">/* 重定位符号的长度；0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">              r_extern:<span class="number">1</span>,<span class="comment">/* 不包含引用符号的值(即为外部符号)；does not include value of sym referenced */</span></span><br><span class="line">              r_type:<span class="number">4</span>;        <span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r_address和r_length足够让我们知道要重定位的字节了；</span></span><br></pre></td></tr></table></figure><img src="/images/compilelink/24.png" alt="18" style="zoom:70%;" /><p>可以看出：</p><ul><li>a.o文件的重定位表中记录符号了_func和_global_var两个需要重定位的符号，并且<code>r_address</code>给出了两个符号在代码段section的位置，<code>r_symbolnum</code>指向了符号在符号表的index。</li><li>链接时候，a.o里面有这两符号的引用，然后b.o里面有这两符号的定义，一起合并到全局符号表里（见下方符号表部分中的示意图）。</li><li>在全局符号表里，可以找到这两个符号的虚拟内存位置和其它信息，就可以完成重定位工作(对指令进行地址修正)了。</li></ul><h3 id="2-3-静态库链接"><a href="#2-3-静态库链接" class="headerlink" title="2.3 静态库链接"></a>2.3 静态库链接</h3><p>一个静态库可以简单看成一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件。</p><p>静态库链接：是指自己的模块与静态库里的某个模块（用到的某个目标文件，或多个目标文件）链接成可执行文件。其实和静态链接概念一样，只是这里，我们这里取了静态库里的某个/多个目标文件与我们自己的目标文件一起作为输入。</p><p>Q：为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a静态库里面printf.o只有printf()函数、strlen.o只有strlen()函数，为什么要这样组织？</p><p>A：我们知道，<strong>链接器在链接静态库的时候是<code>以目标文件为单位</code>的</strong>。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件（函数）就不要链接到最终的输出文件中。</p><h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a></li><li><a href="">《程序员的自我修养》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、链接概述&quot;&gt;&lt;a href=&quot;#一、链接概述&quot; class=&quot;headerlink&quot; title=&quot;一、链接概述&quot;&gt;&lt;/a&gt;一、链接概述&lt;/h2&gt;&lt;p&gt;链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) Mach-O 文件结构</title>
    <link href="https://tenloy.github.io/2021/09/23/compile-macho.html"/>
    <id>https://tenloy.github.io/2021/09/23/compile-macho.html</id>
    <published>2021-09-23T14:25:50.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式<code>Mach-O的结构</code>，方便了解之后的<code>链接</code>生成可执行文件的过程。</p><p>先附上相关源码地址：与Mach-O 文件格式有关的结构体定义都可以从 <code>/usr/include/mach-o/loader.h</code> 中找到(直接在xcode项目中找到<code>loader.h</code>，然后Show In Finder即可)。</p><h2 id="一、进程与二进制格式"><a href="#一、进程与二进制格式" class="headerlink" title="一、进程与二进制格式"></a>一、进程与二进制格式</h2><p>进程在众多操作系统中都有提及，它是作为一个正在执行的程序的实例，这是 UNIX 的一个基本概念。而进程的出现是特殊文件在内从中加载得到的结果，这种文件必须使用操作系统可以认知的格式，这样才对该文件引入依赖库，初始化运行环境以及顺利地执行创造条件。</p><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）。macOS 支持三种可执行格式：解释器脚本格式、通用二进制格式和 Mach-O 格式(关于三者区别，在下面说到Mach-O Header的时候介绍)。</p><h2 id="二、相关工具"><a href="#二、相关工具" class="headerlink" title="二、相关工具"></a>二、相关工具</h2><p>命令行工具</p><ul><li><p>file 命令，查看Mach-O文件的基本信息：<code>file 文件路径</code></p></li><li><p>otool 命令，查看Mach-O特定部分和段的内容</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Mach-O文件的header信息</span></span><br><span class="line">otool -h 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件的load commands信息</span></span><br><span class="line">otool -l 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多使用方法，终端输入otool -help查看</span></span><br></pre></td></tr></table></figure><ul><li>lipo 命令，来处理多架构Mach-O文件，常用命令如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看架构信息</span></span><br><span class="line">lipo -info 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出某种类型的架构</span></span><br><span class="line">lipo 文件路径 -thin 架构类型 -output 输出文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并多种架构类型</span></span><br><span class="line">lipo 文件路径1 文件路径2 -output 输出文件路径</span><br></pre></td></tr></table></figure><p>GUI工具</p><ul><li>MachOView：文件浏览。<a href="https://github.com/gdbinit/MachOView">MachOView官网</a></li><li>hopper：反汇编工具</li></ul><h2 id="三、Mach-O-文件格式"><a href="#三、Mach-O-文件格式" class="headerlink" title="三、Mach-O 文件格式"></a>三、Mach-O 文件格式</h2><p>Mach-O 文件格式在官方文档中有一个描述图，很多教程中都引用到。<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html">官网文档</a></p><img src="/images/compilelink/12.png" alt="12" style="zoom:90%;" /><p>可以看的出 Mach-O 主要由 3 部分组成，下面一一讲述。Load Command的作用是指导内核加载器、动态链接器怎么将可执行文件装载到内存进行执行。所以Load Command放到最后一部分。</p><h3 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h3><p>用 helloworld 来做个试验：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// main.cpp</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>clang -g main.cpp -o main</code> 生成执行文件。然后拖入到 <em>MachOView</em> 中来查看一下加载 Segment 的结构（当然使用 <em>Synalyze It!</em> 也能捕捉到这些信息的，但是 <em>MachOView</em> 更对结构的分层更加一目了然）：</p><img src="/images/compilelink/13.jpg" alt="12" style="zoom:80%;" /><h3 id="3-2-Mach-O-头"><a href="#3-2-Mach-O-头" class="headerlink" title="3.2 Mach-O 头"></a>3.2 Mach-O 头</h3><p>Mach-O 头（Mach Header）描述了 Mach-O 的 CPU 架构、大小端、文件类型以及加载命令等信息。它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p><p>以下只给出 64 位定义的代码，因为 32 位的区别是缺少了一个预留字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC    0xfeedface    <span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM    0xcefaedfe    <span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;            <span class="comment">/* magic(魔数)：用来确认文件的格式，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。 */</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>    cputype;        <span class="comment">/* CPU架构 */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>    cpusubtype;  <span class="comment">/* CPU子版本 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filetype;         <span class="comment">/* 文件类型，常见的Mach-O文件有：MH_OBJECT(目标文件)、MH_EXECUTABLE(可执行二进制文件)、MH_DYLIB(动态库)等等。这些文件类型定义在 loader.h 文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    ncmds;            <span class="comment">/* 加载器中加载命令的数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sizeofcmds;       <span class="comment">/* 加载器中所有加载命令的总大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;            <span class="comment">/* dyld 加载需要的一些标志，其中MH_PIE表示启用地址空间布局随机化(ASLR)。其他的值在loader.h文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved;         <span class="comment">/* 64位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>魔数会表明文件的格式。filetype会表明具体是什么文件类型(都是猫，也分黑猫、白猫)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// magic：常见的魔数(Mac是小端模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mach-O文件。用途：macOS 的原生二进制格式</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC0xfeedface  <span class="comment">/* 32位设备上的魔数，大端模式(符合人类阅读习惯，高位数据在前) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM0xcefaedfe  <span class="comment">/* 32位、小端(高位地址在后)，CIGAM就是MAGIC反过来写，从命名上也可以看出端倪 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC_64 0xfeedfacf  <span class="comment">/* 64位、大端 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM_64 0xcffaedfe  <span class="comment">/* 64位、小端 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用二进制格式FAT。用途：包含多种架构支持的二进制格式，只在 macOS 上支持。(在文章末尾简单介绍一下，有兴趣可以瞜一眼)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC     0xcafebabe</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM     0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC_64  0xcafebabf</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM_64  0xbfbafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC_64) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//脚本格式。用途：主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 `#!` 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令。</span></span><br><span class="line">  <span class="comment">// 魔数为 \x7FELF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filetype：常见的Mach-O格式的文件类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_OBJECT  0x1<span class="comment">/* 可重定位的目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_EXECUTE0x2<span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLIB  0x6<span class="comment">/* 动态绑定共享库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLINKER0x7<span class="comment">/* 动态链接编辑器，如dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_BUNDLE  0x8<span class="comment">/* 动态绑定bundle(包)文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DSYM  0xa<span class="comment">/* 调试所用的符号文件 */</span></span></span><br></pre></td></tr></table></figure><p>举例：利用otool工具查看Mach-o文件的头部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -hv bibi.decrypted </span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">   MH_MAGIC     ARM         V7  0x00     EXECUTE    59       6016   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br><span class="line"></span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    59       6744   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br></pre></td></tr></table></figure><h3 id="3-3-Data"><a href="#3-3-Data" class="headerlink" title="3.3 Data"></a>3.3 Data</h3><p>数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码。</p><blockquote><p>Raw segment data存放了所有的原始数据，而Load commands相当于Raw segment data的索引目录</p></blockquote><h4 id="3-3-1-Segment-段"><a href="#3-3-1-Segment-段" class="headerlink" title="3.3.1 Segment(段)"></a>3.3.1 Segment(段)</h4><p>其中，LC_SEGMENT_64定义了一个64位的段，当文件加载后映射到地址空间(包括段里面节的定义)。64位段的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护，用八进制表示(4=r(read)，2=w(write)，1=x(execute执行权限)) */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 段页面最初始的内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* 段(segment)包含的区(section)的个数(如果存在的话) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>系统将 fileoff 偏移处 filesize 大小的内容加载到虚拟内存的 vmaddr 处，大小为vmsize，段页面的权限由initprot进行初始化。它的权限可以动态改变，但是不能超过maxprot的值，例如 _TEXT 初始化和最大权限都是可读/可执行/不可写。</strong></p><p>常见的<code>LC_SEGMENT</code> Segment (cmd为<code>LC_SEGMET</code>)，其<code>segname[16]</code>有以下几种值：</p><ul><li><strong>__PAGEZERO</strong>：空指针陷阱段，映射到虚拟内存空间的第1页，用于捕捉对 NULL 指针的引用。</li><li><strong>__TEXT</strong>：代码段/只读数据段。</li><li><strong>__DATA</strong>：读取和写入数据的段。</li><li><strong>__LINKEDIT</strong>：动态链接器需要使用的信息，包括符号表、重定位表、绑定信息、懒加载信息等。</li><li><strong>__OBJC</strong>：包含会被Objective Runtime使用到的一些数据。(从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述)</li></ul><h4 id="3-3-2-Section-节"><a href="#3-3-2-Section-节" class="headerlink" title="3.3.2 Section(节)"></a>3.3.2 Section(节)</h4><p>从示例图中可以看到，部分的 Segment (<code>__TEXT</code> 和 <code>__DATA</code>) 可以进一步分解为 Section。</p><p>之所以按照 Segment(段) -&gt; Section(节) 的结构组织方式，是因为在同一个 Segment 下的 Section，在内存中的权限相同(编译时，编译器把相同权限的section放在一起，成为segment)，可以不完全按照 Page 的大小进行内存对齐，节省内存的空间。而 Segment 对外整体暴露，在装载程序时，完整映射成一个vma(Virtual Memory Address)，更好的做到内存对齐，减少内存碎片（可以参考《OS X &amp; iOS Kernel Programming》第一章内容）。</p><p>Section 具体的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合示例图，下面列举一些常见(并非全部)的 Section：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __TEXT Segment(段)下面的节：</span></span><br><span class="line">  __text              <span class="comment">// 程序可执行的代码区域</span></span><br><span class="line">  __stubs             <span class="comment">// 间接符号存根。本质上是一小段代码，跳转到懒加载/延迟绑定(lazybinding)指针表(即__DATA.la_symbol_ptr)。找到对应项指针指向的地址。</span></span><br><span class="line">  __sub_helper        <span class="comment">// 辅助函数。帮助解决懒加载符号加载，上述提到的lazybinding的表(__DATA.la_symbol_ptr)中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span></span><br><span class="line">  __objc_methname     <span class="comment">// 方法名</span></span><br><span class="line">  __objc_classname    <span class="comment">// 类名</span></span><br><span class="line">  __objc_methtype     <span class="comment">// 方法签名</span></span><br><span class="line">  __cstring           <span class="comment">// 去重后的只读的C风格字符串，包含OC的部分字符串和属性名</span></span><br><span class="line">  __const             <span class="comment">// 初始化过的常量</span></span><br><span class="line">  __unwind_info       <span class="comment">// 用户存储处理异常情况信息</span></span><br><span class="line">  __eh_frame          <span class="comment">// 调试辅助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __DATA Segment(段)下面的节：</span></span><br><span class="line">  __data              <span class="comment">// 初始化过的可变的数据</span></span><br><span class="line">  __const             <span class="comment">// 没有初始化过的常量</span></span><br><span class="line">  __bss               <span class="comment">// 没有初始化的静态变量</span></span><br><span class="line">  __common            <span class="comment">// 没有初始化过的符号声明</span></span><br><span class="line">  __nl_symbol_ptr     <span class="comment">// 非延迟导入/非懒加载(lazy-binding)符号指针表，每个表项中的指针都指向一个在dyld加载过程中，搜索完成的符号。即在dyld加载时会立即绑定值。</span></span><br><span class="line">  __la_symbol_ptr     <span class="comment">// 延迟导入/懒加载(lazy-binding)符号指针表，每个表项中的指针一开始指向stub_helper。在第 1 次调用时才会绑定值。</span></span><br><span class="line">  __got               <span class="comment">// 非懒加载全局指针表</span></span><br><span class="line">  __mod_init_func     <span class="comment">// 初始化/constructor(构造)函数</span></span><br><span class="line">  __mod_term_func     <span class="comment">// destructor(析构)函数</span></span><br><span class="line">  __cfstring          <span class="comment">// OC字符串</span></span><br><span class="line">  __objc_classlist    <span class="comment">// 程序中的类列表</span></span><br><span class="line">  __objc_nlclslist    <span class="comment">// 程序中自己实现了+load方法的类</span></span><br><span class="line">  __objc_protolist    <span class="comment">// 协议的列表</span></span><br><span class="line">  __objc_classrefs    <span class="comment">// 被引用的类列表</span></span><br><span class="line">  __objc_ivar         <span class="comment">// 成员变量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-stubs-与-stub-helper"><a href="#3-4-stubs-与-stub-helper" class="headerlink" title="3.4 __stubs 与 __stub_helper"></a>3.4 <code>__stubs</code> 与 <code>__stub_helper</code></h3><blockquote><p>用来实现 LazyBind 的两个section：<code>__TEXT.__stubs</code>、<code>__TEXT.__stub_helper</code></p></blockquote><p>在 wikipedia 有一个关于 <a href="https://en.wikipedia.org/wiki/Method_stub">Method stub</a> 的词条，大意就是：Stub 是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。</p><p>总结来说：</p><ul><li>stub就是一段代码，功能为：跳转到 <code>__DATA.__la_symbol_ptr</code>( <code>__DATA</code> Segment 中的 <code>__la_symbol_ptr</code> Section) 对应表项的数据，所指向的地址。</li><li><code>__la_symbol_ptr</code> 里面的所有表项的数据在初始时都会被 binding 成 <code>__stub_helper</code>。</li><li>当懒加载符号第一次使用到的时候，按照上面的结构，会跳转到<code>__stub_helper</code>这个section的代码，然后代码中会调用<code>dyld_stub_binder</code>来执行真正的bind。 bind结束后，就将<code>__la_symbol_ptr</code>中该懒加载符号 原本对应的指向<code>__stub_helper</code>的地址 修改为 符号的真实地址。</li><li>之后的调用中，虽然依旧会跳到 <code>__stub</code> 区域，但是 <code>__la_symbol_ptr</code>表由于在之前的调用中获取到了符号的真实地址而已经修正完成，所以无需在进入 <code>dyld_stub_binder</code> 阶段，可以直接使用符号。</li></ul><p>这样就完成了LazyBind的过程。Stub 机制 其实和 <code>wikipedia</code> 上的说法一致，设置一个桩函数(模拟、占位函数)并采用 <strong>lazy</strong> 思想做成延迟 binding 的流程。</p><p>在《深入解析 Mac OS X &amp; iOS操作系统》中有详细的验证，也可以参考<a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a> 自己动手验证一下。</p><h3 id="3-5-Load-Command"><a href="#3-5-Load-Command" class="headerlink" title="3.5 Load Command"></a>3.5 Load Command</h3><p>Mach-O文件头中包含了非常详细的指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。这些指令，或称为“加载命令”，紧跟在基本的mach_header之后。</p><p>每一条命令，在<code>load.c</code>文件中，都有对应的结构体，来记录信息。共同点是都采用“<code>类型-长度-值</code>”的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmd;       <span class="comment">/* 32位的cmd值(表示类型) ，下面列举了部分 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmdsize;   <span class="comment">/* 32位的cmdsize值(32位二进制为4的倍数，64位二进制为8的倍数) */</span></span><br><span class="line">  ...                      <span class="comment">/* 记录命令本身的一些信息 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面列举一些load command的类型(对应的cmd值)，这里只列举了部分，全面的可以看源码，总共50多种load command。按照加载命令是由内核加载器、动态链接器处理分开记录。</span></span><br><span class="line"><span class="comment">// 内核加载器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SEGMENT                0x1  <span class="comment">/* 定义一个段(Segment)，加载后被映射到内存中，包括里面的节(Section) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLINKER          0xe  <span class="comment">/* 默认的加载器路径。通常路径是“/usr/lib/dyld” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_UUID                   0x1b   <span class="comment">/* 用于标识Mach-0文件的ID，匹配二进制文件与符号表。在分析崩溃堆栈信息能用到，通过地址在符号表中找到符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_CODE_SIGNATURE         0x1d  <span class="comment">/* 代码签名信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ENCRYPTION_INFO_64     0x2C   <span class="comment">/* 文件是否加密的标志，加密内容的偏移和大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SYMTAB                 0x2  <span class="comment">/* 为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的 external 符号被链接器使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYSYMTAB               0xb  <span class="comment">/* 将符号表中给出符号的额外符号信息提供给动态链接器。 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ID_DYLIB               0xd  <span class="comment">/* 依赖的动态库，包括动态库名称、当前版本号、兼容版本号。可以使用“otool-L xxx”命令查看 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_RPATH                 (0x1c | LC_REQ_DYLD)    <span class="comment">/* RunpathSearchPaths，@rpath搜索的路径 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_DYLD_INFO              0x22  <span class="comment">/* compressed dyld information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYLD_INFO_ONLY        (0x22 | LC_REQ_DYLD)  <span class="comment">/* 记录了有关链接的重要信息，包括在__LINKEDIT中动态链接相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的链接器无法识别它，程序就会出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_VERSION_MIN_IPHONEOS   0x25   <span class="comment">/* 系统要求的最低版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_FUNCTION_STARTS        0x26   <span class="comment">/* 函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_MAIN                  (0x28 | LC_REQ_DYLD)    <span class="comment">/* 程序的入口。dyld获取该地址，然后跳转到该处执行。replacement for LC_UNIXTHREAD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DATA_IN_CODE           0x29   <span class="comment">/* 定义在代码段内的非指令的表   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SOURCE_VERSION         0x2A   <span class="comment">/* 构建二进制文件的源代码版本号 */</span></span></span><br></pre></td></tr></table></figure><p>有一些命令是由<code>内核加载器</code>(定义在<code>bsd/kern/mach_loader.c</code>文件中) 直接使用的， 其他命令是由<code>动态链接器</code>处理的。</p><img src="/images/compilelink/14.png" alt="12" style="zoom:70%;" /><img src="/images/compilelink/15.png" alt="12" style="zoom:70%;" /><p>在Mach-O文件加载解析时，多个Load Command会告诉操作系统应当如何加载文件中每个Segment的数据，对系统内核加载器和动态链接器起引导作用。(不同的数据对应不同的加载命令，可以看到<code>segment_command_64</code>、<code>symtab_command</code>、<code>dylib_command</code>等，下面我们会讲解Segment的加载命令，下一节讲静态链接时，会涉及符号表symtab的加载命令)。</p><p>下面，以三个内核加载器负责解析处理的load command，来简单看下：</p><h4 id="3-5-1-LC-CODE-SIGNATURE-数字签名"><a href="#3-5-1-LC-CODE-SIGNATURE-数字签名" class="headerlink" title="3.5.1 LC_CODE_SIGNATURE(数字签名)"></a>3.5.1 LC_CODE_SIGNATURE(数字签名)</h4><p>Mach-O二进制文件有一个重要特性就是可以进行数字签名。尽管在 OS X 中仍然没怎么使用数字签名，不过由于代码签名和新改进的沙盒机制绑定在一起，所以签名的使用率也越来越高。在 iOS 中，代码签名是强制要求的，这也是苹果尽可能对系统封锁的另一种尝试：在 iOS 中只有苹果自己的签名才会被认可。在 OS X 中，code sign(1) 工具可以用于操纵和显示代码签名。man手册页，以及 Apple’s code signing guide 和 Mac OS X Code Signing In Depth文档都从系统管理员的角度详细解释了代码签名机制。</p><p><code>LC_CODE_SIGNATURE</code> 包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配(或者如果在iOS上这条命令不存在)，那么内核会立即给进程发送一个SIGKILL信号将进程杀掉，没有商量的余地，毫不留情。</p><p>在iOS 4之前，还可以通过两条sysctl(8)命令覆盖负责强制执行(利用内核的MAC，即Mandatory AccessControl)的内核变量，从而实现禁用代码签名检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w security.mac.proc_enforce &#x3D; 0 &#x2F;&#x2F;禁用进程的MAC</span><br><span class="line">sysctl -w security.mac.vnode_enforce&#x3D;0 &#x2F;&#x2F;禁用VNode的MAC</span><br></pre></td></tr></table></figure><p>而在之后版本的iOS中，苹果意识到只要能够获得root权限，越狱者就可以覆盖内核变量。因此这些变量变成了只读变量。untethered越狱(即完美越狱)因为利用了一个内核漏洞所以可以修改这些变量。由于这些变量的默认值都是启用签名检查，所以不完美越狱会导致非苹果签名的应用程序崩溃——除非i设备以完美越狱的方式引导。</p><p>此外，通过 Saurik 的 ldid 这类工具可以在 Mach-O 中嵌入伪代码签名。这个工具可以替代OS X的code sign(1)，允许生成自我签署认证的伪签名。这在iOS中尤为重要，因为签名和沙盒模型的应用程序“entitlement”绑定在一起， 而后者在iOS中是强制要求的。entitlement 是声明式的许可(以plist的形式保存)，必须内嵌在Mach-O中并且通过签名盖章，从而允许执行安全敏感的操作时具有运行时权限。</p><p>OS X 和 iOS 都有一个特殊的系统调用csops(#169)用于代码签名的操作</p><h4 id="3-5-2-LC-SEGMENT-进程虚拟内存设置"><a href="#3-5-2-LC-SEGMENT-进程虚拟内存设置" class="headerlink" title="3.5.2 LC_SEGMENT(进程虚拟内存设置)"></a>3.5.2 LC_SEGMENT(进程虚拟内存设置)</h4><p>LC_SEGMENT(或LC_SEGMENT_64) 命令是最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些“段”直接从Mach-O二进制文件加载到内存中。</p><p>每一条LC_SEGMENT[64] 命令都提供了段布局的所有必要细节信息。见上文的数据结构成员变量。</p><p>有了LC_SEGMENT命令，设置进程虚拟内存的过程就变成遵循LC_SEGMENT命令的简单操作。对于每一个段，将文件中相应的内容加载到内存中：<strong>从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节</strong>。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。段的保护设置可以动态改变，但是不能超过 maxprot 中指定的值(在iOS中，+x和+w是互斥的)。</p><h4 id="3-5-3-LC-MAIN-设置主线程入口地址"><a href="#3-5-3-LC-MAIN-设置主线程入口地址" class="headerlink" title="3.5.3 LC_MAIN(设置主线程入口地址)"></a>3.5.3 LC_MAIN(设置主线程入口地址)</h4><p>从Mountain Lion开始，一条新的加载命令<code>LC_MAIN</code>替代了<code>LC_UNIX_THREAD</code>命令。</p><ul><li>后者的作用是：开启一个unix线程，初始化栈和寄存器，通常情况下，除了指令指针(Intel的IP)或程序计数器(ARM的r15)之外，所有的寄存器值都为0。</li><li>前者作用是<strong>设置程序主线程的入口点地址和栈大小</strong>。</li></ul><p>这条命令比LC_UNIXTHREAD命令更实用一些， 因为无论如何除了程序计数器之外所有的寄存器都设置为0了。由于没有LC_UNIXTHREAD命令， 所以不可以在之前版本的 OS X 上运行使用了LC_MAIN的二进制文件(在加载时会导致dyld(1)崩溃)。</p><img src="/images/compilelink/16.png" alt="12" style="zoom:90%;" /><p>LC_Main对应的加载命令如下，记录了可执行文件的入口函数<code>int main(int argc, char * argv[])</code>的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmd;        <span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmdsize;    <span class="comment">/* 24 */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  entryoff;   <span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  stacksize;  <span class="comment">/* if not zero, initial stack size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义上可以看到入口函数的地址计算：<code>Entry Point = vm_addr(__TEXT) + entryOff + Slide</code></p><p>从<a href="https://opensource.apple.com/source/dyld/">dyld的源码</a>里能看到对Entry Point的获取和调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start()   <span class="comment">// dyldInitialization.cpp</span></span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dyldbootstrap &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line">    <span class="comment">// sets up some registers and call this function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uintptr_t</span></span><br><span class="line">    _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">            <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">            <span class="keyword">uintptr_t</span>* startGlue) &#123;</span><br><span class="line">        <span class="comment">// find entry point for main executable</span></span><br><span class="line">        result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下这几种load command所表示的信息。关于进程地址空间分布、线程入口在第四节 —— 装载会从进程启动到运行详细梳理一下流程。</p><h2 id="四、通用二进制格式（Universal-Binary）"><a href="#四、通用二进制格式（Universal-Binary）" class="headerlink" title="四、通用二进制格式（Universal Binary）"></a>四、通用二进制格式（Universal Binary）</h2><p>通常也被称为<code>胖二进制格式（Fat Binary）</code>，Apple 提出这个概念是为了解决一些历史原因，macOS（更确切的应该说是 OS X）最早是构建于 PPC 架构智商，后来才移植到 Intel 架构（从 Mac OS X Tiger 10.4.7 开始），通用二进制格式的二进制文件可以在 PPC 和 x86 两种处理器上执行。</p><p>说到底，通用二进制格式只不过是对多架构的二进制文件的打包集合文件，而 macOS 中的多架构二进制文件也就是适配不同架构的 Mach-O 文件。即一个通用二进制格式包含了很多个 Mach-O 格式文件。它有以下特点：</p><ul><li>因为需要存储多种架构的代码，所以通用二进制文件要比单架构二进制文件要大</li><li>因为两种种架构之间可以共用一些资源，所以两种架构的通用二进制文件大小不会达到单一架构版本的两倍。</li><li>运行过程中只会调用其中的部分代码，所以运行起来不会占用额外的内存</li></ul><p><strong>Fat Header</strong> 的数据结构在 <code>&lt;mach-o/fat.h&gt;</code> 头文件中有定义，可以参看 <code>/usr/include/mach-o/fat.h</code> 找到定义头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC    0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM    0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;           <span class="comment">/* FAT_MAGIC 或 FAT_MAGIC_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nfat_arch;       <span class="comment">/* 结构体实例的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>     cputype;      <span class="comment">/* cpu 说明符 (int) */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>  cpusubtype;   <span class="comment">/* 指定 cpu 确切型号的整数 (int) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       offset;       <span class="comment">/* CPU 架构数据相对于当前文件开头的偏移值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       size;         <span class="comment">/* 数据大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       align;        <span class="comment">/* 数据内润对其边界，取值为 2 的幂 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>cputype</code> 和 <code>cpusubtype</code> 两个字段这里不讲述，可以参看 <code>/usr/include/mach/machine.h</code> 头中对其的定义，另外 <a href="https://developer.apple.com/documentation/kernel/mach_header?language=objc">Apple 官方文档</a>中也有简单的描述。</p><p>在 <code>fat_header</code> 中，<code>magic</code> 也就是我们之前在表中罗列的 <em>magic</em> 标识符，也可以类比成 UNIX 中 ELF 文件的 <em>magic</em> 标识。加载器会通过这个符号来判断这是什么文件，通用二进制的 <em>magic</em> 为 <code>0xcafebabe</code>。<code>nfat_arch</code> 字段指明当前的通用二进制文件中包含了多少个不同架构的 Mach-O 文件。<code>fat_header</code> 后会跟着多个 <code>fat_arch</code>，并与多个 Mach-O 文件及其描述信息（文件大小、CPU 架构、CPU 型号、内存对齐方式）相关联。</p><p>这里可以通过 <code>file</code> 命令来查看简要的架构信息，这里以 iOS 平台 WeChat 4.5.1 版本为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ file Desktop/WeChat.app/WeChat</span><br><span class="line">Desktop/WeChat.app/WeChat: Mach-O universal binary with 2 architectures: [arm_v7: Mach-O executable arm_v7] [arm64]</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture armv7):    Mach-O executable arm_v7</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture arm64):    Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><p>进一步，也可以使用 <code>otool</code> 工具来打印其 <code>fat_header</code> 详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ otool -f -V Desktop/WeChat.app/WeChat</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic FAT_MAGIC</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture armv7</span><br><span class="line">    cputype CPU_TYPE_ARM</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM_V7</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 56450224</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture arm64</span><br><span class="line">    cputype CPU_TYPE_ARM64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 56475648</span><br><span class="line">    size 64571648</span><br><span class="line">    align 2^14 (16384)</span><br></pre></td></tr></table></figure><p>之后我们用 <em>Synalyze It!</em> 来查看 WeChat 的 Mach64 Header 的效果：</p><img src="/images/compilelink/17.jpg" alt="12" style="zoom:80%;" /><ul><li>  从第一个段中得到 <code>magic = 0xcafebabe</code> ，说明是 <code>FAT_MAGIC</code>。</li><li>  第二段中所存储的字段为 <code>nfat_arch = 0x00000002</code>，说明该 App 中包含了两种 CPU 架构。</li><li>  后续的则是 <code>fat_arch</code> 结构体中的内容，<code>cputype(0x0000000c)</code>、<code>cpusubtype(0x00000009)</code>、<code>offset(0x00004000)</code>、<code>size(0x03505C00)</code> 等等。如果只含有一种 CPU 架构，是没有 fat 头定义的，这部分则可跳过，从而直接过去 <code>arch</code> 数据。</li></ul><blockquote><p><strong>注意，在mach-o中，数据结构中的地址表示：如果是value、address等，那一般是绝对地址；如果是偏移量offset等，一般都是相对于目标文件/可执行文件（注意，尤其是后者，起始地址不会是0，寻址时要加上起始地址）。</strong></p></blockquote><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903959618912263#heading-10">iOS逆向学习之四（初识Mach-O）</a></li><li><a href="https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html">Mach-O 文件格式探索</a></li><li><a href="">《iOS应用逆向与安全》— 刘培庆</a></li><li><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho(1)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式&lt;code&gt;Mach-O的结构&lt;/code&gt;，方便了解之后的&lt;code&gt;链接&lt;/code&gt;生成可执行文件的过程。&lt;/p&gt;
&lt;p&gt;先附上相关源码地址：与Mach-O 文件格</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(一) Clang/LLVM 介绍、OC 程序的编译过程</title>
    <link href="https://tenloy.github.io/2021/09/22/compile-clang-llvm.html"/>
    <id>https://tenloy.github.io/2021/09/22/compile-clang-llvm.html</id>
    <published>2021-09-22T14:25:45.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编译、链接工具-—-Clang-LLVM"><a href="#一、编译、链接工具-—-Clang-LLVM" class="headerlink" title="一、编译、链接工具 — Clang/LLVM"></a>一、编译、链接工具 — Clang/LLVM</h2><blockquote><p><a href="https://llvm.org/">官网定义：</a></p><ul><li>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies(LLVM项目是一系列分模块、可重用的编译<strong>工具链</strong>). Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</li><li>Clang is an “LLVM native” C/C++/Objective-C compiler. </li></ul></blockquote><h3 id="1-1-LLVM的诞生"><a href="#1-1-LLVM的诞生" class="headerlink" title="1.1 LLVM的诞生"></a>1.1 LLVM的诞生</h3><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的克里斯·拉特纳(Chris Lattner，twitter为 <a href="https://twitter.com/clattner_llvm">clattner_llvm</a>） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。</p><p>2005年，由于GCC 对于 Objective-C 的支持比较差，效率和性能都没有办法达到苹果公司的要求，而且它还难以推动 GCC 团队。于是，苹果公司决定自己来掌握编译相关的工具链，于是将Chris Lattner招入麾下，发起了 Clang 软件项目。</p><ul><li>Clang 作为 LLVM 编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。Clang支持C、C++、Objective C。</li><li>测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</li><li>此后，苹果使用的 GCC 全面替换成了 LLVM。</li></ul><p>2010年，Chris Lattner开始主导开发 Swift 语言。这也使得 Swift 这门集各种高级语言特性的语言，能够在非常高的起点上，出现在开发者面前。</p><p>2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p><h3 id="1-2-LLVM及其子项目"><a href="#1-2-LLVM及其子项目" class="headerlink" title="1.2 LLVM及其子项目"></a>1.2 LLVM及其子项目</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>llvm特点：</p><ul><li>模块化</li><li>统一的中间代码IR，而前端、后端可以不一样。而GCC的前端、后端耦合在了一起，所以支持一门新语言或者新的平台，非常困难。</li><li>功能强大的Pass系统，根据依赖性自动对Pass（包括分析、转换和代码生成Pass）进行排序，管道化以提高效率。</li></ul><p>llvm有广义和狭义两种定义：</p><ul><li>在广义中，llvm特指一整个编译器框架，<strong>是一个模块化和可重用的编译器和工具链技术的集合</strong>，由前端、优化器、后端组成，clang只是用于c/c++的一种前端，llvm针对不同的语言可以设计不同的前端，同样的针对不同的平台架构（amd，arm，misp），也会有不同后端设计</li><li>在狭义中 ，特指llvm后端，指优化器（pass）对IR进行一系列优化直到目标代码生成的过程</li></ul><p>简单罗列LLVM几个主要的子项目，详见<a href="https://llvm.org/">官网</a>：</p><ul><li><p>LLVM Core libraries：LLVM核心库提供了一个独立于源和目标架构的现代<a href="https://llvm.org/docs/Passes.html">优化器optimizer</a>，以及对许多流行cpu(以及一些不太常见的cpu)的<a href="https://llvm.org/docs/CodeGenerator.html">代码生成(code generation)</a>支持。这些库是围绕一种被称为LLVM中间表示(“LLVM IR”)的良好指定的代码表示构建的。</p></li><li><p>Clang：一个 C/C++/Objective-C 编译器，提供高效快速的编译效率，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。(见下文详述)</p></li><li><p>lld： 是LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。<br>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p></li><li><p>LLDB：基于 LLVM 和 Clang提供的库构建的一个优秀的本地调试器，使用了 Clang ASTs、表达式解析器、LLVM JIT、LLVM 反汇编器等。</p></li></ul><h4 id="1-2-2-Clang"><a href="#1-2-2-Clang" class="headerlink" title="1.2.2 Clang"></a>1.2.2 Clang</h4><p>从<a href="http://llvm.org/svn/llvm-project/cfe/trunk/lib/">Clang的源码</a>目录中可以大致看出Clang提供的功能：</p><img src="/images/compilelink/01.png" alt="01" style="zoom:80%;" /><h5 id="1-Clang提供了哪些功能？"><a href="#1-Clang提供了哪些功能？" class="headerlink" title="1. Clang提供了哪些功能？"></a>1. Clang提供了哪些功能？</h5><p>Clang 为一些需要分析代码语法、语义信息的工具提供了基础设施。分别是：</p><ul><li><p><strong>LibClang</strong>。LibClang提供了一个稳定的高级 C 接口，Xcode 使用的就是 LibClang。LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有 Token、遍历语法树、代码补全等。由于 API 很稳定，Clang 版本更新对其 影响不大。但是，LibClang 并不能完全访问到 Clang AST 信息。</p></li><li><p><strong>Clang Plugins</strong>。可以在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。插件是在运 行时由编译器加载的动态库，方便集成到构建系统中。<br>使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。<br>应用：实现命名规范、代码规范等一些扩展功能</p></li><li><p><strong>LibTooling</strong>。是一个 C++ 接口，所写的工具不依赖于构建系统，可以作为一个命令单独使用。与 Clang Plugins 相比，LibTooling 无法影响编译过程；与 LibClang 相比，LibTooling 的接口没有那么稳定。<br>应用：做代码转换，比如把 OC 转 JavaScript 或 Swift；代码检查。</p></li></ul><h5 id="2-Clang的优点"><a href="#2-Clang的优点" class="headerlink" title="2. Clang的优点"></a>2. Clang的优点</h5><p>Clang 是 C、C++、Objective-C 的编译前端，而 Swift 有自己的编译前端 （也就是 Swift 前端多出的 SIL optimizer）。Clang 有哪些优势？</p><ul><li>对于使用者来说，Clang 编译的速度非常快，对内存的使用率非常低，并且兼容 GCC。</li><li>对于代码诊断来说， Clang 也非常强大，Xcode 也是用的 Clang。使用 Clang 编译前端，可以精确地显示出问题所在的行和具体位置，并且可以确切地说明出现这个问题的原因，并指出错误的类型是什么，使得我们可以快速掌握问题的细节。这样的话，我们不用看源码，仅通过 Clang 突出标注的问题范围也能够了解到问题的情况。</li><li>Clang 对 typedef 的保留和展开也处理得非常好。typedef 可以缩写很长的类型，保留 typedef 对于粗粒度诊断分析很有帮助。但有时候，我们还需要了解细节，对 typedef 进行展开即可。</li><li>Fix-it 提示也是 Clang 提供的一种快捷修复源码问题的方式。在宏的处理上，很多宏都是深度嵌套的， Clang 会自动打印实例化信息和嵌套范围信息来帮助你进行宏的诊断和分析。</li><li>Clang 的架构是模块化的。除了代码静态分析外，利用其输出的接口还可以开发用于代码转义、代码生成、代码重构的工具，方便与 IDE 进行集成。</li></ul><p>Clang 是基于 C++ 开发的，如果你想要了解 Clang 的话，需要有一定的 C++ 基础。但是，Clang 源码本身质量非常高，有很多值得学习的地方，比如说目录清晰、功能解耦做得很好、分类清晰方便组合和复用、代码风格统一而且规范、注释量大便于阅读等。</p><h3 id="1-3-Clang-LLVM架构"><a href="#1-3-Clang-LLVM架构" class="headerlink" title="1.3 Clang-LLVM架构"></a>1.3 Clang-LLVM架构</h3><p>Clang-LLVM架构，即用Clang作为前端的LLVM(编译工具集)。</p><p>Clang-LLVM下，一个源文件的编译过程：</p><img src="/images/compilelink/02.png" alt="01" style="zoom:65%;" /><p>iOS 开发完整的编译流程图：</p><img src="/images/compilelink/03.png" alt="01" style="zoom:80%;" /><p>LLVM架构的主要组成部分：</p><ul><li><p><strong>前端</strong>：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang(Clang-LLVM)。<br>LLVM支持三种表达形式：人类可读的汇编(<code>.ll</code>后缀，是LLVM IR文件，其有自己的语法)、在C++中对象形式、序列化后的bitcode形式(<code>.bc</code>后缀)。</p></li><li><p><strong>Pass</strong>(v.通过/传递/变化 n.经过/通行证/<strong>通道</strong>/<strong>流程</strong>/<strong>阶段</strong>) ：是 LLVM 优化(optimize)工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。我们可以自己编写Pass，做一些代码混淆优化等操作。</p></li><li><p><strong>后端</strong>：后端用来生成实际的机器码。至3.4版本的LLVM已经支持多种后端指令集，比如主流的x86、x86-64、z/Architecture、ARM和PowerPC等</p></li></ul><p>虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:</p><img src="/images/compilelink/04.png" alt="01" style="zoom:100%;" /><p>LLVM的架构如下：</p><img src="/images/compilelink/05.png" alt="01" style="zoom:75%;" /><p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端，其它部分完成可以复用，不用重新设计。在基于LLVM进行代码混淆时，只需要关注中间层代码(IR)表示。</p><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><ul><li>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</li><li>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</li><li>Gallium3D 中使用 LLVM 进行 JIT 优化</li><li>Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度</li><li>LLVM-Lua 用LLVM 来编译 lua 代码</li><li>gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</li></ul><p>下面，通过具体的代码、命令，来看一下iOS中源代码详细的编译、链接过程</p><h2 id="二、编译、静态链接过程"><a href="#二、编译、静态链接过程" class="headerlink" title="二、编译、静态链接过程"></a>二、编译、静态链接过程</h2><blockquote><p>从源码到可执行文件 — iOS应用编译、静态链接过程</p></blockquote><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p><p>我们先来一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINEEight 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eight = DEFINEEight;</span><br><span class="line">    <span class="keyword">int</span> six = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = eight + six;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</span><br><span class="line">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</span><br></pre></td></tr></table></figure><p>然后将该可执行文件copy到手机目录 /usr/bin 下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx-iPhone:/usr/bin root<span class="comment"># ./main</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>下面深入剖析其中的过程。</p><h3 id="Clang常用命令与参数"><a href="#Clang常用命令与参数" class="headerlink" title="Clang常用命令与参数"></a>Clang常用命令与参数</h3><p><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">参考链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看编译的步骤</span></span><br><span class="line">clang -ccc-print-phases main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewrite Objective-C source to C++，将OC源代码重写为C++(仅供参考，与真正的运行时代码还是有细微差别的)</span></span><br><span class="line"><span class="comment">// 如果想了解真正的代码，可以使用-emit-llvm参数查看.ll中间代码</span></span><br><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作内部命令</span></span><br><span class="line">clang -##<span class="meta"># main.m -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接生成可执行文件</span></span><br><span class="line">clang main.m <span class="comment">// 默认生成的文件名为a.out</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">    -cc1：Clang编译器前端具有几个额外的Clang特定功能，这些功能不通过GCC兼容性驱动程序接口公开。 -cc1参数表示将使用编译器前端，而不是驱动程序。 clang -cc1功能实现了核心编译器功能。</span></span><br><span class="line"><span class="comment">-E：只进行预编译处理(preprocessor)</span></span><br><span class="line"><span class="comment">-S：只进行预编译、编译工作</span></span><br><span class="line"><span class="comment">-c：只进行预处理、编译、汇编工作</span></span><br><span class="line"><span class="comment">-fmodules：允许modules的语言特性。</span></span><br><span class="line"><span class="comment">在使用#include、#import时，会看到预处理时已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation。</span></span><br><span class="line"><span class="comment">所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</span></span><br><span class="line"><span class="comment">后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入。现在Xcode中默认是打开的，即编译源码时会加上-fmodules参数。也是因为modules机制的出现，pch不再默认自动创建。</span></span><br><span class="line"><span class="comment">使用了该参数，在导入库的地方，只需要 @import Foundation; 就行</span></span><br><span class="line"><span class="comment">可以看到使用了@import之后，clang -fmodules xx 生成的文件中，不再有上万行的系统库的代码引入，精简了很多。</span></span><br><span class="line"><span class="comment">-fsyntax-only：防止编译器生成代码,只是语法级别的说明和修改</span></span><br><span class="line"><span class="comment">-Xclang &lt;arg&gt;：向clang编译器传递参数</span></span><br><span class="line"><span class="comment">-dump-tokens：运行预处理器,拆分内部代码段为各种token</span></span><br><span class="line"><span class="comment">-ast-dump：构建抽象语法树AST,然后对其进行拆解和调试</span></span><br><span class="line"><span class="comment">-fobjc-arc：为OC对象生成retain和release的调用</span></span><br><span class="line"><span class="comment">-emit-llvm：使用LLVM描述汇编和对象文件</span></span><br><span class="line"><span class="comment">-o &lt;file&gt;：输出到目标文件</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>查看更多的<code>clang</code>使用方法可以在终端输入<code>clang --hep</code>查看,也可以点击下面的链接:<a href="https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110">https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110</a></p><h3 id="2-1-预处理（Preprocess）"><a href="#2-1-预处理（Preprocess）" class="headerlink" title="2.1 预处理（Preprocess）"></a>2.1 预处理（Preprocess）</h3><p>预编译过程主要处理源代码文件中的以”#”开头的预编译指令，<strong>不检查语法错误</strong>。规则如下：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。 </li><li>处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件内容插入到(全部复制到)该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。#include 可以导入任何(合法/不合法)文件，都能展开。</li><li>删除所有的注释“//”和“/* */”，会变成空行。 </li><li>保留所有的 #pragma 编译器指令，因为编译器须要使用它们。</li><li>添加行号和文件名标识，比如# 2 “main.m” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。<br>  格式是“<code># 行号 文件名 标志</code>”，参数解释如下：<ul><li>行号与文件名：表示从它后一行开始的内容来源于哪一个文件的哪一行</li><li>标志：可以是1,2,3,4四个数字，每个数字的含义如下：<br>1：表示新文件的开始<br>2：表示从一个被包含的文件中返回<br>3：表示后面的内容来自系统头文件<br>4：表示后面的内容应当被当做一个隐式的extern ‘C’块</li></ul></li></ul><p>经过预编译后的<code> .i 文件</code>不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><p>可以通过执行以下命令，<code>-E</code>表示只进行预编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">clang -E -fmodules main.m <span class="comment"># 此时需要源码中改为@import</span></span><br></pre></td></tr></table></figure><p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"># 408 &quot;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4</span><br><span class="line"># 2 &quot;main.m&quot; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int eight &#x3D; 8;</span><br><span class="line">    int six &#x3D; 6;</span><br><span class="line">    int rank &#x3D; eight + six;</span><br><span class="line">    printf(&quot;%d\n&quot;,rank);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。</p><h3 id="2-2-词法分析-Lexical-Analysis"><a href="#2-2-词法分析-Lexical-Analysis" class="headerlink" title="2.2 词法分析 (Lexical Analysis)"></a>2.2 词法分析 (Lexical Analysis)</h3><p>预处理之后，就是编译。编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p><p>首先，Clang 会对代码进行词法分析，将代码切分成 Token。你可以在<a href="https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">这个链接</a><br>中，看到 Clang 定义的所有 Token 类型。我们可以把这些 Token 类型，分为下面这 4 类。 </p><ul><li>关键字：语法中的关键字，比如 if、else、while、for 等;</li><li>标识符：变量名;</li><li>字面量：值、数字、字符串; </li><li>特殊符号：加减乘除、左右括号等符号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure><p>每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int &#39;int&#39; [StartOfLine]Loc&#x3D;&lt;main.m:4:1&gt;</span><br><span class="line">identifier &#39;main&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:4:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:4:9&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:4:10&gt;</span><br><span class="line">l_brace &#39;&#123;&#39;Loc&#x3D;&lt;main.m:4:11&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:5:5&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:15&gt;</span><br><span class="line">numeric_constant &#39;8&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:17 &lt;Spelling&#x3D;main.m:2:21&gt;&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:5:28&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:6:5&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:13&gt;</span><br><span class="line">numeric_constant &#39;6&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:15&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:6:16&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:7:5&gt;</span><br><span class="line">identifier &#39;rank&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:14&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:16&gt;</span><br><span class="line">plus &#39;+&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:22&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:24&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:7:27&gt;</span><br><span class="line">identifier &#39;printf&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:8:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:8:11&gt;</span><br><span class="line">string_literal &#39;&quot;%d\n&quot;&#39;Loc&#x3D;&lt;main.m:8:12&gt;</span><br><span class="line">comma &#39;,&#39;Loc&#x3D;&lt;main.m:8:18&gt;</span><br><span class="line">identifier &#39;rank&#39;Loc&#x3D;&lt;main.m:8:19&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:8:23&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:8:24&gt;</span><br><span class="line">return &#39;return&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:9:5&gt;</span><br><span class="line">numeric_constant &#39;0&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:9:12&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:9:13&gt;</span><br><span class="line">r_brace &#39;&#125;&#39; [StartOfLine]Loc&#x3D;&lt;main.m:10:1&gt;</span><br><span class="line">eof &#39;&#39;Loc&#x3D;&lt;main.m:10:2&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-语法、语义分析"><a href="#2-3-语法、语义分析" class="headerlink" title="2.3 语法、语义分析"></a>2.3 语法、语义分析</h3><p>这个阶段有两个模块Parser(语法syntax分析器)、Sema(语义分析Semantic)配合完成：</p><ul><li>Parser：遍历每个Token做词句分析，根据当前语言的语法，验证语法是否正确，最后生成一个 节点（Nodes）并记录相关的信息。</li><li>Semantic：在Lex 跟 syntax Analysis之后, 已经确保 词 句已经是正确的形式，semantic 接着做return values, size boundaries, uninitialized variables 等检查，如果发现语义上有错误给出提示；如果没有错误就会将 Token 按照语法组合成语义，生成 Clang 语义节点(Nodes)，然后将这些节点按照层级关系构成抽象语法树(AST)。</li></ul><p>AST可以说是Clang的核心，大部分的优化, 判断都在AST处理（例如寻找Class, 替换代码…等)。此步骤会将 Clang Attr  转换成 AST 上的 AttributeList，能在clang插件上透过 <code>Decl::getAttr&lt;T&gt;</code> 获取</p><blockquote><p>Clang Attributes：是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程, 一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中, Ex: <code>NS_CLASS_AVAILABLE_IOS(9_0)</code></p></blockquote><p>结构跟其他Compiler的AST相同。与其他编译器不同的是 Clang的AST是由C++构成类似Class、Variable的层级表示，其他的则是以汇编语言编写。这代表着AST也能有对应的api，这让AST操作, 获取信息都比较容易，甚至还夹带着地址跟代码位置。</p><blockquote><p>AST Context: 存储所有AST相关资讯, 且提供ASTMatcher等遍历方法</p></blockquote><p>在 Clang的定义中，节点主要分成：Type(类型)，Decl(声明)，Stmt(陈述)，其他的都是这三种的派生。Type具体到某个语言的类型时便可以派生出 PointerType(指针类型)、ObjCObjectType(objc对象类型)、BuiltinType(内置基础数据类型)这些表示。通过这三者的联结、重复或选择（alternative)就能构成一门编程语言。举个例子，下图的一段代码：详细可以看<a href="https://www.stephenw.cc/2018/01/08/clang-ast/">了解 Clang AST</a></p><img src="/images/compilelink/06.png" alt="01" style="zoom:70%;" /><p>FunctionDecl、ParmVarDecl 都是基于 Decl派生的类，CompoundStmt、ReturnStmt、DeclStmt都是基于 Stmt派生的类。）</p><p>从上图中可以看到：</p><ul><li>一个FunctionDecl（函数的实现）由一个 ParmVarDecl联结 CompoundStmt组成。</li><li>函数的 CompoundStmt 由 DeclStmt和 ReturnStmt联结组成。</li><li>还可以发现这段代码的ParmVarDecl由 BuiltinType 和一个标识符字面量联结组成。</li></ul><p>很明显一门编程语言中还有很多其他形态，我们都可以用这种方式描述出来。所以说从抽象的角度看，拥有无限种形态的编程语言便可以用有限的形式来表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&#96;-FunctionDecl 0x7fcbb9947b20 &lt;main.m:4:1, line:10:1&gt; line:4:5 main &#39;int ()&#39;</span><br><span class="line">  &#96;-CompoundStmt 0x7fcbb9947fc8 &lt;col:11, line:10:1&gt;</span><br><span class="line">    |-DeclStmt 0x7fcbb9947c50 &lt;line:5:5, col:28&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947bd0 &lt;col:5, line:2:21&gt; line:5:9 used eight &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947c30 &lt;line:2:21&gt; &#39;int&#39; 8</span><br><span class="line">    |-DeclStmt 0x7fcbb9947d00 &lt;line:6:5, col:16&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947c80 &lt;col:5, col:15&gt; col:9 used six &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947ce0 &lt;col:15&gt; &#39;int&#39; 6</span><br><span class="line">    |-DeclStmt 0x7fcbb9947e20 &lt;line:7:5, col:27&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947d30 &lt;col:5, col:24&gt; col:9 used rank &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-BinaryOperator 0x7fcbb9947e00 &lt;col:16, col:24&gt; &#39;int&#39; &#39;+&#39;</span><br><span class="line">    |     |-ImplicitCastExpr 0x7fcbb9947dd0 &lt;col:16&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |     | &#96;-DeclRefExpr 0x7fcbb9947d90 &lt;col:16&gt; &#39;int&#39; lvalue Var 0x7fcbb9947bd0 &#39;eight&#39; &#39;int&#39;</span><br><span class="line">    |     &#96;-ImplicitCastExpr 0x7fcbb9947de8 &lt;col:24&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |       &#96;-DeclRefExpr 0x7fcbb9947db0 &lt;col:24&gt; &#39;int&#39; lvalue Var 0x7fcbb9947c80 &#39;six&#39; &#39;int&#39;</span><br><span class="line">    |-CallExpr 0x7fcbb9947f20 &lt;line:8:5, col:23&gt; &#39;int&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f08 &lt;col:5&gt; &#39;int (*)(const char *, ...)&#39; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | &#96;-DeclRefExpr 0x7fcbb9947e38 &lt;col:5&gt; &#39;int (const char *, ...)&#39; Function 0x7fcbb9932e70 &#39;printf&#39; &#39;int (const char *, ...)&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f68 &lt;col:12&gt; &#39;const char *&#39; &lt;NoOp&gt;</span><br><span class="line">    | | &#96;-ImplicitCastExpr 0x7fcbb9947f50 &lt;col:12&gt; &#39;char *&#39; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">    | |   &#96;-StringLiteral 0x7fcbb9947e98 &lt;col:12&gt; &#39;char [4]&#39; lvalue &quot;%d\n&quot;</span><br><span class="line">    | &#96;-ImplicitCastExpr 0x7fcbb9947f80 &lt;col:19&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |   &#96;-DeclRefExpr 0x7fcbb9947eb8 &lt;col:19&gt; &#39;int&#39; lvalue Var 0x7fcbb9947d30 &#39;rank&#39; &#39;int&#39;</span><br><span class="line">    &#96;-ReturnStmt 0x7fcbb9947fb8 &lt;line:9:5, col:12&gt;</span><br><span class="line">      &#96;-IntegerLiteral 0x7fcbb9947f98 &lt;col:12&gt; &#39;int&#39; 0</span><br></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><p>语法树直观图:</p><img src="/images/compilelink/07.png" alt="01" style="zoom:90%;" /><h4 id="2-3-1-静态分析-Static-Analyzer"><a href="#2-3-1-静态分析-Static-Analyzer" class="headerlink" title="2.3.1 静态分析 (Static Analyzer)"></a>2.3.1 静态分析 (Static Analyzer)</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg      Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when casting a malloc&#39;ed type T, whether the size is a multiple of the size of T</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><a href="http://clang-analyzer.llvm.org/scan-build.html">scan-build</a> 是用于静态分析代码的工具，它包含在 clang 的源码包中。使用scan-build可以从命令行运行分析器，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">roten@localhost scan-build % .&#x2F;scan-build --use-analyzer&#x3D;xcode xcodebuild -project Demo123.xcodeproj    &#x2F;&#x2F; 需要设置 --use-analyzer指定 clang 的路径</span><br><span class="line"></span><br><span class="line">scan-build: Using &#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang&#39; for static analysis</span><br><span class="line">Build settings from command line:</span><br><span class="line">    CLANG_ANALYZER_EXEC &#x3D; &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS &#x3D; </span><br><span class="line">    CLANG_ANALYZER_OUTPUT &#x3D; plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR &#x3D; &#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER &#x3D; YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">** BUILD SUCCEEDED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory &#39;&#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1&#39; because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure><p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org/">Clang 静态分析器</a></p><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。</p><h3 id="2-4-IR代码生成-CodeGen"><a href="#2-4-IR代码生成-CodeGen" class="headerlink" title="2.4 IR代码生成 (CodeGen)"></a>2.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.m&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.m&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 &#x3D; alloca i32, align 4</span><br><span class="line">  %2 &#x3D; alloca i32, align 4</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  store i32 8, i32* %2, align 4</span><br><span class="line">  store i32 6, i32* %3, align 4</span><br><span class="line">  %5 &#x3D; load i32, i32* %2, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6</span><br><span class="line">  store i32 %7, i32* %4, align 4</span><br><span class="line">  %8 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %9 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %8)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1, !2, !3, !4, !5, !6, !7&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!8&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 2, !&quot;SDK Version&quot;, [2 x i32] [i32 10, i32 15]&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!3 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA,__objc_imageinfo,regular,no_dead_strip&quot;&#125;</span><br><span class="line">!4 &#x3D; !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!5 &#x3D; !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!6 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!7 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!8 &#x3D; !&#123;!&quot;Apple clang version 11.0.0 (clang-1100.0.33.12)&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-1-中间代码优化-Optimize"><a href="#2-4-1-中间代码优化-Optimize" class="headerlink" title="2.4.1 中间代码优化 (Optimize)"></a>2.4.1 中间代码优化 (Optimize)</h4><p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>对应着不同的入参，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p><img src="/images/compilelink/08.png" alt="01" style="zoom:95%;" /><img src="/images/compilelink/09.png" alt="01" style="zoom:85%;" /><p>我们还可以去写一些自己的Pass，官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 5 documentation</a>。</p><h3 id="2-5-生成字节码-LLVM-Bitcode"><a href="#2-5-生成字节码-LLVM-Bitcode" class="headerlink" title="2.5 生成字节码 (LLVM Bitcode)"></a>2.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在，开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p><blockquote><p>Bitcode是编译后的程序的中间表现，包含Bitcode并上传到App Store Connect的Apps会在App Store上编译和链接。包含Bitcode可以在不提交新版本App的情况下，允许Apple在将来的时候再次优化你的App 二进制文件。<br>对于iOS Apps，Enable bitcode 默认为YES，是可选的（可以改为NO）。对于WatchOS和tvOS，bitcode是强制的。如果你的App支持bitcode，App Bundle（项目中所有的target）中的所有的Apps和frameworks都需要包含Bitcode。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure><img src="/images/compilelink/10.png" alt="01" style="zoom:90%;" /><h3 id="2-6-生成相关汇编"><a href="#2-6-生成相关汇编" class="headerlink" title="2.6 生成相关汇编"></a>2.6 生成相关汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">10</span>, <span class="number">15</span>sdk_version <span class="number">10</span>, <span class="number">15</span></span><br><span class="line">.globl_main                   ## -- Begin <span class="meta">function</span> main</span><br><span class="line">.p2align<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## <span class="comment">@main</span></span><br><span class="line">.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq<span class="number">$32</span>, %rsp</span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">movl<span class="number">$8</span>, -<span class="number">8</span>(%rbp)</span><br><span class="line">movl<span class="number">$6</span>, -<span class="number">12</span>(%rbp)</span><br><span class="line">movl-<span class="number">8</span>(%rbp), %eax</span><br><span class="line">addl-<span class="number">12</span>(%rbp), %eax</span><br><span class="line">movl%eax, -<span class="number">16</span>(%rbp)</span><br><span class="line">movl-<span class="number">16</span>(%rbp), %esi</span><br><span class="line">leaqL_.str(%rip), %rdi</span><br><span class="line">movb<span class="number">$0</span>, %al</span><br><span class="line">callq_printf</span><br><span class="line">xorl%esi, %esi</span><br><span class="line">movl%eax, -<span class="number">20</span>(%rbp)         ## <span class="number">4</span>-byte Spill</span><br><span class="line">movl%esi, %eax</span><br><span class="line">addq<span class="number">$32</span>, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line"><span class="meta">.section</span>__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## <span class="comment">@.str</span></span><br><span class="line"><span class="meta">.asciz</span><span class="string">&quot;%d\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.section</span>__<span class="meta">DATA</span>,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line"><span class="symbol">L_OBJC_IMAGE_INFO:</span></span><br><span class="line"><span class="meta">.long</span><span class="number">0</span></span><br><span class="line"><span class="meta">.long</span><span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure><h3 id="2-7-生成目标文件"><a href="#2-7-生成目标文件" class="headerlink" title="2.7 生成目标文件"></a>2.7 生成目标文件</h3><p>编译阶段完成，接下来就是汇编阶段。汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。</p><p>这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure><img src="/images/compilelink/11.png" alt="01" style="zoom:90%;" /><h3 id="2-8-生成可执行文件"><a href="#2-8-生成可执行文件" class="headerlink" title="2.8 生成可执行文件"></a>2.8 生成可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main  <span class="comment"># 生成可执行文件</span></span><br><span class="line">./main  <span class="comment"># 执行 可执行文件 代码</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果：14</span><br></pre></td></tr></table></figure><h3 id="2-9-记录一个Clang命令报错"><a href="#2-9-记录一个Clang命令报错" class="headerlink" title="2.9 记录一个Clang命令报错"></a>2.9 记录一个Clang命令报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:59:11: error: #include nested too deeply  </span><br><span class="line"># include &lt;stdint.h&gt;  </span><br><span class="line">          ^  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:82:11: error: #include nested too deeply</span><br><span class="line"># include &lt;inttypes.h&gt;</span><br><span class="line">          ^</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>可能是xcode-select 没装，于是执行xcode-select –install 进行工具安装。</p></li><li><p>如果问题还在。brew doctor一下就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/includes</span><br><span class="line">brew doctor 2&gt;&amp;1 | grep <span class="string">&quot;/usr/local/include&quot;</span> | awk <span class="string">&#x27;&#123;$1=$1;print&#125;&#x27;</span> | xargs -I _ mv _ /tmp/includes </span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://github.com/SOHU-Co/kafka-node/issues/881">https://github.com/SOHU-Co/kafka-node/issues/881</a></p></li></ol><h2 id="三、小结：iOS从编码到打包"><a href="#三、小结：iOS从编码到打包" class="headerlink" title="三、小结：iOS从编码到打包"></a>三、小结：iOS从编码到打包</h2><ul><li>首先我们编写完成代码之后，会通过LLVM编译器预处理我们的代码，比如将宏放在指定的位置</li><li>预处理结束之后，LLVM会对代码进行词法分析和语法分析，生成AST。AST是抽象语法树，主要用来进行快速遍历，实现静态代码检查的功能。</li><li>AST会生成IR，IR是一种更加接近机器码的语言，通过IR可以生成不同平台的机器码。对于iOS平台，IR生成的可执行文件就是Mach-O.</li><li>然后通过链接器将符号和地址绑定在一起，并且将项目中的多个Mach-O文件(目标文件)合并成一个Mach-O文件(可执行文件)。(<strong>关于Mach-O、链接下一节讲</strong>)</li><li>将可执行文件与资源文件、storyboard、xib等打包，最后通过签名等操作生成.app文件，然后对.app文件进行压缩就生成了我们可以安装的ipa包。</li><li>当然，ipa包的安装途径有两种：<ul><li>通过开发者账号上传到App Store，然后在App Store上下载安装。</li><li>通过PP助手、iFunBox、Xcode等工具来安装</li></ul></li></ul><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="http://blog.alonemonkey.com/2016/12/21/learning-llvm/">关于LLVM，这些东西你必须知道!</a> 本篇文章大部分来自此文章。按照自己的理解记忆方式删减、添加了一些知识。原文中还补充有：<ul><li>Clang的三大基础设施(libclang、LibTooling、ClangPlugin)的应用、代码示例</li><li>动手写Pass的代码示例</li></ul></li><li><a href="https://xiaozhuanlan.com/topic/4916328705">深入剖析 iOS 编译 Clang / LLVM — 戴铭</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://juejin.im/post/6844903716709990414#heading-6">(Xcode) 編譯器小白筆記 - LLVM前端Clang</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编译、链接工具-—-Clang-LLVM&quot;&gt;&lt;a href=&quot;#一、编译、链接工具-—-Clang-LLVM&quot; class=&quot;headerlink&quot; title=&quot;一、编译、链接工具 — Clang/LLVM&quot;&gt;&lt;/a&gt;一、编译、链接工具 — Clang/LL</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>常见架构模式: MVC、MVP、MVVM、VIPER</title>
    <link href="https://tenloy.github.io/2021/09/18/architectural-pattern.html"/>
    <id>https://tenloy.github.io/2021/09/18/architectural-pattern.html</id>
    <published>2021-09-18T17:22:58.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译自：<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">iOS Architecture Patterns</a>(模式图也已汉化)。在<a href="http://slides.com/borlov/arch/fullscreen#/">这里</a>可以看到一个幻灯片</p></blockquote><p>在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？</p><p>相信你会找到以上问题的答案，如果没找到请在评论中指出。</p><p>你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。</p><p>掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题：</p><ul><li>谁应该来负责网络请求？Model 还是 Controller ？</li><li>应该怎样向一个新的页面的 ViewModel 传入一个 Model ?</li><li>谁来创建一个 VIPER 模块，是 Router 还是 Presenter ?</li></ul><img src="/images/pattern/01.jpg" alt="01" style="zoom:90%;" /><h2 id="一、为什么要关注架构设计？"><a href="#一、为什么要关注架构设计？" class="headerlink" title="一、为什么要关注架构设计？"></a>一、为什么要关注架构设计？</h2><p>因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样：</p><ul><li>这个类是一个UIViewController的子类</li><li>数据直接在UIViewController中存储</li><li>UIView类几乎不做任何事情</li><li>Model 仅仅是一个数据结构</li><li>单元测试覆盖不了任何用例</li></ul><p>即使是你遵循了Apple的指导原则并且实现了其 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式，以上这些情况仍旧会出现。不必惊慌，Apple所提出的 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式存在一些问题，我们之后会详述。</p><p>在此，我们可以定义一个好的架构应该具备的特点：</p><ol><li>任务均衡分摊给具有清晰角色的实体</li><li>可测试性通常都来自与上一条（对于一个合适的架构是非常容易）</li><li>易用性和低成本维护</li></ol><h3 id="1-1-为什么采用分布式"><a href="#1-1-为什么采用分布式" class="headerlink" title="1.1 为什么采用分布式?"></a>1.1 为什么采用分布式?</h3><p>采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一功能原则</a> 的前提下，将功能划分给不同的实体。</p><h3 id="1-2-为什么需要易测性？"><a href="#1-2-为什么需要易测性？" class="headerlink" title="1.2 为什么需要易测性？"></a>1.2 为什么需要易测性？</h3><p>其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少<a href="http://appreviewtimes.com/">一周</a>的时间才能再次分发给用户。</p><h3 id="1-3-为什么需要易用性？"><a href="#1-3-为什么需要易用性？" class="headerlink" title="1.3 为什么需要易用性？"></a>1.3 为什么需要易用性？</h3><p>这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。</p><h2 id="二、MV-X-系列概要"><a href="#二、MV-X-系列概要" class="headerlink" title="二、MV(X)系列概要"></a>二、MV(X)系列概要</h2><p>当今我们已经有很架构设计模式方面的选择:</p><ul><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></li><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a></li><li><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a></li><li><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a></li></ul><p>前三种设计模式都把一个应用中的实体分为以下三类：</p><ul><li><strong>Models</strong> — 负责主要的数据或者操作数据的<a href="https://en.wikipedia.org/wiki/Data_access_layer">数据访问层</a>，可以想象 Perspn 和 PersonDataProvider 类。</li><li><strong>Views</strong> — 负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。</li><li><strong>Controller/Presenter/ViewModel</strong> — 负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，并根据 Model 的更改更新 View。</li></ul><p>将实体进行划分给我们带来了以下好处：</p><ul><li>更好的理解它们之间的关系</li><li>复用（尤其是对于View和Model）</li><li>独立的测试</li></ul><p>让我们开始了解MV(X)系列，之后再返回到VIPER模式。</p><h2 id="三、MVC的过去"><a href="#三、MVC的过去" class="headerlink" title="三、MVC的过去"></a>三、MVC的过去</h2><p>在我们探讨Apple的MVC模式之前，我们来看下<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">传统的MVC模式</a>。</p><img src="/images/pattern/02.png" alt="01" style="zoom:80%;" /><p>在这种情况下，View是无状态的。一旦Model被改变，Controller就会简单地渲染View。就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。</p><p>虽然可以在 iOS 应用程序中实现传统的 MVC，但由于架构问题，它没有多大意义 —— 三个实体是紧密耦合的，实体间相互都有通信。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。</p><blockquote><p>传统的MVC架构不适用于当下的iOS开发</p></blockquote><h2 id="四、苹果的MVC"><a href="#四、苹果的MVC" class="headerlink" title="四、苹果的MVC"></a>四、苹果的MVC</h2><h3 id="4-1-愿景"><a href="#4-1-愿景" class="headerlink" title="4.1 愿景"></a>4.1 愿景</h3><p>Cocoa MVC：</p><img src="/images/pattern/03.png" alt="" style="zoom:80%;" /><p>由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。</p><p>理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，<a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">为View controller减负</a>也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？</p><h3 id="4-2-现实"><a href="#4-2-现实" class="headerlink" title="4.2 现实"></a>4.2 现实</h3><p>Realistic Cocoa MVC：</p><img src="/images/pattern/04.png" alt="" style="zoom:80%;" /><p>Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们与View的生命周期息息相关，因此很难说View和ViewController是分离的。</p><p>尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，很多时候，View的最大的任务就是向Controller传递用户动作事件。</p><p>ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。</p><p>你可能会看见过很多次这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var userCell = tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;identifier&quot;</span>) as UserCell</span><br><span class="line">userCell.configureWithUser(user)</span><br></pre></td></tr></table></figure><p>这个cell，就是个直接使用 Model 来配置的 View，此时其实已经违背了MVC的原则，但是这种情况是一直发生的，甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，而不是向这个View传递一个Model对象，但这样就会大大增加Controller的体积。</p><blockquote><p>Cocoa 的MVC被写成Massive View Controller 是不无道理的。</p></blockquote><p>直到进行<a href="http://nshipster.com/unit-testing/">单元测试</a>的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难，你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。</p><p>我们看下一些简单的例子:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123; <span class="comment">// View + Controller</span></span><br><span class="line">    var person: Person!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVC</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.person = model;</span><br></pre></td></tr></table></figure><blockquote><p>MVC可以在一个正在显示的ViewController中实现</p></blockquote><p>这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView相关的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。</p><p>事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作（例如iPad），因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。</p><blockquote><p>View和Controller之间的交互 <a href="http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/">并不适合使用单元测试</a> 来测试。</p></blockquote><p>以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征:</p><ul><li><strong>任务均摊</strong> —— View和Model确实是分开的，但是View和Controller却是紧密耦合的</li><li><strong>可测试性</strong> —— 由于糟糕的分散性，只能对Model进行测试</li><li><strong>易用性</strong> —— 与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。</li></ul><p>如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。</p><blockquote><p>就开发速度而言，Cocoa MVC是最好的架构选择方案。</p></blockquote><h2 id="五、MVP-Passive-View"><a href="#五、MVP-Passive-View" class="headerlink" title="五、MVP(Passive View)"></a>五、MVP(Passive View)</h2><h3 id="5-1-MVP-实现了Cocoa的MVC的愿景"><a href="#5-1-MVP-实现了Cocoa的MVC的愿景" class="headerlink" title="5.1 MVP 实现了Cocoa的MVC的愿景"></a>5.1 MVP 实现了Cocoa的MVC的愿景</h3><p>Passive View variant of MVP：</p><img src="/images/pattern/05.png" alt="" style="zoom:75%;" /><p>这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>（Passive View variant，被动视图变体），但是，这就是说苹果的MVC实际上就是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。</p><blockquote><p>假如告诉你UIViewController就是View呢？</p></blockquote><p>就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewPresenter &#123;</span><br><span class="line">    init(view: GreetingView, person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingViewPresenter &#123;</span><br><span class="line">    unowned let view: GreetingView</span><br><span class="line">    let person: Person</span><br><span class="line">    required init(view: GreetingView, person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var presenter: GreetingViewPresenter!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter.showGreeting()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVP</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter(view: view, person: model)</span><br><span class="line">view.presenter = presenter</span><br></pre></td></tr></table></figure><h3 id="5-2-关于整合问题的重要说明"><a href="#5-2-关于整合问题的重要说明" class="headerlink" title="5.2 关于整合问题的重要说明"></a>5.2 关于整合问题的重要说明</h3><p>MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View和Model耦合，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下几种方案中。</p><p>我们来看下MVP模式下的三个特性的分析：</p><ul><li>任务均摊 —— 我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。</li><li>可测试性 —— 非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单</li><li>易用性 —— 在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰</li></ul><blockquote><p>iOS 中的MVP意味着可测试性强、代码量大。</p></blockquote><h3 id="5-3-变体-—-MVP-Supervising-Controller"><a href="#5-3-变体-—-MVP-Supervising-Controller" class="headerlink" title="5.3 变体 — MVP(Supervising Controller)"></a>5.3 变体 — MVP(Supervising Controller)</h3><p>还有一些其他形态的MVP —— Supervising Controller MVP（监听Controller的MVP）。</p><blockquote><p>核心是：Bindings(绑定)和Hooters(此处译作信号)</p></blockquote><p>这个变体包含了View和Model之间的直接绑定，但是Presenter(Supervising Controller)仍然来管理来自View的动作事件，同时也能胜任对View的更新。</p><p>Supervising Controller variant of the MVP：</p><img src="/images/pattern/07.png" alt="" style="zoom:75%;" /><p>但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。</p><p>和传统的MVC一样，写这样的例子没有什么价值，故不再给出。</p><h2 id="六、MVVM"><a href="#六、MVVM" class="headerlink" title="六、MVVM"></a>六、MVVM</h2><blockquote><p>最新且是最伟大的MV(X)系列的一员</p></blockquote><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。</p><p>从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。</p><img src="/images/pattern/08.png" alt="" style="zoom:75%;" /><p>它和MVP模式看起来非常像:</p><ul><li>MVVM将ViewController视作View</li><li>在View和Model之间没有紧密的联系</li></ul><p>此外，它还有像监管(Supervising)版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间，而是在View和ViewModel之间。</p><p>那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身，并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。</p><h3 id="6-2-绑定"><a href="#6-2-绑定" class="headerlink" title="6.2 绑定"></a>6.2 绑定</h3><p>我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。</p><p>如果我们自己不想自己实现，那么我们有两种选择:</p><ul><li>基于KVO的绑定库如 <a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a> 和 <a href="https://github.com/SwiftBond/Bond">SwiftBond</a></li><li>完全的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6">函数响应式编程</a>，比如像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>、<a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>或者 <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li></ul><p>事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。</p><p>但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下 Reactive Debugging 函数调用栈：</p><img src="/images/pattern/09.jpg" alt="" style="zoom:90%;" /><p>在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewModelProtocol: <span class="keyword">class</span> &#123;</span><br><span class="line">    var greeting: String? &#123; get &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; <span class="comment">// function to call when greeting did change</span></span><br><span class="line">    init(person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewModel : GreetingViewModelProtocol &#123;</span><br><span class="line">    let person: Person</span><br><span class="line">    var greeting: String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.greetingDidChange?(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</span><br><span class="line">    required init(person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    var viewModel: GreetingViewModelProtocol! &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.viewModel.greetingDidChange = &#123; [unowned <span class="keyword">self</span>] viewModel <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.greetingLabel.text = viewModel.greeting</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>.viewModel, action: <span class="string">&quot;showGreeting&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVVM</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let viewModel = GreetingViewModel(person: model)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.viewModel = viewModel</span><br></pre></td></tr></table></figure><p>让我们再来看看关于三个特性的评估：</p><ul><li>任务均摊 —— 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</li><li>可测试性 —— ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</li><li>易用性 —— 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。</li></ul><blockquote><p>MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。</p></blockquote><h2 id="七、VIPER"><a href="#七、VIPER" class="headerlink" title="七、VIPER"></a>七、VIPER</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><blockquote><p>VIPER —— 把LEGO建筑经验迁移到iOS app的设计</p></blockquote><p><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a>是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。</p><p>迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次:</p><img src="/images/pattern/10.png" alt="" style="zoom:70%;" /><p>VIPER</p><ul><li><strong>交互器</strong> —— 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。</li><li><strong>展示器</strong> —— 包含UI层面的业务逻辑以及在交互器层面的方法调用。</li><li><strong>实体</strong> —— 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。</li><li><strong>路由器</strong> —— 用来连接VIPER的各个模块。</li></ul><p>基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程 —— 例如认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。</p><p>当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同:</p><ul><li><strong>Model</strong>（数据交互）逻辑以实体（Entities）为单位（作为最小的数据结构）拆分到交互器（Interactor）中。</li><li><strong>Controller/Presenter/ViewModel</strong>的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。</li><li><strong>VIPER</strong>是第一个通过路由器（Router）实现明确的地址导航模式。</li></ul><blockquote><p>找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。</p></blockquote><p>例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Entity (usually more complex e.g. NSManagedObject)</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> GreetingData &#123; <span class="comment">// Transport data structure (not Entity)</span></span><br><span class="line">    let greeting: String</span><br><span class="line">    let subject: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingProvider &#123;</span><br><span class="line">    func provideGreetingData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingOutput: <span class="keyword">class</span> &#123;</span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingInteractor : GreetingProvider &#123;</span><br><span class="line">    <span class="keyword">weak</span> var output: GreetingOutput!</span><br><span class="line">    </span><br><span class="line">    func provideGreetingData() &#123;</span><br><span class="line">        let person = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>) <span class="comment">// usually comes from data access layer</span></span><br><span class="line">        let subject = person.firstName + <span class="string">&quot; &quot;</span> + person.lastName</span><br><span class="line">        let greeting = GreetingData(greeting: <span class="string">&quot;Hello&quot;</span>, subject: subject)</span><br><span class="line">        <span class="keyword">self</span>.output.receiveGreetingData(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewEventHandler &#123;</span><br><span class="line">    func didTapShowGreetingButton()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</span><br><span class="line">    <span class="keyword">weak</span> var view: GreetingView!</span><br><span class="line">    var greetingProvider: GreetingProvider!</span><br><span class="line">    </span><br><span class="line">    func didTapShowGreetingButton() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingProvider.provideGreetingData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</span><br><span class="line">        let greeting = greetingData.greeting + <span class="string">&quot; &quot;</span> + greetingData.subject</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var eventHandler: GreetingViewEventHandler!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eventHandler.didTapShowGreetingButton()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of VIPER module, without Router</span></span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter()</span><br><span class="line">let interactor = GreetingInteractor()</span><br><span class="line">view.eventHandler = presenter</span><br><span class="line">presenter.view = view</span><br><span class="line">presenter.greetingProvider = interactor</span><br><span class="line">interactor.output = presenter</span><br></pre></td></tr></table></figure><p>让我们再来评估一下特性:</p><ul><li>任务均摊 —— 毫无疑问，VIPER是任务划分中的佼佼者。</li><li>可测试性 —— 不出意外地，更好的分布性就有更好的可测试性。</li><li>易用性 —— 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。</li></ul><h3 id="7-2-什么是LEGO"><a href="#7-2-什么是LEGO" class="headerlink" title="7.2 什么是LEGO"></a>7.2 什么是LEGO</h3><p>当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些<a href="https://inessential.com/2014/03/16/smaller_please">问题</a>，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 <a href="https://github.com/rambler-ios/Generamba">Generamba</a> 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。</p><p>因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;译自：&lt;a href=&quot;https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52&quot;&gt;iOS Architecture Patterns&lt;/a&gt;(模式</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(三) - 图形处理实践案例</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing-case.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing-case.html</id>
    <published>2021-09-15T15:54:07.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。<a href="https://juejin.cn/post/6846687599591948301">原文链接 — iOS图片处理实践</a>、<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">项目代码</a>。</p><h2 id="一、图片手动解码"><a href="#一、图片手动解码" class="headerlink" title="一、图片手动解码"></a>一、图片手动解码</h2><p>写在前面：图片编码解码理论见上上篇</p><p>场景：适用于需要快速显示图片的地方，例如tableCell，先把图片进行bitmap解码操作加入缓存。同时如果是超大图可以和下面第三节的图片压缩方法搭配使用。</p><p>解决方案：通过CGBitmapContextCreate 重绘图片，这种压缩的图片等于手动进行了一次解码，可以加快图片的展示</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片处理-强制解压缩操作-把元数据绘制到当前的上下文-压缩图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithBitmap:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">   <span class="comment">//获取当前图片数据源</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//设置大小改变压缩图片</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">   <span class="comment">//创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建绘制当前图片的上下文</span></span><br><span class="line"><span class="comment">    CGBitmapContextCreate(void * __nullable data,</span></span><br><span class="line"><span class="comment">     size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span></span><br><span class="line"><span class="comment">     CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span></span><br><span class="line"><span class="comment">     data：所需要的内存空间 传nil会自动分配</span></span><br><span class="line"><span class="comment">     width/height：当前画布的大小</span></span><br><span class="line"><span class="comment">     bitsPerComponent：每个颜色分量的大小 RGBA 每一个分量占1个字节</span></span><br><span class="line"><span class="comment">     bytesPerRow：每一行使用的字节数 4*width</span></span><br><span class="line"><span class="comment">     bitmapInfo：RGBA绘制的顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef =</span><br><span class="line">   <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>,</span><br><span class="line">                         width,</span><br><span class="line">                         height,</span><br><span class="line">                         <span class="number">8</span>,</span><br><span class="line">                         <span class="number">4</span>*width,</span><br><span class="line">                         colorSpace,</span><br><span class="line">                         kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//根据数据源在上下文（画板）绘制图片</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   </span><br><span class="line">   imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、大图在本地的高效显示"><a href="#二、大图在本地的高效显示" class="headerlink" title="二、大图在本地的高效显示"></a>二、大图在本地的高效显示</h2><p>项目场景：1、下载大图后需要显示在屏幕上；2、本地读取大图显示在屏幕上。特别是对性能和图片要求较高的时候。</p><p>最佳解决方案：WWDC2018 苹果给的方案，见上上篇最后一节。</p><h2 id="三、图片压缩"><a href="#三、图片压缩" class="headerlink" title="三、图片压缩"></a>三、图片压缩</h2><p>写在前面：首先介绍两种最简单最常见的压缩方式，下面复杂的压缩方式也是在此之上的扩展，可以根据实际情况进行调整；</p><p>关于质量的压缩，苹果提供了一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br></pre></td></tr></table></figure><p>关于这个方法，理论上值越小表示图片质量越低，图片文件自然越小。但是并不是 compression 取 0，就是0b大小，取 1 就是原图。而且如果你是一张很大的图，即使compression = 0.0001等或更小，图片压缩到一定大小后，都无法再被压缩下去。</p><h3 id="3-1-按照指定压缩比例压缩图片"><a href="#3-1-按照指定压缩比例压缩图片" class="headerlink" title="3.1 按照指定压缩比例压缩图片"></a>3.1 按照指定压缩比例压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照质量压缩</span></span><br><span class="line"><span class="comment">//主要弊端：如果有大图按这个方法，尺寸有可能依然很大</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQuality:(<span class="built_in">CGFloat</span>)rate &#123;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, rate);</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-按照指定尺寸压缩图片"><a href="#3-2-按照指定尺寸压缩图片" class="headerlink" title="3.2 按照指定尺寸压缩图片"></a>3.2 按照指定尺寸压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照尺寸压缩</span></span><br><span class="line"><span class="comment">// 主要弊端：图片可能会变形，质量也无法保证</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">   <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">   [<span class="keyword">self</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-具体的应用场景分析"><a href="#3-3-具体的应用场景分析" class="headerlink" title="3.3 具体的应用场景分析"></a>3.3 具体的应用场景分析</h3><h4 id="1-上传或存储有大小要求的图片"><a href="#1-上传或存储有大小要求的图片" class="headerlink" title="1. 上传或存储有大小要求的图片"></a>1. 上传或存储有大小要求的图片</h4><p>循环逐渐减小图片尺寸，直到图片稍小于指定大小，这样做的好处是可以在我们限定图片大小后，图片尺寸也是此时最大的。问题是循环次数多，效率低，耗时长。可以用二分法来提高效率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环逐渐减小图片尺寸，直到图片稍小于指定大小</span></span><br><span class="line"><span class="comment">// 同样的问题是循环次数多，效率低，耗时长。可以用二分法来提高效率，具体代码省略。这里介绍另外一种方法，比二分法更好，压缩次数少，而且可以使图片压缩后刚好小于指定大小(不只是 &lt; maxLength， &gt; maxLength * 0.9)。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleSize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="keyword">self</span>;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">       lastDataLength = data.length;</span><br><span class="line">       <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">       <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">       <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">       <span class="comment">// Use image to draw (drawInRect:), image is larger but more compression time</span></span><br><span class="line">       <span class="comment">// Use result image to draw, image is smaller but less compression time</span></span><br><span class="line">       [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">       resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">       <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">       data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-上传或存储有质量要求的图片"><a href="#2-上传或存储有质量要求的图片" class="headerlink" title="2. 上传或存储有质量要求的图片"></a>2. 上传或存储有质量要求的图片</h4><p>循环压缩图片质量直到图片稍小于指定大小，默认循环6次，循环太多次后面也再也压不下去，当然这个次数可以自行配置。好处就是最大限度的保证了图片质量。同样用二分法来提高效率。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环压缩图片质量直到图片稍小于指定大小。</span></span><br><span class="line"><span class="comment">// ⚠️：注意：当图片质量低于一定程度时，继续压缩没有效果。默认压缩最多6次,通过二分法来优化循环次数多</span></span><br><span class="line"><span class="comment">// 压缩图片质量的优点在于，尽可能保留图片清晰度，图片不会明显模糊；缺点在于，不能保证图片压缩后小于指定大小。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleQulity:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在大小有上限的情况下尽量保证质量"><a href="#3-在大小有上限的情况下尽量保证质量" class="headerlink" title="3. 在大小有上限的情况下尽量保证质量"></a>3. 在大小有上限的情况下尽量保证质量</h4><p>两种图片压缩方法结合 尽量兼顾质量和大小。以确保大小合适为标准。好处就是在大小限定的情况下最大保证了质量和尺寸。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQulitySize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="comment">// Compress by quality</span></span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> resultImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Compress by size</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">        lastDataLength = data.length;</span><br><span class="line">        <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                 (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">        [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">        resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, compression);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、图片像素修改操作"><a href="#四、图片像素修改操作" class="headerlink" title="四、图片像素修改操作"></a>四、图片像素修改操作</h2><p>写在前面：这部分的理论都是通过图片重绘来修改修该图片位图中的像素值，从而达到图片的修改。</p><h3 id="4-1-图片灰度图-黑白图"><a href="#4-1-图片灰度图-黑白图" class="headerlink" title="4.1 图片灰度图(黑白图)"></a>4.1 图片灰度图(黑白图)</h3><p>灰度图的三种颜色转换算法：</p><ol><li><p>浮点算法：R = G = B = 0.3<em>R + 0.59</em>G + 0.11*B</p></li><li><p>平均值法：R = G = B = (R+G+B)/3</p></li><li><p>任取一个分量色：R = G = B = R或G或B</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToGray:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">    <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">            <span class="comment">//计算平均值重新存储像素点-直接操作像素点</span></span><br><span class="line">            uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">            <span class="comment">//rgbPiexl[0],rgbPiexl[1],rgbPiexl[2];</span></span><br><span class="line">            <span class="comment">//(rgbPiexl[0]+rgbPiexl[1]+rgbPiexl[2])/3;</span></span><br><span class="line">            uint32_t gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">                gray = (rgbPiexl[<span class="number">0</span>]+rgbPiexl[<span class="number">1</span>]+rgbPiexl[<span class="number">2</span>])/<span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rgbPiexl[<span class="number">0</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">1</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">2</span>] = gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文绘制</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-修改图片的RGB值"><a href="#4-2-修改图片的RGB值" class="headerlink" title="4.2 修改图片的RGB值"></a>4.2 修改图片的RGB值</h3><p>通过修改图片的RGB值来控制图片的颜色显示。或者替换某种颜色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToRGB:(<span class="built_in">CGFloat</span>)rk g:(<span class="built_in">CGFloat</span>)gk b:(<span class="built_in">CGFloat</span>)bk &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//1、获取图片宽高</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="comment">//2、创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">   <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">   <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">   <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">           <span class="comment">//操作像素点</span></span><br><span class="line">           uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">           <span class="comment">//该色值下不做处理</span></span><br><span class="line">           <span class="keyword">if</span> (rgbPiexl[<span class="number">0</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">1</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">2</span>]&gt;<span class="number">245</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;该色值下不做处理&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               rgbPiexl[<span class="number">0</span>] = rgbPiexl[<span class="number">0</span>]*rk;</span><br><span class="line">               rgbPiexl[<span class="number">1</span>] = rgbPiexl[<span class="number">1</span>]*gk;</span><br><span class="line">               rgbPiexl[<span class="number">2</span>] = rgbPiexl[<span class="number">2</span>]*bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据上下文绘制</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="comment">//释放用过的内存</span></span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">   free(imagePiexl);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-图片打码"><a href="#4-3-图片打码" class="headerlink" title="4.3 图片打码"></a>4.3 图片打码</h3><p>马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置马赛克</span></span><br><span class="line"><span class="comment">//马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</span></span><br><span class="line"><span class="comment">//同样使用强制解压缩操作，操作像素点，马赛克部分实际操作</span></span><br><span class="line"><span class="comment">//1、设置区域大小；</span></span><br><span class="line"><span class="comment">//2、在该区域获取一个像素点（第一个）作为整个区域的取色；</span></span><br><span class="line"><span class="comment">//3、将取色设置到区域中；</span></span><br><span class="line"><span class="comment">//4、取下一个区域同上去色设置区域</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageToMosaic:(<span class="built_in">NSInteger</span>)size; &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="comment">//5、获取像素数组</span></span><br><span class="line">    <span class="built_in">UInt8</span> *bitmapPixels = <span class="built_in">CGBitmapContextGetData</span>(contextRef);</span><br><span class="line">    <span class="built_in">UInt8</span> *pixels[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentPixels = <span class="number">0</span>;<span class="comment">//当前的像素点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> preCurrentPiexls = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> mosaicSize = size;<span class="comment">//马赛克尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>;  i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span> ; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            currentPixels = i * width + j;</span><br><span class="line">            <span class="keyword">if</span> (i % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    memcpy(pixels, bitmapPixels + <span class="number">4</span> * currentPixels, <span class="number">4</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, pixels, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCurrentPiexls = (i - <span class="number">1</span>) * width + j;</span><br><span class="line">                memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, bitmapPixels + <span class="number">4</span> * preCurrentPiexls, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文创建图片数据源</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、图形框架合成图片"><a href="#五、图形框架合成图片" class="headerlink" title="五、图形框架合成图片"></a>五、图形框架合成图片</h2><p>使用不同图形框架合成图片，添加滤镜水印等。</p><p>写在前面：理论和上面像素修改一样，通过操作像素达到修改图片的目的，但是这里使用了系统提供的不同框架和第三方GPUImage。不同框架效率也有所不一样。这里每段代码都加入了对应像素（黑白处理），只是为了学习，后面可以根据需求在对应代码块添加或替换对应对像素的操作，亦可后面加入参数进行封装。</p><h3 id="5-1-直接绘图合成"><a href="#5-1-直接绘图合成" class="headerlink" title="5.1 直接绘图合成"></a>5.1 直接绘图合成</h3><p>此方案原理上就是通过绘图，将多张图片的像素按照自己的设计绘制在一张图片上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingPixels:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line">   <span class="comment">// 1. Get the raw pixels of the image</span></span><br><span class="line">   <span class="built_in">UInt32</span> * backPixels;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGImageRef</span> backCGImage = [backImage <span class="built_in">CGImage</span>];</span><br><span class="line">   <span class="built_in">NSUInteger</span> backWidth = <span class="built_in">CGImageGetWidth</span>(backCGImage);</span><br><span class="line">   <span class="built_in">NSUInteger</span> backHeight = <span class="built_in">CGImageGetHeight</span>(backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> backBytesPerRow = bytesPerPixel * backWidth;</span><br><span class="line"></span><br><span class="line">   backPixels = (<span class="built_in">UInt32</span> *)calloc(backHeight * backWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(backPixels, backWidth, backHeight,</span><br><span class="line">                                                bitsPerComponent, backBytesPerRow, colorSpace,</span><br><span class="line">                                                kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, backWidth, backHeight), backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. Blend the pattern onto the image</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> frontCGImage = [frontImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.1 Calculate the size &amp; position of the pattern</span></span><br><span class="line">   <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line">   <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line">   <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"> <span class="comment">//    CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line">       <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 Scale &amp; Get pixels of the pattern</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> frontBytesPerRow = bytesPerPixel * frontSize.width;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UInt32</span> *frontPixels = (<span class="built_in">UInt32</span> *)calloc(frontSize.width * frontSize.height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> frontContext = <span class="built_in">CGBitmapContextCreate</span>(frontPixels, frontSize.width, frontSize.height,</span><br><span class="line">                                                     bitsPerComponent, frontBytesPerRow, colorSpace,</span><br><span class="line">                                                     kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(frontContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, frontSize.width, frontSize.height),frontCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 Blend each pixel</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> offsetPixelCountForInput = frontOrigin.y * backWidth + frontOrigin.x;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; frontSize.height; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; frontSize.width; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> *backPixel = backPixels + j * backWidth + i + offsetPixelCountForInput;</span><br><span class="line">           <span class="built_in">UInt32</span> backColor = *backPixel;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">UInt32</span> * frontPixel = frontPixels + j * (<span class="keyword">int</span>)frontSize.width + i;</span><br><span class="line">           <span class="built_in">UInt32</span> frontColor = *frontPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Blend the pattern with 50% alpha</span></span><br><span class="line"><span class="comment">//            CGFloat frontAlpha = 0.5f * (A(frontColor) / 255.0);</span></span><br><span class="line">           <span class="built_in">CGFloat</span> frontAlpha = <span class="number">1.0</span>f * (A(frontColor) / <span class="number">255.0</span>);</span><br><span class="line">           <span class="built_in">UInt32</span> newR = R(backColor) * (<span class="number">1</span> - frontAlpha) + R(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newG = G(backColor) * (<span class="number">1</span> - frontAlpha) + G(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newB = B(backColor) * (<span class="number">1</span> - frontAlpha) + B(frontColor) * frontAlpha;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Clamp, not really useful here :p</span></span><br><span class="line">           newR = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newR));</span><br><span class="line">           newG = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newG));</span><br><span class="line">           newB = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newB));</span><br><span class="line"></span><br><span class="line">           *backPixel = RGBAMake(newR, newG, newB, A(backColor));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Convert the image to Black &amp; White</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; backHeight; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; backWidth; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> * currentPixel = backPixels + (j * backWidth) + i;</span><br><span class="line">           <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Average of RGB = greyscale</span></span><br><span class="line">           <span class="built_in">UInt32</span> averageColor = (R(color) + G(color) + B(color)) / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">           *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Create a new UIImage</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">   <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5. Cleanup!</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(frontContext);</span><br><span class="line">   free(backPixels);</span><br><span class="line">   free(frontPixels);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-CoreGraphics-框架合成图片"><a href="#5-2-CoreGraphics-框架合成图片" class="headerlink" title="5.2 CoreGraphics 框架合成图片"></a>5.2 CoreGraphics 框架合成图片</h3><p>使用CoreGraphics框架合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingCoreGraphics:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line"> <span class="built_in">CGRect</span> imageRect = &#123;<span class="built_in">CGPointZero</span>,backImage.size&#125;;</span><br><span class="line"> <span class="built_in">NSInteger</span> backWidth = <span class="built_in">CGRectGetWidth</span>(imageRect);</span><br><span class="line"> <span class="built_in">NSInteger</span> backHeight = <span class="built_in">CGRectGetHeight</span>(imageRect);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. Blend the pattern onto our image</span></span><br><span class="line"> <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line"> <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"><span class="comment">//  CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line"> <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">CGRect</span> frontRect = &#123;frontOrigin, frontSize&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIGraphicsBeginImageContext</span>(backImage.size);</span><br><span class="line"> <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// flip drawing context</span></span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flip = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flipThenShift = <span class="built_in">CGAffineTransformTranslate</span>(flip,<span class="number">0</span>,-backHeight);</span><br><span class="line"> <span class="built_in">CGContextConcatCTM</span>(context, flipThenShift);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.1 Draw our image into a new CGContext</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [backImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.2 Set Alpha to 0.5 and draw our pattern on</span></span><br><span class="line"> <span class="built_in">CGContextSetBlendMode</span>(context, kCGBlendModeSourceAtop);</span><br><span class="line"> <span class="built_in">CGContextSetAlpha</span>(context,<span class="number">0.5</span>);</span><br><span class="line"> <span class="built_in">CGRect</span> transformedpatternRect = <span class="built_in">CGRectApplyAffineTransform</span>(frontRect, flipThenShift);</span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, transformedpatternRect, [frontImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIImage</span> * imageWithFront = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"> <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 2. Convert our image to Black and White</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.1 Create a new context with a gray color space</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, backWidth, backHeight,</span><br><span class="line">                          <span class="number">8</span>, <span class="number">0</span>, colorSpace, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.2 Draw our image into the new context</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [imageWithFront <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.3 Get our new B&amp;W Image</span></span><br><span class="line"> <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"> <span class="built_in">UIImage</span> * finalImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Cleanup</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"> <span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> finalImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-CoreImage-框架合成图片"><a href="#5-3-CoreImage-框架合成图片" class="headerlink" title="5.3 CoreImage 框架合成图片"></a>5.3 CoreImage 框架合成图片</h3><p>使用CoreImage 框架以添加滤镜形式合成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)processUsingCoreImage:(UIImage *)backImage frontImage:(UIImage *)frontImage &#123;</span><br><span class="line">  CIImage * backCIImage &#x3D; [[CIImage alloc] initWithImage:backImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 1. Create a grayscale filter</span><br><span class="line">  CIFilter * grayFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorControls&quot;];</span><br><span class="line">  [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. Create our pattern filter</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Cheat: create a larger pattern image</span><br><span class="line">  UIImage * patternFrontImage &#x3D; [self createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">  CIImage * frontCIImage &#x3D; [[CIImage alloc] initWithImage:patternFrontImage];</span><br><span class="line"></span><br><span class="line">  CIFilter * alphaFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorMatrix&quot;];</span><br><span class="line">&#x2F;&#x2F;  CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:0.5 W:0];</span><br><span class="line">     CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:1.0 W:0];</span><br><span class="line">  [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;];</span><br><span class="line">  </span><br><span class="line">  CIFilter * blendFilter &#x3D; [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. Apply our filters</span><br><span class="line">  [alphaFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  frontCIImage &#x3D; [alphaFilter outputImage];</span><br><span class="line"></span><br><span class="line">  [blendFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  [blendFilter setValue:backCIImage forKeyPath:@&quot;inputBackgroundImage&quot;];</span><br><span class="line">  CIImage * blendOutput &#x3D; [blendFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  CIImage * outputCIImage &#x3D; [grayFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. Render our output image</span><br><span class="line">  CIContext * context &#x3D; [CIContext contextWithOptions:nil];</span><br><span class="line">  CGImageRef outputCGImage &#x3D; [context createCGImage:outputCIImage fromRect:[outputCIImage extent]];</span><br><span class="line">  UIImage * outputImage &#x3D; [UIImage imageWithCGImage:outputCGImage];</span><br><span class="line">  CGImageRelease(outputCGImage);</span><br><span class="line">  </span><br><span class="line">  return outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createPaddedPatternImageWithSize 这是个生成滤镜图案的代码块具体请看<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">DEMO</a></p><h3 id="5-4-GPUImage-框架合成图片"><a href="#5-4-GPUImage-框架合成图片" class="headerlink" title="5.4 GPUImage 框架合成图片"></a>5.4 GPUImage 框架合成图片</h3><p>使用GPUImage 框架以添加滤镜形式合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingGPUImage:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 1. Create our GPUImagePictures</span></span><br><span class="line">   GPUImagePicture * backGPUImage = [[GPUImagePicture alloc] initWithImage:backImage];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> *fliterImage = [<span class="keyword">self</span> createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">   GPUImagePicture * frontGPUImage = [[GPUImagePicture alloc] initWithImage:fliterImage];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2. Setup our filter chain</span></span><br><span class="line">   GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init];</span><br><span class="line">   alphaBlendFilter.mix = <span class="number">0.5</span>;</span><br><span class="line">   </span><br><span class="line">   [backGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">0</span>];</span><br><span class="line">   [frontGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">   GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init];</span><br><span class="line">   </span><br><span class="line">   [alphaBlendFilter addTarget:grayscaleFilter];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3. Process &amp; grab output image</span></span><br><span class="line">   [backGPUImage processImage];</span><br><span class="line">   [frontGPUImage processImage];</span><br><span class="line">   [grayscaleFilter useNextFrameForImageCapture];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> * output = [grayscaleFilter imageFromCurrentFramebuffer];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-对比总结"><a href="#5-5-对比总结" class="headerlink" title="5.5 对比总结"></a>5.5 对比总结</h3><ul><li>从代码量来看：明显1直接绘图合成的代码量明显高出许多。CoreImage，和GPUImage的方案要自己加入pattern图，其实代码量也不算少。因此仅从合成图这个功能来看。代码量上 CoreGraphic方案最优。</li><li>从性能来看：本地测试，CoreGraphic，直接绘图合成，速度最快。GPUImage也差不多，CoreImage添加滤镜方案最慢。</li><li>从可控多样性需求来说：GPUImage本来就提供很多滤镜，同时开源。无疑当前最佳，但是其他的都可以自己进行对应功能封装。</li></ul><p>总的来说还是要看项目需求，个人觉得一般性添加水印，合成图片什么如果要直接用CoreGraphic是个不错的选择，以后有时间可以基于CoreGraphic封装功能。</p><h2 id="六、参考文档"><a href="#六、参考文档" class="headerlink" title="六、参考文档"></a>六、参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/822841145b52">iOS图片压缩</a></li><li><a href="https://link.juejin.cn/?target=https://www.raywenderlich.com/sessions/new?return_path=/2335-image-processing-in-ios-part-1-raw-bitmap-modification">Image-Processing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。&lt;a href=&quot;https://juejin.cn/post/68466875</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(二) - 图形与视频处理相关的框架</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing.html</id>
    <published>2021-09-15T15:54:01.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 - <a href="https://juejin.cn/post/6844903645272604679">iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚接触iOS图形相关框架的小白，有一些图形框架在字面上和功能上非常容易混淆。这里旨在总结一下各种框架，区分它们的概念和功能，以作日后进一步细分学习的指引。因而，<strong>本文并不会针对具体框架作详解，只作区分引导</strong>，读者可自行选择方向继续深造。为此，笔者总结了一张各种框架关系图，如下所示：</p><img src="/images/graphics/GraphicsFrames.png" alt="GraphicsFrames" style="zoom:59%;" /><img src="/images/iosrender/01.png" alt="01" style="zoom:90%;" /><p>总的来说，iOS与图形图像处理相关的框架都在这里了：</p><ul><li>界面图形框架 – UIKit</li><li>核心动画框架 – Core Animation</li><li>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D</li><li>传统跨平台图形框架 – OpenGL ES</li><li>苹果最新力推的图形框架 – Metal</li><li>适合图片的苹果滤镜框架 – Core Image</li><li>适合视频的第三方滤镜方案 – GPUImage</li><li>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)</li><li>计算机视觉在iOS的应用 – OpenCV for iOS</li></ul><h2 id="一、界面图形-—-UIKit"><a href="#一、界面图形-—-UIKit" class="headerlink" title="一、界面图形 — UIKit"></a>一、界面图形 — UIKit</h2><h3 id="1-1-UIKit"><a href="#1-1-UIKit" class="headerlink" title="1.1 UIKit"></a>1.1 UIKit</h3><p>UIKit是一组Objective-C API，为线条图形、Quartz图像和颜色操作提供Objective-C 封装，并提供2D绘制、图像处理及用户接口级别的动画。</p><p>UIKit包括UIBezierPath（绘制线、角度、椭圆及其它图形）、UIImage（显示图像）、UIColor（颜色操作）、UIFont和UIScreen（提供字体和屏幕信息）等类以及在位图图形环境、PDF图形环境上进行绘制和 操作的功能等, 也提供对标准视图的支持，也提供对打印功能的支持。</p><h3 id="1-2-UIKit与Core-Graphics的关系"><a href="#1-2-UIKit与Core-Graphics的关系" class="headerlink" title="1.2 UIKit与Core Graphics的关系"></a>1.2 UIKit与Core Graphics的关系</h3><p>在UIKit中，UIView类本身在绘制时<strong>自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境</strong>。在绘制时可以调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    &#x2F;&#x2F; Drawing code</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#x2F;&#x2F;1.获取上下文</span><br><span class="line">    CGContextRef contextRef &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;2.描述路径</span><br><span class="line">    UIBezierPath * path &#x3D; [UIBezierPath bezierPath];</span><br><span class="line">    &#x2F;&#x2F;起点</span><br><span class="line">    [path moveToPoint:CGPointMake(10, 10)];</span><br><span class="line">    &#x2F;&#x2F;终点</span><br><span class="line">    [path addLineToPoint:CGPointMake(100, 100)];</span><br><span class="line">    &#x2F;&#x2F;设置颜色</span><br><span class="line">    [[UIColor whiteColor]setStroke];</span><br><span class="line">    &#x2F;&#x2F;3.添加路径</span><br><span class="line">    CGContextAddPath(contextRef, path.CGPath);</span><br><span class="line">    &#x2F;&#x2F;显示路径</span><br><span class="line">    CGContextStrokePath(contextRef);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这段代码就是在UIView的子类中调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，然后向该图形环境添加路径，最后绘制。</p><h2 id="二、核心动画-—-Core-Animation"><a href="#二、核心动画-—-Core-Animation" class="headerlink" title="二、核心动画 — Core Animation"></a>二、核心动画 — Core Animation</h2><h3 id="2-1-Core-Animation"><a href="#2-1-Core-Animation" class="headerlink" title="2.1 Core Animation"></a>2.1 Core Animation</h3><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p><p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p><p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 <strong>每一个视图都对应Core Animation的一个层对象</strong>，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p><p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p><p>为了使用Core Animation实现动画，可以修改 <strong>层的属性值</strong> 来触发一个action对象的执行，不同的action对象实现不同的动画。</p><h3 id="2-2-Core-Animatio相关基类及子类"><a href="#2-2-Core-Animatio相关基类及子类" class="headerlink" title="2.2 Core Animatio相关基类及子类"></a>2.2 Core Animatio相关基类及子类</h3><p>Core Animation 提供了一下一组应用可以采用的类来提供对不同动画类型的支持：</p><ul><li><strong>CAAnimation</strong> 是一个抽象公共基类，CAAnimation采用CAMediaTiming 和CAAction协议为动画提供时间（如周期、速度、重复次数等）和action行为（启动、停止等）。</li><li><strong>CAPropertyAnimation</strong> 是  CAAnimation的抽象子类，为动画提供一个由一个key路径规定的层属性的支持；</li><li><strong>CABasicAnimation</strong> 是CAPropertyAnimation的具体子类，为一个层属性提供简单插入能力。</li><li><strong>CAKeyframeAnimation</strong> 也是CAPropertyAnimation的具体子类，提供key帧动画支持。</li></ul><h2 id="三、苹果封装的图形框架-—-Core-Graphics"><a href="#三、苹果封装的图形框架-—-Core-Graphics" class="headerlink" title="三、苹果封装的图形框架 — Core Graphics"></a>三、苹果封装的图形框架 — Core Graphics</h2><blockquote><p><a href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphics</a> 框架基于 Quartz 高级绘图引擎。 它提供具有无与伦比的输出保真度的低级、轻量级 2D 渲染。 您可以使用此框架来处理基于路径的绘图、转换、离屏渲染、抗锯齿渲染、颜色管理、渐变和阴影、图案、图像数据管理、图像创建和图像遮罩，以及 PDF 文档的创建、显示和解析。 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html?language=objc#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a></p><p>在 macOS 中，Core Graphics 还包括用于处理显示硬件、低级用户输入事件和窗口系统的服务。</p></blockquote><h3 id="3-1-Core-Graphics"><a href="#3-1-Core-Graphics" class="headerlink" title="3.1 Core Graphics"></a>3.1 Core Graphics</h3><p>Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。</p><h3 id="3-2-Quartz-2D"><a href="#3-2-Quartz-2D" class="headerlink" title="3.2 Quartz 2D"></a>3.2 Quartz 2D</h3><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p><p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p><p>Quartz 2D采用paint模式进行绘制。</p><h3 id="3-3-图形环境Context"><a href="#3-3-图形环境Context" class="headerlink" title="3.3 图形环境Context"></a>3.3 图形环境Context</h3><p>Quartz 2D中使用的图形环境也由一个类CGContext表示。</p><p>在Quartz 2D中可以把一个图形环境作为一个绘制目标。当使用Quartz 2D进行绘制时，所有设备特定的特性被包含在你使用的特定类型的图形环境中，因此通过给相同的图像操作函数提供不同的图像环境你就能够画相同的图像到不同的设备上，因此做到了图像绘制的设备无关性。</p><p>图形环境Context是个比较抽象的东西，它不仅仅是一个可以绘制的图层，还包含为当前图层设置的参数，如阴影，线条粗细，绘制模式等。可以类比成一个新建的Photoshop图层以及当前笔触，颜色等配置。</p><p>对于移动平台，有三种常见的图形环境Context：</p><ul><li>位图上下文（A bitmap graphics context）：一般用于绘制图片或者自定义控件。<ul><li>View Graphics Context: 由UIView自动创建，你重写UIView drawRect方法时，你的内容会画在这个上下文上。</li><li>Bitmap Graphics Context: 绘制在该上下文的内容会以点阵形式存储在一块内存中。简单说，就是为图片开辟一块内存，然后在里面画东西，上下文帮你把图片内存抽象成一个Context(图层)了。</li></ul></li><li>PDF上下文（A PDF graphics context）：用于生成pdf文件。</li><li>图层上下文（A layer context）：用于离屏绘制（ offscreen drawing）。</li></ul><h3 id="3-4-Quartz-2D提供的主要类包括"><a href="#3-4-Quartz-2D提供的主要类包括" class="headerlink" title="3.4 Quartz 2D提供的主要类包括"></a>3.4 Quartz 2D提供的主要类包括</h3><ul><li>CGContext：表示一个图形环境；</li><li>CGPath：使用向量图形来创建路径，并能够填充和stroke；</li><li>CGImage：用来表示位图；</li><li>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；</li><li>CGPattern：用来表示Pattern，用于重复绘制；</li><li>CGShading和 CGGradient：用于绘制剃度；</li><li>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；</li><li>CGFont, 用于绘制文本；</li><li>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</li></ul><h2 id="四、传统跨平台图形框架-—-OpenGL-ES"><a href="#四、传统跨平台图形框架-—-OpenGL-ES" class="headerlink" title="四、传统跨平台图形框架 — OpenGL ES"></a>四、传统跨平台图形框架 — OpenGL ES</h2><h3 id="4-1-OpenGL-ES"><a href="#4-1-OpenGL-ES" class="headerlink" title="4.1 OpenGL ES"></a>4.1 OpenGL ES</h3><p>OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操作和运算，从而能够高性能、高帧率利用GPU提供的2D和3D绘制能力。</p><p>OpenGL ES规范本身不定义绘制表面和绘制窗口，因此ios为了使用它必须提供和创建一个OpenGL ES 的呈现环境，创建和配置存储绘制命令结果的framebuffer 及创建和配置一个或多个呈现目标。</p><h3 id="4-2-EAGL"><a href="#4-2-EAGL" class="headerlink" title="4.2 EAGL"></a>4.2 EAGL</h3><p>在 iOS中使用EAGL提供的EAGLContext类 来实现和提供一个呈现环境，用来保持OpenGL ES使用到的硬件状态。EAGL是一个Objective-C API，提供使OpenGL ES与Core Animation和UIKIT集成的接口。</p><p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p><p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。</p><h3 id="4-3-GLKit"><a href="#4-3-GLKit" class="headerlink" title="4.3 GLKit"></a>4.3 GLKit</h3><p>可以采用不同的方式使用OpenGL ES以便呈现OpenGL ES内容到不同的目标：GLKit和CAEAGLLayer。</p><p>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。</p><p>GLKit是一组Objective-C 类，为使用OpenGL ES 提供一个面向对象接口，用来简化OpenGL ES应用的开发。</p><h3 id="4-4-CAEAGLLayer"><a href="#4-4-CAEAGLLayer" class="headerlink" title="4.4 CAEAGLLayer"></a>4.4 CAEAGLLayer</h3><p>为了使OpenGL ES内容作为一个Core Animation层的部分内容时，可以使用CAEAGLLayer 作为呈现目标，并需要另外创建framebuffer以及自己实现和控制整个绘制流程。</p><h3 id="4-5-GLKit支持四个3D应用开发的关键领域"><a href="#4-5-GLKit支持四个3D应用开发的关键领域" class="headerlink" title="4.5 GLKit支持四个3D应用开发的关键领域"></a>4.5 GLKit支持四个3D应用开发的关键领域</h3><ol><li><p>GLKView 和 GLKViewController 类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p></li><li><p>GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p></li><li><p>数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p></li><li><p>Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p></li></ol><h2 id="五、苹果最新力推的图形框架-—-Metal"><a href="#五、苹果最新力推的图形框架-—-Metal" class="headerlink" title="五、苹果最新力推的图形框架 — Metal"></a>五、苹果最新力推的图形框架 — Metal</h2><p>Metal框架支持GPU硬件加速、高级3D图形渲染以及大数据并行运算。且提供了先进而精简的API来确保框架的细粒度(fine-grain)，并且在组织架构、程序处理、图形呈现、运算指令以及指令相关数据资源的管理上都支持底层控制。其核心目的是尽可能的减少CPU开销，而将运行时产生的大部分负载交由GPU承担。</p><p>编写基于底层图形 API 的渲染引擎时，除了 Metal 以外的其他选择还有 OpenGL 和 OpenGL ES。</p><p>OpenGL 不仅支持包括 OSX，Windows，Linux 和 Android 在内的几乎所有平台，还有大量的教程，书籍和最佳实践指南等资料。目前，Metal 的资源非常有限，并且仅限于搭载了 64 位处理器的 iPhone 和 iPad。但另外一方面，因为 OpenGL 的限制，其性能与 Metal 相比并不占优势，毕竟后者是专门用来解决这些问题的。</p><p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p><h2 id="六、适合图片的苹果滤镜框架-—-Core-Image"><a href="#六、适合图片的苹果滤镜框架-—-Core-Image" class="headerlink" title="六、适合图片的苹果滤镜框架 — Core Image"></a>六、适合图片的苹果滤镜框架 — Core Image</h2><h3 id="6-1-滤镜术语"><a href="#6-1-滤镜术语" class="headerlink" title="6.1 滤镜术语"></a>6.1 滤镜术语</h3><p>摄影滤光镜，简称滤光镜、滤色镜或滤镜（Filter），是摄影时放在照相机镜头前端的一种玻璃或塑料镜片，能够对光的不同波段进行选择性吸收，从而对摄影作品产生特殊的效果。种类很多。一些图像处理软件也可以向图片中加入滤镜的模拟效果。</p><p>常用滤镜：</p><ul><li>UV镜 可降低紫外线射入镜头，另外常被做为保护镜：以保护镜头前方镜片</li><li>偏振镜 又称PL镜：可消除反光、增加色彩鲜艳</li><li>中性灰度滤镜 又称中灰镜、ND镜或减光镜：可以延长曝光时间，或在强光下可以使用大光圈正确曝光</li><li>渐变中灰滤镜 又称中灰渐变镜：可以应付大光比场景</li><li>暖色滤镜：可以暖化肤色</li></ul><p>一些图像处理软件针对性地提供了一些对传统滤镜效果的模拟功能，使图像达到一种特殊效果。滤镜通常需要同通道、图层、色阶等联合使用，才能使图像取得最佳艺术效果。</p><p>滤镜在软件界面中也直接以“滤镜”（Filter）称呼；日久便约定俗成，软件中将一些特定效果（effect）或预设（preset）以‘滤镜’统一称呼，特别于一些简单化傻瓜化软件中较为常见，如美图秀秀以及智能手机appInstagram等。如今智能手机自带的相机系统中也常见诸多滤镜。</p><h3 id="6-2-Core-Image"><a href="#6-2-Core-Image" class="headerlink" title="6.2 Core Image"></a>6.2 Core Image</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101">Core Image</a> 是一种图像处理和分析技术，旨在为静态和视频图像提供近乎实时的处理。它使用 GPU 或 CPU 渲染路径对来自 Core Graphics、Core Video 和 Image I/O 框架的图像数据类型进行操作。 </p><p>Core Image 通过提供易于使用的应用程序编程接口 (API) 来隐藏底层图形处理的细节。您无需了解 OpenGL、OpenGL ES 或 Metal 的详细信息即可利用 GPU 的强大功能，也无需了解 Grand Central Dispatch (GCD) 的任何相关信息即可获得多核处理的优势。 Core Image 为您处理细节。</p><p>Image I/O 编程接口框架允许应用程序读取和写入大多数图像文件格式。 该框架提供了高效率的色彩管理和对图像元数据的访问。</p></blockquote><img src="/images/graphics/architecture_2x.png" alt="" style="zoom:65%;" /><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p><p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p><p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p><p>iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p><p>Core Image 的 API 主要就是三类：</p><ul><li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li><li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li><li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li></ul><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:kCIContextUseSoftwareRenderer]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure><h2 id="七、适合视频的第三方滤镜方案-—-GPUImage"><a href="#七、适合视频的第三方滤镜方案-—-GPUImage" class="headerlink" title="七、适合视频的第三方滤镜方案 — GPUImage"></a>七、适合视频的第三方滤镜方案 — GPUImage</h2><p>GPUImage 优势： 最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。 在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的） GPUImage 在视频处理上有更好的表现。 GPUImage 的代码完成公开，实现透明。 可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p><h2 id="八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D"><a href="#八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D" class="headerlink" title="八、游戏引擎 — Scene Kit (3D) 和 Sprite Kit (2D)"></a>八、游戏引擎 — <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D)</h2><p>对于寻找游戏引擎的开发者来说，Metal 不是最佳选择。苹果官方的的 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D) 是更好的选择。这些 API 提供了包括物理模拟在内的更高级别的游戏引擎。</p><p>另外还有功能更全面的 3D 引擎，例如 Epic 的 <a href="https://link.juejin.cn/?target=https://www.unrealengine.com/">Unreal Engine</a> 或 <a href="https://link.juejin.cn/?target=http://unity3d.com/">Unity</a>，二者都是跨平台的。使用这些引擎，你无需直接使用 Metal 的 API，就可以从 Metal 中获益。</p><h3 id="8-1-2D渲染-–-SpriteKit"><a href="#8-1-2D渲染-–-SpriteKit" class="headerlink" title="8.1 2D渲染 – SpriteKit"></a>8.1 2D渲染 – SpriteKit</h3><p>SpriteKit 让开发者可以开发高性能、省电节能的 2D 游戏。在 iOS 8 中，我们新添了多项增强功能，这将使 2D 游戏体验更加精彩。这些新技术有助于使游戏角色的动作更加自然，并让开发者可以更轻松地在游戏中加入力场、检测碰撞和生成新的灯光效果。</p><h3 id="8-2-3D渲染-–-SceneKit"><a href="#8-2-3D渲染-–-SceneKit" class="headerlink" title="8.2 3D渲染 – SceneKit"></a>8.2 3D渲染 – SceneKit</h3><p>SceneKit 专为休闲 3D 游戏而设计，可让开发者渲染 3D 游戏场景。SceneKit 内置了物理引擎、粒子发生器和各种易用工具，可以轻松快捷地为 3D 物体编写动作。不仅如此，它还与 SpriteKit 完全集成，所以开发者可以直接在 3D 游戏中加入 SpriteKit 的素材。</p><h2 id="九、计算机视觉在iOS的应用-—-OpenCV-for-iOS"><a href="#九、计算机视觉在iOS的应用-—-OpenCV-for-iOS" class="headerlink" title="九、计算机视觉在iOS的应用 — OpenCV for iOS"></a>九、计算机视觉在iOS的应用 — OpenCV for iOS</h2><p>OpenCV 的 API 是 C++ 的。它由不同的模块组成，这些模块中包含范围极为广泛的各种方法，从底层的图像颜色空间转换到高层的机器学习工具。这里提供一个入门PDF文档 <a href="https://link.juejin.cn/?target=http://www.opencv.org.cn/forum.php?mod=viewthread&tid=33549">下载入口</a>。</p><p>使用 C++ API 并不是绝大多数 iOS 开发者每天都做的事，你需要使用 Objective-C++ 文件来调用 OpenCV 的函数。 也就是说，你不能在 Swift 或者 Objective-C 语言内调用 OpenCV 的函数。 这篇 OpenCV 的 <a href="https://link.juejin.cn/?target=http://docs.opencv.org/doc/tutorials/ios/video_processing/video_processing.html%23opencviosvideoprocessing">iOS 教程</a>告诉你只要把所有用到 OpenCV 的类的文件后缀名改为 <code>.mm</code> 就行了，包括视图控制器类也是如此。这么干或许能行得通，却不是什么好主意。正确的方式是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。</p><p>走封装的路子，你的工程中就可以只在这些封装中调用 C++ 代码，从而避免掉很多让人头痛的问题，比如直接改文件后缀名会因为在错误的文件中引用了一个 C++ 头文件而产生难以追踪的编译错误。</p><p>OpenCV 声明了命名空间 <code>cv</code>，因此 OpenCV 的类的前面会有个 <code>cv::</code> 前缀，就像 <code>cv::Mat</code>、 <code>cv::Algorithm</code> 等等。你也可以在 <code>.mm</code> 文件中使用 <code>using namespace cv</code> 来避免在一堆类名前使用 <code>cv::</code>前缀。但是，在某些类名前你必须使用命名空间前缀，比如 <code>cv::Rect</code> 和 <code>cv::Point</code>，因为它们会跟定义在 <code>MacTypes.h</code> 中的 <code>Rect</code> 和 <code>Point</code> 相冲突。尽管这只是个人偏好问题，我还是偏向在任何地方都使用 <code>cv::</code>以保持一致性。</p><p>一般讲的OpenCV是基于CPU的，相关资料和支持也是最完善的。当然，也有基于GPU模块，但提供的接口非常坑爹，相当一部分不支持浮点类型（像histogram、integral这类常用的都不支持）；又如，遇到阈值判断的地方，就必须传回cpu处理，因为gpu函数都是并行处理的，每改写完一个算法模块，就测试一下运行效率，有的时候是振奋人心，有的时候则是当头棒喝——比CPU还慢。详情可参阅 <a href="https://link.juejin.cn/?target=https://blog.csdn.net/kelvin_yan/article/details/41804357">这里</a>。</p><h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><ul><li><p>Core Animations</p><ul><li><a href="https://www.sohu.com/a/203987045_468740">https://www.sohu.com/a/203987045_468740</a> </li><li><a href="https://blog.csdn.net/huangznian/article/details/42919221">https://blog.csdn.net/huangznian/article/details/42919221</a> </li><li><a href="https://www.jianshu.com/p/446a6b72f981">https://www.jianshu.com/p/446a6b72f981</a> </li><li><a href="https://www.jianshu.com/p/439e158b44de">https://www.jianshu.com/p/439e158b44de</a></li></ul></li><li><p>Metal</p><ul><li><a href="https://juejin.cn/post/6844903494072139789">https://juejin.cn/post/6844903494072139789</a> </li><li><a href="https://www.jianshu.com/p/ce53d0178f20">https://www.jianshu.com/p/ce53d0178f20</a> </li><li><a href="https://blog.csdn.net/pizi0475/article/details/50232029">https://blog.csdn.net/pizi0475/article/details/50232029</a> </li><li><a href="https://baike.baidu.com/item/Metal/10917053?fr=aladdin">https://baike.baidu.com/item/Metal/10917053?fr=aladdin</a> </li><li><a href="https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral">https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral</a></li></ul></li><li><p>Core Image</p><ul><li><a href="https://objccn.io/issue-21-6/">https://objccn.io/issue-21-6/</a> </li><li><a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral">http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral</a> </li><li><a href="https://blog.csdn.net/jingcheng345413/article/details/54967640">https://blog.csdn.net/jingcheng345413/article/details/54967640</a> </li><li><a href="https://www.cnblogs.com/try2do-neo/p/3601546.html">https://www.cnblogs.com/try2do-neo/p/3601546.html</a></li></ul></li><li><p>Core Graphics</p><ul><li><a href="https://www.jianshu.com/p/e7a50dcbe7c8">https://www.jianshu.com/p/e7a50dcbe7c8</a> </li><li><a href="https://www.jianshu.com/p/55cc1587e618">https://www.jianshu.com/p/55cc1587e618</a> </li><li><a href="https://www.jianshu.com/p/494c57f49479">https://www.jianshu.com/p/494c57f49479</a> </li><li><a href="https://my.oschina.net/flyfishbay/blog/1504698">https://my.oschina.net/flyfishbay/blog/1504698</a></li></ul></li><li><p>OpenCV</p><ul><li><a href="https://blog.csdn.net/zhonggaorong/article/details/78191514">https://blog.csdn.net/zhonggaorong/article/details/78191514</a> </li><li><a href="http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549">http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549</a> </li><li><a href="https://blog.csdn.net/kelvin_yan/article/details/41804357">https://blog.csdn.net/kelvin_yan/article/details/41804357</a> </li><li><a href="https://blog.csdn.net/sinat_31135199/article/details/53053188">https://blog.csdn.net/sinat_31135199/article/details/53053188</a> </li><li><a href="https://blog.csdn.net/liyuefeilong/article/details/46292339">https://blog.csdn.net/liyuefeilong/article/details/46292339</a></li></ul></li><li><p>GPUImage</p><ul><li><a href="https://blog.csdn.net/fanbird2008/article/details/51707430">https://blog.csdn.net/fanbird2008/article/details/51707430</a></li></ul></li><li><p>其它</p><ul><li><a href="https://blog.csdn.net/goohong/article/details/40743883">https://blog.csdn.net/goohong/article/details/40743883</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 - &lt;a href=&quot;https://juejin.cn/post/6844903645272604679&quot;&gt;iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，Open</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(一) - 图片的加载与编解码</title>
    <link href="https://tenloy.github.io/2021/09/13/image-encode-decode.html"/>
    <id>https://tenloy.github.io/2021/09/13/image-encode-decode.html</id>
    <published>2021-09-13T19:01:06.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、位图、色彩空间"><a href="#一、位图、色彩空间" class="headerlink" title="一、位图、色彩空间"></a>一、位图、色彩空间</h2><h3 id="1-1-色彩空间"><a href="#1-1-色彩空间" class="headerlink" title="1.1 色彩空间"></a>1.1 色彩空间</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93">色彩空间</a>（Color space）是对色彩的组织方式/表示方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定<strong>模拟</strong>和<strong>数字</strong>表示。数字表示，如Adobe RGB、sRGB、RGBA。</p><p>色彩空间并不唯一，比如：</p><ul><li><strong>当在计算机监视器上显示颜色的时候，通常使用RGB（红色、绿色、蓝色）色彩空间定义</strong>，这是另外一种生成同样颜色的方法，红色、绿色、蓝色被当作X、Y和Z坐标轴。</li><li>许多人都知道在绘画时可以使用红色、黄色和蓝色这三种原色生成不同的颜色，这些颜色就定义了一个色彩空间。我们将品红色的量定义为X 坐标轴、青色的量定义为Y坐标轴、黄色的量定义为Z坐标轴，这样就得到一个三维空间，每种可能的颜色在这个三维空间中都有唯一的一个位置。</li><li>另外一个生成同样颜色的方法是使用色相（X轴）、饱和度（色度）（Y轴）和明度（Z轴）表示，这种方法称为HSV色彩空间。</li><li>另外还有许多其它的色彩空间，许多可以按照这种方法用三维（X、Y、Z）、更多或者更少维表示，但是有些根本不能用这种方法表示。</li></ul><p>常见的六种色彩空间：RGB、HSV、CMY、HSL、Lab、YUV</p><h3 id="1-2-像素格式-pixel-format"><a href="#1-2-像素格式-pixel-format" class="headerlink" title="1.2 像素格式(pixel format)"></a>1.2 像素格式(pixel format)</h3><h4 id="1-2-1-像素格式"><a href="#1-2-1-像素格式" class="headerlink" title="1.2.1 像素格式"></a>1.2.1 像素格式</h4><p>像素格式（pixel format）是指像素色彩分量的大小和排列。</p><ul><li>规定了每个像素所使用的总位数以及用于存储像素色彩的红、绿、蓝和 alpha 分量的位数。(每个分量也称为通道)</li><li>描述了像素数据存储所用的格式。定义了像素在内存中的编码方式。</li></ul><h4 id="1-2-2-常见的像素格式"><a href="#1-2-2-常见的像素格式" class="headerlink" title="1.2.2 常见的像素格式"></a>1.2.2 常见的像素格式</h4><ul><li><p>位组格式Byte formats(PF_BYTE_*)：每个通道对应一个byte</p></li><li><p>Short格式(PF_SHORT_*)：每个通道对应一个unsigned short数据(16 bit整型)</p></li><li><p>Float16 格式(PF_FLOAT16_*)：每个通道对应一个16 bit 浮点数</p></li><li><p>Float32格式(PF_FLOAT32_*)：每个通道对应一个32 bit 浮点数</p></li><li><p>压缩格式formats (PF_DXT[1-5])：S3TC压缩纹理格式</p></li><li><p>本地格式 (PF_A8R8G8B8 以及其他大量的不同的类型)：这意味着在内存中使用了本地储存方式（big endian或者little endian，包括16，24，32位）的整形数据。同时意味着可以把PF_A8R8G8B8格式的图片看作一个32位的整形<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84">数组</a>，在16进制表现为0xAARRGGBB。这些字母的意义我们在稍后会提供。</p></li></ul><h4 id="1-2-3-颜色通道"><a href="#1-2-3-颜色通道" class="headerlink" title="1.2.3 颜色通道"></a>1.2.3 颜色通道</h4><p>颜色通道中R,G,B,A,L 以及 X 的意义是：</p><p>R：红色成分，通常范围从0.0（没有红色）到1.0（全部的红色）。</p><p>G：绿色成分，通常范围从0.0（没有绿色）到1.0（全部的绿色）。</p><p>B：蓝色成分，通常范围从0.0（没有蓝色）到1.0（全部的蓝色）。</p><p>A：alpha（不透明度）成分，通常范围从0.0（完全透明）到1.0（不透明）。</p><p>L：亮度成分，通常范围从0.0（黑暗）到1.0（全白）。最终这个成分会被分散到<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>每个中完成最终的图像效果。</p><p>X：这个是被系统忽略的成分。</p><p>对于RGBL通道来说，默认的情况下设置为0。而<a href="https://baike.baidu.com/item/Alpha%E9%80%9A%E9%81%93/3163191">Alpha通道</a>却不同，在默认的情况下被设定为1，代表不透明。</p><h3 id="1-3-位图"><a href="#1-3-位图" class="headerlink" title="1.3 位图"></a>1.3 位图</h3><blockquote><p>A bitmap image (or sampled(采样) image) is an array of pixels (or samples).  Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images. </p></blockquote><p>位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，就可以在屏幕上渲染整张图片了。</p><p>一堆像素点组成的二维数组，其中每个像素点都记录该点位的颜色等信息。显示出来就是一张图了。</p><p>既然像素要存储颜色数据，这里就又引出一个颜色存储格式的概念。我们就以最简单普遍的PF_BYTE_RGBA (32-bit RGBA) 像素格式为例子，一个像素点存储的色彩所需空间是32bits或是4bytes、1byte或8bit存储是一个通道，对应下来就是：</p><ul><li>R = red (占1byte或8bit)</li><li>G = green (占1byte或8bit)</li><li>B = blue (占1byte或8bit)</li><li>A = alpha (占1byte或8bit)</li></ul><p>这样你就知道 32-bit RGBA 格式能够显示的颜色是 2^8 * 2^8* 2^8 (256 * 256 * 256)，将近一千七百多万个颜色。还有颜色空间(Color Spaces)的概念这里就不再扩展了。</p><p>而位图是装载像素点的数组，这样你大概可以理解下一张普通位图包含着多少数据！同时，这里解释颜色是为了下面计算位图大小，便于理解我们为什么要进行图片编码。</p><h2 id="二、图片、编解码"><a href="#二、图片、编解码" class="headerlink" title="二、图片、编解码"></a>二、图片、编解码</h2><h3 id="2-1-编码与解码"><a href="#2-1-编码与解码" class="headerlink" title="2.1 编码与解码"></a>2.1 编码与解码</h3><p>图片的编码： 在当前APP的开发中，图片是经常会使用到的，关于图片有很多种格式，例如JPEG，PNG等。其实这些各种各样的图片格式都对应了位图(bitmap)经过不同算法编码(压缩)后的图片。 苹果提供2种图片编码格式，PNG和JPEG：</p><ul><li>PNG图片是无损压缩，并且支持alpha通道</li><li>JPEG图片则是有损压缩，可以指定0-100%的压缩比。</li></ul><p>图片的解码： </p><ul><li><p>app从磁盘中读入编码后的图片，需要经过解码把图片变成位图(bitmap)读入，这样才能显示在屏幕上。 </p></li><li><p>iOS 默认会在主线程对图像进行解码，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位图大小 = 图片的像素宽  * 图片的像素高  * 每个像素所占的字节数(取决于像素格式)</span><br></pre></td></tr></table></figure><h3 id="2-2-位图为什么要压缩编码"><a href="#2-2-位图为什么要压缩编码" class="headerlink" title="2.2 位图为什么要压缩编码"></a>2.2 位图为什么要压缩编码</h3><p>都知道，<strong>图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</strong>既然如此，图片不编码也就不用解码，都使用位图可以吗？</p><p>举例：一张位图的宽和高分别都是100个像素，那这个位图的大小是多少呢？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一张位图size的公式</span></span><br><span class="line"><span class="comment">//bytesPerPixel每个像素点所需空间 </span></span><br><span class="line"><span class="comment">//32-bit RGBA 格式图片 bytesPerPixel = 4 (R,G,B,A各一个byte)，理论看上面</span></span><br><span class="line">size = width * height * bytesPerPixel </span><br></pre></td></tr></table></figure><p>这样把我们100x100 的位图代入该公式，可以得到其大小：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">100</span> * <span class="number">100</span> * <span class="number">4</span> = <span class="number">40000</span>B = <span class="number">39</span>KB</span><br></pre></td></tr></table></figure><p>正常一张PNG或JPEG格式的100x100的图片，大概只有几KB。如果更大的图，位图所占空间更大，所以位图必须进行编码进行存储。</p><h3 id="2-3-硬解码与软解码"><a href="#2-3-硬解码与软解码" class="headerlink" title="2.3 硬解码与软解码"></a>2.3 硬解码与软解码</h3><p>硬解码：由显卡核心GPU来对高清视频进行解码工作，通过解码电路实现，CPU占用率很低，画质效果比软解码略差一点，需要对播放器进行设置。(省电、对硬件要求高) </p><ul><li>优点：播放流畅、低功耗 </li><li>缺点：受视频格式限制、功耗大、画质没有软解码好 </li></ul><p>软解码：由CPU负责解码，通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码。(省电、对硬件要求不高) </p><ul><li>优点：不受视频格式限制、画质略好于硬解 </li><li>缺点：会占用过高的资源、对于高清视频可能没有硬解码流畅(主要看CPU的能力）</li></ul><h2 id="三、图片的加载及解码流程"><a href="#三、图片的加载及解码流程" class="headerlink" title="三、图片的加载及解码流程"></a>三、图片的加载及解码流程</h2><h3 id="3-1-图片的加载"><a href="#3-1-图片的加载" class="headerlink" title="3.1 图片的加载"></a>3.1 图片的加载</h3><h4 id="3-1-1-三种-Buffer-理念"><a href="#3-1-1-三种-Buffer-理念" class="headerlink" title="3.1.1 三种 Buffer 理念"></a>3.1.1 三种 Buffer 理念</h4><p>通常 Buffer 是表示一片连续的内存空间。在这里，我们说的 Buffer 是指一系列内部结构相同、大小相同的元素组成的内存区域。有三种Buffer：Data Buffer、Image Buffer、Frame Buffer。这个理论是2018WWDC苹果上描述的概念，具体可看<a href="https://link.juejin.cn/?target=https://asciiwwdc.com/2018/sessions/219">Image and Graphics Best Practices</a></p><ul><li>Data Buffer 是指存储在内存中的原始数据，图像可以使用不同的格式保存，如 jpg、png。Data Buffer 的信息不能用来描述图像的位图像素信息。</li><li>Image Buffer 是指图像在内存中的存在方式，其中每个元素描述了一个像素点。Image Buffer 的大小和位图的大小相等。</li><li>Frame Buffer 和 Image Buffer 内容相同，不过其存储在 vRAM（video RAM）中，而 Image Buffer 存储在 RAM 中。</li></ul><h4 id="3-1-2-两种生成UIImage的方法"><a href="#3-1-2-两种生成UIImage的方法" class="headerlink" title="3.1.2 两种生成UIImage的方法"></a>3.1.2 两种生成UIImage的方法</h4><p>iOS中根据本地icon加载出一个UIImage对象有两种方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img1 =  [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pic1&quot;</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *img2 =  [<span class="built_in">UIImage</span> imageWithContentsOfFile:filePath];</span><br></pre></td></tr></table></figure><p><code>imageNamed</code>方法</p><ul><li>后面的参数是icon的名字。图片可以存在项目中，也可以存在Assets中。</li><li>这个方法加载完图片后会存在Cache里面，当用这个方法加载的时候，它会在系统缓存中查找并返回一个对象，如果缓存中没有找到对应的对象，这个方法会从指定的文档中加载，再返回对象。</li><li>优点是提高了运行速度，缺点是消耗内存。如果是不会复用的、大图，最好不要用该方法加载。</li></ul><p><code>imageWithContentsOfFile</code>方法</p><ol><li>后面的参数是图片的路径，格式是字符串</li><li>加载图片时，会根据路径查找，直接加载，使用完后释放，不会存入内存.</li><li>优点是节省内存，缺点是消耗性能。适用于一些不常用的图片或icon，或者资源比较大图片。</li></ol><p>总结：一些小的icon可以存在Assets里面，用imageNamed加载。一些比较大的，使用频率低的可以建立一个bundle存放图片，使用imageWithContentsOfFile 加载。</p><h3 id="3-3-图片的解码"><a href="#3-3-图片的解码" class="headerlink" title="3.3 图片的解码"></a>3.3 图片的解码</h3><h4 id="3-3-1-解码触发时机"><a href="#3-3-1-解码触发时机" class="headerlink" title="3.3.1 解码触发时机"></a>3.3.1 解码触发时机</h4><p>UIImage 是 iOS 中处理图像的高级类。创建一个 UIImage 实例只会加载 Data Buffer，也就是说以上只是把图片转为UIImage对象，该对象存储在Data Buffer里。此时并没有对图片进行解码。</p><p>当将图像显示到屏幕上会触发隐式解码（<strong>必须同时满足图像被设置到 UIImageView 中、UIImageView 添加到视图，才会触发图像解码</strong>）。也就是说你就算实例了一个UIImageView，但是没有把他addSubview，显示到视图上，系统也是不会进行解码的。</p><h4 id="3-3-2-主线程解码的性能问题"><a href="#3-3-2-主线程解码的性能问题" class="headerlink" title="3.3.2  主线程解码的性能问题"></a>3.3.2  主线程解码的性能问题</h4><p>这个解码过程默认是发生在主线程上面的，而且非常消耗 CPU，所以到如果在 tableView 或者 collectionView 中有相当多的图片需要显示的话，这些图片在主线程的解码操作必然会影响滑动的顺畅度。所以我们是否可以在子线程强制将其解码，然后在主线程让系统渲染解码之后的图片呢？当然可以，现在基本上所有的开源图片库都会实现这个操作。例如：YYImage\SDWebImage。</p><h4 id="3-3-3-手动解码的原理"><a href="#3-3-3-手动解码的原理" class="headerlink" title="3.3.3 手动解码的原理"></a>3.3.3 手动解码的原理</h4><p>自己手动解码的原理就是对图片进行重新绘制，得到一张新的解码后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(</span><br><span class="line">  <span class="keyword">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">                                  size_t width, </span><br><span class="line">                                  size_t height, </span><br><span class="line">                                  size_t bitsPerComponent, </span><br><span class="line">                                  size_t bytesPerRow,</span><br><span class="line">                                  <span class="built_in">CGColorSpaceRef</span> cg_nullable space, </span><br><span class="line">                                  uint32_t bitmapInfo) <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>这个方法是创建一个图片处理的上下文 CGContext 对象，因为上面方法的返回值 CGContextRef 实际上就是 CGContext *。关于这个函数的详细讲解博文有很多，官方文档<a href="https://link.juejin.cn/?target=https://developer.apple.com/documentation/coregraphics/1455939-cgbitmapcontextcreate?language=objc">CGBitmapContextCreate</a>。博客<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/e9843d5b70a2">图片解码</a>。</p><h4 id="3-3-4-开源框架解码实现"><a href="#3-3-4-开源框架解码实现" class="headerlink" title="3.3.4 开源框架解码实现"></a>3.3.4 开源框架解码实现</h4><p>开源框架的解决方案基础也是基于这个API：</p><h5 id="1-YYImage-中的解码"><a href="#1-YYImage-中的解码" class="headerlink" title="1. YYImage 中的解码"></a>1. YYImage 中的解码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="built_in">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!imageRef) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">       <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">       <span class="built_in">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">       <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">           alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">           alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">           alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">           hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">       <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">       <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">       bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">       <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">       <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">       <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">       <span class="built_in">CFRelease</span>(context);</span><br><span class="line">       <span class="keyword">return</span> newImage;</span><br><span class="line">       </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上, 这个方法的作用是创建一个图像的拷贝，它接受一个原始的位图参数 imageRef ，最终返回一个新的解码后的位图 newImage ，中间主要经过了以下三个步骤：</p><ul><li>使用 CGBitmapContextCreate 函数创建一个位图上下文；</li><li>使用 CGContextDrawImage 函数将原始位图绘制到上下文中;</li><li>使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。</li></ul><h5 id="2-SDWebImage的解码实现"><a href="#2-SDWebImage的解码实现" class="headerlink" title="2. SDWebImage的解码实现"></a>2. SDWebImage的解码实现</h5><p>事实上，SDWebImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">   <span class="keyword">if</span> (![<span class="built_in">UIImage</span> shouldDecodeImage:image]) &#123;</span><br><span class="line">       <span class="keyword">return</span> image;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</span></span><br><span class="line">   <span class="comment">// on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">   <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">       <span class="built_in">CGColorSpaceRef</span> colorspaceRef = [<span class="built_in">UIImage</span> colorSpaceForImageRef:imageRef];</span><br><span class="line">       </span><br><span class="line">       size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">       size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">       size_t bytesPerRow = kBytesPerPixel * width;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></span><br><span class="line">       <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></span><br><span class="line">       <span class="comment">// to create bitmap graphics contexts without alpha info.</span></span><br><span class="line">       <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                    width,</span><br><span class="line">                                                    height,</span><br><span class="line">                                                    kBitsPerComponent,</span><br><span class="line">                                                    bytesPerRow,</span><br><span class="line">                                                    colorspaceRef,</span><br><span class="line">                                                    kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);</span><br><span class="line">       <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> image;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Draw the image into the context and retrieve the new bitmap image without alpha</span></span><br><span class="line">       <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">       <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">       <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithoutAlpha</span><br><span class="line">                                                        scale:image.scale</span><br><span class="line">                                                  orientation:image.imageOrientation];</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">       <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">   <span class="comment">// Prevent &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; error</span></span><br><span class="line">   <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// do not decode animated images</span></span><br><span class="line">   <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">   <span class="built_in">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                    alpha == kCGImageAlphaLast ||</span><br><span class="line">                    alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                    alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">   <span class="comment">// do not decode images with alpha</span></span><br><span class="line">   <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDWebImage 中和其他不一样的地方，就是如果一张图片有 alpha 分量，那就直接返回原始图片，不再进行解码操作。这么做是因为alpha 分量不可知，为了保证原图完整信息故不做处理。</p><p>SDWebImage 在解码操作外面包了 autoreleasepool，这样在大量图片需要解码的时候，可以使得局部变量尽早释放掉，不会造成内存峰值过高。</p><h2 id="四、大图显示"><a href="#四、大图显示" class="headerlink" title="四、大图显示"></a>四、大图显示</h2><p>大的图片会占用较多的内存资源，解码和传输到 GPU 也会耗费较多时间。 因此，实际需要显示的图像尺寸可能并不是很大，如果能将大图缩小，便能达到优化的目的。</p><p>以下是WWDC给的大图显示方案，功能是缩小图像并解码：</p><h3 id="4-1-Objective-C："><a href="#4-1-Objective-C：" class="headerlink" title="4.1 Objective-C："></a>4.1 Objective-C：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大图缩小为显示尺寸的图</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)downsampleImageAt:(<span class="built_in">NSURL</span> *)imageURL to:(<span class="built_in">CGSize</span>)pointSize scale:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">    <span class="comment">// 利用图像文件地址创建 image source</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *imageSourceOptions =</span><br><span class="line">  @&#123;</span><br><span class="line">    (__bridge <span class="built_in">NSString</span> *)kCGImageSourceShouldCache: @NO <span class="comment">// 原始图像不要解码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> imageSource =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)imageURL, (__bridge <span class="built_in">CFDictionaryRef</span>)imageSourceOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下采样</span></span><br><span class="line">    <span class="built_in">CGFloat</span> maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *downsampleOptions =</span><br><span class="line">    @&#123;</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailFromImageAlways: @YES,</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceShouldCacheImmediately: @YES,  <span class="comment">// 缩小图像的同时进行解码</span></span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailWithTransform: @YES,</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceThumbnailMaxPixelSize: @(maxDimensionInPixels)</span><br><span class="line">       &#125;;</span><br><span class="line">    <span class="built_in">CGImageRef</span> downsampledImage =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, (__bridge <span class="built_in">CFDictionaryRef</span>)downsampleOptions);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:downsampledImage];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(downsampledImage);</span><br><span class="line">    <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Swift"><a href="#4-2-Swift" class="headerlink" title="4.2 Swift"></a>4.2 Swift</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Downsampling large images for display at smaller size</span></span><br><span class="line">func downsample(imageAt imageURL: URL, to pointSize: <span class="built_in">CGSize</span>, scale: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache: <span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale</span><br><span class="line">    let downsampleOptions =</span><br><span class="line">    [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as <span class="built_in">CFDictionary</span></span><br><span class="line"> </span><br><span class="line">    let downsampledImage =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://devstreaming-cdn.apple.com/videos/wwdc/2018/219mybpx95zm9x/219/219_image_and_graphics_best_practices.pdf?dl=1">WWDC2018</a></li><li><a href="https://juejin.cn/post/6847902216238399496">图片显示相关理论</a></li><li><a href="https://link.juejin.cn/?target=https://asciiwwdc.com/2018/sessions/219">Image and Graphics Best Practices</a></li><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/72dd074728d8">探讨iOS 中图片的解压缩到渲染过程</a></li><li><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/dins/p/ios-tu-pian.html">iOS 图片的解压缩</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、位图、色彩空间&quot;&gt;&lt;a href=&quot;#一、位图、色彩空间&quot; class=&quot;headerlink&quot; title=&quot;一、位图、色彩空间&quot;&gt;&lt;/a&gt;一、位图、色彩空间&lt;/h2&gt;&lt;h3 id=&quot;1-1-色彩空间&quot;&gt;&lt;a href=&quot;#1-1-色彩空间&quot; class=&quot;</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] iOS离屏渲染原理及优化</title>
    <link href="https://tenloy.github.io/2021/09/12/iOS-Render.html"/>
    <id>https://tenloy.github.io/2021/09/12/iOS-Render.html</id>
    <published>2021-09-12T20:24:55.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a>、<a href="https://juejin.cn/post/6846687603316490254">iOS圆角的离屏渲染</a></p></blockquote><p>作为一个客户端工程师，把控渲染性能是最关键、最独到的技术要点之一，如果仅仅了解表面知识，到了实际应用时往往会失之毫厘谬以千里，无法得到预期的效果。</p><h2 id="一、先来了解iOS的渲染流程"><a href="#一、先来了解iOS的渲染流程" class="headerlink" title="一、先来了解iOS的渲染流程"></a>一、先来了解iOS的渲染流程</h2><blockquote><p>如果对下图没有疑问，可以直接向下阅读。反之，可以先阅读上篇文章 <a href="https://tenloy.github.io/2021/09/11/core-animation03.html">渲染流程探究及性能分析</a></p></blockquote><img src="/images/iosrender/15.png" alt="01" style="zoom:55%;" /><h2 id="二、GPU的两种渲染方式"><a href="#二、GPU的两种渲染方式" class="headerlink" title="二、GPU的两种渲染方式"></a>二、GPU的两种渲染方式</h2><p>OpenGL中，GPU屏幕渲染有以下两种方式当前屏幕渲染：</p><h3 id="2-1-On-Screen-Rendering"><a href="#2-1-On-Screen-Rendering" class="headerlink" title="2.1 On-Screen Rendering"></a>2.1 On-Screen Rendering</h3><blockquote><p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p></blockquote><p>正常情况下，如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的帧缓冲区(frame buffer)，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。流程如图：</p><img src="/images/iosrender/03.png" alt="01" style="zoom:90%;" /><h3 id="2-2-Off-Screen-Rendering"><a href="#2-2-Off-Screen-Rendering" class="headerlink" title="2.2 Off-Screen Rendering"></a>2.2 Off-Screen Rendering</h3><blockquote><p>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个（离屏）缓冲区进行渲染操作。</p></blockquote><p>如果有时因为一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。流程如图：</p><img src="/images/iosrender/04.png" alt="01" style="zoom:90%;" /><h2 id="三、GPU离屏渲染"><a href="#三、GPU离屏渲染" class="headerlink" title="三、GPU离屏渲染"></a>三、GPU离屏渲染</h2><h3 id="3-1-为什么及何时需要离屏渲染"><a href="#3-1-为什么及何时需要离屏渲染" class="headerlink" title="3.1 为什么及何时需要离屏渲染"></a>3.1 为什么及何时需要离屏渲染</h3><p>在上面的渲染流水线示意图中我们可以看到，主要的渲染操作都是由CoreAnimation的Render Server模块，通过调用显卡驱动所提供的OpenGL/Metal接口来执行的。通常对于每一层layer，Render Server会遵循“<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Painter%27s_algorithm">画家算法</a>”，按次序输出到frame buffer，后一层覆盖前一层，就能得到最终的显示结果（值得一提的是，与一般桌面架构不同，在iOS中，设备主存和GPU的显存<a href="https://link.zhihu.com/?target=https://apple.stackexchange.com/questions/54977/how-much-gpu-memory-do-iphones-and-ipads-have">共享物理内存</a>，这样可以省去一些数据传输开销）。</p><p>画家算法通过按深度对图像中的物体进行排序，并按从（距离观察者）最远到最近的顺序，依次将每一层绘制输出到画布，来创建图像。</p><img src="/images/iosrender/05.png" alt="01" style="zoom:90%;" /><p>然而有些场景并没有那么简单。作为“画家”的GPU虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来擦除/改变其中的某个部分——因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着，<strong>对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作</strong>。</p><p>以绘制一个带有圆角并剪切圆角以外内容的容器，会触发离屏渲染为例。我的猜想是（如果读者中有图形学专家希望能指正）：</p><ul><li>将一个layer的内容裁剪成圆角，可能不存在一次遍历就能完成的方法</li><li>容器的子layer因为父容器有圆角，那么也会需要被裁剪，而这时它们还在渲染队列中排队，尚未被组合到一块画布上，自然也无法统一裁剪</li></ul><p>此时我们就不得不开辟一块独立于frame buffer的空白内存，先把容器以及其所有子layer依次画好，然后把四个角“剪”成圆形，再把结果画到frame buffer中。这就是GPU的离屏渲染。</p><p>个人总结：什么场景下需要离屏渲染</p><img src="/images/iosrender/06.png" alt="01" style="zoom:90%;" /><ul><li>当一个属性的设置需要对一个以上的图层修改时。<ul><li>如设置<code>cornerRadius</code>以及<code>masksToBounds</code>进行圆角+裁剪时，<code>masksToBounds</code>裁剪属性会应用到所有的图层上。如果此时View、layer中不止一个图层，那就会触发离屏渲染了。</li><li>如设置<code> group opacity</code></li></ul></li><li>当一个图层，按照画家算法本应该先绘制，但由于依赖后续图层的数据，只能延后绘制时<ul><li>阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。但矛盾在于<strong>此时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？</strong></li></ul></li></ul><h3 id="3-2-GPU离屏渲染的性能影响"><a href="#3-2-GPU离屏渲染的性能影响" class="headerlink" title="3.2 GPU离屏渲染的性能影响"></a>3.2 GPU离屏渲染的性能影响</h3><p>离屏渲染增大了系统的负担，会形象App性能。主要表现在以下几个方面：</p><ul><li>离屏渲染需要额外的存储空间，渲染空间大小的上限是2.5倍的屏幕像素大小，超过无法使用离屏渲染。</li><li>容易掉帧：一旦因为离屏渲染导致最终存入帧缓存区的时候，已经超过了16.67ms，则会出现掉帧的情况，造成卡顿。</li></ul><p>GPU的操作是高度流水线化的。本来所有计算工作都在有条不紊地正在向frame buffer输出，此时突然收到指令，需要输出到另一块内存，那么流水线中正在进行的一切都不得不被丢弃，切换到只能服务于我们当前的“切圆角”操作。等到完成以后再次清空，再回到向frame buffer输出的正常流程。</p><p>在tableView或者collectionView中，滚动的每一帧变化都会触发每个cell的重新绘制，因此一旦存在离屏渲染，上面提到的<strong>上下文切换</strong>就会每秒发生60次，并且很可能每一帧有几十张的图片要求这么做，对于GPU的性能冲击可想而知（GPU非常擅长大规模并行计算，但是我想频繁的上下文切换显然不在其设计考量之中）</p><p>每16ms就需要根据当前滚动位置渲染整个tableView，是个不小的性能挑战：</p><img src="/images/iosrender/12.jpg" alt="01" style="zoom:90%;" /><h3 id="3-3-善用离屏渲染-shouldRasterize"><a href="#3-3-善用离屏渲染-shouldRasterize" class="headerlink" title="3.3 善用离屏渲染 shouldRasterize"></a>3.3 善用离屏渲染 shouldRasterize</h3><p>尽管离屏渲染开销很大，但是当我们无法避免它的时候，可以想办法把性能影响降到最低。优化思路也很简单：既然已经花了不少精力把图片裁出了圆角，如果我能把结果缓存下来，那么下一帧渲染就可以复用这个成果，不需要再重新画一遍了。</p><p>CALayer为这个方案提供了对应的解法：shouldRasterize。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染。有几个需要注意的点：</p><ul><li>首先，layer不复用，没必要打开shouldRasterize。</li><li>shouldRasterize的主旨在于<strong>降低性能损失，但总是至少会触发一次离屏渲染</strong>。如果你的layer本来并不复杂，也没有圆角阴影等等，打开这个开关反而会增加一次不必要的离屏渲染</li><li>离屏渲染缓存有空间上限，最多不超过屏幕总像素的2.5倍大小</li><li>一旦缓存超过100ms没有被使用，会自动被丢弃</li><li>layer的内容（包括子layer）必须是静态的，因为一旦发生变化（如resize，动画），之前辛苦处理得到的缓存就失效了。如果这件事频繁发生，我们就又回到了“每一帧都需要离屏渲染”的情景，而这正是开发者需要极力避免的。针对这种情况，Xcode提供了“Color Hits Green and Misses Red”的选项，帮助我们查看缓存的使用是否符合预期</li><li>其实除了解决多次离屏渲染的开销，shouldRasterize在另一个场景中也可以使用：如果layer的子结构非常复杂，渲染一次所需时间较长，同样可以打开这个开关，把layer绘制到一块缓存，然后在接下来复用这个结果，这样就不需要每次都重新绘制整个layer树了</li></ul><h2 id="四、GPU离屏渲染常见场景分析及优化"><a href="#四、GPU离屏渲染常见场景分析及优化" class="headerlink" title="四、GPU离屏渲染常见场景分析及优化"></a>四、GPU离屏渲染常见场景分析及优化</h2><h3 id="4-1-关于cornerRadius"><a href="#4-1-关于cornerRadius" class="headerlink" title="4.1 关于cornerRadius"></a>4.1 关于cornerRadius</h3><p>我们经常看到，圆角会触发离屏渲染。但其实这个说法是<strong>不准确的</strong>，因为圆角触发离屏渲染也是<strong>有条件</strong>的。</p><h4 id="4-1-1-cornerRadius的官方释义"><a href="#4-1-1-cornerRadius的官方释义" class="headerlink" title="4.1.1 cornerRadius的官方释义"></a>4.1.1 cornerRadius的官方释义</h4><p>我们先来看看苹果官方文档对于<code>cornerRadius</code>的描述：</p><blockquote><p>Setting the radius to a value greater than <code>0.0</code> causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s <code>contents</code> property; it applies only to the background color and border of the layer. However, setting the <code>masksToBounds</code> property to <code>true</code> causes the content to be clipped to the rounded corners.</p></blockquote><p>设置<code>cornerRadius</code>大于0时，只会为layer的<code>backgroundColor</code>和<code>border</code>设置圆角。</p><p>只有同时设置了<code>layer.masksToBounds</code>为<code>true</code>（对应UIView的<code>clipsToBounds</code>属性）时，才会同时对layer的<code>contents</code>设置圆角。</p><ul><li><p>clipsToBounds：是类View的属性，如果设置为yes，则不显示超出父View的部分</p></li><li><p>masksToBounds：是类CALayer的属性，如果设置为yes，则不显示超出父View layer的部分</p></li></ul><p>如果这时，你认为<code>layer.masksToBounds</code>或者<code>clipsToBounds</code>设置为<code>true</code>就会触发离屏渲染，这是不完全正确的。</p><h4 id="4-1-2-测试用例及现象"><a href="#4-1-2-测试用例及现象" class="headerlink" title="4.1.2 测试用例及现象"></a>4.1.2 测试用例及现象</h4><blockquote><p>测试环境：Xcode 11.5  、iPhone 11 Pro Simulator  、iOS 13.5</p><p>测试手段：模拟器Simulator — Debug — Color Off-screen Rendered</p></blockquote><p>测试用例及结论：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200.0</span>, <span class="number">200.0</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 不设置layer.masksToBounds或者clipsToBounds，其默认值为NO  ———— 不会触发离屏渲染</span></span><br><span class="line">view1.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">view1.layer.borderWidth = <span class="number">2.0</span>;</span><br><span class="line">view1.layer.borderColor = <span class="built_in">UIColor</span>.blackColor.CGColor;</span><br><span class="line">view1.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置layer.masksToBounds或者clipsToBounds为YES  ———— 同样的没有触发离屏渲染</span></span><br><span class="line">view1.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置layer.masksToBounds或者clipsToBounds为YES，同时设置图片 ———— 触发离屏渲染</span></span><br><span class="line">view1.layer.contents = (__bridge <span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pkq&quot;</span>].CGImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 除了如3设置图片。设置layer.masksToBounds或者clipsToBounds为YES，为视图添加一个有颜色、内容或边框等有图像信息（有图像信息还包括在视图或者layer的draw方法中进行绘制等）的子视图也会触发离屏渲染。  ————  触发离屏渲染</span></span><br><span class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100.0</span>, <span class="number">100.0</span>)];</span><br><span class="line"><span class="comment">// 下面3个任何一个属性</span></span><br><span class="line"><span class="comment">// 设置背景色</span></span><br><span class="line">view2.backgroundColor = <span class="built_in">UIColor</span>.blueColor;</span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">view2.layer.contents = (__bridge <span class="keyword">id</span>)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pkq&quot;</span>].CGImage);</span><br><span class="line"><span class="comment">// 设置边框</span></span><br><span class="line">view2.layer.borderWidth = <span class="number">2.0</span>; </span><br><span class="line">view2.layer.borderColor = <span class="built_in">UIColor</span>.blackColor.CGColor;</span><br><span class="line">[view1 addSubview:view2];</span><br></pre></td></tr></table></figure><h4 id="4-1-3-圆角触发离屏渲染的原因"><a href="#4-1-3-圆角触发离屏渲染的原因" class="headerlink" title="4.1.3 圆角触发离屏渲染的原因"></a>4.1.3 圆角触发离屏渲染的原因</h4><p>当我们设置了<code>cornerRadius</code>以及<code>masksToBounds</code>进行圆角+裁剪时，<code>masksToBounds</code>裁剪属性会应用到所有的图层上。</p><p>本来我们从后往前绘制，绘制完一个图层就可以丢弃了。但现在需要依次在 <strong>Offscreen Buffer</strong>中保存，等待圆角+裁剪处理，即引发了 <strong>离屏渲染</strong> 。</p><ul><li><p>背景色、边框、背景色+边框，再加上圆角+裁剪，根据文档说明，因为 <strong>contents = nil</strong> 没有需要裁剪处理的内容，所以<code>masksToBounds</code>设置为<code>YES</code>或者<code>NO</code>都没有影响。</p></li><li><p>一旦我们 <strong>为contents设置了内容</strong> ，无论是图片、绘制内容、有图像信息的子视图等，再加上圆角+裁剪，就会触发离屏渲染。</p><blockquote><p>不一定是直接为contents赋值！</p></blockquote></li></ul><p>原因就如同上面提到的，不得已只能另开一块内存来操作。而如果只是设置cornerRadius（如不需要剪切内容，只需要一个带圆角的边框），或者只是需要裁掉矩形区域以外的内容（虽然也是剪切，但是稍微想一下就可以发现，对于纯矩形而言，实现这个算法似乎并不需要另开内存），并不会触发离屏渲染。</p><h4 id="4-1-4-iOS9及以后的优化"><a href="#4-1-4-iOS9及以后的优化" class="headerlink" title="4.1.4 iOS9及以后的优化"></a>4.1.4 iOS9及以后的优化</h4><p>关于圆角，iOS 9及之后的系统版本，苹果进行了一些优化。</p><ul><li><p><code>layer.contents</code>/<code>imageView.image</code></p><ul><li><p>我们只设置<code>contents</code>或者<code>UIImageView</code>的<code>image</code>，并加上圆角+裁剪，是不会产生离屏渲染的。但如果加上了背景色、边框或其他有图像内容的图层，还是会产生离屏渲染。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200.0</span>, <span class="number">200.0</span>)];</span><br><span class="line"><span class="comment">//设置图片</span></span><br><span class="line">view1.layer.contents = (__bridge <span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;qiyu&quot;</span>].CGImage;</span><br><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">view1.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">view1.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li><li><p>其实这也是可以理解的，因为只有 <strong>单层</strong> 内容需要添加圆角和裁切，所以可以不需要用到离屏渲染技术。</p></li><li><p>但如果加上了背景色、边框或其他有图像内容的图层，就会产生为 <strong>多层</strong> 添加圆角和裁切，所以还是会触发离屏渲染(如2中的第3个例子)。</p></li></ul></li><li><p>UIButton：使用类似于<code>UIButton</code>的视图的时候需要注意：为<code>UIButton</code>设置一个图片，其实会添加一个<code>UIImageView</code>。</p><ul><li><p>为设置了图片的<code>UIButton</code>添加圆角和裁剪，则会触发离屏渲染。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">button.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">button.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li><li><p>为设置了背景色的<code>UIButton</code>添加圆角和裁剪，不会触发离屏渲染。</p></li><li><p>如果改为<code>UIButton</code>中的<code>UIImageView</code>添加圆角和裁剪，则 <strong>不会触发离屏渲染</strong>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">button.imageView.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">button.imageView.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-1-5-实现圆角造成的离屏渲染优化"><a href="#4-1-5-实现圆角造成的离屏渲染优化" class="headerlink" title="4.1.5 实现圆角造成的离屏渲染优化"></a>4.1.5 实现圆角造成的离屏渲染优化</h4><p>方案一：使用切图</p><p>方案二：贝塞尔曲线绘制圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageWithCornerRadius:(<span class="built_in">CGFloat</span>)radius ofSize:(<span class="built_in">CGSize</span>)size&#123;</span><br><span class="line">    <span class="comment">/* 当前UIImage的可见绘制区域 */</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="number">0.</span>f,<span class="number">0.</span>f,size&#125;;</span><br><span class="line">    <span class="comment">/* 创建基于位图的上下文 */</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</span><br><span class="line">    <span class="comment">/* 在当前位图上下文添加圆角绘制路径 */</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</span><br><span class="line">    <span class="comment">/* 当前绘制路径和原绘制路径相交得到最终裁剪绘制路径 */</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br><span class="line">    <span class="comment">/* 绘制 */</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    <span class="comment">/* 取得裁剪后的image */</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">/* 关闭当前位图上下文 */</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：CAShapeLayer + UIBezierPath 绘制圆角来实现UITableViewCell圆角并绘制边框颜色（这种方式比直接设置圆角方式好，但也会触发离屏渲染）,代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *maskLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    maskLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *borderLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    borderLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height);</span><br><span class="line">    borderLayer.lineWidth = <span class="number">1.</span>f;</span><br><span class="line">    borderLayer.strokeColor = COLOR_LINE.CGColor;</span><br><span class="line">    borderLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height) cornerRadius:kRadiusCard];</span><br><span class="line">    maskLayer.path = bezierPath.CGPath;</span><br><span class="line">    borderLayer.path = bezierPath.CGPath;</span><br><span class="line"></span><br><span class="line">    [cell.contentView.layer insertSublayer:borderLayer atIndex:<span class="number">0</span>];</span><br><span class="line">    [cell.layer setMask:maskLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于方案三的解释：</p><ul><li>CAShapeLayer继承于CALayer，因而可以使用CALayer的所有属性值；</li><li>CAShapeLayer需要和贝塞尔曲线配合使用才能够实现效果；</li><li>CAShapeLayer(属于CoreAnimation)与贝塞尔曲线配合使用可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出想要的图形；</li><li>CAShapeLayer动画渲染是驱动GPU，而view的drawRect方法使用CPU渲染，相比其效率更高，消耗内存更少。</li></ul><p>总的来说使用CAShapeLayer的内存消耗少，渲染速度快。</p></blockquote><p>关于剪切圆角的性能优化，根据场景不同有几个方案可供选择，非常推荐阅读<a href="https://link.zhihu.com/?target=https://texturegroup.org/docs/corner-rounding.html">AsyncDisplayKit中的一篇文档</a>。</p><p>ASDK中对于如何选择圆角渲染策略的流程图，非常实用：</p><img src="/images/iosrender/07.jpg" alt="01" style="zoom:80%;" /><p>YYKit是开发中经常用的三方库，YYImage对图片圆角的处理方法是值得推荐的，附上实现源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageByRoundCornerRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">                              corners:(<span class="built_in">UIRectCorner</span>)corners</span><br><span class="line">                          borderWidth:(<span class="built_in">CGFloat</span>)borderWidth</span><br><span class="line">                          borderColor:(<span class="built_in">UIColor</span> *)borderColor</span><br><span class="line">                       borderLineJoin:(<span class="built_in">CGLineJoin</span>)borderLineJoin &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (corners != <span class="built_in">UIRectCornerAllCorners</span>) &#123;</span><br><span class="line">        <span class="built_in">UIRectCorner</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerTopLeft</span>) tmp |= <span class="built_in">UIRectCornerBottomLeft</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerTopRight</span>) tmp |= <span class="built_in">UIRectCornerBottomRight</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerBottomLeft</span>) tmp |= <span class="built_in">UIRectCornerTopLeft</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerBottomRight</span>) tmp |= <span class="built_in">UIRectCornerTopRight</span>;</span><br><span class="line">        corners = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="keyword">self</span>.scale);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, -rect.size.height);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> minSize = MIN(<span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="keyword">if</span> (borderWidth &lt; minSize / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectInset</span>(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">        [path addClip];</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, rect, <span class="keyword">self</span>.CGImage);</span><br><span class="line">        <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (borderColor &amp;&amp; borderWidth &lt; minSize / <span class="number">2</span> &amp;&amp; borderWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> strokeInset = (floor(borderWidth * <span class="keyword">self</span>.scale) + <span class="number">0.5</span>) / <span class="keyword">self</span>.scale;</span><br><span class="line">        <span class="built_in">CGRect</span> strokeRect = <span class="built_in">CGRectInset</span>(rect, strokeInset, strokeInset);</span><br><span class="line">        <span class="built_in">CGFloat</span> strokeRadius = radius &gt; <span class="keyword">self</span>.scale / <span class="number">2</span> ? radius - <span class="keyword">self</span>.scale / <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(strokeRadius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        path.lineWidth = borderWidth;</span><br><span class="line">        path.lineJoinStyle = borderLineJoin;</span><br><span class="line">        [borderColor setStroke];</span><br><span class="line">        [path stroke];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-shadow"><a href="#4-2-shadow" class="headerlink" title="4.2 shadow"></a>4.2 shadow</h3><p>一般情况下是用以下代码，但是不要用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *imageViewLayer = cell.imageView.layer;</span><br><span class="line">imageViewLayer.shadowColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">imageViewLayer.shadowOpacity = <span class="number">1.0</span>;</span><br><span class="line">imageViewLayer.shadowRadius = <span class="number">2.0</span>;</span><br><span class="line">imageViewLayer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>请用更高效的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageViewLayer.shadowPath = <span class="built_in">CGPathCreateWithRect</span>(imageRect, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>其原因在于，虽然layer本身是一块矩形区域，但是阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。</p><p>Core Animation 必须要知道阴影的形状和位置。但矛盾在于<strong>时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢</strong>？这样一来又只能另外申请一块内存，把本体内容都先画好，再查看其 alpha channel 来找出阴影的位置，渲染阴影到frame buffer，最后把内容画上去（实际情况有些复杂）。</p><p>不过如果我们能够预先告诉CoreAnimation（通过shadowPath属性）阴影的几何形状，那么阴影当然可以先被独立渲染出来，不需要依赖layer本体，也就不再需要离屏渲染了。</p><p>阴影会作用在所有子layer所组成的形状上，那就只能等全部子layer画完才能得到：</p><img src="/images/iosrender/08.jpg" alt="01" style="zoom:70%;" /><h3 id="4-3-group-opacity"><a href="#4-3-group-opacity" class="headerlink" title="4.3 group opacity"></a>4.3 group opacity</h3><p>设置了组透明度为 YES，并且透明度不为 1 的layer (layer.allowsGroupOpacity/ layer.opacity)。</p><p>其实从名字就可以猜到，alpha并不是分别应用在每一层之上，而是只有到整个layer树画完之后，再统一加上alpha，最后和底下其他layer的像素进行组合。显然也无法通过一次遍历就得到最终结果。将一对蓝色和红色layer叠在一起，然后在父layer上设置opacity=0.5，并复制一份在旁边作对比。左边关闭group opacity，右边保持默认（从iOS7开始，如果没有显式指定，group opacity会默认打开），然后打开offscreen rendering的调试，我们会发现右边的那一组确实是离屏渲染了。</p><p>同样的两个view，右边打开group opacity（默认行为）的被标记为Offscreen rendering：</p><img src="/images/iosrender/09.jpg" alt="01" style="zoom:60%;" /><h3 id="4-4-mask"><a href="#4-4-mask" class="headerlink" title="4.4 mask"></a>4.4 mask</h3><p>我们知道mask是应用在layer和其所有子layer的组合之上的，而且可能带有透明度，那么其实和group opacity的原理类似，不得不在离屏渲染中完成。</p><p>WWDC中苹果的解释，mask需要遍历至少三次：</p><img src="/images/iosrender/10.jpg" alt="01" style="zoom:95%;" /><h3 id="4-5-UIBlurEffect"><a href="#4-5-UIBlurEffect" class="headerlink" title="4.5 UIBlurEffect"></a>4.5 UIBlurEffect</h3><p>同样无法通过一次遍历完成，其原理在WWDC中提到：</p><img src="/images/iosrender/11.jpg" alt="01" style="zoom:90%;" /><h3 id="4-6-shouldRasterize"><a href="#4-6-shouldRasterize" class="headerlink" title="4.6 shouldRasterize"></a>4.6 shouldRasterize</h3><p>shouldRasterize的主旨在于<strong>降低性能损失，但总是至少会触发一次离屏渲染</strong>。</p><p>shouldRasterize光栅化开启后，会将layer作为位图保存到OffscreenBuffer中。下次直接与其他内容进行混合。这样下次需要再次渲染的时候，就可以直接拿来使用了。</p><h3 id="4-7-其他"><a href="#4-7-其他" class="headerlink" title="4.7 其他"></a>4.7 其他</h3><p>其他还有一些，类似绘制了文字的 layer (UILabel, CATextLayer, Core Text 等)、allowsEdgeAntialiasing等等也可能会触发离屏渲染，原理也都是类似：如果你无法仅仅使用frame buffer来画出最终结果，那就只能另开一块内存空间来储存中间结果。这些原理并不神秘。</p><h2 id="五、CPU”离屏渲染“？"><a href="#五、CPU”离屏渲染“？" class="headerlink" title="五、CPU”离屏渲染“？"></a>五、CPU”离屏渲染“？</h2><h3 id="5-1-CPU渲染"><a href="#5-1-CPU渲染" class="headerlink" title="5.1 CPU渲染"></a>5.1 CPU渲染</h3><p>特殊的离屏渲染：</p><p>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么是不是还有另一种特殊的“离屏渲染”方式： CPU渲染？</p><p>大家知道，如果我们在UIView中重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地完成，渲染得到的bitmap最后再交由GPU用于显示。（就算函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作）。</p><blockquote><p>备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程</p></blockquote><p>对于类似上面这种“新开一块CGContext来画图“的操作，有很多文章和视频也称之为“离屏渲染”（因为像素数据是暂时存入了CGContext，而不是直接到了frame buffer）。进一步来说，其实所有CPU进行的光栅化操作（如文字渲染、图片解码），都无法直接绘制到由GPU掌管的frame buffer，只能暂时先放在另一块内存之中，说起来都属于“离屏渲染”。</p><p>自然我们会认为，因为CPU不擅长做这件事，所以我们需要尽量避免它，就误以为这就是需要避免离屏渲染的原因。但是<a href="https://link.zhihu.com/?target=https://lobste.rs/s/ckm4uw/performance_minded_take_on_ios_design%23c_itdkfh">根据苹果工程师的说法</a>，CPU渲染并非真正意义上的离屏渲染。另一个证据是，如果你的view实现了drawRect，此时打开Xcode调试的“Color offscreen rendered yellow”开关，你会发现这片区域不会被标记为黄色，说明Xcode并不认为这属于离屏渲染。</p><p>其实通过CPU渲染就是俗称的“软件渲染”，而<strong>真正的离屏渲染发生在GPU</strong>。</p><h3 id="5-2-什么时候需要CPU渲染"><a href="#5-2-什么时候需要CPU渲染" class="headerlink" title="5.2 什么时候需要CPU渲染"></a>5.2 什么时候需要CPU渲染</h3><p>渲染性能的调优，其实始终是在做一件事：<strong>平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作</strong>。</p><p>平衡CPU和GPU的负载：</p><img src="/images/iosrender/13.jpg" alt="01" style="zoom:80%;" /><p>绝大多数情况下，得益于GPU针对图形处理的优化，我们都会倾向于让GPU来完成渲染任务，而给CPU留出足够时间处理各种各样复杂的App逻辑。为此Core Animation做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如layer composition，设置backgroundColor等等）。</p><p>但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片（ImageIO）渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。</p><p>来自WWDC18 session 221，可以看到Core Text基于Core Graphics：</p><img src="/images/iosrender/14.jpg" alt="01" style="zoom:80%;" /><p>一个典型的例子是，我们经常会使用CoreGraphics给图片加上圆角（将图片中圆角以外的部分渲染成透明）。整个过程全部是由CPU完成的。这样一来既然我们已经得到了想要的效果，就不需要再另外给图片容器设置cornerRadius。另一个好处是，我们可以灵活地控制裁剪和缓存的时机，巧妙避开CPU和GPU最繁忙的时段，达到平滑性能波动的目的。</p><p>这里有几个需要注意的点：</p><ul><li>渲染不是CPU的强项，调用CoreGraphics会消耗其相当一部分计算时间，并且我们也不愿意因此阻塞用户操作，因此一般来说CPU渲染都在后台线程完成（这也是AsyncDisplayKit的主要思想），然后再回到主线程上，把渲染结果传回CoreAnimation。这样一来，多线程间数据同步会增加一定的复杂度</li><li>同样因为CPU渲染速度不够快，因此只适合渲染静态的元素，如文字、图片（想象一下没有硬件加速的视频解码，性能惨不忍睹）</li><li>作为渲染结果的bitmap数据量较大（形式上一般为解码后的UIImage），消耗内存较多，所以应该在使用完及时释放，并在需要的时候重新生成，否则很容易导致OOM</li><li>如果你选择使用CPU来做渲染，那么就没有理由再触发GPU的离屏渲染了，否则会同时存在两块内容相同的内存，而且CPU和GPU都会比较辛苦</li><li>一定要使用Instruments的不同工具来测试性能，而不是仅凭猜测来做决定</li></ul><h2 id="六、优化实践"><a href="#六、优化实践" class="headerlink" title="六、优化实践"></a>六、优化实践</h2><p>由于在iOS10之后，系统的设计风格慢慢从扁平化转变成圆角卡片，很多APP的设计风格也随之发生变化，加入了大量圆角与阴影效果，如果在处理上稍有不慎，就很容易触发离屏渲染。为此我们采取了以下一些措施：</p><ul><li>大量应用AsyncDisplayKit(Texture)作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看<a href="https://link.zhihu.com/?target=https://medium.com/jike-engineering/asyncdisplaykit%E4%BB%8B%E7%BB%8D-%E4%B8%80-6b871d29e005">之前的一些介绍</a></li><li>对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角</li><li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果</li><li>对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做</li><li>对于所有的阴影，使用shadowPath来规避离屏渲染</li><li>对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存</li><li>对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</li></ul><h2 id="七、总结与资料推荐"><a href="#七、总结与资料推荐" class="headerlink" title="七、总结与资料推荐"></a>七、总结与资料推荐</h2><p>离屏渲染牵涉了很多Core Animation、GPU和图形学等等方面的知识，在实践中也非常考验一个工程师排查问题的基本功、经验和判断能力——如果在不恰当的时候打开了shouldRasterize，只会弄巧成拙。</p><p>从一个更广阔的视角看，离屏渲染也仅仅是渲染性能优化中的一部分，而能否保证UI性能过关，将会直接影响到用户日常的操作体验。渲染技术作为客户端工程师的关键技术能力之一，值得持续研究。</p><p>推荐资料：</p><ul><li><a href="https://link.zhihu.com/?target=https://lobste.rs/s/ckm4uw/performance_minded_take_on_ios_design%23c_itdkfh">Andy Matuschak关于离屏渲染的解释</a></li><li><a href="https://link.zhihu.com/?target=https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen">Objc.io: Moving Pixels onto the Screen</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render">Mastering Offscreen Render</a></li><li>WWDC 2011 421 Core Animation Essentials</li><li>WWDC 2011 121 Understanding UIKit Rendering</li><li>WWDC 2014 419 Advanced Graphics and Animations for iOS Apps</li><li>WWDC 2010 135 Advanced Performance Optimization on iPhone OS Part 1</li><li><a href="https://link.zhihu.com/?target=https://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC">《Core Animation: Advanced Techniques》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72653360&quot;&gt;关于iOS离屏渲染的深入研究&lt;/a&gt;、&lt;a href=&quot;https://juejin.cn/post/6846687603316490254&quot;</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core-Animation(三) - 渲染流程探究及性能分析</title>
    <link href="https://tenloy.github.io/2021/09/11/core-animation03.html"/>
    <id>https://tenloy.github.io/2021/09/11/core-animation03.html</id>
    <published>2021-09-11T20:04:46.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://joakimliu.github.io/2019/03/02/wwdc-2014-419/">原文</a>，摘自 <a href="https://developer.apple.com/videos/play/wwdc2014/419/">Advanced Graphics and Animations for iOS Apps</a> （WWDC14 419，关于UIKit和Core Animation基础的session在早年的WWDC中比较多），字幕在 <a href="https://asciiwwdc.com/2014/sessions/419">transcripts</a> ，当然也可以下载 <a href="https://wwdc.io/">WWDC</a> 在桌面上看带有字幕的视频。这篇挺实用的，讲解了渲染的基本流程，以及怎么发现并解决渲染性能的问题。</p></blockquote><h2 id="一、iOS渲染架构总览"><a href="#一、iOS渲染架构总览" class="headerlink" title="一、iOS渲染架构总览"></a>一、iOS渲染架构总览</h2><h3 id="1-1-简易架构图"><a href="#1-1-简易架构图" class="headerlink" title="1.1 简易架构图"></a>1.1 简易架构图</h3><p>iOS APP 图形图像渲染的基本流程：</p><img src="/images/iosrender/15.png" alt="01" style="zoom:55%;" /><ol><li><p>CPU(Central Processing Unit，中央处理器)：完成对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）。</p></li><li><p>GPU(Graphics Processing Unit，图形处理器)：GPU拿到CPU计算好的显示内容，完成纹理的渲染， 渲染完成后将渲染结果放入帧缓冲区。</p></li><li><p>帧缓冲区（Frame Buffer）（双缓冲机制，不再赘述）</p><p>正常情况下，在当前屏幕显示的内容，由 GPU 渲染完成后放到当前屏幕的帧缓存区，不需要额外的渲染空间。我们知道 iPhone 的屏幕刷新率是 60Hz，也就是刷新一帧的时间是 16.67 ms， 每隔这段时间视频控制器就会去读一次缓存区的内容来显示。 </p><p>假如 GPU 遇到性能瓶颈，导致无法在一帧内更新渲染结果到帧缓存区，那么从缓存区读到的会是上一帧的内容，导致帧率降低界面卡顿。</p></li><li><p>视频控制器读取 Frame Buffer 中的数据 （视频控制器一般由显卡驱动程序或DirectX(微软公司创建的一系列专为多媒体以及游戏开发的应用程序接口)中自带，是芯片与显示平台的数据接口）</p><p>视频控制器会按照 VSync信号(开始新的帧缓冲的读取)、HSync信号(开始帧缓冲新的一行的读取)读取前帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p>GPU开始会绘制后缓存里的画面，然后视频控制器读取完前缓存的画面， 就会去读取后缓存里的画面。</p><p>然后GPU再去绘制前缓存里的画面，即两者交替进行。</p></li></ol><p>将上图更细化一点：</p><img src="/images/iosrender/01.png" alt="01" style="zoom:90%;" /><img src="/images/iosrender/16.png" alt="01" style="zoom:70%;" /><p><a href="https://github.com/Tenloy/iOS-Core-Animation-Advanced-Techniques/blob/master/12-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">(原文)</a>关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。</p><p>总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因，我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）</p><p>大多数动画性能优化都是关于智能利用GPU和CPU，使得它们都不会超出负荷。于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。</p><h3 id="1-2-CoreAnimation渲染架构图"><a href="#1-2-CoreAnimation渲染架构图" class="headerlink" title="1.2 CoreAnimation渲染架构图"></a>1.2 CoreAnimation渲染架构图</h3><p>我们知道 Core Animation 是 iOS 上可用的图形渲染和动画基础结构，它将大部分实际绘图工作交给图形硬件以加速渲染(摘自官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>)。 我们先来看看 Core Animation 渲染的管道图：</p><img src="/images/iosrender/02.jpg" alt="01" style="zoom:92%;" /><p>我们看到：</p><ul><li>在应用程序(Application)和渲染服务器(Render Server)中都有 Core Animation 。我们也可以把iOS下的Core Animation可以理解为一个<strong>复合引擎，主要职责包含：渲染、构建和实现动画</strong>。</li><li>可以看到，渲染工作并不是在应用程序里(尽管它有 Core Animation)完成的，这一层主要是CPU在操作。它只是将视图层级(view hierarchy)打包(encode)提交给<strong>渲染服务器</strong>(<strong>一个单独的进程，也有 Core Animation</strong>)， 视图层级才会被渲染。(“The view hierarchy is then rendered with Core Animation with OpenGL or metal, that’s the GPU.”) </li><li>CPU和GPU双方同处于一个流水线中，协作完成整个渲染工作。</li></ul><p>大致流程如下：</p><ul><li>Handle Events：它代表 touch, 即一切要更新视图层级的事情；</li><li>Commit Transaction：编码打包视图层级，发送给渲染服务器；</li><li>Decode：渲染服务器第一件事就是解码这些视图层级；</li><li>Draw Calls：渲染服务器必须等待下一次重新同步，以便等待缓冲区从 它们实现渲染的显示器 返回，然后最终开始为 GPU 绘制，这里就是 OpenGL or metal 。（<strong>以前是call OpenGL ES，现在慢慢转到了Metal</strong>）。</li><li>Render：一旦视图资源可用， GPU 就开始它的渲染工作，希望在下个重新同步完成，因为要交换缓冲区给用户。</li><li>Display：显示给用户看。</li></ul><p>在上述情况下，这些不同的步骤总共跨越三帧。在最后一个步骤 display 后，是可以平行操作的，在 Draw call 的时候可以处理下一个 handler event 和 Commit Transaction 。如下图所示</p><img src="/images/caa/pipeline2.png" alt="Animation Pipeline2" style="zoom:90%;" /><h2 id="二、渲染步骤详解"><a href="#二、渲染步骤详解" class="headerlink" title="二、渲染步骤详解"></a>二、渲染步骤详解</h2><h3 id="2-1-APP-—-Commit-Transaction"><a href="#2-1-APP-—-Commit-Transaction" class="headerlink" title="2.1 APP — Commit Transaction"></a>2.1 APP — Commit Transaction</h3><h4 id="2-1-1-事务提交的4个阶段"><a href="#2-1-1-事务提交的4个阶段" class="headerlink" title="2.1.1 事务提交的4个阶段"></a>2.1.1 事务提交的4个阶段</h4><p>先聚焦 Commit transaction（事务是什么就不再赘述了）这个阶段，因为这是开发者接触最多的，主要有四个阶段，如下图所示：</p><img src="/images/caa/commit-transaction.png" alt="Commit Transaction" style="zoom:95%;" /><h5 id="1-布局-Layout"><a href="#1-布局-Layout" class="headerlink" title="1. 布局(Layout)"></a>1. 布局(Layout)</h5><p>Set up the views. 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段</p><ul><li>重载的 <code>layoutSubviews</code> 方法会在这个阶段被调用；</li><li>视图的创建，被添加到视图层级上；</li><li>计算内容，比如：字符串，用来布局 label ；</li><li>这个阶段通常是 CPU 或者 I/O 限制，所以做的事情要轻量</li></ul><h5 id="2-显示-Display"><a href="#2-显示-Display" class="headerlink" title="2. 显示(Display)"></a>2. 显示(Display)</h5><p>Draw the views. 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>方法的调用路径。</p><ul><li>主要是 core graphics 用来绘制，调用重载的 <code>drawRect:</code> 方法来绘制，绘制字符串；这个阶段通常是 CPU 或者内存限制，所以减少 core graphics 的工作</li></ul><h5 id="3-准备-Prepare"><a href="#3-准备-Prepare" class="headerlink" title="3. 准备(Prepare)"></a>3. 准备(Prepare)</h5><p>Additional Core Animation work. 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</p><ul><li>主要是图片解码和图片转换。所以，图片大小和格式都是被 GPU 支持的，不然转换是发生在 CPU 上的，最好是 index bitmap ，可以免去转换</li></ul><h5 id="4-提交-Commit"><a href="#4-提交-Commit" class="headerlink" title="4. 提交(Commit)"></a>4. 提交(Commit)</h5><p>Package up the layers and send them to the render server.  这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</p><ul><li>视图层级不要太复杂，尽量扁平，因为这里的打包是循环处理的</li></ul><p>以上这些仅仅阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。</p><h4 id="2-1-2-Animation的渲染"><a href="#2-1-2-Animation的渲染" class="headerlink" title="2.1.2  Animation的渲染"></a>2.1.2  Animation的渲染</h4><p>动画分为三个阶段，前面两个阶段在应用程序，最后一个在渲染服务器，如下图所示</p><p><img src="/images/caa/animation-process.png" alt="Animation Process"></p><p>跟<strong>视图的不同的</strong>是，这里提交的不是视图层级，而是动画。这是出于效率的原因，方便我们可以继续更新动画，因为如果提交视图层级的话，动画一更新，又得返回到应用程序提交新的视图层级，很耗时。</p><h3 id="2-2-Render-Server"><a href="#2-2-Render-Server" class="headerlink" title="2.2 Render Server"></a>2.2 Render Server</h3><h4 id="2-2-1-渲染服务"><a href="#2-2-1-渲染服务" class="headerlink" title="2.2.1 渲染服务"></a>2.2.1 渲染服务</h4><p>Core Animation处在iOS的核心地位：应用内和应用间都会用到它。一个简单的动画可能同步显示多个app的内容，例如当在iPad上多个程序之间使用手势切换，会使得多个程序同时显示在屏幕上。在一个特定的应用中用代码实现它是没有意义的，因为在iOS中不可能实现这种效果（App都是被沙箱管理，不能访问别的视图）。</p><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的*渲染服务(Render Server)*。在iOS5和之前的版本是 SpringBoard 进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做<code>BackBoard</code>。</p><p>一旦 commit Transition 打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<em>渲染树</em>的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p><ul><li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li><li>在屏幕上渲染可见的三角形</li></ul><p>加上前面事务提交时的<strong>布局</strong>、<strong>显示</strong>、<strong>准备</strong>、<strong>提交</strong>，一共有六个阶段（在动画过程中，最后两个阶段不停地重复）。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。</p><p>这并不是个问题，因为在布局和显示阶段，你可以决定哪些由CPU执行，哪些交给GPU去做。那么该如何判断呢？</p><h4 id="2-2-2-GPU相关的操作"><a href="#2-2-2-GPU相关的操作" class="headerlink" title="2.2.2 GPU相关的操作"></a>2.2.2 GPU相关的操作</h4><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非你想绕开Core Animation并编写你自己的OpenGL着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。</p><p>宽泛的说，大多数<code>CALayer</code>的属性都是用GPU来绘制。比如如果你设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个<code>contents</code>属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。</p><p>但是有一些事情会降低（基于GPU）图层绘制效率，比如：</p><ul><li><strong>太多的几何结构</strong>：这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。<ul><li>现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。</li><li>但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见后续“CPU相关操作”）。</li></ul></li><li><strong>重绘</strong>：主要由重叠的半透明图层引起。<ul><li>GPU的<em>填充比率</em>（用颜色填充像素的比率）是有限的，所以需要避免<em>重绘</em>（每一帧用相同的像素填充多次）的发生。</li><li>在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并仍然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。</li></ul></li><li><strong>离屏绘制</strong>：这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。<ul><li>离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。</li><li>对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。</li></ul></li><li><strong>过大的图片</strong>：如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</li></ul><h4 id="2-2-3-CPU相关的操作"><a href="#2-2-3-CPU相关的操作" class="headerlink" title="2.2.3 CPU相关的操作"></a>2.2.3 CPU相关的操作</h4><p>大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p><p>以下CPU的操作都会延迟动画的开始时间：</p><ul><li><strong>布局计算</strong>：如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。</li><li><strong>视图惰性加载</strong>：iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。</li><li><strong>Core Graphics绘制</strong>：如果对视图实现了<code>-drawRect:</code>方法，或者<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</li><li><strong>解压图片</strong>PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（<strong>通常等同于图片宽 x 长 x 4个字节</strong>）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用<code>UIImageView</code>）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li></ul><p>当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树中的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU每一帧的渲染，即使这些事情不是你的应用程序可控的。</p><h4 id="2-2-4-IO相关操作"><a href="#2-2-4-IO相关操作" class="headerlink" title="2.2.4 IO相关操作"></a>2.2.4 IO相关操作</h4><p>还有一项没涉及的就是IO相关工作。上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从闪存（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。</p><p>IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和投机加载（提前加载当前不需要的资源，但是之后可能需要用到）。</p><h3 id="2-3-OpenGL-ES"><a href="#2-3-OpenGL-ES" class="headerlink" title="2.3 OpenGL ES"></a>2.3 OpenGL ES</h3><h4 id="2-3-1-OpenGL是什么？"><a href="#2-3-1-OpenGL是什么？" class="headerlink" title="2.3.1 OpenGL是什么？"></a>2.3.1 OpenGL是什么？</h4><p>从上面的渲染架构图可以看到，OpenGL位于硬件驱动层和软件层之间，</p><p>OpenGL（Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近350个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。</p><p>OpenGL 是一套图形图像开发规范，OpenGL架构评审委员会（ARB）维护。其实现一般由显示设备(GPU/显卡)厂商提供，而且非常依赖于该厂商提供的硬件。OpenGL的高效实现（利用图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。</p><ul><li>OpenGL规范描述了绘制2D和3D图形的抽象API。尽管这些API可以完全通过软件实现，但它是为大部分或者全部使用硬件加速而设计的。</li><li>OpenGL不仅语言无关，而且平台无关。</li><li>OpenGL是一个不断进化的API。每个版本的细节由开发组织(Khronos Group)的成员一致决定，包括显卡厂商、操作系统设计人员以及类似Mozilla和谷歌的一般性科技公司。</li><li>除了核心API要求的功能之外，GPU供应商可以通过扩展的形式提供额外功能。扩展可能会引入新功能和新常量，并且可能放松或取消现有的OpenGL函数的限制。然后一个扩展就分成两部分发布：包含扩展函数原型的头文件和作为厂商的设备驱动。</li></ul><p>OpenGL ES（OpenGL for Embedded Systems）是三维图形应用程序接口OpenGL的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p><h4 id="2-3-2-OpenGL用来干嘛？"><a href="#2-3-2-OpenGL用来干嘛？" class="headerlink" title="2.3.2 OpenGL用来干嘛？"></a>2.3.2 OpenGL用来干嘛？</h4><p>从操作粒度来理解它，它是基于GPU硬件驱动层的API，它直接操作的对象是显示屏幕上的每个像素点(Pixel)。我们可以利用这套API来操作屏幕上的每一个像素点的排列组合，颜色，深度等等来实现各种各样的图形图像。</p><p>总而言之，它是用来操作GPU显示图形图像的API。</p><h4 id="2-3-3-OpenGL-—-状态机"><a href="#2-3-3-OpenGL-—-状态机" class="headerlink" title="2.3.3 OpenGL — 状态机"></a>2.3.3 OpenGL — 状态机</h4><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文(Contex)来渲染。</p><p>OpenGL会保持状态，除非我们调用OpenGL函数来改变它。就像一个时间点的快照一样，除非对这个OpenGL的上下文进行修改，否则它呈现的内容是不会改变的。</p><p>每个OpenGL的上下文都是独立，我们在不同上下文做的工作是互不影响的，在实际操作过程中要注意是否在同一个上下文中。</p><h3 id="2-4-GPU-—-基于图块的渲染"><a href="#2-4-GPU-—-基于图块的渲染" class="headerlink" title="2.4 GPU — 基于图块的渲染"></a>2.4 GPU — 基于图块的渲染</h3><p>先来了解渲染的一些概念(Rendering Concepts)。</p><blockquote><p>tile 图块，瓦片； tiling 铺瓦于，铺以瓷砖</p></blockquote><p>“first tile based rendering is how all GPUs work.”  基于图块的渲染(Tile Based Rendering)是所有 GPU 的工作方式。</p><img src="/images/caa/tile-based-rendering.png" alt="Tile Based Rendering" style="zoom:85%;" /><ul><li>屏幕被分割成 N*N 个像素块，就像之前讲 <a href="http://joakimliu.github.io/2019/02/24/wwdc-2011-129/">Points vs Pixels</a> 中的例子一样；</li><li>每块都适应 Soc 缓存。(Soc: 苹果 A9 是一款由苹果公司设计的系统芯片(Soc)。可以理解为系统芯片。 维基百科上面写的，这个芯片是 2015.9.9 才首次发布)。</li><li>几何体被分割成图块桶(tile buckets)，这一步发生在 tiler stage (后面有提到)。这里举了 iPhone icon 的例子，从上图中可以看到，这个 icon 被分割成多个很小的三角形，使得这些三角形块可以单独的渲染，分割这样做的思路可以决定哪一块显示，哪一块渲染。 因为每个像素只有一个像素着色器，所以混合的话还是有问题的，涉及到覆盖绘制。</li><li>几何体提交后，光栅化才开始。(所以光栅化能提升性能，因为几何体都提交了，下次渲染的时候就可以省略这一步。)</li></ul><h4 id="2-4-1-Rendering-pass"><a href="#2-4-1-Rendering-pass" class="headerlink" title="2.4.1 Rendering pass"></a>2.4.1 Rendering pass</h4><blockquote><p>Pass:  v. 通过; 传递; 变化; 放弃    n. 经过; 通行证; <strong>通道</strong>; <strong>流程</strong>; <strong>阶段</strong>。此处应是译作阶段</p></blockquote><img src="/images/caa/rendering-pass.png" alt="Rendering pass" style="zoom:90%;" /><p>如上图所示，我们假设视图层级已经被提交到渲染服务器，并且 Core Animation 已经解码它，现在需要用 OpenGL 或者 metal 去渲染了，文章讲师举例是用的 OpenGL (所以这里的 Slide 比前面讲 Core Animation Pipeline 的 Slide 在 Render Server 这一栏，多了 OpenGL 在里面)。具体流程如下：</p><ul><li>GPU 收到 Command Buffer ；</li><li>顶点着色器(Vertex Shader)开始运行，思路就是先将所有的顶点转换到屏幕空间，然后平铺处理，平铺成<strong>瓷砖桶</strong>(<strong>tile bucket</strong>)的几何图形。<ul><li>这里分两步走，先顶点处理然后平铺，统称为 <strong>Tiler stage</strong>，在 Instrument 的 OpenGL ES tiler utilization 能看到这一步。</li><li>这一步的产出被写入 Parameter Buffer，下一阶段不会马上启动。相反，会等待，直到 <ul><li>a. 处理完所有的几何体，并且都位于 Parameter Buffer 中；或者 </li><li>b. Parameter buffer 已满（满了的话，必须刷新它）。</li></ul></li></ul></li><li>像素着色器(Pixel Shader)处理，这一步被称为 <strong>Renderer stage</strong>，产出被写入 Render Buffer 。(在 Instrument 的 OpenGL ES renderer utilization 能看到这一步。)</li></ul><h4 id="2-4-2-示例：渲染遮罩"><a href="#2-4-2-示例：渲染遮罩" class="headerlink" title="2.4.2 示例：渲染遮罩"></a>2.4.2 示例：渲染遮罩</h4><p>举了一个渲染遮罩的例子，步骤如下图：</p><img src="/images/caa/masking-rendering-pass.png" alt="" style="zoom:55%;" /><p>分三步走，两步渲染，一步合成。</p><ol><li>将遮罩层(相机 icon)渲染到纹理(texture)上；</li><li>将内容层渲染到纹理上；</li><li>将遮罩添加到内容纹理上。</li></ol><h2 id="三、图形相关概念补充"><a href="#三、图形相关概念补充" class="headerlink" title="三、图形相关概念补充"></a>三、图形相关概念补充</h2><h3 id="3-1-显卡与GPU"><a href="#3-1-显卡与GPU" class="headerlink" title="3.1 显卡与GPU"></a>3.1 显卡与GPU</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E5%8D%A1">显卡</a>是个人电脑最基本组成部分之一，用途是将计算机系统所需要的显示信息进行转换驱动电脑，并提供逐行或隔行扫描信号，控制电脑的正确显示，是连接显示器和个人电脑主板的重要 组件 ，是“人机对话”的重要设备之一。 </p><ul><li>显卡是插在主板上的扩展槽里的(现在一般是PCI-E插槽，此前还有AGP、PCI、ISA等插槽)。它主要负责把主机向显示器发出的显示信号转化为一般电器信号，使得显示器能明白个人电脑 在让它做什么。</li><li>显卡的主要芯片叫“显示芯片”（Video chipset，也叫GPU或VPU，图形处理器或视觉处理器），是显卡的主要处理单元。</li><li>显卡上也有和电脑存储器相似的存储器，称为 “显示存储器”，简称显存。 </li><li>早期的显卡只是单纯意义的显卡，只起到信号转换的作用；目前的显卡一般都带有3D画面运算和图形加速功能 ，所以也叫做“图形加速卡”或“3D加速卡”。</li></ul><p>显卡通常由总线接口、PCB板、显示芯片、显示存储器、RAMDAC、VGA BIOS、VGA端子及其他外围组件构成，现在的显卡大多使用VGA、DVI、HDMI接口或DisplayPort接口。</p><h3 id="3-2-驱动"><a href="#3-2-驱动" class="headerlink" title="3.2 驱动"></a>3.2 驱动</h3><p>设备驱动程序(device driver，简称驱动程序driver)，是一个允许高端电脑软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线(bus)或其它沟通子系统(subsystem)与硬件形成连接的机制，这样的机制使得硬件设备上的资料交换成为可能。</p><h3 id="3-3-硬件加速"><a href="#3-3-硬件加速" class="headerlink" title="3.3 硬件加速"></a>3.3 硬件加速</h3><p>硬件加速是指在计算机中通过把计算量非常大的工作分配给专门的硬件来处理以减轻中央处理器的工作量之技术。尤其是在图像处理中这个技术经常被使用。</p><p>例如，雷神之锤3是第一个必须要求硬件加速的3D游戏。Google Chrome浏览器也设置了“硬件加速”功能，用户可根据需求开启或关闭此功能。</p><h3 id="3-4-图元"><a href="#3-4-图元" class="headerlink" title="3.4 图元"></a>3.4 图元</h3><p>任何一个图形表达都是由若干不同的点、线、面图案或相同的图案循环组合而成的。这些点、线、面图案即为基本图形元素。</p><p>不同的图形系统有不同的图形元素：</p><ul><li>GKS标准规定了6种基本图形元素，即折线、多点记号、填充区、正文、像素阵列和GDP（广义绘图元素）。</li><li>CGM标准除6种基本图形元素外，附加了圆弧、椭圆弧、样条曲线等等图形元素</li></ul><p>基本图形元素所具有的特征有：颜色、亮度、线型、线宽、字符大小、字符间距、字体、图元检索名以及用户定义的其他特征等</p><h3 id="3-5-纹理"><a href="#3-5-纹理" class="headerlink" title="3.5 纹理"></a>3.5 纹理</h3><h4 id="3-5-1-纹理"><a href="#3-5-1-纹理" class="headerlink" title="3.5.1 纹理"></a>3.5.1 纹理</h4><p>计算机图形学中的纹理既包括通常意义上物体表面的纹理即使物体表面呈现凹凸不平的沟纹，同时也包括在物体的光滑表面上的彩色图案，通常我们更多地称之为花纹。</p><ul><li>对于花纹而言，就是在物体表面绘出彩色花纹或图案，产生了纹理后的物体表面依然光滑如故。</li><li>对于沟纹而言，实际上也是要在表面绘出彩色花纹或图案，同时要求视觉上给人以凹凸不平感即可。凹凸不平的图案一般是不规则的。</li></ul><p>在计算机图形学中，这两种类型的纹理的生成方法完全一致，这也是计算机图形学中把他们统称为纹理的原因所在。</p><h4 id="3-5-2-纹理映射"><a href="#3-5-2-纹理映射" class="headerlink" title="3.5.2 纹理映射"></a>3.5.2 纹理映射</h4><p>纹理映射就是在物体的表面上绘制图案。</p><ul><li>Direct3D中的纹理：表示物体表面细节的一幅或几幅二维图形，也称纹理贴图（texture mapping）当把纹理按照特定的方式映射到物体表面上的时候能使物体看上去更加真实。</li><li>Photoshop中的纹理：Photoshop使用“纹理”滤镜赋予图像一种深度或物质的外观，或添加一种有机外观。如龟裂缝、颗粒、马赛克拼贴、拼缀图、染色玻璃、纹理化等。</li><li>Word中也有设置纹理填充。</li></ul><h4 id="3-5-3-材质、贴图、纹理"><a href="#3-5-3-材质、贴图、纹理" class="headerlink" title="3.5.3 材质、贴图、纹理"></a>3.5.3 材质、贴图、纹理</h4><p>整个 CG 领域中这三个概念都是差不多的，在一般的实践中，大致上的层级关系是：</p><blockquote><p>材质 Material 包含 贴图 Map，Map 包含 纹理 Texture。</p><p>日常口语勘误：有人习惯用贴图(Map)指代纹理(Texture)。导致有些场景下贴图就是贴图，有些场景下贴图是在指纹理。这个需要个人区分清楚</p></blockquote><ul><li><p>纹理是最基本的数据输入单位，游戏领域基本上都用的是位图。此外还有程序化生成的纹理 Procedural Texture。</p></li><li><p>贴图的英语 Map 其实包含了另一层含义就是“映射”。其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。</p></li><li><p>材质是一个数据集，主要功能就是给渲染器提供数据和光照算法。</p><ul><li><p>贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比方说 Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。</p></li><li><p>另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。</p><p>光照与物体表面的相互作用可以通过将一些数学公式应用于基于per pixel（区别于基于顶点）的着色，从而模拟出真实生活中的各种材质效果。比如浮雕效果，波浪效果，油漆效果等。</p></li></ul></li></ul><h3 id="3-6-着色器"><a href="#3-6-着色器" class="headerlink" title="3.6 着色器"></a>3.6 着色器</h3><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h4><p>计算机图形学领域中，<strong>着色器(shader)是一种计算机程序</strong>，原本用于进行图像的浓淡处理（计算图像中的光照、亮度、颜色等），但近来，它也被用于完成很多不同领域的工作，比如处理CG特效、进行与浓淡处理无关的视频后期处理、甚至用于一些与计算机图形学无关的其它领域。更多介绍见<a href="https://zh.wikipedia.org/wiki/%E7%9D%80%E8%89%B2%E5%99%A8">WIKI</a>。</p><p>功能：构成最终图像的像素、顶点、纹理，它们的位置、色相、饱和度、亮度、对比度也都可以利用着色器中定义的算法进行动态调整。调用着色器的外部程序，也可以利用它向着色器提供的外部变量、纹理来修改这些着色器中的参数。</p><p>常用的着色器有以下三种：</p><ul><li>二维着色器<ul><li>像素着色器</li></ul></li><li>三维着色器</li></ul><h4 id="3-6-2-二维着色器"><a href="#3-6-2-二维着色器" class="headerlink" title="3.6.2 二维着色器"></a>3.6.2 二维着色器</h4><p>二维着色器处理的是数字图像，也叫纹理，着色器可以修改它们的像素。二维着色器也可以参与三维图形的渲染。目前只有“像素着色器”一种二维着色器。</p><h5 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h5><p>像素着色器(pixel shader，也叫片段着色器fragment shader)，用于计算“片段”的颜色和其它属性，此处的“片段”通常是指单独的像素。</p><ul><li>最简单的像素着色器只有输出颜色值；复杂的像素着色器可以有多个输入输出。</li><li>像素着色器既可以永远输出同一个颜色，也可以考虑光照、做凹凸贴图、生成阴影和高光，还可以实现半透明等效果。</li><li>像素着色器还可以修改片段的深度，也可以为多个渲染目标输出多个颜色。</li></ul><p>三维图形学中，单独一个像素着色器并不能实现非常复杂的效果，因为它只能处理单独的像素，没有场景中其它几何体的信息。不过，像素着色器有屏幕坐标信息，如果将屏幕上的内容作为纹理传入，它就可以对当前像素附近的像素进行采样。利用这种方法，可以实现大量二维后期特效，例如模糊和边缘检测。</p><p>像素着色器还可以处理管线中间过程中的任何二维图像，包括精灵和纹理。因此，如果需要在栅格化后进行后期处理，像素着色器是唯一选择。</p><h4 id="3-6-3-三维着色器"><a href="#3-6-3-三维着色器" class="headerlink" title="3.6.3 三维着色器"></a>3.6.3 三维着色器</h4><p>三维着色器处理的是三维模型或者其它几何体，可以访问用来绘制模型的颜色和纹理。</p><ul><li>顶点着色器是最早的三维着色器；</li><li>几何着色器可以在着色器中生成新的顶点；</li><li>细分曲面着色器（tessellation shader）则可以向一组顶点中添加细节。</li></ul><p>顶点着色器处理每个顶点，将顶点的空间位置投影在屏幕上，即计算顶点的二维坐标。同时，它也负责顶点的深度缓冲（Z-Buffer）的计算。顶点着色器可以掌控顶点的位置、颜色和纹理坐标等属性，但无法生成新的顶点。</p><p>顶点着色器的输出传递到流水线的下一步。如果有之后定义了几何着色器，则几何着色器会处理顶点着色器的输出数据，否则，光栅化器继续流水线任务。</p><p>几何着色器可以从多边形网格中增删顶点。它能够执行对CPU来说过于繁重的生成几何结构和增加模型细节的工作。几何着色器的输出连接光栅化器的输入。</p><h4 id="3-6-4-简化图形流水线"><a href="#3-6-4-简化图形流水线" class="headerlink" title="3.6.4 简化图形流水线"></a>3.6.4 简化图形流水线</h4><p>这些类型的着色器终究会用在GPU的流水线中，<strong>简述</strong>它们是如何被安排在流水线中的，简化图形管线/流水线(pipeline)：</p><ul><li>中央处理器（CPU）发送指令（编译的着色器程序）和几何数据到位于显卡内的图形处理器（GPU）。</li><li>顶点着色器执行几何变换和光照计算。</li><li>若几何着色器位于图形处理器内，它便会修改一些几何信息。</li><li>计算后的几何模型被三角化（分割为三角形）。</li><li>三角形被映射为2×2的像素块。</li></ul><h2 id="四、OpenGL-Pipeline"><a href="#四、OpenGL-Pipeline" class="headerlink" title="四、OpenGL Pipeline"></a>四、OpenGL Pipeline</h2><h3 id="图形渲染管线图"><a href="#图形渲染管线图" class="headerlink" title="图形渲染管线图"></a>图形渲染管线图</h3><p>Contex为我们提供OpenGL的运行环境，而具体的操作则是在OpenGL的渲染管线中进行的。</p><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的<strong>图形渲染管线</strong>(<strong>Graphics Pipeline</strong>)管理的。图形渲染管线可以被划分为两个主要部分：</p><ul><li>第一部分把你的3D坐标转换为2D坐标，</li><li>第二部分是把2D坐标转变为实际的有颜色的像素。</li></ul><blockquote><p>Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></blockquote><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段：</p><ul><li>每个阶段将会把前一个阶段的输出作为输入。</li><li>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<strong>着色器</strong>(<strong>Shader</strong>)。</li><li>着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li></ul><blockquote><p>着色器(Shader)是运行在GPU上的小程序。这些小程序为完成图形渲染管线的某个特定部分的功能而运行。</p></blockquote><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的。</p><p>下图一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p><img src="/images/iosrender/pipeline.png" alt="" style="zoom:90%;" /><p>(几何着色器是可选的，通常使用它默认的着色器就行了)。</p><img src="/images/iosrender/17.jpg" alt="" style="zoom:80%;" /><p>如图所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。概括性地解释一下渲染管线的每个部分：</p><h3 id="4-1-顶点数组"><a href="#4-1-顶点数组" class="headerlink" title="4.1 顶点数组"></a>4.1 顶点数组</h3><p>传递一个顶点数组作为图形渲染管线的输入。这个数组叫做顶点数据(Vertex Data)。一个顶点(Vertex)是一个3D坐标的数据的集合。(简单起见，可以假定每个顶点只由一个3D位置和一些颜色值组成)</p><h3 id="4-2-顶点着色器-Vertex-Shader"><a href="#4-2-顶点着色器-Vertex-Shader" class="headerlink" title="4.2 顶点着色器(Vertex Shader)"></a>4.2 顶点着色器(Vertex Shader)</h3><p>它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为OpenGL的内部坐标信息，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>顶点着色器负责坐标和图形的描述。在OpenGL中有三种基本的图形<strong>点、线、三角形</strong>，只能通过这三种基本图形去描述一个图形。其中在OpenGL中我们的显示区域位于x,y均为[-1,1]之内的空间。</p><img src="/images/iosrender/18.jpg" alt="" style="zoom:90%;" /><ul><li><strong>点</strong>：点存在于三维空间，坐标用（x,y,z）表示。</li><li><strong>线</strong>：由两个三维空间中的点组成。</li><li><strong>三角形</strong>：由三个三维空间的点组成。</li></ul><p><strong>输出：顶点</strong>。</p><h3 id="4-3-图元装配阶段-Primitive-Assembly"><a href="#4-3-图元装配阶段-Primitive-Assembly" class="headerlink" title="4.3 图元装配阶段(Primitive Assembly)"></a>4.3 图元装配阶段(Primitive Assembly)</h3><p>将上阶段输出的 — 所有顶点作为输入，进行组装和裁剪，将所有的点装配成指定图元的形状，更准确的说是将所有3D的图元转化为屏幕上2D的图元。</p><img src="/images/iosrender/19.jpg" alt="" style="zoom:90%;" /><p><strong>输出：图元</strong>。（图元由顶点组成）</p><h3 id="4-4-几何着色器-Geometry-Shader"><a href="#4-4-几何着色器-Geometry-Shader" class="headerlink" title="4.4 几何着色器(Geometry Shader)"></a>4.4 几何着色器(Geometry Shader)</h3><p>将上阶段输出的 — 图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。</p><p>(几何着色器是可选的，通常使用它默认的着色器就行了)</p><p><strong>输出：新的图元</strong>。</p><p>到这一步我们已经为OpenGL描述了一个图形的样子，但是要转换为图像还需要颜色信息。↓</p><h3 id="4-5-光栅化阶段-Rasterization-Stage"><a href="#4-5-光栅化阶段-Rasterization-Stage" class="headerlink" title="4.5 光栅化阶段(Rasterization Stage)"></a>4.5 光栅化阶段(Rasterization Stage)</h3><p>将上阶段输出的 — 图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段(Fragment)，即实现通过插值运算将连续的值用一个个像素片段表示出来。</p><img src="/images/iosrender/20.png" alt="" style="zoom:70%;" /><p>在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p><strong>输出：片元/片段</strong>(<strong>Fragment</strong>)</p><ul><li>光栅化：将图转化为一个个栅格组成的图像，每个栅格此处又称为片元/片段(Fragment)，OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</li><li>片元其实已经很接近像素了，但是它还不是像素。片元包含了比RGBA更多的信息，比如可能有深度值，法线，纹理坐标等等信息。</li><li>片元需要在通过一些测试（如深度测试）后才会最终成为像素。可能会有多个片元竞争同一个像素，而这些测试会最终筛选出一个合适的片元，丢弃法线和纹理坐标等不需要的信息后，成为像素。</li></ul><h3 id="4-6-片段着色器-Fragment-Shader"><a href="#4-6-片段着色器-Fragment-Shader" class="headerlink" title="4.6 片段着色器(Fragment Shader)"></a>4.6 片段着色器(Fragment Shader)</h3><p>到了这一步我们已经有了一个个的像素片段（Fragament），我们在这个阶段给它涂上颜色值就可以变成一个完整的像素点。包括位置，颜色，纹理坐标等信息。</p><p>片段着色器的主要目的就是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。</p><p>通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><blockquote><p>同时我们可以编写Fragament Shader的脚本来实现对每个像素颜色的变换来达到一些效果，如纹理贴图，光照，环境光，阴影。</p></blockquote><p><strong>输出：一个像素的最终颜色</strong>。像素 — 影像的最小的完整取样。最终呈现在屏幕上的包含RGBA值的图像最小单元就是像素了。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段。</p><h3 id="4-7-Alpha测试和混合-Blending-阶段"><a href="#4-7-Alpha测试和混合-Blending-阶段" class="headerlink" title="4.7 Alpha测试和混合(Blending)阶段"></a>4.7 Alpha测试和混合(Blending)阶段</h3><p>主要是检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。</p><p>这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>有的书中，称这个阶段也称<strong>片段测试阶段</strong>，对每个像素点进行测试保证这些像素点是正确可用的，最后在输入到帧缓冲（Frambuffer）中。</p><img src="/images/iosrender/21.jpg" alt="" style="zoom:90%;" /><blockquote><p>混合：当图像叠加时，上方图层和下方图层的像素进行混合，从而得到另外一种图像效果。</p></blockquote><blockquote><p>抖动(Dither)是在数字信号处理领域的中一项用于降低量化误差的技术。透过在较低比特中加入噪声，借此破坏谐波的排序，使谐波的影响受到压制，并减少量化误差在低频的影响。抖动常用于音视频处理，且是CD压制过程的最后一步。经过抖动处理过的音乐，将听起来更柔顺、背景更黑；而经过抖动处理过的影像，也会更加地柔顺耐看。</p><p>抖动最重要的用途之一是将灰阶图像转为黑白。透过使用抖动算法，可以令黑白图案的黑点密度接近原图案的大致灰度。</p><p>在数字图像处理中，经常使用抖动混合几种颜色，在颜色数量受限时产生出新的“颜色深度”。</p></blockquote><h3 id="4-8-渲染帧缓存-Renderbuffer"><a href="#4-8-渲染帧缓存-Renderbuffer" class="headerlink" title="4.8 渲染帧缓存(Renderbuffer)"></a>4.8 渲染帧缓存(Renderbuffer)</h3><h4 id="4-8-1-帧缓存-Framebuffer）"><a href="#4-8-1-帧缓存-Framebuffer）" class="headerlink" title="4.8.1 帧缓存 (Framebuffer）"></a>4.8.1 帧缓存 (Framebuffer）</h4><p>经过上述处理流程，我们想要看到的图形图像数据最后都会存储到<strong>帧缓存区（Framebuffer）</strong>中。我们可以同时存在很多帧缓存（Framebuffer），并且可以通过OpenGL让GPU把渲染结果存储到任意数量的帧缓存中（这里引申出一个离屏渲染的工作概念）。</p><p>但是，只有将内容绘制到视窗体提供的<strong>帧缓存（Renderbuffer）</strong>中，才能将内容输出到显示设备。在实现上渲染缓存（Renderbuffer）是直接跟屏幕映射的，可以绕开CPU进行工作。</p><img src="/images/iosrender/22.jpg" alt="" style="zoom:90%;" /><h4 id="4-8-2-帧缓存的渲染"><a href="#4-8-2-帧缓存的渲染" class="headerlink" title="4.8.2 帧缓存的渲染"></a>4.8.2 帧缓存的渲染</h4><p>基本工作原理是存在两个缓存（前缓存和后缓存），当屏幕的刷新同步信号到达时让系统将后缓存交换到前缓存区上。</p><p>这个刷新的时间是由系统决定的，比如在iOS中屏幕刷新率是60fps即每16.75ms会发生一次前后缓存的交换。我们只需要准备好后缓存的数据提供给系统就能进行屏幕刷新渲染了。</p><img src="/images/iosrender/23.png" alt="" style="zoom:90%;" /><h3 id="4-8-小结"><a href="#4-8-小结" class="headerlink" title="4.8 小结"></a>4.8 小结</h3><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p><p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p><p>以上就是OpenGL整体工作流程。首先OpenGL是用来操作GPU进行图形图像渲染工作的，它的操作粒度可以到每个像素点，同时它是直接操作GPU硬件工作的。而之后的工作核心（2D图形图像渲染）基本是集中在对顶点着色器和片段着色器的脚本实现上（酷炫的滤镜效果和动画效果）。</p><h2 id="五、案例1-—-UIBlurEffect的渲染过程"><a href="#五、案例1-—-UIBlurEffect的渲染过程" class="headerlink" title="五、案例1 — UIBlurEffect的渲染过程"></a>五、案例1 — UIBlurEffect的渲染过程</h2><p>UIBlurEffect 是 iOS8 新出的用来实现模糊效果的类。</p><h3 id="5-1-渲染步骤"><a href="#5-1-渲染步骤" class="headerlink" title="5.1 渲染步骤"></a>5.1 渲染步骤</h3><p>它的渲染过程如下：</p><img src="/images/caa/blureffect-rendering-pass.png" alt="" style="zoom:55%;" /><ol><li>渲染 layer 的 content，在这种情况下，它只是一个简单的图像，因此如果我们涉及 UI ，可能需要更长的时间；</li><li>截获 layer 的 content，进行缩放，它实际上相当快。这几乎是不变的成本；</li><li>对缩放内容进行横向模糊，也非常快，因为是小区域。</li><li>对缩放内容进行纵向模糊，同上</li><li>合成操作，合并所有模糊结果。</li></ol><h3 id="5-2-每一步中的三事件"><a href="#5-2-每一步中的三事件" class="headerlink" title="5.2 每一步中的三事件"></a>5.2 每一步中的三事件</h3><p>再看下图，聚焦在一帧。我们可以看到每个渲染步骤所需的时间，每个渲染步骤都牵扯到了下面要提到的三个事件(tile/render/VBlank interrupt)。</p><img src="/images/caa/blureffect1.png" alt="UIBlurEffect1" style="zoom:90%;" /><p>我们可以看到有三行，每一行代表一个事件</p><ul><li>tile activity</li><li>render activity</li><li>VBlank interrupt, “and the last row I put in the VBlank interrupt and we can actually see what our frame boundaries are.” (我们实际上可以看到我们的帧边界是什么)</li></ul><h3 id="5-3-步骤间隙"><a href="#5-3-步骤间隙" class="headerlink" title="5.3 步骤间隙"></a>5.3 步骤间隙</h3><p>我们注意到下图，每个步骤之间的间隙，用橘色标记了</p><img src="/images/caa/blureffect2.png" alt="UIBlurEffect2" style="zoom:90%;" /><p>5 个步骤中间有 4 个间隙，之所以存在，是因为这是发生在 GPU 上切换所花的时间。在空闲时间，每个步骤所花费的时间大概在 0.1<code>~~</code>0.2ms, 所以总共 0.4<code>~~</code>0.8ms, 所以这个是 16.67ms 的一个重要组成部分。</p><p>还列举了不同设备间的耗时，有一种设备某个 Dark style 下的时间是 18.15ms, 超过 16.67ms, 所以不可能在 60 hert 渲染完成。所以 Apple 在这些设备上不支持 blur 。</p><p>UIBlurEffect 有三种 style: Extra light, Light, Dark ，它们消耗的资源各不相同， Dark 最少， Extra light 最多。</p><h2 id="六、案例2-—-UIVibrancyEffect的渲染过程"><a href="#六、案例2-—-UIVibrancyEffect的渲染过程" class="headerlink" title="六、案例2 — UIVibrancyEffect的渲染过程"></a>六、案例2 — UIVibrancyEffect的渲染过程</h2><p>UIVibrancyEffect 是在模糊之上使用的效果，它可以<strong>确保内容突出，而不会被模糊</strong>。它的渲染过程如下：</p><img src="/images/caa/vibrancyeffect-rendering-pass.png" alt="" style="zoom:64%;" /><p>比 UIBlurEffect 多了两个步骤，最后一个步骤 filter 是最昂贵的，所以作用区域越小越好，千万别作用到全屏上。</p><img src="/images/caa/vibrancyeffect1.png" alt="" style="zoom:90%;" /><p>所以也会比 UIBlurEffect 多两个间隙，所以总共 0.6~1.2ms.</p><img src="/images/caa/vibrancyeffect2.png" alt="UIVibrancyEffect2" style="zoom:90%;" /><h2 id="七、分析工具-Profiling-tools"><a href="#七、分析工具-Profiling-tools" class="headerlink" title="七、分析工具(Profiling tools)"></a>七、分析工具(Profiling tools)</h2><h3 id="7-1-性能关注点"><a href="#7-1-性能关注点" class="headerlink" title="7.1 性能关注点"></a>7.1 性能关注点</h3><p>性能调查要考虑以下点</p><img src="/images/caa/performance-inverstigation-mindset.png" alt="" style="zoom:90%;" /><ul><li>What is the frame rate? Goal is always 60 fps. <ul><li>检查工具： Instrument — Core Animation template / OpenGL ES driver template</li></ul></li><li>CPU or GPU bound? Lower utilization is desired and saves battery. <ul><li>更少的 CPU 或者 GPU 利用率，让电池更持久。</li><li>检查工具： Instrument — OpenGL ES driver template</li></ul></li><li>Any unnecessary CPU rendering? GPU is desirable but know when CPU makes sense. <ul><li>得知道渲染什么和怎么渲染， <code>drawRect</code> 方法尽量少用，减少让 CPU 的工作，让 GPU 做更多的渲染。</li><li>检查工具： Instrument — Core Animation template / OpenGL ES driver template</li></ul></li><li>Too many offscreen passes? Fewer is better. <ul><li>前面说 UIBlurEffect 的时候有说到，橘色的间隙就是用在 GPU 切换时间，每个间隙大概 0.1~0.2ms 。 离屏渲染也会出现这样的情况，因为它必须进行切换，所以得减少。因为前面有提到，我们减少 CPU 或者 GPU 的使用时间。</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Too much blending? less is better. <ul><li>GPU 处理 blending 合成的时候，操作昂贵，消耗性能</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Any strange image formats or sizes? Avoida on-the-fly conversions or resizing. <ul><li>会转给 CPU 去处理，增加 CPU 的负担</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Any expensive views or effects? Understand the cost of what is in use. <ul><li>避免昂贵的效果，例如 Blur 和 Vibrancy ，得去考量。</li><li>检查工具： Xcode view debugging</li></ul></li><li>Anything unexpected in the view hierarchy? Know the actual view hierarchy. <ul><li>添加和移除要匹配。</li><li>检查工具： Xcode view debugging</li></ul></li></ul><h3 id="7-2-检查工具"><a href="#7-2-检查工具" class="headerlink" title="7.2 检查工具"></a>7.2 检查工具</h3><p>上面每个例子后面都有提到一个检测工具，这里来讲讲相应检测工具的作用。请注意一点，在开始挖掘代码以试图找出正在发生的事情之前，这总是一个很好的起点(<strong>先看大概发生什么问题，再深入研究代码</strong>)。</p><h4 id="7-2-1-Core-Animation-template"><a href="#7-2-1-Core-Animation-template" class="headerlink" title="7.2.1 Core Animation template"></a>7.2.1 Core Animation template</h4><ul><li>看 fps</li><li>color blended layers, green 表示不透明， red 代表需要去 blend 混合。 增加 GPU 的工作。 绿多红少，是理想中的状态。</li><li>color hit screens and misses red, 展示如何使用或滥用 CALayer’rasterize 属性，没命中缓存就是红色。第一次启动会有很多红色，因为必须在它被缓存之前渲染一次，后面就没有了，因为缓存了。</li><li>color copied images, 如果是 GPU 不支持的图片就会让 CPU 去转换(在 commit phase)，增加了 CPU 的工作。 显示为蓝绿色(cyan)就表示让 CPU 去转换，影响滚动体验。 所以 size and color/image format 最好提前在后台处理好，不要阻塞主线程。</li><li>color misaligned images, 黄色表示需要缩放，紫色表示像素没对齐。</li><li>color offscreen-rendered yellow, 黄色代表离屏渲染。 nav bar 和 tool bar 是黄色，因为这些图层的模糊实际上模糊了它背后的内容(前面 blur 有讲过)。</li><li>color OpenGL fast path blue, 蓝色是好事，由显示硬件去 blend ，这样就会减少 GPU 的工作。</li><li>flash updated regions, 正在更新的部分为黄色。 理想状况下，黄色区域越少越好。它意味着 CPU 和 GPU 的工作都减少了。</li></ul><h4 id="6-2-2-OpenGL-ES-driver-template"><a href="#6-2-2-OpenGL-ES-driver-template" class="headerlink" title="6.2.2 OpenGL ES driver template"></a>6.2.2 OpenGL ES driver template</h4><ul><li>device utilization, which will show you how much the GPU is in use during the trace. (使用率越少越好，这里举例的是 30% vs 70%(心中的理想值))</li><li>render and tiler utilization, correspond to the renderer and tiler phases.</li><li>CoreAnimationFramesPerSecond, what the actual frame rate is that we’re seeing.</li></ul><h4 id="6-2-3-Time-Profiler-template"><a href="#6-2-3-Time-Profiler-template" class="headerlink" title="6.2.3 Time Profiler template"></a>6.2.3 Time Profiler template</h4><ul><li>看调用栈耗时，看 CPU 在干什么；</li></ul><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_5">Learn OpenGL</a> (已fork，备丢)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://joakimliu.github.io/2019/03/02/wwdc-2014-419/&quot;&gt;原文&lt;/a&gt;，摘自 &lt;a href=&quot;https://developer.apple.com/videos/play/w</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation(二) - 隐式动画、CATransaction与CAAction</title>
    <link href="https://tenloy.github.io/2021/09/09/core-animation02.html"/>
    <id>https://tenloy.github.io/2021/09/09/core-animation02.html</id>
    <published>2021-09-09T19:36:17.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques/blob/master/7-%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB/%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB.md">原文地址</a> 译自《iOS Core Animation Advanced Techniques》</p></blockquote><p>动画是Core Animation库一个非常显著的特性。这一章我们来看看它是怎么工作的。具体来说，我们先来讨论框架自动实现的<em>隐式动画</em>（除非你明确禁用了这个功能）。</p><h2 id="一、可动画、事务与RunLoop"><a href="#一、可动画、事务与RunLoop" class="headerlink" title="一、可动画、事务与RunLoop"></a>一、可动画、事务与RunLoop</h2><h3 id="1-1-可动画的图层属性"><a href="#1-1-可动画的图层属性" class="headerlink" title="1.1 可动画的图层属性"></a>1.1 可动画的图层属性</h3><p>Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。你并不需要在Core Animation中手动打开动画，但是你需要明确地关闭它，否则它会一直存在。</p><p>当你改变<code>CALayer</code>一个可做动画的属性时，这个改变并不会立刻在屏幕上体现出来。相反，该属性会从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作 —— 这就是可动画的(隐式动画)。</p><blockquote><p>可动画的(animatable)：当改变时，会触发一个从旧的值过渡到新值的简单动画；</p></blockquote><p><strong>几乎所有的图层的属性都是隐性可动画的。</strong>你可以在文档中看到它们的简介是以 ‘animatable’ 结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，甚至也囊括了像 isHidden 和 doubleSided 这样的布尔值。 像 paths 这样的属性也是 animatable 的，但是它不支持隐式动画。</p><h3 id="1-2-CATransaction"><a href="#1-2-CATransaction" class="headerlink" title="1.2 CATransaction"></a>1.2 CATransaction</h3><p><a href="https://developer.apple.com/documentation/quartzcore/catransaction">CATransaction</a>是Core Animation中的事务类，负责批量的把多个对图层树(layer-tree)的修改作为一个原子更新到渲染树。</p><ul><li>事务是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可动画的图层属性都不会立刻发生变化，而是当事务一旦<em>提交</em>的时候开始用一个动画过渡到新值。</li><li>事务是通过<code>CATransaction</code>类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。<code>CATransaction</code>没有属性或者实例方法，并且也不能用<code>+alloc</code>和<code>-init</code>方法创建它。而是用类方法<code>+begin</code>和<code>+commit</code>分别来入栈或者出栈。</li><li>支持嵌套事务。</li></ul><p>在iOS中的图层中，<strong>对图层树的每次修改都必须是事务的一部分</strong>。任何可动画的图层属性，发生改变产生的动画都会被添加到栈顶的事务，你可以通过<code>+setAnimationDuration:</code>方法设置当前事务的动画时间，或者通过<code>+animationDuration</code>方法来获取时长值（默认0.25秒）。</p><p>Core Animation支持两种类型的事务：隐式事务和显式事务。</p><ul><li><p><strong>当图层树被没有显式事务的线程修改时，隐式事务会自动创建，并在线程的 runloop 下一次迭代时自动提交</strong>。</p><ul><li>即Core Animation会监测修改，然后在每个<em>runloop</em>周期中自动开始一次新的事务（runloop是iOS负责收集用户输入，处理未完成的定时器或者网络事件，最终重新绘制屏幕的东西），即使你不显式地使用<code>[CATransaction begin]</code>开始一次事务，在一个特定runloop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。</li></ul></li><li><p>当应用程序在修改图层树之前向 CATransaction 类发送 begin() 消息，然后向 CATransaction 类发送 commit() 消息时，就会发生显式事务。</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CATransaction</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和提交事物（Creating and Committing Transactions）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前线程创建一个新的事物(Transaction)，可嵌套 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)begin;   </span><br><span class="line"><span class="comment">/* 提交当前事物中的所有改动，如果事物不存在将会出现异常 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)commit;  </span><br><span class="line"><span class="comment">/* 提交任意的隐式动画，将被延迟一直到嵌套的显示事物被完成 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)flush;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写动画时间（Overriding Animation Duration and Timing）</span></span><br><span class="line"><span class="comment">/* 获取动画时间，默认0.25秒 */</span></span><br><span class="line">+ (<span class="built_in">CFTimeInterval</span>)animationDuration;</span><br><span class="line"><span class="comment">/* 设置动画时间 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationDuration:(<span class="built_in">CFTimeInterval</span>)dur;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认nil，设置和获取CAMediaTimingFunction（速度控制函数） */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">CAMediaTimingFunction</span> *)animationTimingFunction;</span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationTimingFunction:(<span class="keyword">nullable</span> <span class="built_in">CAMediaTimingFunction</span> *)function;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止属性更改而触发的action(隐式动画)（Temporarily Disabling Property Animations）</span></span><br><span class="line"><span class="comment">/* 每条线程事物，都有disableActions属性的存取器，即设置和获取方法，默认为false，允许隐式动画 */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)disableActions;</span><br><span class="line">+ (<span class="keyword">void</span>)setDisableActions:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调闭包（Getting and Setting Completion Block Objects）</span></span><br><span class="line"><span class="comment">/* 动画完成之后被调用 */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionBlock;</span><br><span class="line">+ (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理并发（Managing Concurrency）</span></span><br><span class="line"><span class="comment">/* 两个方法用于动画事物的加锁与解锁 在多线程动画中，保证修改属性的安全 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)lock;</span><br><span class="line">+ (<span class="keyword">void</span>)unlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置和获取事物属性（Getting and Setting Transaction Properties）</span></span><br><span class="line"><span class="comment">/* 支持的事务属性包括:&quot;animationDuration&quot;， &quot;animationTimingFunction&quot;， &quot;completionBlock&quot;， &quot;disableActions&quot;。*/</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">+ (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="二、隐式动画"><a href="#二、隐式动画" class="headerlink" title="二、隐式动画"></a>二、隐式动画</h2><h3 id="2-1-演示"><a href="#2-1-演示" class="headerlink" title="2.1 演示"></a>2.1 演示</h3><p>隐式动画看起来这太棒了，似乎不太真实，我们用一个demo来解释一下：首先和第一章“图层树”一样创建一个蓝色的方块，然后添加一个按钮，随机改变它的颜色。点击按钮，你会发现图层的颜色平滑过渡到一个新值，而不是跳变。代码及显示效果如下：</p><p>清单7.1 随机改变图层颜色</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create sublayer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">    <span class="comment">//add it to our view</span></span><br><span class="line">    [<span class="keyword">self</span>.layerView.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;                                                                                       ￼</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><img src="/images/caa/7.1.jpg" alt="" style="zoom:60%;" /><p>这其实就是所谓的<em>隐式</em>动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。Core Animaiton同样支持<em>显式</em>动画，下章详细说明。</p><p>当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前<em>事务</em>的设置，动画类型取决于*图层行为(action)*。</p><p>我们当然可以用当前事务的<code>+setAnimationDuration:</code>方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</p><p>修改后的代码见清单7.2。运行程序，你会发现色块颜色比之前变得更慢了。</p><p>清单7.2 使用<code>CATransaction</code>控制动画时间</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    ￼<span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-UIView动画的底层事务"><a href="#2-2-UIView动画的底层事务" class="headerlink" title="2.2 UIView动画的底层事务"></a>2.2 UIView动画的底层事务</h3><p>如果你用过<code>UIView</code>的动画方法做过一些动画效果，那么应该对这个模式不陌生。<code>UIView</code>有两个方法，<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>，和<code>CATransaction</code>的<code>+begin</code>和<code>+commit</code>方法类似。实际上在<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>之间所有视图或者图层属性的改变而做的动画都是由于设置了<code>CATransaction</code>的原因。</p><p>在iOS4中，苹果对UIView添加了一种基于block的动画方法：<code>+animateWithDuration:animations:</code>。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。</p><p><code>CATransaction</code>的<code>+begin</code>和<code>+commit</code>方法在<code>+animateWithDuration:animations:</code>内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对<code>+begin</code>和<code>+commit</code>匹配的失误造成的风险。</p><h3 id="2-3-事务完成block"><a href="#2-3-事务完成block" class="headerlink" title="2.3 事务完成block"></a>2.3 事务完成block</h3><p>基于<code>UIView</code>的block的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。我们来调整上个例子，在颜色变化结束之后执行一些操作。我们来添加一个完成之后的block，用来在每次颜色变化结束之后切换到另一个旋转90的动画。</p><p>示例：在颜色动画完成之后添加一个回调，比如再做一次旋转</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//add the spin animation on completion</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;</span><br><span class="line">        <span class="comment">//rotate the layer 90 degrees</span></span><br><span class="line">        <span class="built_in">CGAffineTransform</span> transform = <span class="keyword">self</span>.colorLayer.affineTransform;</span><br><span class="line">        transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.affineTransform = transform;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    <span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/caa/7.2.jpg" alt="" style="zoom:60%;" /><p>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p><h2 id="三、图层行为-action"><a href="#三、图层行为-action" class="headerlink" title="三、图层行为(action)"></a>三、图层行为(action)</h2><h3 id="3-1-UIView所关联layer禁止隐式动画"><a href="#3-1-UIView所关联layer禁止隐式动画" class="headerlink" title="3.1 UIView所关联layer禁止隐式动画"></a>3.1 UIView所关联layer禁止隐式动画</h3><p>在 iOS 中也有一些单独的 layer，比如 <code>AVCaptureVideoPreviewLayer</code> 和 <code>CAShapeLayer</code>，它们不需要附加到 view 上就可以在屏幕上显示内容。两种情况下其实都是 layer 在起决定作用。</p><p>当然了，附加到 view 上的 layer 和单独的 layer 在行为上还是稍有不同的。</p><ul><li><p>基本上你改变一个单独的 layer 的任何属性的时候，都会触发一个从旧的值过渡到新值的简单动画（这就是所谓的可动画 <code>animatable</code>）。</p></li><li><p>然而，如果你改变的是 view 中 layer 的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有 layer，但是当 layer 附加在 view 上时，它的默认的隐式动画的 layer 行为就不起作用了。</p></li></ul><p>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对<em>为什么</em>会这样做出了一个解释：</p><blockquote><p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p></blockquote><p>这正是我们所看到的行为；当一个属性在动画 block 之外被改变时，没有动画，但是当属性在动画 block 内被改变时，就带上了动画。对于这是_如何_发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了 view 和 layer 之间是如何协同工作和被精心设计的。</p><p>示例：现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。</p><p>下面代码是对上面代码的一点修改，移除了<code>colorLayer</code>，并且直接设置<code>layerView</code>关联图层的背景色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//set the color of our layerView backing layer directly</span></span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    <span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。发生了什么呢？隐式动画好像被<code>UIView</code>关联图层给禁用了。</p><p>UIKit建立在Core Animation之上，而Core Animation默认对<code>CALayer</code>的所有属性（可动画的属性）做动画，但是<code>UIView</code>把它关联的图层的这个特性关闭了。</p><p>那么隐式动画是如何被UIKit禁用掉呢？为了更好说明这一点，我们需要知道隐式动画是如何实现的。</p><h3 id="3-2-CAAction"><a href="#3-2-CAAction" class="headerlink" title="3.2 CAAction"></a>3.2 CAAction</h3><p>无论何时，一个可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中把这种改变属性时<code>CALayer</code>自动应用的动画称为action，或者 <code>CAAction</code>，中文译作动作，也称行为（<strong>以下统称 行为</strong>）。</p><p><strong>行为通常是一个被Core Animation<em>隐式</em>调用的<em>显式</em>动画对象。</strong></p><h4 id="1-2-1-CALayer与CAAction协议"><a href="#1-2-1-CALayer与CAAction协议" class="headerlink" title="1.2.1 CALayer与CAAction协议"></a>1.2.1 CALayer与CAAction协议</h4><blockquote><p>CAAction：技术上来说，这是一个接口，并可以用来做各种事情。但是实际中，某种程度上你可以只把它理解为用来处理动画。</p></blockquote><blockquote><p>是一个接口，允许对象响应 CALayer 改变触发的 actions</p></blockquote><p>下面是摘的CALayer中，有关CAAction的部分属性、方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Action (event handler) protocol. **/</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAction</span></span></span><br><span class="line"><span class="comment">//当一个 action object 被调用时，它接收三个参数：事件的名称、事件发生的对象（layer）以及特定于每种事件类型的命名参数字典。</span></span><br><span class="line">- (<span class="keyword">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="keyword">id</span>)anObject arguments:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CALayer</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">CALayerDelegate</span>&gt; delegate;</span><br><span class="line"><span class="comment">/* A dictionary mapping keys to objects implementing the CAAction protocol. Default value is nil. */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;&gt; *actions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *style;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)defaultActionForKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此方法搜索 layer 的给定action object。Actions 为 layer 定义了一些动态行为。</span></span><br><span class="line"><span class="comment"> * @param event/key action标识符（a key path、外部action名称或预定义action标识符）</span></span><br><span class="line"><span class="comment"> * @return 返回为key提供的action object。该对象必须实现 CAAction 协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/* 如果已定义，则由 -actionForKey: 方法的默认实现调用。 */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>CALayer 的 animatable 属性通常都具有相应的 action object 来启动实际动画，也就是说<strong>当 <code>CALayer</code> 改变属性时会自动应用动画</strong>。</p><p>当<code>CALayer</code>的属性被修改时候，它会调用<code>-actionForKey:</code>方法，传递属性的名称。来查找到与该属性名称关联的 action object （遵守 CAAction 协议，并能接收 <code>run(forKey:object:arguments:)</code> 消息）并执行它。</p><p>您还可以将自定义 action objects 与你的 layer 相关联，以实现一些 APP 特定的操作。</p><h4 id="1-2-2-actionForKey-查找流程"><a href="#1-2-2-actionForKey-查找流程" class="headerlink" title="1.2.2 actionForKey:查找流程"></a>1.2.2 actionForKey:查找流程</h4><p>layer 将像 <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410844-actionforkey">CALayer 的 actionForKey: 文档</a> 中所写的的那样去寻找对应属性变化的 action，整个过程分为四个步骤：</p><ol><li>如果该 layer 具有实现 <code>actionForLayer:forKey:</code> 方法的 delegate，则 layer 调用该方法并返回结果。返回值：<ul><li>返回给定 key 的 action object，这种情况下 layer 将使用这个行为。</li><li>如果它不处理 action，则返回 NSNull 对象，告诉 layer 这里不需要执行一个行为，明确地强制不再进行进一步的搜索。</li><li>返回一个 <code>nil</code>， 这样 layer 就会到其他地方继续寻找。</li></ul></li><li>如果没有委托，或者委托没有实现<code>-actionForLayer:forKey</code>方法，图层接着检查包含属性名称对应行为映射的<code>actions</code>字典。</li><li>如果<code>actions</code>字典没有包含对应的属性，那么图层接着在它的<code>style</code>字典接着搜索属性名。</li><li>最后，如果在<code>style</code>里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的<code>-defaultActionForKey:</code>方法。</li></ol><p>如果上述任何步骤返回 NSNull 的实例，则在继续之前将其转换为 nil。</p><p>所以一轮完整的搜索结束之后，<code>-actionForKey:</code>要么返回空（这种情况下将不会有动画发生），要么是<code>CAAction</code>协议对应的对象，最后<code>CALayer</code>拿这个结果去对先前和当前的值做动画。</p><p><strong>上面的步骤，是对于单独的 layer 来说的。对于 view 中的 layer，对行为的搜索只会到第一步为止（至少我没有见过 view 返回一个 <code>nil</code> 然后导致继续搜索行为的情况）。</strong></p><p>让这一切变得有趣的是，当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</p><blockquote><p>在 iOS 中，如果 layer 与一个 UIView 对象关联时，这个属性<code>必须</code>被设置为持有这个 layer 的那个 view。</p></blockquote><p>理解这些之后，就很容易解释UIKit是如何禁用隐式动画的：属性改变时 layer 会向 view 请求一个行为，而一般情况下 view 将返回一个 <code>NSNull</code>，只有当属性改变发生在动画 block 中时，view 才会返回实际的行为。</p><h4 id="1-2-3-验证示例1"><a href="#1-2-3-验证示例1" class="headerlink" title="1.2.3 验证示例1"></a>1.2.3 验证示例1</h4><p>对一个一般来说可以动画的 layer 属性向 view 询问行为就可以了，比如对于 ‘position’：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;outside animation block: %@&quot;</span>,</span><br><span class="line">      [myView actionForLayer:myView.layer forKey:<span class="string">@&quot;position&quot;</span>]);</span><br><span class="line"></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;inside animation block: %@&quot;</span>,</span><br><span class="line">          [myView actionForLayer:myView.layer forKey:<span class="string">@&quot;position&quot;</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>运行上面的代码，可以看到在 block 外 view 返回的是 NSNull 对象，而在 block 中时返回的是一个 CABasicAnimation。很优雅，对吧？值得注意的是打印出的 NSNull 是带着一对尖括号的 (“<code>&lt;null&gt;</code>“)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号(<code>(null)</code>)：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outside animation block: &lt;null&gt;</span><br><span class="line">inside animation block: &lt;<span class="built_in">CABasicAnimation</span>: <span class="number">0x8c2ff10</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-验证示例2"><a href="#1-2-4-验证示例2" class="headerlink" title="1.2.4 验证示例2"></a>1.2.4 验证示例2</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//test layer action when outside of animation block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Outside: %@&quot;</span>, [<span class="keyword">self</span>.layerView actionForLayer:<span class="keyword">self</span>.layerView.layer forKey:<span class="string">@&quot;backgroundColor&quot;</span>]);</span><br><span class="line">    <span class="comment">//begin animation block</span></span><br><span class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//test layer action when inside of animation block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Inside: %@&quot;</span>, [<span class="keyword">self</span>.layerView actionForLayer:<span class="keyword">self</span>.layerView.layer forKey:<span class="string">@&quot;backgroundColor&quot;</span>]);</span><br><span class="line">    <span class="comment">//end animation block</span></span><br><span class="line">    [<span class="built_in">UIView</span> commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行程序，控制台显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LayerTest[21215:c07] Outside: &lt;null&gt;</span><br><span class="line">$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-setDisableActions"><a href="#3-3-setDisableActions" class="headerlink" title="3.3 +setDisableActions"></a>3.3 +setDisableActions</h3><p>当然返回<code>NSNull</code>并不是禁用隐式动画唯一的办法，<code>CATransaction</code>有个方法叫做<code>+setDisableActions:</code>，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的<code>[CATransaction begin]</code>之后添加下面的代码，同样也会阻止动画的发生：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>总结一下，我们知道了如下几点</p><ul><li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li><li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li></ul><p>我们来对颜色渐变的例子使用一个不同的行为，通过给<code>colorLayer</code>设置一个自定义的<code>actions</code>字典。我们也可以使用委托来实现，但是<code>actions</code>字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？</p><h3 id="3-5-自定义图层属性行为"><a href="#3-5-自定义图层属性行为" class="headerlink" title="3.5 自定义图层属性行为"></a>3.5 自定义图层属性行为</h3><p>行为通常是一个被Core Animation<em>隐式</em>调用的<em>显式</em>动画对象。这里我们使用的是一个实现了<code>CATransition</code>的实例，叫做<em>推进过渡</em>（代码如下）。</p><p>显式动画中的过渡，不再赘述，对于现在，只要知道<code>CATransition</code>响应<code>CAAction</code>协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。</p><p>实现自定义行为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create sublayer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">    <span class="comment">//add a custom action</span></span><br><span class="line">    <span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">    transition.type = kCATransitionPush;</span><br><span class="line">    transition.subtype = kCATransitionFromLeft;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.actions = @&#123;<span class="string">@&quot;backgroundColor&quot;</span>: transition&#125;;</span><br><span class="line">    <span class="comment">//add it to our view</span></span><br><span class="line">    [<span class="keyword">self</span>.layerView.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用推进过渡的色值动画：</p><img src="/images/caa/7.3.jpg" alt="" style="zoom:60%;" /><h2 id="四、呈现图层与模型图层"><a href="#四、呈现图层与模型图层" class="headerlink" title="四、呈现图层与模型图层"></a>四、呈现图层与模型图层</h2><h3 id="4-1-presentationLayer与modelLayer"><a href="#4-1-presentationLayer与modelLayer" class="headerlink" title="4.1 presentationLayer与modelLayer"></a>4.1 presentationLayer与modelLayer</h3><p><code>CALayer</code>的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？</p><p>当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p><p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p><p>我们讨论的就是一个典型的<em>微型MVC模式</em>。<code>CALayer</code>是一个连接用户界面（就是MVC中的<em>view</em>）虚构的类，但是在界面本身这个场景下，<code>CALayer</code>的行为更像是存储了视图如何显示和动画的数据模型。实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。</p><p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着<code>CALayer</code>除了“真实”值（就是你设置的值）之外，必须要知道当前<em>显示</em>在屏幕上的属性值的记录。</p><p>每个图层属性的显示值都被存储在一个叫做<em>呈现图层</em>的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以<strong>通过呈现图层的值来获取当前屏幕上真正显示出来的值</strong>。</p><p>如图，一个移动的图层是如何通过数据模型呈现的：</p><img src="/images/caa/7.4.jpg" alt="" style="zoom:60%;" /><p>我们在本书的第一章中提到除了图层树，另外还有<em>呈现树</em>。<strong>呈现树通过图层树中所有图层的呈现图层所形成</strong>。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p><p>你可能注意到有一个叫做<code>–modelLayer</code>的方法。在呈现图层上调用<code>–modelLayer</code>将会返回它正在呈现所依赖的<code>CALayer</code>。通常在一个图层上调用<code>-modelLayer</code>会返回<code>–self</code>（实际上我们已经创建的原始图层就是一种数据模型）。</p><h3 id="4-2-呈现图层的使用场景"><a href="#4-2-呈现图层的使用场景" class="headerlink" title="4.2 呈现图层的使用场景"></a>4.2 呈现图层的使用场景</h3><p>大多数情况下，你不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p><ul><li>如果你在实现一个基于定时器的动画（见第11章“基于定时器的动画”），而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li><li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法（见第三章“图层几何学”）来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li></ul><p>我们可以用一个简单的案例来证明后者（代码如下）。在这个例子中，点击屏幕上的任意位置将会让图层平移到那里。点击图层本身可以随机改变它的颜色。我们通过对呈现图层调用<code>-hitTest:</code>来判断是否被点击。</p><p>如果修改代码让<code>-hitTest:</code>直接作用于<em>colorLayer</em>而不是呈现图层，你会发现当图层移动的时候它并不能正确工作。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是<strong>用呈现图层来响应hit test</strong>的原因）。</p><p>使用<code>presentationLayer</code>图层来判断当前图层位置：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create a red layer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.position = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.bounds.size.width / <span class="number">2</span>, <span class="keyword">self</span>.view.bounds.size.height / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get the touch point</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = [[touches anyObject] locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//check if we&#x27;ve tapped the moving layer</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.colorLayer.presentationLayer hitTest:point]) &#123;</span><br><span class="line">        <span class="comment">//randomize the layer background color</span></span><br><span class="line">        <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//otherwise (slowly) move the layer to new position</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">4.0</span>];</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.position = point;</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="五、实践篇"><a href="#五、实践篇" class="headerlink" title="五、实践篇"></a>五、实践篇</h2><blockquote><p>原文 — <a href="https://objccn.io/issue-12-4/">View-Layer 协作</a></p></blockquote><h3 id="5-1-从-UIKit-中学习"><a href="#5-1-从-UIKit-中学习" class="headerlink" title="5.1 从 UIKit 中学习"></a>5.1 从 UIKit 中学习</h3><p>我很确定我们都会同意 UIView 动画是一组非常优秀的 API，它简洁明确。实际上，它使用了 Core Animation 来执行动画，这给了我们一个绝佳的机会来深入研究 UIKit 是如何使用 Core Animation 的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴。:)</p><h4 id="5-1-1-addAnimation-forKey"><a href="#5-1-1-addAnimation-forKey" class="headerlink" title="5.1.1 addAnimation:forKey:"></a>5.1.1 addAnimation:forKey:</h4><p>当属性在动画 block 中改变时，view 将向 layer 返回一个基本动画，然后动画通过图层的 <code>addAnimation:forKey:</code> 方法被添加到 layer 中，就像显式地添加动画那样。再一次，别直接信我，让我们实践检验一下。</p><p>归功于 UIView 的 <code>+layerClass</code> 类方法，view 和 layer 之间的交互很容易被观测到。通过这个方法我们可以在为 view 创建 layer 时为其指定要使用的类。通过子类一个 UIView，以及用这个方法返回一个自定义的 layer 类，我们就可以重写 layer 子类中的 <code>addAnimation:forKey:</code> 并输出一些东西来验证它是否确实被调用。唯一要记住的是我们需要调用 super 方法，不然的话我们就把要观测的行为完全改变了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRInspectionLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRInspectionLayer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)addAnimation:(<span class="built_in">CAAnimation</span> *)anim forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;adding animation: %@&quot;</span>, [anim debugDescription]);</span><br><span class="line">    [<span class="keyword">super</span> addAnimation:anim forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRInspectionView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRInspectionView</span></span></span><br><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [DRInspectionLayer <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过输出动画的 debug 信息，我们不仅可以验证它确实如预期一样被调用了，还可以看到动画是如何组织构建的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CABasicAnimation</span>:<span class="number">0x8c73680</span>; </span><br><span class="line">    delegate = &lt;<span class="built_in">UIViewAnimationState</span>: <span class="number">0x8e91fa0</span>&gt;;</span><br><span class="line">    fillMode = both; </span><br><span class="line">    timingFunction = easeInEaseOut; </span><br><span class="line">    duration = <span class="number">0.3</span>; </span><br><span class="line">    fromValue = <span class="built_in">NSPoint</span>: &#123;<span class="number">5</span>, <span class="number">5</span>&#125;; </span><br><span class="line">    keyPath = position</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当动画刚被添加到 layer 时，属性的新值还没有被改变。在构建动画时，只有 <code>fromValue</code> (也就是当前值) 被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说，意味着什么：</p><blockquote><p>fromValue、toValue、byValue三个对象定义了要插入的属性值。三者都是可选的，并且不应该超过两个非nil。</p><p>当只有 <code>fromValue</code> 不是 <code>nil</code> 时，在 <code>fromValue</code> 和属性当前显示层的值之间进行插值。</p><p>插值指利用某一个函数来计算出2个或更多的值之间的值，最简单的比如算术平均数(x+y)/2就是x,y的线性插值。在图形图像中例如旋转，放大，缩小等操作中，往往变化后图像中的点对应源图片中的点是不存在的，例如（2.1，3）这个点，那么在计算目标图像的在该点像素值的时候，就 需要进行插值运算来计算出该点的像素值。</p></blockquote><p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到 layer 上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *fadeIn = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@&quot;opacity&quot;</span>];</span><br><span class="line">fadeIn.duration  = <span class="number">0.75</span>;</span><br><span class="line">fadeIn.fromValue = @<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">myLayer.opacity = <span class="number">1.0</span>; <span class="comment">// 更改 model 的值 ...</span></span><br><span class="line"><span class="comment">// ... 然后添加动画对象</span></span><br><span class="line">[myLayer addAnimation:fadeIn forKey:<span class="string">@&quot;fade in slowly&quot;</span>];</span><br></pre></td></tr></table></figure><p>这很简洁，你也不需要在动画被移除的时候做什么额外操作。如果动画是在一段延迟后才开始的话，你可以使用 backward 填充模式 (或者 ‘both’ 填充模式)，就像 UIKit 所创建的动画那样。</p><h4 id="5-1-2-UIViewAnimationState类"><a href="#5-1-2-UIViewAnimationState类" class="headerlink" title="5.1.2 UIViewAnimationState类"></a>5.1.2 UIViewAnimationState类</h4><p>可能你看见上面输出中的动画的 delegate 了，想知道这个 UIViewAnimationState 类是用来做什么的吗？</p><p>在此之前，先来看一下这个 CAAnimationDelegate 协议：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CAAnimation</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>, <span class="title">CAMediaTiming</span>, <span class="title">CAAction</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;<span class="built_in">CAAnimationDelegate</span>&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAnimationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">/* Called when the animation begins its active duration. */</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the animation either completes its active duration or is removed from the object</span></span><br><span class="line"><span class="comment"> * it is attached to (i.e. the layer). &#x27;flag&#x27; is true if the animation reached the end of its active </span></span><br><span class="line"><span class="comment"> * duration without being removed. */</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后我们可以来看看这个实现了上次协议的类做了什么，<a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump 出来的头文件</a>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewAnimationState</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationState</span>* _nextState;</span><br><span class="line">    <span class="built_in">NSString</span>* _animationID;</span><br><span class="line">    <span class="keyword">void</span>* _context;</span><br><span class="line">    <span class="keyword">id</span> _delegate;  <span class="comment">// </span></span><br><span class="line">    <span class="keyword">double</span> _duration;</span><br><span class="line">    <span class="keyword">double</span> _delay;</span><br><span class="line">    <span class="keyword">double</span> _frameInterval;</span><br><span class="line">    <span class="keyword">double</span> _start;</span><br><span class="line">    <span class="keyword">int</span> _curve;</span><br><span class="line">    <span class="keyword">float</span> _repeatCount;</span><br><span class="line">    <span class="keyword">int</span> _transition;</span><br><span class="line">    <span class="built_in">UIView</span>* _transitionView;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_3_2</span></span><br><span class="line">    <span class="keyword">int</span> _filter;</span><br><span class="line">    <span class="built_in">UIView</span>* _filterView;</span><br><span class="line">    <span class="keyword">float</span> _filterValue;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SEL _willStartSelector;</span><br><span class="line">    SEL _didEndSelector;</span><br><span class="line">    <span class="keyword">int</span> _didEndCount;</span><br><span class="line">    <span class="built_in">CGPoint</span> _position;</span><br><span class="line">    <span class="keyword">unsigned</span> _willStartSent : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _useCurrentLayerState : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _cacheTransition : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _autoreverses : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _roundsToInteger : <span class="number">1</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &lt; __IPHONE_3_2</span></span><br><span class="line">    <span class="keyword">unsigned</span> _reserved : <span class="number">27</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)pushViewAnimationState:(<span class="keyword">id</span>)state context:(<span class="keyword">void</span>*)context;</span><br><span class="line">+ (<span class="keyword">void</span>)popAnimationState;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line">- (<span class="keyword">void</span>)setAnimationAttributes:(<span class="keyword">id</span>&lt;<span class="built_in">CAMediaTiming</span>&gt;)attributes;<span class="comment">// save the attributes of the animation state *into* the argument.</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="keyword">id</span>)animation;</span><br><span class="line">- (<span class="keyword">void</span>)sendDelegateAnimationDidStop:(<span class="keyword">id</span>)sendDelegateAnimation finished:(<span class="built_in">BOOL</span>)finished;</span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="keyword">id</span>)animation finished:(<span class="built_in">BOOL</span>)finished;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到，它主要用来维护动画的一些状态 (持续时间，延时，重复次数等等)。它还负责对一个栈做 push 和 pop，这是为了在多个动画 block 嵌套时能够获取正确的动画状态。这些都是些实现细节，除非你想要写一套自己的基于 block 的动画 API，否则可能你不会用到它们 (实际上这是一个很有趣的点子)。</p><p>然后真正<em>有意思</em>的是这个 delegate 实现了 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code>，并将信息传给了它自己的 delegate。</p><blockquote><p><strong>编者注</strong> 这里不太容易理解，加以说明：从上面的头文件中可以看出，作为 CAAnimation 的 delegate 的私有类 <code>UIViewAnimationState</code> 中还有一个 <code>_delegate</code> 成员，并且 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code> 也是典型的 delegate 的实现方法。</p></blockquote><h4 id="5-1-3-UIViewAnimationBlockDelegate类"><a href="#5-1-3-UIViewAnimationBlockDelegate类" class="headerlink" title="5.1.3 UIViewAnimationBlockDelegate类"></a>5.1.3 UIViewAnimationBlockDelegate类</h4><p>通过打印这个 delegate 的 delegate，我们可以发现它也是一个私有类：UIViewAnimationBlockDelegate。同样进行 <a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的 delegate 回调并且执行相应的 block。如果我们使用自己的 Core Animation 代码，并且选择 block 而不是 delegate 做回调的话，添加这个是很容易的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRAnimationBlockDelegate</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="keyword">void</span>(^start)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="keyword">void</span>(^stop)(<span class="built_in">BOOL</span>);</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">instancetype</span>)animationDelegateWithBeginning:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))beginning</span><br><span class="line">                                   completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRAnimationBlockDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)animationDelegateWithBeginning:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))beginning</span><br><span class="line">                                    completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];</span><br><span class="line">    result.start = beginning;</span><br><span class="line">    result.stop  = completion;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.start) &#123;</span><br><span class="line">        <span class="keyword">self</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.start = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stop) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stop(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.stop = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>虽然是我个人的喜好，但是我觉得像这样的基于 block 的回调风格可能会比实现一个 delegate 回调更适合你的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;beginning to fade in&quot;</span>);</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;did fade %@&quot;</span>, finished ? <span class="string">@&quot;to the end&quot;</span> : <span class="string">@&quot;but was cancelled&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="5-2-自定义基于-block-的动画-APIs"><a href="#5-2-自定义基于-block-的动画-APIs" class="headerlink" title="5.2 自定义基于 block 的动画 APIs"></a>5.2 自定义基于 block 的动画 APIs</h3><p>一旦你知道了 <code>actionForKey:</code> 的机理之后，UIView 就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于 block 的动画 APIs。我所设计的动画将通过在 block 中用一个很激进的时间曲线来做动画，以吸引用户对该 view 的注意，之后做一个缓慢的动画回到原始状态。你可以把它看作一种类似 pop (请不要和 Facebook 的 Pop 框架弄混了)的行为。</p><h4 id="5-2-1-效果展示"><a href="#5-2-1-效果展示" class="headerlink" title="5.2.1 效果展示"></a>5.2.1 效果展示</h4><p>与一般使用 <code>UIViewAnimationOptionAutoreverse</code> 的动画 block 不同，因为动画设计和概念上的需要，我自己实现了将 model 值改变回原始值的过程。自定义的动画 API 的使用方法就像这样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> DR_popAnimationWithDuration:<span class="number">0.7</span></span><br><span class="line">                         animations:^&#123;</span><br><span class="line">                                myView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(M_PI_2);</span><br><span class="line">                              &#125;];</span><br></pre></td></tr></table></figure><p>当我们完成后，效果是这个样子的 (对四个不同的 view 为位置，尺寸，颜色和旋转进行动画)：</p><p>The custom block animation API, used to animate the position, size, color, and rotation of four different views：</p><img src="/images/caa/custom-block-animations.gif" alt="" style="zoom:70%;" /><h4 id="5-2-2-代码实现"><a href="#5-2-2-代码实现" class="headerlink" title="5.2.2 代码实现"></a>5.2.2 代码实现</h4><h5 id="1-Method-Swizzle"><a href="#1-Method-Swizzle" class="headerlink" title="1. Method Swizzle"></a>1. Method Swizzle</h5><p>要开始实现它，我们首先要做的是当一个 layer 属性变化时获取 delegate 的回调。因为我们无法事先预测 layer 要改变什么，所以我选择在一个 UIView 的 category 中 swizzle <code>actionForLayer:forKey:</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">DR_CustomBlockAnimations</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;        </span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(actionForLayer:forKey:);</span><br><span class="line">    SEL extendedSelector = <span class="keyword">@selector</span>(DR_actionForLayer:forKey:);</span><br><span class="line"></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">    Method extendedMethod = class_getInstanceMethod(<span class="keyword">self</span>, extendedSelector);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(originalMethod, <span class="string">@&quot;original method should exist&quot;</span>);</span><br><span class="line">    <span class="built_in">NSAssert</span>(extendedMethod, <span class="string">@&quot;exchanged method should exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">self</span>, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, extendedMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-上下文变量控制"><a href="#2-上下文变量控制" class="headerlink" title="2. 上下文变量控制"></a>2. 上下文变量控制</h5><p>为了保证我们不破坏其他依赖于 <code>actionForLayer:forKey:</code> 回调的代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子来说一个简单的 <code>BOOL</code> 其实就够了，但是如果我们之后要写更多内容的话，上下文的话就要灵活得多了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *DR_currentAnimationContext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *DR_popAnimationContext     = &amp;DR_popAnimationContext;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)DR_actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DR_currentAnimationContext == DR_popAnimationContext) &#123;</span><br><span class="line">        <span class="comment">// 这里写我们自定义的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始方法</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> DR_actionForLayer:layer forKey:event]; <span class="comment">// 没错，你没看错。因为它们已经被交换了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的实现中，我们要确保在执行动画 block 之前设置动画的上下文，并且在执行后恢复上下文：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)DR_popAnimationWithDuration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                         animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">&#123;</span><br><span class="line">    DR_currentAnimationContext = DR_popAnimationContext;</span><br><span class="line">    <span class="comment">// 执行动画 (它将触发交换后的 delegate 方法)</span></span><br><span class="line">    animations();</span><br><span class="line">    <span class="comment">/* 一会儿再添加 */</span></span><br><span class="line">    DR_currentAnimationContext = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-定义动画状态存储类"><a href="#3-定义动画状态存储类" class="headerlink" title="3. 定义动画状态存储类"></a>3. 定义动画状态存储类</h5><p>如果我们想要做的不过是添加一个从旧的值向新的值过度的动画的话，我们可以直接在 delegate 的回调中来做。然而因为我们想要更精确地控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓。</p><p>有意思的是，iOS 添加的一个基于 block 的动画 API 也遇到了同样的问题。使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每个关键帧，在属性变化时，view 返回 <code>nil</code>，但是却存储下需要的状态。这样就能在所有关键帧 block 执行后创建一个 <code>CAKeyframeAnimation</code> 对象。</p><p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么 layer 被更改了，什么 key path 的值被改变了，以及原来的值是什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRSavedPopAnimationState</span> : <span class="title">NSObject</span> @<span class="title">property</span> (<span class="title">strong</span>) <span class="title">CALayer</span>  *<span class="title">layer</span>; @<span class="title">property</span> (<span class="title">copy</span>)   <span class="title">NSString</span> *<span class="title">keyPath</span>; @<span class="title">property</span> (<span class="title">strong</span>) <span class="title">id</span>        <span class="title">oldValue</span>; + (<span class="title">instancetype</span>)<span class="title">savedStateWithLayer</span>:(<span class="title">CALayer</span> *)<span class="title">layer</span>                             <span class="title">keyPath</span>:(<span class="title">NSString</span> *)<span class="title">keyPath</span>; @<span class="title">end</span> @<span class="title">implementation</span> <span class="title">DRSavedPopAnimationState</span> + (<span class="title">instancetype</span>)<span class="title">savedStateWithLayer</span>:(<span class="title">CALayer</span> *)<span class="title">layer</span>                             <span class="title">keyPath</span>:(<span class="title">NSString</span> *)<span class="title">keyPath</span> </span>&#123;     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];     savedState.layer    = layer;     savedState.keyPath  = keyPath;     savedState.oldValue = [layer valueForKeyPath:keyPath];     <span class="keyword">return</span> savedState; &#125; <span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>接下来，在我们的交换后的 delegate 回调中，我们简单地将被变更的属性的状态存入一个静态可变数组中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)DR_actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event&#123;    <span class="keyword">if</span> (DR_currentAnimationContext == DR_popAnimationContext) &#123;        <span class="comment">// 这里写我们自定义的代码...        [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer                                                                                 keyPath:event]];        // 没有隐式的动画 (稍后添加)        return (id&lt;CAAction&gt;)[NSNull null];    &#125;    // 调用原始方法    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-创建关键帧动画"><a href="#4-创建关键帧动画" class="headerlink" title="4. 创建关键帧动画"></a>4. 创建关键帧动画</h5><p>在动画 block 执行完毕后，所有的属性都被变更了，它们的状态也被保存了。现在，创建关键帧动画：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)DR_popAnimationWithDuration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                         animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">&#123;</span><br><span class="line">    DR_currentAnimationContext = DR_popAnimationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行动画 (它将触发交换后的 delegate 方法)</span></span><br><span class="line">    animations();</span><br><span class="line"></span><br><span class="line">    [[<span class="keyword">self</span> DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;</span><br><span class="line">        <span class="built_in">CALayer</span> *layer    = savedState.layer;</span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = savedState.keyPath;</span><br><span class="line">        <span class="keyword">id</span> oldValue       = savedState.oldValue;</span><br><span class="line">        <span class="keyword">id</span> newValue       = [layer valueForKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CAKeyframeAnimation</span> *anim = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGFloat</span> easing = <span class="number">0.2</span>;</span><br><span class="line">        <span class="built_in">CAMediaTimingFunction</span> *easeIn  = [<span class="built_in">CAMediaTimingFunction</span> functionWithControlPoints:<span class="number">1.0</span> :<span class="number">0.0</span> :(<span class="number">1.0</span>-easing) :<span class="number">1.0</span>];</span><br><span class="line">        <span class="built_in">CAMediaTimingFunction</span> *easeOut = [<span class="built_in">CAMediaTimingFunction</span> functionWithControlPoints:easing :<span class="number">0.0</span> :<span class="number">0.0</span> :<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">        anim.duration = duration;</span><br><span class="line">        anim.keyTimes = @[@<span class="number">0</span>, @(<span class="number">0.35</span>), @<span class="number">1</span>];</span><br><span class="line">        anim.values = @[oldValue, newValue, oldValue];</span><br><span class="line">        anim.timingFunctions = @[easeIn, easeOut];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不带动画地返回原来的值</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">        [layer setValue:oldValue forKeyPath:keyPath];</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 &quot;pop&quot; 动画</span></span><br><span class="line">        [layer addAnimation:anim forKey:keyPath];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫除工作 (移除所有存储的状态)</span></span><br><span class="line">    [[<span class="keyword">self</span> DR_savedPopAnimationStates] removeAllObjects];</span><br><span class="line"></span><br><span class="line">    DR_currentAnimationContext = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意老的 model 值被设到了 layer 上，所以在当动画结束和移除后，model 的值和 presentation 的值是相符合的。</p><p>创建像这样的你自己的 API 不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂 UIView block 动画的 APIs，特别是你已经在 Core Animation 的舒适区的时候，这非常有助于你的提高。</p><h3 id="5-3-其他的动画灵感"><a href="#5-3-其他的动画灵感" class="headerlink" title="5.3 其他的动画灵感"></a>5.3 其他的动画灵感</h3><p>UIImageView 动画是一个完全不同的更高层次的动画 API 的实现方式，我会把它留给你来探索。表面上，它只不过是重新组装了一个传统的动画 API。你所要做的事情就是指定一个图片数组和一段时间，然后告诉 image view 开始动画。在抽象背后，其实是一个添加在 image view 的 layer 上的 contents 属性的离散的关键帧动画：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CAKeyframeAnimation</span>:<span class="number">0x8e5b020</span>; </span><br><span class="line">    removedOnCompletion = <span class="number">0</span>; </span><br><span class="line">    delegate = &lt;_UIImageViewExtendedStorage: <span class="number">0x8e49230</span>&gt;; </span><br><span class="line">    duration = <span class="number">2.5</span>; </span><br><span class="line">    repeatCount = <span class="number">2.14748e+09</span>; </span><br><span class="line">    calculationMode = discrete; </span><br><span class="line">    values = (</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d6ce80&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d6d2d0&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d5cd30&gt;&quot;</span></span><br><span class="line">    ); </span><br><span class="line">    keyPath = contents</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>动画 APIs 可以以很多不同形式出现，而对于你自己写的动画 API 来说，也是这样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章讨论了：</p><ul><li>隐式动画，还有Core Animation对指定属性选择合适的动画行为的机制。</li><li>UIKit是如何充分利用Core Animation的隐式动画机制来强化它的显式系统，</li><li>以及动画是如何被默认禁用并且当需要的时候启用的。</li><li>最后，你了解了呈现和模型图层，以及Core Animation是如何通过它们来判断出图层当前位置以及将要到达的位置。</li></ul><p>下一章将研究Core Animation提供的<em>显式</em>动画类型，既可以直接对图层属性做动画，也可以覆盖默认的图层行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques/blob/master/7-%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation(一) - UIView与CALayer</title>
    <link href="https://tenloy.github.io/2021/09/07/core-animation01.html"/>
    <id>https://tenloy.github.io/2021/09/07/core-animation01.html</id>
    <published>2021-09-07T14:50:38.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<p>Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做<em>Layer Kit</em>这么一个不怎么和动画有关的名字演变而来。</p><p>Core Animation是一个<em>复合引擎</em>，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的<em>图层</em>，存储在一个叫做<strong>图层树</strong>的体系之中。于是这个树形成了<strong>UIKit</strong>以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p><h2 id="一、View与Layer"><a href="#一、View与Layer" class="headerlink" title="一、View与Layer"></a>一、View与Layer</h2><h3 id="1-1-CALayer图层"><a href="#1-1-CALayer图层" class="headerlink" title="1.1 CALayer图层"></a>1.1 CALayer图层</h3><blockquote><p>CALayer： 管理基于图像的内容，并允许你对该内容执行动画</p></blockquote><p>在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。layer给view提供了基础设施，使得绘制内容和呈现更高效动画更容易、更低耗；layer不参与view的事件处理、不参与响应链。</p><img src="/images/caa/7.5.png" alt="" style="zoom:100%;" /><p>UIKit 中的每个视图都有自己的 CALayer 。 这个图层通常有一个缓存区/后备存储(Backing Store)，它是像素位图。这个后备存储实际上是渲染到显示器上的。</p><blockquote><p>术语“后备存储”通常用于图形用户界面的上下文中。 是一块记忆，其中包含窗户的图像。 如果窗口被覆盖（甚至部分）然后被覆盖，则后备存储用于重绘。</p></blockquote><blockquote><p>测试：分别修改、打印MyView与.layer的backgroundColor，可以看到这两者是同步变化的。<strong>所以其实UIView的背景色就是CALayer的背景色。</strong></p></blockquote><p>为什么iOS要基于<code>UIView</code>和<code>CALayer</code>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。</p><ul><li><p>在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p></li><li><p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p></li></ul><h3 id="1-2-四个层级关系"><a href="#1-2-四个层级关系" class="headerlink" title="1.2 四个层级关系"></a>1.2 四个层级关系</h3><p>在整个Core Animation机制中，存在4个层级关系：</p><h4 id="1-2-1-视图层级"><a href="#1-2-1-视图层级" class="headerlink" title="1.2.1 视图层级"></a>1.2.1 视图层级</h4><p>视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。</p><h4 id="1-2-2-图层树"><a href="#1-2-2-图层树" class="headerlink" title="1.2.2 图层树"></a>1.2.2 图层树</h4><p>每一个<code>UIView</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p><h4 id="1-2-3-呈现树"><a href="#1-2-3-呈现树" class="headerlink" title="1.2.3 呈现树"></a>1.2.3 呈现树</h4><p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着<code>CALayer</code>除了“真实”值（就是你设置的值）之外，必须要知道当前<em>显示</em>在屏幕上的属性值的记录。</p><p>每个图层属性的显示值都被存储在一个叫做<em>呈现图层</em>的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p><p>呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p><h4 id="1-2-4-渲染树"><a href="#1-2-4-渲染树" class="headerlink" title="1.2.4 渲染树"></a>1.2.4 渲染树</h4><p>详见<a href="https://tenloy.github.io/2021/09/11/core-animation03.html">下下篇 iOS渲染流程探究</a></p><p>图层树的改动会在Application这一层以事务的形式完成打包提交，一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<em>渲染树</em>的图层树。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p><ul><li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li><li>在屏幕上渲染可见的三角形</li></ul><h2 id="二、View的绘制"><a href="#二、View的绘制" class="headerlink" title="二、View的绘制"></a>二、View的绘制</h2><blockquote><p>苹果文档 —— <a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html">The View Drawing Cycle</a></p></blockquote><h3 id="2-1-绘制机制"><a href="#2-1-绘制机制" class="headerlink" title="2.1 绘制机制"></a>2.1 绘制机制</h3><p>UIView 类使用按需绘制模型来呈现内容。</p><ul><li>当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕获此内容的快照并将该快照用作视图的视觉表示。</li><li>如果您从不更改视图的内容，则视图的绘制代码可能永远不会被再次调用。大多数涉及视图的操作都会重复使用快照图像。</li><li>如果您确实更改了内容，则会通知系统视图已更改。然后视图重复绘制视图和捕获新结果的快照的过程。</li></ul><p>当视图的内容发生更改时，不要直接重绘这些更改。可以使用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法使视图无效。这些方法告诉系统视图的内容发生了变化，需要在下一次重绘。</p><h3 id="2-2-绘制周期"><a href="#2-2-绘制周期" class="headerlink" title="2.2 绘制周期"></a>2.2 绘制周期</h3><p><strong>系统会等到当前 run loop 执行结束(一个loop也就是一个绘制周期)，才启动任何绘图操作</strong>。这种延迟使您有机会一次性使多个视图无效、在层次结构中添加或删除视图、隐藏视图、调整视图大小和重新定位视图。然后，所做的所有更改都会同时反映出来。</p><h3 id="2-3-Custom-Drawing"><a href="#2-3-Custom-Drawing" class="headerlink" title="2.3 Custom Drawing"></a>2.3 Custom Drawing</h3><blockquote><p>寄宿图：CALayer类除了简单的设置背景颜色外，还能够包含一张图片。又称CALayer的寄宿图（即图层中包含的图）。</p></blockquote><p>当需要渲染视图的内容时，实际的绘制过程取决于视图及其配置。系统视图通常实现私有绘图方法来呈现其内容。这些相同的系统视图经常公开接口，您可以使用这些接口来配置视图的实际外观。</p><ul><li>直接设置layer的contents属性</li><li>对于自定义 UIView 子类，可以重写 drawRect: 方法并使用该方法绘制视图的内容。（最常用）</li></ul><h4 id="2-3-1-contents属性"><a href="#2-3-1-contents属性" class="headerlink" title="2.3.1 contents属性"></a>2.3.1 contents属性</h4><p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app都能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p><p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p><p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p><p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），它们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents &#x3D; (__bridge id)image.CGImage;</span><br></pre></td></tr></table></figure><p>如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p><h4 id="2-3-2-drawRect"><a href="#2-3-2-drawRect" class="headerlink" title="2.3.2 drawRect"></a>2.3.2 drawRect</h4><p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p><p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：<strong>如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法</strong>。</p><p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后<strong>内容就会被缓存起来直到它需要被更新</strong>（比如手动调用了<code>-setNeedsDisplay</code>方法。当影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p><p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code>协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p><p>当需要被重绘时，CALayer会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。</p><h2 id="三、View的重绘"><a href="#三、View的重绘" class="headerlink" title="三、View的重绘"></a>三、View的重绘</h2><h3 id="3-1-重绘流程图"><a href="#3-1-重绘流程图" class="headerlink" title="3.1 重绘流程图"></a>3.1 重绘流程图</h3><p>写在前面：注意：<strong>更改视图的几何形状不会自动导致系统重绘视图的内容</strong>。视图的内容模式(contentMode)属性决定了如何解释视图几何的变化。大多数content modes会在视图边界内拉伸或重新定位现有快照，并且不会创建新快照。有关内容模式如何影响视图的绘制周期的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html">Content Modes</a>。</p><p>先来看一下<strong>更新-绘制流程图</strong>，然后梳理一下其中的重要方法</p><img src="/images/caa/viewredraw.png" alt="viewredraw" style="zoom:90%;" /><ul><li><p>当我们调用 <code>[UIView setNeedsDisplay]</code> 这个方法时，其实并没有立即进行绘制工作，系统会立刻调用CALayer的同名方法，并且<strong>会在当前layer上打上一个标记，然后会在当前runloop将要结束的时候（下一个绘制周期）</strong>调用 <code>[CALayer display]</code> 这个方法，然后进入我们视图的真正绘制过程。</p></li><li><p>在 <code>[CALayer display]</code> 这个方法的内部实现中会判断这个 layer 的 delegate 是否响应 displayLayer: 这个方法，如果响应这个方法，就会进入到系统绘制流程中；如果不响应这个方法，那么就会为我们提供<strong>异步绘制</strong>的入口。</p></li><li><p>在异步绘制中，会先判断代理是否有实现协议的 <code>drawLayer:inContext</code> 方法，如果有实现，就会创建一个空的寄宿图和 Core Craphics 的绘制上下文，为绘制寄宿图做准备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGBitmapContextCreate(...);</span><br><span class="line"><span class="comment">// Core Craphics API...</span></span><br><span class="line">CGBitmapContextCreateImage(...);</span><br></pre></td></tr></table></figure><p>然后会在一个合适的时候调用一个我们非常熟悉的方法<code>[UIView drawRect:]</code> 来获取寄宿图内容。<code>[UIView drawRect:]</code> 这个方法默认是什么都不做，系统给我们开这个口子是为了让我们可以再做一些其他的绘制工作。</p></li><li><p>无论是哪个分支，<strong>最终都会由CALayer上传对应的backing store(寄宿图，也即位图bitmap)给GPU</strong>，然后就结束了本次绘制流程。</p></li></ul><h3 id="3-2-内容重绘-—-Layer方法"><a href="#3-2-内容重绘-—-Layer方法" class="headerlink" title="3.2 内容重绘 — Layer方法"></a>3.2 内容重绘 — Layer方法</h3><h4 id="3-2-1-display"><a href="#3-2-1-display" class="headerlink" title="3.2.1 -display"></a>3.2.1 -display</h4><p>重新加载该图层的内容。调用 -drawInContext: 方法，然后更新图层的’contents’属性。</p><p>通常这不会被直接调用。</p><h4 id="3-2-2-setNeedsDisplay"><a href="#3-2-2-setNeedsDisplay" class="headerlink" title="3.2.2 -setNeedsDisplay"></a>3.2.2 -setNeedsDisplay</h4><p>将图层的内容标记为需要更新。</p><p>调用此方法会导致图层重新缓存其内容。 这导致图层可能调用其委托的 displayLayer: 或 drawLayer:inContext: 方法。 删除图层 contents 属性中的现有内容，为新内容让路。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘范围是整个边界矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay;</span><br><span class="line"><span class="comment">// 重绘范围是参数指定的矩形(应在接收器的坐标系中指定, 且只对该图层有效)</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(<span class="built_in">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-drawInContext"><a href="#3-2-3-drawInContext" class="headerlink" title="3.2.3 -drawInContext:"></a>3.2.3 -drawInContext:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用指定的图形上下文绘制图层的内容。</span></span><br><span class="line"><span class="comment"> * @param ctx 在其中绘制内容的图形上下文。可以剪裁上下文以保护有效的层内容。</span></span><br><span class="line"><span class="comment"> * 希望找到要绘制的实际区域的子类可以调用 CGContextGetClipBoundingBox。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>此方法的默认实现本身不进行任何绘图。 如果图层的委托实现了 drawLayer:inContext: 方法，则调用该方法来进行实际绘制。</p><p>子类可以覆盖此方法并使用它来绘制图层的内容。 绘制时，所有坐标都应在逻辑坐标空间中以点为单位指定。</p><h4 id="3-2-4-CALayerDelegate"><a href="#3-2-4-CALayerDelegate" class="headerlink" title="3.2.4 CALayerDelegate"></a>3.2.4 CALayerDelegate</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-display方法的默认实现调用，在这种情况下，它应该实现整个 display 过程(通常通过设置&#x27; contents&#x27;属性)。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-drawInContext的默认实现调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-display方法的默认实现调用。</span></span><br><span class="line"><span class="comment"> 允许delegate在-drawLayer:InContext之前配置任何影响内容的图层状态，如&#x27;contentsFormat&#x27;和&#x27; opaque&#x27;。如果委托实现了-displayLayer，它将不会被调用。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)layerWillDraw:(<span class="built_in">CALayer</span> *)layer</span><br><span class="line">  API_AVAILABLE(macos(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果实现了，则由layer的-layoutSublayers方法的默认实现调用(在检查layoutManager之前)。</span></span><br><span class="line"><span class="comment">   注意，如果调用委托方法，布局管理器将被忽略。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)layoutSublayersOfLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 隐式动画中用到的 */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-3-内容重绘-—-View方法"><a href="#3-3-内容重绘-—-View方法" class="headerlink" title="3.3 内容重绘 — View方法"></a>3.3 内容重绘 — View方法</h3><h4 id="3-3-1-setNeedsDisplay"><a href="#3-3-1-setNeedsDisplay" class="headerlink" title="3.3.1 -setNeedsDisplay"></a>3.3.1 -setNeedsDisplay</h4><p>通知系统你的视图内容需要重绘。此方法将指定的矩形添加到视图的当前无效矩形列表中并立即返回。直到下一个绘制周期才会真正重绘视图，此时所有无效的视图都会更新。</p><p>你应该仅在视图的内容或外观发生更改时，使用此方法请求重绘视图。<strong>如果只是更改视图的几何形状，通常不会重新绘制视图，它的现有内容根据视图的 contentMode 属性中的值进行调整。</strong></p><p> 注意：如果您的视图由 CAEAGLLayer 对象支持，则此方法无效。它仅适用于使用原生绘图技术（例如 UIKit 和 Core Graphics）来呈现其内容的视图。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘范围是整个边界矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay;</span><br><span class="line"><span class="comment">// 重绘范围是参数指定的矩形(应在接收器的坐标系中指定, 且只对该图层有效)</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(<span class="built_in">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><h3 id="3-4-布局重新计算-—-Layer方法"><a href="#3-4-布局重新计算-—-Layer方法" class="headerlink" title="3.4 布局重新计算 — Layer方法"></a>3.4 布局重新计算 — Layer方法</h3><h4 id="3-4-1-layoutSublayers"><a href="#3-4-1-layoutSublayers" class="headerlink" title="3.4.1 -layoutSublayers"></a>3.4.1 -layoutSublayers</h4><p>告诉图层更新其布局 </p><p>子类可以覆盖此方法并使用它来实现自己的布局算法。您的实现必须设置每个子层的frame。</p><p>此方法的默认实现：</p><ul><li><p>如果 layer 有delegate对象，且实现了 layoutSublayersOfLayer: 方法，调用它。</p></li><li><p>否则，该方法调用 layoutManager 属性对象(Mac OS API)的 layoutSublayersOfLayer: 方法。 </p></li></ul><h4 id="3-4-2-setNeedsLayout-做标记"><a href="#3-4-2-setNeedsLayout-做标记" class="headerlink" title="3.4.2 -setNeedsLayout(做标记)"></a>3.4.2 -setNeedsLayout(做标记)</h4><p>使图层的布局无效并将其标记为需要更新。会在下一个更新周期中触发布局更新。系统调用任何需要布局更新的图层的 layoutSublayers 方法。</p><p>当图层的边界发生变化或添加或删除子图层时，系统通常会自动调用此方法。   </p><h4 id="3-4-3-layoutIfNeeded-立即"><a href="#3-4-3-layoutIfNeeded-立即" class="headerlink" title="3.4.3 -layoutIfNeeded(立即)"></a>3.4.3 -layoutIfNeeded(立即)</h4><p> 如果需要，立即重新计算图层的布局。</p><p> 收到此消息后，将遍历该图层的父图层，直到找到不需要布局的祖先图层。然后在该祖先下的整个层树上执行布局。</p><h3 id="3-5-布局重新计算-—-View方法"><a href="#3-5-布局重新计算-—-View方法" class="headerlink" title="3.5 布局重新计算 — View方法"></a>3.5 布局重新计算 — View方法</h3><h4 id="3-5-1-layoutSubviews"><a href="#3-5-1-layoutSubviews" class="headerlink" title="3.5.1 -layoutSubviews"></a>3.5.1 -layoutSubviews</h4><p>默认实现使用您设置的任何约束来确定每一个子视图的大小和位置。</p><p>子类可以根据需要覆盖此方法以对其子视图执行更精确的布局。 仅当子视图的自动调整大小和基于约束的行为不提供您想要的行为时，您才应该覆盖此方法。 您可以使用您的实现直接设置子视图的框架矩形。</p><p>您<strong>不应直接调用</strong>此方法。 如果要强制更新布局，请在下一次绘图更新之前调用 setNeedsLayout 方法。 如果您想立即更新视图的布局，请调用 layoutIfNeeded 方法。</p><h4 id="3-5-2-setNeedsLayout-做标记"><a href="#3-5-2-setNeedsLayout-做标记" class="headerlink" title="3.5.2 -setNeedsLayout(做标记)"></a>3.5.2 -setNeedsLayout(做标记)</h4><p>使当前布局无效并在下一个更新周期触发布局更新。</p><p>当您想要调整视图子视图的布局时，请<strong>在应用程序的主线程上调用此方法</strong>。此方法记录请求并立即返回。</p><p>由于此方法不会强制立即更新，而是等待下一个更新周期，因此您可以使用它在更新任何视图之前使多个视图的布局无效。此行为<strong>允许您将所有布局更新合并到一个更新周期，这通常对性能更好</strong>。</p><h4 id="3-5-3-layoutIfNeeded-立即"><a href="#3-5-3-layoutIfNeeded-立即" class="headerlink" title="3.5.3 -layoutIfNeeded(立即)"></a>3.5.3 -layoutIfNeeded(立即)</h4><p>如果有待办的(pending)布局更新，则立即布局子视图。</p><p>使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改。用接收此消息的视图作为根视图开始布局视图子树。</p><p>如果没有待处理的布局更新，则此方法退出而不修改布局或调用任何与布局相关的回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做&lt;em&gt;Layer Kit&lt;/em&gt;这么一个不怎么和动画有关的名字演变而来。&lt;/p&gt;
&lt;p&gt;Core Animation是一个&lt;em&gt;复合引擎&lt;/em&gt;，它的职责就是尽</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] AFN框架实现解析</title>
    <link href="https://tenloy.github.io/2021/09/05/AFN-Analyse.html"/>
    <id>https://tenloy.github.io/2021/09/05/AFN-Analyse.html</id>
    <published>2021-09-05T18:53:12.000Z</published>
    <updated>2021-12-03T08:23:35.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">原文链接</a>，有一些细节修改</p></blockquote><img src="/images/AFN/AFN-01.png" alt="img" style="zoom:70%;" /><ul><li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li><li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li><li>本文将从源码的角度去分析AF的实际作用。 <strong>或许看完这篇文章，你心里会有一个答案。</strong></li></ul><h1 id="一、框架结构"><a href="#一、框架结构" class="headerlink" title="一、框架结构"></a>一、框架结构</h1><p>先从最新的AF3.x讲起吧：</p><p>首先，我们就一起分析一下该框架的组成。 将AF下载导入工程后，下面是AF代码结构图，相对于2.x变得非常简单了：</p><img src="/images/AFN/AFN-02.jpg" alt="img" style="zoom:60%;" /><p>除去Support Files，可以看到AF分为如下5个功能模块：</p><ul><li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li><li>网络状态监听模块(Reachability)</li><li>网络通信安全策略模块(Security)</li><li>网络通信信息序列化/反序列化模块(Serialization)</li><li>对于iOS UIKit库的扩展(UIKit)</li></ul><p>这五个模块所对应的类的结构关系图（AF架构图）如下所示：</p><ul><li><strong>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</strong></li><li>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></li></ul><img src="/images/AFN/AFN-03.jpg" alt="img" style="zoom:55%;" /><h1 id="二、AFURL-amp-HTTPSessionManager"><a href="#二、AFURL-amp-HTTPSessionManager" class="headerlink" title="二、AFURL&amp;HTTPSessionManager"></a>二、AFURL&amp;HTTPSessionManager</h1><h2 id="2-1-AFHTTPSessionManager的初始化"><a href="#2-1-AFHTTPSessionManager的初始化" class="headerlink" title="2.1 AFHTTPSessionManager的初始化"></a>2.1 AFHTTPSessionManager的初始化</h2><h3 id="2-1-1-初始化源码"><a href="#2-1-1-初始化源码" class="headerlink" title="2.1.1 初始化源码"></a>2.1.1 初始化源码</h3><p>首先我们简单的写个get请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:<span class="string">@&quot;http://localhost&quot;</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="1-AFHTTPSessionManager"><a href="#1-AFHTTPSessionManager" class="headerlink" title="1. AFHTTPSessionManager"></a>1. AFHTTPSessionManager</h4><p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:url sessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span> sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化都调用到这个方法中来了</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li><li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li></ul><h4 id="2-AFURLSessionManager"><a href="#2-AFURLSessionManager" class="headerlink" title="2. AFURLSessionManager"></a>2. AFURLSessionManager</h4><p>直接来到父类AFURLSessionManager的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">      configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">  <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">  <span class="comment">// 重点：这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span></span><br><span class="line">  <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//各种响应转码</span></span><br><span class="line">  <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认安全策略</span></span><br><span class="line">  <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">  <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点2：这个字典是用来让每一个请求task和我们自定义的AF代理来建立映射用的。</span></span><br><span class="line">    <span class="comment">// 在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理</span></span><br><span class="line">    <span class="comment">// 其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span></span><br><span class="line">  <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点3：置空task关联的代理。</span></span><br><span class="line">    <span class="comment">// 作用：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。</span></span><br><span class="line">    <span class="comment">// 但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：https://github.com/AFNetworking/AFNetworking/issues/3499。原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</span></span><br><span class="line">  [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;        </span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-NSURLSession概述"><a href="#2-1-2-NSURLSession概述" class="headerlink" title="2.1.2 NSURLSession概述"></a>2.1.2 NSURLSession概述</h3><ul><li>用于替代 <code>NSURLConnection</code></li><li>支持后台运行的网络任务</li><li>暂停、停止、重启网络任务，不再需要 <code>NSOperation</code> 封装</li><li>请求可以使用同样的<code>配置容器</code></li><li>不同的 <code>session</code> 可以使用不同的私有存储</li><li><code>block</code> 和<code>代理</code>可以同时起作用</li><li>直接从文件系统上传、下载</li><li>为了方便程序员使用，苹果提供了一个全局 <code>session</code></li><li>所有的 <code>任务(Task)</code> 都是由 <code>Session</code> 发起的</li><li>所有的任务默认是<code>挂起</code>的，需要 <code>Resume</code></li></ul><p>协议支持：</p><ul><li>NSURLSession 类支持data、file、ftp、http 和 https URL schemes，透明支持代理服务器和 SOCKS 网关，如用户系统首选项中配置的那样。</li><li>NSURLSession 支持 HTTP/1.1、HTTP/2 和 HTTP/3 协议。 如 RFC 7540 所述，HTTP/2 支持需要支持应用层协议协商 (ALPN) 的服务器。</li><li>还可以通过继承 NSURLProtocol 来添加对开发者自定义的网络协议和 URL 方案的支持（供您的应用程序私人使用）。</li></ul><p>线程安全：</p><p>URL Session API 是线程安全的。 可以在任何线程上下文中自由创建 sessions 和 tasks。 当调用提供的 completion handlers 时，工作会自动安排在正确的 delegate queue 中。</p><h3 id="2-1-3-NSURLSessionConfigration概述"><a href="#2-1-3-NSURLSessionConfigration概述" class="headerlink" title="2.1.3 NSURLSessionConfigration概述"></a>2.1.3 NSURLSessionConfigration概述</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">    configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration。会话配置文件用于设置网络会话属性，包括：身份验证，超时时长，缓存策略，Cookie等。</p><h4 id="1-三种模式"><a href="#1-三种模式" class="headerlink" title="1. 三种模式"></a>1. 三种模式</h4><p>NSURLSessionConfiguration有三个类工厂方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通模式（default）：返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//临时模式（ephemeral）：返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//后台模式（background）：特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在按下home键后，即应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfiguration:(<span class="built_in">NSString</span> *)identifier; </span><br></pre></td></tr></table></figure><p>一般基本上都是使用默认设置。</p><h4 id="2-HTTPMaximumConnectionsPerHost属性"><a href="#2-HTTPMaximumConnectionsPerHost属性" class="headerlink" title="2. HTTPMaximumConnectionsPerHost属性"></a>2. HTTPMaximumConnectionsPerHost属性</h4><p>与给定主机建立的最大同时连接数。</p><p>此属性决定了根据本configuration创建的 sessions 中的任务与每个主机建立的最大同时连接数。</p><p>此限制是针对每个 session 的，因此如果使用了多个 session，那应用程序作为一个整体可能会超过此限制。 此外，根据与 Internet 的连接，session 使用的限制可能低于指定的限制。</p><p>macOS 中的默认值为 6，iOS 中的默认值为 4。</p><ul><li>如果 session 是用上面三个类工厂方法创建的，那么将共享 HTTPMaximumConnectionsPerHost 的设置，即最后一次的配置为所有session使用的最终的配置。</li><li>最好不要为了增加并发而创建多个Session，创建多个Session的目的应该是为了对不同的Task使用不同的策略，来实现更符合我们需求的交互。</li></ul><h3 id="2-1-4-AF-maxConcurrentOperationCount设置"><a href="#2-1-4-AF-maxConcurrentOperationCount设置" class="headerlink" title="2.1.4 AF maxConcurrentOperationCount设置"></a>2.1.4 AF maxConcurrentOperationCount设置</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里先说结论，有些内容是在下面陈述的：</p><ul><li><p>首先我们要明确一个概念，<strong>这里的并发数仅仅是回调代理的线程并发数。而不是请求网络的线程并发数。请求网络是由NSURLSession来做的，它内部维护了一个线程池，用来做网络请求</strong>。它调度线程，基于底层的CFSocket去发送请求和接收数据。这些<strong>线程是并发的</strong>。</p></li><li><p>明确了这个概念之后，我们来梳理一下AF3.x的整个流程和线程的关系：</p><ul><li>我们一开始初始化sessionManager的时候，一般都是在主线程，（当然不排除有些人喜欢在分线程初始化…）</li><li>然后我们调用get或者post等去请求数据，接着会进行request拼接，AF代理的字典映射，progress的KVO添加等等，到NSUrlSession的resume之前这些准备工作，仍旧是在主线程中的。</li><li>然后我们调用NSUrlSession的resume，接着就跑到NSUrlSession内部去对网络进行数据请求了,在它内部是多线程并发的去请求数据的。</li><li>紧接着数据请求完成后，回调回来在我们一开始生成的并发数为1的NSOperationQueue中，这个时候会是多线程串行的回调回来的。（注：不明白的朋友可以看看雷纯峰大神这篇<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues</a>）</li><li>然后我们到返回数据解析那一块，我们自己又创建了并发的多线程，去对这些数据进行了各种类型的解析。</li><li>最后我们如果有自定义的completionQueue，则在自定义的queue中回调回来，也就是分线程回调回来，否则就是主队列，主线程中回调结束。</li></ul></li><li><p>最后我们来解释解释为什么回调Queue要设置并发数为1：个人认为AF这么做有以下两点原因：</p><ul><li><p>众所周知，AF2.x所有的回调是在一条线程（<em>参考6.7小节</em>），这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。</p></li><li><p>因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。<strong>反而多task回调导致的多线程并发，平白浪费了部分性能。</strong></p><p>而设置Queue的并发数为1（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFURLSessionManager的那些方法）至少回调的事件，是不需要多线程并发的。<strong>回调没有了NSLock的等待时间，所以对时间并没有多大的影响。</strong></p></li><li><p>注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程：<font color='red'>response的解析是并发线程执行的</font>（<em>参考2.3.6-1小节</em>）。</p></li></ul></li></ul><p>初始化方法到这就全部完成了。</p><h2 id="2-2-AFHTTPSessionManager创建GET-Task"><a href="#2-2-AFHTTPSessionManager创建GET-Task" class="headerlink" title="2.2 AFHTTPSessionManager创建GET Task"></a>2.2 AFHTTPSessionManager创建GET Task</h2><h3 id="2-2-1-源码实现"><a href="#2-2-1-源码实现" class="headerlink" title="2.2.1 源码实现"></a>2.2.1 源码实现</h3><p>接着我们来看看网络请求:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//生成一个系统的NSURLSessionDataTask实例</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始网络请求</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                          uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                        downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                 success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                 failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 用self.requestSerializer把各种参数转化为一个我们最终请求网络需要的NSMutableURLRequest实例。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span>  <span class="comment">// 这里是用来忽略 ?: 带来的警告</span></span></span><br><span class="line">            <span class="comment">// 当解析错误，我们直接调用传进来的 failure 的 Block 失败返回了，这里有一个 self.completionQueue ，这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</span></span><br><span class="line">            <span class="comment">// 实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-AFURLRequestSerialization创建request"><a href="#2-2-2-AFURLRequestSerialization创建request" class="headerlink" title="2.2.2 AFURLRequestSerialization创建request"></a>2.2.2 AFURLRequestSerialization创建request</h3><p>AFURLRequestSerialization文件中定义了三个请求参数序列化的类：</p><ul><li>AFHTTPRequestSerializer<ul><li>符合 <code>AFURLRequestSerialization</code> 和 <code>AFURLResponseSerialization</code> 协议，提供 query 字符串 / URL form-encoded 参数序列化和默认请求头的具体基础实现，以及响应状态代码和内容类型验证。</li><li>鼓励任何处理 HTTP 请求序列化的程序继承 <code>AFHTTPRequestSerializer</code> ，以确保一致的默认行为。</li><li>当请求的 Content-Type 是 <code>application/x-www-form-urlencoded</code> 时使用。<font color='red'>默认</font></li></ul></li><li>AFJSONRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSJSONSerialization</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/json</code>。</li><li>当请求的 Content-Type 是 <code>application/json</code> 时使用。</li></ul></li><li>AFPropertyListRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSPropertyListSerializer</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/x-plist</code>。</li><li>当请求的 Content-Type 是 <code>application/x-plist</code> 时使用。</li></ul></li></ul><p>此处主要看的也是 AFHTTPRequestSerializer 序列化类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，debug模式下，如果缺少改参数，crash</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将request的各种观察属性循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="comment">//如果该观察属性已经发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           <span class="comment">//把给自己设置的属性给request设置</span></span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲一下这个方法，这个方法做了3件事：</p><h4 id="1-设置request请求类型"><a href="#1-设置request请求类型" class="headerlink" title="1. 设置request请求类型"></a>1. 设置request请求类型</h4><p>设置request的请求类型，get、post、put…等</p><h4 id="2-添加request配置参数"><a href="#2-添加request配置参数" class="headerlink" title="2. 添加request配置参数"></a>2. 添加request配置参数</h4><p>往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span></span><br><span class="line">    <span class="comment">// HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//就是一个数组里装了很多方法的名字,</span></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个函数就是封装了一些属性的名字，这些都是NSURLRequest的属性。</p><p>再来看看<code>self.mutableObservedChangedKeyPaths</code>，这个是 AFHTTPRequestSerializer 类的一个属性，在 init 方法中对这个集合进行了初始化，<strong>并对当前类的和NSURLRequest相关的那些属性添加了KVO监听</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *mutableObservedChangedKeyPaths;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 每次都会重置变化</span></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给这些key添加观察者为自己，就是request的各种属性，set方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO触发的方法：</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span></span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。</p><p>接下来调用下面的代码，用KVC的方式，把属性值都设置到我们请求的request中去。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure><h4 id="3-编码及设置请求参数"><a href="#3-编码及设置请求参数" class="headerlink" title="3. 编码及设置请求参数"></a>3. 编码及设置请求参数</h4><p>把需要传递的参数进行编码，并且设置到request中去：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从自己的head里去遍历，如果有值则设置给request的head</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来把各种类型的参数，array dic set转化成字符串，给request</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">//自定义的解析方式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认解析方式</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//post put请求</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了3件事：</p><h5 id="1-设置header中的参数"><a href="#1-设置header中的参数" class="headerlink" title="1) 设置header中的参数"></a>1) 设置header中的参数</h5><p>从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去</p><h5 id="2-将请求参数转换为字符串"><a href="#2-将请求参数转换为字符串" class="headerlink" title="2) 将请求参数转换为字符串"></a>2) 将请求参数转换为字符串</h5><p>把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span></span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分数组返回参数字符串</span></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="comment">//往下调用</span></span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span></span><br><span class="line">    <span class="comment">// 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span></span><br><span class="line">    <span class="comment">// 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;description&quot;</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[%@]&quot;</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[]&quot;</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</p><p>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.field = field;</span><br><span class="line">    <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@=%@&quot;</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     <span class="string">@&quot;phone&quot;</span>: @&#123;<span class="string">@&quot;mobile&quot;</span>: <span class="string">@&quot;xx&quot;</span>, <span class="string">@&quot;home&quot;</span>: <span class="string">@&quot;xx&quot;</span>&#125;, </span><br><span class="line">     <span class="string">@&quot;families&quot;</span>: @[<span class="string">@&quot;father&quot;</span>, <span class="string">@&quot;mother&quot;</span>], </span><br><span class="line">     <span class="string">@&quot;nums&quot;</span>: [NSSet setWithObjects:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: <span class="string">@&quot;name&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[mobile]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[home]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;father&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;mother&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;1&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;2&quot;</span>, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=<span class="number">1</span>&amp;num=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p><h5 id="3-根据请求类型设置请求参数"><a href="#3-根据请求类型设置请求参数" class="headerlink" title="3) 根据请求类型设置请求参数"></a>3) 根据请求类型设置请求参数</h5><p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//post put请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求体</span></span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们生成了一个request。</p><h3 id="2-2-3-AFURLSessionManger父类创建task"><a href="#2-2-3-AFURLSessionManger父类创建task" class="headerlink" title="2.2.3 AFURLSessionManger父类创建task"></a>2.2.3 AFURLSessionManger父类创建task</h3><p>现在弄清楚request的创建流程中，我们跳出当前方法，再回到上层AFHTTPSessionManager类中的 <code>dataTaskWithHTTPMethod:URLString:...</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                      uploadProgress:uploadProgress</span><br><span class="line">                    downloadProgress:downloadProgress</span><br><span class="line">                   completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            failure(dataTask, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(dataTask, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这是调用了继承自父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                    uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                  downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                 completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//第一件事，创建NSURLSessionDataTask，里面适配了iOS 8以下taskIdentifiers，函数创建task对象。</span></span><br><span class="line">    <span class="comment">//其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span></span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</p><h4 id="1-create-task-safely"><a href="#1-create-task-safely" class="headerlink" title="1. create_task_safely()"></a>1. create_task_safely()</h4><p>我们到这先到这个函数里去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="comment">// Fix of bug</span></span><br><span class="line">        <span class="comment">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line">        <span class="comment">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span></span><br><span class="line">      <span class="comment">//第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span></span><br><span class="line">      <span class="comment">//这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">//保证了即使是在多线程的环境下，也不会创建其他队列</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.creation&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用 <code>dataTask = [self.session dataTaskWithRequest:request];</code> 非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</p><p><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</p><p>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</p><h4 id="2-addDelegateForDataTask"><a href="#2-addDelegateForDataTask" class="headerlink" title="2. addDelegateForDataTask:"></a>2. addDelegateForDataTask:</h4><p>我们接着看到：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure><p>一起来看一下主要的调用流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</span><br><span class="line">﹂setDelegate:forTask:</span><br><span class="line">﹂setupProgressForTask:</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 生成一个AFURLSessionManagerTaskDelegate，这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系。代理把AFURLSessionManager这个类作为属性了，属性是weak声明的，所以不会存在循环引用的问题。</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. ***** 将AF delegate对象与 dataTask建立关系</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置AF delegate的上传进度，下载进度块。</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，如果没有这个参数，debug下crash在这</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁保证字典线程安全。要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为AF delegate 设置task 的progress监听</span></span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加task开始和暂停的通知</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为task设置progress</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 设置 downloadProgress 与 uploadProgress 的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么...）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//拿到上传下载期望的数据大小</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span></span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.downloadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 给task和progress的各个属及添加KVO监听</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//观察task的这些属性</span></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察progress这两个属性</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                            forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                               context:<span class="literal">NULL</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                          forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                             options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                             context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KVO 触发的监听方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是task</span></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]] || [object isKindOfClass:[<span class="built_in">NSURLSessionDownloadTask</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//给进度条赋新值</span></span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的赋新值会触发这两个，调用block回调，用户拿到进度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单直观，主要就是如果task触发KVO，则给progress进度赋值，因为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</p><p>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</p><p>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</p><p>到这里我们整个对task的处理就完成了。</p><h2 id="2-3-AFURLSessionManager中Session代理实现及转发"><a href="#2-3-AFURLSessionManager中Session代理实现及转发" class="headerlink" title="2.3 AFURLSessionManager中Session代理实现及转发"></a>2.3 AFURLSessionManager中Session代理实现及转发</h2><h3 id="2-3-1-代理方法概览"><a href="#2-3-1-代理方法概览" class="headerlink" title="2.3.1 代理方法概览"></a>2.3.1 代理方法概览</h3><p>接着task就开始请求网络了，还记得我们初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，下图这些NSUrlSession的代理开始调用了：</p><img src="/images/AFN/AFN-04.jpg" alt="img" style="zoom:60%;" /><p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p><p>而只转发了其中3条到下图中AF自定义的delegate中：</p><img src="/images/AFN/AFN-05.jpg" alt="img" style="zoom:60%;" /><p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p><p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSURLSession这么多代理呢？我们点到NSURLSession.h中去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionTaskDelegate</span> &lt;<span class="title">NSURLSessionDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDataDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDownloadDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionStreamDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</p><p>而AF还重写了<code>respondsToSelector</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复写了selector的方法，这几个方法是在本类有实现的，但这些代理方法实现中只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。所以返回NO，相当于没有实现！也就不会去回调这些代理。</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:willCacheResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSessionDidFinishEventsForBackgroundURLSession:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[self <span class="class"><span class="keyword">class</span>] <span class="title">instancesRespondToSelector</span>:<span class="type">selector];</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这，我们顺便看看AFURLSessionManager的一些自定义Block：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure><p>各自对应的还有一堆这样的set方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法都是一样的，就不重复粘贴占篇幅了。主要谈谈这个设计思路</p><ul><li>作者用@property把这些Block属性在.m文件中声明，然后复写了set方法。</li><li>然后在.h中去声明这些set方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br></pre></td></tr></table></figure><p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p><p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p><h3 id="2-3-2-NSURLSessionDelegate实现"><a href="#2-3-2-NSURLSessionDelegate实现" class="headerlink" title="2.3.2 NSURLSessionDelegate实现"></a>2.3.2 NSURLSessionDelegate实现</h3><h4 id="01-URLSession-didBecomeInvalidWithError"><a href="#01-URLSession-didBecomeInvalidWithError" class="headerlink" title="01. URLSession:didBecomeInvalidWithError"></a>01. URLSession:didBecomeInvalidWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前这个session已经失效时，该代理方法被调用。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span></span><br><span class="line"><span class="comment"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span></span><br><span class="line"><span class="comment"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li><li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li></ul><h4 id="02-URLSession-didReceiveChallenge"><a href="#02-URLSession-didReceiveChallenge" class="headerlink" title="02. URLSession:didReceiveChallenge"></a>02. URLSession:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、用作https认证的，详细看第四节AFSecurityPolicy</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-URLSessionDidFinishEventsForBackgro"><a href="#03-URLSessionDidFinishEventsForBackgro" class="headerlink" title="03. URLSessionDidFinishEventsForBackgro.."></a>03. URLSessionDidFinishEventsForBackgro..</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li>函数讨论：<ul><li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler: 消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li><li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li></ul></li></ul><h3 id="2-3-3-NSURLSessionTaskDelegate实现"><a href="#2-3-3-NSURLSessionTaskDelegate实现" class="headerlink" title="2.3.3 NSURLSessionTaskDelegate实现"></a>2.3.3 NSURLSessionTaskDelegate实现</h3><h4 id="04-URLSession-task-willPerformHTTPRedirection"><a href="#04-URLSession-task-willPerformHTTPRedirection" class="headerlink" title="04. URLSession:task:willPerformHTTPRedirection"></a>04. URLSession:task:willPerformHTTPRedirection</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被服务器重定向的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        <span class="comment">//用自己自定义的一个重定向的block实现，返回一个新的request。</span></span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        <span class="comment">// step2. 用request重新请求</span></span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">&#x27;BASEPATH&#x27;</span>) <span class="keyword">OR</span> <span class="keyword">exit</span>(<span class="string">&#x27;No direct script access allowed&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        header(<span class="string">&quot;location: http://www.huixionghome.cn/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p><p>关于这个代理还有一些需要注意的地方：此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。（这里指的模式是我们一开始初始化 session时的模式）。</p><h4 id="05-URLSession-task-didReceiveChallenge"><a href="#05-URLSession-task-didReceiveChallenge" class="headerlink" title="05.URLSession:task:didReceiveChallenge"></a>05.URLSession:task:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https认证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：</p><ul><li>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li><li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li><li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li></ul><h4 id="06-URLSession-task-needNewBodyStream"><a href="#06-URLSession-task-needNewBodyStream" class="headerlink" title="06. URLSession:task:needNewBodyStream"></a>06. URLSession:task:needNewBodyStream</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代理方法会在下面两种情况被调用：</p><ol><li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li><li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li></ol><h4 id="07-URLSession-task-didSendBodyData"><a href="#07-URLSession-task-didSendBodyData" class="headerlink" title="07. URLSession:task:didSendBodyData"></a>07. URLSession:task:didSendBodyData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 周期性地通知代理发送到服务器端数据的进度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span></span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Length&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li><li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li></ul><h4 id="08-URLSession-task-didCompleteWithError"><a href="#08-URLSession-task-didCompleteWithError" class="headerlink" title="08. URLSession:task:didCompleteWithError"></a>08. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> task完成之后的回调，成功和失败都会回调这里</span></span><br><span class="line"><span class="comment"> 函数讨论：</span></span><br><span class="line"><span class="comment"> 注意这里的error不会报告服务期端的error，他表示的是客户端这边的error，比如无法解析hostname或者连不上host主机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//根据task去取我们一开始创建绑定的delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//把代理转发给我们绑定的delegate</span></span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        <span class="comment">//转发完移除delegate</span></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Block回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理就是task完成了的回调，方法内做了下面这几件事：</p><ul><li><p>在这里我们拿到了之前和这个task对应绑定的AF的delegate:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>去转发了调用了AF代理的方法。这个等我们下面讲完NSUrlSession的代理之后会详细说。</p></li><li><p>然后把这个AF的代理和task的绑定解除了，并且移除了相关的progress和通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">  <span class="comment">//移除跟AF代理相关的东西</span></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  [delegate cleanUpProgressForTask:task];</span><br><span class="line">  [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用了自定义的Blcok:self.taskDidComplete(session, task, error);</p><p>代码还是很简单的，至于这个通知，我们等会再来补充吧。</p></li></ul><h3 id="2-3-4-NSURLSessionDataDelegate实现"><a href="#2-3-4-NSURLSessionDataDelegate实现" class="headerlink" title="2.3.4 NSURLSessionDataDelegate实现"></a>2.3.4 NSURLSessionDataDelegate实现</h3><h4 id="09-URLSession-dataTask-didReceiveResponse"><a href="#09-URLSession-dataTask-didReceiveResponse" class="headerlink" title="09. URLSession:dataTask:didReceiveResponse"></a>09. URLSession:dataTask:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务器响应后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置默认为继续进行</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义去设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><p>函数作用：告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：</p><ul><li>NSURLSessionResponseAllow 该task正常进行</li><li>NSURLSessionResponseCancel 该task会被取消</li><li>NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task</li><li>NSURLSessionResponseBecomeStream 转成一个StreamTask</li></ul><p>函数讨论：</p><p>该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。</p><p>总结一下：</p><ul><li>当你把添加content-type的类型为 multipart/x-mixed-replace 那么服务器的数据会分片的传回来。然后这个方法是每次接受到对应片响应的时候会调被调用。你可以去设置上述4种对这个task的处理。</li><li>如果我们实现了自定义Block，则调用一下，不然就用默认的NSURLSessionResponseAllow方式。</li></ul><h4 id="10-URLSession-dataTask-didBecomeDownloadTask"><a href="#10-URLSession-dataTask-didBecomeDownloadTask" class="headerlink" title="10. URLSession:dataTask:didBecomeDownloadTask"></a>10. URLSession:dataTask:didBecomeDownloadTask</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代理如果设置为NSURLSessionResponseBecomeDownload，则会触发调用这个方法，作用就是新建一个downloadTask，替换掉当前的dataTask。所以我们在这里做了AF自定义代理的重新绑定操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为转变了task，所以要对task做一个重新绑定</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照顺序来，其实还有个AF没有去实现的代理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF没实现的代理</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeStreamTask:(<span class="built_in">NSURLSessionStreamTask</span> *)streamTask;</span><br></pre></td></tr></table></figure><p>这个也是之前的那个代理，设置为NSURLSessionResponseBecomeStream则会调用到这个代理里来。会新生成一个NSURLSessionStreamTask来替换掉之前的dataTask。</p><h4 id="11-URLSession-dataTask-didReceiveData"><a href="#11-URLSession-dataTask-didReceiveData" class="headerlink" title="11. URLSession:dataTask:didReceiveData"></a>11. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们获取到数据就会调用，会被反复调用，请求到的数据就在这被拼装完整</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和上面didCompleteWithError算是NSUrlSession的代理中最重要的两个方法了。</p><p>我们转发了这个方法到AF的代理中去，所以数据的拼接都是在AF的代理中进行的。这也是情理中的，毕竟每个响应数据都是对应各个task，各个AF代理的。在AFURLSessionManager都只是做一些公共的处理。</p><h4 id="12-URLSession-dataTask-willCacheResponse"><a href="#12-URLSession-dataTask-willCacheResponse" class="headerlink" title="12. URLSession:dataTask:willCacheResponse"></a>12. URLSession:dataTask:willCacheResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当task接收到所有期望的数据后，session会调用此代理方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><ul><li><p>函数作用：</p><ul><li>询问data task或上传任务（upload task）是否缓存response。</li></ul></li><li><p>函数讨论：</p><ul><li>当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。</li><li>该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：<ul><li>该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）</li><li>确保request请求是成功的（返回的status code为200-299）</li><li>返回的response是来自服务器端的，而非缓存中本身就有的</li><li>提供的NSURLRequest对象的缓存策略要允许进行缓存</li><li>服务器返回的response中与缓存相关的header要允许缓存</li><li>该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）</li></ul></li></ul></li><li><p>总结一下就是一个用来缓存response的方法，方法中调用了我们自定义的Block，自定义一个response用来缓存。</p></li></ul><h3 id="2-3-5-NSURLSessionDownloadDelegate实现"><a href="#2-3-5-NSURLSessionDownloadDelegate实现" class="headerlink" title="2.3.5 NSURLSessionDownloadDelegate实现"></a>2.3.5 NSURLSessionDownloadDelegate实现</h3><h4 id="13-URLSession-downloadTask-didFinishDown…"><a href="#13-URLSession-downloadTask-didFinishDown…" class="headerlink" title="13. URLSession:downloadTask:didFinishDown…"></a>13. URLSession:downloadTask:didFinishDown…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载完成的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//这个是session的，也就是全局的，后面的个人代理也会做同样的这件事</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用自定义的block拿到文件存储的地址</span></span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">//从临时的下载路径移动至我们需要的路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            <span class="comment">//如果移动出错</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发代理</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和之前的两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)taskdidCompleteWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure><p>总共就这3个方法，被转调到AF自定义delegate中。</p><p>方法做了什么看注释应该很简单，就不赘述了。</p><h4 id="14-URLSession-downloadTask-didWriteData"><a href="#14-URLSession-downloadTask-didWriteData" class="headerlink" title="14. URLSession:downloadTask:didWriteData"></a>14. URLSession:downloadTask:didWriteData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//周期性地通知下载进度调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下这几个参数:</p><ul><li>bytesWritten表示自上次调用该方法后，接收到的数据字节数</li><li>totalBytesWritten表示目前已经接收到的数据字节数</li><li>totalBytesExpectedToWrite表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown。</li></ul><h4 id="15-URLSession-downloadTask-didResumeAtOffset"><a href="#15-URLSession-downloadTask-didResumeAtOffset" class="headerlink" title="15. URLSession:downloadTask:didResumeAtOffset"></a>15. URLSession:downloadTask:didResumeAtOffset</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当下载被取消或者失败后重新恢复下载时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交给自定义的Block去调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li><p>函数作用：</p><ul><li>告诉代理，下载任务重新开始下载了。</li></ul></li><li><p>函数讨论：</p><ul><li>如果一个正在下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。</li><li>随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。</li></ul></li></ul><p>总结一下：</p><ul><li><strong>其实这个就是用来做断点续传的代理方法。</strong>可以在下载失败的时候，拿到我们失败的拼接的部分resumeData，然后用去调用downloadTaskWithResumeData：就会调用到这个代理方法来了。</li><li>其中注意：fileOffset这个参数，如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。否则，该值表示当前已经下载data的偏移量。</li><li>方法中仅仅调用了downloadTaskDidResume自定义Block。</li></ul><p>至此NSUrlSesssion的delegate讲完了。大概总结下：</p><ul><li>每个代理方法对应一个我们自定义的Block,如果Block被赋值了，那么就调用它。</li><li>在这些代理方法里，我们做的处理都是相对于这个sessionManager所有的request的。<strong>是公用的处理。</strong></li><li>转发了3个代理方法到AF的deleagate中去了，AF中的deleagate是需要对应每个task去<strong>私有化处理的</strong>。</li></ul><h3 id="2-3-6-转发到AFURLSxxMxxTaskDelegate的方法"><a href="#2-3-6-转发到AFURLSxxMxxTaskDelegate的方法" class="headerlink" title="2.3.6 转发到AFURLSxxMxxTaskDelegate的方法"></a>2.3.6 转发到AFURLSxxMxxTaskDelegate的方法</h3><p>接下来我们来看从 AFURLSessionManager 中转发到 AFURLSessionManagerTaskDelegate 的deleagate，一共3个方法：</p><h4 id="1-URLSession-task-didCompleteWithError"><a href="#1-URLSession-task-didCompleteWithError" class="headerlink" title="1. URLSession:task:didCompleteWithError"></a>1. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF实现的代理！被从urlsession那转发到这</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block</span></span><br><span class="line"></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储一些相关信息，来发送通知用的</span></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//存储responseSerializer响应解析对象</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续给userinfo填数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以自己自定义完成组 和自定义完成queue,完成回调</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//主线程中发送完成通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//url_session_manager_processing_queue AF的并行队列</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析数据</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是下载文件，那么responseObject为下载的路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入userInfo</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果解析错误</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回调结果</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是NSURLSession任务完成的代理方法中，主动调用过来的。配合注释，应该代码很容易读，这个方法大概做了以下几件事：</p><ol><li><p>生成了一个存储这个task相关信息的字典：userInfo，这个字典是用来作为发送任务完成的通知的参数。</p></li><li><p>判断了参数error的值，来区分请求成功还是失败。</p></li><li><p>如果成功则在一个AF的并行queue中，去做数据解析等后续操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意AF的优化的点：<font color='red'>虽然代理回调是串行的(参考2.1.4小节 maxConcurrentOperationCount属性)。但是数据解析这种费时操作，确是用并行线程来做的。</font></p></li><li><p>然后根据我们一开始设置的responseSerializer来解析data。如果解析成功，调用成功的回调，否则调用失败的回调。我们重点来看看返回数据解析这行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br></pre></td></tr></table></figure><p>我们点进去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                         data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>原来就是这么一个协议方法，各种类型的responseSerializer类，都是遵守这个协议方法，实现了一个把我们请求到的data转换为我们需要的类型的数据的方法。至于各种类型的responseSerializer如何解析数据，我们到代理讲完再来补充。</p></li><li><p>这边还做了一个判断，如果自定义了GCD完成组completionGroup和完成队列的话completionQueue，会在加入这个组和在队列中回调Block。否则默认的是AF的创建的组：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和主队列回调。<strong>AF没有用这个GCD组做任何处理，只是提供这个接口，让我们有需求的自行调用处理。</strong>如果有对多个任务完成度的监听，可以自行处理。<br>而队列的话，如果你不需要回调主线程，可以自己设置一个回调队列。</p></li><li><p>回到主线程，发送了任务完成的通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>这个通知这回AF有用到了，在我们对UIKit的扩展中，用到了这个通知。</p></li></ol><h4 id="2-URLSession-dataTask-didReceiveData"><a href="#2-URLSession-dataTask-didReceiveData" class="headerlink" title="2. URLSession:dataTask:didReceiveData"></a>2. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拼接数据</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样被NSUrlSession代理转发到这里，拼接了需要回调的数据。</p><h4 id="3-URLSession-downloadTask-didFinishDownload…"><a href="#3-URLSession-downloadTask-didFinishDownload…" class="headerlink" title="3. URLSession:downloadTask:didFinishDownload…"></a>3. URLSession:downloadTask:didFinishDownload…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF代理的自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//得到自定义下载路径</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="comment">//把下载路径移动到我们自定义的下载路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误发通知</span></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载成功了被NSUrlSession代理转发到这里，这里有个地方需要注意下：</p><ul><li><p>之前的NSUrlSession代理和这里都移动了文件到下载路径，而NSUrlSession代理的下载路径是所有request公用的下载路径，一旦设置，所有的request都会下载到之前那个路径。</p></li><li><p>而这个是对应的每个task的，每个task可以设置各自下载路径,还记得AFHttpManager的download方法么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[manager downloadTaskWithRequest:resquest progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个地方return的path就是对应的这个代理方法里的path，我们调用最终会走到这么一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                     destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">  delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">  delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回地址的Block</span></span><br><span class="line">  <span class="keyword">if</span> (destination) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//有点绕，就是把一个block赋值给我们代理的downloadTaskDidFinishDownloading，这个Block里的内部返回也是调用Block去获取到的，这里面的参数都是AF代理传过去的。</span></span><br><span class="line">      delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">          <span class="comment">//把Block返回的地址返回</span></span><br><span class="line">          <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">  delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清楚的可以看到地址被赋值给AF的Block了。</p></li></ul><p>至此AF的代理也讲完了，<strong>数据或错误信息随着AF代理成功失败回调，回到了用户的手中。</strong></p><h2 id="2-4-AFURLSessionTaskSwizzling类"><a href="#2-4-AFURLSessionTaskSwizzling类" class="headerlink" title="2.4 _AFURLSessionTaskSwizzling类"></a>2.4 _AFURLSessionTaskSwizzling类</h2><p>在AFURLSessionManager中，有这么一个类：_AFURLSessionTaskSwizzling。这个类大概的作用就是替换掉NSURLSession中的resume和suspend方法。正常处理原有逻辑的同时，多发送一个通知，以下是我们需要替换的新方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被替换掉的方法，只要有TASK开启或者暂停，都会执行</span></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块知识是关于OC的Runtime:method swizzling的，如果有不清楚的地方，可以看看这里<a href="http://www.jianshu.com/p/db6dc23834e3">method swizzling–by冰霜</a>或者自行查阅。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionTask&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">&quot;-Wnonnull&quot;</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 2) 获取到af_resume实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 检查当前class是否实现了resume。如果实现了，继续第4步。</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 获取到当前class的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) 获取到当前class对于resume实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  6) 获取到父类对于resume实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                <span class="comment">//执行交换的函数</span></span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8) 设置当前操作的class为其父类class，重复步骤3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原方法中有大量的英文注释，我把它翻译过来如下：</p><ul><li><p>iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick</p><p>关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的</p></li><li><p>目前我们所知的：</p><ul><li>NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）</li><li>简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。</li><li>iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 <strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自__NSCFURLSessionTask。</li><li>iOS 8上，localDataTask的类型为<strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自NSURLSessionTask</li><li>iOS 7上，<strong>NSCFLocalSessionTask和</strong>NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外<strong>NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即</strong>NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。</li><li>iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类</li><li>因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。</li></ul></li><li><p>一些假设前提:</p><ul><li>目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理。</li><li>没有哪个后台task会重写resume和suspend函数</li></ul></li></ul><p>其余的一部分翻译在注释中，对应那一行代码。大概总结下这个注释：</p><ul><li>其实这是被社区大量讨论的一个bug，之前AF因为这个替换方法，会导致偶发性的crash，如果不要这个swizzle则问题不会再出现，但是这样会导致AF中很多UIKit的扩展都不能正常使用。</li><li><strong>原来这是因为iOS7和iOS8的NSURLSessionTask的继承链不同导致的，</strong>而且在iOS7继承链中会有两个类都实现了resume和suspend方法。而且子类没有调用父类的方法，我们则需要对着两个类都进行方法替换。而iOS8只需要对一个类进行替换。</li><li>对着注释看，上述方法代码不难理解，用一个while循环，一级一级去获取父类，如果实现了resume方法，则进行替换。</li></ul><p>但是有几个点大家可能会觉得疑惑的，我们先把这个方法调用的替换的函数一块贴出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其引用的交换的函数：</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有小伙伴问到过，所以我们来分析分析大家可能会觉得疑惑的地方：</p><ol><li><p>首先可以注意class_getInstanceMethod这个方法，它会获取到当前类继承链逐级往上，第一个实现的该方法。所以说它获取到的方法不能确定是当前类还是父类的。而且这里也没有用dispatch_once_t来保证一个方法只交换一次，那万一这是父类的方法，当前类换一次，父类又换一次，不是等于没交换么？…请注意这行判断：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line"><span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; </span><br><span class="line">      <span class="comment">//执行交换的函数</span></span><br><span class="line">     [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件就杜绝了这种情况的发生，只有当前类实现了这个方法，才可能进入这个if块。</p></li><li><p>那iOS7两个类都交换了af_resume，那岂不是父类换到子类方法了?…只能说又是没仔细看代码的…注意AF是去向当前类添加af_resume方法，然后去交换当前类的af_resume。所以说根本不会出现这种情况…</p></li></ol><h1 id="三、AFURLResponseSerialization"><a href="#三、AFURLResponseSerialization" class="headerlink" title="三、AFURLResponseSerialization"></a>三、AFURLResponseSerialization</h1><p>接下来我们来补充之前AFURLResponseSerialization这一块是如何解析数据的：</p><img src="/images/AFN/AFN-06.jpg" alt="img" style="zoom:70%;" /><p>如图所示，AF用来解析数据的一共上述这些方法。第一个实际是一个协议方法，协议方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>而后面6个类都是遵守这个协议方法，去做数据解析。**这地方可以再次感受一下AF的设计模式…**接下来我们就来主要看看这些类对这个协议方法的实现：</p><h2 id="3-1-AFHTTPResponseSerializer"><a href="#3-1-AFHTTPResponseSerializer" class="headerlink" title="3.1 AFHTTPResponseSerializer"></a>3.1 AFHTTPResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用了一个另外的方法之后，就把data返回来了，我们继续往里看这个方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是可接受类型和可接受code，不是则填充error</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//response是否合法标识</span></span><br><span class="line">  <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">//验证的error</span></span><br><span class="line">  <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果存在且是NSHTTPURLResponse</span></span><br><span class="line">  <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要判断自己能接受的数据类型和response的数据类型是否匹配，</span></span><br><span class="line">    <span class="comment">//如果有接受数据类型，如果不匹配response，而且响应类型不为空，数据长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">        !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入If块说明解析数据肯定是失败的，这时候要把解析错误信息放到error里。</span></span><br><span class="line">        <span class="comment">//如果数据长度大于0，而且有响应url</span></span><br><span class="line">        <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误信息字典，填充一些错误信息</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: unacceptable content-type: %@&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">            &#125; mutableCopy];</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成错误</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断自己可接受的状态吗</span></span><br><span class="line">    <span class="comment">//如果和response的状态码不匹配，则进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">        <span class="comment">//填写错误信息字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">             <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: %@ (%ld)&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">             <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">             AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">        &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成错误</span></span><br><span class="line">        validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给我们传过来的错误指针赋值</span></span><br><span class="line">  <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">      *error = validationError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回是否错误标识</span></span><br><span class="line">  <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看注释应该很容易明白这个方法有什么作用。简单来说，<strong>这个方法就是来判断返回数据与咱们使用的解析器是否匹配，需要解析的状态码是否匹配。</strong>如果错误，则填充错误信息，并且返回NO，否则返回YES，错误信息为nil。</li><li>其中里面出现了两个属性值，一个acceptableContentTypes，一个acceptableStatusCodes，两者在初始化的时候有给默认值，我们也可以去自定义，但是如果给acceptableContentTypes定义了不匹配的类型，那么数据仍旧会解析错误。</li><li>而AFHTTPResponseSerializer仅仅是调用验证方法，然后就返回了data。</li></ul><h2 id="3-2-AFJSONResponseSerializer"><a href="#3-2-AFJSONResponseSerializer" class="headerlink" title="3.2 AFJSONResponseSerializer"></a>3.2 AFJSONResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断是不是可接受类型和可接受code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空，或者有错误，去函数里判断。</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="comment">//返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">&quot; &quot;</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//没空格去json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要移除Null值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿着json解析的error去填充错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回解析结果</span></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，大概需要讲一下的是以下几个函数: （之前注释已经写清楚了这些函数的作用）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain))</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">AFErrorWithUnderlyingError(serializationError, *error);</span><br></pre></td></tr></table></figure><p>第一个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是我们自己之前生成的错误信息，是的话返回YES</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域名和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果userInfo的NSUnderlyingErrorKey有值，则在判断一次。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以注意，我们这里传过去的code和domain两个参数分别为NSURLErrorCannotDecodeContentData、AFURLResponseSerializationErrorDomain，这两个参数是我们之前判断response可接受类型和code时候自己去生成错误的时候填写的。</p><p>第二个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//分数组和字典</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个数组，只需要JSONObject.count个，感受到大神写代码的严谨态度了吗...</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            <span class="comment">//调用自己</span></span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看我们解析类型是mutable还是非muatable,返回mutableArray或者array</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="comment">//value空则移除</span></span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//如果数组还是去调用自己</span></span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要还是通过递归的形式实现。比较简单。</p><p>第三个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要是把json解析的错误，赋值给我们需要返回给用户的error上。比较简单，小伙伴们自己看看就好。</p><p>至此，AFJSONResponseSerializer就讲完了。而我们ResponseSerialize还有一些其他的类型解析，大家可以自行去阅读，代码还是很容易读的，在这里就不浪费篇幅去讲了。</p><p>至此我们AF3.X业务层的逻辑，基本上结束了。</p><h1 id="四、AFSecurityPolicy"><a href="#四、AFSecurityPolicy" class="headerlink" title="四、AFSecurityPolicy"></a>四、AFSecurityPolicy</h1><p>关于TLS的连接过程、单向认证/双向认证、证书信任链等概念，这里不再赘述了。</p><p>AF就是用AFSecurityPolicy这个类来满足我们各种https认证需求。在这之前我们来看看AF实现的 NSURLSessionDelegate 中用来做https认证的代理方法：</p><h2 id="4-1-session-didReceiveChallenge代理方法"><a href="#4-1-session-didReceiveChallenge代理方法" class="headerlink" title="4.1 session:didReceiveChallenge代理方法"></a>4.1 session:didReceiveChallenge代理方法</h2><p>这个方法就是做https认证的。把官方文档对这个方法的描述翻译一下：</p><ul><li><p>函数作用：</p><ul><li>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</li><li>接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential。<ul><li>disposition是应对这个挑战的认证方式，而credential是客户端应对这个挑战生成的证书。</li><li>注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书。</li></ul></li><li>最后调用completionHandler回应服务器端的挑战。</li></ul></li><li><p>函数讨论：</p><ul><li>该代理方法会在下面两种情况调用：<ul><li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li><li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）</li></ul></li><li>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 首先指定了https为默认的认证方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理。就像这个delegate方法没实现，credential被忽略</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书(证书可能为nil)</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战。整个请求都将被取消，credential被忽略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. sessionDidReceiveAuthenticationChallenge属性是一个自定义的做认证的Block，判断是否有值。</span></span><br><span class="line">    <span class="comment">// 若有，则调用，会生成一个认证方式，并给 credential 赋值，即我们需要接受认证的证书。</span></span><br><span class="line">    <span class="comment">// 若无，则去执行默认的认证步骤</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 3. 判断如果服务端的认证方法要求是 NSURLAuthenticationMethodServerTrust ，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust。也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。该证书需要使用credentialForTrust:来创建一个NSURLCredential对象。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 执行AFSecurityPolicy的方法，做一个AF内部的https认证：基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 用服务器返回的一个 serverTrust 去生成了一个认证证书。然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。</span></span><br><span class="line">                <span class="comment">// 注1：这个 serverTrust 是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）</span></span><br><span class="line">                <span class="comment">// 注2：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; <span class="comment">// 证书挑战</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;  <span class="comment">// 默认挑战</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回NO，说明AF内部认证失败，则取消挑战，即取消请求。</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 最后调用 completionHandler 传递认证方式和要认证的证书，去做系统根证书验证。</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下这里 <code>securityPolicy</code> 存在的作用就是，<strong>使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。</strong>如果通不过，则直接越过系统的验证，取消https的网络请求。否则，继续去走系统根证书的验证。</p><h2 id="4-2-AFSecurityPolicy内部"><a href="#4-2-AFSecurityPolicy内部" class="headerlink" title="4.2 AFSecurityPolicy内部"></a>4.2 AFSecurityPolicy内部</h2><p>接下来我们看看<code>AFSecurityPolicy</code>内部是如何做https认证的:</p><h3 id="4-2-1-五个属性"><a href="#4-2-1-五个属性" class="headerlink" title="4.2.1 五个属性"></a>4.2.1 五个属性</h3><blockquote><p>Certificate Pinning，或者有叫作SSL Pinning/TLS Pinning的，都是指的同一个东西，中文翻译成证书锁定，最大的作用就是用来抵御针对CA的攻击。在实际当中，它一般被用来阻止man-in-the-middle（中间人攻击）。</p><p>说起中间人攻击，可能不是那么直观，但是这一类工具我们可能经常会用到，如Mac平台的Charles和Windows平台的Fiddler。如果一个应用使用了Certificate Pinning技术，那么你使用前边说的工具是无法直接来调试/监控应用的网络流量的。</p><p>当应用通过HTTPS握手连接到Fidder/Charles时，应用会检查请求的response的证书，如果发现与预设的不一致，会拒绝后续的网络请求，从而增加应用与服务器的安全通信。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFSSLPinningMode 共提供了3种验证方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    <span class="comment">//验证证书</span></span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFSecurityPolicy，一共有4个公有属性：</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https验证模式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="comment">// if pinning(固定) is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否去验证证书域名是否匹配。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"><span class="comment">  置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line"><span class="comment">  如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如下方式，我们可以创建一个<code>securityPolicy</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">  AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  securityPolicy.SSLPinningMode = AFSSLPinningModeNone; <span class="comment">// 默认指定了SSLPinningMode模式为AFSSLPinningModeNone</span></span><br><span class="line">  <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFSecurityPolicy 还有一个私有属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br></pre></td></tr></table></figure><p>AF复写了 pinnedCertificates 属性的setter方法，会同时把证书中每个公钥放在了self.pinnedPublicKeys中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置证书数组</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    </span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应公钥集合</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="comment">//创建公钥集合</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//从证书中拿到公钥。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-evaluateServerTrust-方法"><a href="#4-2-2-evaluateServerTrust-方法" class="headerlink" title="4.2.2 evaluateServerTrust:方法"></a>4.2.2 evaluateServerTrust:方法</h3><h4 id="1-参数SecTrustRef与源码实现解读"><a href="#1-参数SecTrustRef与源码实现解读" class="headerlink" title="1. 参数SecTrustRef与源码实现解读"></a>1. 参数SecTrustRef与源码实现解读</h4><p>我们接着回到代理https认证的这行代码上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>我们传了两个参数进去，一个是<code>SecTrustRef</code>类型的serverTrust，这是什么呢？我们看到苹果的文档介绍如下：</p><blockquote><p>CFType used for performing X.509 certificate trust evaluations.  </p><p>大概意思是用于执行X.509证书信任评估，再讲简单点，其实就是一个容器，装了服务器端需要验证的证书的基本信息、公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，这个客户端的证书，可以用来和服务端的证书去匹配验证的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Security.framework 源码 https://opensource.apple.com/tarballs/Security/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> &#123;</span></span><br><span class="line">    CFRuntimeBase           _base;</span><br><span class="line">    CFArrayRef              _certificates;  <span class="comment">//证书</span></span><br><span class="line">    CFArrayRef              _anchors; <span class="comment">// 锚点</span></span><br><span class="line">    CFTypeRef               _policies; <span class="comment">// 评估信任的策略</span></span><br><span class="line">    CFArrayRef              _responses;</span><br><span class="line">    CFArrayRef              _SCTs;</span><br><span class="line">    CFArrayRef              _trustedLogs;</span><br><span class="line">    CFDateRef               _verifyDate;</span><br><span class="line"><span class="comment">// 证书链。什么是证书链？百科：证书链由两个环节组成：信任锚（CA证书）环节和已签名证书环节。自我签名的证书仅有一个环节的长度：信任锚环节就是已签名证书本身。简单来说，证书链就是就是根证书，和根据根证书签名派发得到的证书。</span></span><br><span class="line">  CFArrayRef              _chain; </span><br><span class="line">    SecKeyRef               _publicKey;</span><br><span class="line">    CFArrayRef              _details;</span><br><span class="line">    CFDictionaryRef         _info;</span><br><span class="line">    CFArrayRef              _exceptions;</span><br><span class="line"></span><br><span class="line">    SecTrustResultType      _trustResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If true we don&#x27;t trust any anchors other than the ones in _anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _anchorsOnly;</span><br><span class="line">    <span class="comment">/* If false we shouldn&#x27;t search keychains for parents or anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _keychainsAllowed;</span><br><span class="line">    <span class="comment">/* Dispatch queue for thread-safety */</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span>        _trustQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> *<span class="title">SecTrustRef</span>;</span>  <span class="comment">// trust management object(信任管理对象)，包括要验证的证书以及用于评估信任的一个或多个策略</span></span><br></pre></td></tr></table></figure><p>这个方法是<code>AFSecurityPolicy</code>最核心的方法，其他的都是为了配合这个方法。这个方法完成了服务端的证书的信任评估。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 验证服务端是否值得信任</span></span><br><span class="line"><span class="comment"> * serverTrust SecTrustRef </span></span><br><span class="line"><span class="comment"> * domain 服务器域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判断矛盾的条件</span></span><br><span class="line">    <span class="comment">//判断有域名，且允许自建证书，需要验证域名，</span></span><br><span class="line">    <span class="comment">//因为要验证域名，所以必须不能是后者两种：AFSSLPinningModeNone或者添加到项目里的证书为0个。</span></span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;</span>);</span><br><span class="line">        <span class="comment">//不受信任，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 为serverTrust设置验证策略</span></span><br><span class="line"><span class="comment">// 用来装验证策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">//要验证域名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">        <span class="comment">//添加验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要验证domain，就使用默认的BasicX509验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//serverTrust：X.509服务器的证书信任。</span></span><br><span class="line">    <span class="comment">//为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 判断模式，如果是AFSSLPinningModeNone，按照下面的逻辑肯定是返回YES，不论是自签还是公信机构的证书。</span></span><br><span class="line">    <span class="comment">//有验证策略了，可以去验证了。如果是AFSSLPinningModeNone，是自签名，直接返回可信任，否则不是自签名的就去系统根证书里去找是否有匹配的证书。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="comment">//如果支持自签名，直接返回YES，不允许才去判断第二个条件，判断serverTrust是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是AFSSLPinningModeNone，且验证无效AFServerTrustIsValid，而且allowInvalidCertificates不允许自签，返回NO</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SSLPinningMode</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="comment">// 理论上，上面那个部分已经解决了self.SSLPinningMode 为 AFSSLPinningModeNone 等情况，所以此处再遇到，就直接返回NO</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 如果是AFSSLPinningModeCertificate(验证证书类型)，则从serverTrust中去获取证书链，然后和我们一开始初始化设置的证书集合self.pinnedCertificates去匹配，如果有一对能匹配成功的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把证书data，用系统api转成 SecCertificateRef 类型的数据，SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 将pinnedCertificates设置成评估 信任管理对象 时使用的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书）</span></span><br><span class="line">            <span class="comment">//serverTrust是服务器来的验证，有需要被验证的证书。在不调用SecTrustSetAnchorCertificatesOnly()的情况下调用此函数将禁用对锚证书中锚之外的任何锚的信任。</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自签在之前是验证通过不了的，在这一步，把我们自己设置的证书加进去之后，就能验证成功了。</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//在设置锚点证书之后，再调用SecTrustEvaluate来验证一下serverTrust的证书是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#x27;s the Root CA)</span></span><br><span class="line">            <span class="comment">//注意，这个方法和我们之前的锚点证书没关系了，是去从我们需要被验证的服务端证书，去拿证书链。</span></span><br><span class="line">            <span class="comment">//服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//reverseObjectEnumerator逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果我们的证书中，有一个和它证书链中的证书匹配的，就返回YES</span></span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有匹配的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 5. 如果是AFSSLPinningModePublicKey公钥验证，则和第二步一样还是从serverTrust，获取证书链每一个证书的公钥，放到数组中。和我们的self.pinnedPublicKeys，去配对，如果有一个相同的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="comment">//公钥验证 AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历服务端公钥</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//遍历本地公钥</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="comment">//判断如果相同 trustedPublicKeyCount+1</span></span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中关联了一系列的函数，我在这边按照调用顺序一一列出来（有些是系统函数，不在这里列出，会在下文集体描述作用）：</p><h4 id="2-调用函数一-AFServerTrustIsValid"><a href="#2-调用函数一-AFServerTrustIsValid" class="headerlink" title="2. 调用函数一: AFServerTrustIsValid"></a>2. 调用函数一: AFServerTrustIsValid</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断serverTrust是否有效</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认无效</span></span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//用来装验证结果，枚举</span></span><br><span class="line">    SecTrustResultType result;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//__Require_noErr_Quiet 用来判断前者是0还是非0，如果0则表示没错，就跳到后面的表达式所在位置去执行，否则表示有错就继续往下执行。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//SecTrustEvaluate系统评估证书的是否可信的函数，去系统根目录找，然后把结果赋值给result。评估结果匹配，返回0，否则出错返回非0</span></span><br><span class="line">    <span class="comment">//do while 0 ,只执行一次，为啥要这样写....</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评估没出错走掉这，只有两种结果能设置为有效，isValid= 1</span></span><br><span class="line">    <span class="comment">//当result为kSecTrustResultUnspecified（此标志表示serverTrust评估成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书）。</span></span><br><span class="line">    <span class="comment">//或者当result为kSecTrustResultProceed（此标志表示评估成功，和上面不同的是该评估得到了用户认可），这两者取其一就可以认为对serverTrust评估成功</span></span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out函数块,如果为SecTrustEvaluate，返回非0，则评估出错，则isValid为NO</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来验证serverTrust是否有效，其中主要是交由系统API<code>SecTrustEvaluate</code>来验证的，它验证完之后会返回一个<code>SecTrustResultType</code>枚举类型的result，然后我们根据这个result去判断是否证书是否有效。</p><p>其中比较有意思的是，它调用了一个系统定义的宏函数<code>__Require_noErr_Quiet</code>，函数定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __Require_noErr_Quiet</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">      <span class="keyword">do</span>                                                                          \</span><br><span class="line">      &#123;                                                                           \</span><br><span class="line">          <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            \</span><br><span class="line">          &#123;                                                                       \</span><br><span class="line">              <span class="keyword">goto</span> exceptionLabel;                                                \</span><br><span class="line">          &#125;                                                                       \</span><br><span class="line">      &#125; <span class="keyword">while</span> ( <span class="number">0</span> ) <span class="comment">// 在Linux内核和其它一些著名的C库中都会有许多使用do&#123;...&#125;while(0)的宏定义。作用：使用do&#123;...&#125;while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数主要作用就是，判断errorCode是否为0，不为0则，程序用<code>goto</code>跳到<code>exceptionLabel</code>位置去执行。这个<code>exceptionLabel</code>就是一个代码位置标识，类似上面的<code>_out</code>。</p><h4 id="3-调用函数二、三获取证书链证书或公钥"><a href="#3-调用函数二、三获取证书链证书或公钥" class="headerlink" title="3. 调用函数二、三获取证书链证书或公钥"></a>3. 调用函数二、三获取证书链证书或公钥</h4><p>函数二、三（两个函数类似，所以放在一起）：</p><ul><li>获取serverTrust证书链证书。如果 <code>SSLPinningMode</code> 是 <code>AFSSLPinningModeCertificate</code>，就获取证书，进行校验。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取证书链</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//使用SecTrustGetCertificateCount函数获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取serverTrust证书链公钥。如果 <code>SSLPinningMode</code> 是 <code>AFSSLPinningModePublicKey</code>，就只获取公钥，进行校验。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。</span></span><br><span class="line">    <span class="comment">//安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//遍历serverTrust里证书的证书链。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        <span class="comment">//从证书链取证书</span></span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="comment">//CF数组</span></span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据给定的certificates和policy来生成一个trust对象</span></span><br><span class="line">        <span class="comment">//不成功跳到 _out。</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用SecTrustEvaluate来评估上面构建的trust</span></span><br><span class="line">        <span class="comment">//评估失败跳到 _out</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的一组公钥</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法功能类似，都是调用了一些系统的API，利用For循环，获取证书链上每一个证书或者公钥。具体内容看源码很好理解。唯一需要注意的是，这个获取的证书排序，是从证书链的叶节点，到根节点的。</p><h4 id="4-调用函数四-判断公钥是否相同"><a href="#4-调用函数四-判断公钥是否相同" class="headerlink" title="4. 调用函数四: 判断公钥是否相同"></a>4. 调用函数四: 判断公钥是否相同</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个公钥是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">AFSecKeyIsEqualToKey</span><span class="params">(SecKeyRef key1, SecKeyRef key2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">    <span class="comment">//iOS 判断二者地址</span></span><br><span class="line">    <span class="keyword">return</span> [(__bridge id)key1 isEqual:(__bridge id)key2];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AFSecKeyGetData</span>(key1) isEqual:<span class="built_in">AFSecKeyGetData</span>(key2)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法适配了各种运行环境，做了匹配的判断。</p><h4 id="5-验证过程中调用的系统原生函数"><a href="#5-验证过程中调用的系统原生函数" class="headerlink" title="5. 验证过程中调用的系统原生函数"></a>5. 验证过程中调用的系统原生函数</h4><p>接下来列出验证过程中调用过得系统原生函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个验证SSL的策略，两个参数，第一个参数true则表示验证整个证书链</span></span><br><span class="line"><span class="comment">//第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">SecPolicyCreateSSL(&lt;#Boolean server#&gt;, &lt;#CFStringRef  _Nullable hostname#&gt;)</span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.默认的BasicX509验证策略,不验证域名。</span></span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">SecTrustSetPolicies(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#CFTypeRef  _Nonnull policies#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.验证serverTrust,并且把验证结果返回给第二参数 result</span></span><br><span class="line">SecTrustEvaluate(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#SecTrustResultType * _Nullable result#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判断前者errorCode是否为0，为0则跳到exceptionLabel处执行代码</span></span><br><span class="line">__Require_noErr(&lt;#errorCode#&gt;, &lt;#exceptionLabel#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.根据证书data,去创建SecCertificateRef类型的数据。</span></span><br><span class="line">SecCertificateCreateWithData(&lt;#CFAllocatorRef  _Nullable allocator#&gt;, &lt;#CFDataRef  _Nonnull data#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.给serverTrust设置锚点证书，即如果以后再次去验证serverTrust，会从锚点证书去找是否匹配。</span></span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.拿到证书链中的证书个数</span></span><br><span class="line">CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="function">CFIndex <span class="title">SecTrustGetCertificateCount</span><span class="params">(SecTrustRef trust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    __block CFIndex certCount = <span class="number">1</span>;</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            certCount = CFArrayGetCount(trust-&gt;_chain);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> certCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.去取得证书链中对应下标的证书。</span></span><br><span class="line">SecTrustGetCertificateAtIndex(serverTrust, i)</span><br><span class="line">  </span><br><span class="line"><span class="function">SecCertificateRef <span class="title">SecTrustGetCertificateAtIndex</span><span class="params">(SecTrustRef trust,</span></span></span><br><span class="line"><span class="function"><span class="params">    CFIndex ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block SecCertificateRef cert = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == <span class="number">0</span>) &#123;</span><br><span class="line">        dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_certificates, <span class="number">0</span>);  <span class="comment">// SecTrustRef成员_certificates</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cert;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_chain, ix);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.根据证书获取公钥。</span></span><br><span class="line">SecTrustCopyPublicKey(trust)</span><br></pre></td></tr></table></figure><p>其功能如注释，大家可以对比着源码，去加以理解~</p><h2 id="4-3-关于HTTPS-开发者需要做什么"><a href="#4-3-关于HTTPS-开发者需要做什么" class="headerlink" title="4.3 关于HTTPS, 开发者需要做什么"></a>4.3 关于HTTPS, 开发者需要做什么</h2><p>可能看到这，又有些小伙伴迷糊了，讲了这么多，<strong>那如果做https请求，真正需要我们自己做的到底是什么呢？</strong></p><h3 id="4-3-1-如果只想访问能通"><a href="#4-3-1-如果只想访问能通" class="headerlink" title="4.3.1 如果只想访问能通"></a>4.3.1 如果只想访问能通</h3><p>分为以下两种情况：</p><ol><li>如果你用的是付费的公信机构颁发的证书，标准的https，<strong>那么无论你用的是AF还是NSUrlSession,什么都不用做，代理方法也不用实现。</strong>你的网络请求就能正常完成。</li><li>如果你用的是自签名的证书:</li></ol><ul><li>首先你需要在plist文件中，设置可以返回不安全的请求（关闭该域名的ATS）。</li><li>其次，如果是<code>NSUrlSesion</code>，那么需要在代理方法实现如下（其实就是AF的相对于自签证书的实现的简化版）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust]; </span><br><span class="line">    <span class="comment">// 确定挑战的方式</span></span><br><span class="line">    <span class="keyword">if</span> (credential) &#123; </span><br><span class="line">    <span class="comment">//证书挑战 则跑到这里</span></span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">       completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是AF，你则需要设置policy：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许自签名证书，必须的</span></span><br><span class="line">policy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//是否验证域名的CN字段</span></span><br><span class="line"><span class="comment">//不是必须的，但是如果写YES，则必须导入证书。</span></span><br><span class="line">policy.validatesDomainName = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-如果想验证服务器来源"><a href="#4-3-2-如果想验证服务器来源" class="headerlink" title="4.3.2 如果想验证服务器来源"></a>4.3.2 如果想验证服务器来源</h3><p>当然还可以根据需求，你可以去验证证书或者公钥，这一步的目的是实现：要求数据必须来自指定的服务器。</p><ul><li>如果是自签证书，需要把自签的服务端证书，或者自签的CA根证书导入到项目中。</li><li>如果是付费的公信机构颁发的证书，那也要把证书导入到项目中。</li></ul><img src="/images/AFN/AFN-07.jpg" alt="img" style="zoom:83%;" /><p>并且如下设置证书：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *certFilePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;AFUse_server.cer&quot;</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:certFilePath];</span><br><span class="line"><span class="built_in">NSSet</span> *certSet = [<span class="built_in">NSSet</span> setWithObjects:certData,certData, <span class="literal">nil</span>]; </span><br><span class="line">policy.pinnedCertificates = certSet;</span><br></pre></td></tr></table></figure><p>这样你就可以使用AF的不同<code>AFSSLPinningMode</code>去验证了。</p><p>这一步实现了防中间人攻击劫持，比如如果用 Charles 代理抓包，那么客户端中的请求 https 认证是无法通过的，<font color='red'><strong>报错：已取消。</strong></font>（一般AF中证书错误的code码是 -999，报错信息是已取消）。</p><h2 id="4-4-总结-AF之于https到底做了什么"><a href="#4-4-总结-AF之于https到底做了什么" class="headerlink" title="4.4 总结: AF之于https到底做了什么"></a>4.4 总结: AF之于https到底做了什么</h2><p>最后总结一下，AF之于https到底做了什么：</p><ul><li><strong>AF可以让你在系统验证证书之前，就去自主验证。</strong>然后如果自己验证不正确，直接取消网络请求。否则验证通过则继续进行系统验证。</li><li>讲到这，顺便提一下，系统验证的流程：首先是去系统的根证书找，看是否有能匹配服务端的证书，如果匹配，则验证成功，返回https的安全数据。</li><li>如果不匹配则去判断ATS是否关闭，如果关闭，则返回https不安全连接的数据。如果开启ATS，则拒绝这个请求，请求失败。</li></ul><p>总之一句话：<strong>AF的验证方式不是必须的，但是对有特殊验证需求的用户确是必要的</strong>。</p><p>写在结尾：</p><ul><li>看完之后，有些小伙伴可能还是会比较迷惑，建议还是不清楚的小伙伴，可以自己生成一个自签名的证书或者用百度地址等做请求，然后设置<code>AFSecurityPolicy</code>不同参数，打断点，一步步的看AF是如何去调用函数作证书验证的。相信这样能加深你的理解。</li><li>最后关于自签名证书的问题，等2017年1月1日，也没多久了…一个月不到。除非有特殊原因说明，否则已经无法审核通过了。详细的可以看看这篇文章：<a href="https://www.jianshu.com/p/36ddc5b009a7">iOS 10 适配 ATS（app支持https通过App Store审核）</a>。</li><li>苹果官网最新消息：原定于2017.1.1强制的https被延期了，具体延期到什么时候不确定，得等官方通知：</li></ul><h1 id="五、UIKit扩展与缓存实现"><a href="#五、UIKit扩展与缓存实现" class="headerlink" title="五、UIKit扩展与缓存实现"></a>五、UIKit扩展与缓存实现</h1><p>我们来看看AF对<code>UIkit</code>的扩展:</p><img src="/images/AFN/AFN-08.jpg" alt="img" style="zoom:67%;" /><p>一共如上这个多类，下面我们开始着重讲其中两个UIKit的扩展：</p><ul><li>一个是我们网络请求时状态栏的小菊花。</li><li>一个是我们几乎都用到过请求网络图片的如下一行方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url ;</span><br></pre></td></tr></table></figure><h2 id="5-1-AFNetworkActivityIndicatorManager"><a href="#5-1-AFNetworkActivityIndicatorManager" class="headerlink" title="5.1 AFNetworkActivityIndicatorManager"></a>5.1 AFNetworkActivityIndicatorManager</h2><p>这个类的作用相当简单，就是当网络请求的时候，状态栏上的小菊花就会开始转:</p><img src="/images/AFN/AFN-09.jpg" alt="img" style="zoom:100%;" /><p>需要的代码也很简单，只需在你需要它的位置中（比如AppDelegate）导入类，并加一行代码即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;AFNetworkActivityIndicatorManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>接下来我们来讲讲这个类的实现：</p><ul><li>这个类的实现也非常简单，还记得我们之前讲的AF对<code>NSURLSessionTask</code>中做了一个<strong>Method Swizzling</strong>吗？大意是把它的<code>resume</code>和<code>suspend</code>方法做了一个替换，在原有实现的基础上添加了一个通知的发送。</li><li>这个类就是基于这两个通知和task完成的通知来实现的。</li></ul><h3 id="5-1-1-初始化方法"><a href="#5-1-1-初始化方法" class="headerlink" title="5.1.1 初始化方法"></a>5.1.1 初始化方法</h3><p>首先我们来看看它的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkActivityManagerState) &#123;</span><br><span class="line">    <span class="comment">//没有请求</span></span><br><span class="line">    AFNetworkActivityManagerStateNotActive,</span><br><span class="line">    <span class="comment">//请求延迟开始</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingStart,</span><br><span class="line">    <span class="comment">//请求进行中</span></span><br><span class="line">    AFNetworkActivityManagerStateActive,</span><br><span class="line">    <span class="comment">//请求延迟结束</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingEnd</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* state一共如上4种状态，其中两种应该很好理解，而延迟开始和延迟结束怎么理解呢？</span></span><br><span class="line"><span class="comment">- 原来这是AF对请求菊花显示做的一个优化处理，试问如果一个请求时间很短，那么菊花很可能闪一下就结束了。如果很多请求过来，那么菊花会不停的闪啊闪，这显然并不是我们想要的效果。</span></span><br><span class="line"><span class="comment">- 所以多了这两个参数：</span></span><br><span class="line"><span class="comment">1）在一个请求开始的时候，我延迟一会在去转菊花，如果在这延迟时间内，请求结束了，那么我就不需要去转菊花了。</span></span><br><span class="line"><span class="comment">  2）但是一旦转菊花开始，哪怕很短请求就结束了，我们还是会去转一个时间再去结束，这时间就是延迟结束的时间。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerActivationDelay = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerCompletionDelay = <span class="number">0.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFNetworkActivityIndicatorManager</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkActivityIndicatorManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _sharedManager = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1. 设置状态为没有request活跃</span></span><br><span class="line">    <span class="keyword">self</span>.currentState = AFNetworkActivityManagerStateNotActive;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 监听了三个通知，用来监听当前正在进行的网络请求的状态。</span></span><br><span class="line">    <span class="comment">//开始下载通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidStart:) name:AFNetworkingTaskDidResumeNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//挂起通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidSuspendNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//完成通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 设置了我们前面提到的这个转菊花延迟开始和延迟结束的时间，</span></span><br><span class="line">    <span class="comment">//开始延迟</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelay = kDefaultAFNetworkActivityManagerActivationDelay;</span><br><span class="line">    <span class="comment">//结束延迟</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelay = kDefaultAFNetworkActivityManagerCompletionDelay;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-通知触发调用的方法"><a href="#5-1-2-通知触发调用的方法" class="headerlink" title="5.1.2 通知触发调用的方法"></a>5.1.2 通知触发调用的方法</h3><p>接着我们来看看三个通知触发调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求开始</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidStart:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//增加请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> incrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidFinish:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//AFNetworkRequestFromNotification(notification)返回这个通知的request,用来判断request是否是有效的</span></span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//减少请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> decrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，就是开始的时候增加了请求活跃数，结束则减少。调用了如下两个方法进行加减：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)incrementActivityCount &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//活跃的网络数+1，并手动发送KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        _activityCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程去做</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)decrementActivityCount &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">        _activityCount = MAX(_activityCount - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法做了什么应该很容易看明白，这里需要注意的是，<strong>task的几个状态的通知，是会在多线程的环境下发送过来的</strong>。所以这里对活跃数的加减，都用了<code>@synchronized</code>这种方式的锁，进行了线程保护。然后回到主线程调用了<code>updateCurrentStateForNetworkActivityChange</code></p><p>我们接着来看看这个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateCurrentStateForNetworkActivityChange &#123;</span><br><span class="line">    <span class="comment">//1. 判断了我们一开始设置是否需要菊花的`self.enabled`，如果需要，才执行。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.enabled) &#123;</span><br><span class="line">        <span class="comment">// 2. 这里主要是根据当前的状态，来判断下一个状态应该是什么。</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.currentState) &#123;</span><br><span class="line">            <span class="comment">//不活跃</span></span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                <span class="comment">//判断活跃数，大于0为YES</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    <span class="comment">//设置状态为延迟开始</span></span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingStart];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                <span class="comment">//No op. Let the delay timer finish out.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingEnd];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有这么一个属性<code>self.isNetworkActivityOccurring</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否活跃</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isNetworkActivityOccurring &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activityCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-重写currentState的setter"><a href="#5-1-3-重写currentState的setter" class="headerlink" title="5.1.3 重写currentState的setter"></a>5.1.3 重写currentState的setter</h3><p>这个类复写了currentState的set方法，每当我们改变这个state，就会触发set方法，而怎么该转菊花也在该方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前小菊花状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setCurrentState:(AFNetworkActivityManagerState)currentState &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != currentState) &#123;</span><br><span class="line">            <span class="comment">//KVO</span></span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">            _currentState = currentState;</span><br><span class="line">            <span class="keyword">switch</span> (currentState) &#123;</span><br><span class="line">                <span class="comment">//如果为不活跃</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                    <span class="comment">//取消两个延迟用的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelActivationDelayTimer];</span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//设置小菊花不可见</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">NO</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                    <span class="comment">//开启一个定时器延迟去转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> startActivationDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果是活跃状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                    <span class="comment">//取消延迟完成的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//开始转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">YES</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//延迟完成状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                    <span class="comment">//开启延迟完成timer</span></span><br><span class="line">                    [<span class="keyword">self</span> startCompletionDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set方法就是这个类最核心的方法了。它的作用如下：</p><ul><li>这里根据当前状态，是否需要开始执行一个延迟开始或者延迟完成，又或者是否需要取消这两个延迟。</li><li>还判断了，是否需要去转状态栏的菊花，调用了<code>setNetworkActivityIndicatorVisible:</code>方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setNetworkActivityIndicatorVisible:(<span class="built_in">BOOL</span>)networkActivityIndicatorVisible &#123;</span><br><span class="line">    <span class="keyword">if</span> (_networkActivityIndicatorVisible != networkActivityIndicatorVisible) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">             _networkActivityIndicatorVisible = networkActivityIndicatorVisible;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//支持自定义的Block，去自己控制小菊花</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityActionBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.networkActivityActionBlock(networkActivityIndicatorVisible);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则默认AF根据该Bool，去控制状态栏小菊花是否显示</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法就是用来控制菊花是否转。并且支持一个自定义的Block,我们可以自己去拿到这个菊花是否应该转的状态值，去做一些自定义的处理。</li><li>如果我们没有实现这个Block，则调用下面的方法去转菊花。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br></pre></td></tr></table></figure><p>回到state的set方法中，我们除了控制菊花去转，还调用了以下4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始任务到结束的时间，默认为1秒，如果1秒就结束，那么不转菊花，延迟去开始转</span></span><br><span class="line">- (<span class="keyword">void</span>)startActivationDelayTimer &#123;</span><br><span class="line">    <span class="comment">//只执行一次</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelayTimer = [<span class="built_in">NSTimer</span></span><br><span class="line">                                 timerWithTimeInterval:<span class="keyword">self</span>.activationDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(activationDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//添加到主线程runloop去触发</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.activationDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成任务到下一个任务开始，默认为0.17秒，如果0.17秒就开始下一个，那么不停  延迟去结束菊花转</span></span><br><span class="line">- (<span class="keyword">void</span>)startCompletionDelayTimer &#123;</span><br><span class="line">    <span class="comment">//先取消之前的</span></span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">    <span class="comment">//延迟执行让菊花不在转</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelayTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.completionDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(completionDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.completionDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelActivationDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.activationDelayTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelCompletionDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这4个方法分别是开始延迟执行一个方法，和结束的时候延迟执行一个方法，和对应这两个方法的取消。其作用，注释应该很容易理解。</p><p>我们继续往下看，这两个延迟调用的到底是什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)activationDelayTimerFired &#123;</span><br><span class="line">    <span class="comment">//活跃状态，即活跃数大于1才转</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityOccurring) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)completionDelayTimerFired &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个开始，一个完成调用，都设置了不同的currentState的值，又回到之前<code>state</code>的<code>set</code>方法中了。</p><p>至此这个<code>AFNetworkActivityIndicatorManager</code>类就讲完了，代码还是相当简单明了的。</p><h2 id="5-2-UIImageView-AFNetworking"><a href="#5-2-UIImageView-AFNetworking" class="headerlink" title="5.2 UIImageView+AFNetworking"></a>5.2 UIImageView+AFNetworking</h2><p>接下来我们来讲一个我们经常用的方法，这个方法的实现类是：<code>UIImageView+AFNetworking.h</code>。</p><p>这是个类目，并且给UIImageView扩展了4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个UIImageView去异步的请求一张图片，并且可以设置一张占位图。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line"> placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一张图，并且可以拿到成功和失败的回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">      placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前的图片设置请求</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask;</span><br></pre></td></tr></table></figure><p><code>SDWebImage</code>、<code>YYKit</code>、<code>AF</code>都实现了这么个类目。AF关于这个类目<code>UIImageView+AFNetworking</code>的实现，<strong>依赖于这么两个类：<code>AFImageDownloader</code>，<code>AFAutoPurgingImageCache</code>。</strong></p><p>当然<code>AFImageDownloader</code>中，关于图片数据请求的部分，还是使用<code>AFURLSessionManager</code>来实现的。</p><h3 id="5-2-1-AFImageDownloader"><a href="#5-2-1-AFImageDownloader" class="headerlink" title="5.2.1 AFImageDownloader"></a>5.2.1 AFImageDownloader</h3><h4 id="1-先看初始化方法"><a href="#1-先看初始化方法" class="headerlink" title="1. 先看初始化方法"></a>1. 先看初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类为单例，上述方法中，创建了一个 sessionManager, 这个 sessionManager 将用于我们之后的网络请求。从这里我们可以看到，这个类的网络请求都是基于之前AF自己封装的 AFHTTPSessionManager。</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> AFImageDownloader *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="comment">// 在这里初始化了一系列的对象</span></span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *defaultConfiguration = [<span class="keyword">self</span>.class defaultURLSessionConfiguration];</span><br><span class="line">    AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:defaultConfiguration];</span><br><span class="line">    sessionManager.responseSerializer = [AFImageResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //这个枚举值代表着，一堆图片下载，执行任务的顺序</span></span><br><span class="line"><span class="comment">      typedef NS_ENUM(NSInteger, AFImageDownloadPrioritization) &#123;</span></span><br><span class="line"><span class="comment">          //先进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationFIFO,</span></span><br><span class="line"><span class="comment">          //后进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationLIFO</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionManager:sessionManager</span><br><span class="line">                 downloadPrioritization:AFImageDownloadPrioritizationFIFO <span class="comment">// </span></span><br><span class="line">                 maximumActiveDownloads:<span class="number">4</span></span><br><span class="line">                             imageCache:[[AFAutoPurgingImageCache alloc] init]]; </span><br><span class="line">  <span class="comment">// AFAutoPurgingImageCache这个类是AF做图片缓存用的。这里我们暂时就这么理解它，讲完当前类，我们再来补充它。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultURLSessionConfiguration &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO set the default HTTP headers</span></span><br><span class="line">  </span><br><span class="line">    configuration.HTTPShouldSetCookies = <span class="literal">YES</span>;</span><br><span class="line">    configuration.HTTPShouldUsePipelining = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    configuration.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</span><br><span class="line">    <span class="comment">//是否允许蜂窝网络，手机网</span></span><br><span class="line">    configuration.allowsCellularAccess = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//默认超时</span></span><br><span class="line">    configuration.timeoutIntervalForRequest = <span class="number">60.0</span>;</span><br><span class="line">    <span class="comment">//设置的图片缓存对象</span></span><br><span class="line">    configuration.URLCache = [AFImageDownloader defaultURLCache];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们看到除了<code>[[AFAutoPurgingImageCache alloc] init]</code>，还创建了一个cache：<code>[AFImageDownloader defaultURLCache]</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个系统缓存，内存缓存为20M，磁盘缓存为150M，</span></span><br><span class="line"><span class="comment">//这个是系统级别维护的缓存。</span></span><br><span class="line"> + (<span class="built_in">NSURLCache</span> *)defaultURLCache &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                         diskCapacity:<span class="number">150</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                             diskPath:<span class="string">@&quot;com.alamofire.imagedownloader&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到这可能迷惑了，怎么这么多cache，那AF做图片缓存到底用哪个呢？答案是AF自己控制的图片缓用 <code>AFAutoPurgingImageCache</code>，而 <code>NSUrlRequest</code> 的缓存由它自己内部根据策略去控制，用的是<code>NSURLCache</code>，不归AF处理，只需在configuration中设置上即可。</p><ul><li>那么看到这有些小伙伴又要问了，为什么不直接用<code>NSURLCache</code>，还要自定义一个<code>AFAutoPurgingImageCache</code>呢？原来是因为<code>NSURLCache</code>的诸多限制，例如只支持get请求等等。而且因为是系统维护的，我们自己的可控度不强，并且如果需要做一些自定义的缓存处理，无法实现。</li><li>更多关于<code>NSURLCache</code>的内容，大家可以自行查阅。</li></ul><p>接着上面的方法调用到这个最终的初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionManager:(AFHTTPSessionManager *)sessionManager</span><br><span class="line">                downloadPrioritization:(AFImageDownloadPrioritization)downloadPrioritization</span><br><span class="line">                maximumActiveDownloads:(<span class="built_in">NSInteger</span>)maximumActiveDownloads</span><br><span class="line">                            imageCache:(<span class="keyword">id</span> &lt;AFImageRequestCache&gt;)imageCache &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">//持有</span></span><br><span class="line">        <span class="keyword">self</span>.sessionManager = sessionManager;</span><br><span class="line">        <span class="comment">//定义下载任务的顺序，默认FIFO，先进先出-队列模式，还有后进先出-栈模式</span></span><br><span class="line">        <span class="keyword">self</span>.downloadPrioritizaton = downloadPrioritization;</span><br><span class="line">        <span class="comment">//最大的下载数</span></span><br><span class="line">        <span class="keyword">self</span>.maximumActiveDownloads = maximumActiveDownloads;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义的cache</span></span><br><span class="line">        <span class="keyword">self</span>.imageCache = imageCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列中的任务，待执行的</span></span><br><span class="line">        <span class="keyword">self</span>.queuedMergedTasks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">//合并的任务，所有任务的字典</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">        <span class="comment">//活跃的request数</span></span><br><span class="line">        <span class="keyword">self</span>.activeRequestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用UUID来拼接名字</span></span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.synchronizationqueue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建一个串行的queue</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.responsequeue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建并行queue</span></span><br><span class="line">        <span class="keyword">self</span>.responseQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边初始化了一些属性，这些属性跟着注释看应该很容易明白其作用。主要需要注意的就是，这里创建了两个queue：<strong>一个串行的请求queue，和一个并行的响应queue。</strong></p><ul><li>这个串行queue,是用来做内部生成task等等一系列业务逻辑的。它保证了我们在这些逻辑处理中的线程安全问题（迷惑的接着往下看）。</li><li>这个并行queue，被用来做网络请求完成的数据回调。</li></ul><h4 id="2-再看创建请求task的方法"><a href="#2-再看创建请求task的方法" class="headerlink" title="2. 再看创建请求task的方法"></a>2. 再看创建请求task的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">        success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">UIImage</span> * ))success</span><br><span class="line">        failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">NSError</span> * ))failure </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> downloadImageForURLRequest:request withReceiptID:[<span class="built_in">NSUUID</span> UUID] </span><br><span class="line">            success:success failure:failure];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                  withReceiptID:(<span class="keyword">nonnull</span> <span class="built_in">NSUUID</span> *)receiptID</span><br><span class="line">        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="comment">//还是类似之前的，同步串行去做下载的事 生成一个task,这些事情都是在当前线程中串行同步做的，所以不用担心线程安全问题。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//url字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</span><br><span class="line">        <span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                <span class="comment">//错误返回，没Url</span></span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    failure(request, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个任务已经存在，则添加成功失败Block,然后直接返回，即一个url用一个request,可以响应好几个block</span></span><br><span class="line">        <span class="comment">//从自己task字典中根据Url去取AFImageDownloaderMergedTask，里面有task id url等等信息</span></span><br><span class="line">        AFImageDownloaderMergedTask *existingMergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        <span class="keyword">if</span> (existingMergedTask != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//里面包含成功和失败Block和UUid</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</span><br><span class="line">            <span class="comment">//添加handler</span></span><br><span class="line">            [existingMergedTask addResponseHandler:handler];</span><br><span class="line">            <span class="comment">//给task赋值</span></span><br><span class="line">            task = existingMergedTask.task;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据request的缓存策略，加载缓存</span></span><br><span class="line">        <span class="keyword">switch</span> (request.cachePolicy) &#123;</span><br><span class="line">            <span class="comment">//这3种情况都会去加载缓存</span></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</span><br><span class="line">                <span class="comment">//从cache中根据request拿数据</span></span><br><span class="line">                <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(request, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这说明即没有请求中的request,也没有cache,开始请求</span></span><br><span class="line">        <span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        <span class="comment">//task</span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *createdTask;</span><br><span class="line">        __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用sessionManager的去请求，注意，只是创建task,还是挂起状态</span></span><br><span class="line">        createdTask = [<span class="keyword">self</span>.sessionManager</span><br><span class="line">                       dataTaskWithRequest:request</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">//在responseQueue中回调数据,初始化为并行queue</span></span><br><span class="line">                           <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.responseQueue, ^&#123;</span><br><span class="line">                               __<span class="keyword">strong</span> __typeof__(weakSelf) strongSelf = weakSelf;</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//拿到当前的task</span></span><br><span class="line">                               AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//如果之前的task数组中，有这个请求的任务task，则从数组中移除</span></span><br><span class="line">                               <span class="keyword">if</span> ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</span><br><span class="line">                                   <span class="comment">//安全的移除，并返回当前被移除的AF task</span></span><br><span class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">                                   <span class="comment">//请求错误</span></span><br><span class="line">                                   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                       <span class="comment">//去遍历task所有响应的处理</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="comment">//主线程，调用失败的Block</span></span><br><span class="line">                                           <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.failureBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, error);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                       <span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                                       <span class="comment">//调用成功Block</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="keyword">if</span> (handler.successBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.successBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, responseObject);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                       </span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">//减少活跃的任务数</span></span><br><span class="line">                               [strongSelf safelyDecrementActiveTaskCount];</span><br><span class="line">                               [strongSelf safelyStartNextTaskIfNecessary];</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) Store the response handler for use when the request completes</span></span><br><span class="line">        <span class="comment">//创建handler</span></span><br><span class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</span><br><span class="line">                                                                                                   success:success</span><br><span class="line">                                                                                                   failure:failure];</span><br><span class="line">        <span class="comment">//创建task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</span><br><span class="line">                                                   initWithURLIdentifier:URLIdentifier</span><br><span class="line">                                                   identifier:mergedTaskIdentifier</span><br><span class="line">                                                   task:createdTask];</span><br><span class="line">        <span class="comment">//添加handler</span></span><br><span class="line">        [mergedTask addResponseHandler:handler];</span><br><span class="line">        <span class="comment">//往当前任务字典里添加任务</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) Either start the request or enqueue it depending on the current active request count</span></span><br><span class="line">        <span class="comment">//如果小于，则开始任务下载resume</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到最终生成的task</span></span><br><span class="line">        task = mergedTask.task;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        <span class="comment">//创建一个AFImageDownloadReceipt并返回，里面就多一个receiptID。</span></span><br><span class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么一个非常非常长的方法，这个方法执行的内容都是在我们之前创建的串行queue中，同步的执行的，这是因为这个方法绝大多数的操作都是需要线程安全的。可以对着源码和注释来看，我们在这讲下它做了什么：</p><h5 id="1-判断url是否为空"><a href="#1-判断url是否为空" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>首先做了一个url的判断，如果为空则返回失败Block。</p><h5 id="2-判断是否是已生成task"><a href="#2-判断是否是已生成task" class="headerlink" title="2) 判断是否是已生成task"></a>2) 判断是否是已生成task</h5><p>判断这个需要请求的url，是不是已经被生成的task中，如果是的话，则多添加一个回调处理就可以。</p><h5 id="2-1-AFImageDownloaderResponseHandler"><a href="#2-1-AFImageDownloaderResponseHandler" class="headerlink" title="2-1) AFImageDownloaderResponseHandler"></a>2-1) AFImageDownloaderResponseHandler</h5><p>回调处理对象为<code>AFImageDownloaderResponseHandler</code>。这个类非常简单，总共就如下3个属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderResponseHandler</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderResponseHandler</span></span></span><br><span class="line"><span class="comment">//初始化回调对象</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithUUID:(<span class="built_in">NSUUID</span> *)uuid</span><br><span class="line">                     success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">                     failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.uuid = uuid;</span><br><span class="line">        <span class="keyword">self</span>.successBlock = success;</span><br><span class="line">        <span class="keyword">self</span>.failureBlock = failure;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个task完成的时候，会调用我们添加的回调。</p><h5 id="2-2-AFImageDownloaderMergedTask"><a href="#2-2-AFImageDownloaderMergedTask" class="headerlink" title="2-2) AFImageDownloaderMergedTask"></a>2-2) AFImageDownloaderMergedTask</h5><p>关于<code>AFImageDownloaderMergedTask</code>，我们在这里都用的是这种类型的task，其实这个task也很简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderMergedTask</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;AFImageDownloaderResponseHandler*&gt; *responseHandlers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderMergedTask</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier identifier:(<span class="built_in">NSUUID</span> *)identifier task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URLIdentifier = URLIdentifier;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line">        <span class="keyword">self</span>.responseHandlers = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)addResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers addObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)removeResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers removeObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>其实就是除了<code>NSURLSessionDataTask</code>，多加了几个参数，<code>URLIdentifier</code>和<code>identifier</code>都是用来标识这个task的，responseHandlers是用来存储task完成后的回调的，里面可以存一组，当任务完成时候，里面的回调都会被调用。</p><h5 id="3-判断缓存是否存在"><a href="#3-判断缓存是否存在" class="headerlink" title="3. 判断缓存是否存在"></a>3. 判断缓存是否存在</h5><p>接着去根据缓存策略，去加载缓存，如果有缓存，从<code>self.imageCache</code>中返回缓存，否则继续往下走。</p><h5 id="4-创建NSURLSessionDataTask并设置完成回调"><a href="#4-创建NSURLSessionDataTask并设置完成回调" class="headerlink" title="4. 创建NSURLSessionDataTask并设置完成回调"></a>4. 创建NSURLSessionDataTask并设置完成回调</h5><p>走到这说明没相同url的task，也没有cache，那么就开始一个新的task，调用的是<code>AFUrlSessionManager</code>里的请求方法生成了一个task（前面已经说过，不赘述）。</p><p>同时做了请求完成的处理。注意，这里处理是在我们一开始初始化的并行queue:<code>self.responseQueue</code>中的，这里的响应处理是多线程并发进行的。</p><p>完成后：</p><ol><li>调用如下方法把这个task从全局字典中移除：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除task相关，用同步串行的形式，防止移除中出现重复移除一系列问题</span></span><br><span class="line">- (AFImageDownloaderMergedTask*)safelyRemoveMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    __block AFImageDownloaderMergedTask *mergedTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        mergedTask = [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据task的成功或失败情况，去循环这个task的<code>responseHandlers</code>，分别调用它的成功或者失败的回调。</li><li>如果成功，把成功请求到的数据，加到AF自定义的cache中：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">[<span class="meta">strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil</span>];</span><br></pre></td></tr></table></figure><ol start="4"><li>并且调用下面两个方法，去减少正在请求的任务数，和开启下一个任务：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//减少活跃的任务数</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</span><br><span class="line">    <span class="comment">//回到串行queue去-</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果可以，则开启下一个任务</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyStartNextTaskIfNecessary &#123;</span><br><span class="line">    <span class="comment">//回到串行queue</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//先判断并行数限制</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">self</span>.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取数组中第一个task</span></span><br><span class="line">                AFImageDownloaderMergedTask *mergedTask = [<span class="keyword">self</span> dequeueMergedTask];</span><br><span class="line">                <span class="comment">//如果状态是挂起状态</span></span><br><span class="line">                <span class="keyword">if</span> (mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，跟我们本类的一些数据相关的操作，<strong>都是在我们一开始的串行queue中同步进行的。</strong></p><h5 id="5-创建ResponseHandler和MergedTask"><a href="#5-创建ResponseHandler和MergedTask" class="headerlink" title="5. 创建ResponseHandler和MergedTask"></a>5. 创建ResponseHandler和MergedTask</h5><p>用<code>NSUUID</code>生成的唯一标识，去生成<code>AFImageDownloaderResponseHandler</code>，然后生成一个<code>AFImageDownloaderMergedTask</code>，把之前第5步生成的<code>createdTask</code>和回调都绑定给这个AF自定义可合并回调的task，然后这个task加到全局的task映射字典中，key为url:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br></pre></td></tr></table></figure><h5 id="6-判断当前并行数是否超限"><a href="#6-判断当前并行数是否超限" class="headerlink" title="6. 判断当前并行数是否超限"></a>6. 判断当前并行数是否超限</h5><p>判断当前正在下载的任务是否超过最大并行数，如果没有则开始下载，否则先加到等待的数组中去:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果小于最大并行数，则开始任务下载resume</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断并行数限制</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isActiveRequestCountBelowMaximumLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeRequestCount &lt; <span class="keyword">self</span>.maximumActiveDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载</span></span><br><span class="line"> - (<span class="keyword">void</span>)startMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    [mergedTask.task resume];</span><br><span class="line">    <span class="comment">//任务活跃数+1</span></span><br><span class="line">    ++<span class="keyword">self</span>.activeRequestCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把任务先加到数组里</span></span><br><span class="line"> - (<span class="keyword">void</span>)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.downloadPrioritizaton) &#123;</span><br><span class="line">            <span class="comment">//先进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationFIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks addObject:mergedTask];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//后进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationLIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks insertObject:mergedTask atIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断并行数限制，如果小于最大限制，则开始下载，把当前活跃的request数量+1。</li><li>如果暂时不能下载，被加到等待下载的数组中去的话，会根据我们一开始设置的下载策略，是先进先出，还是后进先出，去插入这个下载任务。</li></ul><h5 id="7-创建AFImageDownloadReceipt"><a href="#7-创建AFImageDownloadReceipt" class="headerlink" title="7. 创建AFImageDownloadReceipt"></a>7. 创建AFImageDownloadReceipt</h5><p>最后判断这个mergeTask是否为空。不为空，我们生成了一个<code>AFImageDownloadReceipt</code>，绑定了一个UUID，否则为空返回nil。这个<code>AFImageDownloadReceipt</code>仅仅是多封装了一个UUID:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloadReceipt</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloadReceipt</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithReceiptID:(<span class="built_in">NSUUID</span> *)receiptID task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.receiptID = receiptID;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么封装是为了标识每一个task，我们后面可以根据这个<code>AFImageDownloadReceipt</code>来对task做取消操作。</p><h4 id="3-取消task"><a href="#3-取消task" class="headerlink" title="3. 取消task"></a>3. 取消task</h4><p>这个<code>AFImageDownloader</code>中最核心的方法基本就讲完了，还剩下一些方法没讲，像前面讲到的task的取消的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据AFImageDownloadReceipt来取消任务，即对应一个响应回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//拿到url</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</span><br><span class="line">        <span class="comment">//根据url拿到task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快速遍历查找某个下标，如果返回YES，则index为当前下标</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> index = [mergedTask.responseHandlers indexOfObjectPassingTest:^<span class="built_in">BOOL</span>(AFImageDownloaderResponseHandler * _Nonnull handler, __unused <span class="built_in">NSUInteger</span> idx, __unused <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> handler.uuid == imageDownloadReceipt.receiptID;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">//移除响应处理</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</span><br><span class="line">            [mergedTask removeResponseHandler:handler];</span><br><span class="line">            <span class="built_in">NSString</span> *failureReason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ImageDownloader cancelled URL request: %@&quot;</span>,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>:failureReason&#125;;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorCancelled</span> userInfo:userInfo];</span><br><span class="line">            <span class="comment">//并调用失败block，原因为取消</span></span><br><span class="line">            <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果任务里的响应回调为空或者状态为挂起，则取消task,并且从字典中移除</span></span><br><span class="line">        <span class="keyword">if</span> (mergedTask.responseHandlers.count == <span class="number">0</span> &amp;&amp; mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">            [mergedTask.task cancel];</span><br><span class="line">            [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据URLIdentifier移除task</span></span><br><span class="line">- (AFImageDownloaderMergedTask *)removeMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">    [<span class="keyword">self</span>.mergedTasks removeObjectForKey:URLIdentifier];</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法比较简单，大家自己看看就好。至此```AFImageDownloader``这个类讲完了。如果大家看的感觉比较绕，没关系，等到最后我们一起来总结一下，捋一捋。</p><h3 id="5-2-2-AFAutoPurgingImageCache"><a href="#5-2-2-AFAutoPurgingImageCache" class="headerlink" title="5.2.2 AFAutoPurgingImageCache"></a>5.2.2 AFAutoPurgingImageCache</h3><p>我们之前讲到<code>AFAutoPurgingImageCache</code>这个类略过去了，现在我们就来补充一下这个类的相关内容：</p><p>首先来讲讲这个类的作用，它是AF自定义用来做图片缓存的。</p><h4 id="1-下文要用到的AFCachedImage"><a href="#1-下文要用到的AFCachedImage" class="headerlink" title="1. 下文要用到的AFCachedImage"></a>1. 下文要用到的AFCachedImage</h4><p>关于这个<code>AFCachedImage</code>，其实就是Image之外封装了几个关于这个缓存的参数，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFCachedImage</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;  <span class="comment">//url标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;   <span class="comment">//总大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;  <span class="comment">//上次获取时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage; <span class="comment">//这个参数没被用到过</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFCachedImage</span></span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"> -(<span class="keyword">instancetype</span>)initWithImage:(<span class="built_in">UIImage</span> *)image identifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = image;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerPixel = <span class="number">4.0</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        <span class="keyword">self</span>.totalBytes = (<span class="built_in">UInt64</span>)bytesPerPixel * (<span class="built_in">UInt64</span>)bytesPerSize;</span><br><span class="line">        <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次获取缓存的时间</span></span><br><span class="line"> - (<span class="built_in">UIImage</span>*)accessImage &#123;</span><br><span class="line">    <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2. 初始化方法"></a>2. 初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//默认为内存100M，后者为缓存溢出后保留的内存</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithMemoryCapacity:<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span> preferredMemoryCapacity:<span class="number">60</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMemoryCapacity:(<span class="built_in">UInt64</span>)memoryCapacity preferredMemoryCapacity:(<span class="built_in">UInt64</span>)preferredMemoryCapacity &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//1. 声明了一个默认的内存缓存大小100M，还有一个意思是如果超出100M之后，我们去清除缓存，此时仍要保留的缓存大小60M。（如果还是不理解，可以看后文，源码中会讲到）</span></span><br><span class="line">        <span class="keyword">self</span>.memoryCapacity = memoryCapacity;</span><br><span class="line">        <span class="keyword">self</span>.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 创建了一个cache字典，我们所有的缓存数据，都被保存在这个字典中，key为url，value为`AFCachedImage`。</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.autopurgingimagecache-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 创建了一个并行queue，这个并行queue，这个类除了初始化以外，所有的方法都是在这个并行queue中调用的。</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//4. 添加了一个通知，监听内存警告，当发生内存警告，调用该方法，移除所有的缓存，并且把当前缓存数置为0：</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">         addObserver:<span class="keyword">self</span></span><br><span class="line">         selector:<span class="keyword">@selector</span>(removeAllImages)</span><br><span class="line">         name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">         object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有图片</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)removeAllImages &#123;</span><br><span class="line">    __block <span class="built_in">BOOL</span> removed = <span class="literal">NO</span>;</span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cachedImages.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cachedImages removeAllObjects];</span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage = <span class="number">0</span>;</span><br><span class="line">            removed = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类大量的使用了<code>dispatch_barrier_sync</code>与<code>dispatch_barrier_async</code>，小伙伴们如果对这两个方法有任何疑惑，可以看看这篇文章：<a href="http://blog.csdn.net/u013046795/article/details/47057585">dispatch_barrier_async与dispatch_barrier_sync异同</a>。</p><ul><li><p>这里我们可以看到使用了<code>dispatch_barrier_sync</code>，这里没有用锁，但是因为使用了<code>dispatch_barrier_sync</code>，不仅同步了<code>synchronizationQueue</code>队列，而且阻塞了当前线程，所以保证了里面执行代码的线程安全问题。</p></li><li><p>在这里其实使用锁也可以，但是AF在这的处理却是使用同步的机制来保证线程安全，<strong>或许这跟图片的加载缓存的使用场景，高频次有关系</strong>，在这里使用sync，并不需要在去开辟新的线程，浪费性能，只需要在原有线程，提交到<code>synchronizationQueue</code>队列中，阻塞的执行即可。这样省去大量的开辟线程与使用锁带来的性能消耗。（当然这仅仅是我的一个猜测，有不同意见的朋友欢迎讨论~）</p><ul><li>在这里用了<code>dispatch_barrier_sync</code>，因为<code>synchronizationQueue</code>是个并行queue，所以在这里不会出现死锁的问题。</li><li>关于保证线程安全的同时，同步还是异步，与性能方面的考量，可以参考这篇文章：<a href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a>。</li></ul></li></ul><h4 id="3-核心方法addImage"><a href="#3-核心方法addImage" class="headerlink" title="3. 核心方法addImage:"></a>3. 核心方法addImage:</h4><p>接着我们来看看这个类最核心的一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加image到cache里</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image withIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用dispatch_barrier_async，来同步这个并行队列</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//生成cache对象</span></span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去之前cache的字典里取</span></span><br><span class="line">        AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//如果有被缓存过</span></span><br><span class="line">        <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//当前已经使用的内存大小减去图片的大小</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新cache的image加上去</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</span><br><span class="line">        <span class="comment">//加上内存大小</span></span><br><span class="line">        <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做缓存溢出的清除，清除的是早期的缓存</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//如果使用的内存大于我们设置的内存容量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</span><br><span class="line">            <span class="comment">//拿到使用内存 - 被清空后首选内存 =  需要被清除的内存</span></span><br><span class="line">            <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</span><br><span class="line">            <span class="comment">//拿到所有缓存的数据</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据lastAccessDate排序 升序，越晚的越后面</span></span><br><span class="line">            <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@&quot;lastAccessDate&quot;</span></span><br><span class="line">                                                                           ascending:<span class="literal">YES</span>];</span><br><span class="line">            </span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//移除早期的cache bytesToPurge大小</span></span><br><span class="line">            <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减去被清掉的内存</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释应该很容易明白，这个方法做了两件事：</p><ol><li>设置缓存到字典里，并且把对应的缓存大小设置到当前已缓存的数量属性中。</li><li>判断是缓存超出了我们设置的最大缓存100M，如果是的话，则清除掉部分早时间的缓存，清除到缓存小于我们溢出后保留的内存60M以内。</li></ol><p>当然在这里更需要说一说的是<code>dispatch_barrier_async</code>，这里整个类都没有使用<code>dispatch_async</code>，所以不存在是为了做一个栅栏，来同步上下文的线程。其实它在本类中的作用很简单，就是一个串行执行。</p><ul><li>讲到这，小伙伴们又疑惑了，既然就是只是为了串行，那为什么我们不用一个串行queue就得了？非得用<code>dispatch_barrier_async</code>干嘛？其实小伙伴要是看的仔细，就明白了，上文我们说过，我们要用<code>dispatch_barrier_sync</code>来保证线程安全。<strong>如果我们使用串行queue,那么线程是极其容易死锁的。</strong></li></ul><h4 id="4-其他几个方法"><a href="#4-其他几个方法" class="headerlink" title="4. 其他几个方法"></a>4. 其他几个方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id获取图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//用同步的方式获取，防止线程安全问题</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//并且刷新获取的时间</span></span><br><span class="line">        image = [cachedImage accessImage];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier添加cache</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image forRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    [<span class="keyword">self</span> addImage:image withIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier移除图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeImageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> removeImageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据request和additionalIdentifier获取图片</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> imageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成id的方式为Url字符串+additionalIdentifier</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</span><br><span class="line">    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>) &#123;</span><br><span class="line">        key = [key stringByAppendingString:additionalIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法都很简单，大家自己看看就好了，就不赘述了。至此<code>AFAutoPurgingImageCache</code>也讲完了，我们还是等到最后再来总结。</p><h3 id="5-2-3-UIImageView-AFNetworking"><a href="#5-2-3-UIImageView-AFNetworking" class="headerlink" title="5.2.3 UIImageView+AFNetworking"></a>5.2.3 UIImageView+AFNetworking</h3><p>我们绕了一大圈，总算回到了<code>UIImageView+AFNetworking</code>这个类，现在图片下载的方法，和缓存的方法都有了，实现这个类也是水到渠成的事了。</p><h4 id="1-setImageWithURL"><a href="#1-setImageWithURL" class="headerlink" title="1. setImageWithURL:"></a>1. setImageWithURL:</h4><p>我们来看下面我们绝大多数人很熟悉的方法，看看它的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> setImageWithURL:url placeholderImage:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">       placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置head，可接受类型为image</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    [request addValue:<span class="string">@&quot;image/*&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Accept&quot;</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setImageWithURLRequest:request placeholderImage:placeholderImage success:<span class="literal">nil</span> failure:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法按顺序往下调用，第二个方法给head的Accept类型设置为Image。接着调用到第三个方法，也是这个类目唯一一个重要的方法：</p><h4 id="2-setImageWithURLRequest"><a href="#2-setImageWithURLRequest" class="headerlink" title="2. setImageWithURLRequest:"></a>2. setImageWithURLRequest:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">              placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//url为空，则取消</span></span><br><span class="line">    <span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消task</span></span><br><span class="line">        [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line">        <span class="comment">//设置为占位图</span></span><br><span class="line">        <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看设置的当前的回调的request和需要请求的request是不是为同一个，是的话为重复调用，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveTaskURLEqualToURLRequest:urlRequest])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始请求前，先取消之前的task,即解绑回调</span></span><br><span class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到downloader</span></span><br><span class="line">    AFImageDownloader *downloader = [[<span class="keyword">self</span> <span class="keyword">class</span>] sharedImageDownloader];</span><br><span class="line">    <span class="comment">//拿到cache</span></span><br><span class="line">    <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Use the image from the image cache if it exists</span></span><br><span class="line">    <span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//去获取cachedImage</span></span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//有的话直接设置，并且置空回调</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = cachedImage;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无缓存，如果有占位图，先设置</span></span><br><span class="line">        <span class="keyword">if</span> (placeholderImage) &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        AFImageDownloadReceipt *receipt;</span><br><span class="line">        <span class="comment">//去下载，并得到一个receipt，可以用来取消回调</span></span><br><span class="line">        receipt = [downloader</span><br><span class="line">                   downloadImageForURLRequest:urlRequest</span><br><span class="line">                   withReceiptID:downloadID</span><br><span class="line">                   success:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> * _Nonnull responseObject) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//判断receiptID和downloadID是否相同 成功回调，设置图片</span></span><br><span class="line">                       <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                               success(request, response, responseObject);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(responseObject) &#123;</span><br><span class="line">                               strongSelf.image = responseObject;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//置空回调</span></span><br><span class="line">                           [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   failure:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//失败有failuerBlock就回调，</span></span><br><span class="line">                        <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                failure(request, response, error);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//置空回调对象</span></span><br><span class="line">                            [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                        &#125;</span><br><span class="line">                   &#125;];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">self</span>.af_activeImageDownloadReceipt = receipt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，细节的地方可以关注注释，这里总结一下做了什么：</p><h5 id="1-判断url是否为空-1"><a href="#1-判断url是否为空-1" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>如果为空则取消task，调用如下方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearActiveDownloadInformation &#123;</span><br><span class="line">    <span class="keyword">self</span>.af_activeImageDownloadReceipt = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意<code>cancelImageDownloadTask</code>中，调用了<code>self.af_activeImageDownloadReceipt</code>这么一个属性，看看定义的地方：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">setter</span> = af_setActiveImageDownloadReceipt:) AFImageDownloadReceipt *af_activeImageDownloadReceipt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="comment">//绑定属性 AFImageDownloadReceipt，就是一个事件响应的接受对象，包含一个task，一个uuid</span></span><br><span class="line"> - (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</span><br><span class="line">    <span class="keyword">return</span> (AFImageDownloadReceipt *)objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"> - (<span class="keyword">void</span>)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们现在是给<code>UIImageView</code>添加的一个类目，所以我们无法直接添加属性，而是使用的是runtime的方式来生成set和get方法生成了一个<code>AFImageDownloadReceipt</code>类型的属性。看过上文应该知道这个对象里面就一个task和一个UUID。这个属性就是我们这次下载任务相关联的信息。</p><h5 id="2-做了一系列判断，见注释"><a href="#2-做了一系列判断，见注释" class="headerlink" title="2) 做了一系列判断，见注释"></a>2) 做了一系列判断，见注释</h5><h5 id="3-创建AFImageDownloader并判断缓存"><a href="#3-创建AFImageDownloader并判断缓存" class="headerlink" title="3) 创建AFImageDownloader并判断缓存"></a>3) 创建AFImageDownloader并判断缓存</h5><p>然后生成了一个我们之前分析过得<code>AFImageDownloader</code>，然后去获取缓存，如果有缓存，则直接读缓存。还记得<code>AFImageDownloader</code>里也有一个读缓存的方法么？那个是和cachePolicy相关的，而这个是有缓存的话直接读取。不明白的可以回过头去看看。</p><h5 id="4-请求图片"><a href="#4-请求图片" class="headerlink" title="4) 请求图片"></a>4) 请求图片</h5><p>走到这说明没缓存了，然后就去用<code>AFImageDownloader</code>，我们之前讲过的方法，去请求图片。完成后，则调用成功或者失败的回调，并且置空属性<code>self.af_activeImageDownloadReceipt</code>，成功则设置图片。</p><h4 id="3-cancelImageDownloadTask"><a href="#3-cancelImageDownloadTask" class="headerlink" title="3. cancelImageDownloadTask"></a>3. cancelImageDownloadTask</h4><p>还有一个取消这次任务的方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也是去调用我们之前讲过的<code>AFImageDownloader</code>的取消方法。</p><p>这个类总共就这么几行代码，就完成了我们几乎没有人不用的，设置ImageView图片的方法。当然真正的难点在于<code>AFImageDownloader</code>和<code>AFAutoPurgingImageCache</code>。</p><h3 id="5-2-4-总结"><a href="#5-2-4-总结" class="headerlink" title="5.2.4 总结"></a>5.2.4 总结</h3><p>接下来我们来总结一下整个请求图片，缓存，然后设置图片的流程：</p><ul><li>调用<code>- (void)setImageWithURL:(NSURL *)url;</code>时，我们生成 <code>AFImageDownloader</code>单例，并替我们请求数据。</li><li>而<code>AFImageDownloader</code>会生成一个<code>AFAutoPurgingImageCache</code>替我们缓存生成的数据。当然我们设置的时候，给<code>session</code>的<code>configuration</code>设置了一个系统级别的缓存<code>NSUrlCache</code>,这两者是互相独立工作的，互不影响的。</li><li>然后<code>AFImageDownloader</code>，就实现下载和协调<code>AFAutoPurgingImageCache</code>去缓存，还有一些取消下载的方法。然后通过回调把数据给到我们的类目<code>UIImageView+AFNetworking</code>,如果成功获取数据，则由类目设置上图片，整个流程结束。</li></ul><p>经过这三个文件： <code>UIImageView+AFNetworking</code>、<code>AFImageDownloader</code>、<code>AFAutoPurgingImageCache</code>，至此整个设置网络图片的方法结束了。</p><p>写在最后：对于UIKit的总结，我们就到此为止了，其它部分的扩展，小伙伴们可以自行阅读，都很简单，基本上每个类200行左右的代码。核心功能基本上都是围绕<code>AFURLSessionManager</code>实现的。</p><h1 id="六、AF2-x与AF3-x"><a href="#六、AF2-x与AF3-x" class="headerlink" title="六、AF2.x与AF3.x"></a>六、AF2.x与AF3.x</h1><p>以下是<strong>涉及AF2.x的核心实现，与AF3.x最新版本之间的对比，以及本系列的一个最终总结：AFNetworking到底做了什么？</strong></p><h2 id="6-1-源码结构"><a href="#6-1-源码结构" class="headerlink" title="6.1 源码结构"></a>6.1 源码结构</h2><p>首先我们来看看AF2.x的项目目录:</p><img src="/images/AFN/AFN-10.jpg" alt="img" style="zoom:70%;" /><p>除了UIKit扩展外，大概就是上述这么多类，其中最重要的有3个类：</p><ul><li>AFURLConnectionOperation：大家都知道，AF2.x是基于<code>NSURLConnection</code>来封装的，而<code>NSURLConnection</code>的创建以及数据请求，就被封装在这个类中。所以这个类基本上是AF2.x最底层也是最核心的类。</li><li>AFHTTPRequestOperation：继承自<code>AFURLConnectionOperation</code>，对它父类一些方法做了些封装。</li><li>AFHTTPRequestOperationManager：则是一个管家，去管理这些这些<code>operation</code>。</li></ul><p>我们接下来按照网络请求的流程去看看AF2.x的实现：</p><p>注：本文会涉及一些<code>NSOperationQueue</code>、<code>NSOperation</code>方面的知识，如果对这方面的内容不了解的话，可以先看看雷纯峰的这篇：<a href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues </a></p><p>首先，我们来写一个get或者post请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:url parameters:params</span><br><span class="line">     success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure><p>就这么简单的几行代码，完成了一个网络请求。</p><h2 id="6-2-AFHTTPRequestOperationManager"><a href="#6-2-AFHTTPRequestOperationManager" class="headerlink" title="6.2 AFHTTPRequestOperationManager"></a>6.2 AFHTTPRequestOperationManager</h2><h3 id="6-2-1-初始化方法"><a href="#6-2-1-初始化方法" class="headerlink" title="6.2.1 初始化方法"></a>6.2.1 初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    <span class="comment">//用来调度所有请求的queue</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="comment">//是否做证书验证</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，基本和AF3.x类似，除了以下两点：</p><ol><li>设置了一个<code>operationQueue</code>，这个队列，用来调度里面所有的<code>operation</code>，在AF2.x中，每一个<code>operation</code>就是一个网络请求。</li><li>设置<code>shouldUseCredentialStorage</code>为YES，这个后面会传给<code>operation</code>，<code>operation</code>会根据这个值，去返回给代理，系统是否做https的证书验证。</li></ol><h3 id="6-2-2-get方法及AFHTTPRequestOperation创建"><a href="#6-2-2-get方法及AFHTTPRequestOperation创建" class="headerlink" title="6.2.2 get方法及AFHTTPRequestOperation创建"></a>6.2.2 get方法及AFHTTPRequestOperation创建</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                     parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                        success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                        failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 用 self.requestSerializer 生成了一个request，至于如何生成，可以参考之前的文章，这里就不赘述了。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2. 生成了一个 AFHTTPRequestOperation，然后把这个 operation 加到我们一开始创建的 queue 中。</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [<span class="keyword">self</span> HTTPRequestOperationWithRequest:request success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建<code>AFHTTPRequestOperation</code>方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 方法创建了一个 AFHTTPRequestOperation ，并把自己的一些参数交给了这个 operation 处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建自定义的AFHTTPRequestOperation</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">    operation.responseSerializer = <span class="keyword">self</span>.responseSerializer;</span><br><span class="line">    operation.shouldUseCredentialStorage = <span class="keyword">self</span>.shouldUseCredentialStorage;</span><br><span class="line">    operation.credential = <span class="keyword">self</span>.credential;</span><br><span class="line">    <span class="comment">//设置自定义的安全策略</span></span><br><span class="line">    operation.securityPolicy = <span class="keyword">self</span>.securityPolicy;</span><br><span class="line"></span><br><span class="line">    [operation setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    operation.completionQueue = <span class="keyword">self</span>.completionQueue;</span><br><span class="line">    operation.completionGroup = <span class="keyword">self</span>.completionGroup;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AFHTTPRequestOperation的初始化方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h2 id="6-3-AFURLConnectionOperation"><a href="#6-3-AFURLConnectionOperation" class="headerlink" title="6.3 AFURLConnectionOperation"></a>6.3 AFURLConnectionOperation</h2><h3 id="6-3-1-初始化方法"><a href="#6-3-1-初始化方法" class="headerlink" title="6.3.1 初始化方法"></a>6.3.1 初始化方法</h3><p>首先我们要明确<strong>这个类是继承自NSOperation的</strong>，然后我们接着往下看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(urlRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为ready</span></span><br><span class="line">    _state = AFOperationReadyState;</span><br><span class="line">    <span class="comment">//递归锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = kAFNetworkingLockName;</span><br><span class="line">    <span class="keyword">self</span>.runLoopModes = [<span class="built_in">NSSet</span> setWithObject:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="keyword">self</span>.request = urlRequest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否应该咨询证书存储连接</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//https认证策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法中，初始化了一些属性，下面我们来简单的介绍一下这些属性：</p><h3 id="6-3-2-成员变量和属性"><a href="#6-3-2-成员变量和属性" class="headerlink" title="6.3.2 成员变量和属性"></a>6.3.2 成员变量和属性</h3><h4 id="1-属性state和重写setter"><a href="#1-属性state和重写setter" class="headerlink" title="1. 属性state和重写setter"></a>1. 属性state和重写setter</h4><p><code>_state</code>设置为<code>AFOperationReadyState</code> 准备就绪状态，这是个枚举：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFOperationState) &#123;</span><br><span class="line">    AFOperationPausedState      = <span class="number">-1</span>,  <span class="comment">//停止</span></span><br><span class="line">    AFOperationReadyState       = <span class="number">1</span>,   <span class="comment">//准备就绪</span></span><br><span class="line">    AFOperationExecutingState   = <span class="number">2</span>,  <span class="comment">//正在进行中</span></span><br><span class="line">    AFOperationFinishedState    = <span class="number">3</span>,  <span class="comment">//完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本类重写了state的setter方法，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setState:(AFOperationState)state &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断从当前状态到另一个状态是不是合理，在加上现在是否取消。。大神的框架就是屌啊，这判断严谨的。。一层层</span></span><br><span class="line">    <span class="keyword">if</span> (!AFStateTransitionIsValid(<span class="keyword">self</span>.state, state, [<span class="keyword">self</span> isCancelled])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到对应的父类管理当前线程周期的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *oldStateKey = AFKeyPathFromOperationState(<span class="keyword">self</span>.state);</span><br><span class="line">    <span class="built_in">NSString</span> *newStateKey = AFKeyPathFromOperationState(state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:oldStateKey];</span><br><span class="line">    _state = state;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:oldStateKey];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_state</code>标志着这个网络请求的状态，一共如上4种状态。这些状态其实对应着<code>operation</code>如下的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射这个operation的各个状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NSString * <span class="title">AFKeyPathFromOperationState</span><span class="params">(AFOperationState state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFOperationReadyState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isReady&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationExecutingState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isExecuting&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationFinishedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isFinished&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationPausedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isPaused&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wunreachable-code&quot;</span></span></span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;state&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重写父类NSOperation的属性getter"><a href="#2-重写父类NSOperation的属性getter" class="headerlink" title="2. 重写父类NSOperation的属性getter"></a>2. 重写父类NSOperation的属性getter</h4><p>复写了这些属性的get方法，用来和自定义的state一一对应：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写这些方法，与自己的定义的state对应</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isReady &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationReadyState &amp;&amp; [<span class="keyword">super</span> isReady];</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationExecutingState;</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationFinishedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性lock"><a href="#3-属性lock" class="headerlink" title="3. 属性lock"></a>3. 属性lock</h4><p><code>self.lock</code>这个锁是用来提供给本类一些数据操作的线程安全，至于为什么要用递归锁，是因为有些方法可能会存在递归调用的情况，例如有些需要锁的方法可能会在一个大的操作环中，形成递归。<strong>而AF使用了递归锁，避免了这种情况下死锁的发生</strong>。</p><h4 id="4-属性runLoopModes"><a href="#4-属性runLoopModes" class="headerlink" title="4. 属性runLoopModes"></a>4. 属性runLoopModes</h4><p>初始化了<code>self.runLoopModes</code>，默认为<code>NSRunLoopCommonModes</code>。</p><h4 id="5-属性securityPolicy"><a href="#5-属性securityPolicy" class="headerlink" title="5. 属性securityPolicy"></a>5. 属性securityPolicy</h4><p>生成了一个默认的 <code>self.securityPolicy</code>，关于这个policy执行的https认证，可以见楼主之前的文章。</p><h3 id="6-3-3-复写operation的start方法"><a href="#6-3-3-复写operation的start方法" class="headerlink" title="6.3.3 复写operation的start方法"></a>6.3.3 复写operation的start方法</h3><p>这个类为了自定义<code>operation</code>的各种状态，而且更好的掌控它的生命周期，复写了<code>operation</code>的<code>start</code>方法。</p><h4 id="1-源码实现"><a href="#1-源码实现" class="headerlink" title="1. 源码实现"></a>1. 源码实现</h4><p>当这个<code>operation</code>在一个新线程被调度执行的时候，首先就调入这个<code>start</code>方法中，接下来我们它的实现看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果被取消了就调用取消的方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//在AF常驻线程中去执行</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备好了，才开始</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="comment">//改变状态，开始执行</span></span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，发起请求和取消请求都是在同一个线程！！包括回调都是在一个线程</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法判断了当前的状态，是取消还是准备就绪，然后去调用了各自对应的方法。</p><h4 id="2-开辟新线程"><a href="#2-开辟新线程" class="headerlink" title="2. 开辟新线程"></a>2. 开辟新线程</h4><p>注意这些方法都是在另外一个线程中去调用的，我们来看看这个线程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">//添加端口，防止runloop直接退出</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法基本上是被许多人举例用过无数次了…</p><ul><li>这是一个单例，用<code>NSThread</code>创建了一个线程，并且为这个线程添加了一个<code>runloop</code>，并且加了一个<code>NSMachPort</code>，来防止<code>runloop</code>直接退出。</li><li><strong>这条线程就是AF用来发起网络请求，并且接受网络请求回调的线程，仅仅就这一条线程</strong>（到最后我们来讲为什么要这么做）。和我们之前讲的AF3.x发起请求，并且接受请求回调时的处理方式，遥相呼应。</li></ul><h4 id="3-start调用流程"><a href="#3-start调用流程" class="headerlink" title="3. start调用流程"></a>3. start调用流程</h4><p>我们接着来看如果准备就绪，start调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态，开始执行</span></span><br><span class="line"><span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br></pre></td></tr></table></figure><p>接着在常驻线程中,并且不阻塞的方式，在我们<code>self.runLoopModes</code>的模式下调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationDidStart &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//如果没取消</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//设置为startImmediately YES 请求发出，回调会加入到主线程的 Runloop 下，RunloopMode 会默认为 NSDefaultRunLoopMode</span></span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line">            <span class="comment">//把connection和outputStream注册到当前线程runloop中去，只有这样，才能在这个线程中回调</span></span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开输出流</span></span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line">        <span class="comment">//开启请求</span></span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了以下几件事：</p><h5 id="1-创建NSURLConnection"><a href="#1-创建NSURLConnection" class="headerlink" title="1) 创建NSURLConnection"></a>1) 创建NSURLConnection</h5><p>首先这个方法创建了一个<code>NSURLConnection</code>，设置代理为自己，startImmediately为NO，至于这个参数干什么用的，我们来看看官方文档：</p><blockquote><p>startImmediately<br> YES if the connection should begin loading data immediately, otherwise NO. If you pass NO, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling scheduleInRunLoop:forMode: .</p></blockquote><p>大意是，这个值默认为YES，而且任务完成的结果会在主线程的runloop中回调。如果我们设置为NO，则需要调用我们下面看到的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.connection scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>去注册一个runloop和mode，它会在我们指定的这个runloop所在的线程中回调结果。</p><h5 id="2-outputStream的创建及注册"><a href="#2-outputStream的创建及注册" class="headerlink" title="2) outputStream的创建及注册"></a>2) outputStream的创建及注册</h5><p>值得一提的是这里调用了:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>这个<code>outputStream</code>在getter方法中被初始化了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_outputStream) &#123;</span><br><span class="line">        <span class="comment">//一个写入到内存中的流，可以通过NSStreamDataWrittenToMemoryStreamKey拿到写入后的数据</span></span><br><span class="line">        <span class="keyword">self</span>.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _outputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里数据请求和拼接并没有用<code>NSMutableData</code>，而是用了<code>outputStream</code>，而且把写入的数据，放到内存中。</p><ul><li>其实讲道理来说<code>outputStream</code>的优势在于下载大文件的时候，可以以流的形式，将文件直接保存到本地，<strong>这样可以为我们节省很多的内存</strong>，调用如下方法设置：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:<span class="string">@&quot;filePath&quot;</span> append:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><ul><li>但是这里是把流写入内存中，这样其实这个节省内存的意义已经不存在了。那为什么还要用呢？这里我猜测的是就是为了用它这个可以注册在某一个<code>runloop</code>的指定<code>mode</code>下。 虽然AF使用这个<code>outputStream</code>是肯定在这个常驻线程中的，不会有线程安全的问题。但是要注意它是被声明在.h中的：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *outputStream;</span><br></pre></td></tr></table></figure><p>难保外部不会在其他线程对这个数据做什么操作，所以它相对于<code>NSMutableData</code>作用就体现出来了，就算我们在外部其它线程中去操作它，也不会有线程安全的问题。</p><h5 id="3-开始执行connection"><a href="#3-开始执行connection" class="headerlink" title="3) 开始执行connection"></a>3) 开始执行connection</h5><h5 id="4-到主线程发送任务开始执行的通知"><a href="#4-到主线程发送任务开始执行的通知" class="headerlink" title="4) 到主线程发送任务开始执行的通知"></a>4) 到主线程发送任务开始执行的通知</h5><h3 id="6-3-4-实现NSURLConnectionDelegate"><a href="#6-3-4-实现NSURLConnectionDelegate" class="headerlink" title="6.3.4 实现NSURLConnectionDelegate"></a>6.3.4 实现NSURLConnectionDelegate</h3><p>接下来网络请求开始执行了，就开始触发<code>connection</code>的代理方法了：</p><img src="/images/AFN/AFN-11.jpg" alt="img" style="zoom:74%;" /><p> AF2.x一共实现了如上这么多代理方法，这些代理方法，作用大部分和我们之前讲的<code>NSURLSession</code>的代理方法类似，我们重点讲下面这四个代理：</p><p>注意，有一点需要说明，我们之前是把connection注册在我们常驻线程的runloop中了，<strong>所以以下所有的代理方法，都是在这仅有的一条常驻线程中回调。</strong></p><h4 id="1-connection-didReceiveResponse"><a href="#1-connection-didReceiveResponse" class="headerlink" title="1. connection:didReceiveResponse"></a>1. connection:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到响应，响应头类似相关数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，就是收到响应后，把response赋给自己的属性。</p><h4 id="2-connection-didReceiveData"><a href="#2-connection-didReceiveData" class="headerlink" title="2. connection:didReceiveData"></a>2. connection:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接获取到的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [data length];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> totalNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果outputStream 还有空余空间</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//创建一个buffer流缓冲区，大小为data的字节数</span></span><br><span class="line">            <span class="keyword">const</span> uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//当写的长度小于数据的长度，在循环里</span></span><br><span class="line">            <span class="keyword">while</span> (totalNumberOfBytesWritten &lt; (<span class="built_in">NSInteger</span>)length) &#123;</span><br><span class="line">                <span class="comment">//往outputStream写数据，系统的方法，一次就写一部分，得循环写</span></span><br><span class="line">                numberOfBytesWritten = [<span class="keyword">self</span>.outputStream write:&amp;dataBuffer[(<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten)];</span><br><span class="line">                <span class="comment">//如果 numberOfBytesWritten写入失败了。跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加上每次写的长度</span></span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.outputStream.streamError) &#123;</span><br><span class="line">            <span class="comment">//取消connection</span></span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            <span class="comment">//调用失败的方法</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(connection:didFailWithError:) withObject:<span class="keyword">self</span>.connection withObject:<span class="keyword">self</span>.outputStream.streamError];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程回调下载数据大小</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.totalBytesRead += (<span class="keyword">long</span> <span class="keyword">long</span>)length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgress) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress(length, <span class="keyword">self</span>.totalBytesRead, <span class="keyword">self</span>.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看起来长，其实容易理解而且简单，它只做了3件事：</p><ol><li>给<code>outputStream</code>拼接数据，具体如果拼接，大家可以读注释自行理解下。</li><li>如果出错则调用：<code>connection:didFailWithError:</code>也就是网络请求失败的代理，我们一会下面就会讲。</li><li>在主线程中回调下载进度。</li></ol><h4 id="3-connectionDidFinishLoading"><a href="#3-connectionDidFinishLoading" class="headerlink" title="3. connectionDidFinishLoading"></a>3. connectionDidFinishLoading</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成了调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> __unused *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从outputStream中拿到数据 NSStreamDataWrittenToMemoryStreamKey写入到内存中的流</span></span><br><span class="line">    <span class="keyword">self</span>.responseData = [<span class="keyword">self</span>.outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">       <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空connection</span></span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理是任务完成之后调用。我们从<code>outputStream</code>拿到了最后下载数据，然后关闭置空了<code>outputStream</code>。并且清空了<code>connection</code>。调用了<code>finish</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)finish &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//修改状态</span></span><br><span class="line">    <span class="keyword">self</span>.state = AFOperationFinishedState;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送完成的通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把当前任务状态改为已完成，并且到主线程发送任务完成的通知。<strong>这里我们设置状态为已完成。注意上面已经讲过：本类是复写了state的setter方法的</strong>，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><p>大家了解<code>NSOperationQueue</code>就知道，如果对应的operation的属性<code>finnished</code>被设置为YES，则代表当前<code>operation</code>结束了，会把<code>operation</code>从队列中移除，并且调用<code>operation</code>的<code>completionBlock</code>。<strong>这点很重要，因为我们请求到的数据就是从这个<code>completionBlock</code>中传递回去的</strong>（下面接着讲这个完成Block，就能从这里对接上了）。</p><h4 id="4-connection-didFailWithError"><a href="#4-connection-didFailWithError" class="headerlink" title="4. connection:didFailWithError"></a>4. connection:didFailWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求失败的回调，在cancel connection的时候，自己也主动调用了</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到error</span></span><br><span class="line">    <span class="keyword">self</span>.error = error;</span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一需要说一下的就是这里给<code>self.error</code>赋值，之后完成Block会根据这个error，去判断这次请求是成功还是失败。</p><p>至此我们把<code>AFURLConnectionOperation</code>的业务主线讲完了。</p><p>我们此时数据请求完了，数据在<code>self.responseData</code>中，那它是怎么回到我们手里的呢。需要回到<code>AFURLConnectionOperation</code>子类<code>AFHTTPRequestOperation</code>，有这么一个方法：<code>setCompletionBlockWithSuccess:failure:</code></p><h2 id="6-4-AFHTTPRequestOperation"><a href="#6-4-AFHTTPRequestOperation" class="headerlink" title="6.4 AFHTTPRequestOperation"></a>6.4 AFHTTPRequestOperation</h2><h3 id="6-4-1-初始化方法"><a href="#6-4-1-初始化方法" class="headerlink" title="6.4.1 初始化方法"></a>6.4.1 初始化方法</h3><p>前面已经看过这个AFHTTPRequestOperation的初始化方法，这里再整合一下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h3 id="6-4-2-设置completionBlock"><a href="#6-4-2-设置completionBlock" class="headerlink" title="6.4.2 设置completionBlock"></a>6.4.2 设置completionBlock</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                              failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">    <span class="keyword">self</span>.completionBlock = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">            dispatch_group_enter(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(http_request_operation_processing_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> responseObject = <span class="keyword">self</span>.responseObject;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(<span class="keyword">self</span>, responseObject);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">                dispatch_group_leave(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我们在<code>AFHTTPRequestOperationManager</code>中是调用过这个方法的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation setCompletionBlockWithSuccess:success failure:failure];</span><br></pre></td></tr></table></figure><ul><li>我们在把成功和失败的Block传给了这个方法。</li><li>这个方法也很好理解，就是设置我们之前提到过得<code>completionBlock</code>，<strong>当自己数据请求完成，就会调用这个Block。然后我们在这个Block中调用传过来的成功或者失败的Block。</strong>如果error为空，说明请求成功，把数据传出去，否则为失败，把error信息传出。</li><li>这里也类似AF3.x，可以自定义一个完成组和完成队列。数据可以在我们自定义的完成组和队列中回调出去。</li><li>除此之外，还有一个有意思的地方：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>之前我们说过，这是在忽略编译器的一些警告。</p><ul><li><code>-Wgnu</code>就不说了，是忽略 ?: 。</li><li>值得提下的是<code>-Warc-retain-cycles</code>，这里忽略了循环引用的警告。我们仔细看看就知道<code>self</code>持有了<code>completionBlock</code>，而<code>completionBlock</code>内部持有<code>self</code>。这里确实循环引用了。那么AF是如何解决这个循环引用的呢？</li></ul><p>我们在回到<code>AFURLConnectionOperation</code>，还有一个方法我们之前没讲到，它复写了setCompletionBlock这个方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写setCompletionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:^ &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">            <span class="comment">//看有没有自定义的完成组，否则用AF的组</span></span><br><span class="line">            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</span><br><span class="line">            <span class="comment">//看有没有自定义的完成queue，否则用主队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用设置的Block,在这个组和队列中</span></span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                block();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结束时候置nil，防止循环引用</span></span><br><span class="line">            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&#123;</span><br><span class="line">                [strongSelf setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，它在我们设置的block调用结束的时候，主动的调用:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">strongSelf setCompletionBlock:nil</span>];</span><br></pre></td></tr></table></figure><p>把Block置空，这样循环引用不复存在了。</p><h3 id="6-4-3-数据解析的调用"><a href="#6-4-3-数据解析的调用" class="headerlink" title="6.4.3 数据解析的调用"></a>6.4.3 数据解析的调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObject &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!_responseObject &amp;&amp; [<span class="keyword">self</span> isFinished] &amp;&amp; !<span class="keyword">self</span>.error) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//做数据解析</span></span><br><span class="line">        <span class="keyword">self</span>.responseObject = [<span class="keyword">self</span>.responseSerializer responseObjectForResponse:<span class="keyword">self</span>.response data:<span class="keyword">self</span>.responseData error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">self</span>.responseSerializationError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> _responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestOperation</code> 复写了 <code>responseObject</code> 的getter方法，并且把数据按照我们需要的类型（json、xml等等）进行解析。</p><h2 id="6-5-ResponseSerializer与SecurityPolicy"><a href="#6-5-ResponseSerializer与SecurityPolicy" class="headerlink" title="6.5 ResponseSerializer与SecurityPolicy"></a>6.5 ResponseSerializer与SecurityPolicy</h2><p>关于数据的序列化、SecurityPolicy，前面已经详细的讲过，AF2.x与AF3.x基本差不多，不再赘述。<code>AFSecurityPolicy</code> 在  <code>AFURLConnectionOperation</code>中https认证的代理中被调用</p><p>至此，AF2.x整个业务流程就结束了。</p><h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><p>接下来，我们来总结总结AF2.x整个业务请求的流程：</p><img src="/images/AFN/AFN-12.jpg" alt="img" style="zoom:65%;" /><p>如上图，我们来梳理一下整个流程：</p><ul><li>最上层的是<code>AFHTTPRequestOperationManager</code>,我们调用它进行get、post等等各种类型的网络请求</li><li>然后它去调用<code>AFURLRequestSerialization</code>做request参数拼装。然后生成了一个<code>AFHTTPRequestOperation</code>实例，并把request交给它。然后把<code>AFHTTPRequestOperation</code>添加到一个<code>NSOperationQueue</code>中。</li><li>接着<code>AFHTTPRequestOperation</code>拿到request后，会去调用它的父类<code>AFURLConnectionOperation</code>的初始化方法，并且把相关参数交给它，除此之外，当父类完成数据请求后，它调用了<code>AFURLResponseSerialization</code>把数据解析成我们需要的格式（json、XML等等）。</li><li>最后就是我们AF最底层的类<code>AFURLConnectionOperation</code>，它去数据请求，并且如果是https请求，会在请求的相关代理中，调用<code>AFSecurityPolicy</code>做https认证。最后请求到的数据返回。</li></ul><p>这就是AF2.x整个做网络请求的业务流程。</p><h2 id="6-7-遗留问题：一条常驻线程"><a href="#6-7-遗留问题：一条常驻线程" class="headerlink" title="6.7 遗留问题：一条常驻线程"></a>6.7 遗留问题：一条常驻线程</h2><p>我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？</p><p>首先如果我们用<code>NSURLConnection</code>，我们为了获取请求结果有以下三种选择：</p><ol><li>在主线程调异步接口</li><li>每一个请求用一个线程，对应一个runloop，然后等待结果回调。</li><li>只用一条线程，一个runloop，所有结果回调在这个线程上。</li></ol><p>很显然AF选择的是第3种方式，创建了一条常驻线程专门处理所有请求的回调事件，这个模型跟<code>nodejs</code>有点类似，我们来讨论讨论不选择另外两种方式的原因：</p><p>先说第一种。试想如果我们所有的请求都在主线程中异步调用，好像没什么不可以？那为什么AF不这么做呢…在这里有两点原因（楼主个人总结的，有不同意见，欢迎讨论）：</p><ol><li><p>第一，如果我们放到主线程去做，势必要这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>] </span><br></pre></td></tr></table></figure><p>这样NSURLConnection的回调会被放在主线程中<code>NSDefaultRunLoopMode</code>中，这样我们在其它类似<code>UITrackingRunLoopMode</code>模式下，我们是得不到网络请求的结果的，这显然不是我们想要的，那么我们势必需要调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>]; </span><br></pre></td></tr></table></figure><p>把它加入 <code>NSRunLoopCommonModes</code> 中，试想如果有大量的网络请求，同时回调回来，就会影响我们的UI体验了。</p></li><li><p>另外一点原因是，如果我们请求数据返回，势必要进行数据解析，解析成我们需要的格式，那么这些解析都在主线程中做，给主线程增加额外的负担。又或者我们回调回来开辟一个新的线程去做数据解析，那么我们有n个请求回来开辟n条线程带来的性能损耗，以及线程间切换带来的损耗，是不是一笔更大的开销。</p></li></ol><p>所以综述两点原因，我们并不适合在主线程中回调。</p><p>再说第二种。我们一开始就开辟n条线程去做请求，然后设置runloop保活住线程，等待结果回调。其实看到这，大家想想都觉得这个方法很傻，为了等待不确定的请求结果，阻塞住线程，白白浪费n条线程的开销。</p><p>综上所述，这就是<strong>AF2.x需要一条常驻线程的原因了</strong>。</p><p>至此我们把AF2.x核心流程分析完了。</p><h1 id="七、总结AFNetworking到底做了什么？"><a href="#七、总结AFNetworking到底做了什么？" class="headerlink" title="七、总结AFNetworking到底做了什么？"></a>七、总结AFNetworking到底做了什么？</h1><p>接着到我们本系列一个最终总结了: <strong>AFNetworking到底做了什么？</strong></p><p>相信如果从头看到尾的小伙伴，心里都有了一个属于自己的答案。其实在楼主心里，实在不想去总结它，因为<code>AFNetworking</code>中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。但是想想也知道，如果我说不总结，估计有些看到这的朋友杀人的心都有…所以我还是赶鸭子上架，来总结总结它。</p><p>AFNetworking的作用总结：</p><p>一、首先我们需要明确一点的是：<strong>相对于AFNetworking2.x，AFNetworking3.x确实没那么有用了。</strong>AFNetworking之前的核心作用就是为了帮我们去调度所有的请求。但是最核心地方却被苹果的<code>NSURLSession</code>给借鉴过去了，嗯…是借鉴。这些请求的调度，现在完全由<code>NSURLSession</code>给做了，AFNetworking3.x的作用被大大的削弱了。</p><p>二、但是除此之外，其实它还是很有用的：</p><ol><li><strong>首先它帮我们做了各种请求方式request的拼接。</strong>想想如果我们用<code>NSURLSession</code>，我们去做请求，是不是还得自己去考虑各种请求方式下，拼接参数的问题。</li><li><strong>它还帮我们做了一些公用参数（session级别的），和一些私用参数（task级别的）的分离</strong>。它用Block的形式，支持我们自定义一些代理方法，如果没有实现的话，AF还帮我们做了一些默认的处理。而如果我们用<code>NSURLSession</code>的话，还得参照AF这么一套代理转发的架构模式去封装。</li><li><strong>它帮我们做了自定义的https认证处理</strong>。看过楼主之前那篇<a href="https://www.jianshu.com/p/a84237b07611">AFNetworking之于https认证</a>的朋友就知道，如果我们自己用<code>NSURLSession</code>实现那几种自定义认证，需要多写多少代码…</li><li><strong>对于请求到的数据，AF帮我们做了各种格式的数据解析，并且支持我们设置自定义的code范围，自定义的数据方式</strong>。如果不在这些范围中，则直接调用失败block。如果用<code>NSURLSession</code>呢？这些都自己去写吧…（你要是做过各种除json外其他的数据解析,就会知道这里面坑有多少…）</li><li><strong>对于成功和失败的回调处理。</strong>AF帮我们在数据请求到，到回调给用户之间，做了各种错误的判断，保证了成功和失败的回调，界限清晰。在这过程中，AF帮我们做了太多的容错处理，而<code>NSURLSession</code>呢？只给了一个完成的回调，我们得多做多少判断，才能拿到一个确定能正常显示的数据？</li><li>……</li><li>…</li></ol><p>光是这些网络请求的业务逻辑，AF帮我们做的就太多太多，当然还远不仅于此。它用凝聚着许多大牛的经验方式，帮我在有些处理中做了最优的选择，比如我们之前说到的，回调线程数设置为1的问题…帮我们绕开了很多的坑，比如系统内部并行创建<code>task</code>导致id不唯一等等…</p><p>三、而如果我们需要一些UIKit的扩展，AF则提供了最稳定，而且最优化实现方式：</p><ul><li>就比如之前说到过得那个状态栏小菊花，如果是我们自己去做，得多写多少代码，而且实现的还没有AF那样质量高。</li><li>又或者<code>AFImageDownloader</code>，它对于组图片之间的下载协调，以及缓存使用的之间线程调度。对于线程，锁，以及性能各方面权衡，找出最优化的处理方式，试问小伙伴们自己基于<code>NSURLSession</code>去写，能到做几分…</li></ul><p>所以最后的结论是：<strong>AFNetworking虽然变弱了，但是它还是很有用的。</strong>用它真的不仅仅是习惯，而是因为它确实帮我们做了太多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F&quot;&gt;原文链接&lt;/a&gt;，有一些细节修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;im</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="AFN" scheme="https://tenloy.github.io/tags/AFN/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络相关知识汇总</title>
    <link href="https://tenloy.github.io/2021/09/03/computer-network-knowledge.html"/>
    <id>https://tenloy.github.io/2021/09/03/computer-network-knowledge.html</id>
    <published>2021-09-03T18:53:12.000Z</published>
    <updated>2021-12-03T08:23:35.429Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程：是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</p><p>我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。</p><p>这些过程都发生了网络数据的交互：</p><ul><li>bs：browser server 浏览器和服务器的网络编程模型</li><li>cs：client server 客户端和服务器的网络编程模型</li></ul><p>强调：网络编程重在思想，node只是一个可以帮助我们网络编程的一个工具而已。使用其他编程语言或者操作系统进行网络编程，思想都是一样的。</p><h1 id="一、服务器与服务器容器"><a href="#一、服务器与服务器容器" class="headerlink" title="一、服务器与服务器容器"></a>一、服务器与服务器容器</h1><h2 id="1-1-服务器-server"><a href="#1-1-服务器-server" class="headerlink" title="1.1 服务器(server)"></a>1.1 服务器(server)</h2><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li>一个管理资源并为用户<font color='red'>提供服务</font>的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</li><li>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h3 id="1-1-1-作为硬件"><a href="#1-1-1-作为硬件" class="headerlink" title="1.1.1 作为硬件"></a>1.1.1 作为硬件</h3><p>服务器就是一台特殊的、功能强大、没有外接设备(屏幕、键盘、鼠标)的电脑。一个服务器一个IP，有些大公司，拥有成千上万个服务器，我们通过主机域名来访问资源，服务器是随机分配给我们的。</p><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li><li>服务器不需要比较复杂的可视化操作界面，因为比较耗资源。服务器一旦部署好服务后，一般动的比较少。</li></ul><h3 id="1-1-2-作为软件"><a href="#1-1-2-作为软件" class="headerlink" title="1.1.2 作为软件"></a>1.1.2 作为软件</h3><h4 id="1-常见分类"><a href="#1-常见分类" class="headerlink" title="1. 常见分类"></a>1. 常见分类</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，按提供的服务类型不同可分为：</p><ul><li><strong>应用程序服务器(application server/AP server)</strong></li><li><strong>网页服务器(Web server)</strong> —— Apache、Nginx、IIS、Tomcat、NodeJS等；</li><li>文件服务器(file server)或网络存储设备(network attached storage) —— Server-U、FileZilla、VsFTP等；</li><li>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</li><li>邮件服务器(mail server) —— Postfix、Sendmail等；</li><li>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</li><li>域名服务器（DNS server）—— 如BIND等</li><li>代理服务器（proxy server）—— 如Squid cache</li><li>其他，如Active Directory服务器、Minecraft游戏服务器等</li></ul><img src = "/images/ComNet/servers.jpg" width = '50%' align:left style='margin-left:10%'><h4 id="2-应用程序服务器"><a href="#2-应用程序服务器" class="headerlink" title="2. 应用程序服务器"></a>2. 应用程序服务器</h4><p><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</p><p>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong></p><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul><h4 id="3-网页服务器-Web-server"><a href="#3-网页服务器-Web-server" class="headerlink" title="3. 网页服务器(Web server)"></a>3. 网页服务器(Web server)</h4><p>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</p><p>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。如Apache（静态）、Apache Tomcat（静态、动态）、Node.js、lighttpd、nginx、微软的IIS等；</p><img src="/images/ComNet/web-server.jpg" alt="图片" style="zoom:90%;" /><h4 id="4-WEB应用服务器"><a href="#4-WEB应用服务器" class="headerlink" title="4. WEB应用服务器"></a>4. WEB应用服务器</h4><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p><h3 id="1-1-3-服务器的其它分类"><a href="#1-1-3-服务器的其它分类" class="headerlink" title="1.1.3 服务器的其它分类"></a>1.1.3 服务器的其它分类</h3><p><strong>按操作系统分</strong></p><ul><li>Linux服务器、Windows服务器等；</li></ul><p><strong>按照浏览器的访问权限来分</strong></p><ul><li><p>外网服务器<br>别名：远程服务器，<font color=red>任何网段的设备都能访问的服务器</font><br>应用场景：应用上线后使用的服务器<br>使用人群：供全体用户使用<br>速度：取决于服务器的性能、用户的网速</p></li><li><p>内网服务器<br>别名：本地服务器，<font color=red>只有连同样内网的设备才能访问到的服务器</font><br>应用场景：应用处于开发、测试阶段使用的服务器<br>使用人群：仅供公司内部的开发人员、测试人员使用<br>速度：由于是局域网，所以速度飞快，有助于提高开发测试效率</p></li><li><p>一般公司会有三套服务器：本地测试服务器、外网测试服务器、外网正式服务器<br>内网测试可以直接测试服务器的并发连接性能<br>外网的话首先要考验你的互联网导致的延时和掉包的因素</p></li></ul><h3 id="1-1-4-内网和外网的区别"><a href="#1-1-4-内网和外网的区别" class="headerlink" title="1.1.4 内网和外网的区别"></a>1.1.4 内网和外网的区别</h3><p><font color=red>内网可以访问外网服务器，也可以设置不能访问。</font></p><p><font color=red>外网肯定不能访问内网服务器。</font></p><h4 id="1-内网"><a href="#1-内网" class="headerlink" title="1. 内网"></a>1. 内网</h4><p>内网就是我们平常说的局域网。</p><p>局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组。</p><ul><li>它可以是邻居之间的2台电脑，也可以是一幢100层大楼里的1000台电脑。</li><li><font color=red>可以是独立封闭运行的</font>（配置了服务器，建立了内部的web网页，论坛等等，但时不能上QQ、MSN等等，不能与外部发生通信），也可以是和外网相连接的</li></ul><h4 id="2-外网"><a href="#2-外网" class="headerlink" title="2. 外网"></a>2. 外网</h4><p>外网就是与internet连接的网络，可以跟世界上任何地方取得联系，但不能访问人家的内网服务器。外网就不经路由器或交换机就可以上网的网络，可以直接被外界所访问到。无需经如何设备，直接连接电脑。</p><h4 id="3-区分内网与外网"><a href="#3-区分内网与外网" class="headerlink" title="3. 区分内网与外网"></a>3. 区分内网与外网</h4><ul><li>用猫、路由器连接的都是外网。内网只用交换机<br>但是：有些光纤到楼、小区宽带、教育网、有线电视Cable Modem上网虽然地域范围比较大但本质上还是基于以太网技术，所以仍然属于内网。</li><li>判断内网和外网最简单的方法：判断网段 (有专业的方法，不会)</li><li><font color=red>内网IP的网段</font><ul><li>10.0.0.0 / 8:10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 / 12.172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 / 16.192.168.0.0 ~ 192.168.255.255</li></ul></li></ul><h4 id="4-为什么生活中很多的局域网？"><a href="#4-为什么生活中很多的局域网？" class="headerlink" title="4. 为什么生活中很多的局域网？"></a>4. 为什么生活中很多的局域网？</h4><p>其实<font color=red>外网IP是比较紧张的，现在的电脑的普及使得外网IP根本不够用，根本做不到一台电脑一个外网IP</font>，内网的产生就是为了解决这个难题的！</p><p>路由器只需一个外网IP就可以供下面的N多电脑联网。因为不同的内网IP是可以重复使用（任何一台电脑要上网，都必须在网络上有一个唯一的IP地址。在局域网内，这个IP地址是唯一的。但是在另外一个局域网，这个IP地址仍然能够使用）。拿网吧举例，一个网吧N多台电脑，其实他只要一个外网IP就可以给下面的电脑提供上网</p><h2 id="1-2-服务器容器"><a href="#1-2-服务器容器" class="headerlink" title="1.2 服务器容器"></a>1.2 服务器容器</h2><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = "/images/ComNet/container_server.jpg" width = '40%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = "/images/ComNet/containers.jpg" width = '50%' align:left style='margin-left:10%'><h3 id="1-2-1-Servlet容器"><a href="#1-2-1-Servlet容器" class="headerlink" title="1.2.1 Servlet容器"></a>1.2.1 Servlet容器</h3><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h3 id="1-2-2-Java-WEB容器"><a href="#1-2-2-Java-WEB容器" class="headerlink" title="1.2.2 Java WEB容器"></a>1.2.2 Java WEB容器</h3><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h3 id="1-2-3-Java-EE容器"><a href="#1-2-3-Java-EE容器" class="headerlink" title="1.2.3 Java EE容器"></a>1.2.3 Java EE容器</h3><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h2 id="1-3-举例说明容器与服务器的联系"><a href="#1-3-举例说明容器与服务器的联系" class="headerlink" title="1.3 举例说明容器与服务器的联系"></a>1.3 举例说明容器与服务器的联系</h2><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h3 id="1-3-1-Apache、Nginx、IIS"><a href="#1-3-1-Apache、Nginx、IIS" class="headerlink" title="1.3.1 Apache、Nginx、IIS"></a>1.3.1 Apache、Nginx、IIS</h3><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><p>Nginx：</p><ul><li>代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>nginx除了是个web服务器还能够做反向代理服务器，反向代理服务器的作用，可以用来做负载均衡代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>也可以用nginx来做负载均衡</li></ul><h3 id="1-3-2-Node没有Web容器"><a href="#1-3-2-Node没有Web容器" class="headerlink" title="1.3.2 Node没有Web容器"></a>1.3.2 Node没有Web容器</h3><ul><li>.net平台的 ASP或者ASP.net 需要 <code>IIS</code> 作为服务器容器</li><li>PHP需要搭载 Apache 或者 <code>Nginx</code> 作为服务器容器</li><li>Java 的 JSP 需要 <code>Tomcat</code> 作为服务器容器</li><li>ruby 的 ruby on rails 需要 搭配 <code>Apache</code> 等作为自己的服务器容器。。。</li></ul><p>如果我用 js 写了一个 web 应用程序，那么 node 就是web服务器，Node，不需要服务器容器。</p><h3 id="1-3-3-Tomcat及常见的JavaEE应用服务器"><a href="#1-3-3-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="1.3.3 Tomcat及常见的JavaEE应用服务器"></a>1.3.3 Tomcat及常见的JavaEE应用服务器</h3><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h3 id="1-3-4-Nginx-Tomcat的WEB应用服务器-集群"><a href="#1-3-4-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="1.3.4 Nginx + Tomcat的WEB应用服务器(集群)"></a>1.3.4 Nginx + Tomcat的WEB应用服务器(集群)</h3><img src = "/images/ComNet/nginx_tomcat.jpg" width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="1-4-服务器开发"><a href="#1-4-服务器开发" class="headerlink" title="1.4 服务器开发"></a>1.4 服务器开发</h2><p>开发服务器的语言很多：Java、PHP、.net、node.js、python、go、ruby、erlang等等</p><p>不同语言开发的服务器，对应的配置电脑为服务器的软件也不一样(这里说的都是Windows系统的)</p><ul><li>java — Tomcat</li><li>php — wamp (w-windows、a-apache、m - mysql、p-php)</li><li>node.js — NodeJS</li></ul><h2 id="1-5-Apache服务器的配置"><a href="#1-5-Apache服务器的配置" class="headerlink" title="1.5 Apache服务器的配置"></a>1.5 Apache服务器的配置</h2><p>在iOS与前端的学习中，Apache使用起来最方便。所以这里主要说Web服务器：- http服务器： - Apache服务器</p><p>Apache服务器的配置</p><ul><li>Windows系统：wamp软件安装，然后修改一些配置信息</li><li>Mac系统：自带有Apache服务器，通过终端配置一些信息，然后打开即可</li></ul><p>在配置信息中，我们会<font color=red>指定一个文件夹，作为别人访问我们的电脑服务器时能获取到的文件 — 网站根目录</font></p><p>被访问的时候</p><ul><li>如果网站根目录中，<font color=red>有index命名的文件(不管是HTML文件，还是PHP文件)，会直接运行.</font></li><li>如果没有index命名的，那么就会将该文件夹内的文件，以列表形式展示出来.</li></ul><h2 id="1-6-PHP开发服务器是怎么工作的"><a href="#1-6-PHP开发服务器是怎么工作的" class="headerlink" title="1.6 PHP开发服务器是怎么工作的"></a>1.6 PHP开发服务器是怎么工作的</h2><p>PHP服务器，是怎么接收的？</p><h3 id="1-6-1-创建PHP文件"><a href="#1-6-1-创建PHP文件" class="headerlink" title="1.6.1 创建PHP文件"></a>1.6.1 创建PHP文件</h3><ul><li><p>.php文件，写PHP代码，也可以写HTML+CSS+JS代码，跟写在.html文件中，显示效果一模一样。</p><p>不过，PHP代码，需要写在 <?php ?> 标签中，而且标签内只能写PHP代码。</p></li><li><p>.html文件里，不能写PHP代码</p></li></ul><p><font color=red>要放在我们服务器里的根目录里，PHP代码只有放在服务器中，被访问的时候，才会执行</font></p><h3 id="1-6-2-取值"><a href="#1-6-2-取值" class="headerlink" title="1.6.2 取值"></a>1.6.2 取值</h3><p>别人根据URL，访问该PHP文件的时候，如果携带参数，那就会将参数，传值到该文件</p><p>取值：php中为我们预定义了几个 超全局对象</p><ul><li><p>GET取值：$_GET 是一个关系型数组 $_GET[‘key’]</p></li><li><p>POST取值：$_POST 也是一个关系型数组 $_POST[‘key’]</p></li><li><p>POST上传文件: $_FILES</p><p>获取 上传的文件信息 关系型数组 <code>$fileArr = $_FILES[&#39;upFile&#39;];</code></p><p>获取 上传的文件的原本名字 <code>$fileName = $fileArr[&#39;name&#39;];</code></p><p>获取保存在服务器的那个位置 <code>$filePath = $fileArr[&#39;tmp_name&#39;];</code></p><p>PHP将上传的文件，保存至指定位置</p><ul><li><p>参数1：是从上传的文件信息中，取的Path值</p></li><li><p>参数2：我们指定的存储位置</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(<span class="variable">$filePath</span>,’文件夹/‘.<span class="variable">$fileName</span>); <span class="comment">//注意：<span class="doctag">bug:</span> Mac本上，必须要设置一些指定路径文件夹的权限，设置为everyone可读写，否则，访问的时候，是写不进去东西的</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：key的值就是提交的参数名，需要保持一致</p><h3 id="1-6-3-返回访问结果"><a href="#1-6-3-返回访问结果" class="headerlink" title="1.6.3 返回访问结果"></a>1.6.3 返回访问结果</h3><p><font color=red>如果请求的是HTML文件：原封不动返回，服务器不会动这个HTML文件</font></p><p><font color=red>如果请求的是PHP文件：</font></p><ul><li><p>HTML部分的代码，原封不动的返回</p></li><li><p><code>&lt;?php ?&gt;</code>里的PHP代码，<font color=red>在服务器端执行</font>，只返回输出函数：echo、print_f 打印的结果</p></li></ul><h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><p>试想一下,如果一个网站的注册用户有1千万个那么应该使用什么格式,什么方式来保存这些数据呢?</p><h2 id="3-1-常规保存方式"><a href="#3-1-常规保存方式" class="headerlink" title="3.1 常规保存方式"></a>3.1 常规保存方式</h2><h3 id="3-1-1-txt文件"><a href="#3-1-1-txt文件" class="headerlink" title="3.1.1 .txt文件"></a>3.1.1 .txt文件</h3><p>因为内容是文本,所以直接使用文本文件保存肯定可以,但是当一个文本文件很大很大时,打开是异常缓慢的</p><h3 id="3-1-2-excel文件"><a href="#3-1-2-excel文件" class="headerlink" title="3.1.2 .excel文件"></a>3.1.2 .excel文件</h3><p>可以用来进行数据的统计,分析等操作,但是当很多个人需要访问同一个.excel文件时,性能也很差</p><h2 id="3-2-数据库"><a href="#3-2-数据库" class="headerlink" title="3.2 数据库"></a>3.2 数据库</h2><p>按照数据结构来组织,存储和管理数据的仓库,软件开发行业一般指的是数据库软件,常见的有:Oracle、MySQL、MSSQL等</p><p>特点:</p><ul><li>数据共享:多用户同时访问数据的稳定性</li><li>故障恢复:数据库软件提供了一套的方法,可以用来发现错误并且修复错误</li><li>减少数据冗余:由于大家都可以使用同一套数据,没有必要重复创建了</li></ul><h2 id="3-3-DBA"><a href="#3-3-DBA" class="headerlink" title="3.3 DBA"></a>3.3 DBA</h2><p>数据库管理员（Database Administrator，简称DBA）</p><p>从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支</p><p>工作是:</p><ol><li>主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</li><li>保证数据库的稳定性、安全性、完整性和高性能.</li></ol><p>在国外，也有公司把DBA称作数据库工程师(Database Engineer)，两者的工作内容基本相同，都是保证数据库服务7*24小时的稳定高效运转，但是需要区分一下DBA和数据库开发工程师(Database Developer)：</p><ol><li>数据库开发工程师的主要职责是设计和开发数据库管理系统和数据库应用软件系统，侧重于软件研发；</li><li>DBA的主要职责是运维和管理数据库管理系统，侧重于运维管理。</li></ol><h1 id="三、网络编程-—-BS-CS模式"><a href="#三、网络编程-—-BS-CS模式" class="headerlink" title="三、网络编程 — BS/CS模式"></a>三、网络编程 — BS/CS模式</h1><p>网络编程 是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：</p><ul><li>这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</li><li>无论是C/S，还是B/S都需要联网，所以不需要互联网的单机软件不在讨论范围内。</li></ul><h2 id="3-1-C-S架构-client-server"><a href="#3-1-C-S架构-client-server" class="headerlink" title="3.1 C/S架构(client/server)"></a>3.1 C/S架构(client/server)</h2><blockquote><p>指的是客户端，服务器架构的意思,很多常见的软件都是这种架构</p></blockquote><ul><li><strong>解释：</strong>对于C/S架构，最为常见的例子就是网络游戏，比如LOL、WOW如果不联网无法使用，你在软件内所做的所有操作通过互联网能够传递到其他的的玩家身上。</li><li><strong>优点:</strong><ul><li>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可</li><li>界面酷炫：客户端可以使用更多系统提供的效果(比如传感信息，浏览器就很难做到),做出更为炫目的效果</li></ul></li><li><strong>缺点:</strong><ul><li>更新软件：如果推出了新版本,不更新客户端无法登陆使用(一部分)</li><li>不同设备访问：如果使用其他的电脑,没有安装客户端的话就无法登陆软件(比如收发邮件)</li></ul></li></ul><h2 id="3-2-B-S架构-Browser-Server"><a href="#3-2-B-S架构-Browser-Server" class="headerlink" title="3.2 B/S架构(Browser/Server)"></a>3.2 B/S架构(Browser/Server)</h2><blockquote><p>指的是浏览器—服务器，是WEB兴起之后的一种架构</p></blockquote><ul><li><strong>解释：</strong>现在所有的网站都是B/S架构,较为常见的例子有百度,知乎,网易云音乐Web等等,所有只需要通过浏览器即可使用.</li><li><strong>优点:</strong><ul><li>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容,但是对用户而言只需要刷新浏览器即可</li><li>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用</li></ul></li><li><strong>缺点:</strong><ul><li>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小</li><li>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一,移动设备兼容性较好,ie6已经越来越少人用了</li></ul></li></ul><h1 id="四、网络通讯模型及协议"><a href="#四、网络通讯模型及协议" class="headerlink" title="四、网络通讯模型及协议"></a>四、网络通讯模型及协议</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>在都知道了浏览器、客户端、服务器、数据库是什么之后，接下来就是核心-重点：浏览器/客户端与服务器之间的网络通讯</p><p><strong>学习网络编程：</strong></p><ol><li>可以掌握实时更新数据的手段</li><li>是开发优秀应用的前提和基础</li></ol><p><strong>网络通讯三要素:传输协议、端口号、IP</strong></p><p>通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据</p><img src="/images/ComNet/网络通讯.png" alt="img" style="zoom:90%;" /><h2 id="4-2-OSI七层模型"><a href="#4-2-OSI七层模型" class="headerlink" title="4.2 OSI七层模型"></a>4.2 OSI七层模型</h2><p>要了解传输协议，首先需要知道传输过程中分为哪几层传输，每一层的传输协议是不一样的。</p><img src="/images/ComNet/OSI七层模型.png" alt="img" style="zoom:90%;" /><table><thead><tr><th>分层</th><th>功能及协议</th></tr></thead><tbody><tr><td>应用层</td><td>网络服务与最终用户的一个接口  HTTP/HTTPS超文本传输协议、FTP文件传输协议、SMTP邮件传输协议</td></tr><tr><td>表示层</td><td>数据的表示、安全、压缩。</td></tr><tr><td>会话层</td><td>建立、管理、终止会话</td></tr><tr><td></td><td>以上三层：http协议(所有的万维网文件都必须遵守)、HLS(渐进流式传输协议，苹果改造HTTP协议创建的流媒体协议)、RTMP/MMS(实时流式传输协议-微软出品)、XMPP/IMPP/PRIM/SIP(四种IM(即时消息通讯)协议，XMPP最灵活常用) 等等好多好多协议</td></tr><tr><td>传输层</td><td><font color=red>遵循TCP/UDP协议，定义传输数据的协议端口号</font> HTTP协议的端口号默认是80，我们可以根据自己实际情况改的</td></tr><tr><td>网络层</td><td>路由器 <font color=red>遵循IP协议，会给电脑分配IP</font>，进行逻辑地址寻址</td></tr><tr><td>数据链路层</td><td>网卡、网桥、交换机 建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）</td></tr><tr><td>物理层</td><td>光纤、电话线 建立、维护、断开物理连接。（由底层网络定义协议）</td></tr></tbody></table><p>注意：</p><ol><li>传输层和上面的三层就是在客户端里的了</li><li>会话层、表示层、应用层在五层模型中合并为应用层</li></ol><h3 id="OSI模型通讯"><a href="#OSI模型通讯" class="headerlink" title="OSI模型通讯"></a>OSI模型通讯</h3><img src="/images/ComNet/OSI模型通讯.png" alt="img" style="zoom:90%;" /><p>解析说明：计算机A -&gt; B，之所以叫封包/解包，是因为当我们应用层需要获取数据时</p><ul><li>会在应用层生成一个请求的数据包(是按照<font color=red>HTTP协议生成</font>的)</li><li>然后到了传输层，会按照TCP/UDP协议进行封装包装，<font color=red>加了个端口号</font></li><li>到了网络层进行IP协议的封装，<font color=red>加了个协议号</font></li><li>然后经过下两层传到服务器</li><li>服务器会进行一一相对应的解封，知道服务器的应用层，会按照请求，返回响应(响应返回去的过程与来时一样)</li></ul><h2 id="4-3-HTTP协议-定义数据格式"><a href="#4-3-HTTP协议-定义数据格式" class="headerlink" title="4.3 HTTP协议 - 定义数据格式"></a>4.3 HTTP协议 - 定义数据格式</h2><h3 id="4-3-1-HTTP协议概述"><a href="#4-3-1-HTTP协议概述" class="headerlink" title="4.3.1 HTTP协议概述"></a>4.3.1 HTTP协议概述</h3><blockquote><p>协议：经过双方或多方共同商量或谈判后取得的一致意见：双方达成协议｜根据协议办事 | 遵守这样的约束。</p></blockquote><ul><li>网络之间传输数据就需要协议。</li><li>所谓的协议就是双方约定好的一些数据格式。否则两台计算机之间如何识别对方发送过来的 0 1 数据。</li></ul><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>HTTP（Hyper Text Transfer Protocol），超文本(图片，视频，zip等)传输协议，是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。所以<strong>HTTP协议就是 浏览器 和 服务器 之间通信的一个数据格式规范</strong>。</li><li>HTTP 协议是网络编程使用最为广泛的协议，因为很简单</li><li>它是一个应用层协议，承载于TCP之上</li><li>HTTP协议用于客户端和服务器端之间的通信。由请求和响应构成，是一个标准的客户端服务器模型<ul><li>在两台计算机之间使用HTTP协议通信时，必定一端担任客户端角色，另一端担任服务器端角色</li></ul></li><li>通过请求和响应的交换达成通信。是问答式交互，客户端和服务器一问一答进行通信<ul><li>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回</li><li>也就是说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求时，<strong>不会主动向浏览器推送数据</strong>。这样是安全考虑，也是提高服务器性能的考虑。如果要服务器向浏览器推送数据，则需要使用Socket.IO等额外的技术来解决。</li></ul></li></ul><p>请求响应实例：请求访问某台HTTP服务器上的/index.htm页面资源：</p><ul><li>起始行开头的GET：表示请求访问服务器的类型，称为方法</li><li>随后的字符串/index.html：指明了请求访问的资源对象，也叫请求URI</li><li>最后的HTTP/1.1，即HTTP版本号用来提示客户端使用的HTTP协议的功能</li></ul><img src="/images/ComNet/http-reqres-example.png" style="zoom:80%"><h4 id="2-HTTP协议中的内容"><a href="#2-HTTP协议中的内容" class="headerlink" title="2. HTTP协议中的内容"></a>2. HTTP协议中的内容</h4><ul><li>规定URL的格式<ul><li>协议:// 主机地址: 端口号//路径</li><li><a href="http://www.baidu.com/">http://www.baidu.com</a>: 80//…… (http默认的端口号是80，可以省)</li></ul></li><li>规定客户端和服务器之间的数据传输格式，让客户端和服务器能有效地进行数据沟通<ul><li>规定请求怎么发</li><li>规定响应怎么发</li></ul></li></ul><h4 id="3-HTTP协议特点"><a href="#3-HTTP协议特点" class="headerlink" title="3. HTTP协议特点"></a>3. HTTP协议特点</h4><ol><li>简单快速。HTTP协议简单，所以 HTTP 服务器的程序规模小，通信速度快</li><li>灵活。HTTP 允许传输任意类型的数据</li></ol><h4 id="4-HTTP的版本"><a href="#4-HTTP的版本" class="headerlink" title="4. HTTP的版本"></a>4. HTTP的版本</h4><ul><li>HTTP 0.9 和 1.0 使用非持续连接：限制每次连接只处理一个请求，服务器对客户端的请求做出响应后，立刻断开连接，这种方式可以节省传输时间</li><li>HTTP 1.1 使用持续连接（如今最常用）：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，不会创建那么多的请求了</li></ul><h4 id="5-协议的请求、响应结构"><a href="#5-协议的请求、响应结构" class="headerlink" title="5. 协议的请求、响应结构"></a>5. 协议的请求、响应结构</h4><img src="/images/ComNet/http-structure.png" style="zoom:70%"><h3 id="4-3-2-请求报文的格式"><a href="#4-3-2-请求报文的格式" class="headerlink" title="4.3.2 请求报文的格式"></a>4.3.2 请求报文的格式</h3><blockquote><p>客户端向服务器索取数据的一种行为</p></blockquote><h4 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的由客户端发给服务器的 HTTP 请求报文 需要包含以下内容：</p><ul><li><p><strong>请求行</strong></p><ul><li>客户端给服务器的一些额外信息，指定 请求方法、请求资源路径 以及 HTTP协议版本</li><li>格式：<code>请求Method /路径(请求URI) 协议版本</code></li></ul></li><li><p><strong>请求头</strong></p><ul><li><font color=red>请求头中至少包含以下信息</font><ul><li>客户端要访问的服务器主机地址 Host: m.baidu.com</li></ul></li><li>请求头中还可以包含以下附加信息（<strong>可选的请求首部字段</strong>）<ul><li>客户端的类型，客户端的软件环境User-Agent: iPhone AppleWebKit</li><li>客户端所能接收的数据类型Accept: text/html, <em>/</em></li><li>客户端的语言环境Accept-Language: zh-cn</li><li>客户端支持的数据压缩格式Accept-Encoding: gzip</li><li>访问结束后，是否断开连接Connection: Close</li></ul></li></ul></li><li><p><strong>请求体(可选)</strong></p><ul><li>客户端发给服务器的具体数据，例如要上传的文件数据（<strong>内容实体</strong>）</li><li>请求格式<ul><li>每一项请求信息末尾使用 \r\n</li><li>最后一个请求项末尾使用 \r\n\r\n 表示请求结束</li></ul></li></ul></li></ul><img src="/images/ComNet/http-req-msg.png" style="zoom:70%"><h4 id="2-请求方法Method"><a href="#2-请求方法Method" class="headerlink" title="2. 请求方法Method"></a>2. 请求方法Method</h4><blockquote><p>HTTP 协议的请求行有一个请求方法, 它有 8 种, 但是我们只要了解五种 (GET,POST,HEAD,DELETE,PUT)。</p></blockquote><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p><p>方法的作用在于：可以指定请求的资源按期望产生某种行为。</p><img src="/images/ComNet/http-req-method.png" style="zoom:70%"><p>HTTP/1.0和HTTP/1.1支持的方法：(LINK和UNLINK已被HTTP/1.1废弃，不再支持)</p><img src="/images/ComNet/http-req-method2.png" style="zoom:70%"><h5 id="1-GET"><a href="#1-GET" class="headerlink" title="1) GET"></a>1) GET</h5><ol><li>GET 的本质是“得”，从服务器拿数据，效率更高。<font color=red>GET请求能够被缓存，保存在 Cache 目录中 \bundleId 下 Cache.db 中</font><ul><li>cfurl_cache_receiver_data，缓存所有的请求数据</li><li>cfurl_cache_response，缓存所有的响应</li></ul></li><li>在 HTTP 协议定义中，没有对 GET 请求的数据大小限制，不过因为浏览器不同，一般限制在 2~8K 之间</li><li>所有的参数包装在URL中，并且服务器的访问日志会记录，不要传递敏感信息</li></ol><p><font color=red>GET实现网址跳转的原理：</font></p><ul><li>拼接网址，然后跳转。在URL添加参数, 首先在URL 添加一个? , 表示要追加参数, 多个参数用&amp; 连接，然后跳转到这个拼接后的网址</li><li>格式:<a href="http://127.0.0.1/login.php">http://127.0.0.1/login.php</a> ? username = aaa &amp; password = bbb(username和password是服务器后台给我们的文档中固定的)</li><li>注意：<ul><li>http 默认的请求的方法就是GET，是网络访问使用频率最好的方法。</li><li>GET请求能够被缓存(存储在沙盒Cache中，电脑浏览器也可以缓存在历史记录，服务器也可以缓存)(一般来讲用get请求过的网页，下次可能会快点)</li><li><font color=red>如果URL中有中文或者空格，创建出来的URL是空的</font> ，程序会崩溃需要进行%号转义，对URL 进行编码<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[urlString stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-POST"><a href="#2-POST" class="headerlink" title="2) POST"></a>2) POST</h5><ol><li>POST 的本质是<font color=red>“给”</font>，向服务器发送数据，也可以获得服务器处理之后的结果，效率不如 GET</li><li>POST请求不能被缓存</li><li>POST提交数据比较大，大小靠服务器的设定值限制，PHP通常限定 <font color=red>2M</font></li><li>URL中，只有资源路径，但不包含参数，<font color=red>服务器日志不会记录参数</font>，相对更安全</li><li>参数被包装成二进制的数据体，<font color=red>放在请求体中</font>，格式与 GET 基本一致，只是不包含 ?</li></ol><p>所有设计用户隐私的数据（密码，银行卡号）一定记住使用 POST 方式传递</p><p><font color=red>POST代码中，要用NSMutableURLRequest，要设置HTTPMethod和HTTPBody</font></p><h5 id="3-GET-和-POST-的区别"><a href="#3-GET-和-POST-的区别" class="headerlink" title="3) GET 和 POST 的区别"></a>3) GET 和 POST 的区别</h5><p><strong>显示：</strong></p><ul><li>Post传输数据时，不需要在URL中显示出来，是写在请求体中的，格式一样，没有 ？号，而Get方法会在URL中显示参数值、文件名字。</li><li>get提交格式：url后跟着”?”，由于客户端可能向服务器提交多个键值对，键值对之间用”&amp;”进行分割，如果url中有汉字、特殊符号，则需要对url进行编码</li></ul><p><strong>大小：</strong></p><ul><li><font color=red>http 协议中的 get/post 并没有发送数据大小的限制</font>，对发送数据大小产生限制的是浏览器以及操作系统、服务器。<font color=red>http 本身并没有对 url 长度有所限制。</font></li><li>IE 对 URL 长度的限制是 2083字节（&lt;=IE 8）。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统以及服务器的支持。而 chrome 遇到长度很长的 URL 时，会直接 崩溃。URL 长了，对服务器处理本来也是一种负担</li></ul><p><strong>缓存：</strong></p><ul><li>GET会被手机端cache、web浏览器历史记录、服务器各种缓存，POST不会</li></ul><p><strong>规定：</strong></p><ul><li>根据HTTP规范：Post就是为了将数据传送到服务器段，Get就是为了从服务器段取得数据。而Get之所以也能传送数据，只是用来设计告诉服务器，你到底需要什么样的数据。Post的信息作为http请求的内容，而Get是在Http头部传输的。 </li></ul><p><strong>选择：</strong></p><ul><li>一般来讲：开发的时候，这个都是后台告诉我们的</li><li>而如果是自己写,前台后台都是由我们决定的，可以自由选取使用的方式，当某种方式无法实现需求时，再去进行更改，但就提交普通的文本数据而言get跟post是一致的，post所谓的安全性跟get相比也只是多一些而已</li></ul><p>在web中：</p><ul><li>如果要传递大数据量不能用get，必然要type=“file”上传文件，type:”password”传递密码或者<code>&lt;textarea&gt;</code>提交大量文本字段。</li><li>表单域只有设定了name属性的表单元素才会被提交给服务器</li><li>如果给submit按钮设定了name，那么按钮的value也会被提交到服务器</li><li>对于post的表单重新敲地址栏再刷新就不会提示重新提交了，因为重新敲地址就没有偷偷提交的数据了。</li></ul><h5 id="4-POST增强"><a href="#4-POST增强" class="headerlink" title="4) POST增强"></a>4) POST增强</h5><p>包括：</p><ul><li>上传单文件</li><li>上传多文件</li><li>POST JSON</li><li>POST 自定义对象(对象转字典)</li></ul><p>小文件上传</p><ul><li><p>大小一般都是有限制的 <font color=red>2-8k</font> ，php默认限制是 <font color=red>2M</font> ，超过2M的部分上传不上去的，新浪微博上传图片，单张最大允许 <font color=red>5M</font></p></li><li><p>单个小文件</p><p>应用场景：上传用户的头像</p></li><li><p>多个小文件</p><p>应用场景：微信朋友圈，微博</p></li></ul><h4 id="3-常见的其他请求头字段"><a href="#3-常见的其他请求头字段" class="headerlink" title="3. 常见的其他请求头字段"></a>3. 常见的其他请求头字段</h4><img src="/images/ComNet/请求.jpeg" style="zoom:75%;" /><ul><li>User-Agent<ul><li>浏览器的具体类型　　</li><li>如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0</li></ul></li><li>Accept<ul><li>浏览器支持哪些数据类型　　</li><li>如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;</li></ul></li><li>Accept-Charset<ul><li>浏览器采用的是哪种编码　　</li><li>如：Accept-Charset: ISO-8859-1</li></ul></li><li>Accept-Encoding<ul><li>浏览器支持解码的数据压缩格式　　</li><li>如：Accept-Encoding: gzip, deflate</li></ul></li><li>Accept-Language<ul><li>浏览器的语言环境　　</li><li>如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</li></ul></li><li>Host<ul><li>请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:<a href="http://www.baidu.com/">www.baidu.com</a></li></ul></li><li>Connection<ul><li>表示是否需要持久连接。Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive</li></ul></li><li>Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。</li><li>Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</li><li>Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</li><li>Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</li><li>Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: <a href="http://www.baidu.com/">http://www.baidu.com/</a></li></ul><h3 id="4-3-3-响应报文"><a href="#4-3-3-响应报文" class="headerlink" title="4.3.3 响应报文"></a>4.3.3 响应报文</h3><blockquote><p>服务器对客户端的请求做出的反应，一般指返回数据给客户端</p></blockquote><h4 id="1-格式-1"><a href="#1-格式-1" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的 HTTP 响应报文包含以下内容：</p><ul><li><strong>状态行</strong><ul><li>格式：<code>HTTP协议版本 状态码 用以解释状态码的原因短语</code>。</li></ul></li><li><strong>响应头</strong><ul><li>服务器返回给客户端的一些额外信息，包含了对服务器的描述、对返回数据的描述<ul><li>服务器的类型Server: Apache/2.4.10 (Unix) PHP/5.5.20</li><li>返回数据的类型Content-Type: text/html</li><li>返回数据的长度Content-Length: 660</li><li>响应时间Date: Thu, 04 Jun 2015 19:31:50 GMT</li><li>ETag(HASH值，用于检测本地资源和服务器资源是否一致)ETag: “294-4e1862f57e7c0”</li></ul></li></ul></li><li><strong>实体内容</strong><ul><li>服务器返回给客户端的具体二进制数据。如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。</li></ul></li></ul><img src="/images/ComNet/http-res-msg.png" style="zoom:65%"><h4 id="2-响应的状态码"><a href="#2-响应的状态码" class="headerlink" title="2. 响应的状态码"></a>2. 响应的状态码</h4><p>作用：当客户端向服务器发送请求时，描述请求的返回结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><table><thead><tr><th></th><th><strong>类别</strong></th><th><strong>原因短语</strong></th></tr></thead><tbody><tr><td>1XX</td><td>信息状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求，客户端的请求有错误</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table><img src="/images/ComNet/res-status-code.jpg" alt="图片" style="zoom:90%;" /><h4 id="3-响应的content-Type"><a href="#3-响应的content-Type" class="headerlink" title="3. 响应的content-Type"></a>3. 响应的content-Type</h4><ul><li>Content-Type：text/html; charset=utf-8表示返回数据的类型</li><li>服务器通过Content-Type告诉客户端<strong>响应的数据的类型</strong>，这样<strong>浏览器就根据返回数据的类型来进行不同的处理</strong>：<ul><li>如果是图片类型就显示：image/jpeg</li><li>如果是文本类型就直接显示内容：text/plain</li><li>如果是文本类型的html格式就用浏览器渲染该格式：text/html</li><li>……</li></ul></li><li>常用Content-Type：text/html、image/gif、image/jpeg、text/plain、text/javascript…</li><li>Content-Length:表示响应报文体的字节长度，报文头只是描述，返回的具体数据在两个回车之后的内容中</li></ul><p>默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；</p><p>比如，我们返回的是一段HTML，但是没有指定格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res1.jpg" alt="图片" style="zoom:100%;" /><p>但是，如果我们指定了格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf8&quot;</span>);</span><br><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res2.jpg" alt="图片" style="zoom:90%;" /><p>如果我们希望返回一段JSON数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-常见的其他响应头字段"><a href="#4-常见的其他响应头字段" class="headerlink" title="4) 常见的其他响应头字段"></a>4) 常见的其他响应头字段</h4><img src="/images/ComNet/响应.jpeg" alt="响应" style="zoom:90%;" /><ul><li><p>Cache-Control </p><ul><li>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 </li><li>下面的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。</li><li><code>Cache-Control: max-age=3600</code></li></ul></li><li><p>ETag</p><ul><li>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。</li><li><code>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></li></ul></li><li><p>Location</p><ul><li>我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：</li><li><code>Location: http://www.google.com.hk</code></li></ul></li><li><p>Set-Cookie</p><ul><li>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。</li><li><code>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</code></li></ul></li></ul><h3 id="4-3-4-HTTP—持久连接"><a href="#4-3-4-HTTP—持久连接" class="headerlink" title="4.3.4 HTTP—持久连接"></a>4.3.4 HTTP—持久连接</h3><p>早期的HTTP连接模型：每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销</p><img src="/images/ComNet/http-short-connect.png" style="zoom:70%"><p><strong>在 HTTP 1.0 中</strong>, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加<code>Connection: Keep-Alive</code>，然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中<code>Connection: Keep-Alive</code>。</p><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p><p><strong>HTTP持久连接</strong>（<strong>HTTP persistent connection</strong>，也称作<strong>HTTP keep-alive</strong>或<strong>HTTP connection reuse</strong>）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。</p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。然而， Apache 2.0 httpd 的<strong>默认连接过期时间</strong>是仅仅15秒，对于 Apache 2.2 只有5秒。短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。</p><img src="/images/ComNet/http-long-connect.png" style="zoom:70%"><p>特点：只要任意一端没有明确提出断开连接，则保持连接状态。</p><p>好处：</p><ul><li>减少了连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</li><li>减少开销的那部分时间，使HTTP请求和响应能够更早的结束，Web页面显示速度也响应提高</li></ul><h3 id="4-3-5-HTTP—无状态"><a href="#4-3-5-HTTP—无状态" class="headerlink" title="4.3.5 HTTP—无状态"></a>4.3.5 HTTP—无状态</h3><ul><li>HTTP协议是无状态的。使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前的一切的请求或响应报文的信息。</li><li>这是为了更快的处理大量事物，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。正因为HTTP协议本身非常简单，所以才被应用到各种场景</li><li><strong>如果让服务器管理全部客户端状态则会成为很大的负担。</strong>由于不必保存状态，自然可以减少服务器的CPU及内存资源的消耗</li><li>所以哪怕在同一个页面中的js、css、jpg也都要重复的提交Accept-Language、Accept-Encoding、Cookie等</li></ul><h3 id="4-3-6-Cookie"><a href="#4-3-6-Cookie" class="headerlink" title="4.3.6 Cookie"></a>4.3.6 Cookie</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的。</li><li>保留无状态优点的同时又要解决类似的矛盾问题，于是引入了Cookie技术。</li><li>Cookie(曲奇饼)，可以记录服务器与客户端之间的状态</li><li>Cookie是一个由浏览器和服务器共同协作实现的规范。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<ul><li>服务器向客户端发送Cookie<ul><li>是在响应头中</li><li>Set-Cookie:name=value; Path=/; Max-Age=; Domain=*.com<ul><li>name=value; 必须包含</li><li>Path=/; 表示Cookie影响的路径，当访问路径不匹配时，浏览器不会发送该Cookie。<code>/</code>表示该请求下所有路径都发送，也可以指定子路径。</li><li>Max-Age：告诉浏览器该Cookie多长时间过期，单位为秒</li><li>HttpOnly：告知浏览器不允许通过脚本document.cookie访问</li></ul></li></ul></li><li>浏览器将Cookie保存</li><li>之后在每一次请求中浏览器都会将Cookie发向服务器。此时服务器就知道是哪个客户端了。<ul><li>Cookie值的格式是 key=value; foo=bar的形式</li><li>客户端发送的Cookie在请求报文的Cookie字段中</li></ul></li></ul></li></ul><img src="/images/ComNet/http-cookie-no.png" style="zoom:60%"><img src="/images/ComNet/http-cookie-yes.png" style="zoom:60%"><p>Cookie-请求响应报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.客户端第一次请求报文</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">* 首部字段内没有Cookie的相关信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.服务器端响应报文（生成Cookie信息）</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, =&gt;10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.客户端请求报文（自动发送保存着Cookie的信息）</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure><h4 id="2-Cookie的问题"><a href="#2-Cookie的问题" class="headerlink" title="2. Cookie的问题"></a>2. Cookie的问题</h4><ul><li>不能存储太多内容。因为Cookie体积过大会造成请求和响应速度变慢，所以尽量不要再Cookie中存储大量数据</li><li>将静态资源存储在单独的机器上避免Cookie的无效传输</li><li>不安全。Cookie可以在前后端修改，数据容易被篡改和伪造。所以Cookie对于敏感数据的保护基本是无效的</li></ul><h3 id="4-3-7-Session"><a href="#4-3-7-Session" class="headerlink" title="4.3.7 Session"></a>4.3.7 Session</h3><ul><li>为了解决Cookie无法存储大量数据，以及不安全的问题，Session被设计出来了。</li><li>Session的数据是只保留在服务器端的，客户端无法修改。</li><li>Session不是什么新技术，是基于Cookie实现的。需要和cookie搭配来使用</li><li>服务器端保存key（口令）/value（数据）对象，客户端保存，key（口令），一旦口令被篡改，就丢失了映射关系。服务器端用cookie里面的key来查找对应的session值。</li><li>session可以存在内存或硬盘上都可以。<ul><li>将Session集中化，使用Redis、Memcached等高效的缓存服务器技术</li></ul></li></ul><p>Session的口令依旧保存在客户端，还是存在口令被盗用和伪造的情况，解决方案是将口令通过私钥加密进行签名，使得伪造成本更高</p><h3 id="4-3-8-HTTP-2-0"><a href="#4-3-8-HTTP-2-0" class="headerlink" title="4.3.8 HTTP 2.0"></a>4.3.8 HTTP 2.0</h3><p>HTTP2.0了解吗，相比之前的优化</p><ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送： <a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">HTTP/2 服务器推送（Server Push）教程</a> 也得先客户端发起请求，只不过服务器可以额外推送几个附带资源(不用请求)而已，是需要配置的。</li></ul><h2 id="4-4-TCP-UDP协议-端口号"><a href="#4-4-TCP-UDP协议-端口号" class="headerlink" title="4.4 TCP/UDP协议 - 端口号"></a>4.4 TCP/UDP协议 - 端口号</h2><h3 id="4-4-1-TCP-UDP协议"><a href="#4-4-1-TCP-UDP协议" class="headerlink" title="4.4.1 TCP/UDP协议"></a>4.4.1 TCP/UDP协议</h3><p><strong>TCP(传输控制协议) —生成流式Socket</strong></p><ul><li>建立连接，形成传输数据的通道，在连接中进行<font color=red>大数据传输</font>(数据大小不受限制)</li><li>通过三次握手完成连接，是<font color=red>可靠协议</font>，能安全送达，但是由于必须建立连接，所以<font color=red>效率会稍低</font>.</li></ul><p><strong>TCP三次握手</strong></p><ol><li>客户端向服务器发送一个包，然后等服务器确认 （在吗）</li><li>服务器收到包，确认，然后发送给客户端一个包 （在）</li><li>客服端收到确认，再想服务器发送一个包 （那我就发数据了）</li></ol><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据</p><p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>UDP(数据报协议) —生成数据报Socket</strong></p><ul><li>将数据源和目的封装成数据包中，<font color=red>不需要建立连接</font>，只管发送，不确认对方是否接收到因为无需连接，因此是不可靠协议。不需要建立连接，速度快</li><li>每个数据报的<font color=red>大小限制在64K之内</font></li><li>应用场景：多媒体教室／网络流媒体/直播平台/游戏</li></ul><p><strong>对比：</strong></p><ul><li>TCP只是网络七大层协议中的一种，需要封装七层的，</li><li>UDP 使用UDP协议，是不用使用七大层封装的，可以直接发出去，这样的坏处就是会丢包，但也有好处：速度更块，实时性更好<ul><li>应用场景：网络直播(即使丢了几帧也没事)</li></ul></li><li><font color=red>TCP和UDP的表现形式，可以比喻为打电话 比 对讲机</font><ul><li>前者可以听的同时也说(也就是发送的时候，也可以接受)</li><li>后者只能发或者接，不能同时接发</li></ul></li><li>像腾讯微信QQ，语音对讲表现形式虽然是UDP，但是因为丢包，所以实质上是使用的TCP(刚开始使用的是UDP，后来改的)，像好多大公司，一般都会自己写底层协议</li></ul><h3 id="4-4-2-端口号"><a href="#4-4-2-端口号" class="headerlink" title="4.4.2 端口号"></a>4.4.2 端口号</h3><p><strong>端口号</strong></p><ul><li>用于标示进程的逻辑地址，不同进程的标示。</li><li>一条进程一定程度上可以表示是一个应用程序，但是有区别：一个“应用程序”一定可以找到一个“进程”，但一个“进程”不一定会有一个“应用程序”与之对应，这些进程有可能是后台程序，用户看不到，感觉不到。</li></ul><p><strong>作用：</strong></p><ul><li>让应用层的各种应用进程都能将其数据通过端口向下交付给运输层。即<font color=red>连接应用层与网络层</font></li><li><font color=red>端口号存在于UDP和TCP报文的首部，而协议号则是存在这个IP数据报的首部.</font></li></ul><p><strong>有效端口：</strong></p><ul><li>0<code>~</code>65535，其中 0~1024由系统使用或者保留端口，开发中我们不要使用 1024 以下的端口，是可以省略的，不写表明使用协议默认的端口号。</li><li>浏览器网页浏览：<ul><li>http默认80</li><li>https默认443</li></ul></li><li>FTP默认20/21/990</li><li>QQ的端口号：由于QQ用的是UDP协议，默认通讯端口是4000，如果4000被占用的话，那么它就会自动改用4001端口，再被占用，以此类推。</li><li>在mac的活动监视器里可以看到一条条的进程对应的端口号</li></ul><h2 id="4-5-IP协议-协议号"><a href="#4-5-IP协议-协议号" class="headerlink" title="4.5 IP协议 - 协议号"></a>4.5 IP协议 - 协议号</h2><blockquote><p>IP协议是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据到了网络层都要经过IP协议的封装，以IP数据报格式传输。它的特点如下:</p></blockquote><p><strong>不可靠（unreliable）</strong></p><ul><li>意思是它不能保证 IP数据报能成功地到达目的地。</li><li>IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， IP有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li></ul><p><strong>无连接（connectionless）</strong></p><ul><li>意思是IP并不维护任何关于后续数据报的状态信息。</li><li>每个数据报的处理是相互独立的。这也说明， IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B） ，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li></ul><p><strong>协议号</strong></p><ul><li>其他，太深入的模块，在这里不做赘述，网络层，经过IP协议封装之后，会生成一个协议号：</li><li>协议号是存在于IP数据报的首部的20字节的固定部分，占有8bit.该字段是指出此数据报所携带的是数据是使用何种协议，以便目的主机的IP层知道将数据部分上交给哪个处理过程。也就是协议字段告诉IP层应当如何交付数据。</li><li><font color=red>简单来讲，协议号连接网络层与数据链路层</font></li></ul><h2 id="4-6-TCP-IP协议与socket"><a href="#4-6-TCP-IP协议与socket" class="headerlink" title="4.6 TCP/IP协议与socket"></a>4.6 TCP/IP协议与socket</h2><h3 id="4-6-1-TCP-IP协议"><a href="#4-6-1-TCP-IP协议" class="headerlink" title="4.6.1 TCP/IP协议"></a>4.6.1 TCP/IP协议</h3><p>是个名词，并不是TCP和IP放在一起说了，中文名叫做<font color=red>传输控制协议/互联网络协议</font>，是一种网络通信协议，它规范了网络上的所有通信设备，数据<font color=red>往来格式以及传送方式(传输)。</font></p><p><font color=red>TCP/IP协议是网络的基础，是Internet的语言。</font></p><p>关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p><blockquote><p>我们在<font color=red>传输数据时，可以只使用(传输层网络层)TCP/IP协议</font>，但是那样的话，没有应用层，便无法识别数据内容。</p><p>如果想要使传输的数据有意义，则必须使用到应用层HTTP协议。<font color=red>应用层提供了封装或者显示数据的具体形式</font></p></blockquote><h3 id="4-6-2-socket-套接字层、插座"><a href="#4-6-2-socket-套接字层、插座" class="headerlink" title="4.6.2 socket(套接字层、插座)"></a>4.6.2 socket(套接字层、插座)</h3><p>实际上socket就是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(<font color=red>API，内部按照TCP/IP协议对数据封包解包，并记录生成的端口号与IP地址</font>)。Socket的出现只是使我们程序员能够更方便的使用TCP/IP协议栈而已，是对TCP/IP的抽象。</p><p>通过Socket，我们能更好地使用TCP/IP协议。</p><p>通信的两端，也就是客户端和服务器都有 Socket(IP地址和端口号两部分)，所以可以说网络通信其实就是在 Socket 间的通信。数据在两个 Socket 间通过 IO 传输 (input/output，<font color=red>一个请求可以看做一次IO传输</font>)</p><p>Socket 是纯C语言的，是跨平台的<strong>使用socket替代HTTP做网络请求</strong></p><h4 id="1-socket通讯的原理"><a href="#1-socket通讯的原理" class="headerlink" title="1. socket通讯的原理"></a>1. socket通讯的原理</h4><p><img src="/images/ComNet/socket%E5%8E%9F%E7%90%86.jpg" alt="img"></p><h4 id="2-C版本的socket通讯"><a href="#2-C版本的socket通讯" class="headerlink" title="2. C版本的socket通讯"></a>2. C版本的socket通讯</h4><img src="/images/ComNet/socket移动端代码.png" alt="img" style="zoom:90%;" /><p>网络通讯链中，将应用层省去，用Socket做网络请求，HTTP的内容：设置服务器的信息等</p><ol><li><p>创建socket</p><p>使用socket函数。返回值是int ,&gt;0就表示成功</p></li><li><p>创建服务器，并将我们创建的socket连接到服务器</p><p>使用connect函数。返回值是int：0代表连接成功，其他失败)</p></li><li><p>向服务器发送消息</p><p>使用send函数。返回值：如果成功返回发送的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>接收服务器返回的数据</p><p>使用recv函数。返回值：如果成功返回数据的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>关闭连接</p><p>clock(创建的socket)</p></li></ol><p>iOS移动端有一个封装的很好的socket套接字库：GCDAsyncSocket</p><h2 id="4-7-长连接与短连接"><a href="#4-7-长连接与短连接" class="headerlink" title="4.7 长连接与短连接"></a>4.7 长连接与短连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p><strong>短连接</strong></p><p>数据请求结束后，立即断开连接，能够及时释放服务器资源</p><p>让服务器能够为更多的用户提供服务</p><p><strong>长连接</strong></p><p>一旦连接建立之后，始终保持连接状态，后续只需发送和接收数据即可，数据响应更及时</p><p>长连接对服务器资源占用比较大</p><p>对交互响应要求快的应用，例如即时通讯，需要使用长连接</p><p><strong>心跳包</strong></p><p>是检测长连接的重要技术手段</p><p>可以由服务器发送，定时向客户端发送小数据，根据回执判断客户端是否在线</p><p>也可以由客户端发送，定时向服务器发送小数据，报告客户端当前在线</p><h1 id="五、网络编程相关概念"><a href="#五、网络编程相关概念" class="headerlink" title="五、网络编程相关概念"></a>五、网络编程相关概念</h1><h2 id="5-1-URL"><a href="#5-1-URL" class="headerlink" title="5.1 URL"></a>5.1 URL</h2><ul><li>Uniform Resoure Locator：统一<strong>资源</strong>定位器</li><li>URL地址格式排列为：scheme://host:port/path<ul><li>Internet资源类型（scheme）：指出WWW 客户程序用来操作的工具。</li><li>服务器地址（host）：指出WWW 页所在的服务器域名</li><li>端口（port）：有时（并非总是这样），对某些资源的访问来说，需给出相应的服务器提供端口号</li><li>路径（path）：指明服务器上某资源的位置</li></ul></li></ul><h2 id="5-2-IP地址、域名与DNS服务器"><a href="#5-2-IP地址、域名与DNS服务器" class="headerlink" title="5.2 IP地址、域名与DNS服务器"></a>5.2 IP地址、域名与DNS服务器</h2><h3 id="5-2-1-IP地址"><a href="#5-2-1-IP地址" class="headerlink" title="5.2.1 IP地址"></a>5.2.1 IP地址</h3><p>ip唯一标识 一台设备</p><p>端口号标识一个设备上的应用</p><p>几个特殊的IP地址</p><table><thead><tr><th>IP地址</th><th>含义</th></tr></thead><tbody><tr><td>localhost</td><td>代表本机地址。不走网卡</td></tr><tr><td>127.0.0.1</td><td>代表本地回环地址。走网卡</td></tr><tr><td>192.168.xx.xx</td><td>代表局域网的IP地址。不管是否是本机，会通过网卡发请求给路由或交换机，在请求回来到指定的电脑</td></tr><tr><td>0.0.0.0</td><td>代表任意的IP地址</td></tr><tr><td>255.255.255.255</td><td>广播地址</td></tr></tbody></table><p><strong>协议域：（数字最大就是255）</strong></p><ul><li>IPV4：有四段</li><li>IPV6：有六段</li></ul><h3 id="5-2-2-域名"><a href="#5-2-2-域名" class="headerlink" title="5.2.2 域名"></a>5.2.2 域名</h3><ul><li>是一串用点分隔的名字组成的Internet上，一台计算机或者一个计算机组的名称，用来标识位置</li><li>.com国际域名 全世界都可以访问 </li><li>.cn中国域名</li></ul><p><strong>两者之间的关系？</strong></p><p>如果是前者，那么一个域名对应一个IP，如果是后者，例如百度这种大公司，肯定是个计算机组，那么这个域名下面就有好多个服务器，也就是好多个IP，并且我们通过访问主机域名，百度返回得到的IP是随机的</p><h3 id="5-2-3-DNS服务器"><a href="#5-2-3-DNS服务器" class="headerlink" title="5.2.3 DNS服务器"></a>5.2.3 DNS服务器</h3><p>注意：我们不是通过域名找到服务器的，而是通过IP地址找到的，</p><p>我们访问域名— <font color=red>DNS域名解析服务器帮我们把域名转换成IP地址</font>—DNS返回给我们的电脑— 电脑通过IP地址找到服务器</p><p>(我们一连接上网络，在网络信息中就可以看到我们的DNS服务器)</p><p>举例：如果我们的电脑网络能上QQ等软件，但是浏览器不能上，很有可能就是DNS服务器出问题了，这个时候：要么直接输入我们要访问的网站的IP地址，要么换一个DNS服务器，谷歌提供了一个8.8.8.8，我们可以使用。</p><h2 id="5-3-端口号"><a href="#5-3-端口号" class="headerlink" title="5.3 端口号"></a>5.3 端口号</h2><h3 id="5-3-1-端口的分类"><a href="#5-3-1-端口的分类" class="headerlink" title="5.3.1 端口的分类"></a>5.3.1 端口的分类</h3><ul><li>端口范围：0-65535之间。端口的意义：用来区分不同的进程。</li><li>端口分为以下三类：<ul><li>公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯 明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯,ftp21,smtp25,….。</li><li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于 这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li></ul></li><li>动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端 口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li></ul><h3 id="5-3-2-使用"><a href="#5-3-2-使用" class="headerlink" title="5.3.2 使用"></a>5.3.2 使用</h3><p>IP能够定位机器，端口号可以定位一个应用程序</p><ul><li>node 默认是3000 多了往上加</li><li>Apache服务器，访问资源<ul><li>部署：丢到服务器软件配置的根目录下</li><li>访问：ip+刚开始配的服务器根目录下的要访问的文件的路径</li></ul></li><li>node服务器，访问资源<ul><li>部署：不需要配置根目录，只需要一个js文件。<ul><li>这个js文件中必须配置了端口号，集成了http核心模块的功能。 </li><li>如果做了下面这些操作，node+文件名，命令行中会一直卡在这里，进程一直在开启着，别人可以访问<br>如果只是一个普通的js文件，node+文件名，一下子就执行完了。做不到一直开启的状态。</li></ul></li><li>访问：ip+端口号+此项目中文件名<ul><li>浏览器中访问，肯定是上面要齐全</li><li>如果是html中写url的时候，如果是访问的本项目中的文件(不管是后台文件 还是前端文件)，可以直接写相对路径，比如url: ‘./app.js’</li><li>端口号：默认3000，如果你开了好几个node项目，那就需要注意，端口号要一致。</li><li>文件名：如果不写，默认是会主动运行这个项目中的index.html文件，一般服务器都会做这个设置，到了nodejs中，因为所有请求都是这个js文件接收的，所以一般都会写这么个代码。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pathname == <span class="string">&#x27;/&#x27;</span> &amp;&amp; req.method == <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, <span class="string">&#x27;index.html&#x27;</span>), <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>注意：</p><ul><li>我们所有对这个端口的访问，都是这个js文件，接收，并处理的。与其他的服务器不一样。<ul><li>比如：Apache，就是我配置了根目录，你想访问什么文件，拿到那个文件的路径就可以，到时候，你的访问是这个文件进行处理。具体代码见笔记中两个js文件</li><li>但nodejs不一样，比如：你要通过这个端口号访问 :3000/public/index.html。这个时候，是js文件接收到这个请求，然后将public/index.html文件的内容readFild读出来，然后返给前端。</li></ul></li><li>一个js文件一个端口号，我们可以同时node + 文件名，同时开启好几个node项目，但是注意端口号要区分开</li></ul><h2 id="5-4-浏览器中跨域的场景"><a href="#5-4-浏览器中跨域的场景" class="headerlink" title="5.4 浏览器中跨域的场景"></a>5.4 浏览器中跨域的场景</h2><ul><li><p>域名不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.com</span><br><span class="line">www.liuxi.com 即为不同的域名</span><br></pre></td></tr></table></figure></li><li><p>二级域名相同，子域名不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.wu.com </span><br><span class="line">www.liuxi.wu.com 为子域不同</span><br></pre></td></tr></table></figure></li><li><p>端口不同，协议不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.wuyou.com </span><br><span class="line">https:&#x2F;&#x2F;www.wuyou.com</span><br><span class="line">www.wuyou.con:8888</span><br><span class="line">www.wuyou.con:8080</span><br></pre></td></tr></table></figure></li></ul><p>前端需要用到跨域的地方：</p><ul><li>加载图片，文件资源。很少会跨域，你用别人的网站图片是另一码事……</li><li>ajax请求。</li></ul><ol><li><p><code>使用ctn节点，进行动静资源分离</code>时，也就是说，我们的前端文件，与需要的后端文件，就没在一个项目里</p></li><li><p>我们后段需要请求别的端口号，或者说是别的服务器项目中的后台文件，这个时候，按理说不应该是前端的任务，正儿八经的，应该是前端文件所在项目中的后台文件，帮我们把数据请求回来，因为他们是不存在跨域的，</p></li></ol><p><font color='red'>跨域是浏览器限制的</font></p><p>但是，如果后台的人不给我们做这一步(它是个半瓶水，或者是个棒槌) 或者 说这个接口做了，用几天就不用了(比如双十一这种暂时的活动接口)，那就需要我们进行jsonp跨域请求了,</p><p>由上面可知，用到跨域的情形还是挺少的，而且我们前面讲过如何解决跨域：</p><ul><li>jsonp</li><li>自己写个php后台文件，请求数据做中转。</li><li>如果只是调试阶段有跨域，我们有浏览器插件</li></ul><h2 id="5-5-前后端分离"><a href="#5-5-前后端分离" class="headerlink" title="5.5 前后端分离"></a>5.5 前后端分离</h2><p>顾名思义，前后端分离就是把一个应用的前端代码和后端代码分开来写，为什么要这样做呢？先说说不分开会有什么问题，在传统的 Java Web 开发模式中，前端页面使用 JSP，而 JSP 代码的开发往往不是完全由后端程序猿来完成的。</p><p>JSP 页面的开发步骤是首先需要前端程序猿完成 HTML 代码，然后交给后端程序猿转为 JSP 再进行开发，后端如果遇到页面问题，就需要找前端来解决，但是此时前端看到的代码已经不是他之前写的 HTML 了，是混合了一大堆标签的 JSP 代码，而前端又不懂 JSP，场面就非常尴尬。</p><h2 id="5-6-网站的优化"><a href="#5-6-网站的优化" class="headerlink" title="5.6 网站的优化"></a>5.6 网站的优化</h2><ul><li>网页中如果有图片、css、js等外部文件的话，图片、css、js都在单独的请求中，也就是并不是页面的所有内容都在一个请求中完成，而是每个资源都有一个请求</li></ul><p>思想</p><ul><li>能压缩的压缩能合并的合并：少一个script也好，少一次请求  </li><li>少用js去遍历对象或者写for循环</li><li>能提前运算好的提前运算好，使用枚举法 <code>var a=1024*1024;</code>这么写一点都不好</li><li>流式(响应式)图片 — 图片压缩</li></ul><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td></tr><tr><td>请求带宽</td><td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td></tr><tr><td>缓存利用</td><td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免CSS表达式，避免重定向</td></tr></tbody></table><p>雅虎14条优化原则</p><ul><li>减少HTTP请求数<ul><li>合并脚本和样式表：分开时分开。就很多网站因为首页的访问量太大，将首页的css和js直接写在页面文件中而不是外部引用。</li><li>CSS Sprites：页面上的背景图片合并为一张，通过css的background-position属性定义不同的值来取背景。<a href="https://links.jianshu.com/go?to=http://www.csssprites.com/">http://www.csssprites.com/</a>可帮助将上传的图片合并并给出对应的background-position坐标。</li></ul></li><li>使用CDN（Content Delivery Network）：从最近的CDN节点请求数据</li><li>添加Expire头，或者Cache-control。通过缓存减少请求数</li><li>Gzip组件。<ul><li>通过压缩减少文件传输的大小。</li><li>所有的文件内容都应该被压缩。</li></ul></li><li>将CSS样式放在页面的上方。一次渲染</li><li>将script放在页面最下面<ul><li>防止脚本阻塞页面的下载，减少页面可视元素的加载时间。（防止页面加载中途去下载脚本）</li><li>防止脚本阻塞并行下载数量</li></ul></li><li>避免在CSS中使用Expressions</li><li>把javascript和css都放到外部文件中<ul><li>把css和js写在页面内容可减少两次请求，但也增大了页面的大小。使用外部文件，如果做了缓存，也不会有两次多余的http请求。</li><li>要视情况而定，参见第一点。</li></ul></li><li>减少DNS查询。减少DNS解析过程、加快页面加载速度。建议一个页面所包含的域名数量尽量控制在2-4个。</li><li>压缩JavaScript和CSS。<ul><li>通过压缩，减少页面字节数，从而提高加载速度，同时还可以起到一定的保护作用。</li><li>但是会丧失可读性，阿里巴巴是在发布的时候在服务器端进行压缩。</li></ul></li><li>避免重定向。增加一次冲重定向就会增加一次web请求。</li><li>移除重复的脚本</li><li>配置实体标签（ETags）</li><li>使AJAX缓存</li></ul><h2 id="5-7-在地址栏输入网址后页面是如何呈现的？"><a href="#5-7-在地址栏输入网址后页面是如何呈现的？" class="headerlink" title="5.7 在地址栏输入网址后页面是如何呈现的？"></a>5.7 在地址栏输入网址后页面是如何呈现的？</h2><ul><li>DNS 把域名转化成ip<ul><li>DNS服务器来做这个事情</li><li>运营商提供的dns服务器</li></ul></li><li>CDN 内容分发网络</li></ul><p>输入 URL：<a href="http://www.baidu.com/">http://www.baidu.com</a></p><ul><li>DNS 域名解析<ul><li>计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置</li><li>在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口）</li><li>158.12.25.652  域名就是为了好记</li><li>为了好记，所以我们的 万维网提供了 一个 域名这样的概念</li><li>当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器</li></ul></li><li>将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器<ul><li>浏览器将用户输入的 URL 地址根据HTTP协议 封装成了  http 请求报文（请求头+请求行+请求体）</li><li>该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器</li></ul></li><li>后台服务器接收到用户HTTP Request 请求报文<ul><li>后台服务器接收到 客户端发送给自己的数据（二进制数据）<ul><li>首先把二进制数据按照编码解析成字符（人类可以识别的）</li><li>解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来</li></ul></li></ul></li><li>后台服务器处理用户请求信息<ul><li>当得到用户请求报文之后，根据请求报文中的 get、post取出URL中的查询字符串 或者 请求体中的数据</li><li>根据用户的特定的请求数据做特定的处理</li></ul></li><li>后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端<ul><li>当我们解析和处理完用户请求报文消息之后</li><li>服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文</li><li>响应头、响应字段、响应体</li><li>该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端</li><li>发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单</li></ul></li><li>用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码<ul><li>当客户端解析到 服务器发送过来的 二进制数据</li><li>客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串</li><li>然后根据 HTTP 协议，解析服务器发送过来的 响应报文</li><li>然后根据响应报文中的报文内容（报文头、报文体）做具体的解析</li></ul></li><li>当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程：是指&lt;strong&gt;编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。&lt;/p&gt;
&lt;p&gt;我们处于互联网时代，我们可以随时随地通过 Interne</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
