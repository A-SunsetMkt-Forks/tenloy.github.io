<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2022-06-21T10:15:46.557Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS SQLite的使用与优化</title>
    <link href="https://tenloy.github.io/2022/05/05/sqlite.html"/>
    <id>https://tenloy.github.io/2022/05/05/sqlite.html</id>
    <published>2022-05-05T11:12:33.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-数据库方案"><a href="#iOS-数据库方案" class="headerlink" title="iOS 数据库方案"></a>iOS 数据库方案</h1><p>目前移动端数据库方案按其实现可分为两类，</p><ul><li><p><strong>关系型数据库</strong>，代表有CoreData、FMDB等。</p><ul><li><strong>CoreData</strong>：它是苹果内建框架，和Xcode深度结合，可以很方便进行ORM；但其上手学习成本较高，不容易掌握。稳定性也堪忧，很容易crash；多线程的支持也比较鸡肋。</li><li><strong>FMDB</strong>：它基于SQLite封装，对于有SQLite和ObjC基础的开发者来说，简单易懂，可以直接上手；而缺点也正是在此，FMDB只是将SQLite的C接口封装成了ObjC接口，没有做太多别的优化，即所谓的胶水代码(Glue Code)。使用过程需要用大量的代码拼接SQL、拼装Object，并不方便。</li></ul></li><li><p><strong>key-value数据库</strong>，代表有Realm、LevelDB、RocksDB等。</p><ul><li><strong>Realm</strong>：因其在各平台封装、优化的优势，比较受移动开发者的欢迎。对于iOS开发者，key-value的实现直接易懂，可以像使用NSDictionary一样使用Realm。并且ORM彻底，省去了拼装Object的过程。但其对代码侵入性很强，Realm要求类继承RLMObject的基类。这对于单继承的ObjC，意味着不能再继承其他自定义的子类。同时，key-value数据库对较为复杂的查询场景也比较无力。</li></ul></li></ul><p>可见，各个方案都有其独特的优势及劣势，没有最好的，只有最适合的。</p><h1 id="一、SQLite概述及其优点、不足"><a href="#一、SQLite概述及其优点、不足" class="headerlink" title="一、SQLite概述及其优点、不足"></a>一、SQLite概述及其优点、不足</h1><blockquote><p><a href="https://www.sqlite.org/">SQLite官方文档</a></p></blockquote><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p><p>就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。</p><h2 id="1-1-为什么要用-SQLite？"><a href="#1-1-为什么要用-SQLite？" class="headerlink" title="1.1 为什么要用 SQLite？"></a>1.1 为什么要用 SQLite？</h2><ul><li>不需要一个单独的服务器进程或操作的系统（无服务器的）。</li><li>SQLite 不需要配置，这意味着不需要安装或管理。</li><li>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</li><li>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</li><li>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</li><li>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</li><li>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</li><li>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</li><li>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</li></ul><h2 id="1-2-SQLite-局限性"><a href="#1-2-SQLite-局限性" class="headerlink" title="1.2 SQLite 局限性"></a>1.2 SQLite 局限性</h2><p>在 SQLite 中，SQL92 不支持的特性如下所示：</p><table><thead><tr><th align="left">特性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">查询 — 外连接</td><td align="left">只实现了 LEFT OUTER JOIN。不支持RIGHT OUTER JOIN、FULL OUTER JOIN</td></tr><tr><td align="left">修改 — ALTER TABLE</td><td align="left">支持修改表名称、添加字段命令，但不支持删除字段、修改字段的属性(名称、类型、宽度等) 。</td></tr><tr><td align="left">Trigger 支持</td><td align="left">支持 FOR EACH ROW 触发器，但不支持 FOR EACH STATEMENT 触发器。</td></tr><tr><td align="left">VIEWs</td><td align="left">在 SQLite 中，视图是只读的。您不可以在视图上执行 DELETE、INSERT 或 UPDATE 语句。</td></tr><tr><td align="left">GRANT 和 REVOKE</td><td align="left">可以应用的唯一的访问权限是底层操作系统的正常文件访问权限。</td></tr></tbody></table><h1 id="二、SQLite中的”连接“与”句柄“"><a href="#二、SQLite中的”连接“与”句柄“" class="headerlink" title="二、SQLite中的”连接“与”句柄“"></a>二、SQLite中的”连接“与”句柄“</h1><h2 id="2-1-MySQL的”连接“"><a href="#2-1-MySQL的”连接“" class="headerlink" title="2.1 MySQL的”连接“"></a>2.1 MySQL的”连接“</h2><p>数据库连接(database connection)是数据库服务器与客户端之间的通信联系（数据库也是个服务器，也需要远程连接操作）。客户通过数据库连接发送命令、接收服务器返回的结果。</p><ul><li><p>通过可执行文件，连接服务器</p><p>以下是从命令行中，使用MySQL二进制方式，连接MySQL数据库，进入到mysql命令提示符下来操作数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本实例中，使用root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</span></span><br><span class="line"><span class="comment"># 如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</span></span><br><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令执行后，登录成功输出结果如下:</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2854760 to server version: 5.0.9</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the buffer.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：</span></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></li><li><p>通过代码连接，比如Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="comment">//static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;  </span></span><br><span class="line">    <span class="comment">//static final String DB_URL = &quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">        Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开链接：连接数据库....</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行查询：实例化Statement对象...</span></span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>;</span><br><span class="line">        ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 展开结果集数据库</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="comment">// 通过字段检索</span></span><br><span class="line">            <span class="keyword">int</span> id  = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String url = rs.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成后关闭</span></span><br><span class="line">        rs.close();</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>IBM DB2, Microsoft SQL Server, Oracle, MySQL, PostgreSQL, 与Neo4j使用连接池技术来改善性能。</p><p>建造连接时，通常要提供一个驱动程序或provider与一个连接字符串。例如，<code>Server=sql_box;Database=Common;User ID=uid;Pwd=password;</code></p><p>一旦连接建立，它可以被打开、关闭、设置性质。</p><h2 id="2-2-操作系统中句柄与文件"><a href="#2-2-操作系统中句柄与文件" class="headerlink" title="2.2 操作系统中句柄与文件"></a>2.2 操作系统中句柄与文件</h2><h3 id="2-2-1-操作系统中的”句柄“"><a href="#2-2-1-操作系统中的”句柄“" class="headerlink" title="2.2.1 操作系统中的”句柄“"></a>2.2.1 操作系统中的”句柄“</h3><blockquote><p>在程序设计中，句柄（handle）是Windows操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，可以使用句柄。</p><p>句柄与普通指针的区别在于：</p><ul><li>指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。</li><li>通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制。</li></ul><p>句柄与安全性：客户获得句柄时，句柄不仅是资源的标识符，也被授予了对资源的特定访问权限。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 打开文件，返回文件指针(FILE是个结构体，记录了打开文件的一些信息)</span></span><br><span class="line"><span class="comment">// 操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指向文件 信息的指针，称为文件指针。文件指针也可以理解为代指打开的文件。</span></span><br><span class="line"><span class="comment">// 指针的类型为 FILE 类型，FILE 是系统使用 typedef 定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。</span></span><br><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> level;        <span class="comment">// 缓冲区&quot;满&quot;或者&quot;空&quot;的程度</span></span><br><span class="line">    <span class="keyword">unsigned</span> flags;     <span class="comment">// 文件状态标志</span></span><br><span class="line">    <span class="keyword">char</span> fd;            <span class="comment">// Linux中叫做文件描述符，Windows中叫句柄</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> hold; <span class="comment">// 如无缓冲区不读取字符</span></span><br><span class="line">    <span class="keyword">short</span> bsize;        <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;<span class="comment">// 数据缓冲区的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> ar;        <span class="comment">// 指针，当前的指向</span></span><br><span class="line">    <span class="keyword">unsigned</span> istemp;    <span class="comment">// 临时文件，指示器</span></span><br><span class="line">    <span class="keyword">short</span> token;        <span class="comment">// 用于有效性的检查</span></span><br><span class="line">&#125; FILE;</span><br><span class="line"></span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">fp = fopen(<span class="string">&quot;../test&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>关于句柄，下面举一个实际的例子，在Linux中，值为0、1、2的fd分别代表标准输入、标准输出和标准错误输出。在程序中打开文件得到的fd从3开始增长。fd具体是什么呢？</p><p>在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象。而fd，就是这个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能够通过系统提供的函数来操作。</p><p>在C语言里，操纵文件的渠道则是FILE结构，不难想象，C语言中的 FILE结构必定和fd有一对一的关系，每个FILE结构都会记录自己唯一对 应的fd。</p><h3 id="2-2-2-文件打开多次-多句柄"><a href="#2-2-2-文件打开多次-多句柄" class="headerlink" title="2.2.2 文件打开多次(多句柄)"></a>2.2.2 文件打开多次(多句柄)</h3><p>一个文件可以被打开多次(同一进程/不同进程)，返回的文件指针、fd(文件描述符/句柄)、文件的读写指针(光标)都不同，都是独立的。</p><ul><li>如果是不同进程中，因为打开文件表是每个进程私有的，得到的fd也是可能一样的。</li></ul><p>被打开多次时：</p><ul><li>记得要关闭多次 </li><li>此时，文件是可以同时读写的，需要注意避免读写冲突：<ul><li>如果打开模式是r/r+/w/w+，那写入的数据因为文件读写指针是独立的，所以会发生数据覆盖写入的问题。</li><li>如果打开模式是a/a+，那写入前会自动调整文件读写指针到文件末尾，<em>此时就是多线程/多进程并发操作文件的效果</em>。</li></ul></li></ul><p>所以，如果是多进程写日志的场景中，一个日志文件打开了多次，那写数据时，最好通过进程号标记每一条日志是由哪个进程写入的，因为各进程写入文件是随机的。</p><h2 id="2-3-SQLite中的”连接“与”句柄“"><a href="#2-3-SQLite中的”连接“与”句柄“" class="headerlink" title="2.3 SQLite中的”连接“与”句柄“"></a>2.3 SQLite中的”连接“与”句柄“</h2><p>SQLite作为应用或产品的嵌入式数据库，此时不是作为一个服务(server)在工作，对SQLite的操作，更类似于文件系统中，对本地文件的操作(打开/关闭)。API也很相似：（<em>但为了跟MySQL等数据库系统看齐，有时候也称这个文件打开操作是个创建连接</em>(<em>Connection</em>)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqlite3</span> &#123;</span></span><br><span class="line">  sqlite3_vfs *pVfs;            <span class="comment">/* OS Interface */</span></span><br><span class="line">  <span class="keyword">int</span> nDb;                      <span class="comment">/* Number of backends currently in use */</span></span><br><span class="line">  Db *aDb;                      <span class="comment">/* All backends */</span></span><br><span class="line">  <span class="keyword">int</span> flags;                    <span class="comment">/* Miscellaneous flags. See below */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> openFlags;       <span class="comment">/* Flags passed to sqlite3_vfs.xOpen() */</span></span><br><span class="line">  <span class="keyword">int</span> errCode;                  <span class="comment">/* Most recent error code (SQLITE_*) */</span></span><br><span class="line">  <span class="keyword">int</span> errMask;                  <span class="comment">/* &amp; result codes with this before returning */</span></span><br><span class="line">  <span class="comment">//....省略了超级多</span></span><br><span class="line">  sqlite3 *pBlockingConnection; <span class="comment">/* Connection that caused SQLITE_LOCKED */</span></span><br><span class="line">  sqlite3 *pUnlockConnection;           <span class="comment">/* Connection to watch for unlock */</span></span><br><span class="line">  <span class="keyword">void</span> *pUnlockArg;                     <span class="comment">/* Argument to xUnlockNotify */</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*xUnlockNotify)(<span class="keyword">void</span> **, <span class="keyword">int</span>);  <span class="comment">/* Unlock notify callback */</span></span><br><span class="line">  sqlite3 *pNextBlocked;        <span class="comment">/* Next in list of all blocked connections */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open a new database Connection. (官方文档中叫连接，源码中直接称Open a new database handle.)</span></span><br><span class="line"><span class="comment"> * @param ppDb 传入一个sqlite3 *指针的地址。这个地址会在函数执行完被赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqlite3_open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *filename,   <span class="comment">/* Database filename (UTF-8) */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    sqlite3 **ppDb          <span class="comment">/* OUT: SQLite db handle.*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Closing A Database Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqlite3_close</span><span class="params">(sqlite3*)</span></span>;</span><br></pre></td></tr></table></figure><p>这个传出参数 <code>ppDb</code> 定义与C语言中的<strong>文件指针</strong>很相似，一点都不符合操作系统中对句柄的定义。<strong>不知道为什么SQLite中将其叫做句柄。不过注意点就好了，知道sqlite3中的句柄本质上是个文件指针，区别于Windows句柄就行。</strong></p><h1 id="三、SQLite-简单使用示例"><a href="#三、SQLite-简单使用示例" class="headerlink" title="三、SQLite 简单使用示例"></a>三、SQLite 简单使用示例</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQLite初体验原生实现(了解)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>&#123;</span><br><span class="line">    sqlite3 *_db;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建数据库和打开数据库,只需要一个函数 sqlite3_open</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        参数1:创建出来的数据库,保存到沙盒的哪个路径中,路径的后缀以.db或是.sqlite结尾</span></span><br><span class="line"><span class="comment">        参数2:数据库实例,后面增,删,改,查都必须用到它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *dbPath = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@&quot;my.db&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有数据库,就创建并且打开</span></span><br><span class="line">    <span class="comment">//如果有数据,直接打开</span></span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_open([dbPath UTF8String], &amp;_db);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;创建和打开数据库的连接成功!!!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建表,新增,修改,删除,都用到一个函数 sqlite3_exec</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            参数1 数据库的实例</span></span><br><span class="line"><span class="comment">            参数2 要执行的创表的Sql</span></span><br><span class="line"><span class="comment">            参数3 成功之后的要执行的函数,如果不传,写NULL</span></span><br><span class="line"><span class="comment">            参数4 执行参数3函数的参数</span></span><br><span class="line"><span class="comment">            参数5 错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSString</span> *createSQLString = <span class="string">@&quot;create table if not exists T_student(studentId integer primary key,studentName text not null,studentAge integer default 20);&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</span><br><span class="line">        sqlite3_exec(_db, createSQLString.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (errmsg==<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;创建表成功了!!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,errmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)query&#123;</span><br><span class="line">    <span class="comment">//查询数据 sqlite3_prepare_v2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        参数1:数据库实例</span></span><br><span class="line"><span class="comment">        参数2:查询sql语句</span></span><br><span class="line"><span class="comment">        参数3:一般传入-1,让系统自动去算</span></span><br><span class="line"><span class="comment">        参数4:查询出来的结果集</span></span><br><span class="line"><span class="comment">        参数5:NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *queryAllSQLString = <span class="string">@&quot;select * from T_student;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果集合</span></span><br><span class="line">    sqlite3_stmt *stmt = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要查询成功了,stmt这个里面就会有数据</span></span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_prepare_v2(_db, queryAllSQLString.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;<span class="comment">//查询成功</span></span><br><span class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;<span class="comment">//遍历到一行数据，会自动判断有没有，没有就跳过这个循环</span></span><br><span class="line">            <span class="comment">//取出该行里面,需要的字段的值</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name = sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">NSString</span> *ocName = [[<span class="built_in">NSString</span> alloc] initWithCString:name encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="keyword">int</span> age  = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@---%d&quot;</span>,ocName,age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="四、SQLite的两种日志模式"><a href="#四、SQLite的两种日志模式" class="headerlink" title="四、SQLite的两种日志模式"></a>四、SQLite的两种日志模式</h1><p>SQLite主要有两种日志模式(journal mode)：DELETE模式和WAL(Write-Ahead Log)模式，默认是DELETE模式。</p><p>DELETE模式下，日志文件记录的是数据页变更前的内容。当事务开启时，将db-page的内容写入日志，写操作直接修改db-page，读操作也是直接读取db-page，db-page存储了事务最新的所有更新，当事务提交时直接删除日志文件即可，事务回滚时将日志文件覆盖db-page文件，恢复原始数据。</p><blockquote><p>WAL：预写日志。是指在数据写入到数据库之前，先写入到日志。再将日志记录变更到存储器中。</p></blockquote><p>WAL模式下，日志文件记录的是数据变更后的内容。当事务开启时，写操作不直接修改db-page，而是以append的方式追加到日志文件末尾，当事务提交时不会影响db-page，直接将日志文件覆盖到db-page即可，事务回滚时直接将日志文件去掉即可。读操作也是读取日志文件，开始读数据时会先扫描日志文件，看需要读的数据是否在日志文件中，如果在直接读取，否则从对应的db-page读取，并引入.shm文件，建立日志索引，采用哈希索引来加快日志扫描。</p><p>两种模式对读写并发的影响：</p><ul><li>DELETE模式下因为读写操作都是直接在db-page上面进行，因此读写操作必须串行执行。</li><li>WAL模式下，读写操作都是在日志文件上进行，写操作会先append到日志文件末尾，而不是直接覆盖旧数据。而读操作开始时，会记下当前的日志文件状态，并且只访问在此之前的数据。这就确保了多线程<strong>读与读</strong>、<strong>读与写</strong>之间可以并发地进行。</li><li>更多关于WAL模式的内容可以阅读<a href="https://www.sqlite.org/">SQLite官方文档</a>。</li></ul><p>iOS中，如果使用了WAL模式，那么打开app沙盒里面的会有三种类型的文件：sqlite、sqlite-shm、sqlite-wal。</p><ul><li>sqlite-shm是共享内存(Shared Memory)文件，该文件里面会包含一份sqlite-wal文件的索引，系统会自动生成shm文件，所以删除它，下次运行还会生成。</li><li>sqlite-wal是预写式日志(Write-Ahead Log)文件，这个文件里面会包含尚未提交的数据库事务，所以看见有这个文件了，就代表数据库里面还有还没有处理完的事务需要提交，所以说如果有sqlite-wal文件，再去打开sqlite文件，很可能最近一次数据库操作还没有执行。</li></ul><p>在调试的时候，如果需要即时的观察数据库的变化，我们就可以先将日志模式设置为DELETE。</p><h1 id="五、数据库的升级"><a href="#五、数据库的升级" class="headerlink" title="五、数据库的升级"></a>五、数据库的升级</h1><h2 id="5-1-数据库升级是指什么？"><a href="#5-1-数据库升级是指什么？" class="headerlink" title="5.1 数据库升级是指什么？"></a>5.1 数据库升级是指什么？</h2><blockquote><p>先弄清楚数据库、数据库系统的区别。</p></blockquote><ul><li>表(Table)：以按行按列形式组织及展现的数据。一张表由表名、表中的字段和表的记录三个部分组成的。</li><li>数据库(Database)：相互之间有关联关系的Table的集合。<ul><li>数据库是电子化信息的集合。将信息规范化并使之电子化，形成电子信息 ‘库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul></li><li>数据库管理系统(Database Management System，DBMS)：能实现数据库的定义、操纵(增删改查)、控制(权限等)、维护(转储/恢复/重组/性能监测/分析)。<ul><li>其实可以就是个SDK，一般提供命令行工具、编程API两种使用方式。</li><li>常见的有：MySQL、SQL Server、DB2、Oracle Database等。</li></ul></li></ul><p><strong>一般移动端开发中的所说的数据库升级，无非就是对库、表的增删，对表结构(<em>设计数据表结构就是定义数据表文件名，确定数据表包含哪些字段，各字段的字段名、字段类型、及宽度</em>)的修改</strong>。</p><p>移动端中的数据库升级，需要考虑不同存量APP版本，升级时的不同处理：比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1: 表A 表B</span></span><br><span class="line"><span class="comment">// V2: 表A 表B 表C</span></span><br><span class="line"><span class="comment">// V3: 表A 表B 表C(Modify, 对表C进行修改)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么</span></span><br><span class="line"><span class="comment">//   1. 在开发V3时，就要考虑对V1、V2的不同处理：V1直接创建最新的表C、V2需要进行表的修改。</span></span><br><span class="line"><span class="comment">//   2. 需要保证已存储的数据不丢失。</span></span><br></pre></td></tr></table></figure><p>服务端开发中，因为数据库升级，不需要考虑上面的存量用户使用问题，所以很简单，不值一提。所以<strong>一般服务端开发人员所说的数据库升级是指数据库管理系统升级，比如MySQL版本升级。</strong></p><h2 id="5-2-表结构修改的几种处理方式"><a href="#5-2-表结构修改的几种处理方式" class="headerlink" title="5.2 表结构修改的几种处理方式"></a>5.2 表结构修改的几种处理方式</h2><p>数据库升级中库、表的增删不提，关于表结构修改的几种处理方式：</p><ul><li><p>直接删除旧表，丢弃已存储数据，再新建新表（<strong>除非评估后，数据可留可删。否则不推荐</strong>）</p></li><li><p><strong>如果SQLite支持要进行的操作</strong>：在已有表的基础上对表结构进行修改。（SQLite的ALTER TABLE命令非常局限，只支持重命名表以及添加新的字段。）</p><ul><li>优点：能够保留数据</li><li>缺点：规则比较繁琐，要建立一个数据库的字段配置文件，然后读取配置文件，执行SQL修改表结构、约束和主键等等，涉及到跨多个版本的数据库升级就变得繁琐并且麻烦了</li></ul></li><li><p><strong>如果SQLite不支持要进行的操作，比如：列的删除操作、字段名、长度、类型等属性的修改</strong>，那此时老表就不能用了，需要进行数据迁移操作。</p><ul><li>数据迁移：将旧表改名为临时表，然后创建新表 — 导入数据 — 删除临时表。(<em>或者先创建临时表，把数据导入到临时表，然后删除旧表，把临时表更名为旧表的名称，也行</em>)</li><li>优点：能够保留数据，支持表结构的修改，约束、主键的变更，实现起来比较简单</li><li>缺点：实现的步骤比较多</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [new_table](id <span class="type">integer</span> <span class="keyword">primary</span> key, name text)</span><br><span class="line"># 导入数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [new_table] <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> [old_table]</span><br><span class="line"># 删除旧表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> [old_table]</span><br><span class="line"># 重命名临时表</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [new_table] rename <span class="keyword">to</span> [old_table]</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-3-数据库升级常见的几种方式"><a href="#5-3-数据库升级常见的几种方式" class="headerlink" title="5.3 数据库升级常见的几种方式"></a>5.3 数据库升级常见的几种方式</h2><p>假如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1: 表A 表B</span></span><br><span class="line"><span class="comment">// V2: 表A 表B 表C</span></span><br><span class="line"><span class="comment">// V3: 表A 表B 表C2(Modify, 对表C进行了修改，称C修改后为C2)</span></span><br><span class="line"><span class="comment">// V4: 表A 表B2(M) 表C2</span></span><br><span class="line"><span class="comment">// V5: 表A2(M) 表B2 表C2 (即将发布的新版本)</span></span><br></pre></td></tr></table></figure><h3 id="5-3-1-最原始的SQLite"><a href="#5-3-1-最原始的SQLite" class="headerlink" title="5.3.1 最原始的SQLite"></a>5.3.1 最原始的SQLite</h3><p>在Android中，SQLiteOpenHelper 类中有一个方法<code>onUpgrade</code>，当我们创建对象的时候如果传入的版本号大于之前的版本号，该方法就会被调用，通过判断oldVersion 和 newVersion 就可以决定如何升级数据库。（iOS同理，只不过需要自己维护版本号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2、创建C2    &#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2、修改C-&gt;C2 &#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2&#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2&#125; </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>要记录每个数据库版本的库、表结构</li><li>每次数据库有了新版本，都需要重写所有存量版本的 if 分支的升级处理。</li></ol><h3 id="5-3-2-只需记录每次迭代改动"><a href="#5-3-2-只需记录每次迭代改动" class="headerlink" title="5.3.2 只需记录每次迭代改动"></a>5.3.2 只需记录每次迭代改动</h3><p>谷歌在 2018 I/O 大会上发布了一系列辅助android开发者的实用工具，这套工具就是Jetpack，它是一套库、工具和指南的合集，可以帮助开发者更轻松地编写和构建出色的 Android 应用程序。</p><p>其中，ROOM就是 JetPack组件中的数据库框架。使用ROOM时，数据库升级时，只需要写出相比上次的更新就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_4_5 = <span class="keyword">new</span> Migration(<span class="number">4</span>,<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;migrate:&quot;</span>+database.getVersion());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `hermes_static_resource` (`url` TEXT NOT NULL, `file_name` TEXT NOT NULL, `file_path` TEXT NOT NULL, `download_status` INTEGER NOT NULL, `update_time` INTEGER NOT NULL, `create_time` INTEGER NOT NULL, PRIMARY KEY(`url`))&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `hermes_cert` (`domain_name` TEXT NOT NULL, `data` TEXT NOT NULL, `version` INTEGER NOT NULL, PRIMARY KEY(`domain_name`))&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS web_resource_data&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS CertificateBean&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS PushMessage&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_5_6 = <span class="keyword">new</span> Migration(<span class="number">5</span>,<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;migrate:&quot;</span>+database.getVersion());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `orion_host` (`old_host` TEXT NOT NULL, `new_host` TEXT NOT NULL, `data` TEXT, `version` INTEGER NOT NULL, PRIMARY KEY(`old_host`))&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iOS方面也有相同的库：FMDB README_MD中推荐了FMDBMigrationManager开源库，来做数据库升级。</p><p>根据官方文档的解释，有两种方法实现升级：</p><p>第一种：每次升级对应一个文件。所谓升级文件，就是一些sql文件，在里面写入一些对数据库操作的语句。</p><ul><li>文件名的格式是固定的 <code>(数字)_(描述性语言).sql</code>。前面的数字就是所谓的版本号，官方建议使用时间戳，也可以使用1，2，3，4，5……升级，保持单调递增即可。</li><li>文件内写入要对数据库做的操作sql语句，比如<code>create table user(name TEXT, ....)</code>。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DBPath是要升级的数据库的地址 </span></span><br><span class="line"><span class="comment">// [NSBundle mainBundle]是保存数据库升级sql文件的位置 根据自己放文件的位置定。</span></span><br><span class="line">   <span class="comment">// FMDBMigrationManager 将会根据创建时给入的NSBundle自行寻找sql文件，对比版本号进行操作。</span></span><br><span class="line">FMDBMigrationManager * manager=[FMDBMigrationManager managerWithDatabaseAtPath:DBPath migrationsBundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> resultState=<span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSError</span> * error=<span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (!manager.hasMigrationsTable) &#123;</span><br><span class="line">    <span class="comment">// 执行完该语句，会发现我们的数据库中多了一个表 schema_migrations。为版本号表，记录数据库的版本号。</span></span><br><span class="line">    resultState=[manager createMigrationsTable:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据库升级到指定版本。UINT64_MAX 表示升级到最高版本</span></span><br><span class="line">resultState=[manager migrateDatabaseToVersion:<span class="built_in">UINT64_MAX</span> progress:<span class="literal">nil</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p>第二种：使用自定义类的形式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FMDBMigrationManager.h&quot;</span></span></span><br><span class="line"><span class="comment">// 首先定义一个新的类：Migration</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Migration</span> : <span class="title">NSObject</span>&lt;<span class="title">FMDBMigrating</span>&gt; // 遵循<span class="title">FMDBMigrating</span>协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于name和version都是只读的，因此我们要自定义一个init方法，传入描述 版本号和升级语句，升级语句最好用数组的方式传入，因为可能有多个升级语句。</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andVersion:(uint64_t)version andExecuteUpdateArray:(<span class="built_in">NSArray</span> *)updateArray;<span class="comment">//自定义方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与第一种拖入文件的方式相同，name是升级描述，version是版本号，最后一个方法里面，进行操作。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) uint64_t version;</span><br><span class="line">- (<span class="built_in">BOOL</span>)migrateDatabase:(FMDatabase *)database error:(<span class="keyword">out</span> <span class="built_in">NSError</span> *__autoreleasing *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  Migration.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Migration.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Migration</span>()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> * myName;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)uint64_t myVersion;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSArray</span> * updateArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Migration</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andVersion:(uint64_t)version andExecuteUpdateArray:(<span class="built_in">NSArray</span> *)updateArray&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _myName=name;</span><br><span class="line">        _myVersion=version;</span><br><span class="line">        _updateArray=updateArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name  &#123; <span class="keyword">return</span> _myName; &#125;</span><br><span class="line">- (uint64_t)version &#123; <span class="keyword">return</span> _myVersion; &#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)migrateDatabase:(FMDatabase *)database error:(<span class="keyword">out</span> <span class="built_in">NSError</span> *__autoreleasing *)error&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSString</span> * updateStr <span class="keyword">in</span> _updateArray)&#123;</span><br><span class="line">        [database executeUpdate:updateStr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用方法也很简单，将自定义类对象添加进manager即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FMDBMigrationManager * manager=[FMDBMigrationManager managerWithDatabaseAtPath:DBPath migrationsBundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line"></span><br><span class="line">Migration * migration_1=[[Migration alloc]initWithName:<span class="string">@&quot;新增USer表&quot;</span> andVersion:<span class="number">1</span> andExecuteUpdateArray:@[<span class="string">@&quot;create table User(name text,age integer)&quot;</span>]];</span><br><span class="line">Migration * migration_2=[[Migration alloc]initWithName:<span class="string">@&quot;USer表新增字段email&quot;</span> andVersion:<span class="number">2</span> andExecuteUpdateArray:@[<span class="string">@&quot;alter table User add email text&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 以后还想升级，在加入一个新的自定义对象，注意！！！版本号要保持递增</span></span><br><span class="line"></span><br><span class="line">[manager addMigration:migration_1];</span><br><span class="line">[manager addMigration:migration_2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> resultState=<span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSError</span> * error=<span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (!manager.hasMigrationsTable) &#123;</span><br><span class="line">    resultState=[manager createMigrationsTable:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultState=[manager migrateDatabaseToVersion:<span class="built_in">UINT64_MAX</span> progress:<span class="literal">nil</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p><strong>看了一下实现代码，很简单，是根据版本号，循环将之前的数据库升级sql执行了一遍</strong>(<strong>简单粗暴</strong>)。而不是直接根据现有版本号与最新版本号，得出两者之间的差异，只做差异更新。</p><ul><li><em>不知道google出版的roomdb是怎么做的。</em></li><li>不过，因为我们每次都是指定的升级sql，而不是当次升级至的数据库状态。通过每次的sql语句，比较指定两次的差异，也不是很好做吧？下面这种提供了ORM形式的数据库升级，应该可以做到直接比较(<em>想到了git工作原理中，就是每次有</em>)。</li></ul><h3 id="5-3-3-与ORM相结合的升级"><a href="#5-3-3-与ORM相结合的升级" class="headerlink" title="5.3.3 与ORM相结合的升级"></a>5.3.3 与ORM相结合的升级</h3><p>比如CoreData、WCDB等，以后者为例。</p><p>WCDB 将数据库升级和 ORM 结合起来，对于需要增删改的字段，只需直接在 ORM 层面修改，并再次调用 createTableAndIndexesOfName:withClass: 接口即可自动升级。以下是一个数据库升级的例子。</p><ul><li><strong>删除字段</strong>：如例子中的 createTime 字段，删除字段只需直接将 ORM 中的定义删除即可。</li><li><strong>增加字段</strong>：如例子中的 aNewProperty 字段，增加字段只需直接添加 ORM 的定义即可。</li><li><strong>修改字段类型</strong>：如例子中的 content 字段，字段类型可以直接修改，但需要确保新类型与旧类型兼容。</li><li><strong>修改字段名称</strong>：如例子中的 aNewModifiedTime ，字段名称可以通过 WCDB_SYNTHESIZE_COLUMN(className, propertyName, columnName) 重新映射。</li><li><strong>增加约束</strong>：如例子中的 WCDB_UNIQUE(Message, aNewModifiedTime) ，新的约束只需直接在 ORM 中添加即可。</li><li><strong>增加索引</strong>：如例子中的 WCDB_INDEX(Message, “_newIndex”, aNewProperty) ，新的索引只需直接在 ORM 添加。</li></ul><img src="/images/sqlite/21.jpg" alt="wcdb-up" style="zoom:90%;" /><p>其他：有个ObjectBox，也支持ORM，跨平台 Android/iOS/Mac/Windows/Go。(Android同事用过)，号称世界最快嵌入式数据库；体积小(最小压缩到增加体积1MB) ；函数设计简单优雅；支持DSL；支持监听数据库；浏览器查看数据库，仅查看；根据配置生成的JSON文件自动迁移；不支持嵌套对象。</p><h1 id="六、SQLite的优化点"><a href="#六、SQLite的优化点" class="headerlink" title="六、SQLite的优化点"></a>六、SQLite的优化点</h1><blockquote><p>原文 — <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a></p></blockquote><p>随着微信iOS客户端业务的增长，在数据库上遇到的性能瓶颈也逐渐凸显。在<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=21#wechat_redirect">微信的卡顿监控系统</a>上，数据库相关的卡顿不断上升。而在用户侧也逐渐能感知到这种卡顿，尤其是有大量群聊、联系人和消息收发的重度用户。</p><p>我们在对SQLite进行优化的过程中发现，靠单纯地修改SQLite的参数配置，已经不能彻底解决问题。因此从6.3.16版本开始，我们合入了SQLite的源码，并开始进行源码层的优化。</p><p>本文将分享在SQLite源码上进行的多线程并发、I/O性能优化等，并介绍优化相关的SQLite原理。</p><h2 id="6-1-多线程并发优化"><a href="#6-1-多线程并发优化" class="headerlink" title="6.1 多线程并发优化"></a>6.1 多线程并发优化</h2><h3 id="6-1-1-背景"><a href="#6-1-1-背景" class="headerlink" title="6.1.1 背景"></a>6.1.1 背景</h3><p>由于历史原因，旧版本的微信一直使用单句柄的方案，即所有线程共有一个SQLite Handle，并用线程锁避免多线程问题。当多线程并发时，各线程的数据库操作同步顺序进行，这就导致后来的线程会被阻塞较长的时间。</p><h3 id="6-1-2-SQLite的多句柄方案及Busy-Retry方案"><a href="#6-1-2-SQLite的多句柄方案及Busy-Retry方案" class="headerlink" title="6.1.2 SQLite的多句柄方案及Busy Retry方案"></a>6.1.2 SQLite的多句柄方案及Busy Retry方案</h3><p>SQLite 支持三种线程模式：(<em><a href="https://www.sqlite.org/threadsafe.html">官方文档 — Using SQLite In Multi-Threaded Applications</a></em>)</p><ul><li>单线程（Single-thread） ，在此模式下，所有互斥锁都被禁用，并且SQLite连接不能在多个线程中使用。</li><li>多线程（Multi-thread），在此模式下，SQLite可以安全地由多个线程使用，前提是在两个或多个线程中不同时使用单个数据库连接。</li><li>串行（Serialized），在此模式下，SQLite可以被多个线程安全地使用而没有任何限制。（<strong>默认</strong>）</li></ul><p>线程模式可以在以下三种时间设置：</p><ul><li>编译时（从源代码编译 SQLite 库时）</li><li>启动时（当打算使用 SQLite 的应用程序正在初始化时）</li><li>运行时（当在应用程序中，创建新的 SQLite 数据库连接时）。</li><li>一般来说，运行时会覆盖启动时，启动时会覆盖编译时。注意：单线程模式一旦选择就不能被覆盖。</li></ul><p>所以，SQLite实际是支持多线程（几乎）无锁地并发操作。只需</p><ol><li>开启配置 <code>PRAGMA SQLITE_THREADSAFE=2</code></li><li>确保同一个句柄同一时间只有一个线程在操作</li></ol><blockquote><p>Multi-thread. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</p></blockquote><p>倘若再开启SQLite的WAL模式（Write-Ahead-Log），多线程的并发性将得到进一步的提升。</p><p>此时写操作会先append到wal文件末尾，而不是直接覆盖旧数据。而读操作开始时，会记下当前的WAL文件状态，并且只访问在此之前的数据。这就确保了多线程<strong>读与读</strong>、<strong>读与写</strong>之间可以并发地进行。</p><p>然而，阻塞的情况并非不会发生。</p><ul><li>当多线程写操作并发时，后来者还是必须在源码层等待之前的写操作完成后才能继续。</li></ul><p>SQLite提供了Busy Retry的方案，即发生阻塞时，会触发Busy Handler，此时可以让线程休眠一段时间后，重新尝试操作。重试一定次数依然失败后，则返回<code>SQLITE_BUSY</code>错误码。</p><p><img src="/images/sqlite/01.jpg" alt="01"></p><h3 id="6-1-3-SQLite-Busy-Retry方案的不足"><a href="#6-1-3-SQLite-Busy-Retry方案的不足" class="headerlink" title="6.1.3 SQLite Busy Retry方案的不足"></a>6.1.3 SQLite Busy Retry方案的不足</h3><p>Busy Retry的方案虽然基本能解决问题，但对性能的压榨做的不够极致。在Retry过程中，休眠时间的长短和重试次数，是决定性能和操作成功率的关键。</p><p>然而，它们的最优值，因不同操作不同场景而不同。</p><ul><li>若休眠时间太短，使得重试次数太多，会空耗CPU的资源；（<em>CPU重试加锁的时间里，是空转的，不响应任何别的工作程序。如下图中第二段红色Try Lock。</em>）</li><li>若休眠时间过长，会造成等待的时间太长；（<em>如下图第三段红色Sleep，CPU可用的情况下，因为sleep时间还没截止，会继续等待。</em>）</li><li>若重试次数太少，则会降低操作的成功率。</li></ul><p><img src="/images/sqlite/02.jpg" alt="01"></p><p>我们通过A/B Test对不同的休眠时间进行了测试，得到了如下的结果：</p><p><img src="/images/sqlite/03.jpg" alt="01"></p><p>可以看到，倘若休眠时间与重试成功率的关系，按照绿色的曲线进行分布，那么p点的值也不失为该方案的一个次优解。然而事总不遂人愿，我们需要一个更好的方案。</p><h3 id="6-1-4-SQLite中的线程锁及进程锁"><a href="#6-1-4-SQLite中的线程锁及进程锁" class="headerlink" title="6.1.4 SQLite中的线程锁及进程锁"></a>6.1.4 SQLite中的线程锁及进程锁</h3><p>作为有着十几年发展历史、且被广泛认可的数据库，SQLite的任何方案选择都是有其原因的。在完全理解由来之前，切忌盲目自信、直接上手修改。因此，首先要了解SQLite是如何控制并发的。</p><p><img src="/images/sqlite/04.png" alt="01"></p><p>SQLite是一个适配不同平台的数据库，不仅支持多线程并发，还支持多进程并发。它的核心逻辑可以分为两部分：</p><ul><li>Core层。包括了接口层、编译器和虚拟机。通过接口传入SQL语句，由编译器编译SQL生成虚拟机的操作码opcode。而虚拟机是基于生成的操作码，控制Backend的行为。</li><li>Backend层。由B-Tree、Pager、OS三部分组成，实现了数据库的存取数据的主要逻辑。</li></ul><p>在架构最底端的OS层是对不同操作系统的系统调用的抽象层。它实现了一个VFS（Virtual File System），将OS层的接口在编译时映射到对应操作系统的系统调用。锁的实现也是在这里进行的。</p><p>SQLite通过两个锁来控制并发：</p><ul><li>第一个锁对应DB文件，通过5种状态进行管理；</li><li>第二个锁对应WAL文件，通过修改一个16-bit的unsigned short int的每一个bit进行管理。</li></ul><p>尽管锁的逻辑有一些复杂，但此处并不需关心。这两种锁最终都落在OS层的<code>sqlite3OsLock</code>、<code>sqlite3OsUnlock</code>和<code>sqlite3OsShmLock</code>上具体实现。</p><p>它们在锁的实现比较类似。以lock操作在iOS上的实现为例：</p><ol><li><p>通过<code>pthread_mutex_lock</code>进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则返回<code>SQLITE_BUSY</code></p></li><li><p>通过<code>fcntl</code>进行文件锁，防止其他进程介入。若锁失败，则返回<code>SQLITE_BUSY</code></p><blockquote><p>多线程可以用多线程互斥量pthread_mutex_t实现线程之间上锁，那么多进程之间如何共享锁呢？</p><ul><li><p>使用文件锁<code>flock</code>实现多进程锁</p><p>由于文件锁是存放到位于内存的系统文件表中， 所有进程/线程可通过系统访问。如果不同进程使用同一文件锁（写锁/排他锁），当取得文件锁时，进程可继续执行；如果没有取得锁，则阻塞等待。而唯一标识该文件的是文件路径，因此，可以通过一个共同的文件路径，来实现多进程锁机制。</p></li><li><p>使用多线程锁实现多进程锁</p><p>多线程之间天然共享内存/变量，而多进程各有自己的进程空间，它们之间是不共享数据的。2个关键步骤</p><p>1）互斥锁变量存放到共享内存；</p><p>2）设置互斥锁变量的进程共享属性（PTHREAD_PROCESS_SHARED)；</p></li></ul></blockquote></li></ol><p>而SQLite选择Busy Retry的方案的原因也正是在此－－－<strong>文件锁没有线程锁类似pthread_cond_signal的通知机制。当一个进程的数据库操作结束时，无法通过锁来第一时间通知到其他进程进行重试。因此只能退而求其次，通过多次休眠来进行尝试。</strong></p><h3 id="6-1-5-优化开始"><a href="#6-1-5-优化开始" class="headerlink" title="6.1.5 优化开始"></a>6.1.5 优化开始</h3><p>通过上面的各种分析、准备，终于可以动手开始修改了。</p><p>我们知道，iOS app是单进程的，并<strong>没有多进程并发的需求</strong>，这和SQLite的设计初衷是不相同的。这就给我们的优化提供了理论上的基础。在iOS这一特定场景下，我们可以舍弃兼容性，提高并发性。</p><p>新的方案修改为，当OS层进行lock操作时：</p><ol><li>通过 <code>pthread_mutex_lock</code> 进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则将当前期望跳转的状态，插入到一个FIFO的Queue尾部。最后，线程通过 <code>pthread_cond_wait</code> 进入休眠状态，等待其他线程的唤醒。</li><li>忽略文件锁</li></ol><p>当OS层的unlock操作结束后：</p><ol><li>取出Queue头部的状态量，并比较状态是否能够跳转。若能够跳转，则通过<code>pthread_cond_signal_thread_np</code>唤醒对应的线程重试。</li></ol><blockquote><p><code>pthread_cond_signal_thread_np</code> 是Apple在pthread库中新增的接口，与 <code>pthread_cond_signal</code> 类似，它能唤醒一个等待条件锁的线程。不同的是，<code>pthread_cond_signal_thread_np</code> 可以指定一个特定的线程进行唤醒。</p></blockquote><p><img src="/images/sqlite/05.jpg" alt="01"></p><p>新的方案可以在DB空闲时的第一时间，通知到其他正在等待的线程，最大程度地降低了空等待的时间，且准确无误。此外，由于Queue的存在，当主线程被其他线程阻塞时，可以将主线程的操作“插队”到Queue的头部。当其他线程发起唤醒通知时，主线程可以有更高的优先级，从而降低用户可感知的卡顿。</p><p>该方案上线后，卡顿检测系统检测到</p><ul><li>等待线程锁的造成的卡顿下降超过90%</li><li>SQLITE_BUSY的发生次数下降超过95%</li></ul><img src="/images/sqlite/06.jpg" alt="01" style="zoom:80%;" /><p><img src="/images/sqlite/07.png" alt="01"></p><h2 id="6-2-I-O-性能优化"><a href="#6-2-I-O-性能优化" class="headerlink" title="6.2 I/O 性能优化"></a>6.2 I/O 性能优化</h2><h3 id="6-2-1-保留WAL文件大小"><a href="#6-2-1-保留WAL文件大小" class="headerlink" title="6.2.1 保留WAL文件大小"></a>6.2.1 保留WAL文件大小</h3><p>如上文多线程优化时提到，开启WAL模式后，写入的数据会先append到WAL文件的末尾。待文件增长到一定长度后，SQLite会进行checkpoint。这个长度默认为1000个页大小，在iOS上约为3.9MB。</p><p>同样的，在数据库关闭时，SQLite也会进行checkpoint。不同的是，checkpoint成功之后，会将WAL文件长度删除或truncate到0。下次打开数据库，并写入数据时，WAL文件需要重新增长。而对于文件系统来说，这就意味着需要<strong>消耗时间重新寻找合适的文件块</strong>。</p><p>显然SQLite的设计是针对容量较小的设备，尤其是在十几年前的那个年代，这样的设备并不在少数。而随着硬盘价格日益降低，对于像iPhone这样的设备，几MB的空间已经不再是需要斤斤计较的了。</p><p>因此我们可以修改为：</p><ul><li>数据库关闭并checkpoint成功时，不再truncate或删除WAL文件只修改WAL的文件头的Magic Number。下次数据库打开时，SQLite会识别到WAL文件不可用，重新从头开始写入。</li></ul><blockquote><p>保留WAL文件大小后，每个数据库都会有这约3.9MB的额外空间占用。如果数据库较多，这些空间还是不可忽略的。因此，微信中目前只对读写频繁且检测到卡顿的数据库开启，如聊天记录数据库。</p></blockquote><h3 id="6-2-2-mmap优化"><a href="#6-2-2-mmap优化" class="headerlink" title="6.2.2 mmap优化"></a>6.2.2 mmap优化</h3><p>mmap对I/O性能的提升无需赘言，尤其是对于读操作。SQLite也在OS层封装了mmap的接口，可以无缝地切换mmap和普通的I/O接口。只需配置 <code>PRAGMA mmap_size=XXX</code> 即可开启mmap。</p><blockquote><p>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</p><p>Many operations, especially I/O intensive operations, can be much faster since content does need to be copied between kernel space and user space. In some cases, performance can nearly double.</p><p>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</p><p>使用内存映射 I/O 有利有弊。优点包括：</p><ul><li>许多操作，尤其是 I/O 密集型操作，可以更快。因为内容不再需要在内核空间和用户空间之间复制。在某些情况下，性能几乎可以翻倍。</li><li>SQLite 库可能需要更少的 RAM，因为它与操作系统页面缓存(page cache)共享pages，而且并不总是需要自己的工作页面(working pages)副本。</li></ul></blockquote><p>然而，你在iOS上这样配置恐怕不会有任何效果。因为早期的iOS版本的存在一些bug，SQLite在编译层就关闭了在iOS上对mmap的支持，并且后知后觉地在16年1月才重新打开。所以如果使用的SQLite版本较低，还需注释掉相关代码后，重新编译生成后，才可以享受上mmap的性能。</p><p><img src="/images/sqlite/08.jpg" alt="01"></p><p>开启mmap后，SQLite性能将有所提升，但这还不够。因为它只会对DB文件进行了mmap，而WAL文件享受不到这个优化。</p><p>WAL文件长度是可能变短的，而在多句柄下，对WAL文件的操作是并行的。一旦某个句柄将WAL文件缩短了，而没有一个通知机制让其他句柄更新mmap的内容。此时其他句柄若使用mmap操作已被缩短的内容，就会造成crash。而普通的I/O接口，则只会返回错误，不会造成crash。因此，SQLite没有实现对WAL文件的mmap。</p><p>还记得我们上一个优化吗？没错，我们保留了WAL文件的大小。因此它在这个场景下是不会缩短的，那么不能mmap的条件就被打破了。实现上，只需在WAL文件打开时，用<code>unixMapfile</code>将其映射到内存中，SQLite的OS层即会自动识别，将普通的I/O接口切换到mmap上。</p><h2 id="6-3-其他优化"><a href="#6-3-其他优化" class="headerlink" title="6.3 其他优化"></a>6.3 其他优化</h2><h3 id="6-3-1-禁用文件锁"><a href="#6-3-1-禁用文件锁" class="headerlink" title="6.3.1 禁用文件锁"></a>6.3.1 禁用文件锁</h3><p>如我们在多线程优化时所说，对于iOS app并没有多进程的需求。因此我们可以直接注释掉<code>os_unix.c</code>中所有文件锁相关的操作。</p><p>也许你会很奇怪，虽然没有文件锁的需求，但这个操作耗时也很短，是否有必要特意优化呢？其实并不全然。耗时多少是比出来。</p><p>SQLite中有cache机制。被加载进内存的page，使用完毕后不会立刻释放。而是在一定范围内通过LRU的算法更新page cache。这就意味着，如果cache设置得当，大部分读操作都不会读取新的page。然而因为文件锁的存在，本来这个只需在内存层面进行的读操作，不得不进行至少一次I/O操作。而我们知道，I/O操作是远远慢于内存操作的。</p><h3 id="6-3-2-禁用内存统计锁"><a href="#6-3-2-禁用内存统计锁" class="headerlink" title="6.3.2 禁用内存统计锁"></a>6.3.2 禁用内存统计锁</h3><p>SQLite会对申请的内存进行统计，而这些统计的数据都是放到同一个全局变量里进行计算的。这就意味着统计前后，都是需要加线程锁，防止出现多线程问题的。</p><p><img src="/images/sqlite/09.jpg" alt="01"></p><p>内存申请虽然不是非常耗时的操作，但却很频繁。多线程并发时，各线程很容易互相阻塞。</p><p>阻塞虽然也很短暂，但频繁地切换线程，却是个很影响性能的操作，尤其是单核设备。</p><p>因此，如果不需要内存统计的特性，可以通过<code>sqlite3_config(SQLITE_CONFIG_MEMSTATUS, 0)</code>进行关闭。这个修改虽然不需要改动源码，但如果不查看源码，恐怕是比较难发现的。</p><p>优化上线后，卡顿监控系统监测到</p><ul><li>DB写操作造成的卡顿下降超过80%</li><li>DB读操作造成的卡顿下降超过85%</li></ul><img src="/images/sqlite/10.jpg" alt="01" style="zoom:80%;" /><h2 id="6-4-数据库修复"><a href="#6-4-数据库修复" class="headerlink" title="6.4 数据库修复"></a>6.4 数据库修复</h2><blockquote><p>数据库修复指的是通过技术手段将损坏的数据库文件修复至可正常使用的数据库文件的过程。 </p></blockquote><h3 id="6-4-1-前言"><a href="#6-4-1-前言" class="headerlink" title="6.4.1 前言"></a>6.4.1 前言</h3><p>众所周知，微信在后台服务器不保存聊天记录，微信在移动客户端所有的聊天记录都存储在一个 SQLite 数据库中，一旦这个数据库损坏，将会丢失用户多年的聊天记录。而我们监控到现网的损坏率是0.02%，也就是每 1w 个用户就有 2 个会遇到数据库损坏。考虑到微信这么庞大的用户基数，这个损坏率就很严重了。更严重的是我们用的官方修复算法，修复成功率只有 30%。损坏率高，修复率低，这两个问题都需要我们着手解决。</p><h3 id="6-4-2-SQLite-损坏原因及其优化-降低损坏率"><a href="#6-4-2-SQLite-损坏原因及其优化-降低损坏率" class="headerlink" title="6.4.2 SQLite 损坏原因及其优化(降低损坏率)"></a>6.4.2 SQLite 损坏原因及其优化(降低损坏率)</h3><p>我们首先来看 SQLite 损坏的原因，SQLite官网(<a href="http://www.sqlite.org/howtocorrupt.html)%E4%B8%8A%E5%88%97%E5%87%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A">http://www.sqlite.org/howtocorrupt.html)上列出以下几点：</a></p><ul><li>文件错写</li><li>文件锁 bug</li><li>文件 sync 失败</li><li>设备损坏</li><li>内存覆盖</li><li>操作系统 bug</li><li>SQLite bug</li></ul><p>但是我们通过收集到的大量案例和日志，分析出实际上移动端数据库损坏的真正原因其实就3个：</p><ul><li>空间不足</li><li>设备断电</li><li>文件 sync 失败</li></ul><p>我们需要针对这些原因一一进行优化。</p><h4 id="1-优化空间占用"><a href="#1-优化空间占用" class="headerlink" title="1. 优化空间占用"></a>1. 优化空间占用</h4><p>首先我们来优化微信的空间占用问题。在这之前微信的部分业务也做了空间清理，例如朋友圈会自动删除7天前缓存的图片。但是总的来说对文件空间的使用缺乏一个全局把控，全靠各个业务自觉。我们需要做得更积极主动，要让开发人员意识到用户的存储空间是宝贵的。我们采取以下措施：</p><ul><li>业务文件先申请后使用，如果某个文件没有申请就使用了，会被自动扫描出来并删除；</li><li>每个业务文件都要申明有效期，是一天、一个星期、一个月还是永久存储；</li><li>过期文件会被自动清理。</li></ul><p><img src="/images/sqlite/11.jpg" alt="11"></p><p>对于微信之外的空间占用，例如相册、视频、其他App的空间占用，微信本身是做不了什么事情的，我们可以提示用户进行空间清理： </p><img src="/images/sqlite/12.jpg" style="zoom:65%;" /><h4 id="2-优化文件-sync"><a href="#2-优化文件-sync" class="headerlink" title="2. 优化文件 sync"></a>2. 优化文件 sync</h4><h5 id="1-synchronous-FULL"><a href="#1-synchronous-FULL" class="headerlink" title="1) synchronous = FULL"></a>1) synchronous = FULL</h5><p>设置SQLite的文件同步机制为全同步，亦即要求每个事务的写操作是真的flush到文件里去。</p><h5 id="2-fullfsync-1"><a href="#2-fullfsync-1" class="headerlink" title="2) fullfsync = 1"></a>2) fullfsync = 1</h5><p>通过与苹果工程师的交流，我们发现在 iOS 平台下还有 fullfsync (<a href="https://www.sqlite.org/pragma.html#pragma_fullfsync">https://www.sqlite.org/pragma.html#pragma_fullfsync</a>) 这个选项，可以严格保证写入顺序跟提交顺序一致。设备开发商为了测评数据好看，往往会对提交的数据进行重排，再统一写入，亦即写入顺序跟App提交的顺序不一致。在某些情况下，例如断电，就可能导致写入文件不一致的情况，导致文件损坏。</p><h4 id="3-优化效果"><a href="#3-优化效果" class="headerlink" title="3. 优化效果"></a>3. 优化效果</h4><p>多管齐下之后，我们成功将损坏率降低了一半多；DB损坏还是无法完全避免，我们还是得提高修复成功率。 </p><img src="/images/sqlite/13.jpg" style="zoom:65%;" /><h3 id="6-4-3-SQLite-修复逻辑优化-提高修复率"><a href="#6-4-3-SQLite-修复逻辑优化-提高修复率" class="headerlink" title="6.4.3 SQLite 修复逻辑优化(提高修复率)"></a>6.4.3 SQLite 修复逻辑优化(提高修复率)</h3><p>长久以来SQLite DB都有损坏问题，从Android、iOS等移动系统，到Windows、Linux 等桌面系统都会出现。由于微信所有消息都保存在DB，服务端不保留备份，一旦损坏将导致用户消息数据丢失，显然不能接受。</p><p>下面介绍一下微信数据库修复的具体方案和发展历程。</p><h4 id="1-我们的需求"><a href="#1-我们的需求" class="headerlink" title="1. 我们的需求"></a>1. 我们的需求</h4><p>具体来说，微信需要一套满足以下条件的DB恢复方案：</p><ul><li><strong>恢复成功率高。</strong> 由于牵涉到用户核心数据，“姑且一试”的方案是不够的，虽说 100% 成功率不太现实，但 90% 甚至 99% 以上的成功率才是我们想要的。</li><li><strong>支持加密DB。</strong> Android 端微信客户端使用的是加密 SQLCipher DB，加密会改变信息 的排布，往往对密文一个字节的改动就能使解密后一大片数据变得面目全非。这对于数据恢复 不是什么好消息，我们的方案必须应对这种情况。</li><li><strong>能处理超大的数据量。</strong> 经过统计分析，个别重度用户DB大小已经超过2GB，恢复方案 必须在如此大的数据量下面保证不掉链子。</li><li><strong>不影响体验。</strong> 统计发现只有万分之一不到的用户会发生DB损坏，如果恢复方案 需要事先准备（比如备份），它必须对用户不可见，不能为了极个别牺牲全体用户的体验。</li></ul><p>经过多年的不断改进，微信先后采用出三套不同的DB恢复方案，离上面的目标已经越来越近了。</p><h4 id="2-sql-master表介绍"><a href="#2-sql-master表介绍" class="headerlink" title="2. sql_master表介绍"></a>2. sql_master表介绍</h4><p>首先我们来看 SQLite 的架构。SQLite 使用 B+树 存储一个表，整个 SQLite 数据库就是这些 B+树 组成的森林。</p><ul><li>每个表的元数据，都记录在一个叫 sql_master 的表中。</li><li>这个 sql_master 表(下面有些场景简称 master 表) 本身也是一个 B+树 存储的普通表。DB 第0页就是他的根节点。</li></ul><img src="/images/sqlite/14.jpg" style="zoom:85%;" /><p><code>sqlite_master</code>是一个每个SQLite DB都有的特殊的表， 无论是查看官方文档<a href="https://www.sqlite.org/schematab.html">Database File Format</a>，还是执行SQL语句 <code>SELECT * FROM sqlite_master;</code>，都可得知这个SQLite的系统表中保存着数据库中所有的其他表、索引(indexes)、触发器(triggers)、视图(views)的元数据：表名、类型（table/index）、创建此表/索引的SQL语句，以及表的RootPage。(只包括table本身的信息即元数据，不包括里面的数据哦)</p><p><code>sqlite_master</code> 每一行记录一个项目。在创建一个SQLIte数据库的时候，该表会自动创建。<code>sqlite_master</code>的表名、表结构都是固定的：</p><ul><li>type：是以下文本字符串之一：“table”、“index”、“view”或“trigger”，具体取决于定义的对象类型。 ‘table’ 字符串用于普通表和虚拟表。</li><li>name：保存对象的名称。</li><li>tbl_name：包含与对象关联的表或视图的名称。<ul><li>对于表或视图，tbl_name 列是 name 列的副本。</li><li>对于索引，tbl_name 是被索引的表的名称。</li><li>对于触发器，tbl_name 列存储导致触发器触发的表或视图的名称。</li></ul></li><li>rootpage：存储表和索引的 b-tree 根节点的 page 号。对于描述视图、触发器和虚拟表(virtual tables)的行，rootpage 列是 0 或 NULL。</li><li>sql：存储描述对象的 SQL 文本。此 SQL 文本是 CREATE TABLE、CREATE VIRTUAL TABLE、CREATE INDEX、CREATE VIEW 或 CREATE TRIGGER 语句。</li><li><em>更详细的说明，可以见上面的官方文档链接</em></li></ul><img src="/images/sqlite/15.jpg" style="zoom:100%;" /><p><strong>正常情况下，SQLite 引擎打开DB后首次使用，需要先遍历</strong> <code>sqlite_master</code>，并将里面保存的SQL语句再解析一遍， 保存在内存中供后续编译SQL语句时使用。</p><p>由于sqlite_master表存储所有的数据库项目，所以可以通过该表判断特定的表、视图或者索引是否存在。例如，以下语句可以判断user表是否存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> sqlite_master <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;user&#x27;</span> <span class="keyword">and</span> type<span class="operator">=</span><span class="string">&#x27;table&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-方案一：官方的Dump恢复方案"><a href="#3-方案一：官方的Dump恢复方案" class="headerlink" title="3. 方案一：官方的Dump恢复方案"></a>3. 方案一：官方的Dump恢复方案</h4><p>Google 一下SQLite DB恢复，不难搜到使用<code>.dump</code>命令恢复DB的方法。<code>.dump</code>命令的作用是将 整个数据库的内容输出为很多 SQL 语句，只要对空 DB 执行这些语句就能得到一个一样的 DB。</p><p><code>.dump</code>命令原理很简单：</p><ol><li>每个SQLite DB都有一个<code>sqlite_master</code>表。遍历它得到所有表的名称和 <code>CREATE TABLE ...</code>的SQL语句，输出<code>CREATE TABLE</code>语句。</li><li>根据根节点地址和创表语句接着使用<code>SELECT * FROM ...</code> 通过表名遍历整个表，每读出一行就输出一个<code>INSERT</code>语句，遍历完后就把整个DB dump出来了（<em>能 select 多少是多少</em>）。</li></ol><p>这样的操作，和普通查表是一样的，遇到损坏一样会返回<code>SQLITE_CORRUPT</code>，我们忽略掉损坏错误，继续遍历下个表，最终可以把所有没损坏的表以及<strong>损坏了的表的前半部分</strong>读取出来。将dump 出来的SQL语句逐行执行，最终可以得到一个等效的新DB。由于直接跑在SQLite上层，所以天然 就支持加密SQLCipher，不需要额外处理。</p><p>下图是dump输出样例：</p><img src="/images/sqlite/16.jpg" style="zoom:100%;" /><p>优点：</p><ul><li>这个方案不需要任何准备，只有坏DB的用户要花好几分钟跑恢复，大部分用户是不感知的。 </li></ul><p>缺点：</p><ul><li>数据量大小，主要影响恢复需要的临时空间：先要保存 dump 出来的SQL的空间，这个大概一倍DB大小，还要另外一倍 DB大小来新建 DB恢复。</li><li>至于我们最关心的成功率呢？上线后，<strong>成功率约为30</strong>%。这个成功率的定义是至少恢复了一条记录，也就是说一大半用户 一条都恢复不成功！研究一下就发现，恢复失败的用户，原因都是<code>sqlite_master</code>表读不出来。</li></ul><p><strong>官方修复算法率低下原因 — 太依赖 master 表</strong>：</p><p>前面说过，master 表他本身也是一个 B+树 形式的普通表，DB 第0页就是他的根节点。那么只要 master 表某个节点损坏，这个节点下面记录的表就都恢复不了。更坏的情况是 DB 第0页损坏，那么整个 master 表都读不出来，就导致整个DB都恢复失败。这就是官方修复算法成功率这么低的原因，太依赖 master 表了。</p><p>恢复率这么低的尴尬状况维持了好久， 其他方案才渐渐露出水面。</p><h4 id="4-方案二：备份恢复方案"><a href="#4-方案二：备份恢复方案" class="headerlink" title="4. 方案二：备份恢复方案"></a>4. 方案二：备份恢复方案</h4><p>损坏的数据无法修复，最直观的解决方案就是<strong>备份</strong>，于是备份恢复方案被提上日程了。备份恢复这个方案思路简单，SQLite 也有不少备份机制可以使用，具体是：</p><ul><li><strong>拷贝：</strong> 不能再直白的方式。由于SQLite DB本身是文件（主DB + journal 或 WAL）， 直接把文件复制就能达到备份的目的。</li><li><strong>Dump：</strong> 上一个恢复方案用到的命令的本来目的。在DB完好的时候执行<code>.dump</code>， 把 DB所有内容输出为 SQL语句，达到备份目的，恢复的时候执行SQL即可。</li><li><strong>Backup API：</strong> SQLite自身提供的一套备份机制，按 Page 为单位复制到新 DB， 支持热备份。</li></ul><p>这么多的方案孰优孰劣？作为一个移动APP，我们关心的无非就是 <strong>备份大小、备份性能、 恢复性能</strong> 几个指标。微信作为一个重度DB使用者，备份大小和备份性能是主要关注点： 原本用户就可能有2GB 大的 DB，如果备份数据本身也有2GB 大小，用户想必不会接受； 性能则主要影响体验和备份成功率，作为用户不感知的功能，占用太多系统资源造成卡顿是不行的，备份耗时越久，被系统杀死等意外事件发生的概率也越高。</p><p>对以上方案做简单测试后，备份方案也就基本定下了。下图是备选方案性能对比（测试用的DB大小约 <strong>50MB</strong>， 数据条目数大约为 <strong>10万条</strong>）：</p><img src="/images/sqlite/17.jpg" style="zoom:100%;" /><p>可以看出，比较折中的选择是 <strong>Dump + 压缩</strong>，备份大小具有明显优势，备份性能尚可， 恢复性能较差但由于需要恢复的场景较少，算是可以接受的短板。</p><p>微信在Dump + gzip方案上再加以优化：</p><ul><li><p>由于格式化SQL语句输出耗时较长，因此使用了自定义的二进制格式承载Dump输出。</p><ul><li>由于数据保密需要，二进制Dump数据也做了加密处理。</li><li> 采用自定义二进制格式还有一个好处是，恢复的时候不需要重复的编译SQL语句，编译一次就可以插入整个表的数据了，恢复性能也有一定提升。</li></ul></li><li><p>第二耗时的压缩操作则放到别的线程同时进行，在双核以上的环境基本可以做到无额外时间消耗。</p></li></ul><p>相比原始的Dump + 压缩，优化后的方案<strong>每秒备份行数提升了 150%，每秒恢复行数也提升了 40%</strong> （性能优化效果如下图）。</p><img src="/images/sqlite/18.jpg" style="zoom:80%;" /><p>即使优化后的方案，对于特大DB备份也是<strong>耗时耗电</strong>。对于移动APP来说，可能未必有这样的机会做这样重度的操作，或者频繁备份会导致卡顿，这也是需要开发者衡量的。比如Android微信会选择在 <strong>充电并灭屏</strong> 时进行DB备份，若备份过程中退出以上状态，备份会中止，等待下次机会。</p><p>备份方案上线后，恢复成功率<strong>达到72</strong>%，但有部分重度用户DB损坏时，由于备份耗时太久， 始终没有成功，而对DB数据丢失更为敏感的也恰恰是这些用户，于是新方案应运而生。</p><h4 id="5-方案三：解析B-tree恢复方案-RepairKit"><a href="#5-方案三：解析B-tree恢复方案-RepairKit" class="headerlink" title="5. 方案三：解析B-tree恢复方案(RepairKit)"></a>5. 方案三：解析B-tree恢复方案(RepairKit)</h4><p>备份方案的高消耗迫使我们从另外的方案考虑，于是我们再次把注意力放在之前的Dump方案。 Dump 方案本质上是尝试从坏DB里读出信息，这个尝试一般来说会出现两种结果：</p><ul><li>DB的基本格式仍然健在，但个别数据损坏，读到损坏的地方SQLite返回 <code>SQLITE_CORRUPT</code> 错误， 但已读到的数据得以恢复。</li><li>基本格式丢失（文件头或<code>sqlite_master</code>损坏），获取有哪些表的时候就返回 <code>SQLITE_CORRUPT</code> ，根本没法恢复。</li></ul><p>第一种可以算是预期行为，毕竟没有损坏的数据能 <strong>部分恢复</strong>。从之前的数据看， 不少用户遇到的是第二种情况，这种有没挽救的余地呢？ —— <strong>sqlite_master 损坏时的修复方案</strong>。</p><h5 id="1-方案：自实现数据读取系统"><a href="#1-方案：自实现数据读取系统" class="headerlink" title="1) 方案：自实现数据读取系统"></a>1) 方案：自实现数据读取系统</h5><p>假如<code>sqlite_master</code>损坏了无法解析，“Dump恢复”这种走正常SQLite 流程的方法，自然会卡在第一步了。</p><p>为了让<code>sqlite_master</code>受损的DB也能打开，需要想办法绕过SQLite引擎的逻辑。 <strong>由于SQLite引擎初始化逻辑比较复杂，为了避免副作用，没有采用hack的方式复用其逻辑，而是决定仿造一个只可以读取数据的最小化系统</strong>。</p><p>虽然仿造最小化系统可以跳过很多正确性校验，但也需要一些必须的数据：</p><h5 id="2-关键点1-—-sqlite-master备份"><a href="#2-关键点1-—-sqlite-master备份" class="headerlink" title="2) 关键点1 — sqlite_master备份"></a>2) 关键点1 — sqlite_master备份</h5><p><code>sqlite_master</code>里保存的信息对恢复来说也是十分重要的， 特别是RootPage，因为它是表对应的B-tree结构的根节点所在地，没有了它我们甚至不知道从哪里开始解析对应的表。</p><p><code>sqlite_master</code>信息量比较小，因此对它进行备份成本是非常低的，一般手机典型只需要几毫秒到数十毫秒即可完成，一致性也容易保证， 只需要执行了上述语句的时候重新备份一次即可。</p><p><strong>备份时机：</strong></p><p>我们只需要每隔一段时间轮询 master 表，看看最近有没有增删 table，有的话就全量备份。</p><p>这里有个担忧，就是普通数据表的插入会不会导致表的根节点发生变化，也就是说 master 表会不会频繁变化，如果变化很频繁的话，我们就不能简单地进行轮询方案了。通过分析源码，我们发现 SQLite 里面 B+树 算法的实现是 <strong>向下分裂</strong> 的，也就是说当一个叶子页满了需要分裂时，原来的叶子页会成为内部节点，然后新申请两个页作为他的叶子页。这就保证了根节点一旦定下来，是再也不会变动的。实际的代码调试也证实了我们这个推论。所以说 master 表只会在新创建表、删除表、修改表结构时（例如执行了<code>CREATE TABLE</code>、<code>ALTER TABLE</code> 等语句）才会发生变化，我们完全可以采用定时轮询方案。</p><p><strong>备份文件有效性</strong></p><p>接下来的难题是既然 DB 可以损坏，那么这个备份文件也会损坏，怎么办呢？我们采用了 <strong>双备份</strong> 的机制。具体来说就是：</p><ul><li>会有新旧两个备份文件，每个文件头都加上 CRC 校验；</li><li>每次备份时，从两个备份文件中选出一个进行覆盖。具体怎么选呢？<ul><li>优先选损坏那个备份文件，如果两个都有效，那么就选相对较旧的。这就保证了即使本次写入导致文件损坏，还有另外一份备份可以用。</li><li>这个做法跟 Realm 标榜的 MVCC（多版本并发控制）的做法有异曲同工之妙，相当于确认新写入的文件有效之后，才使用新写入的文件，否则还是继续用旧的有效的文件。</li></ul></li></ul><p>前面提到 DB 损坏的一个常见场景是空间不足，这种情况下还要分配文件空间给备份文件也是会失败的。为了解决这个问题，我们采取 <strong>预先分配空间</strong> 的做法，初始值是 32K，大约可存 750 个表的元信息，后续则按照32K的倍数进行增长。</p><p>有了备份，我们的逻辑可以在读取DB自带的<code>sqlite_master</code>失败的时候使用备份的信息来代替。</p><h5 id="3-关键点2-—-加解密"><a href="#3-关键点2-—-加解密" class="headerlink" title="3) 关键点2 — 加解密"></a>3) 关键点2 — 加解密</h5><p>DB初始化的问题除了文件头和<code>sqlite_master</code>完整性外，还有加密。</p><p>SQLCipher加密数据库，对应的恢复逻辑还需要加上解密逻辑。按照SQLCipher的实现，加密DB 是按page 进行包括头部的完整加密，所用的密钥是根据用户输入的原始密码和创建DB 时随机生成的 salt 运算后得出的。可以猜想得到，如果保存salt错了，将没有办法得出之前加密用的密钥，导致所有page都无法读出了。由于salt 是创建DB时随机生成，后续不再修改，将它纳入到备份的范围内即可。</p><h5 id="4-实现"><a href="#4-实现" class="headerlink" title="4) 实现"></a>4) 实现</h5><p>到此，初始化必须的数据就保证了，可以仿造读取逻辑了。</p><ul><li>我们常规使用的读取DB的方法（包括dump方式恢复），都是通过执行SQL语句实现的，这牵涉到SQLite系统最复杂的子系统——SQL执行引擎。我们的恢复任务只需要遍历B-tree所有节点， 读出数据即可完成，不需要复杂的查询逻辑，因此最复杂的SQL引擎可以省略。</li><li>同时，因为我们的系统是只读的， 写入恢复数据到新 DB 只要直接调用 SQLite 接口即可，因而可以省略同样比较复杂的B-tree平衡、Journal和同步等逻辑。 </li><li>最后恢复用的最小系统只需要：<ul><li>VFS读取部分的接口（Open/Read/Close），或者直接用stdio的fopen/fread、Posix的open/read也可以</li><li>SQLCipher的解密逻辑：加密 SQLCipher 情况较为复杂，幸好SQLCipher 加密部分可以单独抽出，直接套用其解密逻辑。</li><li>B-tree解析逻辑：Database File Format 详细描述了SQLite文件格式， 参照之实现B-tree解析可读取 SQLite DB。</li></ul></li></ul><p>即可实现。最小化系统如图所示：</p><img src="/images/sqlite/19.jpg" style="zoom:80%;" /><h5 id="5-注意点-—-列的补全"><a href="#5-注意点-—-列的补全" class="headerlink" title="5) 注意点 — 列的补全"></a>5) 注意点 — 列的补全</h5><p>实现了上面的逻辑，就能读出DB的数据进行恢复了，但还有一个小插曲。</p><ul><li>我们知道，使用SQLite查询一个表， 每一行的列数都是一致的，这是Schema层面保证的。但是在Schema的下面一层——B-tree层，没有这个保证。 B-tree的每一行（或者说每个entry、每个record）可以有不同的列数，一般来说，SQLite插入一行时， B-tree里面的列数和实际表的列数是一致的。</li><li>但是<strong>当对一个表进行了 <code>ALTER TABLE ADD COLUMN</code> 操作， 整个表都增加了一列，但已经存在的B-tree行实际上没有做改动，还是维持原来的列数。 当SQLite查询到 <code>ALTER TABLE</code> 前的行，缺少的列会自动用默认值补全</strong>。</li><li>恢复的时候，也需要做同样的判断和支持， 否则会出现缺列而无法插入到新的DB。</li></ul><h5 id="6-优化效果"><a href="#6-优化效果" class="headerlink" title="6) 优化效果"></a>6) 优化效果</h5><p>解析B-tree方案上线后，<strong>成功率约为78</strong>%。这个成功率计算方法为恢复成功的 Page 数除以总 Page 数。 由于是我们自己的系统，可以得知总 Page 数，使用恢复 Page 数比例的计算方法比人数更能反映真实情况。 </p><p>B-tree解析好处是准备成本较低，不需要经常更新备份，对大部分表比较少的应用备份开销也小到几乎可以忽略， 成功恢复后能还原损坏时最新的数据，不受备份时限影响。 坏处是，和Dump一样，如果损坏到表的中间部分，比如非叶子节点，将导致后续数据无法读出。</p><h4 id="6-不同方案的组合"><a href="#6-不同方案的组合" class="headerlink" title="6. 不同方案的组合"></a>6. 不同方案的组合</h4><p>由于解析B-tree恢复原理和备份恢复不同，失败场景也有差别，可以两种手段混合使用覆盖更多损坏场景。 微信的数据库中，有部分数据是临时或者可从服务端拉取的，这部分数据可以选择不修复，有些数据是不可恢复或者 恢复成本高的，就需要修复了。</p><ul><li>如果修复过程一路都是成功的，那无疑使用B-tree解析修复效果要好于备份恢复。备份恢复由于存在时效性，总有部分最新的记录会丢掉，解析修复由于直接基于损坏DB来操作，不存在时效性问题。 假如损坏部分位于不需要修复的部分，解析修复有可能不发生任何错误而完成。</li><li>如果修复过程遇到错误，则很可能是需要修复的B-tree损坏了，这会导致需要修复的表发生部分或全部缺失。 这个时候再使用备份修复，能挽救一些缺失的部分。</li><li>最早的Dump修复，场景已经基本被B-tree解析修复覆盖了，若B-tree修复不成功，Dump恢复也很有可能不会成功。 即便如此，假如上面的所有尝试都失败，最后还是会尝试Dump恢复。</li></ul><p>恢复方案组合如图所示：</p><img src="/images/sqlite/20.jpg" style="zoom:85%;" /><p>上面说的三种修复方法，原理上只涉及到SQLite文件格式以及基本的文件系统，是跨平台的。 实际操作上，各个平台可以利用各自的特性做策略上的调整，比如 Android 系统使用 <code>JobScheduler</code> 在充电灭屏状态下备份。</p><h3 id="6-4-4-小结"><a href="#6-4-4-小结" class="headerlink" title="6.4.4 小结"></a>6.4.4 小结</h3><p>通过这些优化，我们提高了微信聊天记录存储的可靠性。这些优化实践，会同上面在并发、IO性能方面的优化实践（<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a>），将会合并到微信即将开源的 WCDB（WeChat Database）组件中。</p><h2 id="6-5-小结"><a href="#6-5-小结" class="headerlink" title="6.5 小结"></a>6.5 小结</h2><p>移动客户端数据库虽然不如后台数据库那么复杂，但也存在着不少可挖掘的技术点。本次尝试了仅对SQLite原有的方案进行优化，而市面上还有许多优秀的数据库，如LevelDB、RocksDB、Realm等，它们采用了和SQLite不同的实现原理。后续我们将借鉴它们的优化经验，尝试更深入的优化。</p><h1 id="七、SQLite多线程解决方案"><a href="#七、SQLite多线程解决方案" class="headerlink" title="七、SQLite多线程解决方案"></a>七、SQLite多线程解决方案</h1><h2 id="7-1-FMDB中的多线程-—-转串行"><a href="#7-1-FMDB中的多线程-—-转串行" class="headerlink" title="7.1 FMDB中的多线程 — 转串行"></a>7.1 FMDB中的多线程 — 转串行</h2><p><a href="https://github.com/ccgus/fmdb">FMDB</a> 是基于 SQLite 的数据库框架，使用 Objective-C 语言对 SQLite 的 C 语言接口做了一层面向对象的封装，并通过一个 Serial 队列保证在多线程环境下的数据安全。</p><p>FMDB 提供了 <code>FMDatabase</code> 类，该类与数据库文件一一对应，在新建一个 FMDatabase 对象时，可以关联一个已有的数据库文件；该对象以面向对象思想封装了增、删、改、查、事务等常用的数据库操作。但是<code>FMDatabase</code>  <strong>不是线程安全</strong> 的，在多个线程之间使用同一个<code>FMDatabase</code>可能会出现数据错误。</p><p>对于线程安全 FMDB 提供了<code>FMDatabaseQueue</code> 和 <code>FMDatabasePool</code> 。</p><ul><li><code>FMDatabaseQueue</code>持有 SQLite 句柄，多个线程使用同一个句柄，同时在初始化时创建了一个<strong>串行队列</strong>，当在多线程之间执行数据库操作时，<code>FMDatabaseQueue</code>将数据库操作以 <strong>block</strong> 的形式添加到该串行队列，然后按接收<strong>顺序同步执行</strong>，以此来保证数据库在多线程下的数据安全。</li><li><code>FMDatabasePool</code> 实现原理和<code>FMDatabaseQueue</code>一样，它的使用更加灵活，但是容易造成死锁，不推荐使用。</li></ul><p>FMDatabaseQueue原理：让各个线程的数据库操作按顺序同步执行。</p><img src="/images/sqlite/22.png" alt="img" style="zoom:77%;" /><p>示例：</p><p>创建FMDatabaseQueue：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *documentPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSString</span> *path = [documentPath stringByAppendingPathComponent:<span class="string">@&quot;demoDataBase.sqlite&quot;</span>];</span><br><span class="line">_database = [FMDatabase databaseWithPath:path];</span><br></pre></td></tr></table></figure><p>多线程操作数据库：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;张三&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;李四&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;王五&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/images/sqlite/23.png" alt="img" style="zoom:85%;" /><p>数据库结果：</p><p><img src="/images/sqlite/24.png" alt="img"></p><h2 id="7-2-WCDB"><a href="#7-2-WCDB" class="headerlink" title="7.2 WCDB"></a>7.2 WCDB</h2><p>WCDB 是微信团队推出的一个高效、完整、易用的移动数据库框架，基于 SQLCipher（SQLite的加密扩展），支持 iOS，mac OS 和 Android。</p><p>WCDB 通过 <strong>SQLite 多句柄</strong> 和 <strong>WAL 日志模式</strong> 来支持线程间读与读、读与写操作<strong>并发</strong>执行，并通过<strong>优化 Busy Retry 方案</strong> 来提升线程间写与写操作<strong>串行</strong>执行的效率。(<em>实现细节见6.1节</em>)</p><p>WCDB 内置一个句柄池<code>HandlePool</code>，由它管理和分发 SQLite 句柄。WCDB 提供的<code>WCTDatabase</code>、<code>WCTTable</code>和<code>WCTTransaction</code>的所有 SQL 操作接口都是线程安全，它们不直接持有数据库句柄，而是由<code>HandlePool</code>根据数据库访问所在的线程、是否处于事务、并发状态等，自动分发合适的 SQLite 连接进行操作，以此来保证同一个句柄在同一时间只有一个线程在操作，从而达到读与读、读与写并发的效果。</p><h2 id="7-3-性能对比"><a href="#7-3-性能对比" class="headerlink" title="7.3 性能对比"></a>7.3 性能对比</h2><blockquote><p>以下测试数据来自 <a href="https://github.com/Tencent/wcdb/wiki/%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e4%b8%8eBenchmark">WCDB性能数据与Benchmark</a></p></blockquote><p>这里主要对比 FMDB 和 WCDB。</p><p>如无特殊说明，SQLite配置均为WAL模式、缓存大小2000字节、页大小4 kb：</p><ul><li><code>PRAGMA cache_size=-2000</code></li><li><code>PRAGMA page_size=4096</code></li><li><code>PRAGMA journal_mode=WAL</code></li></ul><p>测试数据均为含有一个整型和一个二进制数据的表：<code>CREATE TABLE benchmark(key INTEGER, value BLOB)</code>，二进制数据长度为100字节。</p><h3 id="7-3-1-Baseline"><a href="#7-3-1-Baseline" class="headerlink" title="7.3.1 Baseline"></a>7.3.1 Baseline</h3><ul><li><strong>读操作性能测试</strong>：该测试为从数据库中取出所有数据，并拼装为object。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_read.png" style="zoom:57%;" /><ul><li><strong>写操作性能测试</strong>：该测试为将object的数据不断插入到数据库中（不使用事务）。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_write.png" style="zoom:57%;" /><ul><li><strong>批量写操作性能测试</strong>：该测试为将object的数据批量插入数据库（使用事务）。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_batch_write.png" style="zoom:57%;" /><p>WCDB写操作和批量写操作的性能分别优于FMDB <strong>28%</strong> 和 <strong>180%</strong> ，而读操作则劣于FMDB <strong>5%</strong> 。</p><p>对于读操作，SQLite速度很快，因此封装层的消耗会占比较多。FMDB只做了最简单的封装， 而WCDB还包括ORM、WINQ等操作，因此执行的指令会比FMDB多，从而导致性能稍差于FMDB。但WCDB也通过一些优化手段减少这种差距。例如，通过IMP指针调用函数、部分操作No-ARC等等。</p><p>而写操作，WCDB也做了许多针对性的优化。例如，WAL模式下写入操作触发checkpoint时，不立即执行checkpoint，而是由一个checkpoint线程来完成，从而减少单次操作的耗时等等。</p><h3 id="7-3-2-Multithread"><a href="#7-3-2-Multithread" class="headerlink" title="7.3.2 Multithread"></a>7.3.2 Multithread</h3><ul><li><strong>多线程读操作性能测试</strong>：该测试同时启动两个线程，分别从数据库中取出所有数据，并拼装为object。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_read_read.png" style="zoom:57%;" /><ul><li><strong>多线程读写操作性能测试</strong>：该测试同时启动两个线程，一个线程从数据库中取出所有数据，并拼装为object；另一个将object的数据批量插入到数据库中。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_read_write.png" style="zoom:57%;" /><ul><li><strong>多线程写操作性能测试</strong>：该测试同时启动两个线程，分别将object的数据批量插入数据库。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_write_write.png" style="zoom:57%;" /><p>WCDB 的多线程读写操作性能优于 FMDB <strong>62%</strong> ，而多线程读操作基本与 FMDB 持平（FMDB 只对 SQLite 做了最简单的封装， 而 WCDB 还包括ORM、WINQ等操作，执行的指令会比 FMDB 多，因此在多线程读测试中没有表现出明显的优势）。</p><p>FMDB在多线程写测试中，直接触发了 Busy Retry ，返回错误<code>SQLITE_BUSY</code>，因此无法比较。而WCDB通过优化Busy Retry，多线程写操作实质也是串行执行，但不会出错导致操作中断。</p><h2 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h2><p>FMDB 采用串行队列来保证线程安全，并且采用单句柄方案，即所有线程共用一个SQLite Handle。在多线程并发时，虽然能够使各个线程的数据库操作按顺序同步进行，保证了数据安全，但正是因为各线程同步进行，导致后来的线程会被阻塞较长时间，无论是读操作还是写操作，都必须等待前面的线程执行完毕，使得性能无法得到更好的保障。</p><p>WCDB 内置了一个句柄池，根据各个线程的情况派发数据库句柄，通过多句柄方案来实现线程间读与读、读与写并发执行，并开启SQLite的WAL日志模式进一步提高多线程的并发性。同时 WCDB 修改了SQLite的内部实现，优化了 Busy Retry 方案，禁用了文件锁并添加队列来支持主动唤醒等待的线程，以此来提高线程间写与写串行执行的效率。</p><p>WCDB 在多线程方面明显优于 FMDB。</p><h1 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h1><ul><li>并发及IO优化<ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a></li></ul></li><li>数据库修复<ul><li><a href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw">微信 SQLite 数据库修复实践</a></li><li><a href="https://cloud.tencent.com/developer/article/1005513">微信移动端数据库组件 WCDB 系列：数据库修复三板斧（二）</a></li></ul></li><li>WCDB的使用<ul><li><a href="https://mp.weixin.qq.com/s/1XxcrsR2HKam9ytNk8vmGw">微信移动端数据库组件WCDB系列（一）-iOS基础篇</a></li><li><a href="https://cloud.tencent.com/developer/article/1005718">为什么要从 FMDB 迁移到 WCDB？</a></li><li><a href="https://github.com/Tencent/wcdb/wiki/%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E4%B8%8EBenchmark">性能数据与Benchmark</a></li><li><a href="https://github.com/Tencent/wcdb">WCDB 源码</a></li></ul></li><li><a href="https://cloud.tencent.com/developer/article/1005549">微信 WCDB 进化之路：开源与开始</a></li><li><a href="https://github.com/ccgus/fmdb">FMDB 源码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS-数据库方案&quot;&gt;&lt;a href=&quot;#iOS-数据库方案&quot; class=&quot;headerlink&quot; title=&quot;iOS 数据库方案&quot;&gt;&lt;/a&gt;iOS 数据库方案&lt;/h1&gt;&lt;p&gt;目前移动端数据库方案按其实现可分为两类，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="数据的存储与传输" scheme="https://tenloy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BC%A0%E8%BE%93/"/>
    
    
  </entry>
  
  <entry>
    <title>内存映射mmap函数的原理与应用</title>
    <link href="https://tenloy.github.io/2022/04/28/mmap.html"/>
    <id>https://tenloy.github.io/2022/04/28/mmap.html</id>
    <published>2022-04-28T10:15:19.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p><img src="/images/OS/mmap/mmap-03.png" alt="mmap-03" style="zoom:100%;" /><h2 id="二、相关API"><a href="#二、相关API" class="headerlink" title="二、相关API"></a>二、相关API</h2><h3 id="2-1-mmap"><a href="#2-1-mmap" class="headerlink" title="2.1 mmap()"></a>2.1 mmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mmap(), munmap() - map or unmap files or devices into memory(将文件或设备映射或取消映射到内存中)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * addr/length分别用于指定需要申请的空间的起始地址和长度。</span></span><br><span class="line"><span class="comment"> *    如果addr设置为0/NULL，那么Linux系统会自动挑选合适的起始地址(这是最方便的方式)。</span></span><br><span class="line"><span class="comment"> *    如果addr不为NULL，则内核将其作为关于在何处放置映射的提示；</span></span><br><span class="line"><span class="comment"> *        在Linux上，内核将选择一个附近的页面边界（但总是高于或等于 /proc/sys/vm/mmap_min_addr 指定的值）并尝试在那里创建映射。</span></span><br><span class="line"><span class="comment"> *        如果那里已经存在另一个映射，内核会选择一个新地址，该地址可能依赖于提示，也可能不依赖于提示。</span></span><br><span class="line"><span class="comment"> * prot: 用于设置申请的空间的权限（可读、可写、可执行，并且不能与文件的打开模式冲突）。是以下的某个值，可以通过or运算合理地组合在一起</span></span><br><span class="line"><span class="comment">                  PROT_EXEC  ：页内容可以被执行</span></span><br><span class="line"><span class="comment">                  PROT_READ  ：页内容可以被读取</span></span><br><span class="line"><span class="comment">                  PROT_WRITE ：页可以被写入</span></span><br><span class="line"><span class="comment">                  PROT_NONE  ：页不可访问</span></span><br><span class="line"><span class="comment"> * @param flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</span></span><br><span class="line"><span class="comment">                  MAP_FIXED     // 使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</span></span><br><span class="line"><span class="comment">                  MAP_SHARED    // 与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。</span></span><br><span class="line"><span class="comment">                  MAP_PRIVATE   // 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</span></span><br><span class="line"><span class="comment">                  MAP_DENYWRITE // 这个标志被忽略。</span></span><br><span class="line"><span class="comment">                  MAP_EXECUTABLE// 同上</span></span><br><span class="line"><span class="comment">                  MAP_NORESERVE // 不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</span></span><br><span class="line"><span class="comment">                  MAP_LOCKED    // 锁定映射区的页面，从而防止页面被交换出内存。</span></span><br><span class="line"><span class="comment">                  MAP_GROWSDOWN // 用于堆栈，告诉内核VM系统，映射区可以向下扩展。</span></span><br><span class="line"><span class="comment">                  MAP_ANONYMOUS // 匿名映射，映射区不与任何文件关联。</span></span><br><span class="line"><span class="comment">                  MAP_ANON      // MAP_ANONYMOUS的别称，不再被使用。</span></span><br><span class="line"><span class="comment">                  MAP_FILE      // 兼容标志，被忽略。</span></span><br><span class="line"><span class="comment">                  MAP_32BIT     // 将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</span></span><br><span class="line"><span class="comment">                  MAP_POPULATE  // 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</span></span><br><span class="line"><span class="comment">                  MAP_NONBLOCK  // 仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</span></span><br><span class="line"><span class="comment"> * flags:用于设置映射类型（文件映射、匿名空间等）。确定映射的更新是否对映射同一区域的其他进程可见，以及是否将更新传递到底层文件。</span></span><br><span class="line"><span class="comment"> * fd:   用于文件映射时，指定文件描述符。在mmap()调用返回后，文件描述符fd可以立即关闭，而不会使映射无效。</span></span><br><span class="line"><span class="comment"> * offset: 用于文件映射时，指定文件偏移。offset 必须是 sysconf(_SC_PAGE_SIZE) 返回的页面大小的倍数。</span></span><br><span class="line"><span class="comment"> * return: </span></span><br><span class="line"><span class="comment"> *  成功时，mmap() 返回一个指向映射区域的指针。</span></span><br><span class="line"><span class="comment"> *  出错时，返回值 MAP_FAILED（即 (void *) -1），并设置 errno 以指示错误。</span></span><br><span class="line"><span class="comment">                  EACCES：访问出错</span></span><br><span class="line"><span class="comment">                  EAGAIN：文件已被锁定，或者太多的内存已被锁定</span></span><br><span class="line"><span class="comment">                  EBADF ：fd不是有效的文件描述词</span></span><br><span class="line"><span class="comment">                  EINVAL：一个或者多个参数无效</span></span><br><span class="line"><span class="comment">                  ENFILE：已达到系统对打开文件的限制</span></span><br><span class="line"><span class="comment">                  ENODEV：指定文件所在的文件系统不支持内存映射</span></span><br><span class="line"><span class="comment">                  ENOMEM：内存不足，或者进程已超出最大内存映射数量</span></span><br><span class="line"><span class="comment">                  EPERM ：权能不足，操作不允许</span></span><br><span class="line"><span class="comment">                  ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志</span></span><br><span class="line"><span class="comment">                  SIGSEGV：试着向只读区写入</span></span><br><span class="line"><span class="comment">                  SIGBUS：试着访问不属于进程的内存区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>mmap() 的作用就是向操作系统申请一段虚拟地址空间，这段空间：</p><ul><li>当然这块虚拟地址空间可以映射到某个文件（这也是这个系统调用的最初的作用）<ul><li>此时，会使用从文件描述符 <code>fd</code> 引用的文件（或其他对象）中， 偏移量 <code>offset</code> 开始，长度 <code>length</code> 字节的数据，对映射区域进行初始化。</li></ul></li><li>当它不将地址空间映射到某个文件时，我们又称这块空间为匿名（Anonymous）空间，匿名空间就可以拿来作为堆空间(就是单纯的申请内存)，又称匿名映射。<ul><li>此时，映射没有任何文件支持；它的内容被初始化为零。</li><li>关于这个使用，详见<em>4.2.1节-malloc的原理</em>。</li></ul></li><li>使用场景：进程间通信(共享内存映射)、文件的装载。</li></ul><h3 id="2-2-munmap"><a href="#2-2-munmap" class="headerlink" title="2.2 munmap()"></a>2.2 munmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>成功执行时，munmap()返回0。失败时，munmap返回-1，error返回标志和mmap一致；</p><p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；</p><p>当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p><h3 id="2-3-msync"><a href="#2-3-msync" class="headerlink" title="2.3 msync()"></a>2.3 msync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。</p><p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p><h2 id="三、mmap和常规文件操作的区别"><a href="#三、mmap和常规文件操作的区别" class="headerlink" title="三、mmap和常规文件操作的区别"></a>三、mmap和常规文件操作的区别</h2><h3 id="3-1-页缓存-page-cache"><a href="#3-1-页缓存-page-cache" class="headerlink" title="3.1 页缓存(page cache)"></a>3.1 页缓存(page cache)</h3><blockquote><p>维基百科：<a href="https://en.wikipedia.org/wiki/Page_cache">Page cache</a></p></blockquote><p>在计算中，页面缓存(page cache)，有时也称为磁盘缓存(disk cache)，[1] 是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器 (HDD) 或固态驱动器 (SSD)）的页面。操作系统在主内存 (RAM) 的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p><p>通常，所有不直接分配给应用程序的物理内存都被操作系统用于页面缓存。出于充分利用内存不使其处于空闲状态，以及此类内存在应用程序请求时很容易回收，因此通常没有相关的性能损失。操作系统甚至可能将此类内存报告为“空闲(free)”或“可用(available)”。</p><p>与主存相比，硬盘驱动器的读/写速度很慢，随机访问需要昂贵的磁盘寻道；因此，随着更多数据可以缓存在内存中，大容量的主内存能带来明显的性能提升。 </p><ul><li>独立的磁盘缓存(Separate disk caching)由专用 RAM 或 NVRAM 芯片（位于磁盘控制器(<a href="https://en.wikipedia.org/wiki/Disk_controller">disk controller</a>)或磁盘阵列控制器(<a href="https://en.wikipedia.org/wiki/Disk_array_controller">disk array controller</a>)中。如果是前者，此时缓存被集成到硬盘驱动器中，通常称为磁盘缓冲区(disk buffer)）在硬件方面提供。此类内存不应与页面缓存(page cache)混淆了</li></ul><p>页缓存中被引入后修改的页称为脏页(dirty pages)。</p><h4 id="3-1-1-补充-—-文件系统、文件、磁盘"><a href="#3-1-1-补充-—-文件系统、文件、磁盘" class="headerlink" title="3.1.1 补充 — 文件系统、文件、磁盘"></a>3.1.1 补充 — 文件系统、文件、磁盘</h4><blockquote><p>文件系统：是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的哪个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p></blockquote><p>现代OS几乎都是通过文件系统来组织和管理在计算机中所存储的大量程序和数据的。<strong>文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现</strong>的。而<strong>文件则是指具有文件名的若干相关元素的集合</strong>。<strong>元素通常是记录，而记录是一组有意义的数据项的集合</strong>。可以把数据组成分为数据项、记录、文件。</p><ul><li><strong>数据项</strong>，数据项是最低级数据组织形式。分为基本数据项（用于描述一个对象某种属性的字符集，是数据组织中可以明明的最小逻辑数据单位，即原子数据，又称为数据元素或字段）和组合数据项（由若干个基本数据项组成）</li><li><strong>记录</strong>，是一组相关数据项的集合，用于描述一个对象在某方面的属性，为了能够唯一标识一个记录，需要在记录中确定一个或集合数据项，把他们的集合称为关键字，关键字是能够唯一标识一个记录的数据项。</li><li><strong>文件</strong>，文件是具有文件名的一组相关元素的集合。<ul><li>文件分为有结构文件和无结构文件。有结构文件由若干个相关记录组成，无结构文件则被看成一个字符流。</li><li>文件是文件系统的最大数据单位。</li><li>文件应该具有自己的属性，包括：<ul><li>文件类型：如源文件、目标文件、可执行文件等。</li><li>文件长度：文件的当前长度，也可能是最大允许长度。</li><li>文件的物理位置：指示文件在哪一个设备上及在该设备的哪个位置的指针。</li><li>文件的建立时间：文件最后一次修改时间。</li></ul></li></ul></li></ul><p>一个文件可对应若干个记录，一个记录可对应若干个数据项。</p><p>文件系统管理的对象有：</p><ul><li><strong>文件</strong>：作为文件管理的直接对象</li><li><strong>目录</strong>：为了方便用户对文件的存取和检索，在文件系统中配置目录，每个目录项中，必须含有文件名及该文件所在的物理地址，对目录的组织和管理是方便和提高对文件存取速度的关键。</li><li><strong>磁盘存储空间</strong>：文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul><h4 id="3-1-2-补充-—-字符设备文件和块设备文件"><a href="#3-1-2-补充-—-字符设备文件和块设备文件" class="headerlink" title="3.1.2 补充 — 字符设备文件和块设备文件"></a>3.1.2 补充 — 字符设备文件和块设备文件</h4><p>在Unix的/dev 目录下，有许多文件，其中有两个大类：字符设备文件和块设备文件。</p><ul><li>字符设备特殊文件进行I/O操作不经过操作系统的缓冲区，与外设进行I/O操作时每次只传输一个字符。</li><li>块设备特殊文件使用了cache机制，在外设和内存之间一次可以传送一整块数据(定长的包传输)。</li><li>裸设备是一种特殊类型的块设备文件，允许以直接访问硬盘的方式访问一个存储设备，而不经过操作系统的高速缓存和缓冲器（尽管可能仍旧使用硬件高速缓存）。应用程序如数据库管理系统可能直接使用裸设备，使它们能自行管理数据的缓存方式，而不将这些任务交给操作系统。</li></ul><p>裸设备少了操作系统这一层，I/O效率更高。不少数据库都能通过使用裸设备作为存储介质来提高I/O效率。</p><p>2021年6月10日，IT之家消息，RAW 设备正式退出了历史舞台。</p><h4 id="3-1-3-Buffer-Cache与Page-Cache（Linux）"><a href="#3-1-3-Buffer-Cache与Page-Cache（Linux）" class="headerlink" title="3.1.3 Buffer Cache与Page Cache（Linux）"></a>3.1.3 Buffer Cache与Page Cache（Linux）</h4><p>在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作（file sync，即文件同步），该操作会将文件关联的脏页(dirty page)数据(<strong>实际文件内容及元数据信息</strong>)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache，也叫页高速缓存)。</p><p>块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。它<strong>缓存部分磁盘数据</strong>，当有磁盘读取请求时，会首先查看块缓存中是否有对应的数据，如果有的话，则直接将对应数据返回，从而减少对磁盘的访问。</p><p>两层缓存各有自己的缓存目标，我好奇的是，这两者到底是什么关系？</p><p>两类缓存各自的作用：</p><ul><li><p>Page Cache</p><p>Page Cache以Page为单位，缓存文件内容。缓存在Page Cache中的文件数据，能够更快的被用户读取。同时对于带buffer的写入操作，数据在写入到Page Cache中即可立即返回，而不需等待数据被实际持久化到磁盘，进而提高了上层应用读写文件的整体性能。</p></li><li><p>Buffer Cache</p><p>磁盘的最小数据单位为sector，每次读写磁盘都是以sector为单位对磁盘进行操作。sector大小跟具体的磁盘类型有关，有的为512Byte， 有的为4K Bytes。无论用户是希望读取1个byte，还是10个byte，最终访问磁盘时，都必须以sector为单位读取，如果裸读磁盘，那意味着数据读取的效率会非常低。同样，如果用户希望向磁盘某个位置写入(更新)1个byte的数据，他也必须整个刷新一个sector，言下之意，则是在写入这1个byte之前，我们需要先将该1byte所在的磁盘sector数据全部读出来，在内存中，修改对应的这1个byte数据，然后再将整个修改后的sector数据，一口气写入磁盘。</p><p>为了降低这类低效访问，尽可能的提升磁盘访问性能，内核会在磁盘sector上构建一层缓存，它以sector的整数倍粒度为单位(block)，缓存部分sector数据在内存中，当有数据读取请求时，它能够直接从内存中将对应数据读出。当有数据写入时，它可以直接在内存中直接更新指定部分的数据，然后再通过异步方式，把更新后的数据写回到对应磁盘的sector中。</p><p>这层缓存则是块缓存Buffer Cache。</p></li></ul><p>虽然，目前Linux Kernel（linux-2.6.18）代码中，Page Cache和Buffer Cache实际上是统一的，无论是文件的Page Cache还是Block的Buffer Cache最终都统一到Page上。但是，在阅读较老代码时，我们能够看出，这两块缓存的实现，原本是完全分开的。是什么原因使得最终这两类缓存“走到了一起”？</p><h5 id="1-第一阶段：仅有Buffer-Cache"><a href="#1-第一阶段：仅有Buffer-Cache" class="headerlink" title="1.  第一阶段：仅有Buffer Cache"></a>1.  第一阶段：仅有Buffer Cache</h5><p>在Linux-0.11版本的代码中，我们会看到，buffer cache是完全独立的实现，甚至都还没有基于page作为内存单元，而是以原始指针的系形式出现。每一个block sector，在kernel内部对应一个独立的buffer cache单元，这个buffer cache单元通过buffer head来描述。</p><h5 id="2-第二阶段：Page-Cache、Buffer-Cache并存"><a href="#2-第二阶段：Page-Cache、Buffer-Cache并存" class="headerlink" title="2. 第二阶段：Page Cache、Buffer Cache并存"></a>2. 第二阶段：Page Cache、Buffer Cache并存</h5><p>到Linux-2.2版本时，磁盘文件访问的高速缓冲仍然是缓冲区高速缓冲(Buffer Cache)。其访问模式与上面Linux-0.11版本的访问逻辑基本类似。但此时，Buffer Cache已基于page来分配内存：</p><ul><li>buffer_head内部，已经有了关于所在page的一些信息：成员变量<code>struct buffer_head *b_this_page;</code></li><li>同时，从buffer cache的初始化，以及buffer cache不足时新建buffer cache单元的动作，我们也可以看出，此时buffer cache已经完全是基于page来分配内存。</li></ul><p>此时的buffer cache基于page来分配内存，但是与Page Cache完全独立，一点关系都没有。</p><p>在Linux-2.2版本中，Page Cache此时用来干什么的？</p><ul><li>用于文件的mmap</li><li>用于network-based filesytems</li></ul><p>此时，Page Cache和Buffer Cache的关系如下图所示：</p><img src="/images/OS/mmap/mmap-07.png" alt="mmap-07" style="zoom:80%;" /><p>Page Cache仅负责其中mmap部分的处理，而Buffer Cache实际上负责所有对磁盘的IO访问。从上面图中，我们也可看出其中一个问题：write绕过了Page Cache，这里导致了一个同步问题。当write发生时，有效数据是在Buffer Cache中，而不是在Page Cache中。这就导致mmap访问的文件数据可能存在不一致问题。</p><p>为了解决这个问题，所有基于磁盘文件系统的write，都需要调用 update_vm_cache() 函数，该操作会修改write相关Buffer Cache对应的Page Cache。从代码中我们可以看到，上述sysv_file_write中，在调用完copy_from_user之后，会调用update_vm_cache。</p><p>同样，正是这样Page Cache、Buffer Cache分离的设计，导致基于磁盘的文件，同一份数据，可能在Page Cache中有一份，而同时，却还在Buffer Cache中有一份。</p><h5 id="3-第三阶段：Page-Cache、Buffer-Cache融合"><a href="#3-第三阶段：Page-Cache、Buffer-Cache融合" class="headerlink" title="3. 第三阶段：Page Cache、Buffer Cache融合"></a>3. 第三阶段：Page Cache、Buffer Cache融合</h5><p>介于上述Page Cache、Buffer Cache分离设计的弊端，Linux-2.4版本中对Page Cache、Buffer Cache的实现进行了融合，融合后的Buffer Cache不再以独立的形式存在：</p><ul><li><p>Buffer Cache的内容，直接存在于Page Cache中，同时，保留了对Buffer Cache的描述符单元：buffer_head。</p><img src="/images/OS/mmap/mmap-08.png" alt="mmap-08" style="zoom:85%;" /></li><li><p>page结构中，通过buffers字段是否为空，来判定这个Page是否与一组Buffer Cache关联（在后续的演进过程中，这个判断，转变为由 private 字段来判定）。</p></li><li><p>而对应的，buffer_head则增加了字段 b_page ，直接指向对应的page。</p></li></ul><p>至此，两者的关系已经相互融合如下图所示：</p><img src="/images/OS/mmap/mmap-09.png" alt="mmap-09" style="zoom:85%;" /><p>将Page Cache与Buffer Cache(buffer_head)相互绑定。<strong>对上，在文件读写时，以page为单位进行处理。而对下，在数据向device进行刷新时，则可以以buffer_head(block)为单位进行处理。</strong></p><p>在后续的linux-2.5版本中，引入了bio结构来替换基于buffer_head的块设备IO操作。</p><p>注意：</p><ul><li><p>这里的Page Cache与Buffer Cache的融合，是针对文件这一层面的Page Cache与Buffer Cache的融合。</p></li><li><p>对于跨层的：File层面的Page Cache和裸设备Buffer Cache，虽然都统一到了基于Page的实现，但File的Page Cache和该文件对应的Block在裸设备层访问的Buffer Cache，这两个是完全独立的Page。</p><p>即：这种情况下，一个物理磁盘Block上的数据，仍然会对应Linux内核中的两份Page：一个是下图右侧，通过文件层访问的File的Page Cache(Page Cache)；一个是下图左侧，通过裸设备层访问的Page Cache(Buffer Cache)。</p><img src="/images/OS/mmap/mmap-10.png" alt="mmap-10" style="zoom:70%;" /></li></ul><h4 id="3-1-4-总结"><a href="#3-1-4-总结" class="headerlink" title="3.1.4 总结"></a>3.1.4 总结</h4><p>早期的Linux内核版本中，同时存在PageCache和BufferCache，由于这两种缓存处于半独立的状态，缺乏集成导致整体性能下降和缺乏灵活性。在内核版本2.4之后，对Page Cache、Buffer Cache的实现进行了融合。融合后的Buffer Cache不再以独立的形式存在，Buffer Cache的内容，直接存在于Page Cache中，同时，保留了对Buffer Cache的描述符单元：buffer_head。</p><p>简单说来，磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种Cache就是分别缓存逻辑和物理级数据的。<strong>page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。</strong></p><ul><li>在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</li><li>Cache(Page Cache)以页面形式缓存了文件系统的文件，给需要使用的程序读取，它是为了给读操作提供缓冲，避免频繁读硬盘，提高读取效率。</li><li>Buffer(Buffer Cache)以块形式缓冲了块设备的操作，定时或手动的同步到硬盘，它是为了缓冲写操作然后一次性将很多改动写入硬盘，避免频繁写硬盘，提高写入效率。</li></ul><h3 id="3-2-常规文件操作"><a href="#3-2-常规文件操作" class="headerlink" title="3.2 常规文件操作"></a>3.2 常规文件操作</h3><p>我们首先简单的回顾一下常规linux文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p><ol><li>进程发起读文件请求。</li><li>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</li><li>inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</li><li>如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</li></ol><p>总结来说，<strong>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。</strong>这样造成读文件时需要先<strong>将文件页从磁盘拷贝到页缓存中</strong>，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要<strong>将数据页从页缓存中再次拷贝到内存对应的用户空间中</strong>。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><img src="/images/OS/mmap/mmap-01.jpg" alt="mmap-01" style="zoom:85%;" /><h3 id="3-3-mmap映射操作文件"><a href="#3-3-mmap映射操作文件" class="headerlink" title="3.3 mmap映射操作文件"></a>3.3 mmap映射操作文件</h3><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p><strong>mmap内存映射的实现过程，总的来说可以分为三个阶段：</strong></p><ol><li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</li><li>调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</li><li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</li></ol><img src="/images/OS/mmap/mmap-02.jpg" style="zoom:85%;" /><p><font color='red'><strong>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong></font>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p><h2 id="四、mmap优点总结"><a href="#四、mmap优点总结" class="headerlink" title="四、mmap优点总结"></a>四、mmap优点总结</h2><p>由上文讨论可知，mmap优点共有一下几点：</p><ul><li><p>对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p></li><li><p>实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p></li><li><p>提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><p>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p></li><li><p>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。<strong>换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</strong></p></li></ul><h2 id="五、mmap使用细节"><a href="#五、mmap使用细节" class="headerlink" title="五、mmap使用细节"></a>五、mmap使用细节</h2><h3 id="5-1-注意点"><a href="#5-1-注意点" class="headerlink" title="5.1 注意点"></a>5.1 注意点</h3><p>1、使用mmap需要注意的一个关键点是，<strong>mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）</strong>。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><p>2、<strong>内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。</strong>也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见“情形三”。</p><p>3、<strong>映射建立之后，即使文件关闭，映射依然存在。</strong>因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p><h3 id="5-2-示例：文件大小、映射大小"><a href="#5-2-示例：文件大小、映射大小" class="headerlink" title="5.2 示例：文件大小、映射大小"></a>5.2 示例：文件大小、映射大小</h3><p>在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：</p><p><strong>情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。</strong></p><p>分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：</p><img src="/images/OS/mmap/mmap-04.png" alt="mmap-04" style="zoom:70%;" /><p>此时：</p><p>（1）读/写前5000个字节（0~4999），会返回操作文件内容。</p><p>（2）读字节5000~8191时，结果全为0。写5000~8191时，进程不会报错，但是所写的内容不会写入原文件中 。</p><p>（3）读/写8192以外的磁盘部分，会返回一个SIGSECV错误。</p><p><strong>情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。</strong></p><p>分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：</p><img src="/images/OS/mmap/mmap-05.png" alt="mmap-05" style="zoom:80%;" /><p>此时：</p><p>（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。</p><p>（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。</p><p>（3）对于8192~14999字节，进程不能对其进行读写，会报SIGBUS错误。</p><p>（4）对于15000以外的字节，进程不能对其读写，会引发SIGSEGV错误。</p><p><strong>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。</strong></p><p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。</p><p>但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。</p><p>这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。</p><p>增加文件的大小，可以使用<code>ftruncate</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将path指定的文件、由fd引用的常规文件截断为精确长度字节的大小。</span></span><br><span class="line"><span class="comment"> *    如果文件以前大于此大小，则多余的数据将丢失。</span></span><br><span class="line"><span class="comment"> *    如果文件先前较短，则将其扩展，扩展部分读取为空字节 (&#x27;\0&#x27;)。</span></span><br><span class="line"><span class="comment"> * 文件偏移量没有改变。</span></span><br><span class="line"><span class="comment"> * 如果大小发生变化，则更新文件的 st_ctime 和 st_mtime 字段（分别为上次状态更改的时间和上次修改的时间），以及set-user-ID 和 set-group-ID权限位可以被清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>; <span class="comment">// 文件必须是可写的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;  <span class="comment">// 文件必须打开才能写入</span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">increaseFileLength</span>(<span class="params">length</span>: size_t)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel map first</span></span><br><span class="line"><span class="keyword">self</span>.munmap()</span><br><span class="line"></span><br><span class="line"><span class="comment">// change file length</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> ftruncate(fileDescriptor, fileLength <span class="operator">+</span> off_t(length))</span><br><span class="line"><span class="keyword">if</span> result <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;can&#x27;t truncate data file&quot;</span>)</span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remap</span></span><br><span class="line">fileLength <span class="operator">=</span> lseek(fileDescriptor, <span class="number">0</span>, <span class="type">SEEK_END</span>)</span><br><span class="line"><span class="keyword">self</span>.mmap()</span><br><span class="line"></span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、使用场景"><a href="#六、使用场景" class="headerlink" title="六、使用场景"></a>六、使用场景</h2><blockquote><p>这一部分来自苹果官方开发文档<a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html">Mapping Files Into Memory</a></p></blockquote><p>尽管映射文件可以提供巨大的性能优势，但并不适用于所有情况。</p><p>文件映射的目标是减少磁盘和内存之间的传输。在某些情况下，文件映射可以帮助您，但不是全部。<strong>映射到内存中的文件越多，文件映射的用处就越少</strong>。</p><p>在将任何文件映射到内存之前，请确保您了解典型的文件使用模式。使用工具来帮助您确定应用程序访问文件的位置以及这些操作需要多长时间。</p><h3 id="6-1-适合的场景"><a href="#6-1-适合的场景" class="headerlink" title="6.1 适合的场景"></a>6.1 适合的场景</h3><ul><li>您有一个很大的文件，希望随机访问其内容一次或多次。</li><li>您有一个小文件，您想一次将其内容全部读入内存并经常访问。这种技术最适用于大小不超过几个虚拟内存页的文件。（页是地址空间的最小单位，虚拟页和物理页的大小是一样的，通常为4KB。）</li><li>您想在内存中缓存文件的特定部分。文件映射完全消除了缓存数据的需要，从而在系统磁盘缓存中为其他数据留出了更多空间。</li></ul><p>当随机访问一个非常大的文件时，最好是一次只映射文件的一小部分。映射大文件的问题是文件消耗活动内存。如果文件足够大，系统可能会被迫调出内存的其他部分来加载文件。将多个文件映射到内存中会加剧这个问题。</p><h3 id="6-2-不适合的场景"><a href="#6-2-不适合的场景" class="headerlink" title="6.2 不适合的场景"></a>6.2 不适合的场景</h3><p>在以下情况下不要使用文件映射：</p><ul><li>您只想从头到尾按顺序读取文件一次。</li><li>该文件的大小为数百兆字节或更大。将大文件映射到内存中会很快填满内存，并可能导致分页，这首先抵消了映射文件的好处。<strong>对于大型顺序读取操作，你应该禁用磁盘缓存(disk cache/page cache)并将文件读入一个小的内存缓冲区。</strong></li><li>该文件大于可用的连续虚拟内存地址空间。这对于 64 位应用程序来说不是问题，但对于 32 位应用程序来说可能是一个问题。</li><li>该文件位于可移动驱动器上。</li><li>该文件位于网络驱动器上。</li></ul><p>如果您在可移动驱动器或网络驱动器上映射文件，并且该驱动器被卸载或由于其他原因消失，则访问映射内存可能会导致总线错误并使您的程序崩溃。</p><h2 id="七、iOS-中的-mmap"><a href="#七、iOS-中的-mmap" class="headerlink" title="七、iOS 中的 mmap"></a>七、iOS 中的 mmap</h2><h3 id="7-1-性能测试用例"><a href="#7-1-性能测试用例" class="headerlink" title="7.1 性能测试用例"></a>7.1 性能测试用例</h3><p>下面这个程序，通过read和mmap两种方法分别对硬盘上一个名为“mmap_test”的文件进行操作，文件中存有10000个整数，程序两次使用不同的方法将它们读出，加1，再写回硬盘。通过对比可以看出，read消耗的时间将近是mmap的两到三倍。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv1</span>, <span class="title">tv2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*read*/</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;mmap_test&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX != read(fd, (<span class="keyword">void</span> *)<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Reading data failed.../n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line">        ++<span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX != write(fd, (<span class="keyword">void</span> *)<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Writing data failed.../n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    gettimeofday(&amp;tv2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time of read/write: %dms/n&quot;</span>, tv2.tv_usec - tv1.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*mmap*/</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;mmap_test&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">array</span> = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line">        ++<span class="built_in">array</span>[i];</span><br><span class="line">        </span><br><span class="line">    munmap(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX);</span><br><span class="line">    msync(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX, MS_SYNC);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    gettimeofday(&amp;tv2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time of mmap: %dms/n&quot;</span>, tv2.tv_usec - tv1.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time of read&#x2F;write: 154ms</span><br><span class="line">Time of mmap: 68ms</span><br></pre></td></tr></table></figure><h3 id="7-2-自实现Demo"><a href="#7-2-自实现Demo" class="headerlink" title="7.2 自实现Demo"></a>7.2 自实现Demo</h3><p>用<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/FileSystem/Articles/MappingFiles.html">官方文档 — Mapping Files Into Memory</a>的代码做参考，实现一个读写的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName, <span class="keyword">void</span> ** outDataPtr, <span class="keyword">size_t</span> * outDataLength, <span class="keyword">size_t</span> appendSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> outError;</span><br><span class="line">    <span class="keyword">int</span> fileDescriptor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statInfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return safe values on error.</span></span><br><span class="line">    outError = <span class="number">0</span>;</span><br><span class="line">    *outDataPtr = <span class="literal">NULL</span>;</span><br><span class="line">    *outDataLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the file.</span></span><br><span class="line">    fileDescriptor = open( inPathName, O_RDWR, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>(fileDescriptor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        outError = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We now know the file exists. Retrieve the file size.</span></span><br><span class="line">        <span class="keyword">if</span>( fstat( fileDescriptor, &amp;statInfo ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            outError = errno;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ftruncate(fileDescriptor, statInfo.st_size + appendSize);</span><br><span class="line">            fsync(fileDescriptor);</span><br><span class="line">            *outDataPtr = mmap(<span class="literal">NULL</span>,</span><br><span class="line">                               statInfo.st_size + appendSize,</span><br><span class="line">                               PROT_READ|PROT_WRITE,</span><br><span class="line">                               MAP_FILE|MAP_SHARED,</span><br><span class="line">                               fileDescriptor,</span><br><span class="line">                               <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>( *outDataPtr == MAP_FAILED ) &#123;</span><br><span class="line">                outError = errno;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// On success, return the size of the mapped file.</span></span><br><span class="line">                *outDataLength = statInfo.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now close the file. The kernel doesn’t use our file descriptor.</span></span><br><span class="line">        close( fileDescriptor );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> dataLength;</span><br><span class="line">    <span class="keyword">void</span> * dataPtr;</span><br><span class="line">    <span class="keyword">char</span> *appendStr = <span class="string">&quot; append_key&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> appendSize = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(appendStr);</span><br><span class="line">    <span class="keyword">if</span>( MapFile(inPathName, &amp;dataPtr, &amp;dataLength, appendSize) == <span class="number">0</span>) &#123;</span><br><span class="line">        dataPtr = dataPtr + dataLength;</span><br><span class="line">        <span class="built_in">memcpy</span>(dataPtr, appendStr, appendSize);</span><br><span class="line">        <span class="comment">// Unmap files</span></span><br><span class="line">        munmap(dataPtr, appendSize + dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="function">interface <span class="title">ViewController</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSString * path = [NSHomeDirectory() stringByAppendingPathComponent:@<span class="string">&quot;test.data&quot;</span>];</span><br><span class="line">    NSLog(@<span class="string">&quot;path: %@&quot;</span>, path);</span><br><span class="line">    NSString *str = @<span class="string">&quot;test str&quot;</span>;</span><br><span class="line">    [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line"></span><br><span class="line">    ProcessFile(path.UTF8String);</span><br><span class="line">    NSString *result = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">    NSLog(@<span class="string">&quot;result:%@&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-MMKV-和-mmap"><a href="#7-3-MMKV-和-mmap" class="headerlink" title="7.3 MMKV 和 mmap"></a>7.3 MMKV 和 mmap</h3><h4 id="7-3-1-MMKV-简介"><a href="#7-3-1-MMKV-简介" class="headerlink" title="7.3.1 MMKV 简介"></a>7.3.1 MMKV 简介</h4><ul><li>NSUserDefault 是常见的缓存工具，但是数据有时会同步不及时，比如说在 crash 前保存的值很容易出现保存失败的情况，在 App 重新启动之后读取不到保存的值。</li><li>MMKV 很好的解决了 NSUserDefault 的局限，但是同样由于其独特设计，在数据量较大、操作频繁的场景下，会产生性能问题。这里的使用给出两个建议：<ul><li>不要全部用 defaultMMKV，根据业务大的类型做聚合，避免某一个 MMKV 数据过大，特别是对于某些只会出现一次的新手引导、红点之类的逻辑，尽可能按业务聚合，使用多个 MMKV 的对象；</li><li>对于需要频繁读写的数据，可以在内存持有一份数据缓存，必要时再更新到 MMKV。</li></ul></li></ul><h4 id="7-3-2-MMKV-原理"><a href="#7-3-2-MMKV-原理" class="headerlink" title="7.3.2 MMKV 原理"></a>7.3.2 MMKV 原理</h4><h5 id="1-内存准备"><a href="#1-内存准备" class="headerlink" title="1. 内存准备"></a>1. 内存准备</h5><p>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由 iOS 负责将内存回写到文件，不必担心 crash 导致数据丢失。</p><h5 id="2-数据组织"><a href="#2-数据组织" class="headerlink" title="2. 数据组织"></a>2. 数据组织</h5><p>数据序列化方面选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</p><p>考虑到要提供的是通用 KV 组件，key 可以限定是 string 字符串类型，value 则多种多样（int/bool/double 等）。要做到通用的话，考虑<strong>将 value 通过 protobuf 协议序列化成统一的内存块（buffer），然后就可以将这些 KV 对象序列化到内存中。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message KV &#123;</span><br><span class="line">  string key = <span class="number">1</span> ;</span><br><span class="line">  buffer value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setInt32:(int32 t)value forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">  auto data = PBEncode(value); </span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> setData:data forKey:key];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setData: (<span class="built_in">NSData</span>*)data forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">  auto kv = KV[key,data];</span><br><span class="line">  auto buf = PBEncode(kv);</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> write: buf];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-写入优化"><a href="#3-写入优化" class="headerlink" title="3. 写入优化"></a>3. 写入优化</h5><p>标准 protobuf 不提供增量更新的能力，每次写入都必须全量写入。考虑到主要使用场景是频繁地进行写入更新，我们需要有<strong>增量更新的能力：将增量 kv 对象序列化后，直接 append 到内存末尾。</strong>这样同一个 key 会有新旧若干份数据，最新的数据在最后。那么只需在程序启动第一次打开 mmkv 时，不断用后读入的 value 替换之前的值，就可以保证数据是最新有效的。</p><h5 id="4-空间增长"><a href="#4-空间增长" class="headerlink" title="4. 空间增长"></a>4. 空间增长</h5><p>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。</p><p>例如同一个 key 不断更新的话，是可能耗尽几百 M 甚至上 G 空间，而事实上整个 KV 文件就这一个 key，不到 1k 空间就存得下，这明显是不可取的。</p><p>我们需要在性能和空间上做个折中：</p><p><strong>以内存 pagesize 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整、key 排重，尝试序列化保存排重结果；排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)append: (<span class="built_in">NSData</span>*)data &#123;</span><br><span class="line">  <span class="keyword">if</span> (space &gt;= data.length) &#123;</span><br><span class="line">    append(fd, data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newData = unique(m_allKV);</span><br><span class="line">    <span class="keyword">if</span> (total_space &gt;= newData.length) &#123;</span><br><span class="line">      write(fd, newData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (total_space &lt; newData.length) &#123;</span><br><span class="line">        total_ space *= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ftruncate(fd, total . space);</span><br><span class="line">      write(fd, newData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数据有效性"><a href="#5-数据有效性" class="headerlink" title="5. 数据有效性"></a>5. 数据有效性</h5><p>考虑到文件系统、操作系统都有一定的不稳定性，另外增加了 crc 校验，对无效数据进行甄别。</p><h5 id="6-MMKV-性能"><a href="#6-MMKV-性能" class="headerlink" title="6. MMKV 性能"></a>6. MMKV 性能</h5><p>写个简单的测试，将 MMKV、NSUserDefaults 的性能进行对比（循环写入1w 次数据，测试环境：iPhone X 256G, iOS 11.2.6，单位：ms）：</p><img src="/images/OS/mmap/mmap-06.jpg" alt="mmap-06" style="zoom:75%;" /><p>可见 MMKV 性能远远优于 iOS 自带的 NSUserDefaults。另外，在测试中发现，NSUserDefaults 在每 2-3 次测试，就会有 1 次比较耗时的操作，怀疑是触发了数据 synchronize 重整写入。对比之下，MMKV 即使触发数据重整，也保持了性能的稳定高效。</p><h3 id="7-4-NSData-与-mmap"><a href="#7-4-NSData-与-mmap" class="headerlink" title="7.4 NSData 与 mmap"></a>7.4 NSData 与 mmap</h3><p>NSData 有一个静态方法和 mmap 有关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (id)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSDataReadingOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint to map the file in if possible and safe. 在保证安全的前提下使用 mmap</span></span><br><span class="line">    NSDataReadingMappedIfSafe =   <span class="number">1UL</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// Hint to get the file not to be cached in the kernel. 不要缓存。如果该文件只会读取一次，这个设置可以提高性能</span></span><br><span class="line">    NSDataReadingUncached = <span class="number">1UL</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// Hint to map the file in if possible. This takes precedence over NSDataReadingMappedIfSafe if both are given.  总使用 mmap</span></span><br><span class="line">    NSDataReadingMappedAlways API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">1UL</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Mapped 的意思是使用 mmap，那么 ifSafe 是什么意思呢？NSDataReadingMappedIfSafe 和 NSDataReadingMappedAlways 有什么区别？</li><li>如果使用 mmap，则在 NSData 的生命周期内，都不能删除对应的文件。</li><li>如果文件是在固定磁盘，非可移动磁盘、网络磁盘，则满足 NSDataReadingMappedIfSafe。对 iOS 而言，这个 NSDataReadingMappedIfSafe = NSDataReadingMappedAlways。</li><li>那什么情况下应该用对应的参数？<ul><li>如果文件很大，直接使用 dataWithContentsOfFile 方法，会导致 load 整个文件，出现内存占用过多的情况；此时用 NSDataReadingMappedIfSafe，则会使用 mmap 建立文件映射，减少内存的占用。</li><li>使用场景：视频加载。视频文件通常比较大，但是使用的过程中不会同时读取整个视频文件的内容，可以使用 mmap 优化。</li></ul></li></ul><h3 id="7-5-FastImageCache"><a href="#7-5-FastImageCache" class="headerlink" title="7.5 FastImageCache"></a>7.5 FastImageCache</h3><p><a href="https://github.com/path/FastImageCache">FastImageCache</a>是Path团队开发的一个开源库，提供了一种在 iOS 应用程序中存储和检索图像的高效、持久且最重要的快速方法。</p><p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤：</p><ol><li><p>从磁盘拷贝数据到内核缓冲区</p></li><li><p>从内核缓冲区复制数据到用户空间</p></li><li><p>生成UIImageView，把图像数据赋值给UIImageView</p></li><li><p>如果图像数据为未解码的PNG/JPG，解码为位图数据</p></li><li><p>CATransaction捕获到UIImageView layer树的变化</p></li><li><p>主线程Runloop提交CATransaction，开始进行图像渲染</p><p>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。</p><p>6.2 GPU处理位图数据，进行渲染。</p></li></ol><p>FastImageCache分别优化了2、4、6.1三个步骤：</p><ol><li>使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。</li><li>缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。</li></ol><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><a href="https://blog.csdn.net/jinking01/article/details/107480248">Linux内核Page Cache和Buffer Cache关系及演化历史</a></li><li><a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用 </a></li><li><a href="https://blog.csdn.net/joejames/article/details/37958017">linux内存映射mmap原理分析</a></li><li><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html">Apple Developer — Mapping Files Into Memory</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tenloy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>AVFoundation Programming Guide(译)</title>
    <link href="https://tenloy.github.io/2022/03/18/avfoundation.html"/>
    <id>https://tenloy.github.io/2022/03/18/avfoundation.html</id>
    <published>2022-03-18T16:54:19.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVFoundation概述"><a href="#AVFoundation概述" class="headerlink" title="AVFoundation概述"></a>AVFoundation概述</h1><blockquote><p>译文，原文链接：<a href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/AVFoundationPG/RevisionHistory.html#//apple_ref/doc/uid/TP40010188-CH99-SW1">AVFoundation Programming Guide</a>.（不完全一致。内容结构有调整，增加了一些类的定义源码）</p></blockquote><p>AVFoundation 是一个媒体框架，它提供的接口：</p><ul><li>可以精确地处理基于时间的音视频媒体数据，比如媒体文件的查找、创建、编辑、二次编码。</li><li>可以从设备获取输入流并在实时捕获和播放期间操作视频。</li></ul><p>iOS 上的架构：</p><img src="/images/avf/frameworksBlockDiagram_2x.png" alt="img" style="zoom:70%;" /><p> OS X 上相应的媒体架构：</p><img src="/images/avf/frameworksBlockDiagramOSX_2x.png" alt="img" style="zoom:70%;" /><p>AVFoundation 框架包含视频API 和音频API 两方面。较早的与音频相关的类提供了处理音频的简单方法：</p><ul><li>播放声音文件，可以使用 AVAudioPlayer。</li><li>录制音频，可以使用 AVAudioRecorder。</li><li>使用 AVAudioSession 配置应用程序的音频行为。</li></ul><p>在完成具体的开发任务时，你应该尽可能的选择更高层次的抽象框架。</p><ul><li>如果只需要播放视频，可以使用 AVKit 框架</li><li>如果需要在 iOS 设备上录制视频，而且并不关心更具体的录制参数，可以使用 UIKit 中 UIImagePickerController 类。</li></ul><p>需要注意的是，在 AVFoundation 框架中使用的一些原始数据结构 (包括时间相关的数据结构和存储描述媒体数据的底层对象)，都在 Core Media 框架中声明。</p><h1 id="一、使用Assets"><a href="#一、使用Assets" class="headerlink" title="一、使用Assets"></a>一、使用Assets</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Asset 资产;财产;有价值的人(或事物);有用的人(或事物);</p><ul><li><p>现实中，更多的指资产、财产</p></li><li><p>编程中，可以理解为资源，图像、音频、视频等，与resource相近(Android中两者所表示的文件在编译处理上大有不同，不展开讲了)。以下出现的资产、资源都是指asset的中文翻译</p></li></ul></blockquote><p>AVFoundation 框架中表示媒体的主要类 — AVAsset。 <code>AVAsset</code> 表示基于时间的视听数据，比如电影文件或视频流。<code>AVAsset</code> 的结构决定了 AV Foundation 框架大部分的工作方式。</p><ul><li>AVAsset 实例是一个或多个媒体数据（音频和视频轨道）的集合的聚合表示。它提供有关整个集合的信息，例如其标题、持续时间、自然呈现大小等。<ul><li>AVAsset也可能有元数据</li></ul></li><li>AVAsset 是一个抽象类，可以使用它的子类来：<ul><li>从 URL 创建一个 asset 对象</li><li>根据已有的媒体资源合成出一个新的媒体资源。</li></ul></li><li>AVAsset 不依赖于特定的数据格式。</li><li>AVAsset 中的每条独立的媒体数据都有一个统一类的型，称为轨道(track)。<ul><li>在一个典型的简单情况下，一个轨道代表音频分量，另一个轨道代表视频分量；</li><li>然而，在复杂的合成中，可能有多个重叠的音频和视频轨道。</li></ul></li></ul><p>拥有一个电影资产后，可以从中提取静止图像、将其转码为另一种格式或修剪内容。</p><h2 id="1-1-资产与轨道-AVAsset与AVAssetTrack"><a href="#1-1-资产与轨道-AVAsset与AVAssetTrack" class="headerlink" title="1.1 资产与轨道(AVAsset与AVAssetTrack)"></a>1.1 资产与轨道(AVAsset与AVAssetTrack)</h2><h3 id="1-1-1-AVAsset类结构"><a href="#1-1-1-AVAsset类结构" class="headerlink" title="1.1.1 AVAsset类结构"></a>1.1.1 AVAsset类结构</h3><p>AVAsset 是 AV Foundation 框架的核心关键类，它提供了对视听数据(如电影、视频流)的<strong>格式无关的抽象</strong>。</p><p>类之间的关系如下图所示。大部分情况下，使用的都是这些类的子类：</p><ul><li>使用 AVComposition 子类创建新的 asset</li><li>使用 AVURLAsset 子类根据一个指定的 URL（包括来自MPMedia、AssetLibrary框架的asset(iPod库/相册)）创建 asset</li></ul><img src="/images/avf/avassetHierarchy_2x.png" alt="img" style="zoom:70%;" /><p>一个 asset 包含：</p><ul><li>一组 track，每个 track 都有特定媒体类型，包括但不限于 audio，video，text，closed captions 以及 subtitles。</li><li>整个资源的信息，比如时长和标题。</li><li>Asset 对象也可能包含元数据 (metadata)，metadata 由 <a href="https://developer.apple.com/reference/avfoundation/avmetadataitem">AVMetadataItem</a> 类表示。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">AVAsynchronousKeyValueLoading</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredRate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredVolume;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGAffineTransform</span> preferredTransform;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> naturalSize API_DEPRECATED(<span class="string">&quot;Use the naturalSize and preferredTransform, as appropriate, of the receiver&#x27;s video tracks. See -tracksWithMediaType:&quot;</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVDisplayCriteria</span> *preferredDisplayCriteria;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> minimumTimeOffsetFromLive;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 异步加载 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetAsynchronousLoading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> providesPreciseDurationAndTiming;</span><br><span class="line">- (<span class="keyword">void</span>)cancelLoading;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用限制 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetReferenceRestrictions</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetReferenceRestrictions</span> referenceRestrictions;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetTrackInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *tracks;</span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrackGroup</span> *&gt; *trackGroups;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMetadataReading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMetadataItem</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lyrics;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *commonMetadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataFormat</span>&gt; *availableMetadataFormats;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *)metadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format;</span><br><span class="line">- (<span class="keyword">void</span>)loadMetadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 章节检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetChapterInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSLocale</span> *&gt; *availableChapterLocales;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 媒体 选择 选项 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMediaSelection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaCharacteristic</span>&gt; *availableMediaCharacteristicsWithMediaSelectionOptions;</span><br><span class="line">- (<span class="built_in">AVMediaSelectionGroup</span> *)mediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadMediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMediaSelectionGroup</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaSelection</span> *preferredMediaSelection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">AVMediaSelection</span> *&gt; *allMediaSelections;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetProtectedContent</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasProtectedContent;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetFragments</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canContainFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> containsFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> overallDurationHint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetUsability</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exportable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> composable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithSavedPhotosAlbum;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithAirPlayVideo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-轨道-Track"><a href="#1-1-2-轨道-Track" class="headerlink" title="1.1.2 轨道(Track)"></a>1.1.2 轨道(Track)</h3><p>如下图所示，一个 track 由 AVAssetTrack 类表示。简单场景下，一个 track 代表 audio component，另一个 track 代表 video component；复杂场景下，可能有多个 audio 和 video 重叠的 track。</p><img src="/images/avf/avassetAndTracks_2x.png" alt="img" style="zoom:70%;" /><p>一个 track 包含多个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 包含此轨道的asset对象  */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">weak</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基本性质和特点 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackBasicPropertiesAndCharacteristics</span>)</span></span><br><span class="line"><span class="comment">// 类型 (video or audio)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// track 包含一个描述格式的数组。这个数组中的元素为 CMFormatDescription 对象，用来描述 track 包含的媒体的格式信息。</span></span><br><span class="line">  <span class="comment">// track通常呈现统一的媒体（例如，使用相同编码设置编码的媒体），此时是包含单一格式的描述。</span></span><br><span class="line">  <span class="comment">// 但是，在某些情况下，track可能包含多种格式描述。例如，一个 H.264 编码的视频轨道可能有一些片段使用 Main profile 编码，而其他片段使用 High profile 编码。</span></span><br><span class="line">  <span class="comment">// 此外，作为 AVAssetTrack 的子类的单个 AVCompositionTrack 可能包含使用不同编解码器的音频或视频片段。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *formatDescriptions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> decodable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> selfContained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">long</span> <span class="keyword">long</span> totalSampleDataLength;</span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTemporalProperties</span>)</span></span><br><span class="line"><span class="comment">//该轨道在assett整体时间线内的时间范围</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 语言属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackLanguageProperties</span>) </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 视觉特征的属性.如画面大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForVisualCharacteristic</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 听觉特性的属性.如音量大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForAudibleCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于帧特性的属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForFrameBasedCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 片段。一个 track 可能被分为几段，每一段由一个 AVAssetTrackSegment 对象表示，该对象就是一个由资源数据到 track 时间轴的映射。 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSegments</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackMetadataReading</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track的关联 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTrackAssociations</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样本光标 AVSampleCursor实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSampleCursorProvision</span>)</span></span><br></pre></td></tr></table></figure><h2 id="1-2-创建AVURLAsset"><a href="#1-2-创建AVURLAsset" class="headerlink" title="1.2 创建AVURLAsset"></a>1.2 创建AVURLAsset</h2><h3 id="1-2-1-类源码"><a href="#1-2-1-类源码" class="headerlink" title="1.2.1 类源码"></a>1.2.1 类源码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> : <span class="title">AVAsset</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)audiovisualTypes;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)audiovisualMIMETypes;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isPlayableExtendedMIMEType: (<span class="built_in">NSString</span> *)extendedMIMEType;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)URLAssetWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetURLHandling</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetResourceLoader</span> *resourceLoader;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetCache</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetCache</span> *assetCache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetCompositionUtility</span> )</span></span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)compatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack;</span><br><span class="line">- (<span class="keyword">void</span>)findCompatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler API_AVAILABLE(macos(<span class="number">12.0</span>), ios(<span class="number">15.0</span>), tvos(<span class="number">15.0</span>), watchos(<span class="number">8.0</span>));</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetVariantInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetVariant</span> *&gt; *variants;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-创建一个AVURLAsset对象"><a href="#1-2-2-创建一个AVURLAsset对象" class="headerlink" title="1.2.2 创建一个AVURLAsset对象"></a>1.2.2 创建一个AVURLAsset对象</h3><p>AVURLAsset代表任何一个能用URL识别的资源的asset。最简单的是从一个file创建asset。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#<span class="string">&quot;标识视听资产（如电影文件）的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>初始化的第二个参数options是一个字典。</p><p>字典中唯一使用的key是AVURLAssetPreferPreciseDurationAndTimingKey。对应的值是一个布尔值（包含在 NSValue对象中），这个布尔值指出了这个asset是否应该提供准确的duration，以及支持随机读取指定时间的内容。</p><p>获得一个asset 精确的的持续时间duration可能需要大量的处理开销。使用一个近似的持续时间通常是更划算的选择，并且对于播放已经足够。因此：</p><ul><li>如果只是播放asset，options传递nil，或者字典里对应的值是NO(包含在NSValue对象中)</li><li>如果要将asset添加到composition，需要精确的随机存取，传递一个字典，对应值是YES(包含在NSValue对象中)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span> : @YES&#125;; </span><br><span class="line"><span class="built_in">AVURLAsset</span> *asset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:fileUrl options:dict];</span><br></pre></td></tr></table></figure><h3 id="1-2-3-访问用户的asset-iPod库-相册"><a href="#1-2-3-访问用户的asset-iPod库-相册" class="headerlink" title="1.2.3 访问用户的asset(iPod库+相册)"></a>1.2.3 访问用户的asset(iPod库+相册)</h3><p>要访问由 iPod 库、相册中的资产，需要获取对应资产的 URL。</p><ul><li>访问 iPod 库，需要创建一个 MPMediaQuery 实例来查找想要的项目，然后使用 <strong>MPMediaItemPropertyAssetURL</strong> 获取其 URL。</li><li>访问照片应用程序管理的资产，使用 <strong>ALAssetsLibrary</strong> —— iOS9.0之后这个库失效，使用PHPhotoLibrary库</li></ul><p>下面的是获取用户相册中第一个视频的示例代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span></span><br><span class="line">[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Within the group enumeration block, filter to enumerate just videos.</span></span><br><span class="line">[group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// For this example, we&#x27;re only interested in the first item.</span></span><br><span class="line">[group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>]</span><br><span class="line">                        options:<span class="number">0</span></span><br><span class="line">                     usingBlock:^(ALAsset *alAsset, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *innerStop) &#123;</span><br><span class="line"> </span><br><span class="line">                         <span class="comment">// The end of the enumeration is signaled by asset == nil.</span></span><br><span class="line">                         <span class="keyword">if</span> (alAsset) &#123;</span><br><span class="line">                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];</span><br><span class="line">                             <span class="built_in">NSURL</span> *url = [representation url];</span><br><span class="line">                             <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line">                             <span class="comment">// Do something interesting with the AV asset.</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;];</span><br><span class="line">                 &#125;</span><br><span class="line">                 failureBlock: ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                     <span class="comment">// Typically you should handle an error more gracefully than this.</span></span><br><span class="line">                     <span class="built_in">NSLog</span>(<span class="string">@&quot;No groups&quot;</span>);</span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure><h2 id="1-3-使用Asset"><a href="#1-3-使用Asset" class="headerlink" title="1.3 使用Asset"></a>1.3 使用Asset</h2><p>注意：<strong>初始化asset或track并不一定意味着它已准备好使用。</strong>可能需要一些时间去计算项目的持续时间(duration)（例如，MP3 文件可能不包含摘要信息）。计算时不要阻塞当前线程，可以使用 AVAsynchronousKeyValueLoading 协议来请求值，完成处理后通过定义的block回调结果（AVAsset 和 AVAssetTrack 符合 AVAsynchronousKeyValueLoading 协议）。</p><p>可以使用 <code>statusOfValueForKey:error:</code> 判断是否为属性加载了值。asset首次加载时，其大部分或全部属性的值为 AVKeyValueStatusUnknown。</p><p>可以使用 <code>loadValuesAsynchronouslyForKeys:completionHandler:</code> 为一个或多个属性加载值。在完成处理程序中，可以根据属性的状态采取任何适当的操作。注意：加载是可能会失败的，比如基于网络的 URL 不可访问，或者加载被取消。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *keys = @[<span class="string">@&quot;duration&quot;</span>]; <span class="comment">// 如果准备一个asset去播放，应该加载它的 tracks 属性</span></span><br><span class="line"> </span><br><span class="line">[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> tracksStatus = [asset statusOfValueForKey:<span class="string">@&quot;duration&quot;</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">switch</span> (tracksStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</span><br><span class="line">            [<span class="keyword">self</span> updateUserInterfaceForDuration];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</span><br><span class="line">            [<span class="keyword">self</span> reportError:error forAsset:asset];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</span><br><span class="line">            <span class="comment">// Do whatever is appropriate for cancelation.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="1-4-视频中获取静态图像-AssetImageGenerator"><a href="#1-4-视频中获取静态图像-AssetImageGenerator" class="headerlink" title="1.4 视频中获取静态图像(AssetImageGenerator)"></a>1.4 视频中获取静态图像(AssetImageGenerator)</h2><p>从视频中获取静态图片 (比如某个时间点的视频预览缩略图)，可以使用 AVAssetImageGenerator。</p><p>使用asset初始化一个图像生成器对象。注意即使asset在初始化时没有视觉轨道，初始化也可能成功，所以如果有必要，应该使用 trackWithMediaCharacteristic: 提前判断一下asset是否用于可视化的track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> anAsset = &lt;#Get an asset#&gt;; <span class="comment">// 使用要生成缩略图的asset来初始化</span></span><br><span class="line"><span class="keyword">if</span> ([[anAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:anAsset];</span><br><span class="line">    <span class="comment">// Image Generator使用默认启用的视频轨道来生成图像</span></span><br><span class="line">    <span class="comment">// Implementation continues...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以配置图像生成器的几个方面，比如：</p><ul><li>使用 maximumSize 属性设置图片的最大尺寸</li><li>使用 apertureMode 属性设置图片的光栅模式</li><li>根据给定的时间点生成单张或者一系列的图片</li></ul><p>注意：生成过程中必须确保 imagegenerator 的强引用。</p><h3 id="1-4-1-生成单个图像"><a href="#1-4-1-生成单个图像" class="headerlink" title="1.4.1 生成单个图像"></a>1.4.1 生成单个图像</h3><p>使用 copyCGImageAtTime:actualTime:error: 在指定时间生成单个图像。AVFoundation可能无法精确的根据你指定的时间生成图像，所以可以将一个指向 CMTime 的指针作为第二个参数传递，该指针在返回时包含实际生成图像的时间。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [[<span class="built_in">AVAssetImageGenerator</span> alloc] initWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> midpoint = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">2.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">CMTime</span> actualTime;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (halfWayImage != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime);</span><br><span class="line">    <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, midpoint);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got halfWayImage: Asked for %@, got %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(halfWayImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-生成一系列图像"><a href="#1-4-2-生成一系列图像" class="headerlink" title="1.4.2 生成一系列图像"></a>1.4.2 生成一系列图像</h3><p>使用 <code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code> 生成一系列图像。</p><ul><li>第一个参数是一个 NSValue 对象数组，每个对象都包含一个 CMTime 结构体对象，指定你希望的生成图像的时间。</li><li>第二个参数是一个block，用作为生成的每个图像调用的回调。block的参数中提供了一个结果常量，表示图像创建是成功、失败、被取消等结果，在 block 中，应当检查图片生成的结果。另外，根据不同情况，可能包含以下的参数：<ul><li>生成的图片</li><li>请求生成图片的时间和实际生成图片的时间</li><li>生成失败的原因</li></ul></li></ul><p>在完成创建图像之前，保持一个对图像生成器的强引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="comment">// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;</span></span><br><span class="line"><span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> end = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[<span class="built_in">NSValue</span> valueWithCMTime:kCMTimeZero],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:end]];</span><br><span class="line"></span><br><span class="line">[imageGenerator generateCGImagesAsynchronouslyForTimes:times</span><br><span class="line">                completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span> image, <span class="built_in">CMTime</span> actualTime,</span><br><span class="line">                                    <span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, requestedTime));</span><br><span class="line">                <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime));</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Requested: %@; actual %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;</span><br><span class="line">                    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorFailed</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed with error: %@&quot;</span>, [error localizedDescription]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorCancelled</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Canceled&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>调用图像生成器的 cancelAllCGImageGeneration ，来取消图像序列的生成。</p><h2 id="1-5-视频的剪辑和转码-AVAssetExportSession"><a href="#1-5-视频的剪辑和转码-AVAssetExportSession" class="headerlink" title="1.5 视频的剪辑和转码(AVAssetExportSession)"></a>1.5 视频的剪辑和转码(AVAssetExportSession)</h2><p>AVAssetExportSession 对象可以剪辑视频或者对视频进行格式转换。流程图如下：</p><img src="/images/avf/export_2x.png" alt="img" style="zoom:80%;" /><p>导出会话(export session)是管理asset异步导出的控制器对象。</p><ul><li><p>使用要导出的asset、指示导出选项的导出预设(export preset)的名称来初始化会话。</p><ul><li>使用 exportPresetsCompatibleWithAsset: 检查是否可以使用给定预设导出asset</li></ul></li><li><p>然后配置 export session 指定导出的 URL 、文件格式、其他信息 (比如是否因为网络使用而对元数据进行优化)。</p><ul><li>指定输出URL：该URL必须是文件URL</li><li>文件类型：AVAssetExportSession 可以从 URL 的路径扩展名推断输出文件类型；但是，通常您直接使用 outputFileType 设置它。</li><li>其它可选的设置，例如元数据、时间范围、输出文件长度的限制、导出的文件是否应针对网络使用输出优化、视频合成等。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *anAsset = &lt;#Get an asset#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *compatiblePresets = [<span class="built_in">AVAssetExportSession</span> exportPresetsCompatibleWithAsset:anAsset];</span><br><span class="line"><span class="keyword">if</span> ([compatiblePresets containsObject:<span class="built_in">AVAssetExportPresetLowQuality</span>]) &#123;</span><br><span class="line">    <span class="built_in">AVAssetExportSession</span> *exportSession = [[<span class="built_in">AVAssetExportSession</span> alloc]</span><br><span class="line">        initWithAsset:anAsset presetName:<span class="built_in">AVAssetExportPresetLowQuality</span>];</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">    <span class="comment">// 使用 timeRange 属性修剪影片</span></span><br><span class="line">    exportSession.outputURL = &lt;#A file URL#&gt;;</span><br><span class="line">    exportSession.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CMTime</span> start = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">1.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTime</span> duration = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTimeRange</span> range = <span class="built_in">CMTimeRangeMake</span>(start, duration);</span><br><span class="line">    exportSession.timeRange = range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 exportAsynchronouslyWithCompletionHandler: 方法导出文件。导出操作完成时会调用complete handler。在该代码块中，需要根据 status 属性判断导出是否成功。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[exportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ([exportSession status]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusFailed</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export failed: %@&quot;</span>, [[exportSession error] localizedDescription]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusCancelled</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export canceled&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>可以通过向会话发送 cancelExport 消息来取消导出。</p></li></ul><p>导出到一个已存在的文件或者导出到应用程序沙盒目录外将会导致导出失败。其他可能导致失败的情况包括：</p><ul><li>导出过程中接收到电话呼叫</li><li>程序进入后台, 有其他程序开始使用播放功能</li></ul><p>在这些情况下，要告知用户导出失败，并允许用户重新开始导出。</p><h1 id="二、播放Assets"><a href="#二、播放Assets" class="headerlink" title="二、播放Assets"></a>二、播放Assets</h1><p>AVFoundation 允许以更精确的方式管理asset的播放。为了支持这一点，它将asset的呈现状态(presentation state)与asset本身分开。这就能让开发者在同一时刻以不同分辨率呈现同一资源的两个不同片段。</p><ul><li>使用 AVPlayer 对象来控制asset的播放。</li><li>使用播放器项目(player item)对象管理asset的呈现状态（AVPlayerItem 实例）</li><li>使用播放器项目轨道(player item track)对象管理asset中每个轨道的呈现状态 （AVPlayerItemTrack实例）</li></ul><p>比如，使用 player item 和 player item tracks 可以：</p><ul><li>设置资源的可视部分在播放时的尺寸</li><li>播放时，设置audio 的混音参数、视频合成设置，或者禁用asset中的某些部分</li></ul><p>使用 <em>player</em> 对象可以播放 player items 对象，或者直接指定将其输出 (output) 到 Core Animation layer 之上。还可以使用播放队列(<em>player queue</em>) 来顺序播放多个 player items 对象。</p><p>使用 AVPlayerLayer 对象来显示视频。</p><h2 id="2-1-核心类概述"><a href="#2-1-核心类概述" class="headerlink" title="2.1 核心类概述"></a>2.1 核心类概述</h2><h3 id="2-1-1-播放器AVPlayer"><a href="#2-1-1-播放器AVPlayer" class="headerlink" title="2.1.1 播放器AVPlayer"></a>2.1.1 播放器AVPlayer</h3><p>播放器(player)是一个控制器对象，用于管理资源的播放，例如开始和停止播放，以及寻找特定时间。</p><ul><li>使用 AVPlayer 实例来播放单个资源。</li><li>使用 AVQueuePlayer 对象按顺序播放多个项目（AVQueuePlayer 是 AVPlayer 的子类）。在 OS X 上，您可以选择使用 AVKit 框架的 AVPlayerView 类在视图中播放内容。</li></ul><p>播放器可提供有关播放状态的信息，因此，如果需要，可以将用户界面与播放器的状态同步。</p><p>通常，将播放器的输出定向到专门的核心动画层（AVPlayerLayer 或 AVSynchronizedLayer 的实例）。要了解有关图层的更多信息，请参阅核心动画编程指南。</p><blockquote><p>多个播放器层：您可以从单个 AVPlayer 实例创建多个 AVPlayerLayer 对象，但只有最近创建的layer才会在屏幕上显示视频内容。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器AVPlayer</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayer</span> : <span class="title">NSObject</span> </span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPlayerItem:(<span class="keyword">nullable</span> <span class="built_in">AVPlayerItem</span> *)item;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVPlayerStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayerItem</span> *currentItem;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> volume;  <span class="comment">// 音量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isMuted) <span class="built_in">BOOL</span> muted; <span class="comment">// 静音</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-AVPlayerItem"><a href="#2-1-2-AVPlayerItem" class="headerlink" title="2.1.2 AVPlayerItem"></a>2.1.2 AVPlayerItem</h3><ul><li>播放资源时，需要向 AVPlayer 对象提供一个 AVPlayerItem 实例，而不是直接提供asset。</li><li>player item会管理与其关联的asset的呈现状态。</li><li>player item包含了播放器项目轨道（AVPlayerItemTrack 的实例），它们对应于asset中的轨道。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器项目AVPlayerItem</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItem</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVPlayerItemStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVPlayerItemTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CGSize</span> presentationSize;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>不仅可以使用现有asset初始化player item，也可以直接从 URL 初始化，以便你可以在特定位置播放资源（AVPlayerItem会为资源创建和配置一个asset）。</p><p>然而，与 AVAsset 一样，简单地初始化一个player item并不一定意味着它已经可以立即播放。你可以<strong>使用KVO观察player item的status属性</strong>来确定它是否以及何时准备好播放。</p><h3 id="2-1-3-AVPlayerLayer"><a href="#2-1-3-AVPlayerLayer" class="headerlink" title="2.1.3 AVPlayerLayer"></a>2.1.3 AVPlayerLayer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerLayer</span> : <span class="title">CALayer</span></span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line"><span class="built_in">AVPlayerLayerInternal</span>*_playerLayer;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">AVPlayerLayer</span> *)playerLayerWithPlayer:(<span class="keyword">nullable</span> <span class="built_in">AVPlayer</span> *)player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="comment">//指示player的当前player item的第一个视频帧是否准备好显示</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isReadyForDisplay) <span class="built_in">BOOL</span> readyForDisplay;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> videoRect;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *pixelBufferAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-1-4-类关系梳理"><a href="#2-1-4-类关系梳理" class="headerlink" title="2.1.4 类关系梳理"></a>2.1.4 类关系梳理</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItemTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 被播放器项目轨道表示了其呈现状态的资产轨道。 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetTrack</span> *assetTrack;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>按照类关联关系：AVPlayer → AVPlayerItem → AVPlayerItemTrack → AVAssetTrack</p></blockquote><img src="/images/avf/avplayerLayer_2x.png" alt="avplayerLayer_2x" style="zoom:70%;" /><p>这种抽象意味着可以同时使用不同的播放器播放一个给定的资源，每个播放器以不同的方式呈现。比如下图 ，不同的播放器使用不同的设置播放同一个相同的资产。可以使用项目轨道，在播放期间禁用特定轨道（例如屏蔽声音）。</p><img src="/images/avf/playerObjects_2x.png" alt="playerObjects_2x" style="zoom:70%;" /><h2 id="2-2-处理不同类型的资源"><a href="#2-2-处理不同类型的资源" class="headerlink" title="2.2 处理不同类型的资源"></a>2.2 处理不同类型的资源</h2><h3 id="2-2-1-两种类型资源"><a href="#2-2-1-两种类型资源" class="headerlink" title="2.2.1 两种类型资源"></a>2.2.1 两种类型资源</h3><p>asset播放的方式取决于其类型。从广义上讲，有两种主要类型：</p><ul><li>基于文件的资源 file-based assets ，你可以随机访问（例如从本地文件、媒体库、相册）</li><li>基于流的资源 stream-based assets（HTTP 实时流格式）</li></ul><h3 id="2-2-2-播放基于文件的资源"><a href="#2-2-2-播放基于文件的资源" class="headerlink" title="2.2.2 播放基于文件的资源"></a>2.2.2 播放基于文件的资源</h3><p>步骤：</p><ol><li>使用 AVURLAsset 创建 AVAsset</li><li>使用asset创建 AVPlayerItem 的实例</li><li>将 AVPlayerItem实例 与 AVPlayer 实例相关联</li><li>等待，直到player item的status属性表明已经可以播放（通过KVO观察属性变化）。</li></ol><p>示例代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@&quot;VideoFileName&quot;</span> </span><br><span class="line">                                             withExtension:<span class="string">@&quot;extension&quot;</span>];</span><br><span class="line">    <span class="comment">//创建一个资源实例</span></span><br><span class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:fileURL];</span><br><span class="line">    <span class="comment">//关联播放资源</span></span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">    <span class="comment">//添加监听PlayerItem的status属性值</span></span><br><span class="line">    [playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;ItemStatusContext];</span><br><span class="line">    <span class="comment">//创建player</span></span><br><span class="line">    _player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:playerItem]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// ... 处理逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-播放-HTTP-实时流"><a href="#2-2-3-播放-HTTP-实时流" class="headerlink" title="2.2.3 播放 HTTP 实时流"></a>2.2.3 播放 HTTP 实时流</h3><p>使用 URL 初始化 AVPlayerItem 的实例。（不能直接创建 AVAsset 实例来表示 HTTP 实时流中的媒体）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;&lt;#Live stream URL#&gt;];</span></span><br><span class="line"><span class="string">// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.</span></span><br><span class="line"><span class="string">self.playerItem = [AVPlayerItem playerItemWithURL:url];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 观察player item的status属性</span></span><br><span class="line"><span class="string">[playerItem addObserver:self forKeyPath:@&quot;</span>status<span class="string">&quot; options:0 context:&amp;ItemStatusContext];</span></span><br><span class="line"><span class="string">self.player = [AVPlayer playerWithPlayerItem:playerItem];</span></span><br></pre></td></tr></table></figure><p>将 AVPlayerItem实例 与 AVPlayer 实例相关联，准备播放。当准备好播放时，player item会创建 AVAsset 和 AVAssetTrack 实例，可以使用它们来检查实时流的内容。</p><p>要获取流媒体项目的持续时间，可以观察player item的duration属性。当项目准备好播放时，此属性将更新为流的正确值。</p><p>如果只是想播放直播，可以如以下代码，直接使用 URL 创建创建播放器player：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithURL:&lt;#Live stream URL#&gt;];</span><br><span class="line"><span class="comment">//观察player的status的属性</span></span><br><span class="line">[player addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;PlayerStatusContext];</span><br></pre></td></tr></table></figure><p>补充：与AVAsset和AVPlayerItem一样，初始化了播放器并不意味着它已准备好播放。你应该监听播放器的status属性，当它准备好播放时，其值会更改为 AVPlayerStatusReadyToPlay。您还可以观察 currentItem 属性以访问为流创建的播放器项目。</p><h3 id="2-2-4-URL类型的判断"><a href="#2-2-4-URL类型的判断" class="headerlink" title="2.2.4 URL类型的判断"></a>2.2.4 URL类型的判断</h3><p>如果不知道自己的 URL 类型，可以按照以下步骤操作：</p><ol><li>尝试使用 URL 初始化 AVURLAsset，然后加载它的tracks属性。如果tracks加载成功，就可以为资源创建一个AVPlayerItem实例。</li><li>如果第一步失败，则直接从 URL 创建一个 AVPlayerItem，监听其status属性来确定它是否可以播放。</li></ol><p>上面任一分支成功，最后都会得到一个player item，然后将其与播放器player关联。</p><h2 id="2-3-播放一个项目-AVPlayer"><a href="#2-3-播放一个项目-AVPlayer" class="headerlink" title="2.3 播放一个项目 AVPlayer"></a>2.3 播放一个项目 AVPlayer</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>调用播放器的play方法，即可开始播放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了简单的播放之外，还可以管理播放的各个方面，例如：</p><ul><li>设置播放头的速率和位置 （<em>播放头playhead为显示当前播放位置的那一条与时间轴垂直的线</em>）</li><li>监控播放器的播放状态（比如设置用户界面与资源的呈现状态同步）。</li></ul><h3 id="2-3-2-更改播放速度"><a href="#2-3-2-更改播放速度" class="headerlink" title="2.3.2 更改播放速度"></a>2.3.2 更改播放速度</h3><p>设置播放器的 rate 属性来更改播放速度。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aPlayer.rate = <span class="number">0.5</span>;</span><br><span class="line">aPlayer.rate = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><ul><li>值 1.0 表示“以当前项目的自然速度播放”。</li><li>值 0.0 与暂停播放相同——也可以直接调用 <code>pause</code> 方法暂停。</li><li>当项目支持反向播放时，可以使用赋值 rate 负数来设置反向播放速度。</li></ul><p>playerItem 的几个属性，用来确定支持的反向播放类型：</p><ul><li>canPlayReverse（是否支持 -1.0 的速度值）</li><li>canPlaySlowReverse（是否支持介于 0.0 到 -1.0 之间的速度）</li><li> canPlayFastReverse（是否支持小于 -1.0 的速度值）</li></ul><h3 id="2-3-3-寻找—重新定位播放头"><a href="#2-3-3-寻找—重新定位播放头" class="headerlink" title="2.3.3 寻找—重新定位播放头"></a>2.3.3 寻找—重新定位播放头</h3><p>要将播放头移动到特定时间，可以使用以下两种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seekToTime:方法是针对性能而不是精度进行调整的</span></span><br><span class="line"><span class="built_in">CMTime</span> fiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要精确移动播放头，使用下面的方法。[tolerance 容许偏差]</span></span><br><span class="line"><span class="built_in">CMTime</span> FiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</span><br></pre></td></tr></table></figure><p>注意：使用零容差可能需要框架解码大量数据。仅当你正在编写需要精确控制的复杂媒体编辑APP时才应使用。</p><p>播放后，播放器的头部被设置到项目的末尾，进一步调用 play 无效。要将播放头放回项目的开头，您可以注册以接收来自项目的 AVPlayerItemDidPlayToEndTimeNotification 通知。在通知的回调方法中，您使用参数 kCMTimeZero 调用 seekToTime:。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    addObserver:<span class="keyword">self</span></span><br><span class="line">    selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">    name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">    object:&lt;#The player item#&gt;];</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-播放多个项目-AVQueuePlayer"><a href="#2-4-播放多个项目-AVQueuePlayer" class="headerlink" title="2.4 播放多个项目 AVQueuePlayer"></a>2.4 播放多个项目 AVQueuePlayer</h2><p>使用 AVQueuePlayer 对象按顺序播放多个项目。 AVQueuePlayer 类是 AVPlayer 的子类。使用一个盛放player Item的数组初始化队列播放器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = &lt;#An array of player items#&gt;;</span><br><span class="line"><span class="built_in">AVQueuePlayer</span> *queuePlayer = [[<span class="built_in">AVQueuePlayer</span> alloc] initWithItems:items];</span><br><span class="line"><span class="comment">// 使用 play 播放队列，就像使用 AVPlayer 对象一样</span></span><br><span class="line">[queuePlayer paly];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列播放器依次播放每个项目。可以调用advanceToNextItem跳到下一个项目</span></span><br><span class="line">[queuePlayer advanceToNextItem];</span><br></pre></td></tr></table></figure><p>可以使用 insertItem:afterItem:、removeItem: 和 removeAllItems 修改队列。添加新项目时，应使用 canInsertItem:afterItem: 检查是否可以将其插入队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVPlayerItem</span> *anItem = &lt;#Get a player item#&gt;;</span><br><span class="line"><span class="comment">// 判断是否可以将新项目附加到队列中，第二个参数可以传 nil</span></span><br><span class="line"><span class="keyword">if</span> ([queuePlayer canInsertItem:anItem afterItem:<span class="literal">nil</span>]) &#123;</span><br><span class="line">    [queuePlayer insertItem:anItem afterItem:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-播放监听"><a href="#2-5-播放监听" class="headerlink" title="2.5 播放监听"></a>2.5 播放监听</h2><h3 id="2-5-1-使用场景"><a href="#2-5-1-使用场景" class="headerlink" title="2.5.1 使用场景"></a>2.5.1 使用场景</h3><p>可以监听播放器player的呈现状态和正在播放的播放器项目player item的许多方面。当一些不受开发者直接控制的状态更改时，这将特别有用。例如：</p><ul><li>如果用户使用多任务切换到不同的应用程序，AVPlayer的 rate 属性值将下降到 0.0。</li><li>如果正在播放远程媒体，AVPlayerItem 的 loadedTimeRanges 和 seekableTimeRanges 属性将随着更多数据可用而改变。<br>这些属性告诉您播放器项目时间线的哪些部分可用。</li><li>当为 HTTP 直播流创建 AVPlayerItem 时，AVPlayer的 currentItem 属性会发生变化。</li><li>播放 HTTP 直播流时，AVPlayerItem 的 tracks 属性可能会发生变化。（比如如果流为内容提供了不同的编码，当播放器切换到不同的编码，tracks会发生变化。）</li><li>如果由于某种原因播放失败，AVPlayer 或 AVPlayerItem 的 status 属性可能会更改。</li></ul><p>可以使用KVO来监听这些属性值的变化。<strong>注意：需要在主线程上注册、注销KVO通知。</strong></p><h3 id="2-5-2-监听status的变化"><a href="#2-5-2-监听status的变化" class="headerlink" title="2.5.2 监听status的变化"></a>2.5.2 监听status的变化</h3><p>当播放器或播放器项目的 status 发生变化时，会发出一个KVO改变通知。如果对象由于某种原因无法播放（例如，如果媒体服务被重置），则 status 将根据需要更改为 AVPlayerStatusFailed 或 AVPlayerItemStatusFailed。在这种情况下，对象的 error 属性将被赋值为一个NSError对象，描述了错误原因。</p><p>AV Foundation 没有指定发送通知的线程。如果要通知更新用户界面，则必须确保是在主线程上进行操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &lt;#Player status context#&gt;) &#123;</span><br><span class="line">        <span class="built_in">AVPlayer</span> *thePlayer = (<span class="built_in">AVPlayer</span> *)object;</span><br><span class="line">        <span class="keyword">if</span> ([thePlayer status] == <span class="built_in">AVPlayerStatusFailed</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [&lt;#The <span class="built_in">AVPlayer</span> object#&gt; error];</span><br><span class="line">            <span class="comment">// Respond to error: for example, display an alert sheet.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deal with other status change if appropriate.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Deal with other change notifications if appropriate.</span></span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-监听可视化内容的就绪状态"><a href="#2-5-3-监听可视化内容的就绪状态" class="headerlink" title="2.5.3 监听可视化内容的就绪状态"></a>2.5.3 监听可视化内容的就绪状态</h3><p>监听 AVPlayerLayer 对象的 readyForDisplay 属性，以便在图层具有用户可见内容时收到通知。特别是，当你只需要在有可视化内容时，才要将播放器图层 player layer 插入到图层树layer tree中的情况。</p><h3 id="2-5-4-监听播放时间"><a href="#2-5-4-监听播放时间" class="headerlink" title="2.5.4 监听播放时间"></a>2.5.4 监听播放时间</h3><p>使用场景：根据已播放时间或剩余时间来更新用户界面，或执行一些其他用户界面同步。</p><p>跟踪 AVPlayer 对象中播放头位置的变化，可以使用下面的两个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block会在指定的时间间隔中被调用。如果时间有跳跃，会在播放开始或者结束的时候调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval </span><br><span class="line">                                   queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                              usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个包装CMTime的NSValue数组。每当这些时间被通过时，block都会被调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addBoundaryTimeObserverForTimes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)times </span><br><span class="line">                                queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                           usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>这两种方法都返回一个作为 observer 的不透明对象。必须对其保持强引用。</li><li>必须平衡上面这两个方法与 removeTimeObserver: 的调用。</li><li>使用上面两个方法，AV Foundation 不保证在每个间隔、边界通过时都会调用block。如果先前调用的block执行尚未完成，就不会调用block。因此，您必须确保您在block中执行的工作不会对系统造成过多的负担。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume a property: @property (strong) id playerObserver;</span></span><br><span class="line"> </span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([&lt;#An asset#&gt; duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[[<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird]];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">self</span>.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:<span class="literal">NULL</span> usingBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *timeDescription = (<span class="built_in">NSString</span> *)</span><br><span class="line">        <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, [<span class="keyword">self</span>.player currentTime]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Passed a boundary at %@&quot;</span>, timeDescription);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="2-5-5-监听播放结束"><a href="#2-5-5-监听播放结束" class="headerlink" title="2.5.5 监听播放结束"></a>2.5.5 监听播放结束</h3><p>可以注册<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知来监听 player item 的播放结束.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:&lt;#The observer, typically <span class="keyword">self</span>#&gt;</span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(&lt;#The selector name#&gt;)</span><br><span class="line">                                           name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                           object:&lt;#A player item#&gt;];</span><br></pre></td></tr></table></figure><h2 id="2-6-示例：使用-AVPlayerLayer-播放视频文件"><a href="#2-6-示例：使用-AVPlayerLayer-播放视频文件" class="headerlink" title="2.6 示例：使用 AVPlayerLayer 播放视频文件"></a>2.6 示例：使用 AVPlayerLayer 播放视频文件</h2><p>这个简短的代码示例说明了如何使用 AVPlayer 对象来播放视频文件。它展示了如何：</p><ul><li>使用 AVPlayerLayer 图层去配置一个view</li><li>创建一个 AVPlayer 对象</li><li>为 file-based asset 创建一个 AVPlayerItem 对象，并使用KVO观察其status值</li><li>监听资源是否准备好播放，同步改变播放按钮的可用状态。</li><li>播放item，然后将播放头恢复到开头位置。</li></ul><blockquote><p>提示: 为了展示核心代码, 这份示例省略了某些内容, 比如内存管理和通知的移除等. 使用 AV Foundation 之前, 你最好已经拥有 Cocoa 框架的使用经验.</p></blockquote><h3 id="step1-定义-Player-View"><a href="#step1-定义-Player-View" class="headerlink" title="step1: 定义 Player View"></a>step1: 定义 Player View</h3><p>要播放一个 asset 的可视部分, 你需要一个包含<code>AVPlayerLayer</code>对象的 view, 用来接收<code>AVPlayer</code>对象的输出. 可以简单的定义一个 UIView 的子类来实现这一功能：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerView</span></span></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">AVPlayer</span>*)player &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] player];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setPlayer:(<span class="built_in">AVPlayer</span> *)player &#123;</span><br><span class="line">    [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] setPlayer:player];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="step2-配置-View-Controller"><a href="#step2-配置-View-Controller" class="headerlink" title="step2: 配置 View Controller"></a>step2: 配置 View Controller</h3><p>假设你有一个简单的视图控制器，声明如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">PlayerView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayerItem</span> *playerItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> PlayerView *playerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *playButton;</span><br><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)play:sender;</span><br><span class="line">- (<span class="keyword">void</span>)syncUI;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>syncUI 方法将按钮的状态与播放器的状态同步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)syncUI &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.player.currentItem != <span class="literal">nil</span>) &amp;&amp;</span><br><span class="line">        ([<span class="keyword">self</span>.player.currentItem status] == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 viewDidLoad 方法中就调用 syncUI 以确保在首次显示视图时用户界面一致。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> syncUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3-创建-Asset、PlayerItem、Player"><a href="#step3-创建-Asset、PlayerItem、Player" class="headerlink" title="step3: 创建 Asset、PlayerItem、Player"></a>step3: 创建 Asset、PlayerItem、Player</h3><p>使用<code>AVURLAsset</code>根据 URL 创建 asset.(下面的代码假设项目中包含了一个视频资源)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle]</span><br><span class="line">        URLForResource:&lt;#<span class="string">@&quot;VideoFileName&quot;</span>#&gt; withExtension:&lt;#<span class="string">@&quot;extension&quot;</span>#&gt;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:fileURL options:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *tracksKey = <span class="string">@&quot;tracks&quot;</span>;</span><br><span class="line"></span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:</span><br><span class="line">     ^&#123;</span><br><span class="line">         <span class="comment">// The completion block goes here.</span></span><br><span class="line">     &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 completion block 中创建 <code>AVPlayerItem</code>，并将其设置为 player view 的 player。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Completion handler block.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">  ^&#123;</span><br><span class="line">      <span class="built_in">NSError</span> *error;</span><br><span class="line">      <span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracksKey error:&amp;error];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;</span><br><span class="line">          <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">          <span class="comment">// 与创建asset一样，简单地创建PlayerItem并不意味着它可以使用。要确定它何时可以播放，需要观察其status属性。</span></span><br><span class="line">          <span class="comment">// 在 playerItem 与 player 完成关联之前，配置此监听</span></span><br><span class="line">          [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> </span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionInitial</span></span><br><span class="line">                               context:&amp;ItemStatusContext];</span><br><span class="line">          [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                   selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">                                       name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                     object:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          <span class="comment">// 将 playerItem 与 player 完成关联时，会触发 playerItem 的播放准备。</span></span><br><span class="line">          <span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          [<span class="keyword">self</span>.playerView setPlayer:<span class="keyword">self</span>.player];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// You should deal with the error appropriately.</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;The asset&#x27;s tracks were not loaded:\n%@&quot;</span>, [error localizedDescription]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="step4-响应-PlayerItem-的-status-改变"><a href="#step4-响应-PlayerItem-的-status-改变" class="headerlink" title="step4: 响应 PlayerItem 的 status 改变"></a>step4: 响应 PlayerItem 的 status 改变</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// 保证在主线程上调用了UI操作代码</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">                       ^&#123;</span><br><span class="line">                           [<span class="keyword">self</span> syncUI];</span><br><span class="line">                       &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step5-播放-Item"><a href="#step5-播放-Item" class="headerlink" title="step5: 播放 Item"></a>step5: 播放 Item</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>item 只被播放一次，播放结束后，播放点会被设置为 item 的结束点，这样下一次调用 play 方法将会失效。要将播放点设置到 item 的起始处，参考如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">        addObserver:<span class="keyword">self</span></span><br><span class="line">        selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">        name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">        object:[<span class="keyword">self</span>.player currentItem]];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span>.player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、编辑-Assets"><a href="#三、编辑-Assets" class="headerlink" title="三、编辑 Assets"></a>三、编辑 Assets</h1><p>AVFoundation 框架为音视频编辑提供了功能丰富的类集。</p><p>这些 API 的核心称为合成/组合 (compositions)。composition 是一个或多个媒体资源的 track 的集合。</p><ul><li>从现有媒体片段<ul><li>使用 compositions(组合) 从现有的媒体片段（通常是一个或多个视频和音频轨道）创建新的asset。</li><li>使用可变的 composition 来添加和删除轨道，并调整它们的时间顺序。</li><li>可以设置音轨的相对音量和渐变效果；并设置视频轨道的透明度和透明度渐变。</li><li>composition 是保存在内存中的一系列媒体片段的集合。可以通过 <em>export session</em> 将 composition 导出到文件中。</li></ul></li><li>从样本缓冲区或静止图像<ul><li>使用资产写入器(asset writer)从样本缓冲区或静止图像等媒体创建asset。</li></ul></li></ul><h2 id="3-1-Asset合成-AVMutableComposition"><a href="#3-1-Asset合成-AVMutableComposition" class="headerlink" title="3.1 Asset合成(AVMutableComposition)"></a>3.1 Asset合成(AVMutableComposition)</h2><h3 id="核心类概述"><a href="#核心类概述" class="headerlink" title="核心类概述"></a>核心类概述</h3><p>AVMutableComposition 类提供了插入和删除 track，以及管理其时间顺序的的接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> : <span class="title">AVComposition</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> naturalSize;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)composition;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)compositionWithURLAssetInitializationOptions:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)URLAssetInitializationOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//composition层面的编辑，管理时间顺序</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionCompositionLevelEditing</span>)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)insertTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange ofAsset:(<span class="built_in">AVAsset</span> *)asset atTime:(<span class="built_in">CMTime</span>)startTime error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">void</span>)insertEmptyTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)removeTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)scaleTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange toDuration:(<span class="built_in">CMTime</span>)duration;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track层面的编辑</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackLevelEditing</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向composition中添加一个新track时，必须同时提供媒体类型 (media type) 和 track ID。</span></span><br><span class="line"><span class="comment"> * @param mediaType 除了最常用的音频和视频类型，还有其他的媒体类型可以选择。比如 AVMediaTypeSubtitle(字幕)，AVMediaTypeText。</span></span><br><span class="line"><span class="comment"> * @param preferredTrackID 每个 track 都会有一个唯一的标识符 track ID(32位整数值)</span></span><br><span class="line"><span class="comment">                           如果指定 kCMPersistentTrackID_Invalid 作为 track ID，则会自动为关联的 track 自动生成一个唯一的 ID。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)addMutableTrackWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType preferredTrackID:(<span class="built_in">CMPersistentTrackID</span>)preferredTrackID;</span><br><span class="line">- (<span class="keyword">void</span>)removeTrack:(<span class="built_in">AVCompositionTrack</span> *)track;</span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)mutableTrackCompatibleWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track检查</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackInspection</span>)</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMutableCompositionTrack</span> *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>下图展示了如何通过已存在的 assets 组合成为一个 composition。</p><img src="/images/avf/avmutablecomposition_2x.png" alt="avmutablecomposition_2x" style="zoom:70%;" /><h3 id="3-1-1-创建AVMutableComposition"><a href="#3-1-1-创建AVMutableComposition" class="headerlink" title="3.1.1 创建AVMutableComposition"></a>3.1.1 创建AVMutableComposition</h3><p>先使用 AVMutableComposition 类创建一个自定义的 Composition。</p><h3 id="3-1-2-添加AVMutableCompositionTrack"><a href="#3-1-2-添加AVMutableCompositionTrack" class="headerlink" title="3.1.2 添加AVMutableCompositionTrack"></a>3.1.2 添加AVMutableCompositionTrack</h3><p>然后如果要向组合中添加媒体数据，那么需要先使用 AVMutableCompositionTrack 类在自定义的 Composition 中添加一个或多个 composition tracks。</p><p>下面是一个通过 video track 和 audio track 创建 composition 的例子:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the video composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the audio composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure><h3 id="3-1-3-向composition-track中添加AVAssetTrack"><a href="#3-1-3-向composition-track中添加AVAssetTrack" class="headerlink" title="3.1.3 向composition track中添加AVAssetTrack"></a>3.1.3 向composition track中添加AVAssetTrack</h3><h4 id="1-添加媒体数据"><a href="#1-添加媒体数据" class="headerlink" title="1. 添加媒体数据"></a>1. 添加媒体数据</h4><p>当配置好一个包含一个或多个track的composition时，就可以开始将媒体数据添加到合适的track中。</p><p>首先，需要访问媒体数据所在的<code>AVAsset</code>对象。将具有相同媒体类型的多个 track 添加到同一个 mutable composition track 中。</p><p>下面的例子说明了如何将两个不同的 video asset tracks 顺序添加到一个 composition track 中:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以从许多地方检索 AVAsset，例如相机胶卷</span></span><br><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="built_in">AVAsset</span> with at least one video track#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *anotherVideoAsset = &lt;<span class="meta">#another AVAsset with at least one video track#&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从每个 asset 中获取第一个视频轨道</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add them both to the composition.</span></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="2-检索兼容的-Composition-Tracks"><a href="#2-检索兼容的-Composition-Tracks" class="headerlink" title="2. 检索兼容的 Composition Tracks"></a>2. 检索兼容的 Composition Tracks</h4><p>如果可能的情况下，每种媒体类型都应当只有一个对之对应的 composition track，这样会降低资源的使用。当串行呈现媒体数据时，应当将相同类型的媒体数据放到同一个 composition track 中。</p><p>可以通过查询一个 mutable composition，找出是否有与 asset track 对应的 composition track.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:&lt;<span class="meta">#the AVAssetTrack you want to insert#&gt;];</span></span><br><span class="line"><span class="keyword">if</span> (compatibleCompositionTrack) &#123;</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 在同一个 composition track 添加多个视频段，可能会导致视频段之间进行切换时掉帧，嵌入式设备尤其明显。如何为 composition track 选择合适数量的视频段取决于 App 的设计以及其目标设备。</p></blockquote><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h3><p>如果你需要顺序合并多个 asset 到一个文件中，上面的内容就已经够用了。但是如果要对合成中的 track 执行任何自定义的音视频处理操作，那么你需要分别进行音频混合、视频组合。</p><h2 id="3-2-音频混合-AVMutableAudioMix"><a href="#3-2-音频混合-AVMutableAudioMix" class="headerlink" title="3.2 音频混合(AVMutableAudioMix)"></a>3.2 音频混合(AVMutableAudioMix)</h2><h3 id="3-2-1-核心类概述"><a href="#3-2-1-核心类概述" class="headerlink" title="3.2.1 核心类概述"></a>3.2.1 核心类概述</h3><p>如下图(performs audio mixing)中所示，使用 AVMutableAudioMix 类可以对 composition 中的 audio track 进行自定义操作。你还可以指定 audio track 的最大音量或者为其设置渐变效果。</p><img src="/images/avf/avmutableaudiomix_2x.png" alt="avmutableaudiomix_2x" style="zoom:70%;" /><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMix</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMix</span> : <span class="title">AVAudioMix</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMixInputParameters</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getVolumeRampForTime:(<span class="built_in">CMTime</span>)time startVolume:(<span class="keyword">float</span> *)startVolume endVolume:(<span class="keyword">float</span> *)endVolume timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMixInputParameters</span> : <span class="title">AVAudioMixInputParameters</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParametersWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParameters;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="keyword">void</span>)setVolumeRampFromStartVolume:(<span class="keyword">float</span>)startVolume toEndVolume:(<span class="keyword">float</span>)endVolume timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setVolume:(<span class="keyword">float</span>)volume atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-示例-自定义音频处理-—-音量渐变"><a href="#3-2-2-示例-自定义音频处理-—-音量渐变" class="headerlink" title="3.2.2 示例: 自定义音频处理 — 音量渐变"></a>3.2.2 示例: 自定义音频处理 — 音量渐变</h3><p>使用一个<code>AVMutableAudioMix</code>对象就可以为 composition 中的每一个 audio tracks 单独执行自定义的音频处理操作。</p><p>下面的例子展示了如何给一个 audio track 设置音量渐变让声音有一个缓慢淡出结束的效果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类方法 audioMix 创建一个 audio mix</span></span><br><span class="line"><span class="built_in">AVMutableAudioMix</span> *mutableAudioMix = [<span class="built_in">AVMutableAudioMix</span> audioMix];</span><br><span class="line"><span class="comment">// 使用AVMutableAudioMixInputParameters设置 将音轨添加到混音时使用的参数。</span></span><br><span class="line"><span class="built_in">AVMutableAudioMixInputParameters</span> *mixParameters = [<span class="built_in">AVMutableAudioMixInputParameters</span> audioMixInputParametersWithTrack:mutableCompositionAudioTrack];</span><br><span class="line"><span class="comment">// 修改音量 Set the volume ramp, 使声音有一个缓慢淡出效果</span></span><br><span class="line">[mixParameters setVolumeRampFromStartVolume:<span class="number">1.</span>f toEndVolume:<span class="number">0.</span>f timeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration)];</span><br><span class="line"><span class="comment">// Attach the input parameters to the audio mix. </span></span><br><span class="line">mutableAudioMix.inputParameters = @[mixParameters];</span><br></pre></td></tr></table></figure><p>AVMutableAudioMixInputParameters 类的接口将 audio mix 与 composition 中特定的 track 关联起来</p><h2 id="3-3-视频合成-AVMutableVideoComposition"><a href="#3-3-视频合成-AVMutableVideoComposition" class="headerlink" title="3.3 视频合成(AVMutableVideoComposition)"></a>3.3 视频合成(AVMutableVideoComposition)</h2><h3 id="3-3-1-核心类概述"><a href="#3-3-1-核心类概述" class="headerlink" title="3.3.1 核心类概述"></a>3.3.1 核心类概述</h3><h4 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h4><p>如下图所示，使用 AVMutableVideoComposition 类可以直接处理合成中的视频 track。</p><ul><li>从一个 video composition 输出视频时，可以指定输出的尺寸、缩放比例、帧率。</li><li>AVMutableVideoCompositionInstruction (视频合成指令)，可以修改视频背景色、设置 layer 的 instructions。<ul><li>AVMutableVideoCompositionLayerInstruction (视频合成图层指令) 可以对合成中的 video track 实现transform、渐变transform、透明度、透明度渐变等效果。</li></ul></li><li>Video composition类还允许通过 <code>animationTool</code> 属性在视频中应用 Core Animation 框架的一些效果。</li></ul><img src="/images/avf/avmutablevideocomposition_2x.png" alt="avmutablevideocomposition_2x" style="zoom:70%;" /><h4 id="2-视频合成类"><a href="#2-视频合成类" class="headerlink" title="2. 视频合成类"></a>2. 视频合成类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt; </span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class&lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositorClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> frameDuration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> sourceTrackIDForFrameTiming;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> renderSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> renderScale;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositionInstruction</span>&gt;&gt; *instructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">AVVideoCompositionCoreAnimationTool</span> *animationTool;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *sourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出帧的颜色空间</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将core Image filters(滤镜)应用于指定asset的每个视频帧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line">               applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> : <span class="title">AVVideoComposition</span></span></span><br><span class="line">  <span class="comment">//.... 继承AVVideoComposition的所有属性</span></span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoComposition;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset prototypeInstruction:(<span class="built_in">AVVideoCompositionInstruction</span> *)prototypeInstruction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line"> applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-视频合成指令类"><a href="#3-视频合成指令类" class="headerlink" title="3. 视频合成指令类"></a>3. 视频合成指令类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionInstruction</span> : <span class="title">AVVideoCompositionInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>)<span class="built_in">CGColorRef</span> backgroundColor;</span><br><span class="line"><span class="comment">// 指定如何从源tracks分层、合成视频帧的指令。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCompositionLayerInstruction</span> *&gt; *layerInstructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> enablePostProcessing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *requiredSourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionLayerInstruction</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getTransformRampForTime:(<span class="built_in">CMTime</span>)time startTransform:(<span class="built_in">CGAffineTransform</span> *)startTransform endTransform:(<span class="built_in">CGAffineTransform</span> *)endTransform timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getOpacityRampForTime:(<span class="built_in">CMTime</span>)time startOpacity:(<span class="keyword">float</span> *)startOpacity endOpacity:(<span class="keyword">float</span> *)endOpacity timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getCropRectangleRampForTime:(<span class="built_in">CMTime</span>)time startCropRectangle:(<span class="built_in">CGRect</span> *)startCropRectangle endCropRectangle:(<span class="built_in">CGRect</span> *)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置transform、opacity等属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionLayerInstruction</span> : <span class="title">AVVideoCompositionLayerInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstructionWithAssetTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="keyword">void</span>)setTransformRampFromStartTransform:(<span class="built_in">CGAffineTransform</span>)startTransform toEndTransform:(<span class="built_in">CGAffineTransform</span>)endTransform timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setTransform:(<span class="built_in">CGAffineTransform</span>)transform atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacityRampFromStartOpacity:(<span class="keyword">float</span>)startOpacity toEndOpacity:(<span class="keyword">float</span>)endOpacity timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacity:(<span class="keyword">float</span>)opacity atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangleRampFromStartCropRectangle:(<span class="built_in">CGRect</span>)startCropRectangle toEndCropRectangle:(<span class="built_in">CGRect</span>)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangle:(<span class="built_in">CGRect</span>)cropRectangle atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="4-核心动画工具"><a href="#4-核心动画工具" class="headerlink" title="4. 核心动画工具"></a>4. 核心动画工具</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionCoreAnimationTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithAdditionalLayer:(<span class="built_in">CALayer</span> *)layer asTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:(<span class="built_in">CALayer</span> *)videoLayer inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">CALayer</span> *&gt; *)videoLayers inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-示例-自定义视频处理"><a href="#3-3-2-示例-自定义视频处理" class="headerlink" title="3.3.2 示例: 自定义视频处理"></a>3.3.2 示例: 自定义视频处理</h3><p>与音频混合一样，可以使用 <code>AVMutableVideoComposition</code> 对象可以对 composition 中的 video tracks 执行所有自定义处理操作。比如指定尺寸、缩放比例、以及帧率。</p><h4 id="1-设置-Composition-的背景色"><a href="#1-设置-Composition-的背景色" class="headerlink" title="1. 设置 Composition 的背景色"></a>1. 设置 Composition 的背景色</h4><p>Video compositions 必须包含一个 AVVideoCompositionInstruction 对象的数组，其中至少包含一个 video composition instruction。</p><p>使用 AVMutableVideoCompositionInstruction 可以创建自定义的视频合成指令(video composition instructions)。使用视频合成指令，来修改composition的背景颜色、指定是否需要后期处理、设置图层的指令等。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *mutableVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line">mutableVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration);</span><br><span class="line">mutableVideoCompositionInstruction.backgroundColor = [[<span class="built_in">UIColor</span> redColor] <span class="built_in">CGColor</span>];</span><br></pre></td></tr></table></figure><h4 id="2-设置-track-切换时的透明度渐变"><a href="#2-设置-track-切换时的透明度渐变" class="headerlink" title="2. 设置 track 切换时的透明度渐变"></a>2. 设置 track 切换时的透明度渐变</h4><p>AVMutableVideoCompositionLayerInstruction 可以用来设置 video track 的 transforms、transforms 渐变、opacity、opacity 渐变。</p><p>AVMutableVideoCompositionInstruction 的属性 layerInstructions 中指令的顺序，决定了在该合成指令的持续时间内，应如何对来自源 track 的视频帧进行分层和合成。</p><p>下面的代码片段展示了如何在第二个视频出现之前为第一个视频增加一个透明度淡出效果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *firstVideoAssetTrack  = &lt;#<span class="built_in">AVAssetTrack</span> representing the first video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *secondVideoAssetTrack = &lt;#<span class="built_in">AVAssetTrack</span> representing the second video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="comment">// 创建第一个视频合成指令</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将timeRange设置为跨越第一个视频track的持续时间</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一个图层指令，然后与视频track，相关联</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不透明度渐变以在整个持续时间内淡出第一个视频轨道。</span></span><br><span class="line">[firstVideoLayerInstruction setOpacityRampFromStartOpacity:<span class="number">1.</span>f toEndOpacity:<span class="number">0.</span>f timeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个视频合成指令，使第二个视频轨道不透明</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将其时间范围设置为跨越第二个视频轨道的持续时间。</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"><span class="comment">// 创建第二个图层指令并将其与视频track相关联。</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach the first layer instruction to the first video composition instruction.</span></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line"><span class="comment">// Attach the second layer instruction to the second video composition instruction.</span></span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach both of the video composition instructions to the video composition.</span></span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure><h4 id="3-结合-Core-Animation"><a href="#3-结合-Core-Animation" class="headerlink" title="3. 结合 Core Animation"></a>3. 结合 Core Animation</h4><p>Video composition 的 animationTool 属性可以在 composition 中展示 Core Animation 框架的强大能力，例如视频水印、视频标题、动画遮罩等。</p><p>在 Video compositions 中 Core Animatio 有两种不同的使用方式：</p><ul><li>添加一个 Core Animation layer 作为独立的 composition track；</li><li>使用 Core Animation layer 将核心动画的效果直接渲染到视频帧中。</li></ul><p>下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *watermarkLayer = &lt;#<span class="built_in">CALayer</span> representing your desired watermark image#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CALayer</span> *parentLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"><span class="built_in">CALayer</span> *videoLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">parentLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">videoLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">[parentLayer addSublayer:videoLayer];</span><br><span class="line"></span><br><span class="line">watermarkLayer.position = <span class="built_in">CGPointMake</span>(mutableVideoComposition.renderSize.width/<span class="number">2</span>, mutableVideoComposition.renderSize.height/<span class="number">4</span>);</span><br><span class="line">[parentLayer addSublayer:watermarkLayer];</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.animationTool = [<span class="built_in">AVVideoCompositionCoreAnimationTool</span> videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];</span><br></pre></td></tr></table></figure><h2 id="3-4-音视频组合-AVAssetExportSession"><a href="#3-4-音视频组合-AVAssetExportSession" class="headerlink" title="3.4 音视频组合(AVAssetExportSession)"></a>3.4 音视频组合(AVAssetExportSession)</h2><p>如下图所示，要对音视频进行组合，可以使用 AVAssetExportSession。使用 composition 初始化一个 export session，然后分别其设置 <code>audioMix</code> 和 <code>videoComposition</code> 属性。</p><img src="/images/avf/puttingitalltogether_2x.png" style="zoom:70%;" /><h2 id="3-5-示例-多个asset的合成与导出"><a href="#3-5-示例-多个asset的合成与导出" class="headerlink" title="3.5 示例: 多个asset的合成与导出"></a>3.5 示例: 多个asset的合成与导出</h2><p>下面的代码简要的展示了如何合并两个 video asset tracks 和一个 audio asset track 为一个视频文件。 包括:</p><ul><li>创建 AVMutableComposition 对象, 并添加多个 AVMutableCompositionTrack 对象</li><li>在 composition tracks 中添加 AVAssetTrack 对象的时间范围</li><li>检查 video asset track 的 preferredTransform 属性，判断视频方向</li><li>使用 AVMutableVideoCompositionLayerInstruction 对象进行 transform 变换</li><li>设置 video composition 的 renderSize 和 frameDuration 属性</li><li>导出视频文件</li><li>保存视频文件到相册</li></ul><blockquote><p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p></blockquote><h3 id="1-创建-Composition"><a href="#1-创建-Composition" class="headerlink" title="1. 创建 Composition"></a>1. 创建 Composition</h3><p>使用<code>AVMutableComposition</code>对象组合多个 assets 中的 tracks。下面的代码创建了一个 composition，并向其添加了一个 audio track 和一个 video track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure><h3 id="2-添加-Assets"><a href="#2-添加-Assets" class="headerlink" title="2. 添加 Assets"></a>2. 添加 Assets</h3><p>向 composition 添加两个 video asset tracks 和一个 audio asset track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAssetTrack</span> *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)</span><br><span class="line">                               ofTrack: firstVideoAssetTrack </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) </span><br><span class="line">                               ofTrack: secondVideoAssetTrack </span><br><span class="line">                                atTime: firstVideoAssetTrack.timeRange.duration </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[audioCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) </span><br><span class="line">                               ofTrack: [[audioAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>] </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h3 id="3-判断视频方向"><a href="#3-判断视频方向" class="headerlink" title="3. 判断视频方向"></a>3. 判断视频方向</h3><p>一旦在 composition 中添加了 audio tracks 和 videotracks，必须确保其中所有的 video tracks 的视频方向都是正确的。</p><p>默认情况下，video tracks 默认为横屏模式，如果 video track 是在竖屏模式下采集的，那么导出视频时会出现方向错误。同理，也不能将一个横向的视频和一个纵向的视频进行合并后导出。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isFirstVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> firstTransform = firstVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="comment">// 对比video track的preferredTransform，判断是否以纵向模式录制。</span></span><br><span class="line"><span class="keyword">if</span> (firstTransform.a == <span class="number">0</span> &amp;&amp; firstTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (firstTransform.b == <span class="number">1.0</span> || firstTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (firstTransform.c == <span class="number">1.0</span> || firstTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isFirstVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> isSecondVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> secondTransform = secondVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="keyword">if</span> (secondTransform.a == <span class="number">0</span> &amp;&amp; secondTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (secondTransform.b == <span class="number">1.0</span> || secondTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (secondTransform.c == <span class="number">1.0</span> || secondTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isSecondVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) || </span><br><span class="line">    (!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *incompatibleVideoOrientationAlert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;Error!&quot;</span> message:<span class="string">@&quot;Cannot combine a video shot in portrait mode with a video shot in landscape mode.&quot;</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@&quot;Dismiss&quot;</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [incompatibleVideoOrientationAlert show];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 <code>AVAssetTrack</code> 对象都有一个 <code>preferredTransform</code> 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面一节的代码中，会将 layer instruction 的 transform 设置为 asset track 的 transform，这样便于修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。</p><h3 id="4-设置视频合成图层指令"><a href="#4-设置视频合成图层指令" class="headerlink" title="4. 设置视频合成图层指令"></a>4. 设置视频合成图层指令</h3><p>一旦确认了视频方向，就可以对每个视频设置必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中去.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将第一个图层指令的时间范围设置为跨越第一个视频轨道的持续时间。</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> * secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 将第一个video track的首选transform 赋值给 第一个图层指令的transform</span></span><br><span class="line">Set the transform of the first layer instruction to the preferred transform of the first video track.</span><br><span class="line">[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];</span><br><span class="line"></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure><h3 id="5-设置渲染尺寸和帧率"><a href="#5-设置渲染尺寸和帧率" class="headerlink" title="5. 设置渲染尺寸和帧率"></a>5. 设置渲染尺寸和帧率</h3><p>要修正视频方向，还必须对 renderSize 属性进行调整。同时也需要设置一个合理的帧持续时间 frameDuration，比如 1/30 秒(30FPS)。默认情况下，renderScale 值为 1.0。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> naturalSizeFirst, naturalSizeSecond;</span><br><span class="line"><span class="comment">// 如果第一个视频资源是在纵向模式下拍摄的，那么如果我们在这里制作第二个视频资源也是如此。</span></span><br><span class="line"><span class="keyword">if</span> (isFirstVideoAssetPortrait) &#123;</span><br><span class="line">    <span class="comment">// 反转video track的宽度和高度以确保它们正确显示。</span></span><br><span class="line">    naturalSizeFirst = <span class="built_in">CGSizeMake</span>(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);</span><br><span class="line">    naturalSizeSecond = <span class="built_in">CGSizeMake</span>(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果视频不是以纵向模式拍摄的，我们可以使用它们的自然尺寸。</span></span><br><span class="line">    naturalSizeFirst = firstVideoAssetTrack.naturalSize;</span><br><span class="line">    naturalSizeSecond = secondVideoAssetTrack.naturalSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> renderWidth, renderHeight;</span><br><span class="line"><span class="comment">// 将 renderWidth 和 renderHeight 设置为两个视频宽度和高度的最大值。</span></span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.width &gt; naturalSizeSecond.width) &#123;</span><br><span class="line">    renderWidth = naturalSizeFirst.width;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderWidth = naturalSizeSecond.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.height &gt; naturalSizeSecond.height) &#123;</span><br><span class="line">    renderHeight = naturalSizeFirst.height;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderHeight = naturalSizeSecond.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.renderSize = <span class="built_in">CGSizeMake</span>(renderWidth, renderHeight);</span><br><span class="line"><span class="comment">// 将帧持续时间设置为适当的值（每秒30帧）</span></span><br><span class="line">mutableVideoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="6-导出-Composition"><a href="#6-导出-Composition" class="headerlink" title="6. 导出 Composition"></a>6. 导出 Composition</h3><p>最后一步是导出 composition 到一个视频文件中，并将视频文件保存到用户相册中。使用 AVAssetExportSession 创建一个新的视频文件，并指定要输出的文件目录的 URL。使用 ALAssetsLibrary 可以将生成的视频文件保存到用户相册中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个staic dataFormatter</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *kDateFormatter;</span><br><span class="line"><span class="keyword">if</span> (!kDateFormatter) &#123;</span><br><span class="line">    kDateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    kDateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;</span><br><span class="line">    kDateFormatter.timeStyle = <span class="built_in">NSDateFormatterShortStyle</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 composition 创建导出会话，并将预设preset设置为最高质量。</span></span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc] initWithAsset:mutableComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];</span><br><span class="line"><span class="comment">// 设置输出URL</span></span><br><span class="line">exporter.outputURL = [[[[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:@YES error:<span class="literal">nil</span>] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]]] URLByAppendingPathExtension:<span class="built_in">CFBridgingRelease</span>(UTTypeCopyPreferredTagWithClass((<span class="built_in">CFStringRef</span>)<span class="built_in">AVFileTypeQuickTimeMovie</span>, kUTTagClassFilenameExtension))];</span><br><span class="line"><span class="comment">// 设置输出文件类型为 QuickTime movie.</span></span><br><span class="line">exporter.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line">exporter.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;</span><br><span class="line">exporter.videoComposition = mutableVideoComposition;</span><br><span class="line"><span class="comment">// 异步导出composition到一个视频文件，导出完成后，保存到相机胶卷</span></span><br><span class="line">[exporter exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];</span><br><span class="line">            <span class="keyword">if</span> ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) &#123;</span><br><span class="line">                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:<span class="literal">NULL</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="四、静态图片和视频捕捉"><a href="#四、静态图片和视频捕捉" class="headerlink" title="四、静态图片和视频捕捉"></a>四、静态图片和视频捕捉</h1><h2 id="核心类概述-1"><a href="#核心类概述-1" class="headerlink" title="核心类概述"></a>核心类概述</h2><p>通过输入 (inputs) 和输出 (outputs) 对象对设备 (比如摄像头或麦克风) 采集到的数据进行管理。使用 AVCaptureSession 对象协调 inputs 和 outputs 之间的数据流。</p><ul><li>AVCaptureDevice 代表输入设备，比如摄像头和麦克风。</li><li>AVCaptureInput 的子类用来对输入设备进行配置。</li><li>AVCaptureOutput 的子类用来管理输出的数据（输出结果为图片或者视频）。</li><li>AVCaptureSession 用来协调 inputs 和 outputs 之间的数据流<ul><li>可以为单个session配置多个输入和输出，即使这个会话正在运行时也可以。</li><li>可以向会话发送消息以启动和停止数据流。</li></ul></li><li>AVCaptureVideoPreviewLayer预览图层(CALayer 的子类)，可以展示摄像头正在采集的画面预览。</li></ul><p>对于一个 session，可以配置多个 inputs 和 outputs，如图所示：</p><img src="/images/avf/captureOverview_2x.png" alt="captureOverview_2x" style="zoom:70%;" /><p>对于大部分的应用而言，这已经足够了。但是有些情况下，会涉及到如何表示一个 inputs 的多个端口 (ports)，以及这些 ports 如何连接到 outputs。</p><p>Capture session 中：</p><ul><li>一个 Inputs(AVCaptureInput实例) 包含一个或多个 input ports(AVCaptureInputPort)。比如输入设备可能同时提供音频和视频数据。</li><li>一个 Outputs(AVCaptureOutput实例) 可以从一个或多个源接收数据，比如 AVCaptureMovieFileOutput 可以同时接收视频和音频数据。</li><li>使用 AVCaptureConnection 对象来定义一组 AVCaptureInputPort 对象和单个 AVCaptureOutput 之间的映射。</li></ul><p>如下图所示，当在 session 中添加一个 input 或 output 时，session 会为所有可匹配的 inputs 和 outputs 之前生成 connections(AVCaptureConnection)。</p><img src="/images/avf/captureDetail_2x.png" alt="captureDetail_2x" style="zoom:70%;" /><p>可以使用一个 connection 来开启或关闭一个 input 或 output 数据流。也可以使用 connection 监控一个 audio 频道的功率平均值和峰值。</p><blockquote><p>注意：媒体捕获不支持同时使用呢 iOS 设备上的前置和后置摄像头捕获。</p></blockquote><h2 id="4-1-使用AVCaptureSession协调数据流"><a href="#4-1-使用AVCaptureSession协调数据流" class="headerlink" title="4.1 使用AVCaptureSession协调数据流"></a>4.1 使用AVCaptureSession协调数据流</h2><p>AVCaptureSession 对象是管理数据捕获的中央协调对象，协调从输入设备到输出的数据流。</p><h3 id="4-1-1-AVCaptureSession-类"><a href="#4-1-1-AVCaptureSession-类" class="headerlink" title="4.1.1 AVCaptureSession 类"></a>4.1.1 AVCaptureSession 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureSession</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canSetSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVCaptureSessionPreset</span> sessionPreset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureInput</span> *&gt; *inputs; <span class="comment">//__kindof表示可以是当前类或子类</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)removeInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ouputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)removeOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addInputWithNoConnections:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addOutputWithNoConnections:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connections 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *connections;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)addConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)removeConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置Capture Session</span></span><br><span class="line">- (<span class="keyword">void</span>)beginConfiguration;</span><br><span class="line">- (<span class="keyword">void</span>)commitConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isRunning) <span class="built_in">BOOL</span> running;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isInterrupted) <span class="built_in">BOOL</span> interrupted;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usesApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresCaptureDeviceForWideColor;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startRunning;</span><br><span class="line">- (<span class="keyword">void</span>)stopRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> masterClock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 session 中添加采集设备并对 output 进行配置之后，可以向 session 发送 startRunning 消息开始采集, 发送 stopRunning 消息停止采集。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line"><span class="comment">// Add inputs and outputs.</span></span><br><span class="line">[session startRunning];</span><br></pre></td></tr></table></figure><h3 id="4-1-2-配置-Capture-Session"><a href="#4-1-2-配置-Capture-Session" class="headerlink" title="4.1.2 配置 Capture Session"></a>4.1.2 配置 Capture Session</h3><p>使用 session 的 <code>sessionPreset</code> 属性指定图片质量和分辨率，perset是一个常数，系统定义了多种配置，需注意，有些配置只有在特定设备上才生效。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSessionPresetHigh</span>      <span class="comment">// 最高级别, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetMedium</span>    <span class="comment">// 中等, 适合 Wi-Fi 分享. 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetLow</span>       <span class="comment">// 低, 适合 3G 分享, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset640x480</span>   <span class="comment">// 640x480, VGA</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset1280x720</span>  <span class="comment">// 1280x720, 720p HD</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetPhoto</span>     <span class="comment">// 全屏照片, 不能用来作为输出视频</span></span><br></pre></td></tr></table></figure><p>在设置一个 preset 之前，需要判断设备是否支持该 preset 值:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要设置一个更高分辨率的 preset，或者在 session 运行时修改一些配置，需要在 beginConfiguration 和 commitConfiguration 之间完成修改。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an existing capture device.移除一个采集设备</span></span><br><span class="line"><span class="comment">// Add a new capture device.         添加一个采集设备</span></span><br><span class="line"><span class="comment">// Reset the preset.                 修改sessionPreset属性</span></span><br><span class="line"><span class="comment">// 单独配置 input 和 output 的属性</span></span><br><span class="line"></span><br><span class="line">[session commitConfiguration]; <span class="comment">// 在调用commitConfiguration 方法之后，改变会一起生效。</span></span><br></pre></td></tr></table></figure><p>beginConfiguration 和 commitConfiguration 方法确保所有的修改作为一个group被整体应用，减少对预览状态的影响。</p><h3 id="4-1-3-监听-Capture-Session-的状态"><a href="#4-1-3-监听-Capture-Session-的状态" class="headerlink" title="4.1.3 监听 Capture Session 的状态"></a>4.1.3 监听 Capture Session 的状态</h3><p>可以监听 session 的状态，例如何时开始运行、停止运行、被中断等。</p><ul><li>当发生运行时错误，会发送 AVCaptureSessionRuntimeErrorNotification 通知。</li><li>可以使用Session的<code>running</code>属性判断当前的运行状态，<code>interrupted</code>属性则可以判断当前是否中断。这两者都可以通过 KVO 进行监听，并且通知都在主线程中发送。</li></ul><h3 id="4-1-4-补充-AVCaptureConnection-类"><a href="#4-1-4-补充-AVCaptureConnection-类" class="headerlink" title="4.1.4 补充: AVCaptureConnection 类"></a>4.1.4 补充: AVCaptureConnection 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureConnection</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *inputPorts;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureOutput</span> *output;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoPreviewLayer</span> *videoPreviewLayer;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> active;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureAudioChannel</span> *&gt; *audioChannels;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mirroring镜像</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoMirroring;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> videoMirrored;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyAdjustsVideoMirroring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持更改方向</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoOrientation;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoOrientation</span> videoOrientation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示应如何处理流经过connect的隔行扫描的视频</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoFieldMode;   </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVVideoFieldMode</span> videoFieldMode; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频最大的尺寸和裁剪因子</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> videoMaxScaleAndCropFactor;</span><br><span class="line"><span class="comment">// 此属性仅适用于涉及视频的连接。可以将此属性设置为介于 1.0 到 videoMaxScaleAndCropFactor 值之间的值。以1.0为因子，图像是其原始大小。系数大于 1.0 时，图像按系数缩放并中心裁剪为其原始尺寸。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> videoScaleAndCropFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定模式。此属性仅适用于涉及视频的 AVCaptureConnection 实例。启用视频稳定会在视频捕获管道中引入额外的延迟，并且可能会消耗更多的系统内存，具体取决于稳定模式和格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoStabilization;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> preferredVideoStabilizationMode;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> activeVideoStabilizationMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置捕获管道以传递相机内在信息(如成像参数等)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliverySupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliveryEnabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="4-2-使用AVCaptureDevice表示输入设备"><a href="#4-2-使用AVCaptureDevice表示输入设备" class="headerlink" title="4.2 使用AVCaptureDevice表示输入设备"></a>4.2 使用AVCaptureDevice表示输入设备</h2><p><a href="https://developer.apple.com/reference/avfoundation/avcapturedevice">AVCaptureDevice</a> 是对实际的物理捕捉设备的抽象，物体捕捉设备向 <code>AVCaptureSession</code> 提供数据。每个 <code>AVCaptureDevice</code> 对象代表一个实际的输入设备，例如前摄像头或后摄像头、或麦克风。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 获取当前可用的捕捉设备，而且可以获取捕捉设备的设备特性</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devices API_DEPRECATED(<span class="string">&quot;Use AVCaptureDeviceDiscoverySession instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 找出对应类型的可用设备</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devicesWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">AVCaptureDevice</span> *)defaultDeviceWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">                                                       </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceDiscoverySession</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *devices;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当前的可用设备的状态可能会发生改变：</p><ul><li>当前使用的输入设备可能会变为不可用状态 (如果设备被另外一个应用使用)；</li><li>也可能会有新的设备变为可用状态 (被其他应用释放)。</li></ul><p>注册接收 <code>AVCaptureDeviceWasConnectedNotification</code> 和 <code>AVCaptureDeviceWasDisconnectedNotification</code> 通知可以得知可用设备列表的变化。</p><p>使用捕捉输入(AVCaptureInput)将输入设备添加到 capture session 中。</p><h3 id="4-2-1-设备特性"><a href="#4-2-1-设备特性" class="headerlink" title="4.2.1 设备特性"></a>4.2.1 设备特性</h3><p>可以获取一个设备的设备特性，比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个可用的捕获设备都有一个唯一的 ID</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *uniqueID;</span><br><span class="line"><span class="comment">// 型号ID，同一型号的所有设备具有相同的、唯一的标识符。例如，两个相同的iPhone机型内置的摄像头的型号ID将是相同的。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *modelID;</span><br><span class="line"><span class="comment">// 本地化、人类可读的名称。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *localizedName;</span><br><span class="line"><span class="comment">// 制造商名称</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *manufacturer;</span><br><span class="line"><span class="comment">// 传输类型(e.g. USB, PCI, etc).</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int32_t transportType;</span><br><span class="line"><span class="comment">// 设备是否能捕捉 给定类型的媒体。如是否能采集音频、视频等</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="comment">// 设备是否可以在使用给定预设配置的capture Session中使用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)supportsAVCaptureSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br></pre></td></tr></table></figure><p>当要提供一个可用的捕捉设备列表给用户进行选择时，获取展示出设备的位置以及名称 (比如前摄像头或后摄像头) 拥有更好的用户体验。</p><p>下图展示了前摄像头 (<code>AVCaptureDevicePositionFront</code>) 和后摄像头 (<code>AVCaptureDevicePositionBack</code>):</p><blockquote><p>注意：媒体捕获不支持同时捕获 iOS 设备上的前置和后置摄像头。</p></blockquote><img src="/images/avf/cameras_2x.png" alt="img" style="zoom:70%;" /><p>下面的代码遍历了所有的可用设备并打印其名称，如果是视频设备，则打印其位置:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devices];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Device name: %@&quot;</span>, [device localizedName]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([device hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ([device position] == <span class="built_in">AVCaptureDevicePositionBack</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : front&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以获取设备的 model ID 以及 unique ID。</p><h3 id="4-2-2-设备捕捉时的参数设置"><a href="#4-2-2-设备捕捉时的参数设置" class="headerlink" title="4.2.2 设备捕捉时的参数设置"></a>4.2.2 设备捕捉时的参数设置</h3><p>不同的设备之间具备不同的能力，比如一些设备支持不同的对焦或闪光灯模式，某些设备还支持兴趣点对焦。</p><p>下面的代码示例了如何找出一个具有手电筒模式和并支持给定capture session preset 的视频输入设备：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *torchDevices = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line">    [<span class="keyword">if</span> ([device hasTorch] &amp;&amp;</span><br><span class="line">         [device supportsAVCaptureSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) &#123;</span><br><span class="line">        [torchDevices addObject:device];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到了多个符合要求的设备，你可能需要让用户选择其中的某一个设备，这时可以使用 localizedName 属性获取设备的描述信息.</p><p>可以用类似的方式实现各种不同的捕捉设置。框架预定义了一些常量用来代表特定的捕捉模式，你可以使用这些常量以便于判断设备是否支持特定的模式。</p><p>在大部分情况下，可以通过属性值的监听，获悉设备特性的变化。</p><p>任何情况下，在改变设备的捕捉参数配置之前，都应该先锁定设备，详见下节设备的配置。</p><blockquote><p>兴趣点对焦模式和兴趣点曝光模式是互斥的，正如对焦模式和曝光模式也是互斥的一样</p></blockquote><h4 id="1-对焦模式-Focus分类"><a href="#1-对焦模式-Focus分类" class="headerlink" title="1. 对焦模式(Focus分类)"></a>1. 对焦模式(Focus分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFocus</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> lockingFocusWithCustomLensPositionSupported;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的对焦模式，然后设置属性 focusMode 改变对焦模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFocusModeSupported:(<span class="built_in">AVCaptureFocusMode</span>)focusMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 三种对焦模式：</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeLocked: 固定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeAutoFocus: 自动对焦然后锁定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeContinuousAutoFocus: 根据需要连续自动对焦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFocusMode</span> focusMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点对焦模式. 通过下面方法判断是否支持该模式, 然后使用属性 focusPointOfInterest 设置焦点. </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> focusPointOfInterestSupported;</span><br><span class="line"><span class="comment">// 赋值CGPoint。无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> focusPointOfInterest;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在对焦中。可以使用 KVO 监听该属性获取对焦开始与结束的通知。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingFocus;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> autoFocusRangeRestrictionSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureAutoFocusRangeRestriction</span> autoFocusRangeRestriction;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> smoothAutoFocusSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> smoothAutoFocusEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensPosition;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureLensPositionCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setFocusModeLockedWithLensPosition:(<span class="keyword">float</span>)lensPosition completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> minimumFocusDistance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置对焦模式的示例代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isFocusModeSupported:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> autofocusPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setFocusPointOfInterest:autofocusPoint];</span><br><span class="line">    [currentDevice setFocusMode:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-曝光模式-Exposure分类"><a href="#2-曝光模式-Exposure分类" class="headerlink" title="2. 曝光模式(Exposure分类)"></a>2. 曝光模式(Exposure分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceExposure</span>)</span></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的曝光模式，然后设置属性 exposureMode 改变曝光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExposureModeSupported:(<span class="built_in">AVCaptureExposureMode</span>)exposureMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 两种曝光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeContinuousAutoExposure: 自动调整曝光等级</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeLocked: 固定曝光等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureExposureMode</span> exposureMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点曝光模式. 通过下面的方法判断是否支持该模式, 然后使用属性 exposurePointOfInterest 设置曝光点.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exposurePointOfInterestSupported;</span><br><span class="line"><span class="comment">// 无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> exposurePointOfInterest;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> activeMaxExposureDuration;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在改变曝光设置中. 可以使用 KVO 监听该属性获取开始设置曝光模式与结束设置曝光模式的通知.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingExposure;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensAperture;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> exposureDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> ISO;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CMTime</span> <span class="built_in">AVCaptureExposureDurationCurrent</span>;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureISOCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureModeCustomWithDuration:(<span class="built_in">CMTime</span>)duration ISO:(<span class="keyword">float</span>)ISO completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetOffset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> minExposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> maxExposureTargetBias;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureExposureTargetBiasCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureTargetBias:(<span class="keyword">float</span>)bias completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置曝光模式的示例代码如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isExposureModeSupported:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> exposurePoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setExposurePointOfInterest:exposurePoint];</span><br><span class="line">    [currentDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-闪光模式-Flash分类"><a href="#3-闪光模式-Flash分类" class="headerlink" title="3. 闪光模式(Flash分类)"></a>3. 闪光模式(Flash分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFlash</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasFlash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashAvailable) <span class="built_in">BOOL</span> flashAvailable API_AVAILABLE(macos(<span class="number">10.15</span>), ios(<span class="number">5.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashActive) <span class="built_in">BOOL</span> flashActive API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -isFlashScene instead.&quot;</span>, ios(<span class="number">5.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(macos) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="comment">// 判断是否支持某个闪光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFlashModeSupported:(<span class="built_in">AVCaptureFlashMode</span>)flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -supportedFlashModes instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置闪光灯模式</span></span><br><span class="line"><span class="comment"> 三种闪光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeAuto: 根据环境亮度自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFlashMode</span> flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoSettings.flashMode instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="4-手电筒模式-Torch分类"><a href="#4-手电筒模式-Torch分类" class="headerlink" title="4. 手电筒模式(Torch分类)"></a>4. 手电筒模式(Torch分类)</h4><p>手电筒模式下，闪光灯会一直处于开启状态，用于视频捕捉。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceTorch</span>)</span></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasTorch;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> torchLevel;</span><br><span class="line"><span class="comment">// 判断是否支持某个手电筒模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTorchModeSupported:(<span class="built_in">AVCaptureTorchMode</span>)torchMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置手电筒模式，三种手电筒模式:</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeAuto: 根据需要自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureTorchMode</span> torchMode;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setTorchModeOnWithLevel:(<span class="keyword">float</span>)torchLevel error:(<span class="built_in">NSError</span> ** _Nullable)outError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于一个有手电筒的设备，手电筒只有在设备与一个运行中的 capture session 进行了关联后才可以设置为开启。</p><h4 id="5-白平衡-WhiteBalance分类"><a href="#5-白平衡-WhiteBalance分类" class="headerlink" title="5. 白平衡(WhiteBalance分类)"></a>5. 白平衡(WhiteBalance分类)</h4><p>有两种白平衡模式:</p><ul><li><code>AVCaptureWhiteBalanceModeLocked</code>: 固定参数的白平衡</li><li><code>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance</code>: 由相机自动调整白平衡参数</li></ul><p>使用方法 isWhiteBalanceModeSupported: 判断设备是否支持给定的白平衡模式，然后通过属性 whiteBalanceMode 设置白平衡模式。</p><p>使用属性 adjustingWhiteBalance 判断当前是否正在修改白平衡模式。可以使用 KVO 监听该属性获取开始设置白平衡模式与结束设置白平衡模式的通知。</p><h4 id="6-视频稳定性-AVCaptureConnection"><a href="#6-视频稳定性-AVCaptureConnection" class="headerlink" title="6. 视频稳定性(AVCaptureConnection)"></a>6. 视频稳定性(AVCaptureConnection)</h4><p>依赖于某些特殊的硬件设备，视频会有更好的稳定性。但并不支持所有的视频格式和分辨率。</p><p>开启电影视频稳定性特性在捕捉视频时可能会增加延迟。</p><p>使用属性 videoStabilizationEnabled 可以判断当前是否使用了视频稳定性特性。</p><p>属性 enablesVideoStabilizationWhenAvailable 可以在设备支持的情况下自动开启视频稳定性特性，该属性默认为关闭状态。</p><h4 id="7-设置设备方向-AVCaptureConnection"><a href="#7-设置设备方向-AVCaptureConnection" class="headerlink" title="7. 设置设备方向(AVCaptureConnection)"></a>7. 设置设备方向(AVCaptureConnection)</h4><p>可以在<code>AVCaptureConnection</code>上指定期望的设备方向，用来设置输出时<code>AVCaptureOutput</code>(<code>AVCaptureMovieFileOutput</code>、<code>AVCaptureStillImageOutput</code>和<code>AVCaptureVideoDataOutput</code>) 的设备方向。</p><p>使用属性<code>AVCaptureConnectionsupportsVideoOrientation</code>判断设备是否支持修改视频方向，使用属性<code>videoOrientation</code>指定一个方向。下面的代码将<code>AVCaptureConnection</code>的方向设置为<code>AVCaptureVideoOrientationLandscapeLeft</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *captureConnection = &lt;#A capture connection#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureConnection isVideoOrientationSupported]) &#123;</span><br><span class="line">    <span class="built_in">AVCaptureVideoOrientation</span> orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>;</span><br><span class="line">    [captureConnection setVideoOrientation:orientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-设备配置"><a href="#4-2-3-设备配置" class="headerlink" title="4.2.3 设备配置"></a>4.2.3 设备配置</h3><p>要修改设备的捕捉参数相关的属性，首先需要使用方法 <a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1387810-lockforconfiguration">lockForConfiguration:</a> 锁定设备，这样可以避免与其他应用的设置产生冲突。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeLocked</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">        device.focusMode = <span class="built_in">AVCaptureFocusModeLocked</span>;</span><br><span class="line">        [device unlockForConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Respond to the failure as appropriate.</span></span><br></pre></td></tr></table></figure><p>只有当你需要设备属性保持不变时，您应该保持设备锁定。不必要地保持设备锁定可能会降低共享设备的其他应用程序的捕获质量。</p><h3 id="4-2-4-切换设备"><a href="#4-2-4-切换设备" class="headerlink" title="4.2.4 切换设备"></a>4.2.4 切换设备</h3><p>某些场景下可能需要允许用户切换输入设备，比如前后摄像头。为了避免卡顿，可以重新配置正在运行的 session，使用 <a href="https://developer.apple.com/reference/avfoundation/avcapturesession/1389174-beginconfiguration">beginConfiguration</a> 和 <a href="https://developer.apple.com/reference/avfoundation/avcapturesession/1388173-commitconfiguration">commitConfiguration</a> 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = &lt;#A capture session#&gt;;</span><br><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line">[session removeInput:frontFacingCameraDeviceInput];</span><br><span class="line">[session addInput:backFacingCameraDeviceInput];</span><br><span class="line"></span><br><span class="line">[session commitConfiguration];</span><br></pre></td></tr></table></figure><p>当最后的<code>commitConfiguration</code>方法被调用时，所有的设置变化会一起执行，确保了切换的流畅性.</p><h2 id="4-3-使用AVCaptureInput添加输入设备"><a href="#4-3-使用AVCaptureInput添加输入设备" class="headerlink" title="4.3 使用AVCaptureInput添加输入设备"></a>4.3 使用AVCaptureInput添加输入设备</h2><p>要把一个 capture device 添加到 capture session 中，需要使用 AVCaptureDeviceInput(抽象类<code>AVCaptureInput</code>的子类)。</p><p>Capture device input 管理设备的端口。</p><h3 id="4-3-1-AVCaptureInput-与-Port"><a href="#4-3-1-AVCaptureInput-与-Port" class="headerlink" title="4.3.1 AVCaptureInput 与 Port"></a>4.3.1 AVCaptureInput 与 Port</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInputPort</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureInput</span> *input;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> formatDescription;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> clock;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDeviceType</span> sourceDeviceType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDevicePosition</span> sourceDevicePosition;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *ports;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceInput</span> : <span class="title">AVCaptureInput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)deviceInputWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>)<span class="built_in">AVCaptureDevice</span> *device;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> unifiedAutoExposureDefaultsEnabled;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)portsWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType </span><br><span class="line">                     sourceDeviceType:(<span class="built_in">AVCaptureDeviceType</span>)sourceDeviceType </span><br><span class="line">                 sourceDevicePosition:(<span class="built_in">AVCaptureDevicePosition</span>)sourceDevicePosition;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> videoMinFrameDurationOverride;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-添加输入设备-AVCaptureSession"><a href="#4-3-2-添加输入设备-AVCaptureSession" class="headerlink" title="4.3.2 添加输入设备(AVCaptureSession)"></a>4.3.2 添加输入设备(AVCaptureSession)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!input) &#123;</span><br><span class="line">    <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 addInput: 添加输入，使用 canAddInput: 判断该设备是否可以被添加到 session 中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *captureDeviceInput = &lt;#Get a capture device input#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddInput:captureDeviceInput]) &#123;</span><br><span class="line">    [captureSession addInput:captureDeviceInput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>AVCaptureInput</code>对象包含一个或多个数据流。例如，输入设备可能同时提供音频和视频数据。</p><p>每个 AVCaptureInputPort 对象代表一个媒体数据流。</p><p>Capture session 使用一个<code>AVCaptureConnection</code> 对象定义一组 <code>AVCaptureInputPort</code> 和一个 <code>AVCaptureOutput</code> 之间的映射关系。</p><h2 id="4-4-使用AVCaptureOutput输出数据"><a href="#4-4-使用AVCaptureOutput输出数据" class="headerlink" title="4.4 使用AVCaptureOutput输出数据"></a>4.4 使用AVCaptureOutput输出数据</h2><p>要从 capture session 中输出数据，可以向其添加一个或多个 outputs(AVCaptureOutput 的子类)，比如:</p><ul><li>AVCaptureFileOutput: 输出为文件</li><li>AVCaptureMovieFileOutput 电影文件<ul><li>AVCaptureAudioFileOutput 音频文件</li></ul></li><li>AVCaptureVideoDataOutput: 可以逐帧处理捕捉到的视频</li><li>AVCaptureAudioDataOutput: 可以处理捕捉到的音频数据</li><li>AVCaptureStillImageOutput: 输出为静态图片</li><li>…等</li></ul><p>使用方法 addOutput: 在 capture session 中添加 outputs。使用方法 canAddOutput: 判断是否可以添加一个给定的 output。可以根据需要在 session 运行过程中添加或移除一个 output。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *movieOutput = &lt;#Create and configure a movie output#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddOutput:movieOutput]) &#123;</span><br><span class="line">    [captureSession addOutput:movieOutput];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-1-输出为视频文件-AVCaptureFileOutput"><a href="#4-4-1-输出为视频文件-AVCaptureFileOutput" class="headerlink" title="4.4.1 输出为视频文件(AVCaptureFileOutput)"></a>4.4.1 输出为视频文件(AVCaptureFileOutput)</h3><p>使用 AVCaptureMovieFileOutput 将视频数据保存为一个本地文件（AVCaptureMovieFileOutput 是 AVCaptureFileOutput 的一个具体子类，它定义了许多基本行为）。</p><h4 id="1-三个输出文件类"><a href="#1-三个输出文件类" class="headerlink" title="1. 三个输出文件类"></a>1. 三个输出文件类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureFileOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputDelegate</span>&gt; delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputFileURL;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line">- (<span class="keyword">void</span>)stopRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recordingPaused __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)pauseRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)resumeRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> recordedDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int64_t recordedFileSize;</span><br><span class="line"><span class="comment">// 最大录制时长</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> maxRecordedDuration;  </span><br><span class="line"><span class="comment">// 最大的录制文件大小</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t maxRecordedFileSize;</span><br><span class="line"><span class="comment">// 磁盘应保持的最低容量。当达到限制时停止录制，并且调用 captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error: 委托方法，传出错误。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t minFreeDiskSpaceLimit;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为视频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureMovieFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> movieFragmentInterval;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedOutputSettingsKeysForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettingsForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">BOOL</span>)recordsVideoOrientationAndMirroringChangesAsMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setRecordsVideoOrientationAndMirroringChanges:(<span class="built_in">BOOL</span>)doRecordChanges asMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isPrimaryConstituentDeviceSwitchingBehaviorForRecordingEnabled) <span class="built_in">BOOL</span> primaryConstituentDeviceSwitchingBehaviorForRecordingEnabled;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimaryConstituentDeviceSwitchingBehaviorForRecording:(<span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span>)switchingBehavior restrictedSwitchingBehaviorConditions:(<span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span>)restrictedSwitchingBehaviorConditions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span> primaryConstituentDeviceSwitchingBehaviorForRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span> primaryConstituentDeviceRestrictedSwitchingBehaviorConditionsForRecording;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为音频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)availableOutputFileTypes;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL outputFileType:(<span class="built_in">AVFileType</span>)fileType recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以对 movie file output 的参数进行配置，比如最大的录制时长、最大的录制文件大小。如果设备磁盘空间不足的话，还可以阻止用户进行视频录制。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc] init];</span><br><span class="line"><span class="built_in">CMTime</span> maxDuration = &lt;#Create a <span class="built_in">CMTime</span> to represent the maximum duration#&gt;;</span><br><span class="line">aMovieFileOutput.maxRecordedDuration = maxDuration;</span><br><span class="line">aMovieFileOutput.minFreeDiskSpaceLimit = &lt;#An appropriate minimum given the quality of the movie format and the duration#&gt;;</span><br></pre></td></tr></table></figure><p>输出的分辨率和码率依赖于 capture session 的<code>sessionPreset</code> 属性，常用的视频编码格式是 H.264，音频编码格式是 AAC。实际的编码格式可能由于设备不同有所差异。</p><h4 id="2-两个协议"><a href="#2-两个协议" class="headerlink" title="2. 两个协议"></a>2. 两个协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件录制协议。在单个文件记录过程中的各个阶段，通知外部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputRecordingDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didStartRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didPauseRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didResumeRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output willFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出协议。用于监听和控制媒体文件输出的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)captureOutputShouldProvideSampleAccurateRecordingStart:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 开始录制</span></span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = &lt;#A file URL that identifies the output location#&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 使用方法下面的方法开始录制一段 QuickTime 视频，方法需要传入一个本地文件的 URL 和一个录制的 delegate。</span></span><br><span class="line"><span class="comment"> - 传入的本地 URL 不能是已经存在的文件，因为 movie file output 不会对已存在的文件进行重写，而且对传入的文件路径，程序必须有写入权限。</span></span><br><span class="line"><span class="comment"> - 传入的 delegate 必须遵循 AVCaptureFileOutputRecordingDelegate 协议，且必须实现其require方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;#The delegate#&gt;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 确保文件写入成功，在下面协议方法中不仅需要检测 error, 还需要对 error 中的 user info 字典中的 AVErrorRecordingSuccessfullyFinishedKey进行判断。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput</span><br><span class="line">        didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL</span><br><span class="line">        fromConnections:(<span class="built_in">NSArray</span> *)connections</span><br><span class="line">        error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> recordedSuccessfully = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([error code] != noErr) &#123;</span><br><span class="line">        <span class="comment">// A problem occurred: Find out if the recording was successful.</span></span><br><span class="line">        <span class="keyword">id</span> value = [[error userInfo] objectForKey:<span class="built_in">AVErrorRecordingSuccessfullyFinishedKey</span>];</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            recordedSuccessfully = [value boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Continue as appropriate...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以需要对<code>AVErrorRecordingSuccessfullyFinishedKey</code>进行判断，是因为即使写入过程中抛出了一个 error，文件也可能被成功写入了。抛出的 error 可能是因为：</p><ul><li>达到了一些设置的限制约束条件，比如：<ul><li>AVErrorMaximumDurationReached</li><li>AVErrorMaximumFileSizeReached</li></ul></li><li>其他可能导致录制中断的情况如下:<ul><li>磁盘已满 - AVErrorDiskFull</li><li>与录制的设备的连接断开 - AVErrorDeviceWasDisconnected</li><li>session 中断 (比如有电话接入) - AVErrorSessionWasInterrupted</li></ul></li></ul><h4 id="4-在文件中添加元数据-AVMetadataItem"><a href="#4-在文件中添加元数据-AVMetadataItem" class="headerlink" title="4. 在文件中添加元数据(AVMetadataItem)"></a>4. 在文件中添加元数据(AVMetadataItem)</h4><p>可在任何时刻对文件的元数据 (metadata) 进行设置，哪怕是在录制过程中。一个 file output 的 metadata 由一个 AVMetadataItem 对象的数组来表示。可以使用其可变子类 AVMutableMetadataItem 创建自定义的 metadata。</p><img src="/images/avf/avmetadataItem.jpg" alt="avmetadataItem" style="zoom:75%;" /><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *existingMetadataArray = aMovieFileOutput.metadata;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *newMetadataArray = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (existingMetadataArray) &#123;</span><br><span class="line">    newMetadataArray = [existingMetadataArray mutableCopy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    newMetadataArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];</span><br><span class="line">item.keySpace = <span class="built_in">AVMetadataKeySpaceCommon</span>;</span><br><span class="line">item.key = <span class="built_in">AVMetadataCommonKeyLocation</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CLLocation</span> *location - &lt;#The location to set#&gt;;</span><br><span class="line">item.value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%+08.4lf%+09.4lf/&quot;</span></span><br><span class="line">    location.coordinate.latitude, location.coordinate.longitude];</span><br><span class="line"></span><br><span class="line">[newMetadataArray addObject:item];</span><br><span class="line"></span><br><span class="line">aMovieFileOutput.metadata = newMetadataArray;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-处理视频帧-AVCaptureVideoDataOutput"><a href="#4-4-2-处理视频帧-AVCaptureVideoDataOutput" class="headerlink" title="4.4.2 处理视频帧(AVCaptureVideoDataOutput)"></a>4.4.2 处理视频帧(AVCaptureVideoDataOutput)</h3><h4 id="1-AVCaptureVideoDataOutput类"><a href="#1-AVCaptureVideoDataOutput类" class="headerlink" title="1. AVCaptureVideoDataOutput类"></a>1. AVCaptureVideoDataOutput类</h4><p>AVCaptureVideoDataOutput 使用代理模式来对视频帧进行处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoDataOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理，此外还需要传入代理方法被调用的队列。</span></span><br><span class="line"><span class="comment">// 必须使用串行队列确保视频帧按照录制顺序被传递到代理方法中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setSampleBufferDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt;)sampleBufferDelegate queue:(<span class="built_in">dispatch_queue_t</span>)sampleBufferCallbackQueue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt; sampleBufferDelegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> sampleBufferCallbackQueue;</span><br><span class="line"><span class="comment">// 自定义输出格式. videoSettings属性是一个字典类型, 目前只支持kCVPixelBufferPixelFormatTypeKey.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">null_resettable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *)availableVideoCodecTypesForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForVideoCodecType:(<span class="built_in">AVVideoCodecType</span>)videoCodecType assetWriterOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line"><span class="comment">// 获取支持的视频像素格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableVideoCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// 获取支持的视频编解码格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line"><span class="comment">// 最小帧率。降低帧率来确保有足够的时间对视频帧进行处理</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> minFrameDuration API_DEPRECATED(<span class="string">&quot;Use AVCaptureConnection&#x27;s videoMinFrameDuration property instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 如果data output queue is阻塞，是否丢弃帧(当我们处理静止图像时)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysDiscardsLateVideoFrames;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresOutputBufferDimensions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> deliversPreviewSizedOutputBuffers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从video data输出样本缓冲区，并监控其状态的方法。</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureVideoDataOutputSampleBufferDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 通知已写入新的视频帧。视频帧由 CMSampleBufferRef 类型表示。默认情况下，buffers 被设置为当前设备相机效率最高的格式。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didDropSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection API_AVAILABLE(ios(<span class="number">6.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置队列时，可以使用队列修改视频帧传递处理的优先级，参见示例 <a href="https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190">SquareCam</a>。</p><p>Core Graphics 和 OpenGL 都很好的兼容了<code>BGRA</code>格式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =</span><br><span class="line">                @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput.videoSettings = newSettings;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果data output queue is阻塞，则丢弃(当我们处理静止图像时)</span></span><br><span class="line">[videoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="literal">YES</span>];)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建串行队列</span></span><br><span class="line">videoDataOutputQueue = dispatch_queue_create(<span class="string">&quot;VideoDataOutputQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">[videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:videoDataOutputQueue];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#The Capture Session#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( [captureSession canAddOutput:videoDataOutput] )</span><br><span class="line">     [captureSession addOutput:videoDataOutput];</span><br></pre></td></tr></table></figure><h4 id="2-视频处理时的性能考虑"><a href="#2-视频处理时的性能考虑" class="headerlink" title="2. 视频处理时的性能考虑"></a>2. 视频处理时的性能考虑</h4><p>导出视频应当尽可能的使用低分辨率，高分辨率会消耗额外的 CPU 和电量。</p><p>确保在代理方法 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中处理 sample buffer 时不要使用耗时操作，如果处理占用时间过长，AV Foundation 会停止向代理方法中传递视频帧，而且会停止其他的输出，比如 preview layer 上的预览。</p><p>可以设置 capture video data 的属性 minFrameDuration 通过降低帧率来确保有足够的时间对视频帧进行处理。</p><p>将属性 alwaysDiscardsLateVideoFrames 设置为<code>YES</code>(默认值) 的话，后面的视频帧将会被丢弃，而不是排队等待处理。如果你并不介意延迟，而且需要处理所有的视频帧，也可以将<code>alwaysDiscardsLateVideoFrames</code>设置为<code>NO</code>(即使如此, 也可能会出现掉帧的情况)。</p><h3 id="4-4-3-捕捉静态图像-AVCaptureStillImageOutput"><a href="#4-4-3-捕捉静态图像-AVCaptureStillImageOutput" class="headerlink" title="4.4.3 捕捉静态图像(AVCaptureStillImageOutput)"></a>4.4.3 捕捉静态图像(AVCaptureStillImageOutput)</h3><p>使用 AVCaptureStillImageOutput 捕捉带元数据的静态图像。图片的分辨率依赖于 session 的 preset 设置和具体的硬件设备。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureStillImageOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="comment">// 可以指定需要的图片格式等</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="comment">// ouput支持的图像像素格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableImageDataCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// ouput支持的图像编解码格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableImageDataCodecTypes;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyEnablesStillImageStabilizationWhenAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> highResolutionStillImageOutputEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> capturingStillImage;</span><br><span class="line">- (<span class="keyword">void</span>)captureStillImageAsynchronouslyFromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">CMSampleBufferRef</span> _Nullable imageDataSampleBuffer, <span class="built_in">NSError</span> * _Nullable error))handler <span class="built_in">NS_SWIFT_DISABLE_ASYNC</span>;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)jpegStillImageNSDataRepresentation:(<span class="built_in">CMSampleBufferRef</span>)jpegSampleBuffer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="1-像素和编码格式"><a href="#1-像素和编码格式" class="headerlink" title="1. 像素和编码格式"></a>1. 像素和编码格式</h4><p>不同的设备支持不同的图片格式。</p><p>可以使用 availableImageDataCVPixelFormatTypes、availableImageDataCodecTypes 查询。使用outputSettings 设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureStillImageOutput *stillImageOutput &#x3D; [[AVCaptureStillImageOutput alloc] init];</span><br><span class="line">NSDictionary *outputSettings &#x3D; @&#123; AVVideoCodecKey : AVVideoCodecJPEG&#125;;</span><br><span class="line">[stillImageOutput setOutputSettings:outputSettings];</span><br></pre></td></tr></table></figure><p>如果需要的是 JPEG 图片，则不要指定压缩格式。相反，应该让 still image output 进行压缩 (因为它是硬件加速的)。可以使用 jpegStillImageNSDataRepresentation: 获取 NSData对象，且无需重新压缩数据，即使你修改了图像的元数据。</p><h4 id="2-捕捉图片"><a href="#2-捕捉图片" class="headerlink" title="2. 捕捉图片"></a>2. 捕捉图片</h4><p>使用方法 captureStillImageAsynchronouslyFromConnection:completionHandler: 捕捉图片。</p><ul><li>第一个参数是需要捕捉的 connection，需要判断当前的 connection 中哪个 input 正在采集视频。</li><li>第二个参数是一个有两个参数的<code>block</code>：<ul><li>一个包含图像数据的<code>CMSampleBuffer</code>类型</li><li>一个是 NSError 对象。Sample buffer 自身包含了元数据，比如 EXIF 信息字典，可以对这些元数据进行修改。</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *videoConnection = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureConnection</span> *connection <span class="keyword">in</span> stillImageOutput.connections) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureInputPort</span> *port <span class="keyword">in</span> [connection inputPorts]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[port mediaType] isEqual:<span class="built_in">AVMediaTypeVideo</span>] ) &#123;</span><br><span class="line">            videoConnection = connection;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (videoConnection) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:</span><br><span class="line">    ^(<span class="built_in">CMSampleBufferRef</span> imageSampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> exifAttachments =</span><br><span class="line">            <span class="built_in">CMGetAttachment</span>(imageSampleBuffer, kCGImagePropertyExifDictionary, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (exifAttachments) &#123;</span><br><span class="line">            <span class="comment">// Do something with the attachments.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue as appropriate.</span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h2 id="4-5-录制预览"><a href="#4-5-录制预览" class="headerlink" title="4.5 录制预览"></a>4.5 录制预览</h2><p>可以提供给用户一个 preview，用来展示正在通过摄像头录制的内容 (使用 preview layer)，或者正在通过麦克风记录的音频内容 (通过监听 audio channel)。</p><h3 id="4-5-1-视频预览-AVCaptureVideoPreviewLayer"><a href="#4-5-1-视频预览-AVCaptureVideoPreviewLayer" class="headerlink" title="4.5.1 视频预览(AVCaptureVideoPreviewLayer)"></a>4.5.1 视频预览(AVCaptureVideoPreviewLayer)</h3><h4 id="1-AVCaptureVideoPreviewLayer类"><a href="#1-AVCaptureVideoPreviewLayer类" class="headerlink" title="1. AVCaptureVideoPreviewLayer类"></a>1. AVCaptureVideoPreviewLayer类</h4><p>使用 AVCaptureVideoPreviewLayer 可以进行视频预览。 <code>AVCaptureVideoPreviewLayer</code>是<code>CALayer</code>的子类. 进行视频预览不需要设置任何的 output 对象。</p><p>大体上，video preview layer 的性质与<code>CALayer</code>类似。你可以对图像进行缩放，向操作其他任何 layer 一样进行 transformations，rotations 等操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoPreviewLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">AVCaptureSession</span> *session;</span><br><span class="line">- (<span class="keyword">void</span>)setSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureConnection</span> *connection;</span><br><span class="line"><span class="comment">/* 指示图层如何在其范围内显示视频内容。(为啥叫重力模式？)</span></span><br><span class="line"><span class="comment">   Preview layer 支持三种重力模式</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspect: 保持视频款高比, 当视频内容不能铺满屏幕时, 不足的部分使用黑色背景进行填充.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspectFill: 保持视频款高比, 但是会铺满整个屏幕, 必要时会对视频内容进行裁剪.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResize: 拉伸视频内容铺满屏幕, 可能导致图像变形.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> previewing;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)captureDevicePointOfInterestForPoint:(<span class="built_in">CGPoint</span>)pointInLayer;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)pointForCaptureDevicePointOfInterest:(<span class="built_in">CGPoint</span>)captureDevicePointOfInterest;</span><br><span class="line">- (<span class="built_in">CGRect</span>)metadataOutputRectOfInterestForRect:(<span class="built_in">CGRect</span>)rectInLayerCoordinates;</span><br><span class="line">- (<span class="built_in">CGRect</span>)rectForMetadataOutputRectOfInterest:(<span class="built_in">CGRect</span>)rectInMetadataOutputCoordinates;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">AVMetadataObject</span> *)transformedMetadataObjectForMetadataObject:(<span class="built_in">AVMetadataObject</span> *)metadataObject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用 AVCaptureVideoDataOutput 类可以在视频展示给用户预览之前对视频进行处理。</p><p>与 capture output 不同，一个 video preview layer 会强引用与其相关联的 session。这是为了确保在进行视频预览时 session 不会被销毁。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">CALayer</span> *viewLayer = &lt;#Get a layer from the view <span class="keyword">in</span> which you want to present the preview#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession];</span><br><span class="line">[viewLayer addSublayer:captureVideoPreviewLayer];</span><br></pre></td></tr></table></figure><h4 id="2-预览时使用点击聚焦功能"><a href="#2-预览时使用点击聚焦功能" class="headerlink" title="2. 预览时使用点击聚焦功能"></a>2. 预览时使用点击聚焦功能</h4><p>在 preview layer 上实现点击聚焦功能时，需要注意视频方向、视频重力模式以及可能预览设置了视频镜像。参见代码示例 <a href="https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112">AVCam-iOS: Using AVFoundation to Capture Images and Movies</a>.</p><h3 id="4-5-2-展示声音等级-AVCaptureAudioChannel"><a href="#4-5-2-展示声音等级-AVCaptureAudioChannel" class="headerlink" title="4.5.2 展示声音等级(AVCaptureAudioChannel)"></a>4.5.2 展示声音等级(AVCaptureAudioChannel)</h3><p>要在 capture connection 中检测声音的均值和峰值，可以使用 AVCaptureAudioChannel 对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioChannel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> averagePowerLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> peakHoldLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> volume;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>声音等级不能使用 KVO 的方式获取，所以需要根据界面更新的需求定时进行轮询 (比如每秒 10 次)。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureAudioDataOutput</span> *audioDataOutput = &lt;#Get the audio data output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *connections = audioDataOutput.connections;</span><br><span class="line"><span class="keyword">if</span> ([connections count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There should be only one connection to an AVCaptureAudioDataOutput.</span></span><br><span class="line">    <span class="built_in">AVCaptureConnection</span> *connection = [connections objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *audioChannels = connection.audioChannels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureAudioChannel</span> *channel <span class="keyword">in</span> audioChannels) &#123;</span><br><span class="line">        <span class="keyword">float</span> avg = channel.averagePowerLevel;</span><br><span class="line">        <span class="keyword">float</span> peak = channel.peakHoldLevel;</span><br><span class="line">        <span class="comment">// Update the level meter user interface.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-示例-捕捉视频帧为UIImage对象"><a href="#4-6-示例-捕捉视频帧为UIImage对象" class="headerlink" title="4.6 示例: 捕捉视频帧为UIImage对象"></a>4.6 示例: 捕捉视频帧为UIImage对象</h2><p>接下来的代码简单示例了如何捕捉视频，并将捕捉到的视频帧转换为 UIImage 对象:</p><ul><li>创建<code>AVCaptureSession</code>对象</li><li>找到合适类型的<code>AVCaptureDevice</code>对象进行输入</li><li>为设备创建<code>AVCaptureDeviceInput</code>对象</li><li>创建<code>AVCaptureVideoDataOutput</code>对象获取视频帧</li><li>实现<code>AVCaptureVideoDataOutput</code>的代理</li><li>实现一个方法将接收到的<code>CMSampleBuffer</code>转换为<code>UIImage</code></li></ul><blockquote><p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)config &#123;</span><br><span class="line">    <span class="comment">// 1. 创建和配置 Capture Session，用来协调 input 和 output 之间的数据流。</span></span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPresetMedium</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建和配置 Device 和 Device Input。AVCaptureDevic表示采集设备，AVCaptureInput用来配置 采集设备的端口(一台设备有一个或多个端口)。通常使用默认配置的capture input</span></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =  <span class="comment">//如果找不到合适的设备，error不为空</span></span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    [session addInput:input];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建和配置 Video Data Output。使用 AVCaptureVideoDataOutput处理未压缩的视频帧。</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    [session addOutput:output];</span><br><span class="line">    output.videoSettings =</span><br><span class="line">                    @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;; <span class="comment">//配置像素格式</span></span><br><span class="line">    output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>); <span class="comment">//最小帧率。将帧率限制为15fps（1/15 sec）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;MyQueue&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 提供串行队列. 在此队列上回调</span></span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 实现 Sample Buffer 代理方法。注意该方法是在指定的队列上调用的。如果要更新UI，必须在主线程上。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将转换为 UIImage 的操作代码参见 [Converting CMSampleBuffer to a UIImage Object](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/06_MediaRepresentations.html#//apple_ref/doc/uid/TP40010188-CH2-SW4).</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">    <span class="comment">// Add your code here that uses the image.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 配置 capture session 之后，需要确保应用有访问相机的权限.</span></span><br><span class="line">- (<span class="keyword">void</span>)checkAccess &#123;</span><br><span class="line">  <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line">  [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (granted)&#123;</span><br><span class="line">          <span class="comment">//Granted access to mediaType</span></span><br><span class="line">          [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;AVCam!&quot;</span></span><br><span class="line">                                      message:<span class="string">@&quot;AVCam doesn&#x27;t have permission to use Camera, please change privacy settings&quot;</span></span><br><span class="line">                                     delegate:<span class="keyword">self</span></span><br><span class="line">                            cancelButtonTitle:<span class="string">@&quot;OK&quot;</span></span><br><span class="line">                            otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                  [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 开始和停止</span></span><br><span class="line"><span class="comment">// 当获取到相应的访问权限之后，可以使用 startRunning 方法开始录制。startRunning 会阻塞线程，所以需要异步调用，以免阻塞主线程。</span></span><br><span class="line">[session startRunning];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 stopRunning 可以停止录制.</span></span><br><span class="line">[session stopRunning];</span><br></pre></td></tr></table></figure><h2 id="4-7-高帧率视频捕捉"><a href="#4-7-高帧率视频捕捉" class="headerlink" title="4.7 高帧率视频捕捉"></a>4.7 高帧率视频捕捉</h2><p>iOS 7.0 在选定的硬件上引入了高帧率视频捕获支持（也称为“SloMo”视频）。完整的 AVFoundation 框架支持高帧率内容。</p><p>可以使用 AVCaptureDeviceFormat 类确定设备的捕获能力。此类具有返回支持的媒体类型、帧速率、视野、最大缩放系数、是否支持视频稳定等的方法。</p><ul><li>捕捉：支持每秒 60 帧 (fps) 、720p（1280 x 720 像素）分辨率，包括视频稳定和可丢弃的 P 帧（H264 编码电影的一项功能，即使在较慢和较旧的硬件上也可以流畅地播放电影。 )</li><li>播放：增强了对慢速和快速播放的音频支持，允许音频的时间音高可以在更慢或更快的速度下保存。</li><li>编辑：完全支持可变 compositions 中的缩放编辑。</li><li>导出：支持 60 fps 影片时，导出提供两个选项。可以保留可变帧速率、慢动作或快动作，或者将电影转换为任意较慢的帧速率，例如每秒 30 帧。</li></ul><p>SloPoke 示例代码演示了 AVFoundation 对快速视频捕获的支持、确定硬件是否支持高帧率视频捕获、使用各种速率和时间间距算法进行播放以及编辑（包括为部分合成设置时间比例）。</p><h3 id="4-7-1-播放"><a href="#4-7-1-播放" class="headerlink" title="4.7.1 播放"></a>4.7.1 播放</h3><p>AVPlayer 的实例通过设置 setRate: 方法值自动管理大部分播放速度。该值用作播放速度的乘数。值 1.0 会导致正常播放，0.5 会以半速播放，5.0 会比正常播放快五倍，依此类推。</p><p>AVPlayerItem 对象支持 audioTimePitchAlgorithm 属性（指示缩放音频编辑时，音频音高的处理算法）。此属性允许您使用 Time Pitch Algorithm Settings 常量指定在以各种帧速率播放电影时如何播放音频。</p><p>下表显示了支持的时间音高算法、质量、算法是否导致音频匹配特定的帧速率，以及每种算法支持的帧速率范围。</p><table><thead><tr><th align="left">Time pitch algorithm</th><th align="left">Quality</th><th align="left">Snaps to specific frame rate</th><th align="left">Rate range</th></tr></thead><tbody><tr><td align="left">AVAudioTimePitchAlgorithmLowQualityZeroLatency(低质量零延迟)</td><td align="left">低质量，适用于快进、快退或低质量语音。</td><td align="left"><code>YES</code></td><td align="left">0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0 rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmTimeDomain(时域)</td><td align="left">质量适中，计算成本较低，适用于语音。</td><td align="left"><code>NO</code></td><td align="left">0.5–2x rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmSpectral(光谱)</td><td align="left">最高质量，最昂贵的计算，保留原始项目的音高。</td><td align="left"><code>NO</code></td><td align="left">1/32–32 rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmVarispeed(变速)</td><td align="left">无需音高校正的高质量播放。</td><td align="left"><code>NO</code></td><td align="left">1/32–32 rates.</td></tr></tbody></table><h3 id="4-7-2-编辑"><a href="#4-7-2-编辑" class="headerlink" title="4.7.2 编辑"></a>4.7.2 编辑</h3><p>编辑时，您使用 AVMutableComposition 类来构建临时编辑。</p><ul><li>使用类方法 composition 创建一个新的 AVMutableComposition 实例。</li><li>使用 insertTimeRange:ofAsset:atTime:error: 方法插入视频资产。</li><li>使用 scaleTimeRange:toDuration: 设置部分 composition 的时间比例。</li></ul><h3 id="4-7-3-导出"><a href="#4-7-3-导出" class="headerlink" title="4.7.3 导出"></a>4.7.3 导出</h3><p>导出 60 fps 视频使用 AVAssetExportSession 类来导出资产。可以使用两种技术导出内容：</p><ul><li>使用 AVAssetExportPresetPassthrough 预设来避免重新编码电影。它使用标记为 60 fps 部分、减速部分或加速部分的媒体部分重新定时媒体。</li><li>使用恒定帧速率导出以获得最大的播放兼容性。将视频合成的 frameDuration 属性设置为 30 fps。还可以通过设置导出会话的 audioTimePitchAlgorithm 属性来指定时间音高。</li></ul><h3 id="4-7-4-录制"><a href="#4-7-4-录制" class="headerlink" title="4.7.4 录制"></a>4.7.4 录制</h3><p>使用 AVCaptureMovieFileOutput 类捕获高帧率视频，该类自动支持高帧率录制。它将自动选择正确的 H264 音高电平和比特率。</p><p>要进行自定义录制，您必须使用 AVAssetWriter 类，这需要一些额外的设置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assetWriterInput.expectsMediaDataInRealTime=<span class="literal">YES</span>；<span class="comment">// input是否应针对实时源调整其对媒体数据的处理</span></span><br></pre></td></tr></table></figure><p>此设置确保捕获可以跟上传入的数据。</p><h1 id="五、Asset的读、写、重编码"><a href="#五、Asset的读、写、重编码" class="headerlink" title="五、Asset的读、写、重编码"></a>五、Asset的读、写、重编码</h1><blockquote><p>Asset  → AssetReader → AssetReaderOutput → 内存 → AssetWriteInput → AssetWrite → 文件URL</p></blockquote><p>可以使用AVAssetExportSession 、 <em>AVAssetReader</em> 、<em>AVAssetWriter</em> 对象，完成一些的音视频资源操作需求，比如：</p><ul><li>可以通过一个导出会话 (<em>export session</em>)，将一个已存在的 asset 进行重新编码为，一些已经预设置好的常用格式 (commonly-used presets)。</li><li>协同使用 <em>AVAssetReader</em> 和 <em>AVAssetWriter</em> 对象，可以实现更多的自定义设置，如可以选择将哪些 track 输出到文件中，对资源进行修改。<ul><li>在需要对 asset 内容进行操作时使用<code>AVAssetReader</code>。例如，需要读取 audio track 绘制音频波形图.。</li><li>在需要将媒体 (比如 sample buffers 或者静态图像) 转换为一个 asset 时，使用<code>AVAssetWriter</code>。</li></ul></li></ul><p>注意：</p><ul><li>这两个类不适用于实时处理。</li><li><code>AVAssetReader</code>不能用来读取 HTTP 直播流这样的实时资源。</li><li>如果在实时数据处理 (比如 AVCaptureOutput) 中使用了<code>AVAssetWriter</code>，需要将<code>AVAssetWriter</code>的属性 expectsMediaDataInRealTime 设置为<code>YES</code>，这样可以保证以正确的顺序写入文件。</li></ul><h2 id="5-1-读取Asset-AVAssetReader"><a href="#5-1-读取Asset-AVAssetReader" class="headerlink" title="5.1 读取Asset(AVAssetReader)"></a>5.1 读取Asset(AVAssetReader)</h2><h3 id="AVAssetReader-和-Output-类"><a href="#AVAssetReader-和-Output-类" class="headerlink" title="AVAssetReader 和 Output 类"></a>AVAssetReader 和 Output 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReader</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetReaderStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetReaderOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line"><span class="comment">//开始读取</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)startReading;</span><br><span class="line">- (<span class="keyword">void</span>)cancelReading;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>每个<code>AVAssetReader</code>对象只能被关联到一个 asset，但是这个 asset 可能包含多个 track。因此，在开始读取之前，需要为 asset reader配置一个 AVAssetReaderOutput 的子类来设置媒体数据的读取方式。</p><p><code>AVAssetReaderOutput</code>有三个子类可以用来读取 asset：AVAssetReaderTrackOutput、AVAssetReaderAudioMixOutput、AVAssetReaderVideoCompositionOutput。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 AVAssetReader 读取通用媒体类型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// 是否输出样本数据的副本。默认值为YES。</span></span><br><span class="line"><span class="comment">// 可以通过将值设置为 NO 来禁用默认行为，注意此时只能引用，而不能修改它们，因为修改共享缓冲区的行为是未定义的。</span></span><br><span class="line"><span class="comment">// 如果不需要修改样本数据，禁用复制可能会提高性能。如果你打算修改它返回的有样本数据，置为YES是合适的。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysCopiesSampleData;</span><br><span class="line"><span class="comment">// 复制下一个样本缓冲区</span></span><br><span class="line">- (<span class="built_in">CMSampleBufferRef</span>)copyNextSampleBuffer <span class="built_in">CF_RETURNS_RETAINED</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> (<span class="title">AVAssetReaderOutputRandomAccess</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsRandomAccess;</span><br><span class="line">- (<span class="keyword">void</span>)resetForReadingTimeRanges:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)timeRanges;</span><br><span class="line">- (<span class="keyword">void</span>)markConfigurationAsFinal;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 AVAssetReader 的 AVAsset 的单个 AVAssetTrack 读取媒体数据。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderTrackOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderTrackOutputWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetTrack</span> *track;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取由 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTrack 中的音频混合产生的音频样本。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderAudioMixOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderAudioMixOutputWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *audioTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioMix</span> *audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取已从 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTracks 中的帧合成在一起的视频帧。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderVideoCompositionOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderVideoCompositionOutputWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *videoTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVVideoComposition</span> *videoComposition;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositor;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-1-1-创建-AVAssetReader"><a href="#5-1-1-创建-AVAssetReader" class="headerlink" title="5.1.1 创建 AVAssetReader"></a>5.1.1 创建 AVAssetReader</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 AVAssetReader 对象需要一个 asset 对象</span></span><br><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">AVAsset</span> *someAsset = &lt;#<span class="built_in">AVAsset</span> that you want to read#&gt;;</span><br><span class="line"><span class="built_in">AVAssetReader</span> *assetReader = [<span class="built_in">AVAssetReader</span> assetReaderWithAsset:someAsset error:&amp;outError];</span><br><span class="line"><span class="comment">// 需要检查 assetReader 是否创建成功, 如果失败, error 会包含相关的错误信息.</span></span><br><span class="line"><span class="built_in">BOOL</span> success = (assetReader != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><h3 id="5-1-2-设置-AVAssetReaderOutput"><a href="#5-1-2-设置-AVAssetReaderOutput" class="headerlink" title="5.1.2 设置 AVAssetReaderOutput"></a>5.1.2 设置 AVAssetReaderOutput</h3><p>成功创建 assetReader 后，至少需要设置一个 output 来接收读取的媒体数据。确保 output 的属性 alwaysCopiesSampleData 被设置为<code>NO</code>，这样能提升性能。本章所有的实例代码中，该属性都设置为<code>NO</code>。</p><h4 id="1-AVAssetReaderTrackOutput"><a href="#1-AVAssetReaderTrackOutput" class="headerlink" title="1. AVAssetReaderTrackOutput"></a>1. AVAssetReaderTrackOutput</h4><p>如果只是需要从一个或多个 track 中读取数据并修改其格式，那么可以使用<code>AVAssetReaderTrackOutput</code>。</p><p>要解压一个 audio track 为 Linear PCM，需要进行如下设置:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *localAsset = assetReader.asset;</span><br><span class="line"><span class="comment">// Get the audio track to read.</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTrack = [[localAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Decompression settings for Linear PCM</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// Create the output with the audio track and decompression settings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *trackOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:trackOutput])</span><br><span class="line">    [assetReader addOutput:trackOutput];</span><br></pre></td></tr></table></figure><blockquote><p>要以存储时的格式读取数据，将参数<code>outputSettings</code>设置为<code>nil</code>.</p></blockquote><h4 id="2-AVAssetReaderAudioMixOutput"><a href="#2-AVAssetReaderAudioMixOutput" class="headerlink" title="2. AVAssetReaderAudioMixOutput"></a>2. AVAssetReaderAudioMixOutput</h4><p>对于使用 AVAudioMix 和 AVVideoComposition 处理过的 asset，需要使用<code>AVAssetReaderAudioMixOutput</code> 和 <code>AVAssetReaderVideoCompositionOutput</code>进行读取。</p><p>通常，当从 AVComposition 对象中读取数据时，会使用到这些 output 对象。</p><p>使用一个<code>AVAssetReaderAudioMixOutput</code>对象，可以读取 asset 中的多个 audio track。下面的代码展示了如何使用 asset 中所有的 audio track 创建一个<code>AVAssetReaderAudioMixOutput</code>对象，解压缩 audio track 为 Linear PCM，并为 output 设置音频混合方式 (audio mix)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAudioMix</span> *audioMix = &lt;#<span class="string">&quot;一个 AVAudioMix，指定如何混合来自 AVAsset 的音轨&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 对象初始化的。</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的音轨</span></span><br><span class="line"><span class="built_in">NSArray</span> *audioTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line"><span class="comment">// 获取线性 PCM 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// 使用音轨和解压缩设置创建音频混合输出。</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *audioMixOutput = [<span class="built_in">AVAssetReaderAudioMixOutput</span> assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">audioMixOutput.audioMix = audioMix;</span><br><span class="line"><span class="comment">// 将output添加到reader</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:audioMixOutput])</span><br><span class="line">    [assetReader addOutput:audioMixOutput];</span><br></pre></td></tr></table></figure><blockquote><p>设置参数<code>audioSettings</code> 为 <code>nil</code>，将返回未被压缩的样本数据。对<code>AVAssetReaderVideoCompositionOutput</code>也一样。</p></blockquote><h4 id="3-AVAssetReaderVideoCompositionOutput"><a href="#3-AVAssetReaderVideoCompositionOutput" class="headerlink" title="3. AVAssetReaderVideoCompositionOutput"></a>3. AVAssetReaderVideoCompositionOutput</h4><p><code>AVAssetReaderVideoCompositionOutput</code> 的使用方法大致与<code>AVAssetReaderAudioMixOutput</code> 相同，可以从 asset 中读取多个 video track。下面的代码示例了如何从多个 video track 中读取数据，并解压为 ARGB:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVVideoComposition</span> *videoComposition = &lt;#<span class="string">&quot;一个 AVVideoComposition，指定如何合成来自 AVAsset 的视频轨道&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 初始化的</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的视频轨道。</span></span><br><span class="line"><span class="built_in">NSArray</span> *videoTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="comment">// ARGB 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123; (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary] &#125;;</span><br><span class="line"><span class="comment">// 使用视频轨道和解压缩设置创建视频合成输出</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *videoCompositionOutput = [<span class="built_in">AVAssetReaderVideoCompositionOutput</span> assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">videoCompositionOutput.videoComposition = videoComposition;</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:videoCompositionOutput])</span><br><span class="line">    [assetReader addOutput:videoCompositionOutput];</span><br></pre></td></tr></table></figure><h3 id="5-1-3-读取-Asset-中的媒体数据"><a href="#5-1-3-读取-Asset-中的媒体数据" class="headerlink" title="5.1.3 读取 Asset 中的媒体数据"></a>5.1.3 读取 Asset 中的媒体数据</h3><p>按需设置 outputs 之后，调用 asset reader 的方法 startReading 开始读取数据。然后使用方法 copyNextSampleBuffer 从 output 中开始检索、获取媒体数据。示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the asset reader up.</span></span><br><span class="line">[<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line"><span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">while</span> (!done)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Copy the next sample buffer from the reader output.</span></span><br><span class="line">  <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">  <span class="keyword">if</span> (sampleBuffer)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Do something with sampleBuffer here.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">    sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Find out why the asset reader output couldn&#x27;t copy another sample buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">      <span class="comment">// Handle the error here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The asset reader output has read all of its samples.</span></span><br><span class="line">      done = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-写入Asset-AVAssetWriter"><a href="#5-2-写入Asset-AVAssetWriter" class="headerlink" title="5.2 写入Asset(AVAssetWriter)"></a>5.2 写入Asset(AVAssetWriter)</h2><h3 id="AVAssetWriter-和-Input-类"><a href="#AVAssetWriter-和-Input-类" class="headerlink" title="AVAssetWriter 和 Input 类"></a>AVAssetWriter 和 Input 类</h3><p><a href="https://developer.apple.com/reference/avfoundation/avassetwriter">AVAssetWriter</a> 将多个来源的数据以指定格式写入到单个文件中。Asset writer 并不与一个特定的 asset 相关联，但必须与要创建的输出文件相关联。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriter</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithContentType:(UTType *)outputContentType <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">AVFileType</span> outputFileType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaType</span>&gt; *availableMediaTypes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetWriterStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldOptimizeForNetworkUse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *directoryForTemporaryFiles;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetWriterInput</span> *&gt; *inputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canApplyOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="built_in">BOOL</span>)startWriting;</span><br><span class="line">- (<span class="keyword">void</span>)startSessionAtSourceTime:(<span class="built_in">CMTime</span>)startTime;</span><br><span class="line">- (<span class="keyword">void</span>)endSessionAtSourceTime:(<span class="built_in">CMTime</span>)endTime;</span><br><span class="line">- (<span class="keyword">void</span>)cancelWriting;</span><br><span class="line">- (<span class="built_in">BOOL</span>)finishWriting API_DEPRECATED_WITH_REPLACEMENT(<span class="string">&quot;finishWritingWithCompletionHandler:&quot;</span>;</span><br><span class="line">- (<span class="keyword">void</span>)finishWritingWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))handler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.....还有一些分类，此处不再列出.....</span></span><br><span class="line">                                                      </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVAssetWriterDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType segmentReport:(<span class="built_in">AVAssetSegmentReport</span> *)segmentReport;</span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由于一个 asset writer 可以从多个来源获取数据，所以需要为每个要写入的 track 创建对应的 AVAssetWriterInput 对象。</p><ul><li>接收 CMSampleBufferRef 类型的数据，使用<code>AVAssetWriterInput</code>对象</li><li>如果想要添加 CVPixelBufferRef 类型的数据，可以使用 AVAssetWriterInputPixelBufferAdaptor。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriterInput</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readyForMoreMediaData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> expectsMediaDataInRealTime;</span><br><span class="line">- (<span class="keyword">void</span>)requestMediaDataWhenReadyOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)appendSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer;</span><br><span class="line">- (<span class="keyword">void</span>)markAsFinished;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-2-1-创建-AVAssetWriter"><a href="#5-2-1-创建-AVAssetWriter" class="headerlink" title="5.2.1 创建 AVAssetWriter"></a>5.2.1 创建 AVAssetWriter</h3><p>创建 AVAssetWriter 对象需要指定一个文件 URL 和文件格式。下面的代码示例了如何初始化一个 AVAssetWriter 用来创建 QuickTime 电影.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">NSURL</span> *outputURL = &lt;#<span class="string">&quot;NSURL对象，表示您要保存视频的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:outputURL</span><br><span class="line">                                                      fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span></span><br><span class="line">                                                         error:&amp;outError];</span><br><span class="line"><span class="built_in">BOOL</span> success = (assetWriter != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-2-设置-AVAssetWriterInput"><a href="#5-2-2-设置-AVAssetWriterInput" class="headerlink" title="5.2.2 设置 AVAssetWriterInput"></a>5.2.2 设置 AVAssetWriterInput</h3><p>要让 AVAssetWriter 能写入媒体数据，必须至少设置一个 asset writer input。</p><h4 id="1-AVAssetWriterInput"><a href="#1-AVAssetWriterInput" class="headerlink" title="1. AVAssetWriterInput"></a>1. AVAssetWriterInput</h4><p>例如要写入<code>CMSampleBufferRef</code>类型的数据，需要使用<code>AVAssetWriterInput</code>。下面的代码示例了将压缩的音频数据写入为 128 kbps 的 AAC 格式:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 将通道布局(channel layout)配置为立体声</span></span><br><span class="line">AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 channel layout 对象转换为 NSData 对象</span></span><br><span class="line"><span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 128 kbps AAC 的压缩设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用压缩设置创建asset writer input，并将媒体类型指定为音频。</span></span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *assetWriterInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:compressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the input to the writer if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetWriter canAddInput:assetWriterInput])</span><br><span class="line">    [assetWriter addInput:assetWriterInput];</span><br></pre></td></tr></table></figure><blockquote><p>只有 asset writer 初始化时<code>fileType</code>为 AVFileTypeQuickTimeMovie，参数<code>outputSettings</code>才能为 nil，意味着写入的文件格式为 QuickTime movie。</p></blockquote><p>使用属性 metadata 和 transform 可以为指定的 track 设置 metadata 和 transform。<em>（注意，需要在开始写入之前设置这两个属性才会生效）</em></p><p>当输入源为 video track 时，可以通过如下方式持有 video track 的原始 transform:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="string">&quot;具有至少一个视频轨道的 AVAsset&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">assetWriterInput.transform = videoAssetTrack.preferredTransform</span><br></pre></td></tr></table></figure><h4 id="2-AVAssetWriterInputPixelBufferAdaptor"><a href="#2-AVAssetWriterInputPixelBufferAdaptor" class="headerlink" title="2. AVAssetWriterInputPixelBufferAdaptor"></a>2. AVAssetWriterInputPixelBufferAdaptor</h4><p>在写入文件时，有时候可能会需要分配一个 pixel buffer，这时可以使用<code>AVAssetWriterInputPixelBufferAdaptor</code>类。为了提高效率，可以直接使用 pixel buffer adaptor 提供的 pixel buffer pool。下面的代码示例了创建了一个 pixel buffer 对象处理 RGB 色域:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixelBufferAttributes = @&#123;</span><br><span class="line">     kCVPixelBufferCGImageCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferCGBitmapContextCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithInt:kCVPixelFormatType_32ARGB]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> *inputPixelBufferAdaptor = [<span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> assetWriterInputPixelBufferAdaptorWithAssetWriterInput:<span class="keyword">self</span>.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];</span><br></pre></td></tr></table></figure><blockquote><p>注意，所有的<code>AVAssetWriterInputPixelBufferAdaptor</code>对象都必须与一个 asset writer input 相关联 。这个 asset writer input 对象必须接收<code>AVMediaTypeVideo</code>类型的数据。</p></blockquote><h3 id="5-2-3-写入媒体数据"><a href="#5-2-3-写入媒体数据" class="headerlink" title="5.2.3 写入媒体数据"></a>5.2.3 写入媒体数据</h3><p>当配置完 asset writer 之后，就可以开始写入数据了。</p><p>下面的代码示例了从一个输入源读取数据并写入所有读取到的数据:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the asset writer for writing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动写入过程</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line"><span class="comment">// 开启一个写入会话 (sample-writing session)。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Asset writer 的所有写入过程都通过这个 session 完成，并且 sesion 的时间范围决定了源媒体数据中哪个时间范围内的数据会被写入到文件中</span></span><br><span class="line"><span class="comment">  例如，只写入源数据的后一半的示例代码如下:</span></span><br><span class="line"><span class="comment">  CMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);</span></span><br><span class="line"><span class="comment">  [self.assetWriter startSessionAtSourceTime:halfAssetDuration];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^&#123;</span><br><span class="line">     <span class="comment">// 表示input是否准备好接受媒体数据。</span></span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取下一个样本缓冲区。</span></span><br><span class="line">          <span class="comment">// copyNextSampleBufferToWrite方法只是一个stub(桩代码/存根)。此存根的位置是您需要插入一些逻辑以返回表示你要写入的媒体数据的 CMSampleBufferRef 对象的位置。Sample buffers 可能来源于一个 asset reader output.</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> nextSampleBuffer = [<span class="keyword">self</span> copyNextSampleBufferToWrite];</span><br><span class="line">          <span class="keyword">if</span> (nextSampleBuffer)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 如果存在，则将下一个样本缓冲区附加到输出文件。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:nextSampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(nextSampleBuffer);</span><br><span class="line">               nextSampleBuffer = <span class="literal">nil</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 假设没有下一个样本缓冲区，意味着样本缓冲区源没有样本并将输入标记为已完成。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>一般情况下，方法 endSessionAtSourceTime: 用来结束写入会话。但是如果文件已经写入完毕，则可以方法 finishWriting 结束写入会话。</p><h2 id="5-3-重编码Assets"><a href="#5-3-重编码Assets" class="headerlink" title="5.3 重编码Assets"></a>5.3 重编码Assets</h2><p>可以搭配使用 asset reader 和 asset writer 进行 asset 之间的转换。相比于使用<code>AVAssetExportSession</code>，使用这些对象可以更好的控制转换细节。例如：</p><ul><li>可以选择导出哪个 track</li><li>可以指定导出的文件格式</li><li>可以在转换过程中修改asset，如指定导出的时间范围。</li></ul><p>下面的代码片段示例了如何从一个 asset reader output 读取数据，并使用 asset writer input 写入这些数据.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个用于读写的串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^&#123;</span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取asset reader output的下一个样本缓冲区</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">          <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If it exists, append this sample buffer to the output file.</span></span><br><span class="line">               <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">               sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Check for errors that may have occurred when appending the new sample buffer.</span></span><br><span class="line">               <span class="keyword">if</span> (!success &amp;&amp; <span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetWriter.error;</span><br><span class="line">                    <span class="comment">//Handle the error.</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">//如果下一个样本缓冲区不存在， 定位asset reader output 无法提供另一个样本缓冲区的原因。</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">                    <span class="comment">//Handle the error here.</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// The asset reader output已经听过所有数据，标记为已完成 </span></span><br><span class="line">                    [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="5-4-示例-Asset-Reader和Writer-重编码-Asset"><a href="#5-4-示例-Asset-Reader和Writer-重编码-Asset" class="headerlink" title="5.4 示例: Asset Reader和Writer 重编码 Asset"></a>5.4 示例: Asset Reader和Writer 重编码 Asset</h2><p>下面的代码简要示例了使用 asset reader 和 writer 对一个 asset 中的第一个 video 和 audio track 进行重新编码并将结果数据写入到一个新文件中.</p><blockquote><p>提示: 为了将注意力集中在核心代码上，这份示例省略了某些内容.</p></blockquote><h3 id="5-4-1-初始化设置"><a href="#5-4-1-初始化设置" class="headerlink" title="5.4.1 初始化设置"></a>5.4.1 初始化设置</h3><p>在创建和配置 asset reader 和 writer 之前，需要进行一些初始化设置。首先需要为读写过程创建三个串行队列.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the main serialization queue. 用于 asset reader 和 writer 的启动、停止和取消。</span></span><br><span class="line"><span class="keyword">self</span>.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwAudioSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw audio serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写音频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwVideoSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw video serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写视频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-2-加载-asset-中的-track，并开始重编码"><a href="#5-4-2-加载-asset-中的-track，并开始重编码" class="headerlink" title="5.4.2 加载 asset 中的 track，并开始重编码."></a>5.4.2 加载 asset 中的 track，并开始重编码.</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.asset = &lt;#<span class="built_in">AVAsset</span> that you want to reencode#&gt;;</span><br><span class="line"><span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.outputURL = &lt;#<span class="built_in">NSURL</span> representing desired output URL <span class="keyword">for</span> file generated by asset writer#&gt;;</span><br><span class="line"><span class="comment">// Asynchronously load the tracks of the asset you want to read.</span></span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:@[<span class="string">@&quot;tracks&quot;</span>] completionHandler:^&#123;</span><br><span class="line">     <span class="comment">// Once the tracks have finished loading, dispatch the work to the main serialization queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// Due to asynchronous nature, check to see if user has already cancelled.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">          <span class="built_in">NSError</span> *localError = <span class="literal">nil</span>;</span><br><span class="line">          <span class="comment">// Check for success of loading the assets tracks.</span></span><br><span class="line">          success = ([<span class="keyword">self</span>.asset statusOfValueForKey:<span class="string">@&quot;tracks&quot;</span> error:&amp;localError] == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.</span></span><br><span class="line">               <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">               <span class="built_in">NSString</span> *localOutputPath = [<span class="keyword">self</span>.outputURL path];</span><br><span class="line">               <span class="keyword">if</span> ([fm fileExistsAtPath:localOutputPath])</span><br><span class="line">                    success = [fm removeItemAtPath:localOutputPath error:&amp;localError];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> setupAssetReaderAndAssetWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> startAssetReaderAndWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:success withError:localError];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>剩下的工作就是实现取消的处理，并实现三个自定义方法.</p><h3 id="5-4-3-初始化-Asset-Reader-和-Writer"><a href="#5-4-3-初始化-Asset-Reader-和-Writer" class="headerlink" title="5.4.3 初始化 Asset Reader 和 Writer"></a>5.4.3 初始化 Asset Reader 和 Writer</h3><p>自定义方法 <code>setupAssetReaderAndAssetWriter</code> 实现了 asset Reader 和 writer 的初始化和配置。在这个示例中：</p><ul><li>audio 先被 asset reader 解压为 Linear PCM，然后被 asset write 压缩为 128 kbps AAC。</li><li>video 被 asset reader 解压为 YUV，然后被 asset writer 压缩为 H.264:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupAssetReaderAndAssetWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Create and initialize the asset reader.</span></span><br><span class="line">     <span class="keyword">self</span>.assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:<span class="keyword">self</span>.asset error:outError];</span><br><span class="line">     <span class="built_in">BOOL</span> success = (<span class="keyword">self</span>.assetReader != <span class="literal">nil</span>);</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader was successfully initialized, do the same for the asset writer.</span></span><br><span class="line">          <span class="keyword">self</span>.assetWriter = [[<span class="built_in">AVAssetWriter</span> alloc] initWithURL:<span class="keyword">self</span>.outputURL fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span> error:outError];</span><br><span class="line">          success = (<span class="keyword">self</span>.assetWriter != <span class="literal">nil</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.</span></span><br><span class="line">          <span class="built_in">AVAssetTrack</span> *assetAudioTrack = <span class="literal">nil</span>, *assetVideoTrack = <span class="literal">nil</span>;</span><br><span class="line">          <span class="built_in">NSArray</span> *audioTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line">          <span class="keyword">if</span> ([audioTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetAudioTrack = [audioTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">          <span class="built_in">NSArray</span> *videoTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">          <span class="keyword">if</span> ([videoTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetVideoTrack = [videoTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetAudioTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderAudioOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderAudioOutput];</span><br><span class="line">               <span class="comment">// Then, set the compression settings to 128kbps AAC and create the asset writer input.</span></span><br><span class="line">               AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">                    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">                    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">                    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">                    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">                    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">                    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">                    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetWriterAudioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterAudioInput];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetVideoTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is a video track to read, set the decompression settings for YUV and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123;</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey     : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderVideoOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderVideoOutput];</span><br><span class="line">               <span class="built_in">CMFormatDescriptionRef</span> formatDescription = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Grab the video format descriptions from the video track and grab the first one if it exists.</span></span><br><span class="line">               <span class="built_in">NSArray</span> *videoFormatDescriptions = [assetVideoTrack formatDescriptions];</span><br><span class="line">               <span class="keyword">if</span> ([videoFormatDescriptions count] &gt; <span class="number">0</span>)</span><br><span class="line">                    formatDescription = (__bridge <span class="built_in">CMFormatDescriptionRef</span>)[formatDescriptions objectAtIndex:<span class="number">0</span>];</span><br><span class="line">               <span class="built_in">CGSize</span> trackDimensions = &#123;</span><br><span class="line">                    .width = <span class="number">0.0</span>,</span><br><span class="line">                    .height = <span class="number">0.0</span>,</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">                    trackDimensions = <span class="built_in">CMVideoFormatDescriptionGetPresentationDimensions</span>(formatDescription, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    trackDimensions = [assetVideoTrack naturalSize];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionSettings = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *cleanAperture = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *pixelAspectRatio = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> cleanApertureFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_CleanAperture);</span><br><span class="line">                    <span class="keyword">if</span> (cleanApertureFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         cleanAperture = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureWidthKey</span>            : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHeightKey</span>           : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHorizontalOffsetKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureVerticalOffsetKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> pixelAspectRatioFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);</span><br><span class="line">                    <span class="keyword">if</span> (pixelAspectRatioFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         pixelAspectRatio = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioHorizontalSpacingKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioVerticalSpacingKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Add whichever settings we could grab from the format description to the compression settings dictionary.</span></span><br><span class="line">                    <span class="keyword">if</span> (cleanAperture || pixelAspectRatio)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="built_in">NSMutableDictionary</span> *mutableCompressionSettings = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">                         <span class="keyword">if</span> (cleanAperture)</span><br><span class="line">                              [mutableCompressionSettings setObject:cleanAperture forKey:<span class="built_in">AVVideoCleanApertureKey</span>];</span><br><span class="line">                         <span class="keyword">if</span> (pixelAspectRatio)</span><br><span class="line">                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:<span class="built_in">AVVideoPixelAspectRatioKey</span>];</span><br><span class="line">                         compressionSettings = mutableCompressionSettings;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Create the video settings dictionary for H.264.</span></span><br><span class="line">               <span class="built_in">NSMutableDictionary</span> *videoSettings = (<span class="built_in">NSMutableDictionary</span> *) @&#123;</span><br><span class="line">                    <span class="built_in">AVVideoCodecKey</span>  : <span class="built_in">AVVideoCodecH264</span>,</span><br><span class="line">                    <span class="built_in">AVVideoWidthKey</span>  : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.width],</span><br><span class="line">                    <span class="built_in">AVVideoHeightKey</span> : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.height]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// Put the compression settings into the video settings dictionary if we were able to grab them.</span></span><br><span class="line">               <span class="keyword">if</span> (compressionSettings)</span><br><span class="line">                    [videoSettings setObject:compressionSettings forKey:<span class="built_in">AVVideoCompressionPropertiesKey</span>];</span><br><span class="line">               <span class="comment">// Create the asset writer input and add it to the asset writer.</span></span><br><span class="line">               <span class="keyword">self</span>.assetWriterVideoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterVideoInput];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-重编码-Asset"><a href="#5-4-4-重编码-Asset" class="headerlink" title="5.4.4 重编码 Asset"></a>5.4.4 重编码 Asset</h3><p>方法<code>startAssetReaderAndWriter</code>负责读取和写入 asset：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)startAssetReaderAndWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">     <span class="comment">// Attempt to start the asset reader.</span></span><br><span class="line">     success = [<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">          *outError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader started successfully, attempt to start the asset writer.</span></span><br><span class="line">          success = [<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               *outError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.</span></span><br><span class="line">          <span class="keyword">self</span>.dispatchGroup = dispatch_group_create();</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is audio to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwAudioSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.audioFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterAudioInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next audio sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderAudioOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterAudioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the audio work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                         <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If we had video to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwVideoSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.videoFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterVideoInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next video sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderVideoOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterVideoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the video work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                         <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set up the notification that the dispatch group will send when the audio and video work have both finished.</span></span><br><span class="line">          dispatch_group_notify(<span class="keyword">self</span>.dispatchGroup, <span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">               <span class="built_in">BOOL</span> finalSuccess = <span class="literal">YES</span>;</span><br><span class="line">               <span class="built_in">NSError</span> *finalError = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// Check to see if the work has finished due to cancellation.</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If so, cancel the reader and writer.</span></span><br><span class="line">                    [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">                    [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If cancellation didn&#x27;t occur, first make sure that the asset reader didn&#x27;t fail.</span></span><br><span class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span>.assetReader status] == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = <span class="literal">NO</span>;</span><br><span class="line">                         finalError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If the asset reader didn&#x27;t fail, attempt to stop the asset writer and check for any errors.</span></span><br><span class="line">                    <span class="keyword">if</span> (finalSuccess)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = [<span class="keyword">self</span>.assetWriter finishWriting];</span><br><span class="line">                         <span class="keyword">if</span> (!finalSuccess)</span><br><span class="line">                              finalError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.</span></span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];</span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Return success here to indicate whether the asset reader and writer were started successfully.</span></span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重编码过程中，为了提升性能，音频处理和视频处理在两个不同队列中进行。但这两个队列在一个 dispatchGroup 中，当每个队列的任务都完成后，会发送通知。判断重新编码结果是否成功。</p><p>最后调用<code>readingAndWritingDidFinishSuccessfully:</code>。</p><h3 id="5-4-5-处理编码结果"><a href="#5-4-5-处理编码结果" class="headerlink" title="5.4.5 处理编码结果"></a>5.4.5 处理编码结果</h3><p>对重编码的结果进行处理并同步到 UI:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)readingAndWritingDidFinishSuccessfully:(<span class="built_in">BOOL</span>)success withError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 如果重新编码过程未成功完成，则asset reader、asset writer都将被取消</span></span><br><span class="line">          [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to failure.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Reencoding was successful, reset booleans.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to success.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-6-取消重编码"><a href="#5-4-6-取消重编码" class="headerlink" title="5.4.6 取消重编码"></a>5.4.6 取消重编码</h3><p>使用多个串行队列，可以很轻松的取消对 asset 的重编码。</p><ul><li>在主序列化队列上，消息被异步发送到每个 asset 重新编码序列化队列，以取消它们的读取和写入。</li><li>当这两个序列化队列完成取消时，调度组向主序列化队列发送通知，其中取消属性设置为 YES。</li></ul><p>可以将下面的代码与 UI 上的 “取消” 按钮关联起来:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Handle cancellation asynchronously, but serialize it with the main queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// If we had audio data to reencode, we need to cancel the audio work.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the audio queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwAudioSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                    <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group since the audio work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the video queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwVideoSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                    <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group, since the video work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set the cancelled Boolean property to YES to cancel any work on the main queue as well.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-AVOutputSettingsAssistant介绍"><a href="#5-5-AVOutputSettingsAssistant介绍" class="headerlink" title="5.5 AVOutputSettingsAssistant介绍"></a>5.5 AVOutputSettingsAssistant介绍</h2><p><a href="https://developer.apple.com/reference/avfoundation/avoutputsettingsassistant">AVOutputSettingsAssistant</a> 类的功能是为 asset reader 或 writer 创建设置信息。这使得设置更简单，特别是在对于具有许多特定预设的高帧率的 H264 视频进行参数设置时。</p><p>下面的代码是<code>AVOutputSettingsAssistant</code>的使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVOutputSettingsAssistant</span> *outputSettingsAssistant = [<span class="built_in">AVOutputSettingsAssistant</span> outputSettingsAssistantWithPreset:&lt;some preset&gt;];</span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> audioFormat = [<span class="keyword">self</span> getAudioFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (audioFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceAudioFormat:(<span class="built_in">CMAudioFormatDescriptionRef</span>)audioFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> videoFormat = [<span class="keyword">self</span> getVideoFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (videoFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceVideoFormat:(<span class="built_in">CMVideoFormatDescriptionRef</span>)videoFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMTime</span> assetMinVideoFrameDuration = [<span class="keyword">self</span> getMinFrameDuration];</span><br><span class="line"><span class="built_in">CMTime</span> averageFrameDuration = [<span class="keyword">self</span> getAvgFrameDuration]</span><br><span class="line"></span><br><span class="line">[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];</span><br><span class="line">[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:&lt;some URL&gt; fileType:[outputSettingsAssistant outputFileType] error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *audioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *videoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeVideo</span> outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];</span><br></pre></td></tr></table></figure><h1 id="六、时间和媒体的表示"><a href="#六、时间和媒体的表示" class="headerlink" title="六、时间和媒体的表示"></a>六、时间和媒体的表示</h1><p>AV Foundation 框架中使用的一些用来代表时间和媒体的底层数据结构来源于 Core Media 框架。</p><h2 id="6-1-时间的表示"><a href="#6-1-时间的表示" class="headerlink" title="6.1 时间的表示"></a>6.1 时间的表示</h2><p>AV Foundation 框架中的时间由一个 Core Media 框架中的数据结构表示.</p><h3 id="6-1-1-用-CMTime-表示一段时间"><a href="#6-1-1-用-CMTime-表示一段时间" class="headerlink" title="6.1.1 用 CMTime 表示一段时间"></a>6.1.1 用 CMTime 表示一段时间</h3><p><a href="https://developer.apple.com/reference/coremedia/cmtime">CMTime</a> 是一个以有理数表示时间的 C 语言结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个 int64_t 类型作为分子，一个 int32_t 类型作为分母。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeValue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> CMTimeScale;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeEpoch</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">CMTimeValuevalue;<span class="comment">/*!&lt; The value of the CMTime. value/timescale = seconds */</span></span><br><span class="line">CMTimeScaletimescale;<span class="comment">/*!&lt; The timescale of the CMTime. value/timescale = seconds. */</span></span><br><span class="line"><span class="comment">// 除了用来表示时间，CMTime还可以用来表示非数值的值：正无穷大(+infinity)，负无穷大(-infinity)，不确定(indefinite)，还可以指示时间是否在某个时间点四舍五入(HasBeenRounded)。</span></span><br><span class="line">  CMTimeFlagsflags;<span class="comment">/*!&lt; The flags, eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity, etc. */</span></span><br><span class="line">  <span class="comment">// 维护了一个纪元数（记数的起算时间）。epoch通常为0，但您可以使用不同的值，例如，在循环中。</span></span><br><span class="line">CMTimeEpochepoch;</span><br><span class="line">&#125; CMTime;</span><br></pre></td></tr></table></figure><p>从概念上来看，timescale (时间段/时间刻度) 描述了一秒中包含多少个时间单元。</p><ul><li>如果 timescale 等于 4，则每个时间单元代表四分之一秒；</li><li>如果果 timescale 等于 10，则每个时间单元代表十分之一秒，以此类推；</li><li>经常使用 600 的 timescale ，因为这是几个常用帧速率的倍数：电影 24 fps、NTSC 30 fps（用于北美和日本的电视）和 PAL 25 fps（用于电视欧洲）。使用 600 的timescale，可以准确地表示这些系统中的任意数量的帧。</li></ul><h4 id="1-CMTime的创建与使用"><a href="#1-CMTime的创建与使用" class="headerlink" title="1. CMTime的创建与使用"></a>1. CMTime的创建与使用</h4><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1400785-cmtimemake">CMTimeMake</a> 或者 <a href="https://developer.apple.com/reference/coremedia/1400797-cmtimemakewithseconds">CMTimeMakeWithSeconds</a> 创建一个时间。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用value和时间刻度的有效 CMTime。 Epoch 隐含为 0。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMake</span>(int64_t value, int32_t timescale);</span><br><span class="line"><span class="comment">// 使用秒数和首选时间刻度生成 CMTime。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMakeWithSeconds</span>(Float64 seconds, int32_t preferredTimescale)</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> time1 = <span class="built_in">CMTimeMake</span>(<span class="number">200</span>, <span class="number">2</span>); <span class="comment">// 200 1/2秒</span></span><br><span class="line"><span class="built_in">CMTime</span> time2 = <span class="built_in">CMTimeMake</span>(<span class="number">400</span>, <span class="number">4</span>); <span class="comment">// 400 1/4秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// time1 和 time2 都代表 100 秒，但使用不同的时间刻度。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTimeCompare</span>(time1, time2) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time1 and time2 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Float64 float64Seconds = <span class="number">200.0</span> / <span class="number">3</span>;</span><br><span class="line"><span class="built_in">CMTime</span> time3 = <span class="built_in">CMTimeMakeWithSeconds</span>(float64Seconds , <span class="number">3</span>); <span class="comment">// 66.66... third-seconds</span></span><br><span class="line">time3 = <span class="built_in">CMTimeMultiply</span>(time3, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//  time3 现在代表 200 秒；接下来减去 time1（100 秒）</span></span><br><span class="line">time3 = <span class="built_in">CMTimeSubtract</span>(time3, time1);</span><br><span class="line"><span class="built_in">CMTimeShow</span>(time3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_COMPARE_INLINE</span>(time2, ==, time3)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time2 and time3 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细信息参见 <a href="https://developer.apple.com/reference/coremedia/1669288-cmtime"><em>CMTime Reference</em></a>.</p><h4 id="2-CMTime-的特殊值与判断宏"><a href="#2-CMTime-的特殊值与判断宏" class="headerlink" title="2. CMTime 的特殊值与判断宏"></a>2. CMTime 的特殊值与判断宏</h4><p>Core Media 框架提供了一些常量:</p><ul><li><code>kCMTimeZero</code></li><li><code>kCMTimeInvalid</code></li><li><code>kCMTimePositiveInfinity</code> </li><li><code>kCMTimeNegativeInfinity</code>。</li></ul><p><code>CMTime</code>结构体能够进行很多操作，比如要判断一个时间是否有效(是否为非数字值)，可以使用一些定义好的宏：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_VALID(time) ((Boolean)(((time).flags &amp; kCMTimeFlags_Valid) != 0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INVALID(time) (! CMTIME_IS_VALID(time))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_POSITIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_PositiveInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NEGATIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_NegativeInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INDEFINITE(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_Indefinite) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NUMERIC(time) ((Boolean)(((time).flags &amp; (kCMTimeFlags_Valid | kCMTimeFlags_ImpliedValueFlagsMask)) == kCMTimeFlags_Valid))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_HAS_BEEN_ROUNDED(time) ((Boolean)(CMTIME_IS_NUMERIC(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_HasBeenRounded) != 0)))</span></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> myTime = &lt;#Get a <span class="built_in">CMTime</span>#&gt;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_IS_INVALID</span>(myTime)) &#123;</span><br><span class="line">    <span class="comment">// Perhaps treat this as an error; display a suitable alert to the user.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能将 CMTime 结构体与<code>kCMTimeZero</code>直接进行比较。</p><h4 id="3-将-CMTime-转换为对象"><a href="#3-将-CMTime-转换为对象" class="headerlink" title="3. 将 CMTime 转换为对象"></a>3. 将 CMTime 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTime，使用方法 <a href="https://developer.apple.com/reference/coremedia/1400845-cmtimecopyasdictionary">CMTimeCopyAsDictionary</a> 和 <a href="https://developer.apple.com/reference/coremedia/1400819-cmtimemakefromdictionary">CMTimeMakeFromDictionary</a> 可以在 CMTime 结构体和<code>CFDictionary</code>类型 (参见 <a href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1400791-cmtimecopydescription">CMTimeCopyDescription</a> 可以获取 CMTime 结构体的字符串描述。</p><h4 id="4-纪元-Epochs"><a href="#4-纪元-Epochs" class="headerlink" title="4. 纪元 (Epochs)"></a>4. 纪元 (Epochs)</h4><p><code>CMTime</code>结构体中的 epoch 通常被设置为 0。但有些场景下，可以用到，比如在循环中，可以使用这个值来区分不同循环次数中的同一个时间点。</p><h3 id="6-1-2-用-CMTimeRange-表示一个时间范围"><a href="#6-1-2-用-CMTimeRange-表示一个时间范围" class="headerlink" title="6.1.2 用 CMTimeRange 表示一个时间范围"></a>6.1.2 用 CMTimeRange 表示一个时间范围</h3><p>CMTimeRange 是一个 C 语言结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CMTime  start;<span class="comment">// 起始时间</span></span><br><span class="line">    CMTime  duration;<span class="comment">// 持续时间</span></span><br><span class="line">&#125; CMTimeRange;</span><br><span class="line"></span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeMake</span><span class="params">(CMTime start, CMTime duration)</span></span>;</span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeFromTimeToTime</span><span class="params">(CMTime start, CMTime end)</span></span>;</span><br></pre></td></tr></table></figure><p>一个时间范围并不包含<code>start</code>加上<code>duration</code>得到的时间。（是个数学上的开区间，不包含后边界）</p><p>使用上面两个方法可以创建一个时间范围，但是存在一些限制:</p><ul><li><code>CMTimeRange</code>不能跨过不同的<code>epoch</code>。</li><li><code>start</code>的<code>epoch</code>值可能不为0，我们只能对<code>start</code>的<code>epoch</code>值相同的 CMTimeRange 进行范围操作(例如 CMTimeRangeGetUnion)。</li><li><code>duration</code>的<code>epoch</code>值应该一直为 0，<code>value</code> 值为非负。</li></ul><h4 id="1-处理-CMTimeRange"><a href="#1-处理-CMTimeRange" class="headerlink" title="1. 处理 CMTimeRange"></a>1. 处理 CMTimeRange</h4><p>Core Media 框架提供了一些一个时间范围操作方法：</p><ul><li>判断一个时间范围是否包含某个时间点或者其他时间范围的方法</li><li>判断两个时间范围是否相同</li><li>对两个时间范围进行交集和并集运算的方法。</li></ul><p>例如，<a href="https://developer.apple.com/reference/coremedia/1462775-cmtimerangecontainstime">CMTimeRangeContainsTime</a>，<a href="https://developer.apple.com/reference/coremedia/1462841-cmtimerangeequal">CMTimeRangeEqual</a>，<a href="https://developer.apple.com/reference/coremedia/1462830-cmtimerangecontainstimerange">CMTimeRangeContainsTimeRange</a> 和 <a href="https://changjianfeishui.gitbooks.io/avfoundation-programming-guide/CMTimeRangeGetUnion">CMTimeRangeGetUnion</a>.</p><p>注意下面的表达式永远返回 false(<em>包前不包后，前闭后开</em>)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTimeRangeContainsTime</span>(range, <span class="built_in">CMTimeRangeGetEnd</span>(range));</span><br></pre></td></tr></table></figure><p>更多相关的详细信息，参见 <a href="https://developer.apple.com/reference/coremedia/1665980-cmtimerange"><em>CMTimeRange Reference</em></a>.</p><h4 id="2-CMTimeRange-的特殊值"><a href="#2-CMTimeRange-的特殊值" class="headerlink" title="2. CMTimeRange 的特殊值"></a>2. CMTimeRange 的特殊值</h4><p>Core Media 提供了两个常量：</p><ul><li>kCMTimeRangeZero：表示空范围</li><li>kCMTimeRangeInvalid：表示无效范围</li></ul><p>可以使用以下这些宏对 CMTimeRange 的特殊值进行判断: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_VALID(range) ((Boolean)(CMTIME_IS_VALID(range.start) &amp;&amp; CMTIME_IS_VALID(range.duration) &amp;&amp; (range.duration.epoch == 0) &amp;&amp; (range.duration.value &gt;= 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INVALID(range) (! CMTIMERANGE_IS_VALID(range))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INDEFINITE(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_IS_INDEFINITE(range.start) || CMTIME_IS_INDEFINITE(range.duration))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_EMPTY(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_COMPARE_INLINE(range.duration, ==, kCMTimeZero))))</span></span><br></pre></td></tr></table></figure><p>不能将 CMTimeRange 结构体与<code>kCMTimeRangeInvalid</code>直接进行比较。</p><h4 id="3-将-CMTimeRange-转换为对象"><a href="#3-将-CMTimeRange-转换为对象" class="headerlink" title="3. 将 CMTimeRange 转换为对象"></a>3. 将 CMTimeRange 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTimeRange，使用方法 <a href="https://developer.apple.com/reference/coremedia/1462781-cmtimerangecopyasdictionary">CMTimeRangeCopyAsDictionary</a> 和 <a href="https://developer.apple.com/reference/coremedia/1462777-cmtimerangemakefromdictionary">CMTimeRangeMakeFromDictionary</a> 可以在 CMTimeRange 结构体和<code>CFDictionary</code>类型 (参见 <a href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1462823-cmtimerangecopydescription">CMTimeRangeCopyDescription</a> 可以获取 CMTimeRange 结构体的字符串描述.</p><h2 id="6-2-媒体的表示-CMSampleBuffer"><a href="#6-2-媒体的表示-CMSampleBuffer" class="headerlink" title="6.2 媒体的表示(CMSampleBuffer)"></a>6.2 媒体的表示(CMSampleBuffer)</h2><p>视频数据和与其相关联的元数据都使用 Core Media 框架中的对象类型来表示。</p><p>Core Media 使用<code>CMSampleBuffer</code>(参见 <a href="https://developer.apple.com/reference/coremedia/cmsamplebuffer">CMSampleBufferRef</a>) 类型表示视频数据。</p><blockquote><p>CMSampleBuffers 是包含零个或多个特定媒体类型（音频、视频、多路混合等）的压缩（或未压缩）样本的 CF 对象，用于在媒体系统中移动媒体样本数据。</p><p>CMSampleBuffer 可以包含一个或多个媒体样本的 CMBlockBuffer 或 CVImageBuffer、CMSampleBuffer 流的格式描述、每个包含的媒体样本的大小和时间信息，以及缓冲区级别(buffer-level)和样本级别(sample-level)的附件。</p></blockquote><p>一个<code>CMSampleBuffer</code>对象是一个包含了视频数据帧的 sample buffer(样本缓冲区)，用来作为 Core Video pixel buffer(核心视频像素缓冲区，参见 <a href="https://developer.apple.com/reference/corevideo/cvpixelbufferref">CVPixelBufferRef</a>)。</p><p>可以使用 <a href="https://developer.apple.com/reference/coremedia/1489236-cmsamplebuffergetimagebuffer">CMSampleBufferGetImageBuffer</a> 方法访问 sample buffer 中的 pixel buffer.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(&lt;#A <span class="built_in">CMSampleBuffer</span>#&gt;);</span><br></pre></td></tr></table></figure><p>可以在 pixel buffer 访问到实际的视频数据，参见下节示例代码。</p><p>除了视频数据而言，还可以获取视频帧其他方面的信息:</p><ul><li><p><strong>时间信息</strong>: 使用 <a href="https://developer.apple.com/reference/coremedia/1489252-cmsamplebuffergetpresentationtim">CMSampleBufferGetPresentationTimeStamp</a> 和 <a href="https://developer.apple.com/reference/coremedia/1489404-cmsamplebuffergetdecodetimestamp">CMSampleBufferGetDecodeTimeStamp</a> 可以分别获取视频帧的初始时间和解码时间。</p></li><li><p><strong>格式信息</strong>: 包含在一个<code>CMFormatDescription</code>对象中 (参见 <a href="https://developer.apple.com/reference/coremedia/cmformatdescriptionref">CMFormatDescriptionRef</a>)。从格式描述 对象中，可以：</p><ul><li>使用<code>CMVideoFormatDescriptionGetCodecType</code>获取视频的编码信息</li><li>使用<code>CMVideoFormatDescriptionGetDimensions</code>获取视频尺寸。</li></ul></li><li><p><strong>元数据</strong>: 以附件形式存储在一个字典中，通过 <a href="https://developer.apple.com/reference/coremedia/1470707-cmgetattachment">CMGetAttachment</a> 获取:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMSampleBufferRef</span> sampleBuffer = &lt;#Get a sample buffer#&gt;;</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> metadataDictionary =</span><br><span class="line">    <span class="built_in">CMGetAttachment</span>(sampleBuffer, <span class="built_in">CFSTR</span>(<span class="string">&quot;MetadataDictionary&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (metadataDictionary) &#123;</span><br><span class="line">    <span class="comment">// Do something with the metadata.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-3-将CMSampleBuffer转换为UIImage"><a href="#6-3-将CMSampleBuffer转换为UIImage" class="headerlink" title="6.3 将CMSampleBuffer转换为UIImage"></a>6.3 将CMSampleBuffer转换为UIImage</h2><p>下面的代码示例了如何将<code>CMSampleBuffer</code>转换为<code>UIImage</code>。这个转换相当消耗性能，使用时必须进行谨慎考虑。</p><p>例如，它适用于从大约每秒钟拍摄的一帧视频数据创建静态图像。您不应该将此作为实时操作来自捕获设备的每一帧视频的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a UIImage from sample buffer data</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *) imageFromSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>) sampleBuffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get a CMSampleBuffer&#x27;s Core Video image buffer for the media data</span></span><br><span class="line">    CVImageBufferRef imageBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line">    <span class="comment">// Lock the base address of the pixel buffer</span></span><br><span class="line">    CVPixelBufferLockBaseAddress(imageBuffer, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    <span class="keyword">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class="line">    <span class="comment">// Get the pixel buffer width and height</span></span><br><span class="line">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class="line">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a device-dependent RGB color space</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a bitmap graphics context with the sample buffer data</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(baseAddress, width, height, <span class="number">8</span>,</span><br><span class="line">      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    <span class="comment">// Create a Quartz image from the pixel data in the bitmap graphics context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> quartzImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="comment">// Unlock the pixel buffer</span></span><br><span class="line">    CVPixelBufferUnlockBaseAddress(imageBuffer,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Free up the context and color space</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create an image object from the Quartz image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:quartzImage];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Release the Quartz image</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(quartzImage);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、并发编程"><a href="#七、并发编程" class="headerlink" title="七、并发编程"></a>七、并发编程</h1><p>来自 AVFoundation 的回调 —— block、KVO、notification，都不能保证会在任何特定线程或队列上进行。相反，AVFoundation 会在任务的线程或队列上执行这些回调。</p><p>两个有关通知和线程的准则：</p><ul><li>UI 相关的通知必须在主线程中发送</li><li>需要创建或指定一个队列的类或方法，将在该队列上返回通知</li></ul><p>除了这两个准则之外，您不应该假设将在任何特定线程上返回通知。</p><p>如果你正在编写一个多线程的应用程序，你可以使用 NSThread 类的下面方法来判断当前是否是你所需要的线程： </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread;</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSThread</span> currentThread] isEqual:&lt;#A stored thread reference#&gt;] </span><br></pre></td></tr></table></figure><p>可以使用 NSObject 下面的方法来指定线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector </span><br><span class="line">                         withObject:(nullable id)arg </span><br><span class="line">                      waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">               onThread:(NSThread *)thr </span><br><span class="line">             withObject:(nullable id)arg </span><br><span class="line">          waitUntilDone:(BOOL)wait </span><br><span class="line">                  modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>dispatch_async</code>将回调 block 放到合适的线程中执行。</p><ul><li>更多并发编程的资料参考：<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091"><em>Concurrency Programming Guide.</em></a> </li><li>更多 block 相关资料参见 <a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502"><em>Blocks Programming Topics</em></a>. </li><li>示例代码 <a href="https://developer.apple.com/library/prerelease/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112"><em>AVCam-iOS: Using AVFoundation to Capture Images and Movies</em></a> 是 AVFoundation 的一个基础示例， 并展示了一些 AVFoundation 中线程和队列的用法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVFoundation概述&quot;&gt;&lt;a href=&quot;#AVFoundation概述&quot; class=&quot;headerlink&quot; title=&quot;AVFoundation概述&quot;&gt;&lt;/a&gt;AVFoundation概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;译文，原文链接：&lt;</summary>
      
    
    
    
    <category term="音视频处理" scheme="https://tenloy.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS音视频库概述</title>
    <link href="https://tenloy.github.io/2022/03/17/avframework.html"/>
    <id>https://tenloy.github.io/2022/03/17/avframework.html</id>
    <published>2022-03-17T08:29:54.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 和 OS X 平台都有一系列操作音视频的 API，其中涵盖了从低到高的全部层级。随着时间的推移、平台的增长以及改变，不同 API 的数量可以说有着非常巨大的变化。本文对当前可以使用的 API 以及它们使用的不同目的进行简要的概括。</p><h1 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h1><ul><li><p>iOS 框架：MediaPlayer、AVKit、AVFoundation、AudioToolbox、AudioUnit、OpenAL。</p><ul><li>其中AVKit、MediaPlayer 、 AVFoundation 是基于 Objective-C/Swift 的； AudioToolBox 、 AudioUnit 和 OpenAL 是基于 C 的。</li></ul></li><li><p>第三方库：FFmpeg 、 FAAC 、 FAAD2。</p></li></ul><h2 id="Media-Player"><a href="#Media-Player" class="headerlink" title="Media Player"></a>Media Player</h2><p>Media Player 框架是 iOS 平台上一个用于音频和视频播放的高层级接口，它包含了一个你可以在应用中直接使用的默认的用户界面。你可以使用它来播放用户在 iPod 库中的项目，或者播放本地文件以及网络流。</p><p>另外，这个框架也包括了查找用户媒体库中内容的 API，同时还可以配置像是在锁屏界面或者控制中心里的音频控件。</p><ul><li>使用 MPMusicPlayerController 播放音频文件。 </li></ul><h2 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h2><p>为媒体播放创建用户界面，包括传输控件、章节导航、画中画支持以及字幕和隐藏式字幕的显示。</p><ul><li>使用 AVPlayerController 播放音频文件或流。 </li></ul><h2 id="AVFoundation"><a href="#AVFoundation" class="headerlink" title="AVFoundation"></a>AVFoundation</h2><blockquote><p>定义视听资产，控制设备摄像头，处理音频和配置系统音频交互。</p><p>结合了六大技术领域，共同涵盖了在 Apple 平台上捕获、处理、合成、控制、导入和导出视听媒体的广泛任务。</p></blockquote><p>AVFoundation 是苹果的现代媒体框架，它包含了一些不同的用途的 API 和不同层级的抽象。其中有一些是现代 Objective-C 对于底层 C 语言接口的封装。除了少数的例外情况，<code>AVFoundation</code> 可以同时在 iOS 和 OS X 中使用。</p><ul><li>AVAudioSession 操作音频会话</li><li>AVAudioFile(iOS8) 读写音频文件</li><li>AVAudioRecorder 录制音频文件</li><li>AVAudioPlayer 和 AVPlayer 播放音频文件</li><li>AVCaptureSession 录制音频和视频数据。 </li><li>在 iOS 8 之前使用 AVAssetWritter 将 PCM 音频写入 AAC LC 编码格式的音频文件，而且使用的是硬编码。 </li><li>在 iOS 8 及以后可以使用 AVAudioEngine 进行均衡器、混响和混音等操作，其基于底层的 AudioUnit ，但比后者更易用。 </li></ul><h3 id="AVAudioSession"><a href="#AVAudioSession" class="headerlink" title="AVAudioSession"></a>AVAudioSession</h3><p>AVAudioSession 是用于 iOS 系统中协调应用程序之间的音频播放的 API 的。例如，当有电话打进来时，音频的播放就会被暂停；在用户启动电影时，音乐的播放就会停止。我们需要使用这些 API 来确保一个应用程序能够正确响应并处理这类事件。</p><h3 id="AVAudioPlayer"><a href="#AVAudioPlayer" class="headerlink" title="AVAudioPlayer"></a>AVAudioPlayer</h3><p>这个高层级的 API 为你提供一个简单的接口，用来播放本地或者内存中的音频。这是一个无界面的音频播放器 (也就是说没有提供 UI 元素)，使用起来也很直接简单。它不适用于网络音频流或者低延迟的实时音频播放。如果这些问题都不需要担心，那么 <code>AVAudioPlayer</code> 可能就是正确的选择。音频播放器的 API 也为我们带来了一些额外的功能，比如循环播放、获取音频的音量强度等等。</p><h3 id="AVAudioRecorder"><a href="#AVAudioRecorder" class="headerlink" title="AVAudioRecorder"></a>AVAudioRecorder</h3><p>作为与 <code>AVAudioPlayer</code> 相对应的 API，<code>AVAudioRecorder</code> 是将音频录制为文件的最简单的方法。除了用一个音量计接受音量的峰值和平均值以外，这个 API 简单粗暴，但要是你的使用场景很简单的话，这可能恰恰就是你想要的方法。</p><h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p>AVPlayer 与上面提到的 API 相比，提供了更多的灵活性和可控性。它基于 <code>AVPlayerItem</code> 和 <code>AVAsset</code>，为你提供了颗粒度更细的权限来获取资源，比如选择指定的音轨。它还通过 <code>AVQueuePlayer</code> 子类支持播放列表，而且你可以控制这些资源是否能够通过 AirPlay 发送。</p><p>与 <code>AVAudioPlayer</code> 最主要的区别是，<code>AVPlayer</code> 对来自网络的流媒体资源的 “开箱即用” 支持。这增加了处理播放状态的复杂性，但是你可以使用 KVO 来观测所有的状态参数来解决这个问题。</p><h3 id="AVAudioEngine"><a href="#AVAudioEngine" class="headerlink" title="AVAudioEngine"></a>AVAudioEngine</h3><p>AVAudioEngine 是播放和录制的 Objective-C 接口。它提供了以前需要深入到 Audio Toolbox 框架的 C API 才能做的控制 (例如一些实时音频任务)。该音频引擎 API 对底层的 API 建立了优秀的接口。如果你不得不处理底层的问题，你仍然可以使用 Audio Toolbox 框架。</p><p>这个 API 的基本概念是建立一个音频的节点图，从源节点 (播放器和麦克风) 以及过处理 (overprocessing) 节点 (混音器和效果器) 到目标节点 (硬件输出)。每一个节点都具有一定数量的输入和输出总线，同时这些总线也有良好定义的数据格式。这种结构使得它非常的灵活和强大。而且它集成了音频单元 (audio unit)。</p><h2 id="AudioToolbox"><a href="#AudioToolbox" class="headerlink" title="AudioToolbox"></a>AudioToolbox</h2><p>Audio Toolbox 框架是强大的，但是它的层级却非常的低。在过去，它基于 C++ 所编写，但是<strong>其大多数的功能现在都可以通过 <code>AVFoundation</code> 实现。</strong></p><p>简单介绍：</p><ul><li>System Sound Services 播放音频文件、</li><li>Audio Queue Services 录制和播放音频数据</li><li>Audio Converter Services 进行音频转码(格式、 bit-depth 和采样率)</li><li>Audio File Services 和 AudioFileStream 读写音频文件。 </li></ul><h2 id="Audio-Unit"><a href="#Audio-Unit" class="headerlink" title="Audio Unit"></a>Audio Unit</h2><p>Audio Unit 框架是一个底层的 API；所有 iOS 中的音频技术都构建在 Audio Unit 这个框架之上。音频单元是用来加工音频数据的插件。一个音频单元链叫做音频处理图。</p><p>如果你需要<strong>非常低的延迟 (如 VoIP 或合成乐器)、回声消除、混音或者音调均衡</strong>的话，你可能需要直接使用音频单元，或者自己写一个音频单元。但是其中的大部分工作可以使用 <code>AVAudioEngine</code> 的 API 来完成。如果你不得不写自己的音频单元的话，你可以将它们与 <code>AVAudioUnit</code> 节点一起集成在 <code>AVAudioEngine</code> 处理图中。</p><h3 id="跨应用程序音频"><a href="#跨应用程序音频" class="headerlink" title="跨应用程序音频"></a>跨应用程序音频</h3><p>Audio Unit 的 API 可以在 iOS 中进行跨应用音频。音频流 (和 MIDI 命令) 可以在应用程序之间发送。比如说：一个应用程序可以提供音频的效果器或者滤波器。另一个应用程序可以将它的音频发送到第一个应用程序中，并使用其中的音频效果器处理音频。被过滤的音频又会被实时地发送回原来的应用程序中。 CoreAudioKit 提供了一个简单的跨应用程序的音频界面。</p><h2 id="OpenAL"><a href="#OpenAL" class="headerlink" title="OpenAL"></a>OpenAL</h2><p><a href="https://en.wikipedia.org/wiki/OpenAL">OpenAL</a> 是一个跨平台的 API。它提供了位置 (3D) 和低延迟的音频服务。它主要用于跨平台游戏的开发。它有意地模仿了 OpenGL 中 API 的风格。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>MIDI</strong>：在 iOS 上，Core MIDI 和 CoreAudioKit 可以被用来使应用程序表现为 MIDI 设备。在 OS X 上，Music Sequencing 服务提供了基于 MIDI 的控制和对音乐数据访问的权限。Core MIDI 服务为服务器和驱动程序提供了支持。</li><li>在 OS X 中，最基本的音频接口就是 <code>NSBeep()</code>，它能够简单地播放系统中的声音。</li><li><strong>NSSound 类</strong>：为 OS X 提供了用于播放声音的简单接口，与 iOS 中的 <code>AVAudioPlayer</code> 在概念上基本类似。</li><li>所有的通知 API，包括 iOS 中的本地通知或者推送通知、OS X 中的 <code>NSUserNotification</code> 以及 CloudKit 通知，都可以播放声音。</li><li>QTKit 和 QuickTime 框架现在已经过时了，它们不应该被用在以后的开发中。我们应该使用 <code>AVFoundation</code> (和 AVKit) 来代替它们。</li></ul><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><ul><li>FAAC：将 PCM 软编码为 AAC LC。 </li><li>FFmpeg、FAAD2：将 AAC LC 软解码为 PCM 、 PCM 重采样(Resample)。</li></ul><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><ul><li><p>iOS 框架：MediaPlayer、AVKit、UIKit、AVFoundation、VideoToolBox、GLKit(OpenGL ES) 。</p><ul><li>其中 MediaPlayer、AVKit、UIKit、AVFoundation基于 Objective-C ； VideoToolBox 和 GLKit 基于 C 的。当然， GLKit 远远不只是可以渲染视频。</li></ul></li><li><p>第三方库 FFmpeg 、 x264。</p></li></ul><img src="https://tenloy.github.io/images/avf/frameworksBlockDiagram_2x.png" alt="img" style="zoom:70%;" /><h2 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h2><ul><li>使用 MPMoviePlayerViewController(MPMoviePlayerController/MPMoviePlayer) 播放视频文件或流。 </li></ul><h2 id="AVKit-1"><a href="#AVKit-1" class="headerlink" title="AVKit"></a>AVKit</h2><ul><li>使用 AVPlayerController 播放视频文件或流。 </li></ul><h2 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h2><ul><li>使用 UIImagePickerController 录制包含音频的视频文件</li><li>使用 UIVideoEditorController 可对视频进行简单编辑。 </li></ul><h2 id="AVFoundation-1"><a href="#AVFoundation-1" class="headerlink" title="AVFoundation"></a>AVFoundation</h2><ul><li>使用 AVPlayer 播放视频文件或流</li><li>使用AVCaptureSession 录制视频帧。 </li><li>在 iOS 8 之前使用 AVFoundation 框架的 AVAssetWritter 将 YUV 数据写入 H.264 编码格式的视频文件，而且使用的是硬编码。 </li></ul><h2 id="VideoToolBox"><a href="#VideoToolBox" class="headerlink" title="VideoToolBox"></a>VideoToolBox</h2><p>在 iOS 8 及以后使用 VideoToolBox 框架将 YUV 视频数据硬编码为 H.264 ，以及将 H.264 硬解码为 YUV 视频数据。 </p><h2 id="GLKit"><a href="#GLKit" class="headerlink" title="GLKit"></a>GLKit</h2><p>使用 GLKit 将 sRGB 或 YUV 视频数据渲染输出到屏幕。 </p><h2 id="第三方库-1"><a href="#第三方库-1" class="headerlink" title="第三方库"></a>第三方库</h2><ul><li>FFmpeg：将 H.264 软解码为 YUV 。 </li><li>x264：将 YUV 视频软编码为 H.264 。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;iOS 和 OS X 平台都有一系列操作音视频的 API，其中涵盖了从低到高的全部层级。随着时间的推移、平台的增长以及改变，不同 API 的数量可以说有着非常巨大的变化。本文对当前可以使用的 API 以及它们使用的不同目的进行简要的概括。&lt;/p&gt;
&lt;h1 id=&quot;Audio</summary>
      
    
    
    
    <category term="音视频处理" scheme="https://tenloy.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] OAuth 2.0简述</title>
    <link href="https://tenloy.github.io/2022/02/09/OAuth.html"/>
    <id>https://tenloy.github.io/2022/02/09/OAuth.html</id>
    <published>2022-02-09T17:03:25.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 —— <a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释 —— 阮一峰</a></p></blockquote><p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p><blockquote><p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p></blockquote><p>这段话的意思就是，<strong>OAuth 是一种授权机制，核心就是向第三方应用颁发令牌(token)。</strong>以获取用户数据</p><p>然后，RFC 6749 接着写道：</p><blockquote><p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p></blockquote><p>下面就是重点讲解这两点：OAuth的运行流程、四种授权方式</p><h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><ol><li>“云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</li><li>Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</li><li>“云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</li><li>用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</li><li>只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</li></ol><p>OAuth就是为了解决上面这些问题而诞生的。</p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h1 id="二、令牌与密码"><a href="#二、令牌与密码" class="headerlink" title="二、令牌与密码"></a>二、令牌与密码</h1><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><h1 id="三、OAuth的思路与运行流程"><a href="#三、OAuth的思路与运行流程" class="headerlink" title="三、OAuth的思路与运行流程"></a>三、OAuth的思路与运行流程</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。<ul><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul></li><li><strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li></ul><p>OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。</p><ul><li>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</li><li>“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</li><li>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</li></ul><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png"></p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><h1 id="四、四种授权方式"><a href="#四、四种授权方式" class="headerlink" title="四、四种授权方式"></a>四、四种授权方式</h1><p><strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h2 id="4-1-授权码"><a href="#4-1-授权码" class="headerlink" title="4.1 授权码"></a>4.1 授权码</h2><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040905.jpg" alt="img"></p><h2 id="4-2-隐藏式"><a href="#4-2-隐藏式" class="headerlink" title="4.2 隐藏式"></a>4.2 隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040906.jpg" alt="img"></p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h2 id="4-3-密码式"><a href="#4-3-密码式" class="headerlink" title="4.3 密码式"></a>4.3 密码式</h2><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h2 id="4-4-凭证式"><a href="#4-4-凭证式" class="headerlink" title="4.4 凭证式"></a>4.4 凭证式</h2><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h1 id="五、令牌的使用"><a href="#五、令牌的使用" class="headerlink" title="五、令牌的使用"></a>五、令牌的使用</h1><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h1 id="六、令牌的更新"><a href="#六、令牌的更新" class="headerlink" title="六、令牌的更新"></a>六、令牌的更新</h1><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p><h1 id="七、示例-GitHub-OAuth第三方登录"><a href="#七、示例-GitHub-OAuth第三方登录" class="headerlink" title="七、示例: GitHub OAuth第三方登录"></a>七、示例: GitHub OAuth第三方登录</h1><p>今天演示一个实例，如何通过 OAuth 获取 API 数据。</p><p>很多网站登录时，允许使用第三方网站的身份，这称为”第三方登录”。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042101.jpg" alt="img"></p><p>下面就以 GitHub 为例，写一个最简单的应用，演示第三方登录。</p><h2 id="7-1-第三方登录的原理"><a href="#7-1-第三方登录的原理" class="headerlink" title="7.1 第三方登录的原理"></a>7.1 第三方登录的原理</h2><p>所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>举例来说，A 网站允许 GitHub 登录，背后就是下面的流程。</p><ol><li>A 网站让用户跳转到 GitHub。</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。</li><li>A 网站使用授权码，向 GitHub 请求令牌。</li><li>GitHub 返回令牌.</li><li>A 网站使用令牌，向 GitHub 请求用户数据。</li></ol><p>下面就是这个流程的代码实现。</p><h2 id="7-2-应用登记"><a href="#7-2-应用登记" class="headerlink" title="7.2 应用登记"></a>7.2 应用登记</h2><p>一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。</p><p>所以，你要先去 GitHub 登记一下。当然，我已经登记过了，你使用我的登记信息也可以，但为了完整走一遍流程，还是建议大家自己登记。这是免费的。</p><p>访问这个<a href="https://github.com/settings/applications/new">网址</a>，填写登记表。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042102.jpg" alt="img"></p><p>应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p><p>提交表单以后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码。</p><h2 id="7-3-示例仓库"><a href="#7-3-示例仓库" class="headerlink" title="7.3 示例仓库"></a>7.3 示例仓库</h2><p>我写了一个<a href="https://github.com/ruanyf/node-oauth-demo">代码仓库</a>，请将它克隆到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:ruanyf/node-oauth-demo.git</span><br><span class="line">$ <span class="built_in">cd</span> node-oauth-demo</span><br></pre></td></tr></table></figure><p>两个配置项要改一下，写入上一步的身份识别码。</p><ul><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L3"><code>index.js</code></a>：改掉变量<code>clientID</code> and <code>clientSecret</code></li><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/public/index.html#L16"><code>public/index.html</code></a>：改掉变量<code>client_id</code></li></ul><p>然后，安装依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure><p>浏览器访问<code>http://localhost:8080</code>，就可以看到这个示例了。</p><h2 id="7-4-浏览器跳转-GitHub"><a href="#7-4-浏览器跳转-GitHub" class="headerlink" title="7.4 浏览器跳转 GitHub"></a>7.4 浏览器跳转 GitHub</h2><p>示例的首页很简单，就是一个链接，让用户跳转到 GitHub。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042103.jpg" alt="img"></p><p>跳转的 URL 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?</span><br><span class="line">  client_id&#x3D;7e015d8ce32370079895&amp;</span><br><span class="line">  redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect</span><br></pre></td></tr></table></figure><p>这个 URL 指向 GitHub 的 OAuth 授权网址，带有两个参数：<code>client_id</code>告诉 GitHub 谁在请求，<code>redirect_uri</code>是稍后跳转回来的网址。</p><p>用户点击到了 GitHub，GitHub 会要求用户登录，确保是本人在操作。</p><h2 id="7-5-授权码"><a href="#7-5-授权码" class="headerlink" title="7.5 授权码"></a>7.5 授权码</h2><p>登录后，GitHub 询问用户，该应用正在请求数据，你是否同意授权。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042104.png" alt="img"></p><p>用户同意授权， GitHub 就会跳转到<code>redirect_uri</code>指定的跳转网址，并且带上授权码，跳转回来的 URL 就是下面的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect?</span><br><span class="line">  code&#x3D;859310e7cecc9196f4af</span><br></pre></td></tr></table></figure><p>后端收到这个请求以后，就拿到了授权码（<code>code</code>参数）。</p><h2 id="7-6-后端实现"><a href="#7-6-后端实现" class="headerlink" title="7.6 后端实现"></a>7.6 后端实现</h2><p>示例的<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js">后端</a>采用 Koa 框架编写，具体语法请看<a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">教程</a>。</p><p>这里的关键是针对<code>/oauth/redirect</code>的请求，编写一个<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L16">路由</a>，完成 OAuth 认证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oauth = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(route.get(<span class="string">&#x27;/oauth/redirect&#x27;</span>, oauth));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>oauth</code>函数就是路由的处理函数。下面的代码都写在这个函数里面。</p><p>路由函数的第一件事，是从 URL 取出授权码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestToken = ctx.request.query.code;</span><br></pre></td></tr></table></figure><h2 id="7-7-令牌"><a href="#7-7-令牌" class="headerlink" title="7.7 令牌"></a>7.7 令牌</h2><p>后端使用这个授权码，向 GitHub 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tokenResponse = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;https://github.com/login/oauth/access_token?&#x27;</span> +</span><br><span class="line">    <span class="string">`client_id=<span class="subst">$&#123;clientID&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`client_secret=<span class="subst">$&#123;clientSecret&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`code=<span class="subst">$&#123;requestToken&#125;</span>`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub 的令牌接口<code>https://github.com/login/oauth/access_token</code>需要提供三个参数。</p><ul><li><code>client_id</code>：客户端的 ID</li><li><code>client_secret</code>：客户端的密钥</li><li><code>code</code>：授权码</li></ul><p>作为回应，GitHub 会返回一段 JSON 数据，里面包含了令牌<code>accessToken</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> accessToken = tokenResponse.data.access_token;</span><br></pre></td></tr></table></figure><h2 id="7-8-API-数据"><a href="#7-8-API-数据" class="headerlink" title="7.8 API 数据"></a>7.8 API 数据</h2><p>有了令牌以后，就可以向 API 请求数据了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url: <span class="string">`https://api.github.com/user`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    Authorization: <span class="string">`token <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub API 的地址是<code>https://api.github.com/user</code>，请求的时候必须在 HTTP 头信息里面带上令牌<code>Authorization: token 361507da</code>。</p><p>然后，就可以拿到用户数据，得到用户的身份。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = result.data.name;</span><br><span class="line">ctx.response.redirect(<span class="string">`/welcome.html?name=<span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 —— &lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot;&gt;OAuth 2.0 的一个简单解释 —— 阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="互联网标准RFC" scheme="https://tenloy.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86RFC/"/>
    
    
  </entry>
  
  <entry>
    <title>WKWebView使用过程中遇到的坑</title>
    <link href="https://tenloy.github.io/2022/01/18/wkwebview-buges.html"/>
    <id>https://tenloy.github.io/2022/01/18/wkwebview-buges.html</id>
    <published>2022-01-18T17:39:45.000Z</published>
    <updated>2022-06-21T10:15:46.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WKWebView-API"><a href="#WKWebView-API" class="headerlink" title="WKWebView API"></a>WKWebView API</h1><h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h2><p>关于 <code>extendedLayoutIncludesOpaqueBars</code> 和 <code>automaticallyAdjustsScrollViewInsets</code></p><ul><li>这两个属性属于UIViewController</li><li>默认情况下extendedLayoutIncludesOpaqueBars = false 扩展布局不包含导航栏</li><li>默认情况下automaticallyAdjustsScrollViewInsets = true 自动计算滚动视图的内容边距</li><li>但是，当 导航栏 是 不透明时，而tabBar为透明的时候，为了正确显示tableView的全部内容，需要重新设置这两个属性的值，然后设置contentInset(参考代码).</li></ul><p>在iOS11 中， UIViewController的 <code>automaticallyAdjustsScrollViewInsets</code> 属性已经不再使用，我们需要使用UIScrollView的 <code>contentInsetAdjustmentBehavior </code> 属性来替代它.</p><p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型，值有以下几种:</p><ul><li>automatic 和scrollableAxes一样，scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时，也会设置内边距.</li><li>scrollableAxes 自动计算内边距.</li><li>never不计算内边距</li><li>always 根据safeAreaInsets 计算内边距一般我们肯定需要设置为 never，我们自己来控制间距，但是在iOS 12的webView中，就会出现开始所说的问题，需要设置为automatic才能解决</li></ul><p><strong>调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值.</strong></p><h2 id="2-调整滚动速率"><a href="#2-调整滚动速率" class="headerlink" title="2. 调整滚动速率"></a>2. 调整滚动速率</h2><p>WKWebView 需要通过 scrollView delegate 调整滚动速率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">  scrollView.decelerationRate = <span class="built_in">UIScrollViewDecelerationRateNormal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-视频自动播放"><a href="#3-视频自动播放" class="headerlink" title="3. 视频自动播放"></a>3. 视频自动播放</h2><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p><h2 id="4-goBack-API问题"><a href="#4-goBack-API问题" class="headerlink" title="4. goBack API问题"></a>4. goBack API问题</h2><p>WKWebView 上调用 -[WKWebView goBack]， 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>在以前，一直以为Hybrid App开发是一种略显简单的事，不会使用太多能发挥移动端原生本身优势的复杂API，后来在新公司的工作(半混合式开发)过程中，发现混合式开发也是很多坑… 或者说WKWebView好多坑…</p><blockquote><p> 以下所说的内容，<a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA">参考链接</a>上基本上都有，本文的叙述方式主要是结合自己的经历(自己踩过的总结总是那么的深刻…[\捂脸])</p><p> 应该在开始混合开发之前就看下这篇文章的，结果真的是等自己踩坑踩了一遍，总结之后，发现这篇文章上都有….[\大哭]</p><p> 参考链接2： <a href="https://www.jianshu.com/p/86d99192df68">https://www.jianshu.com/p/86d99192df68</a></p></blockquote><h2 id="1-加载URL的-encode问题"><a href="#1-加载URL的-encode问题" class="headerlink" title="1. 加载URL的 encode问题"></a>1. 加载URL的 encode问题</h2><p>在数据网络请求或其他情况下，需要把URL中的一些特殊字符转换成UTF-8编码，比如：中文。解决<code>无法加载</code>的问题</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ios9后对其方法进行了修改</span></span><br><span class="line">stringByAddingPercentEncodingWithAllowedCharacters: [<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByReplacingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// iOS 9以后</span></span><br><span class="line">stringByRemovingPercentEncoding</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>混合开发中，最好将所有的URL的编解码问题都<strong>交给前端或者后端来做</strong>，毕竟移动端发版不够灵活。</li><li>API编写时，要<strong>保证iOS与Android两端的处理一致</strong>，否则前端同学做处理就太麻烦了。</li></ul><h2 id="2-loadRequest造成的body数据丢失"><a href="#2-loadRequest造成的body数据丢失" class="headerlink" title="2. loadRequest造成的body数据丢失"></a>2. loadRequest造成的body数据丢失</h2><p>在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是由于进程间通信性能问题，HTTPBody字段被丢弃[request setHTTPMethod:@&quot;POST&quot;];</span></span><br><span class="line">[request setHTTPBody:[<span class="string">@&quot;bodyData&quot;</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">[wkwebview loadRequest: request];</span><br></pre></td></tr></table></figure><p>目前也已经有成熟的解决方案了，见<a href="https://github.com/karosLi/KKJSBridge#ajax-hook-%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">KKJSBridge库</a>。原理上都是hook ajax，不过细节上分两种：</p><p>这里只对比方案间相互比较的优缺点，共同的优点，就不赘述了。如果对私有 API 不敏感的，我是比较推荐使用方案一的。</p><h3 id="方案一：Ajax-Hook-部分-API-NSURLProtocol"><a href="#方案一：Ajax-Hook-部分-API-NSURLProtocol" class="headerlink" title="方案一：Ajax Hook 部分 API + NSURLProtocol"></a>方案一：Ajax Hook 部分 API + NSURLProtocol</h3><p>这个方案对应的是这里的 <code>KKJSBridge/AjaxProtocolHook</code>。</p><p>原理介绍：此种方案，是只需要 hook ajax 中的 open/send 方法。</p><ol><li>在 hook 的 send 方法里，先把要发送的 body 通过 JSBridge 发送到 Native 侧去缓存起来。<ul><li><em>为每一个post请求设置一个id，对应其缓存起来的body数据？</em></li><li><em>如果不想缓存，那先把post转get、或者body参数存header中，缺点都是body有限制。这种适合参数较少时。注意有个坑就是修改header可能会导致发出options请求。—— 来自群友交流</em></li></ul></li><li>缓存成功后，再去执行真实的 send 方法，NSURLProtocol 此时会拦截到该请求，然后取出之前缓存的 body 数据，重新拼接请求，就可以发送出去了。</li><li>然后通过 NSURLProtocol 把请求结果返回给 WebView 内核。</li></ol><p>优点：</p><ul><li>兼容性会更好，网络请求都是走 webview 原生的方式。</li><li>hook 的逻辑会更少，会更加稳定。</li><li>可以更好的支持 ajax 获取二进制的数据。例如 H5 小游戏场景（白鹭引擎是通过异步获取图片资源）。</li></ul><p>缺点：</p><ul><li>需要使用到私有 API browsingContextController 去注册 http/https。（其实现在大部分的离线包方案也是使用了这个私有 API 了）</li></ul><h3 id="方案二：Ajax-Hook-全部-API"><a href="#方案二：Ajax-Hook-全部-API" class="headerlink" title="方案二：Ajax Hook 全部 API"></a>方案二：Ajax Hook 全部 API</h3><p>这个方案对应的是这里的 <code>KKJSBridge/AjaxHook</code>。</p><p>原理介绍：此种方案，是使用 hook 的 XMLHttpRequest 对象来代理真实的 XMLHttpRequest 去发送请求，相当于是需要 hook ajax 中的所有方法。</p><ul><li>在 hook 的 open 方法里，调用 JSBridge 让 Native 去创建一个 NSMutableRequest 对象。</li><li>在 hook 的 send 方法里，把要发送的 body 通过 JSBridge 发送到 Native 侧，并把 body 设置给刚才创建的 NSMutableRequest 对象。</li><li>在 Native 侧完成请求后，通过 JS 执行函数，把请求结果通知给 JS 侧，JS 侧找到 hook 的 XMLHttpRequest 对象，最后调用 onreadystatechange 函数，让 H5 知道有请求结果了。</li></ul><p>优点：</p><ul><li>没有使用私有 API。</li></ul><p>缺点：</p><ul><li>需要 hook XMLHttpRequest 的所有方法。</li><li>请求结果是通过 JSBrdige 来进行传输的，性能上肯定没有原生的性能好。</li><li>不能支持 ajax 获取二进制的数据。要想支持的话，还需要额外的序列化工作。</li></ul><h2 id="3-WKUserContentController造成内存泄漏"><a href="#3-WKUserContentController造成内存泄漏" class="headerlink" title="3. WKUserContentController造成内存泄漏"></a>3. WKUserContentController造成内存泄漏</h2><blockquote><p>self -&gt; webView -&gt; WKWebViewConfiguration -&gt; WKUserContentController -&gt; self (addScriptMessageHandler)</p></blockquote><p>以下的方法，并不能解决问题</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) copy_self = <span class="keyword">self</span>;</span><br><span class="line">addScriptMessageHandler: copy_self</span><br></pre></td></tr></table></figure><p>解决方案： 单独创建一个类实现<code>WKScriptMessageHandler</code>协议，然后在该类中再创建一个协议，由self来实现协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> -&gt; webView -&gt; <span class="built_in">WKWebViewConfiguration</span> -&gt; <span class="built_in">WKUserContentController</span> -&gt; <span class="keyword">weak</span> delegate obj --delegate--&gt; <span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个新类WeakScriptMessageDelegate</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakScriptMessageDelegate</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt; scriptDelegate;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakScriptMessageDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">      _scriptDelegate = scriptDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在我们使用WKWebView的控制器中引入我们创建的那个类，将注入js对象的代码改为:</span></span><br><span class="line">[config.userContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:<span class="keyword">self</span>] name:scriptMessage];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在delloc方法中通过下面的方式移除注入的js对象</span></span><br><span class="line">[<span class="keyword">self</span>.config.userContentController removeScriptMessageHandlerForName:scriptMessage];</span><br></pre></td></tr></table></figure><p>上面三步就可以解决控制器不能被释放的问题了。</p><h2 id="4-WKWebView的白屏问题-拍照引起"><a href="#4-WKWebView的白屏问题-拍照引起" class="headerlink" title="4.  WKWebView的白屏问题(拍照引起)"></a>4.  WKWebView的白屏问题(拍照引起)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。</p><p>换WKWebView加载网页后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。<strong>在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。</strong></p><ul><li><p>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；</p></li><li><p>在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>总结下来，白屏的现象有几种：</p><ul><li>WKWebView的URL为空，出现白屏，这种现象可以通过loadRequest解决。</li><li>WKWebView的URL不空，出现白屏、部分白屏、白屏部分能点击，这种现象无论是reload还是loadRequest都不能刷出网页。（可以尝试3、4）</li></ul><h4 id="方案1-ContentProcessDidTerminate"><a href="#方案1-ContentProcessDidTerminate" class="headerlink" title="方案1. ContentProcessDidTerminate"></a>方案1. ContentProcessDidTerminate</h4><p>借助 iOS 9以后 <code>WKNavigtionDelegate</code> 新增了一个回调函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(<span class="built_in">WKWebView</span> *)webView API_AVAILABLE(macosx(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><p>当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行<code>[webView reload]</code>(这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p><h4 id="方案2-检测-webView-title-是否为空"><a href="#方案2-检测-webView-title-是否为空" class="headerlink" title="方案2. 检测 webView.title 是否为空"></a>方案2. 检测 webView.title 是否为空</h4><p>并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的<code>意见反馈</code>H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，<strong>WebContent Process 被系统挂起</strong>），但上面的回调函数并没有被调用。</p><p>在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空， 因此，可以在 viewWillAppear 的时候检测 <code>webView.title</code> 是否为空来 reload 页面。</p><p>注意：可能<strong>有的前端页面确实没写title标签</strong>，在前端移动端开发中是可能会有这种场景的，会造成页面反复刷新</p><p>综合以上两种方法可以解决绝大多数的白屏问题。</p><h4 id="方案3-检索WKCompositingView控件"><a href="#方案3-检索WKCompositingView控件" class="headerlink" title="方案3. 检索WKCompositingView控件"></a>方案3. 检索WKCompositingView控件</h4><blockquote><p>（<em>未验证，有人说不好使</em>）</p></blockquote><p>WKWebView的URL不空，出现白屏不能点击、白屏部分能点击、部分白屏能点击等，这种现象无论是reload、loadRequest、清缓存、setNeedsLayout都不能刷出网页，只能回收旧webview（webview = nil 后记得清除代理，移除监听，要不然会crash）创建新的 webview， 然后重新request。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否白屏</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isBlankView:(<span class="built_in">UIView</span> *)view &#123; <span class="comment">// YES：blank</span></span><br><span class="line">    Class wkCompositingView = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;WKCompositingView&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:[wkCompositingView <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">UIView</span> * subView <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> isBlankView:subView]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案4-html中加入资源加载的监听"><a href="#方案4-html中加入资源加载的监听" class="headerlink" title="方案4. html中加入资源加载的监听"></a>方案4. html中加入资源加载的监听</h4><p>在本地html中加入资源加载的监听，只要发生错误，就调用location.reload();重载当前文档。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监控资源加载错误(img,script,css,以及jsonp)</span></span><br><span class="line">window.addEventListener(<span class="string">&#x27;error&#x27;</span>, function (e) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;===&quot;</span> + e.message + <span class="string">&quot;===&quot;</span>);</span><br><span class="line">    location.reload();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;错误信息：&quot;</span>, errorMessage);</span><br><span class="line">    console.log(<span class="string">&quot;出错文件：&quot;</span>, scriptURI);</span><br><span class="line">    console.log(<span class="string">&quot;出错行号：&quot;</span>, lineNumber);</span><br><span class="line">    console.log(<span class="string">&quot;出错列号：&quot;</span>, columnNumber);</span><br><span class="line">    console.log(<span class="string">&quot;错误详情：&quot;</span>, errorObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这段代码要放在head内，并且css不能内联。</p><h2 id="5-NSURLProtocol-做网页缓存"><a href="#5-NSURLProtocol-做网页缓存" class="headerlink" title="5. NSURLProtocol(做网页缓存)"></a>5. NSURLProtocol(做网页缓存)</h2><p>见<a href="https://www.jianshu.com/p/9989ef064f7d">WKWebView中NSURLProtocol的使用以及对H5的缓存</a>，这是利用NSURLProtocol做网页缓存以及带来的隐患。</p><h2 id="6-WKWebView的截屏问题-做意见反馈"><a href="#6-WKWebView的截屏问题-做意见反馈" class="headerlink" title="6.  WKWebView的截屏问题(做意见反馈)"></a>6.  WKWebView的截屏问题(做意见反馈)</h2><p>WKWebView 下通过 <code>-[CALayer renderInContext:]</code>实现截屏的方式失效，需要通过以下方式实现截屏功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ImageSnapshot</span>) </span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)imageSnapshot &#123; </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size,<span class="literal">YES</span>,<span class="keyword">self</span>.contentScaleFactor); </span><br><span class="line">    [<span class="keyword">self</span> drawViewHierarchyInRect:<span class="keyword">self</span>.bounds afterScreenUpdates:<span class="literal">YES</span>]; </span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>(); </span><br><span class="line">    <span class="keyword">return</span> newImage; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而这种方式依然解决不了 webGL 页面的截屏问题，Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：<strong>对webGL 页面的截屏结果不是空白就是纯黑图片</strong>。</p><h2 id="7-window-alert-引起的crash问题-暂时没遇到"><a href="#7-window-alert-引起的crash问题-暂时没遇到" class="headerlink" title="7. window.alert()引起的crash问题(暂时没遇到)"></a>7. window.alert()引起的crash问题(暂时没遇到)</h2><h2 id="8-WKWebView拦截协议"><a href="#8-WKWebView拦截协议" class="headerlink" title="8. WKWebView拦截协议"></a>8. WKWebView拦截协议</h2><p>WKWebView内默认不允许iTunes、weixin等协议跳转。</p><p>UIWebView打开ituns.apple.com、跳转到appStore、拨打电话、唤起邮箱等一系列操作，UIWebView自己处理不了会自动交给UIApplication 来处理。</p><p>WKWebView上述事件WKWebView 不会自动交给UIApplication 来处理，除此之外，js端通过window.open() 打开新的网页的动作也被禁掉了。</p><h2 id="9-User-Agent修改"><a href="#9-User-Agent修改" class="headerlink" title="9. User-Agent修改"></a>9. User-Agent修改</h2><ul><li><p>在UIWebView初始化之前，全局设置User-Agent才会生效</p></li><li><p>在shouldStartLoadWithRequest可以给某个request设置UA，但是需要重新[webView loadUrl]，注意判断条件，不要死循环</p></li><li><p><strong>不要擅自修改webView的User-Agent，务必要跟前端反复确认，是否有用UA来做一些设备区分，进而做一些系统、机型适配问题。</strong></p></li></ul><h2 id="10-didFinish不调用"><a href="#10-didFinish不调用" class="headerlink" title="10. didFinish不调用"></a>10. didFinish不调用</h2><p>WKWebView didFinishNavigation明明看起来页面加载完全，却不调用(<strong>一般只发生在第一次进入该页面</strong>)。经过自定义NSURLProtocol，拦截所有的H5加载资源，并在didCompleteWithError中打印资源的加载情况，发现有图片资源，域名有问题。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=<span class="built_in">NSURLErrorDomain</span> Code=<span class="number">-1003</span> <span class="string">&quot;未能找到使用指定主机名的服务器。 </span></span><br></pre></td></tr></table></figure><p>原因：DNS解析失败导致系统认定H5一直没加载完成！第二次再进入，系统缓存了DNS解析的映射记录，所以很快就认定资源错误，调用了didFinish方法。</p><h2 id="11-UI细节问题"><a href="#11-UI细节问题" class="headerlink" title="11. UI细节问题"></a>11. UI细节问题</h2><h3 id="11-1-WKWebView中-h5绝对布局不生效"><a href="#11-1-WKWebView中-h5绝对布局不生效" class="headerlink" title="11.1 WKWebView中 h5绝对布局不生效"></a>11.1 WKWebView中 h5绝对布局不生效</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ios 11之后</span></span><br><span class="line">_baseWebView.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br></pre></td></tr></table></figure><p>然后：前端需要在meta标签中增加 <strong>iPhoneX</strong>的适配**—<strong>适配方案</strong>viewport-fit<strong>：</strong>cover**</p><h3 id="11-2-iOS-12中WKWebView中表单-键盘"><a href="#11-2-iOS-12中WKWebView中表单-键盘" class="headerlink" title="11.2. iOS 12中WKWebView中表单 键盘"></a>11.2. iOS 12中WKWebView中表单 键盘</h3><p>iOS 12中WKWebView中表单键盘弹起自动上移，导致的兼容问题。</p><p>WKWebView会自动监听键盘弹出，并做上下移动处理(效果如同IQKeyboardManage这些库)，但是在iOS12中会有一些问题，键盘收起后，控件不恢复原状，或者部分控件消失等不兼容问题</p><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(kSystemVersion &lt; <span class="number">12.0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">12.0</span>, *)) &#123;</span><br><span class="line">     _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-WKWebview会下移20"><a href="#11-3-WKWebview会下移20" class="headerlink" title="11.3 WKWebview会下移20"></a>11.3 WKWebview会下移20</h3><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS11前</span></span><br><span class="line">VC.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;  </span><br><span class="line"><span class="comment">//iOS11及以后</span></span><br><span class="line">_webview.scrollView.contentInsetAdjustmentBehavior;</span><br></pre></td></tr></table></figure><h2 id="12-H5标签不可点击，Native不受影响"><a href="#12-H5标签不可点击，Native不受影响" class="headerlink" title="12. H5标签不可点击，Native不受影响"></a>12. H5标签不可点击，Native不受影响</h2><p><em>iOS 11系统上，WKWebView内H5标签不可点击，Native不受影响。</em></p><p>在频繁的切换页面、刷新WKWebView的情况下，会出现WKWebView卡死，所有的H5标签不可点击，Native的UI不受影响，TabBarVC的几个子控制器最为严重，有时候切换、刷新四五次左右，就会出现这种情况。</p><p><strong>更新：结论：在viewWillAppear方法中调用了<code>evaluateJavaScript: completionHandler:</code>方法，将该方法的调用移到viewDidAppear方法中即可。</strong></p><p>下面是探索的一些步骤，也走了一些弯路，可绕过：</p><blockquote><p>分别从内存、视图、网络请求几个方面入手，按照以下步骤定位问题：</p><ol><li><p>对APP进行内存泄漏检测，优化了几处代码。毫无用处</p></li><li><p>WKWebView单独进程内存问题？因为有一些二级页面按照问题出现流程复现了N多次，都没有出现，所以暂时先排除</p></li><li><p>网速问题。发现网速差时，确实很容易复现，网速好的时候，试了好几次没复现！做了一些网络优化，比如及时cancel掉一些不需要的请求，没有效果。</p></li><li><p>视图加载、更新问题。猜测依据：一级页面更容易复现，且比二级页面多了一个Tabbar的视图。</p></li><li><p>结论：结合第3、4，猜测是网络过慢时，tabbar出现、隐藏，及WKWebView刷新、加载、渲染HTML，几种情况结合导致的WKWebView布局混乱。</p></li></ol><p>最后解决方法：包含WKWebView的一级页面，<code>viewDidAppear</code>时重新设置了一下WKWebView的约束。(设置UIScrollViewContentInsetAdjustmentAutomatic = YES，没有效果)</p><p>效果：大大改善了，但却没有根治问题。加了个保底方案，下拉刷新时，销毁旧WKWebView，创建新的，并loadRequest。(因为这些情况下iOS 11上出现的，且没有更低版本的测试机复现，所以暂时把修改限制在了iOS 11及以下的系统)</p></blockquote><p><strong>最后</strong>：有个最省事的方案，针对这些页面，<strong>将WKWebView替换成UIWebView</strong>。 可行，但逃避问题，不太可取，而且UIWebView、WKWebView各有一些特性，另一个不支持，比如WKWebView支持html，滚动时实时回调，而UIWebView只支持滚动停止时回调。且苹果已经不太支持UIWebView。还是早点拥抱WKWebView吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WKWebView-API&quot;&gt;&lt;a href=&quot;#WKWebView-API&quot; class=&quot;headerlink&quot; title=&quot;WKWebView API&quot;&gt;&lt;/a&gt;WKWebView API&lt;/h1&gt;&lt;h2 id=&quot;1-属性&quot;&gt;&lt;a href=&quot;#1-属性&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>数据加密 — 对称加密(以AES为例)</title>
    <link href="https://tenloy.github.io/2021/12/22/aes.html"/>
    <id>https://tenloy.github.io/2021/12/22/aes.html</id>
    <published>2021-12-22T17:52:12.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据加密简述"><a href="#一、数据加密简述" class="headerlink" title="一、数据加密简述"></a>一、数据加密简述</h2><blockquote><p>数据加密(Encryption)是指将明文信息(Plaintext)采取 <code>数学方法进行函数转换</code>成密文(Ciphertext)，只有特定接受方才能将其解密(Decryption)还原成明文的过程。</p></blockquote><p>构成:</p><ul><li>明文(Plaintext)：加密前的原始信息 </li><li>密文(Ciphertext)：明文被加密后的信息 </li><li>密钥(Key)：控制加密算法和解密算法得以实现的关键信息，分为<code>加密密钥和解密密钥</code>(必然，密钥不同，由明文生成的密文的结果也不同)</li><li>加密(Encryption)：将明文通过数学算法转换成密文的过程 </li><li>解密(Decryption)：将密文还原成明文的过程</li></ul><h3 id="1-1-密码系统的一般模型"><a href="#1-1-密码系统的一般模型" class="headerlink" title="1.1 密码系统的一般模型"></a>1.1 密码系统的一般模型</h3><img src="/images/encrypt/20.png" alt="20" style="zoom:80%;" /><ul><li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<strong>无条件安全</strong>的，或称为<strong>理论上是不可破</strong>的（这种方法是不太容易获得的，因此在现实生活中，更多是追求计算上安全即可。）</li><li>如果密码体制中的密码不能被<em>可使用的计算资源</em> 破译，则这一密码体制称为在<strong>计算上是安全的</strong>（利用已有的最好方法破译某个密码系统所需要的代价超出了破译者的能力（如时间、空间、资金等资源））</li></ul><h2 id="二、对称密钥加密-单钥加密"><a href="#二、对称密钥加密-单钥加密" class="headerlink" title="二、对称密钥加密(单钥加密)"></a>二、对称密钥加密(单钥加密)</h2><img src="/images/encrypt/21.jpg" alt="20" style="zoom:60%;" /><p>常用的对称加密算法：</p><ul><li>DES/3DES(3重DES)</li><li>IDEA</li><li>RC5</li><li>AES(Rijndael)</li></ul><p>DES早期用的很多，但是由于相对比较简单，加密的安全性偏低，所以现在一般都使用3DES或 AES来替代。</p><h3 id="2-1-对称加密的优缺点"><a href="#2-1-对称加密的优缺点" class="headerlink" title="2.1 对称加密的优缺点"></a>2.1 对称加密的优缺点</h3><p>优点：</p><ol><li>算法公开(往往是标准算法，是可以公开的)</li><li>计算量小</li><li>加密速度快(核心是替换和移位，可以用硬件来实现)</li><li>加密效率高。</li></ol><p>缺点：</p><ol><li>交易双方都使用同样钥匙，安全性得不到保证。</li><li>每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，使得发收双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户负担。</li><li>密钥分发比较困难，尤其网络环境中安全难以保障，易成为瓶颈。</li></ol><h2 id="三、AES-Rijndael"><a href="#三、AES-Rijndael" class="headerlink" title="三、AES(Rijndael)"></a>三、AES(Rijndael)</h2><blockquote><p>下面摘自 <a href="https://blog.dynox.cn/?p=1562">一篇写的非常全面的博客</a></p></blockquote><p>AES, Advanced Encryption Standard，其实是一套标准：<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS 197</a>，而我们所说的AES算法其实是Rijndael算法。</p><img src="/images/encrypt/22.png" alt="20" style="zoom:60%;" /><p>Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><p><strong>补充</strong>：<strong>代换-置换网络SPN</strong>是一系列被应用于分组密码中相关的数学运算，高级加密标准(AES)、3-Way、Kuznyechik、PRESENT、SAFER、SHARK、Square都有涉用。这种加密网络使用明文块和密钥块作为输入，并通过交错的若干“轮”（或“层”）代换操作和置换操作产生密文块。<strong>代换（Substitution）和置换（Permutation）分别被称作S盒（替换盒/S-boxes）和P盒（排列盒/P-boxes）</strong>。由于其实施于硬件的高效性，SPN的应用十分广泛。</p><h2 id="四、iOS中的AES"><a href="#四、iOS中的AES" class="headerlink" title="四、iOS中的AES"></a>四、iOS中的AES</h2><blockquote><p>部分摘自 <a href="https://www.jianshu.com/p/df828a57cb8f">简书博客1</a>，加了一些个人理解，有兴趣可以直接移步原文</p><p>iOS中的AES：iOS SDK中的Security.framework库，非openssl库  </p></blockquote><h3 id="4-1-四个参数"><a href="#4-1-四个参数" class="headerlink" title="4.1 四个参数"></a>4.1 四个参数</h3><p>AES是开发中常用的加密算法之一。然而由于前后端开发使用的语言不统一，导致经常出现前端加密而后端不能解密的情况出现。然而无论什么语言系统，AES的算法总是相同的， 因此导致结果不一致的原因在于 加密设置的参数不一致 。于是先来看看在两个平台使用AES加密时需要统一的几个参数。</p><ul><li>密钥长度（Key Size）</li><li>加密模式（Cipher Mode）</li><li>填充方式（Padding）</li><li>初始向量（Initialization Vector）</li></ul><h4 id="4-1-1-密钥长度"><a href="#4-1-1-密钥长度" class="headerlink" title="4.1.1 密钥长度"></a>4.1.1 密钥长度</h4><p><strong>AES算法标准</strong>下，key的长度有三种：128、192和256 bits。由于历史原因，JDK默认只支持不大于128 bits的密钥，而128 bits的key已能够满足商用安全需求。因此本例先使用AES-128。（Java使用大于128 bits的key方法在文末提及）</p><h4 id="4-1-2-加密模式"><a href="#4-1-2-加密模式" class="headerlink" title="4.1.2 加密模式"></a>4.1.2 加密模式</h4><p>AES属于块加密（Block Cipher），块加密中有ECB、CBC、CFB、OFB、CTR、CCM、GCM等几种工作模式。本例统一使用CBC模式。</p><h4 id="4-1-3-填充方式"><a href="#4-1-3-填充方式" class="headerlink" title="4.1.3 填充方式"></a>4.1.3 填充方式</h4><p>由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块<code>加密前进行数据填充，解密后删除掉填充的数据</code>。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）</p><ul><li><strong>NoPadding</strong>：<ul><li>顾名思义，不填充，自己对长度不足block size的部分进行填充</li></ul></li><li><strong>ZeroPadding</strong>：<ul><li>数据长度不对齐时使用0填充，否则不填充(当原数据尾部也存在0时，在unpadding时可能会存在问题)。</li></ul></li><li><strong>PKCS7Padding</strong>：<ul><li>如果数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n；</li><li>如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小。</li></ul></li><li><strong>PKCS5Padding</strong>：<ul><li>PKCS7Padding的子集，块大小固定为8字节，其它一致(即<strong>PKCS5Padding是限制块大小的PKCS7Padding</strong>)。</li></ul></li><li><strong>PKCS1Padding</strong>：<ul><li>与RSA算法一起使用，这里不再赘述</li></ul></li></ul><p>附上文档链接：</p><ul><li><a href="http://tools.ietf.org/html/rfc2315">PKCS #7: Cryptographic Message Syntax</a> 10.3节中讲到了上面提到的填充算法,  对Block Size并没有做规定</li><li><a href="http://tools.ietf.org/html/rfc2898">PKCS #5: Password-Based Cryptography Specification</a> 在6.1.1 中对 填充做了说明，该标准只讨论了 8字节(64位) 块的加密, 对其他块大小没有做说明，其填充算法跟 PKCS7是一样的</li></ul><p>使用PKCS7Padding/PKCS5Padding填充时，最后一个字节肯定为填充数据的长度，所以在解密后，取最后一位，就可以准确删除填充的数据。</p><p>在iOS SDK中提供了PKCS7Padding，而JDK则提供了PKCS5Padding(限制Block Size为8 bytes)，但AES等算法，后来都把BlockSize扩充到了16字节或更大，<strong>Java中，采用PKCS5实质上就是采用PKCS7</strong>(PKCS5Padding与PKCS7Padding填充结果是相等的）。</p><h4 id="4-1-4-初始向量"><a href="#4-1-4-初始向量" class="headerlink" title="4.1.4 初始向量"></a>4.1.4 初始向量</h4><p>使用除ECB以外的其他加密模式均需要传入一个初始向量，其<strong>大小(即串的长度)与Block Size相等</strong>（AES的Block Size为128 bits），而两个平台的API文档均指明当不传入初始向量时，系统将默认使用一个全0的初始向量。(<strong>在区块加密中，使用了初始化向量的加密模式被称为区块加密模式</strong>)</p><p>以CBC为例：IV是长度为分组大小的一组随机，通常情况下不用保密，不过在大多数情况下，针对同一密钥不应多次使用同一组IV。 CBC要求第一个分组的明文在加密运算前先与IV进行<strong>异或</strong>；从第二组开始，所有的明文先与前一分组加密后的密文进行异或。</p><h3 id="4-2-iOS实现"><a href="#4-2-iOS实现" class="headerlink" title="4.2 iOS实现"></a>4.2 iOS实现</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个初始向量IV的值。ECB模式不需要</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kInitVector = <span class="string">@&quot;16-Bytes--String&quot;</span>;</span><br><span class="line"><span class="comment">//确定密钥长度，这里选择 AES-128。即&quot;密钥是个16位字符串</span></span><br><span class="line">size_t <span class="keyword">const</span> kKeySize = kCCKeySizeAES128;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)encryptAES:(<span class="built_in">NSString</span> *)content key:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *contentData = [content dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> dataLength = contentData.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为结束符&#x27;\0&#x27; +1</span></span><br><span class="line">    <span class="keyword">char</span> keyPtr[kKeySize + <span class="number">1</span>];</span><br><span class="line">    memset(keyPtr, <span class="number">0</span>, <span class="keyword">sizeof</span>(keyPtr));</span><br><span class="line">    [key getCString:keyPtr maxLength:<span class="keyword">sizeof</span>(keyPtr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密文长度 &lt;= 明文长度 + BlockSize</span></span><br><span class="line">    size_t encryptSize = dataLength + kCCBlockSizeAES128;</span><br><span class="line">    <span class="keyword">void</span> *encryptedBytes = malloc(encryptSize);</span><br><span class="line">    size_t actualOutSize = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *initVector = [kInitVector dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      第三个参数：先查看下枚举说明，可以发现里面只有两个枚举变量，并在kCCOptionECBMode的旁边，写着Default is CBC.</span></span><br><span class="line"><span class="comment">        kCCOptionPKCS7Padding：表示函数运用CBC加密模式，并且使用PKCS7Padding的填充模式进行加密</span></span><br><span class="line"><span class="comment">        kCCOptionPKCS7Padding | kCCOptionECBMode：就表示函数运用ECB加密模式，并且使用PKCS7Padding的填充模式进行加密</span></span><br><span class="line"><span class="comment">        如果要设置NoPadding，可以填入0x0000</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, <span class="comment">//加密/解密</span></span><br><span class="line">                                          kCCAlgorithmAES, <span class="comment">//选用的加密算法</span></span><br><span class="line">                                          kCCOptionPKCS7Padding,  <span class="comment">//设置工作模式+填充</span></span><br><span class="line">                                          keyPtr,  <span class="comment">//key</span></span><br><span class="line">                                          kKeySize, <span class="comment">// key length </span></span><br><span class="line">                                          initVector.bytes, <span class="comment">// 初始向量IV的长度，如果不需要IV，设置为nil(不可以为@&quot;&quot;)</span></span><br><span class="line">                                          contentData.bytes,</span><br><span class="line">                                          dataLength,</span><br><span class="line">                                          encryptedBytes,</span><br><span class="line">                                          encryptSize,</span><br><span class="line">                                          &amp;actualOutSize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="comment">// 对加密后的数据进行 base64 编码</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="built_in">NSData</span> dataWithBytesNoCopy:encryptedBytes length:actualOutSize] base64EncodedStringWithOptions:<span class="built_in">NSDataBase64EncodingEndLineWithLineFeed</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    free(encryptedBytes);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Java实现"><a href="#4-3-Java实现" class="headerlink" title="4.3 Java实现"></a>4.3 Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理先在类中定义一个初始向量，需要与iOS端的统一。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IV_STRING = <span class="string">&quot;16-Bytes--String&quot;</span>;</span><br><span class="line"><span class="comment">//另 Java 不需手动设置密钥大小，系统会自动根据传入的 Key 进行判断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptAES</span><span class="params">(String content, String key)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException, </span></span><br><span class="line"><span class="function">            NoSuchPaddingException, UnsupportedEncodingException, </span></span><br><span class="line"><span class="function">            InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] byteContent = content.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，为了能与 iOS 统一</span></span><br><span class="line">    <span class="comment">// 这里的 key 不可以使用 KeyGenerator、SecureRandom、SecretKey 生成</span></span><br><span class="line">    <span class="keyword">byte</span>[] enCodeFormat = key.getBytes();</span><br><span class="line">    SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(enCodeFormat, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">byte</span>[] initParam = IV_STRING.getBytes();</span><br><span class="line">    IvParameterSpec ivParameterSpec = <span class="keyword">new</span> IvParameterSpec(initParam);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 指定加密的算法、工作模式和填充方式</span></span><br><span class="line">    Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">byte</span>[] encryptedBytes = cipher.doFinal(byteContent);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样对加密后数据进行 base64 编码</span></span><br><span class="line">    Encoder encoder = Base64.getEncoder();</span><br><span class="line">    <span class="keyword">return</span> encoder.encodeToString(encryptedBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于Java使用大于128 bits的key：</strong></p><p>到Oracle官网下载对应Java版本的 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">JCE</a> ，解压后放到 <strong>JAVA_HOME/jre/lib/security/</strong> ，然后修改 iOS 端的 kKeySize 和两端对应的 key 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、数据加密简述&quot;&gt;&lt;a href=&quot;#一、数据加密简述&quot; class=&quot;headerlink&quot; title=&quot;一、数据加密简述&quot;&gt;&lt;/a&gt;一、数据加密简述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据加密(Encryption)是指将明文信息(Plaintext</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] AES标准及Rijndael算法解析</title>
    <link href="https://tenloy.github.io/2021/12/21/aes-standard.html"/>
    <id>https://tenloy.github.io/2021/12/21/aes-standard.html</id>
    <published>2021-12-21T17:12:12.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://blog.dynox.cn/?p=1562">原文链接</a>，一字不差转载(防丢失)</p></blockquote><h2 id="一、AES简介"><a href="#一、AES简介" class="headerlink" title="一、AES简介"></a>一、AES简介</h2><p><strong>AES即高级加密标准</strong>(Advanced Encryption Standard)，其实是一套标准。美国国家标准与技术研究院<strong>NIST</strong>(National INstitute of Standards and Technology) 在1997年9月12日公开征集更高效更安全的替代DES加密算法，第一轮共有15种算法入选，其中5种算法入围了决赛，分别是MARS，RC6，Rijndael，Serpent和Twofish。又经过3年的验证、评测及公众讨论之后Rijndael算法最终入选。所以，我们所说的AES算法其实是<code>Rijndael算法</code>。</p><p><strong>高级加密标准</strong> 由 <strong>NIST</strong> 于2001年11月26日发布于<a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS PUB 197</a>，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><img src="/images/encrypt/02.png" alt="02" style="zoom:80%;" /><h3 id="1-1-Rijndael算法"><a href="#1-1-Rijndael算法" class="headerlink" title="1.1 Rijndael算法"></a>1.1 Rijndael算法</h3><p>Rijndael算法是由比利时学者Joan Daemen和Vincent Rijmen所提出的，算法的名字就由两位作者的名字组合而成。Rijndael的优势在于集安全性、性能、效率、可实现性及灵活性与一体。</p><h3 id="1-2-AES-vs-Rijndael"><a href="#1-2-AES-vs-Rijndael" class="headerlink" title="1.2 AES vs Rijndael"></a>1.2 AES vs Rijndael</h3><p>Rijndael算法支持多种分组及密钥长度，介于128-256之间所有32的倍数均可，最小支持128位，最大256位，共25种组合。而AES标准支持的分组大小固定为128位，密钥长度有3种选择：128位、192位及256位。</p><h3 id="1-3-加密实例"><a href="#1-3-加密实例" class="headerlink" title="1.3 加密实例"></a>1.3 加密实例</h3><p>下面针对16字节的简单明文字串“0011223344….eeff”，分别用AES-128/AES-192及AES-256进行加密运算：</p><h4 id="1-3-1-AES-128"><a href="#1-3-1-AES-128" class="headerlink" title="1.3.1 AES-128"></a>1.3.1 AES-128</h4><p>密钥选用16字节长的简单字串：“00010203….0e0f” 来，上面的明文经过加密变换后成为”69c4e0d8….6089”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">cypher:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br></pre></td></tr></table></figure><h4 id="1-3-2-AES-192"><a href="#1-3-2-AES-192" class="headerlink" title="1.3.2 AES-192"></a>1.3.2 AES-192</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d .. .. .. 17</span><br><span class="line">cypher:  dd a9 7c a4 86 4c df e0 6e af 70 a0 ec 0d 71 91</span><br></pre></td></tr></table></figure><h4 id="1-3-3-AES-256"><a href="#1-3-3-AES-256" class="headerlink" title="1.3.3 AES-256"></a>1.3.3 AES-256</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plain :  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">key   :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d .. .. .. 17 .. .. .. 1f</span><br><span class="line">cypher:  8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89</span><br></pre></td></tr></table></figure><h2 id="二、总体结构"><a href="#二、总体结构" class="headerlink" title="二、总体结构"></a>二、总体结构</h2><p>Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><img src="/images/encrypt/03.png" alt="02" style="zoom:80%;" /><p>图左侧为轮函数的流程，主要包含4种主要运算操作：字节代换(SubByte)、行移位(ShiftRow)、列混合(MixColumn)、轮密钥加(AddRoundKey)。图右侧为密钥编排方案，在Rijndael中称为密钥扩展算法（KeyExpansion）。</p><p>AES标准算法将128位的明文，以特定次序生成一个4x4的矩阵（每个元素是一个字节，8位），即初始状态（state），经由轮函数的迭代转换之后又将作为下一轮迭代的输入继续参与运算直到迭代结束。</p><p>Rijndael算法支持大于128位的明文分组，所以需要列数更多的矩阵来描述。Rijndael轮函数的运算是在特殊定义的有限域GF(256)上进行的。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。更详细有有关Rijndael算法的数学描述，可以参阅本文最后所罗列的参考资料，在此不做熬述。</p><h3 id="2-1-轮函数"><a href="#2-1-轮函数" class="headerlink" title="2.1 轮函数"></a>2.1 轮函数</h3><p>我们已经得知轮函数主要包含4种运算，但不同的运算轮所做的具体运的算组合并不相同。主要区别是初始轮（Round: 0）和最后一轮（Round: Nr），所有中间轮的运算都是相同的，会依次进行4种运算，即：</p><ol><li>字节代换(SubByte)</li><li>行移位(ShiftRow)</li><li>列混合(MixColumn)</li><li>轮密钥加(AddRoundKey)</li></ol><p>根据Rinjdael算法的定义，加密轮数会针对不同的分组及不同的密钥长度选择不同的数值：</p><img src="/images/encrypt/04.png" alt="02" style="zoom:80%;" /><p>AES标准只支持128位分组（Nb = 4）的情况。</p><p>轮函数的实现代码如下，直接实现在加密函数内部循环中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_encrypt</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len, <span class="keyword">uint8_t</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init state from user buffer (plaintext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = <span class="number">0</span>; nr &lt;= g_aes_rounds[mode]; nr++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                aes_sub_bytes(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                aes_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    aes_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-动画演示加密过程"><a href="#2-2-动画演示加密过程" class="headerlink" title="2.2 动画演示加密过程"></a>2.2 动画演示加密过程</h3><p>Enrique Zabala创建了一个AES-128加密算法的动画演示，清楚、直观地介绍了轮函数执行的过程。<a href="http://www.formaestudio.com/rijndaelinspector/archivos/Rijndael_Animation_v4_eng.swf">点击可直接观看</a>。</p><h3 id="2-3-轮函数拆解：字节代换（Substitute-Bytes）"><a href="#2-3-轮函数拆解：字节代换（Substitute-Bytes）" class="headerlink" title="2.3 轮函数拆解：字节代换（Substitute Bytes）"></a>2.3 轮函数拆解：字节代换（Substitute Bytes）</h3><img src="/images/encrypt/05.png" alt="02" style="zoom:70%;" /><p>字节代换（SubBytes）是对state矩阵中的每一个独立元素于置换盒 （Substitution-box，S盒）中进行查找并以此替换输入状态的操作。字节代换是可逆的非线性变换，也是AES运算组中唯一的非线性变换。字节代换逆操作也是通过逆向置换盒的查找及替换来完成的。</p><p>S盒是事先设计好的16x16的查询表，即256个元素。其设计不是随意的，要根据设计原则严格计算求得，不然无法保证算法的安全性。既然是S盒是计算得来，所以字节代换的操作完全可以通过计算来完成，不过通过S盒查表操作更方便快捷，图中所示就是通过S盒查找对应元素进行的替换操作。</p><img src="/images/encrypt/06.jpg" alt="02" style="zoom:75%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_sub_bytes</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            state[i * <span class="number">4</span> + j] = aes_sub_sbox(state[i * <span class="number">4</span> + j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">  sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br></pre></td></tr></table></figure><h3 id="2-4-轮函数拆解：行移位（Shift-Rows）"><a href="#2-4-轮函数拆解：行移位（Shift-Rows）" class="headerlink" title="2.4 轮函数拆解：行移位（Shift Rows）"></a>2.4 轮函数拆解：行移位（Shift Rows）</h3><img src="/images/encrypt/07.png" alt="02" style="zoom:80%;" /><p>行移位主要目的是实现字节在每一行的扩散，属于线性变换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_shift_rows</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *s = (<span class="keyword">uint8_t</span> *)state;</span><br><span class="line">    <span class="keyword">int</span> i, j, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> tmp = s[i];</span><br><span class="line">            <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; g_aes_nb[mode]; r++) &#123;</span><br><span class="line">                s[i + r * <span class="number">4</span>] = s[i + (r + <span class="number">1</span>) * <span class="number">4</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            s[i + (g_aes_nb[mode] - <span class="number">1</span>) * <span class="number">4</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br></pre></td></tr></table></figure><h3 id="2-5-轮函数拆解：列混合（Mix-Columns）"><a href="#2-5-轮函数拆解：列混合（Mix-Columns）" class="headerlink" title="2.5 轮函数拆解：列混合（Mix Columns）"></a>2.5 轮函数拆解：列混合（Mix Columns）</h3><img src="/images/encrypt/08.png" alt="02" style="zoom:75%;" /><p>列混合是通过将state矩阵与常矩阵C相乘以达成在列上的扩散，属于代替变换。列混合是Rijndael算法中最复杂的一步，其实质是在有限域GF(256)上的多项式乘法运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_mix_columns</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> y[<span class="number">16</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,  <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            s[r] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                s[r] = s[r] ^ aes_mul(state[i * <span class="number">4</span> + j], y[r * <span class="number">4</span> + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;</span><br><span class="line">            state[i * <span class="number">4</span> + r] = s[r];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line"> mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br></pre></td></tr></table></figure><h3 id="2-6-轮函数拆解：轮密钥加（Add-Round-Key）"><a href="#2-6-轮函数拆解：轮密钥加（Add-Round-Key）" class="headerlink" title="2.6 轮函数拆解：轮密钥加（Add Round Key）"></a>2.6 轮函数拆解：轮密钥加（Add Round Key）</h3><img src="/images/encrypt/09.png" alt="02" style="zoom:75%;" /><p>密钥加是将轮密钥简单地与状态进行逐比特异或。实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_add_round_key</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *state,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">uint8_t</span> *round, <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *w = (<span class="keyword">uint32_t</span> *)round;</span><br><span class="line">    <span class="keyword">uint32_t</span> *s = (<span class="keyword">uint32_t</span> *)state;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_aes_nb[mode]; i++) &#123;</span><br><span class="line">        s[i] ^= w[nr * g_aes_nb[mode] + i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br></pre></td></tr></table></figure><h3 id="2-7-密钥扩展算法（Key-Expansion）"><a href="#2-7-密钥扩展算法（Key-Expansion）" class="headerlink" title="2.7 密钥扩展算法（Key Expansion）"></a>2.7 密钥扩展算法（Key Expansion）</h3><p>密钥扩展算法是Rijndael的密钥编排实现算法，其目的是根据种子密钥（用户密钥）生成多组轮密钥。轮密钥为多组128位密钥，对应不同密钥长度，分别是11，13，15组。</p><img src="/images/encrypt/10.png" alt="02" style="zoom:80%;" /><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * nr: number of rounds</span></span><br><span class="line"><span class="comment"> * nb: number of columns comprising the state, nb = 4 dwords (16 bytes)</span></span><br><span class="line"><span class="comment"> * nk: number of 32-bit words comprising cipher key, nk = 4, 6, 8 (KeyLength/(4*8))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_key_expansion</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *round)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *w = (<span class="keyword">uint32_t</span> *)round;</span><br><span class="line">    <span class="keyword">uint32_t</span>  t;</span><br><span class="line">    <span class="keyword">int</span>      i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        w[i] = *((<span class="keyword">uint32_t</span> *)&amp;key[i * <span class="number">4</span> + <span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; g_aes_nk[mode]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i % g_aes_nk[mode]) == <span class="number">0</span>) &#123;</span><br><span class="line">            t = aes_rot_dword(w[i - <span class="number">1</span>]);</span><br><span class="line">            t = aes_sub_dword(t);</span><br><span class="line">            t = t ^ aes_swap_dword(g_aes_rcon[i/g_aes_nk[mode] - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_aes_nk[mode] &gt; <span class="number">6</span> &amp;&amp; (i % g_aes_nk[mode]) == <span class="number">4</span>) &#123;</span><br><span class="line">            t = aes_sub_dword(w[i - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        w[i] = w[i - g_aes_nk[mode]] ^ t;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (++i &lt; g_aes_nb[mode] * (g_aes_rounds[mode] + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key can be discarded (or zeroed) from memory */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以AES-128为例，从128位种子密钥生成11组轮密钥（每组128位）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    key :  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">Key Expansion:</span><br><span class="line">    00:  rs: 00010203</span><br><span class="line">    01:  rs: 04050607</span><br><span class="line">    02:  rs: 08090a0b</span><br><span class="line">    03:  rs: 0c0d0e0f</span><br><span class="line">    04:  rot: 0d0e0f0c sub: d7ab76fe rcon: 01000000 xor: fe76abd6 rs: d6aa74fd</span><br><span class="line">    05:  equ: d6aa74fd rs: d2af72fa</span><br><span class="line">    06:  equ: d2af72fa rs: daa678f1</span><br><span class="line">    07:  equ: daa678f1 rs: d6ab76fe</span><br><span class="line">    08:  rot: ab76fed6 sub: 6238bbf6 rcon: 02000000 xor: f6bb3860 rs: b692cf0b</span><br><span class="line">    09:  equ: b692cf0b rs: 643dbdf1</span><br><span class="line">    10:  equ: 643dbdf1 rs: be9bc500</span><br><span class="line">    11:  equ: be9bc500 rs: 6830b3fe</span><br><span class="line">    12:  rot: 30b3fe68 sub: 046dbb45 rcon: 04000000 xor: 45bb6d00 rs: b6ff744e</span><br><span class="line">    13:  equ: b6ff744e rs: d2c2c9bf</span><br><span class="line">    14:  equ: d2c2c9bf rs: 6c590cbf</span><br><span class="line">    15:  equ: 6c590cbf rs: 0469bf41</span><br><span class="line">    16:  rot: 69bf4104 sub: f90883f2 rcon: 08000000 xor: f28308f1 rs: 47f7f7bc</span><br><span class="line">    17:  equ: 47f7f7bc rs: 95353e03</span><br><span class="line">    18:  equ: 95353e03 rs: f96c32bc</span><br><span class="line">    19:  equ: f96c32bc rs: fd058dfd</span><br><span class="line">    20:  rot: 058dfdfd sub: 6b5d5454 rcon: 10000000 xor: 54545d7b rs: 3caaa3e8</span><br><span class="line">    21:  equ: 3caaa3e8 rs: a99f9deb</span><br><span class="line">    22:  equ: a99f9deb rs: 50f3af57</span><br><span class="line">    23:  equ: 50f3af57 rs: adf622aa</span><br><span class="line">    24:  rot: f622aaad sub: 4293ac95 rcon: 20000000 xor: 95ac9362 rs: 5e390f7d</span><br><span class="line">    25:  equ: 5e390f7d rs: f7a69296</span><br><span class="line">    26:  equ: f7a69296 rs: a7553dc1</span><br><span class="line">    27:  equ: a7553dc1 rs: 0aa31f6b</span><br><span class="line">    28:  rot: a31f6b0a sub: 0ac07f67 rcon: 40000000 xor: 677fc04a rs: 14f9701a</span><br><span class="line">    29:  equ: 14f9701a rs: e35fe28c</span><br><span class="line">    30:  equ: e35fe28c rs: 440adf4d</span><br><span class="line">    31:  equ: 440adf4d rs: 4ea9c026</span><br><span class="line">    32:  rot: a9c0264e sub: d3baf72f rcon: 80000000 xor: 2ff7ba53 rs: 47438735</span><br><span class="line">    33:  equ: 47438735 rs: a41c65b9</span><br><span class="line">    34:  equ: a41c65b9 rs: e016baf4</span><br><span class="line">    35:  equ: e016baf4 rs: aebf7ad2</span><br><span class="line">    36:  rot: bf7ad2ae sub: 08dab5e4 rcon: 1b000000 xor: e4b5da13 rs: 549932d1</span><br><span class="line">    37:  equ: 549932d1 rs: f0855768</span><br><span class="line">    38:  equ: f0855768 rs: 1093ed9c</span><br><span class="line">    39:  equ: 1093ed9c rs: be2c974e</span><br><span class="line">    40:  rot: 2c974ebe sub: 71882fae rcon: 36000000 xor: ae2f8847 rs: 13111d7f</span><br><span class="line">    41:  equ: 13111d7f rs: e3944a17</span><br><span class="line">    42:  equ: e3944a17 rs: f307a78b</span><br><span class="line">    43:  equ: f307a78b rs: 4d2b30c5</span><br></pre></td></tr></table></figure><h3 id="2-8-加密过程实例"><a href="#2-8-加密过程实例" class="headerlink" title="2.8 加密过程实例"></a>2.8 加密过程实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Encrypting block ...</span><br><span class="line"> Round 0:</span><br><span class="line">   input:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">   round:  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">   state:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line"> Round 1:</span><br><span class="line">   input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">     sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">   shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line">     mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">   round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">   state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line"> Round 2:</span><br><span class="line">   input:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line">     sub:  a7 61 ca 9b 97 be 8b 45 d8 ad 1a 61 1f c9 73 69</span><br><span class="line">   shift:  a7 be 1a 69 97 ad 73 9b d8 c9 ca 45 1f 61 8b 61</span><br><span class="line">     mix:  ff 87 96 84 31 d8 6a 51 64 51 51 fa 77 3a d0 09</span><br><span class="line">   round:  b6 92 cf 0b 64 3d bd f1 be 9b c5 00 68 30 b3 fe</span><br><span class="line">   state:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line"> Round 3:</span><br><span class="line">   input:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line">     sub:  3b 59 cb 73 fc d9 0e e0 57 74 22 2d c0 67 fb 68</span><br><span class="line">   shift:  3b d9 22 68 fc 74 fb 73 57 67 cb e0 c0 59 0e 2d</span><br><span class="line">     mix:  4c 9c 1e 66 f7 71 f0 76 2c 3f 86 8e 53 4d f2 56</span><br><span class="line">   round:  b6 ff 74 4e d2 c2 c9 bf 6c 59 0c bf 04 69 bf 41</span><br><span class="line">   state:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line"> Round 4:</span><br><span class="line">   input:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line">     sub:  2d fb 02 34 3f 6d 12 dd 09 33 7e c7 5b 36 e3 f0</span><br><span class="line">   shift:  2d 6d 7e f0 3f 33 e3 34 09 36 02 dd 5b fb 12 c7</span><br><span class="line">     mix:  63 85 b7 9f fc 53 8d f9 97 be 47 8e 75 47 d6 91</span><br><span class="line">   round:  47 f7 f7 bc 95 35 3e 03 f9 6c 32 bc fd 05 8d fd</span><br><span class="line">   state:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line"> Round 5:</span><br><span class="line">   input:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line">     sub:  36 40 09 26 f9 33 6d 2d 9f b5 9d 23 c4 2c 39 50</span><br><span class="line">   shift:  36 33 9d 50 f9 b5 39 26 9f 2c 09 2d c4 40 6d 23</span><br><span class="line">     mix:  f4 bc d4 54 32 e5 54 d0 75 f1 d6 c5 1d d0 3b 3c</span><br><span class="line">   round:  3c aa a3 e8 a9 9f 9d eb 50 f3 af 57 ad f6 22 aa</span><br><span class="line">   state:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line"> Round 6:</span><br><span class="line">   input:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line">     sub:  e8 47 f5 65 14 da dd e2 3f 77 b6 4f e7 f7 d4 90</span><br><span class="line">   shift:  e8 da b6 90 14 77 d4 65 3f f7 f5 e2 e7 47 dd 4f</span><br><span class="line">     mix:  98 16 ee 74 00 f8 7f 55 6b 2c 04 9c 8e 5a d0 36</span><br><span class="line">   round:  5e 39 0f 7d f7 a6 92 96 a7 55 3d c1 0a a3 1f 6b</span><br><span class="line">   state:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line"> Round 7:</span><br><span class="line">   input:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line">     sub:  b4 15 f8 01 68 58 55 2e 4b b6 12 4c 5f 99 8a 4c</span><br><span class="line">   shift:  b4 58 12 4c 68 b6 8a 01 4b 99 f8 2e 5f 15 55 4c</span><br><span class="line">     mix:  c5 7e 1c 15 9a 9b d2 86 f0 5f 4b e0 98 c6 34 39</span><br><span class="line">   round:  14 f9 70 1a e3 5f e2 8c 44 0a df 4d 4e a9 c0 26</span><br><span class="line">   state:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line"> Round 8:</span><br><span class="line">   input:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line">     sub:  3e 17 50 76 b6 1c 04 67 8d fc 22 95 f6 a8 bf c0</span><br><span class="line">   shift:  3e 1c 22 c0 b6 fc bf 76 8d a8 50 67 f6 17 04 95</span><br><span class="line">     mix:  ba a0 3d e7 a1 f9 b5 6e d5 51 2c ba 5f 41 4d 23</span><br><span class="line">   round:  47 43 87 35 a4 1c 65 b9 e0 16 ba f4 ae bf 7a d2</span><br><span class="line">   state:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line"> Round 9:</span><br><span class="line">   input:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line">     sub:  54 11 f4 b5 6b d9 70 0e 96 a0 90 2f a1 bb 9a a1</span><br><span class="line">   shift:  54 d9 90 a1 6b a0 9a b5 96 bb f4 0e a1 11 70 2f</span><br><span class="line">     mix:  e9 f7 4e ec 02 30 20 f6 1b f2 cc f2 35 3c 21 c7</span><br><span class="line">   round:  54 99 32 d1 f0 85 57 68 10 93 ed 9c be 2c 97 4e</span><br><span class="line">   state:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line"> Round 10:</span><br><span class="line">   input:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line">     sub:  7a 9f 10 27 89 d5 f5 0b 2b ef fd 9f 3d ca 4e a7</span><br><span class="line">   shift:  7a d5 fd a7 89 ef 4e 27 2b ca 10 0b 3d 9f f5 9f</span><br><span class="line">   round:  13 11 1d 7f e3 94 4a 17 f3 07 a7 8b 4d 2b 30 c5</span><br><span class="line">   state:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br><span class="line">Output:</span><br><span class="line">  cypher:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br></pre></td></tr></table></figure><h3 id="2-9-解密轮函数"><a href="#2-9-解密轮函数" class="headerlink" title="2.9 解密轮函数"></a>2.9 解密轮函数</h3><p>对Rijndael算法来说，<strong>解密过程就是加密过程的逆向过程</strong>，其解密轮函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_decrypt</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len, <span class="keyword">uint8_t</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init state from user buffer (cyphertext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = g_aes_rounds[mode]; nr &gt;= <span class="number">0</span>; nr--) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    inv_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                inv_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                inv_sub_bytes(mode, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-解密过程实例"><a href="#2-10-解密过程实例" class="headerlink" title="2.10 解密过程实例"></a>2.10 解密过程实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Decrypting block ...</span><br><span class="line"> Round 10:</span><br><span class="line">   input:  69 c4 e0 d8 6a 7b 04 30 d8 cd b7 80 70 b4 c5 5a</span><br><span class="line">   round:  13 11 1d 7f e3 94 4a 17 f3 07 a7 8b 4d 2b 30 c5</span><br><span class="line">   shift:  7a d5 fd a7 89 ef 4e 27 2b ca 10 0b 3d 9f f5 9f</span><br><span class="line">     sub:  7a 9f 10 27 89 d5 f5 0b 2b ef fd 9f 3d ca 4e a7</span><br><span class="line">   state:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line"> Round 9:</span><br><span class="line">   input:  bd 6e 7c 3d f2 b5 77 9e 0b 61 21 6e 8b 10 b6 89</span><br><span class="line">   round:  54 99 32 d1 f0 85 57 68 10 93 ed 9c be 2c 97 4e</span><br><span class="line">     mix:  e9 f7 4e ec 02 30 20 f6 1b f2 cc f2 35 3c 21 c7</span><br><span class="line">   shift:  54 d9 90 a1 6b a0 9a b5 96 bb f4 0e a1 11 70 2f</span><br><span class="line">     sub:  54 11 f4 b5 6b d9 70 0e 96 a0 90 2f a1 bb 9a a1</span><br><span class="line">   state:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line"> Round 8:</span><br><span class="line">   input:  fd e3 ba d2 05 e5 d0 d7 35 47 96 4e f1 fe 37 f1</span><br><span class="line">   round:  47 43 87 35 a4 1c 65 b9 e0 16 ba f4 ae bf 7a d2</span><br><span class="line">     mix:  ba a0 3d e7 a1 f9 b5 6e d5 51 2c ba 5f 41 4d 23</span><br><span class="line">   shift:  3e 1c 22 c0 b6 fc bf 76 8d a8 50 67 f6 17 04 95</span><br><span class="line">     sub:  3e 17 50 76 b6 1c 04 67 8d fc 22 95 f6 a8 bf c0</span><br><span class="line">   state:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line"> Round 7:</span><br><span class="line">   input:  d1 87 6c 0f 79 c4 30 0a b4 55 94 ad d6 6f f4 1f</span><br><span class="line">   round:  14 f9 70 1a e3 5f e2 8c 44 0a df 4d 4e a9 c0 26</span><br><span class="line">     mix:  c5 7e 1c 15 9a 9b d2 86 f0 5f 4b e0 98 c6 34 39</span><br><span class="line">   shift:  b4 58 12 4c 68 b6 8a 01 4b 99 f8 2e 5f 15 55 4c</span><br><span class="line">     sub:  b4 15 f8 01 68 58 55 2e 4b b6 12 4c 5f 99 8a 4c</span><br><span class="line">   state:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line"> Round 6:</span><br><span class="line">   input:  c6 2f e1 09 f7 5e ed c3 cc 79 39 5d 84 f9 cf 5d</span><br><span class="line">   round:  5e 39 0f 7d f7 a6 92 96 a7 55 3d c1 0a a3 1f 6b</span><br><span class="line">     mix:  98 16 ee 74 00 f8 7f 55 6b 2c 04 9c 8e 5a d0 36</span><br><span class="line">   shift:  e8 da b6 90 14 77 d4 65 3f f7 f5 e2 e7 47 dd 4f</span><br><span class="line">     sub:  e8 47 f5 65 14 da dd e2 3f 77 b6 4f e7 f7 d4 90</span><br><span class="line">   state:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line"> Round 5:</span><br><span class="line">   input:  c8 16 77 bc 9b 7a c9 3b 25 02 79 92 b0 26 19 96</span><br><span class="line">   round:  3c aa a3 e8 a9 9f 9d eb 50 f3 af 57 ad f6 22 aa</span><br><span class="line">     mix:  f4 bc d4 54 32 e5 54 d0 75 f1 d6 c5 1d d0 3b 3c</span><br><span class="line">   shift:  36 33 9d 50 f9 b5 39 26 9f 2c 09 2d c4 40 6d 23</span><br><span class="line">     sub:  36 40 09 26 f9 33 6d 2d 9f b5 9d 23 c4 2c 39 50</span><br><span class="line">   state:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line"> Round 4:</span><br><span class="line">   input:  24 72 40 23 69 66 b3 fa 6e d2 75 32 88 42 5b 6c</span><br><span class="line">   round:  47 f7 f7 bc 95 35 3e 03 f9 6c 32 bc fd 05 8d fd</span><br><span class="line">     mix:  63 85 b7 9f fc 53 8d f9 97 be 47 8e 75 47 d6 91</span><br><span class="line">   shift:  2d 6d 7e f0 3f 33 e3 34 09 36 02 dd 5b fb 12 c7</span><br><span class="line">     sub:  2d fb 02 34 3f 6d 12 dd 09 33 7e c7 5b 36 e3 f0</span><br><span class="line">   state:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line"> Round 3:</span><br><span class="line">   input:  fa 63 6a 28 25 b3 39 c9 40 66 8a 31 57 24 4d 17</span><br><span class="line">   round:  b6 ff 74 4e d2 c2 c9 bf 6c 59 0c bf 04 69 bf 41</span><br><span class="line">     mix:  4c 9c 1e 66 f7 71 f0 76 2c 3f 86 8e 53 4d f2 56</span><br><span class="line">   shift:  3b d9 22 68 fc 74 fb 73 57 67 cb e0 c0 59 0e 2d</span><br><span class="line">     sub:  3b 59 cb 73 fc d9 0e e0 57 74 22 2d c0 67 fb 68</span><br><span class="line">   state:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line"> Round 2:</span><br><span class="line">   input:  49 15 59 8f 55 e5 d7 a0 da ca 94 fa 1f 0a 63 f7</span><br><span class="line">   round:  b6 92 cf 0b 64 3d bd f1 be 9b c5 00 68 30 b3 fe</span><br><span class="line">     mix:  ff 87 96 84 31 d8 6a 51 64 51 51 fa 77 3a d0 09</span><br><span class="line">   shift:  a7 be 1a 69 97 ad 73 9b d8 c9 ca 45 1f 61 8b 61</span><br><span class="line">     sub:  a7 61 ca 9b 97 be 8b 45 d8 ad 1a 61 1f c9 73 69</span><br><span class="line">   state:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line"> Round 1:</span><br><span class="line">   input:  89 d8 10 e8 85 5a ce 68 2d 18 43 d8 cb 12 8f e4</span><br><span class="line">   round:  d6 aa 74 fd d2 af 72 fa da a6 78 f1 d6 ab 76 fe</span><br><span class="line">     mix:  5f 72 64 15 57 f5 bc 92 f7 be 3b 29 1d b9 f9 1a</span><br><span class="line">   shift:  63 53 e0 8c 09 60 e1 04 cd 70 b7 51 ba ca d0 e7</span><br><span class="line">     sub:  63 ca b7 04 09 53 d0 51 cd 60 e0 e7 ba 70 e1 8c</span><br><span class="line">   state:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line"> Round 0:</span><br><span class="line">   input:  00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0</span><br><span class="line">   round:  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f</span><br><span class="line">   state:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br><span class="line">Output:</span><br><span class="line">   plain:  00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff</span><br></pre></td></tr></table></figure><h2 id="三、算法设计思想"><a href="#三、算法设计思想" class="headerlink" title="三、算法设计思想"></a>三、算法设计思想</h2><h3 id="3-1-加密算法的一般设计准则"><a href="#3-1-加密算法的一般设计准则" class="headerlink" title="3.1 加密算法的一般设计准则"></a>3.1 加密算法的一般设计准则</h3><p>混淆 (Confusion) 最大限度地复杂化密文、明文与密钥之间的关系，通常用非线性变换算法达到最大化的混淆。</p><p>扩散 (Diffusion) 明文或密钥每变动一位将最大化地影响密文中的位数，通常采用线性变换算法达到最大化的扩散。</p><h3 id="3-2-AES评判要求"><a href="#3-2-AES评判要求" class="headerlink" title="3.2 AES评判要求"></a>3.2 AES评判要求</h3><p>NIST在征集算法的时候就提出了几项硬性要求：</p><ul><li>分组加密算法：支持128位分组大小，128/192/256位密钥</li><li>安全性不低于3DES，但实施与执行要比3DES的更高效</li><li>优化过的ANSI C的实现代码</li><li>KAT(Known-Answer tests)及MCT(Monte Carlo Tests)测试及验证</li><li>软件及硬件实现的便捷</li><li>可抵御已知攻击</li></ul><h3 id="3-3-Rijndael设计思想"><a href="#3-3-Rijndael设计思想" class="headerlink" title="3.3 Rijndael设计思想"></a>3.3 Rijndael设计思想</h3><ul><li>安全性（Security） 算法足够强，抗攻击</li><li>经济性（Efficiency） 算法运算效率高</li><li>密钥捷变（Key Agility） 更改密钥所引入的损失尽量小，即最小消耗的密钥扩展算法</li><li>适应性 （Versatility） 适用于不同的CPU架构，软件或硬件平台的实现</li><li>设计简单（Simplicity） 轮函数的设计精简，只是多轮迭代</li></ul><h3 id="3-4-S盒设计"><a href="#3-4-S盒设计" class="headerlink" title="3.4 S盒设计"></a>3.4 S盒设计</h3><p>S盒是由一个有限域GF(256)上的乘法求逆并串联线性仿射变换所构造出来的，不是一个随意构造的简单查询表。因其运算复杂，众多的AES 软件及硬件实现直接使用了查找表(LUP, Look-up table)，但查询表的方式并不适合所有场景，针对特定的硬件最小化面积设计需求，则要采用优化的组合逻辑以得到同价的S盒替换。</p><h2 id="四、工作模式"><a href="#四、工作模式" class="headerlink" title="四、工作模式"></a>四、工作模式</h2><p>分组加密算法是按分组大小来进行加解密操作的，如DES算法的分组是64位，而AES是128位，但实际明文的长度一般要远大于分组大小，这样的情况如何处理呢？</p><p>这正是”mode of operation”即工作模式要解决的问题：明文数据流怎样按分组大小切分，数据不对齐的情况怎么处理等等。</p><p>早在1981年，DES算法公布之后，NIST在标准文献FIPS 81中公布了4种工作模式：</p><ul><li>电子密码本：Electronic Code Book Mode (ECB)</li><li>密码分组链接：Cipher Block Chaining Mode (CBC)</li><li>密文反馈：Cipher Feedback Mode (CFB)</li><li>输出反馈：Output Feedback Mode (OFB)</li></ul><p>2001年又针对AES加入了新的工作模式：</p><ul><li>计数器模式：Counter Mode (CTR)</li></ul><p>后来又陆续引入其它新的工作模式。在此仅介绍几种常用的：</p><h3 id="4-1-ECB：电子密码本模式"><a href="#4-1-ECB：电子密码本模式" class="headerlink" title="4.1 ECB：电子密码本模式"></a>4.1 ECB：电子密码本模式</h3><p>ECB模式只是将明文按分组大小切分，然后用同样的密钥正常加密切分好的明文分组。</p><img src="/images/encrypt/11.png" alt="02" style="zoom:100%;" /><p>ECB的理想应用场景是短数据（如加密密钥）的加密。此模式的问题是无法隐藏原明文数据的模式，因为同样的明文分组加密得到的密文也是一样的。</p><p>举例来说明，下图为明文图片：</p><img src="/images/encrypt/12.png" alt="02" style="zoom:50%;" /><p>经ECB模式加密的图片：</p><img src="/images/encrypt/13.png" alt="02" style="zoom:50%;" /><p>图中也正好验证了AES的扩散效果：作为局部图案的叶子，其红颜色在加密后扩散到了整张图片上。</p><p>经CBC模式加密的图片：</p><img src="/images/encrypt/14.jpg" alt="02" style="zoom:50%;" /><h3 id="4-2-CBC：密码分组链接模式"><a href="#4-2-CBC：密码分组链接模式" class="headerlink" title="4.2 CBC：密码分组链接模式"></a>4.2 CBC：密码分组链接模式</h3><p>此模式是1976年由IBM所发明，引入了IV（初始化向量：Initialization Vector）的概念。IV是长度为分组大小的一组随机，通常情况下不用保密，不过在大多数情况下，针对同一密钥不应多次使用同一组IV。 CBC要求第一个分组的明文在加密运算前先与IV进行异或；从第二组开始，所有的明文先与前一分组加密后的密文进行异或。[区块链(blockchain)的鼻祖！]  </p><img src="/images/encrypt/15.png" alt="02" style="zoom:70%;" /><p>CBC模式相比ECB实现了更好的模式隐藏，但因为其将密文引入运算，加解密操作无法并行操作。同时引入的IV向量，还需要加、解密双方共同知晓方可。</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_encrypt_cbc</span><span class="params">(AES_CYPHER_T mode, <span class="keyword">uint8_t</span> *data, <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> *iv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> w[<span class="number">4</span> * <span class="number">4</span> * <span class="number">15</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* round key */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> s[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* state */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> v[<span class="number">4</span> * <span class="number">4</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">/* iv */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nr, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key expansion */</span></span><br><span class="line">    aes_key_expansion(mode, key, w);</span><br><span class="line">    <span class="built_in">memcpy</span>(v, iv, <span class="keyword">sizeof</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start data cypher loop over input buffer */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span> * g_aes_nb[mode]) &#123;</span><br><span class="line">        <span class="comment">/* init state from user buffer (plaintext) */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            s[j] = data[i + j] ^ v[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* start AES cypher loop over all AES rounds */</span></span><br><span class="line">        <span class="keyword">for</span> (nr = <span class="number">0</span>; nr &lt;= g_aes_rounds[mode]; nr++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nr &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do SubBytes */</span></span><br><span class="line">                aes_sub_bytes(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* do ShiftRows */</span></span><br><span class="line">                aes_shift_rows(mode, s);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nr &lt; g_aes_rounds[mode]) &#123;</span><br><span class="line">                    <span class="comment">/* do MixColumns */</span></span><br><span class="line">                    aes_mix_columns(mode, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* do AddRoundKey */</span></span><br><span class="line">            aes_add_round_key(mode, s, w, nr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* save state (cypher) to user buffer */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span> * g_aes_nb[mode]; j++)</span><br><span class="line">            data[i + j] = v[j] = s[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-CFB：密文反馈模式"><a href="#4-3-CFB：密文反馈模式" class="headerlink" title="4.3 CFB：密文反馈模式"></a>4.3 CFB：密文反馈模式</h3><p>与CBC模式类似，但不同的地方在于，CFB模式先生成密码流字典，然后用密码字典与明文进行异或操作并最终生成密文。后一分组的密码字典的生成需要前一分组的密文参与运算。</p><img src="/images/encrypt/16.png" alt="02" style="zoom:70%;" /><p>CFB模式是用分组算法实现流算法，明文数据不需要按分组大小对齐。</p><h3 id="4-4-OFB：输出反馈模式"><a href="#4-4-OFB：输出反馈模式" class="headerlink" title="4.4 OFB：输出反馈模式"></a>4.4 OFB：输出反馈模式</h3><p>OFB模式与CFB模式不同的地方是：生成字典的时候会采用明文参与运算，CFB采用的是密文。</p><img src="/images/encrypt/17.png" alt="02" style="zoom:70%;" /><h3 id="4-5-CTR：计数器模式模式"><a href="#4-5-CTR：计数器模式模式" class="headerlink" title="4.5 CTR：计数器模式模式"></a>4.5 CTR：计数器模式模式</h3><p>CTR模式同样会产生流密码字典，但同是会引入一个计数，以保证任意长时间均不会产生重复输出。</p><img src="/images/encrypt/18.png" alt="02" style="zoom:70%;" /><p>CTR模式只需要实现加密算法以生成字典，明文数据与之异或后得到密文，反之便是解密过程。CTR模式可以采用并行算法处理以提升吞量，另外加密数据块的访问可以是随机的，与前后上下文无关。</p><h3 id="4-6-CCM：Counter-with-CBC-MAC"><a href="#4-6-CCM：Counter-with-CBC-MAC" class="headerlink" title="4.6 CCM：Counter with CBC-MAC"></a>4.6 CCM：Counter with CBC-MAC</h3><p>CCM模式，全称是Counter with Cipher Block Chaining-Message Authentication Code，是CTR工作模式和CMAC认证算法的组合体，可以同时数据加密和鉴别服务。</p><p>明文数据通过CTR模式加密成密文，然后在密文后面再附加上认证数据，所以最终的密文会比明文要长。具体的加密流程如下描述：先对明文数据认证并产生一个tag，在后续加密过程中使用此tag和IV生成校验值U。然后用CTR模式来加密原输入明文数据，在密文的后面附上校验码Ｕ。</p><h3 id="4-7-GCM：伽罗瓦计数器模式"><a href="#4-7-GCM：伽罗瓦计数器模式" class="headerlink" title="4.7 GCM：伽罗瓦计数器模式"></a>4.7 GCM：伽罗瓦计数器模式</h3><p>类型CCM模式，GCM模式是CTR和GHASH的组合，GHASH操作定义为密文结果与密钥以及消息长度在GF（2^128）域上相乘。GCM比CCM的优势是在于更高并行度及更好的性能。TLS 1.2标准使用的就是AES-GCM算法，并且Intel CPU提供了GHASH的硬件加速功能。</p><h2 id="五、硬件加速"><a href="#五、硬件加速" class="headerlink" title="五、硬件加速"></a>五、硬件加速</h2><p>AES作为主导的加密标准，其应用越来越广泛，特别是针对网络数据的加密需求，越来越多的硬件都集成AES 128/192/256位算法及不同的工作模式的硬件加速的实现。</p><h3 id="5-1-AES-NI-X86架构"><a href="#5-1-AES-NI-X86架构" class="headerlink" title="5.1 AES_NI: X86架构"></a>5.1 AES_NI: X86架构</h3><p>Intel于2010发发布了支持AES加速的CPU，实现了高阶的AES加解密指令即AES_NI：AES New Instructions。AES_NI包含6指令：其中4条用于加解密，2条用于密钥扩展。根据<a href="https://software.intel.com/sites/default/files/article/165683/aes-wp-2012-09-22-v01.pdf">AES_NI白皮书</a>中所说，AES_NI可以带来2-3倍的性能提升。</p><table><thead><tr><th>Instruction</th><th>Description</th></tr></thead><tbody><tr><td>AESENC</td><td>Perform one round of an AES encryption flow</td></tr><tr><td>AESENCLAST</td><td>Perform the last round of an AES encryption flow</td></tr><tr><td>AESDEC</td><td>Perform one round of an AES decryption flow</td></tr><tr><td>AESDECLAST</td><td>Perform the last round of an AES decryption flow</td></tr><tr><td>AESKEYGENASSIST</td><td>Assist in AES round key generation</td></tr><tr><td>AESIMC</td><td>Assist in AES Inverse Mix Columns</td></tr></tbody></table><p>目前OpenSSL，Linux’s Crypto API以及Windows Cryptography API中均已加入对AES_NI的支持。</p><h4 id="AES-NI-测试"><a href="#AES-NI-测试" class="headerlink" title="AES_NI: 测试"></a>AES_NI: 测试</h4><p>测试环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz 4 Cores with HyperThread (Enabled or Disabled)</span><br><span class="line">Ubuntu 16.04 AMD64, OpenSSL 1.0.2g-fips  1 Mar 2016</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关闭硬件加速1&#x2F;2&#x2F;4&#x2F;8线程AES-256&#x2F;128-CBC：</span><br><span class="line">OPENSSL_ia32cap&#x3D;&quot;~0x200000200000000&quot; openssl speed -multi &#123;1&#x2F;2&#x2F;4&#x2F;8&#125; -elapsed -evp &#123;aes-256&#x2F;128-cbc&#125;</span><br><span class="line"></span><br><span class="line">开启硬件加速1&#x2F;2&#x2F;4&#x2F;8线程AES-256&#x2F;128-CBC：</span><br><span class="line">openssl speed -multi &#123;1&#x2F;2&#x2F;4&#x2F;8&#125; -elapsed -evp &#123;aes-256&#x2F;128-cbc&#125;</span><br><span class="line"></span><br><span class="line">超线程的开户与关闭只能通过UEFI&#x2F;BIOS来设置，测试命令同上。</span><br></pre></td></tr></table></figure><img src="/images/encrypt/19.png" alt="02" style="zoom:95%;" /><p>从图中可以得到如下结论：</p><ol><li> AES_NI加速可以提升性能1倍多，AESNI-128基本上都是AES-128的2.2倍左右。</li><li> AES-128与AES-256的性能比基本在1.36左右（15/11，忽略密钥编排用时的情况下）</li><li> 比较有趣的一点发现是，超线程所带来的影响比预想的要大得多。针对高并行的情形，在开启AES_NI时超线程可以带来接近1倍的性能提升；但在关闭AES_NI的情况下对性能提升的贡献要小的多。超线程虽然逻辑上让我们觉得一核变成了两核，其实质只是同一物理核上的队列管理机制，关闭AES_NI的情况下的测试数据基本验证了这一点。另一方面AES_NI硬件加速是基于物理核的，不可能是针对超线程的，所以超线程与AES_NI组合所带来的巨大的性能提升让人有些费解，比较可能的解释是AES_NI硬件加速引擎的潜力足够强大以至于一个物理核心不能完全发挥其效能，所以在超线程开启的情况下能有更好的表现。</li></ol><h3 id="5-2-ARM及其它体系"><a href="#5-2-ARM及其它体系" class="headerlink" title="5.2 ARM及其它体系"></a>5.2 ARM及其它体系</h3><p>2011年发布的ARMv8-A处理器架构开始支持AES加速指令，其指令集与AES_NI不兼容但实现了类似的功能。除ARM外，SUN SPARC(T4, T5, M5以后)及IBM Power7+架构的CPU均已支持AES加速。</p><h2 id="六、实现上的安全性考虑"><a href="#六、实现上的安全性考虑" class="headerlink" title="六、实现上的安全性考虑"></a>六、实现上的安全性考虑</h2><h3 id="6-1-内存与交换"><a href="#6-1-内存与交换" class="headerlink" title="6.1 内存与交换"></a>6.1 内存与交换</h3><p>程序如果将密钥存储在可交换内存页中，在内存吃紧的情况下有可能会交换出来并写入磁盘。如辅以代码逆向等，密钥很有可能会泄露。</p><p>应用层最好用mlock(Linux)或VirtualLock(Windows)来防止内存页被交换至磁盘。</p><p>但因为密钥在内存中，所以任何能访问内存的方式均有可能导致密钥的泄漏。曾流行的一种攻击是通过1394 DMA方式来访问目标机内存，Linux/Windows Login bypass，Windows bitlock等漏洞均由起引起。较新的CPU为硬件虚拟化所引入的IO MMU （Intel VT-d or AMD-Vi）可以有效地限制硬件对内存的访问权限。</p><h3 id="6-2-传统攻击"><a href="#6-2-传统攻击" class="headerlink" title="6.2 传统攻击"></a>6.2 传统攻击</h3><p>AES从产生至今依然是最安全的加密算法，传统攻击手段依然无法撼动其安全性。虽然已有<a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html">攻击手段</a>显示可以将AES-256的暴力搜索次数从2^256次降至2^119次，但依然没有实际操作价值。</p><p>不过随着计算力的提升，特别是量子计算机的发展，AES将不再是安全的。不过可以肯定的是：一定会出现更安全的加密算法。</p><h3 id="6-3-旁路攻击"><a href="#6-3-旁路攻击" class="headerlink" title="6.3 旁路攻击"></a>6.3 旁路攻击</h3><p>旁路攻击（Side-channel attack, SCA）是指绕过对加密算法的正面对抗及分析，利用硬件实现加密算法的逻辑电路在运算中所泄露的信息，如执行时间、功耗、电磁辐射等，并结合统计理论来实现对密码系统攻击的手段。</p><p>旁路攻击成功的必要条件：</p><ol><li> 在泄漏的物理信号与处理的数据之间建立关联</li><li> 在信息泄漏模型中处理的数据与芯片中处理的数据之间建立关联</li></ol><p>智能卡CPU的实现逻辑相对比较简单，并且都是单线程处理机制，因此可以很好的建立起密码-时序或密码-功耗之间的关联。</p><h4 id="6-3-1-时序攻击"><a href="#6-3-1-时序攻击" class="headerlink" title="6.3.1 时序攻击"></a>6.3.1 时序攻击</h4><p>不同的数值及不同的运算所需时间是不同的，在算法(运算逻辑)固定的前提下完全可以根据运行时间反推出具体的操作数。举个简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strelen(passwd) != <span class="keyword">sizeof</span>(fixed_passwd))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(fixed_passwd); i++)</span><br><span class="line">  <span class="keyword">if</span> (passwd[i] != fixed_passwd[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码在密码的判断上就存在时序攻击的漏洞，如果第一个字符不匹配则直接退出，只有在当前字符匹配的情况下才会继续下一个字符的比较。</p><p>所以如果实际密码长度为8位且只能用字母及数字，则理论上暴力搜索次数为 (26 *2 + 10) ^ 8。但因为算法的实现没有考虑到时序攻击，如果将执行时间加入考量，则搜索次数将降低至(26 *2 + 10) * 8。</p><p>本文示例代码中aes_mul()的实现也有时序攻击的漏洞，并且实现效率也比较低，当然主要目的是为了算法演示。</p><h4 id="6-3-2-功耗攻击"><a href="#6-3-2-功耗攻击" class="headerlink" title="6.3.2 功耗攻击"></a>6.3.2 功耗攻击</h4><p>当信号发生0-1跳变时，需要电源对电容进行充电；而在其它三种情况(0-0, 1-1, 1-0)下则不会进行充电操作，因此可以很容易区分出前者来，这就是功耗攻击原理的简单解释。</p><p>功耗攻击一般分为简单功耗攻击(Simple Power Analysis，SPA)，差分功耗攻击(Differential Power Analysis, DPA)，高阶DPA等。SPA可以揭示出执行操作和能耗泄露间的关系，而DPA则能够揭示出处理数据和能耗泄露间的关系。</p><p>DPA利用不同数据对应的条件功耗分布的差异进行统计分析以找出数值与功耗的微弱关联性，并利用此关联性极大的降低密钥的搜索空间，进而完成高效且低成本的攻击。</p><p>上海交大的教授<a href="http://yuyu.hk/">郁昱</a>就通过功耗攻击成功破解了来自多家手机制造商以及服务供应商的SIM卡的密钥。更详细信息可见于他在Blackhat 2015年的<a href="http://yuyu.hk/files/us-15-Yu-Cloning-3G-4G-Sim-Cards.pdf">演示稿: Cloning 3G/4G SIM Cards with a PC and an Oscilloscope: Lessons Learned in Physical Security</a>。</p><p>以色列特拉维夫大学的研究人员利用旁路攻击，成功从Android和iOS设备上窃取到用于加密比特币钱包、Apple Pay账号和其他高价值资产的密钥，详细请参阅<a href="https://www.cs.tau.ac.il/~tromer/mobilesc/mobilesc.pdf">论文: ECDSA Key Extraction from Mobile Devices via Nonintrusive Physical Side Channels</a>。</p><h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><ol><li> 密码学原理与实践(第二版)，Douglas R. Stinson，<strong>冯登国</strong>译</li><li> <a href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">AES Proposal: Rijndael by Joan Daemen and Vincent Rijmen</a></li><li> <a href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">FIPS 197: <strong>Announcing the AES</strong></a></li><li> <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard - <strong>Wikipedia</strong></a></li><li> <a href="http://www.springer.com/gp/book/9783540425809">The Design of Rijndael by Joan Daemen &amp; Vincent Rijmen</a></li><li> The Block Cipher Companion, <strong>L. Knudsen &amp; M. Robshaw</strong>, 2011</li><li> 加密芯片的旁道攻击防御对策研究(博士学位论文),  <strong>李海军</strong>, 2008</li><li> <a href="https://g2ex.github.io/2016/05/31/Power-Analysis-Attacks-on-Smart-Card/">旁路之能量分析攻击总结</a></li><li> AES算法介绍: <strong>万天添</strong>，2015/3/23</li><li> <a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES_NI - <strong>Wikipedia</strong></a></li><li> <a href="https://software.intel.com/en-us/articles/intel-advanced-encryption-standard-aes-instructions-set/">AES_NI v3.01 - <strong>Intel</strong></a></li></ol><h2 id="八、相关代码"><a href="#八、相关代码" class="headerlink" title="八、相关代码"></a>八、相关代码</h2><ol><li> <a href="https://github.com/matt-wu/AES/">https://github.com/matt-wu/AES/</a></li></ol><p>&lt;最早的手工计算AES-128的想法源于2016年底读过的一本书《How Software Works: The Magic Behind Encryption …》，在阅读过程中发现AES一节中的数据全对不上，然后于17年初开始翻阅AES及Rijndael算法标准等资料，等看完所有文档后才发现此书对AES的介绍真是简化得没边了，后来又做了大量的延伸阅读，春节期间根据FIPS 197及《The Design of Rijndael》实现了AES 128/192/256 ECB/CBC的计算过程，之后开始本blog的书写，中间断断续续直至今日才完工，本文估计用时约40小时。学习从来不是容易的事！但越是不容易的事情做起来才更有乐趣！&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.dynox.cn/?p=1562&quot;&gt;原文链接&lt;/a&gt;，一字不差转载(防丢失)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、AES简介&quot;&gt;&lt;a href=&quot;#一、AES简介&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据加密 — 非对称加密(加签/加密，以RSA为例)</title>
    <link href="https://tenloy.github.io/2021/12/20/asymmetric.html"/>
    <id>https://tenloy.github.io/2021/12/20/asymmetric.html</id>
    <published>2021-12-20T15:49:12.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-非对称加密-公钥加密"><a href="#1-1-非对称加密-公钥加密" class="headerlink" title="1.1 非对称加密(公钥加密)"></a>1.1 非对称加密(公钥加密)</h3><p>公开密钥密码学（Public-key cryptography）也称非对称式密码学（Asymmetric cryptography）是密码学的一种算法。</p><ul><li>它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。</li><li>公钥可以公开，可任意向外发布；<strong>私钥不可以公开，必须由用户自行严格秘密保管</strong>，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。</li><li><strong>公钥加密，私钥加密</strong>：使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。</li><li><strong>私钥签名，公钥验签</strong>：基于非对称加密的特性，它还能提供<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0">数字签名</a>的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。</li></ul><h3 id="1-2-RSA算法"><a href="#1-2-RSA算法" class="headerlink" title="1.2 RSA算法"></a>1.2 RSA算法</h3><p><strong>RSA加密算法</strong>是一种非对称加密算法。</p><p>RSA在相关应用的时候，是需要有一些标准的 — PKI(public key infrastructure)标准(见上篇)。最常用的是pkcs。现在的各种程序中，基本都是遵循这个标准来使用RSA的。</p><ul><li><p><a href="https://www.rsa.com/">RSA官网</a></p></li><li><p><a href="https://www.rfc-editor.org/search/rfc_search_detail.php?title=pkcs&pubstatus%5B%5D=Any&pub_date_type=any">标准的查看</a></p></li></ul><p>公钥加密标准(The Public-Key Cryptography Standards, PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。</p><p><strong>RSA根据密钥长度可以分为rsa 2048、rsa 1024(单位是bit，换算成字节分别是256、128)。注意不要把密钥长度跟证书长度混淆，在rsa1024中，证书的长度应该是216。</strong></p><h2 id="二、加密、解密"><a href="#二、加密、解密" class="headerlink" title="二、加密、解密"></a>二、加密、解密</h2><p>加密的目的是实现只有指定个体才能打开发送方发出的数据，所以<strong>公钥加密</strong>(使用指定接受者的公钥来加密)，<strong>私钥解密</strong>，常用的加密算法如RSA</p><h2 id="三、加签、验签"><a href="#三、加签、验签" class="headerlink" title="三、加签、验签"></a>三、加签、验签</h2><p>接收方可以通过签名来确认发送方的身份，并可进行数据完整性检查。由RSA加密算法的规则可知，一个安全个体的私钥只有自己才知道，公钥则是可以被多方知道，所以要起到签名的效果，需要<strong>私钥签名，公钥验签</strong>。</p><img src="/images/encrypt/01.jpg" alt="01" style="zoom:70%;" /><p><strong>步骤</strong>：</p><ul><li>将原始数据哈希运算，得出标记，用 A 的私钥进行一次非对称加密算法处理。</li><li>B用A的公钥进行解密：<ul><li>如果能解出来，表示：确实是 A 发的。</li><li>如果解出来的值与收到的原始文本算出的哈希值相同，表示：数据传输途中未被修改。</li></ul></li></ul><p><strong>过程中出现的算法</strong>：</p><ul><li><p>哈希算法：将任意长度的消息M映射成一个固定长度的散列值h(也称为消息摘要)，常见的比如MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512</p></li><li><p>签名算法：RSA、DSA。其中RSA既能当做加密算法，也能当做签名算法来用，正反逆运算都是通的。<strong>DSA只能用作签名</strong> </p></li><li><p>本文代码签名算法为SHA1+RSA，Java中称 <code>SHA1WithRSA</code></p></li></ul><h2 id="四、iOS中的RSA"><a href="#四、iOS中的RSA" class="headerlink" title="四、iOS中的RSA"></a>四、iOS中的RSA</h2><p>在iOS中使用RSA加/验签、加/解密，首先需要拿到我们想要的公钥、私钥，在 <a href="%5Bhttps://www.jianshu.com/p/bc32cbfe49e7%5D(https://www.jianshu.com/p/bc32cbfe49e7)">上篇博客</a> 中已经介绍过：</p><p>证书文件常见的两种编码方式：<strong>DER编码</strong>、<strong>PEM编码</strong>。</p><p>在iOS中经常接触到的证书格式标准：<strong>PKCS#1</strong>、<strong>PKCS#8(java中经常使用)<strong>、</strong>PKCS#12</strong>，PKCS#12文件扩展名为**.p12或者.pfx**(可存储公钥+私钥)，此外常见的还有<code>.cer/.crt/.der</code> (存储的是公钥)。</p><p>注意：</p><ul><li>加载 .p12 文件代码转换成私钥</li><li>加载.cer .crt  .der文件代码转换成公钥</li><li>直接将PEM编码格式的、PKCS#1格式的公钥、PKCS#1 / PKCS#8标准的私钥硬编码，写在代码里使用</li></ul><p>以上都是可以的，但是首先需要先确定到底使用哪种方式，因为不同的数据加载方式、不同的证书格式，所要处理的过程是不一样的。详见下面代码</p><h2 id="五、代码处理过程"><a href="#五、代码处理过程" class="headerlink" title="五、代码处理过程"></a>五、代码处理过程</h2><p>这里使用的是iOS SDK中的 Security.framework 库，非openssl库，多年以前苹果就弃用了 OpenSSL，转而推荐自有框架 Security 和 CommonCrypto。当然你仍然可以使用 OpenSSL，比如说在 iOS 上使用开源库 <a href="https://link.jianshu.com/?t=https://github.com/x2on/OpenSSL-for-iPhone">OpenSSL for iPhone</a>。</p><p>分为两步(其实很简单)：</p><ol><li><p>将公私钥文件或者字符串转换成 SecKeyRef 对象， SecKeyRef 对象是一个密码学角度的抽象的密钥对象（也就是说它可以代表一个公钥、私钥或者某种对称加密的密钥）。无论是加解密还是签名，都会需要这个对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - &#x27;.der&#x27;公钥文件生成SecKeyRef对象(公钥)</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(公钥)</span></span><br><span class="line"><span class="comment">//PKCS#8格式的证书如果在代码的处理上，比PKCS#1多了一步对header的处理，也就是demo中的stripPublicKeyHeader函数，如果是PKCS#1的证书，跳过这个函数即可</span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - &#x27;.12&#x27;私钥文件生成SecKeyRef对象(私钥)</span></span><br><span class="line"></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">pragma</span> mark - PKCS#1、PKCS#8 PEM编码公钥生成SecKeyRef对象(私钥)</span></span><br><span class="line"><span class="comment">//生成代码与公钥过程大致相同，有一些细微差别</span></span><br></pre></td></tr></table></figure><p>有兴趣可以看下<a href="https://www.jianshu.com/p/783f2605f3e9">这篇文章 — iOS 生成 SecKeyRef 的正规方式</a>，文章有提到直接处理PEM编码格式的头时，由于对应的代码解析力不够强，经常会返回一个空的密钥对象，但是在我们APP内频繁测试没有发现这个问题(如果读到这里能为我解答这个疑问，麻烦评论留言一下吧，多谢)</p></li><li><p>调用相应的函数，实现功能</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加签函数</span></span><br><span class="line">OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen);</span><br><span class="line"><span class="comment">//验签函数</span></span><br><span class="line">OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *signedData, size_t signedDataLen, <span class="keyword">const</span> uint8_t *sig, size_t sigLen);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen);</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, <span class="keyword">const</span> uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)</span><br></pre></td></tr></table></figure><p>从上面的函数可以看到，函数参数并不复杂，将1中生成SecKeyRef对象传入，数据传输两端确定padding填充方式即可。<strong>要确认两边使用的签名算法设置参数一致</strong>；，详细代码看demo即可</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// digest message with sha1</span></span><br><span class="line">+ (<span class="built_in">NSData</span> *)sha1:(<span class="built_in">NSString</span> *)str</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data = [str cStringUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    CC_LONG len = (CC_LONG)strlen(data);</span><br><span class="line">    uint8_t * md = malloc( CC_SHA1_DIGEST_LENGTH * <span class="keyword">sizeof</span>(uint8_t) );;</span><br><span class="line">    CC_SHA1(data, len, md);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:md length:CC_SHA1_DIGEST_LENGTH];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="6-1-为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？"><a href="#6-1-为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？" class="headerlink" title="6.1 为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？"></a>6.1 为什么RSA公钥加密使用PKCS1填充每次生成结果都不一样？</h3><p>在<a href="https://tenloy.github.io/2021/12/09/pki.html#PKCS1%E5%A1%AB%E5%85%85%E6%96%B9%E5%BC%8F">上一篇博客 — 常见的PKI标准(X.509、PKCS)</a> 中已经介绍过PKCS1填充方式的过程,不再赘述，总结一下：</p><ul><li><p><strong>PKCS1填充格式：加密块EB</strong> = <strong>00 + 块类型BT + 填充字符PS + 00 + 数据D</strong>。</p></li><li><p><strong>如果使用公钥操作，BT永远为02，而对于BT为02的，PS对应的填充字节的值随机产生但不能是0字节(非00)。</strong></p></li><li><p>填充后，进行加密运算之前的数据不一致，得出的结果当然就不一样。</p></li><li><p>(<a href="https://blog.csdn.net/guyongqiangx/article/details/74930951">这篇博客</a>的作者一步步验证了这个现象，感兴趣的可以看下)</p></li></ul><h2 id="七、代码整理Demo"><a href="#七、代码整理Demo" class="headerlink" title="七、代码整理Demo"></a>七、代码整理Demo</h2><p>在<a href="https://github.com/ideawu/Objective-C-RSA">Objective-C-RSA</a>项目代码的基础上，根据自己项目的使用场景，整理了一下代码，放在了 <a href="https://github.com/Roten8/RSAHandle">GitHub - RSAHandle</a> 上，希望能有所帮助，有什么问题可以留言讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-非对称加密-公钥加密&quot;&gt;&lt;a href=&quot;#1-1-非对称加密-公钥加密&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的PKI标准(X.509、PKCS)及证书相关介绍</title>
    <link href="https://tenloy.github.io/2021/12/09/pki.html"/>
    <id>https://tenloy.github.io/2021/12/09/pki.html</id>
    <published>2021-12-09T15:07:02.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PKI(public key infrastructure)标准可以分为第一代标准和第二代标准。</p><p>第一代PKI标准主要包括：</p><ul><li>美国RSA公司的<strong>公钥加密标准</strong>（<code>Public Key Cryptography Standards，PKCS</code>）系列</li><li>国际电信联盟的ITU-T <code>X.509</code></li><li>IETF组织的公钥基础设施X.509（Public Key Infrastructure X.509，PKIX）标准系列</li><li>无线应用协议（Wireless Application Protocol ,WAP）论坛的无线公钥基础设施（Wireless Public Key Infrastructure，WPKI）标准等。</li></ul><p><strong>第一代PKI标准主要是基于抽象语法符号（Abstract Syntax Notation One，ASN.1）编码的</strong>，实现比较困难，这也在一定程度上影响了标准的推广。</p><p>第二代PKI标准，略。</p><p>CA中心普遍采用的规范是X.509系列和PKCS系列。</p><h2 id="一、ASN-1-数据结构描述语言"><a href="#一、ASN-1-数据结构描述语言" class="headerlink" title="一、ASN.1 - 数据结构描述语言"></a>一、ASN.1 - 数据结构描述语言</h2><p>引用自<a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">Wiki</a>：</p><blockquote><p>ASN.1 is a standard <strong>interface description language</strong> for defining <strong>data structures</strong> that can be serialized and deserialized in a <strong>cross-platform</strong> way.</p></blockquote><p>也就是说ASN.1是一种用来定义数据结构的接口描述语言，它不是二进制，也不是文件格式，看下面的例子你就会明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooQuestion ::&#x3D; SEQUENCE &#123;</span><br><span class="line">    trackingNumber INTEGER,</span><br><span class="line">    question       IA5String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了FooQuestion的数据结构，下面是FooQuestion这个数据接口的某个具体的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myQuestion FooQuestion ::&#x3D; SEQUENCE &#123;</span><br><span class="line">    trackingNumber     5,</span><br><span class="line">    question           &quot;Anybody there?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ASN.1用在很多地方比如下面要讲的 <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> 和 <a href="https://en.wikipedia.org/wiki/PKCS">PKCS group of cryptography standards</a>。</p><h2 id="二、文件编码格式"><a href="#二、文件编码格式" class="headerlink" title="二、文件编码格式"></a>二、文件编码格式</h2><h3 id="2-1-DER编码格式"><a href="#2-1-DER编码格式" class="headerlink" title="2.1 DER编码格式"></a>2.1 DER编码格式</h3><p>引用自<a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One">Wiki</a>：</p><blockquote><p>ASN.1 is closely associated with a set of encoding rules that specify how to represent a data structure as a series of bytes</p></blockquote><p>意思是ASN.1有一套关联的编码规则，这些编码规则用来规定如何用二进制来表示数据结构，<a href="https://en.wikipedia.org/wiki/X.690#DER_encoding">DER</a>是其中一种。</p><p>把上面的FooQuestion的例子用DER编码则是（16进制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 13 02 01 05 16 0e 41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">30 — type tag indicating SEQUENCE</span><br><span class="line">13 — length in octets of value that follows</span><br><span class="line">  02 — type tag indicating INTEGER</span><br><span class="line">  01 — length in octets of value that follows</span><br><span class="line">    05 — value (5)</span><br><span class="line">  16 — type tag indicating IA5String </span><br><span class="line">     (IA5 means the full 7-bit ISO 646 set, including variants, </span><br><span class="line">      but is generally US-ASCII)</span><br><span class="line">  0e — length in octets of value that follows</span><br><span class="line">    41 6e 79 62 6f 64 79 20 74 68 65 72 65 3f — value (&quot;Anybody there?&quot;)</span><br></pre></td></tr></table></figure><p>看到这里你应该对DER编码格式有一个比较好的认识了。</p><p>我们可以使用openssl命令来看一下pkcs1.der的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">openssl asn1parse -i -<span class="keyword">in</span> pkcs1.der -inform DER</span><br><span class="line">    0:d=0  hl=4 l= 604 cons: SEQUENCE</span><br><span class="line">    4:d=1  hl=2 l=   1 prim:  INTEGER           :00</span><br><span class="line">    7:d=1  hl=3 l= 129 prim:  INTEGER           :ACB3B7D2A7EA996800A05BEAC54AD1CE0F1F19EC7AF56C53319EA75EEB54A6705E9D6EE73F0B5960258FC5CAB4CFC65BB8C063694E1567D653DFBD0282367E3DDA477C925D3CEB77E1537AE4FBBFF5F11FAE402AE9B33F511B3D734929911F69B78A0C3335A7E38AEF6F009EDE999E509931881AA01AA3ADB0EF0697C7C81F23</span><br><span class="line">  139:d=1  hl=2 l=   3 prim:  INTEGER           :010001</span><br><span class="line">  144:d=1  hl=3 l= 128 prim:  INTEGER           :2898FEC7686DBFAE312781340938F3650B2CF67D1ED27EAA77E9A1D2B0636FD4CE8917BF0894F467A3ACCE843E48F18A323E17A0739898964B9536EB560CD553F5E0305BB3F762033E169269F1E9935E37055BBA7DCD07BEDF8A21F52AB63D214872275B5B48090440DCE26850359335335B0FE88D431FBA4F9DC0198DE76691</span><br><span class="line">  275:d=1  hl=2 l=  65 prim:  INTEGER           :E081C9230D8281F520C1F2D1B8A220B71FFAC7716F48CBD71528522A2B2FB5907885263B06698F095A936BE1ED3149A5720BDA22EC80892645B07BDE1109D135</span><br><span class="line">  342:d=1  hl=2 l=  65 prim:  INTEGER           :C4ED93DD4F5834E428A8EB780E0CD444297326D6C3D655E671BE4C3CA90BC5C8013F3195A2BDB5D7DBC280698C93F9F5EB6BF2B396077E2C5E83C5CB20D7D1F7</span><br><span class="line">  409:d=1  hl=2 l=  64 prim:  INTEGER           :3FA8AD76D202DA84BE48206915386B9C6166039D879795AD2423ADC0A5443EF07B2C0E1E18805FFDA000434BE9ACDB1C1D8D7CCA0053A610031CBAD2C9F405AD</span><br><span class="line">  475:d=1  hl=2 l=  64 prim:  INTEGER           :76EB61178C0AA02607C7BA2A4D91C1BD47AA9A11A7418FAE1191F147D06DA38A1BF6A562CF5BF0ABE1B19B0A22325A07FF9AB87D6A642BF56F3DF3FBAE61A611</span><br><span class="line">  541:d=1  hl=2 l=  65 prim:  INTEGER           :8761C1634E8489A5FBA6D2DCCC4BC05925C1600B07364CBCE2967CA4D0F6F03A5F6ED935306DD228F6E4C236EAC0FB76DB85AB6EFB36CF7DF90770AF91558E78</span><br></pre></td></tr></table></figure><p>里面将RSA私钥的所有数据都输出了。</p><h3 id="2-2-PEM编码格式"><a href="#2-2-PEM编码格式" class="headerlink" title="2.2 PEM编码格式"></a>2.2 PEM编码格式</h3><p>引用自<a href="https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail">Wiki</a>：</p><blockquote><p>Privacy-Enhanced Mail (PEM) is a de facto file format for storing and sending cryptographic keys, certificates, and other data, based on a set of 1993 IETF standards defining “privacy-enhanced mail.”</p></blockquote><p>PEM是一个用来存储和发送密码学key、证书和其他数据的文件格式的事实标准。许多使用ASN.1的密码学标准（比如<a href="https://en.wikipedia.org/wiki/X.509">X.509</a>和<a href="https://en.wikipedia.org/wiki/PKCS">PKCS</a>）都使用DER编码，而DER编码的内容是二进制的，不适合与邮件传输（早期Email不能发送附件），因此使用PEM把二进制内容转换成ASCII码。文件内容的格式像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN label-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END label-----</span><br></pre></td></tr></table></figure><p>label用来区分内容到底是什么类型，下面会讲。</p><p>和PEM相关的RFC有很多，与本文内容相关的则是<a href="https://tools.ietf.org/html/rfc7468">RFC7468</a>，这里面规定了很多label，不过要注意不是所有label都会有对应的RFC或Specification，这些label只是一种约定俗成。</p><p><strong>PEM实际上就是把DER编码的文件的二进制内容用base64编码一下，然后加上 <code>-----BEGIN label-----</code> 这样的头和 <code>-----END label-----</code> 这样的尾，中间则是DER文件的Base64编码</strong>。</p><p>我们可以通过下面的方法验证这个结论，先生成一个RSA Private Key，编码格式是PEM格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem</span><br></pre></td></tr></table></figure><p>查看一下文件内容，可以看到label是<code>RSA PRIVATE KEY</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><p>在—–BEGIN—–与—–END—–之间内容的顶部，有时使用一些头定义对信息进行封装，这些头信息格式如下（不一定都需要，可选的）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proc-Type,4: ENCRYPTED</span><br><span class="line">DEK-Info: cipher-name, ivec</span><br></pre></td></tr></table></figure><p>其中，第一个头信息标注了该文件是否进行了加密，该头信息可能的值包括：</p><ul><li>ENCRYPTED(信息已经加密和签名)</li><li>MIC-ONLY(信息经过数字签名但没有加密)</li><li>MIC-CLEAR(信息经过数字签名但是没有加密、也没有进行编码，可使用非PEM格式阅读)</li><li>CLEAR(信息没有签名和加密并且没有进行编码，该项好象是openssl自身的扩展，但是并没有真正实现)；</li></ul><p>第二个头信息标注了加密的算法以及使用的ivec参量，ivec其实在这儿提供的应该是一个随机产生的数据序列，与块加密算法中要使用到的初始化变量（IV）不一样。 </p><h3 id="2-3-DER与PEM的格式转换"><a href="#2-3-DER与PEM的格式转换" class="headerlink" title="2.3 DER与PEM的格式转换"></a>2.3 DER与PEM的格式转换</h3><p>我们可以把PEM格式转换成DER格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> key.pem -outform der -out key.der</span><br></pre></td></tr></table></figure><p>如果你这个时候看一下文件内容会发现都是二进制。然后我们把DER文件的内容Base64一下，会看到内容和PEM文件一样（忽略头尾和换行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -i key.der -o key.der.base64</span><br></pre></td></tr></table></figure><h2 id="三、证书、密码学Key格式标准"><a href="#三、证书、密码学Key格式标准" class="headerlink" title="三、证书、密码学Key格式标准"></a>三、证书、密码学Key格式标准</h2><p>上面讲到的PEM是对证书、密码学Key文件的一种编码方式，下面举例这些证书、密码学Key文件格式：</p><h3 id="3-1-X-509标准"><a href="#3-1-X-509标准" class="headerlink" title="3.1 X.509标准"></a>3.1 X.509标准</h3><p>引用自<a href="https://en.wikipedia.org/wiki/X.509">Wiki</a> ：</p><blockquote><p>In cryptography, <strong>X.509</strong> is a standard defining the format of public key certificates. X.509 certificates are used in many Internet protocols, including TLS/SSL, which is the basis for HTTPS, the secure protocol for browsing the web.</p></blockquote><p>X.509是一个 <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Public Key Certificates</a> 的格式标准，TLS/SSL使用它，TLS/SSL是HTTPS的基础所以HTTPS也使用它。而所谓 <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Public Key Certificates</a>又被称为 <strong>Digital Certificate(数字证书)</strong> 或 <strong>Identity Certificate</strong>(<strong>身份证书</strong>)。</p><blockquote><p>An X.509 certificate contains a public key and an identity (a hostname, or an organization, or an individual), and is either signed by a certificate authority or self-signed.</p></blockquote><p>一个X.509 Certificate包含一个Public Key和一个身份信息，它要么是被CA签发的要么是自签发的。</p><p>下面这种张图就是一个X.509 Certificate：</p><img src="/images/net/x509.png" alt="x509" style="zoom:80%;" /><p>事实上X.509 Certificate这个名词通常指代的是IETF的PKIX Certificate和CRL Profile，见<a href="https://tools.ietf.org/html/rfc5280">RFC5280</a>。所以当你看到PKIX Certificate字样的时候可以认为就是X.509 Certificate。</p><h3 id="3-2-PKCS-公钥加密标准-系列"><a href="#3-2-PKCS-公钥加密标准-系列" class="headerlink" title="3.2 PKCS(公钥加密标准)系列"></a>3.2 PKCS(公钥加密标准)系列</h3><p>PKCS是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。</p><p>引用自<a href="https://en.wikipedia.org/wiki/PKCS">Wiki</a>：</p><blockquote><p>In cryptography, <strong>PKCS</strong> stands for “Public Key Cryptography Standards”</p></blockquote><p>前面提到的X.509是定义Public Key Certificates的格式的标准，看上去和PKCS有点像，但实际上不同，PKCS是Public Key密码学标准。此外<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-Key Cryptography</a>虽然名字看上去只涉及Public Key，实际上也涉及Priviate Key，因此PKCS也涉及Private Key。</p><p>到1999年底，PKCS已经公布了以下标准： </p><ul><li>PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。 </li><li>PKCS#3：定义Diffie-Hellman密钥交换协议。 </li><li>PKCS#5：描述一种利用从口令派生出来的安全密钥加密字符串的方法。使用MD2或MD5 从口令中派生密钥，并采用DES-CBC模式加密。主要用于加密从一个计算机传送到另一个计算机的私人密钥，不能用于加密消息。 </li><li>PKCS#6：描述了公钥证书的标准语法，主要描述X.509证书的扩展格式。 </li><li>PKCS#7：定义一种通用的消息语法，包括数字签名和加密等用于增强的加密机制，PKCS#7与PEM兼容，所以不需其他密码操作，就可以将加密的消息转换成PEM消息。 </li><li>PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等。 </li><li>PKCS#9：定义一些用于PKCS#6证书扩展、PKCS#7数字签名和PKCS#8私钥加密信息的属性类型。 </li><li>PKCS#10：描述证书请求语法。 </li><li>PKCS#11：称为Cyptoki，定义了一套独立于技术的程序设计接口，用于智能卡和PCMCIA卡之类的加密设备。 </li><li>PKCS#12：描述个人信息交换语法标准。描述了将用户公钥、私钥、证书和其他相关信息打包的语法。 </li><li>PKCS#13：椭圆曲线密码体制标准。 </li><li>PKCS#14：伪随机数生成标准。 </li><li>PKCS#15：密码令牌信息格式标准。 </li></ul><p>下面挑讲PKCS #1、PKCS #8、PKCS #12。</p><h4 id="3-2-1-PKCS-1"><a href="#3-2-1-PKCS-1" class="headerlink" title="3.2.1 PKCS #1"></a>3.2.1 PKCS #1</h4><p>PKCS #1，RSA Cryptography Standard，定义了RSA Public Key和Private Key数学属性和格式，详见<a href="https://tools.ietf.org/html/rfc8017">RFC8017</a>。</p><p>详细的介绍了RSA算法的计算过程，包括：key的产生，key的结构，对数字加密／解密／签名／验证签名的过程、对应算法。</p><ol><li><p><strong>key</strong>：关于key，分别记录了private和public的详细结构，以及存储哪些内容。并且在附录里面推荐了ASN.1 Syntax中的存储结构。注：没有规定实际的物理文件存储结构，比如pem等。</p></li><li><p><strong>加密／解密</strong>：详细描述了加密／解密的算法。包括，首先针对字符串，怎么转化成数字，之后，怎么根据数字进行加密。 这里可以看出，标准中没有对超长字符串处理的说明。而转化出的字符串的长度，全都是key的模长度k。<br> 在字符串转化成数字过程中，需要增加填充字符，所以，分成了两种不同算法：RSAES-OAEP（现有标准）  RSAES-PKCS1-v1_5（兼容过去标准）。在实际加密过程中，就只有一种算法了</p></li><li><p>无论在加密还是签名过程中，都会进行hash操作，hash操作没有自己定义，而是从附录中可以选择需要的hash方式。</p></li><li><p><strong>PKCS1填充方式</strong>：在进行RSA运算时需要将源数据D转化为Encryption block（EB）。其中pkcs1padding V1.5的填充模式按照以下方式进行。</p></li></ol><h5 id="PKCS1填充方式"><a href="#PKCS1填充方式" class="headerlink" title="PKCS1填充方式"></a>PKCS1填充方式</h5><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：加密块EB = <span class="number">00</span> + 块类型BT + 填充字符PS + <span class="number">00</span> + 数据D  <span class="comment">//以下描述均以十六进制字符串来描述</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>EB：为转化后Hex进制表示的数据块，长度为128个字节（密钥1024位的情况下）</li><li>00：为了确保块转换为整数的时候 小于模数</li><li>BT(Block Type)：<ul><li>用一个字节表示，在目前的版本上，有三个值00 01 02。如果使用公钥操作，BT永远为02，如果用私钥操作则可能为00或01。</li><li>块类型为00，数据开头必须不能是00，因为填充的也是00，将无法解析。</li><li>块类型为01或02，块可以被准确解析，因为不会是00来填充。</li><li>如果是私钥操作，且明文数据是以00字节开头，那么建议把BT的值设置为01，否则，BT为00，PS为00，D开头为00，数据无法被分隔开</li></ul></li><li>PS(Padding String)：<ul><li>为填充位，PS由k-3-D这么多个字节构成，k表示密钥的字节长度，如果我们用1024bit的RSA密钥，这个长度就是1024/8=128，D表示明文数据D的字节长度</li><li>对于BT为00的，则这些字节全部为00</li><li>对于BT为01的，这些值全部为FF</li><li>对于BT为02的，这些字节的值随机产生但不能是0字节(非00)</li><li>填充长度至少为8个字节</li></ul></li><li>00：用于分开 PS 和 D</li><li>D：数据原文(HEX十六进制)<ul><li>PS至少为8个字节，所以D &lt;= k-11</li><li>当我们使用128字节密钥对数据进行加密时，明文数据的长度不能超过过128-11=117字节</li><li>当RSA要加密数据大于 k-11字节时怎么办呢？把明文数据按照D的最大长度分块然后逐块加密,最后把密文拼起来就行。</li></ul></li></ul><p>注意：<strong>加密块EB长度 = RSA密钥key的长度</strong>。比如密钥1024bit，即128字节，加密块也会被填充为128字节</p><p>示例：下面的数据需要填充74个FF才够128个字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加密块 &#x3D; 00 + 01 + FF(74个) + 00 + &quot;&gt;3031300d060960864801650304020105000420b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9(51字节)</span><br></pre></td></tr></table></figure><p>此外还有其他标准里定义的填充方式，比如PKCS5Padding、PKCS7Padding，不再赘述</p><h4 id="3-2-2-PKCS-8"><a href="#3-2-2-PKCS-8" class="headerlink" title="3.2.2 PKCS #8"></a>3.2.2 PKCS #8</h4><p>PKCS #8，Private-Key Information Syntax Standard，详细的描述了私钥的存储格式。用于加密、非加密地存储Private Certificate Keypairs（不限于RSA），详见<a href="https://tools.ietf.org/html/rfc5958">RFC5858</a>。</p><h4 id="3-2-3-PKCS-12"><a href="#3-2-3-PKCS-12" class="headerlink" title="3.2.3 PKCS #12"></a>3.2.3 PKCS #12</h4><p>PKCS #12定义了通常用来存储Private Keys和Public Key Certificates（例如前面提到的X.509）的文件格式，使用基于密码的对称密钥进行保护。注意上述Private Keys和Public Key Certificates是复数形式，这意味着PKCS #12文件实际上是一个Keystore，PKCS #12文件可以被用做 <a href="https://en.wikipedia.org/wiki/Keystore">Java Key Store</a>（JKS），详见<a href="https://tools.ietf.org/html/rfc7292">RFC7292</a>。</p><p>如果你用自己的CA所签发了一个证书，运行下列命令可以生成PKCS #12 keystore：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export \</span><br><span class="line">  -in &lt;cert&gt; \</span><br><span class="line">  -inkey &lt;private-key&gt; \</span><br><span class="line">  -name my-cert \</span><br><span class="line">  -caname my-ca-root \</span><br><span class="line">  -CAfile &lt;ca-cert&gt; \</span><br><span class="line">  -chain</span><br><span class="line">  -out &lt;pkcs-file&gt;</span><br></pre></td></tr></table></figure><p>PKCS #12一般不导出PEM编码格式。</p><h2 id="四、常见的证书标准格式-PEM编码"><a href="#四、常见的证书标准格式-PEM编码" class="headerlink" title="四、常见的证书标准格式(PEM编码)"></a>四、常见的证书标准格式(PEM编码)</h2><p>当你不知道你的PEM文件内容是什么格式的可以根据下面查询。</p><h3 id="4-1-X-509-Certificate"><a href="#4-1-X-509-Certificate" class="headerlink" title="4.1 X.509 Certificate"></a>4.1 X.509 Certificate</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-5.1">RFC7468 - Textual Encoding of Certificates</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><h3 id="4-2-X-509-Certificate-Subject-Public-Key-Info"><a href="#4-2-X-509-Certificate-Subject-Public-Key-Info" class="headerlink" title="4.2 X.509 Certificate Subject Public Key Info"></a>4.2 X.509 Certificate Subject Public Key Info</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-13">RFC7468 - Textual Encoding of Subject Public Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-3-PKCS-1-Private-Key"><a href="#4-3-PKCS-1-Private-Key" class="headerlink" title="4.3 PKCS #1 Private Key"></a>4.3 PKCS #1 Private Key</h3><p>没有RFC或权威Specification，该格式有时候被称为traditional format、SSLeay format（见<a href="https://crypto.stackexchange.com/a/47433">SO</a>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-4-PKCS-1-Public-Key"><a href="#4-4-PKCS-1-Public-Key" class="headerlink" title="4.4 PKCS #1 Public Key"></a>4.4 PKCS #1 Public Key</h3><p>同上没有RFC或权威Specification</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PUBLIC KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END RSA PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-5-PKCS-8-Unencrypted-Private-Key"><a href="#4-5-PKCS-8-Unencrypted-Private-Key" class="headerlink" title="4.5 PKCS #8 Unencrypted Private Key"></a>4.5 PKCS #8 Unencrypted Private Key</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-10">RFC7468 - One Asymmetric Key and the Textual Encoding of PKCS #8 Private Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-6-PKCS-8-Encrypted-Private-Key"><a href="#4-6-PKCS-8-Encrypted-Private-Key" class="headerlink" title="4.6 PKCS #8 Encrypted Private Key"></a>4.6 PKCS #8 Encrypted Private Key</h3><p><a href="https://tools.ietf.org/html/rfc7468#section-11">RFC7468 - Textual Encoding of PKCS #8 Encrypted Private Key Info</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN ENCRYPTED PRIVATE KEY-----</span><br><span class="line">BASE64Encoded</span><br><span class="line">-----END ENCRYPTED PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h3 id="4-7-RSA私钥PKCS1与PKCS8格式区别？"><a href="#4-7-RSA私钥PKCS1与PKCS8格式区别？" class="headerlink" title="4.7 RSA私钥PKCS1与PKCS8格式区别？"></a>4.7 RSA私钥PKCS1与PKCS8格式区别？</h3><p><strong>PKCS1：</strong>全名《Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications》最新版本2.2 <em>(rfc8017, 有兴趣的同学可以读一下)</em> ，从名称上可以看出它是针对RSA算法的一个规范。里面包含了RSA加密、解密、签名验签等所有的内容，当然也包含了私钥的格式。PKCS1的1.1版本是1991年发布的。</p><p><strong>PKCS8：</strong>全名《Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification》最新版本1.2，从名称上可以看出它是一个专门用来存储私钥的文件格式规范。PKCS1的1.2版本是2008年发布的。</p><p>它们两个有重合的部分，都定义了私钥的存储，那他们到底有什么关系呢？下面来验证一下</p><h4 id="第一步：产生RSA私钥"><a href="#第一步：产生RSA私钥" class="headerlink" title="第一步：产生RSA私钥"></a>第一步：产生RSA私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out pkcs1.pem 1024</span><br></pre></td></tr></table></figure><p>此时当前目录下就有一个pkcs1.pem文件，查看文件内容可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQCss7fSp+qZaACgW+rFStHODx8Z7Hr1bFMxnqde61SmcF6dbuc/</span><br><span class="line">C1lgJY/FyrTPxlu4wGNpThVn1lPfvQKCNn492kd8kl0863fhU3rk+7/18R+uQCrp</span><br><span class="line">mhGnQY+u+6bS3MxLwFklwWALBzZMvOKWfKTQ9vA6 <span class="comment">#....省略一大坨</span></span><br><span class="line">X27ZNTBt0ij25MI26sD7dtuFq277Ns99+Qdwr5FVjng=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h4 id="第二步：将私钥转为PKCS8"><a href="#第二步：将私钥转为PKCS8" class="headerlink" title="第二步：将私钥转为PKCS8"></a>第二步：将私钥转为PKCS8</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> pkcs1.pem -outform PEM -nocrypt -out pkcs8.pem</span><br></pre></td></tr></table></figure><p>此时当前目录下会多出一个pkcs8.pem文件，查看文件内容可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAKyzt9Kn6ploAKBb</span><br><span class="line">6sVK0c4PHxnsevVsUzGep17rVKZwXp1u5z8LWWAlj8XKtM/GW7jAY2lOFWfWU9+9</span><br><span class="line">nt6ZnlCZMYgaoBqjrbDvBpfHyB8jAgMBAAECgY <span class="comment">#....省略一大坨</span></span><br><span class="line">iaX7ptLczEvAWSXBYAsHNky84pZ8pND28Dpfbtk1MG3SKPbkwjbqwPt224Wrbvs2</span><br><span class="line">z335B3CvkVWOeA==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>那么之间有什么区别呢？从PEM格式的内容中看不出来什么规律，我们需要将两个PEM格式的文件转换为DER格式，这个二进制的数据容易做对比。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -<span class="keyword">in</span> pkcs1.pem -out pkcs1.der -outform DER</span><br><span class="line">$ openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> pkcs1.pem -outform DER -nocrypt -out pkcs8.der</span><br><span class="line">$ ls </span><br><span class="line">pkcs1.der pkcs1.pem pkcs8.der pkcs8.pem</span><br></pre></td></tr></table></figure><p>现在我们得到了两个DER格式的文件，我们可以先用hexdemp看看两个文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat pkcs1.der | hexdump</span><br><span class="line">0000000 30 82 02 5c 02 01 00 02 81 81 00 ac b3 b7 d2 a7</span><br><span class="line">0000010 ea 99 68 00 a0 5b ea c5 4a d1 ce 0f 1f 19 ec 7a</span><br><span class="line">0000020 f5 6c 53 31 9e a7 5e eb ... <span class="comment">#后面的没用，省略</span></span><br><span class="line"></span><br><span class="line">cat pkcs8.der | hexdump</span><br><span class="line">0000000 30 82 02 76 02 01 00 30 0d 06 09 2a 86 48 86 f7</span><br><span class="line">0000010 0d 01 01 01 05 00 04 82 02 60 30 82 02 5c 02 01</span><br><span class="line">0000020 00 02 81 81 00 ac b3 b7 d2 a7 ea 99 68 00 a0 5b</span><br><span class="line">0000030 ea c5 4a d1 ce 0f 1f 19 ec 7a f5 6c 53 31 9e a7</span><br><span class="line">0000040 5e eb ... <span class="comment"># 省略</span></span><br></pre></td></tr></table></figure><p>此时如果从后往前看的话，其实可以发现PKCS8仅比PKCS1多了一个26自己的头，剩余的内容均完全一致。<br> 我们可以使用以下的命令进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">openssl asn1parse -i -<span class="keyword">in</span> pkcs8.der -inform DER</span><br><span class="line">    0:d=0  hl=4 l= 630 cons: SEQUENCE</span><br><span class="line">    4:d=1  hl=2 l=   1 prim:  INTEGER           :00</span><br><span class="line">    7:d=1  hl=2 l=  13 cons:  SEQUENCE</span><br><span class="line">    9:d=2  hl=2 l=   9 prim:   OBJECT            :rsaEncryption</span><br><span class="line">   20:d=2  hl=2 l=   0 prim:   NULL</span><br><span class="line">   22:d=1  hl=4 l= 608 prim:  OCTET STRING      [HEX DUMP]:3082025C02010002818100ACB3B7D2A7EA99 <span class="comment">#pkcs1.der的内容</span></span><br></pre></td></tr></table></figure><p>可以看到 <strong>22:d=1 hl=4 l= 608 prim: OCTET STRING</strong> 这一行的输出就是pkcs1.der的内容。而上面的内容就是pkcs8比pkcs1多的内容。其实最主要的就是算法信息，这也是pkcs8能存储各种算法私钥的原因。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从时间顺序上可以看出来，PKCS标准也是在不断发展的，PKCS1的标准是先于PKCS8出来的，那时候甚至非对称算法还只有RSA是成熟的，在计算机领域刚刚得到应用，PKCS专门将RSA的算法作为一个标准输出就不难理解了。随着加密算法的发展才有了PKCS8出来专门做存储密钥这样一件事情。</p><h2 id="五、常见的证书后缀"><a href="#五、常见的证书后缀" class="headerlink" title="五、常见的证书后缀"></a>五、常见的证书后缀</h2><p>作为文件形式存在的证书一般有这几种后缀：(证书中包含公钥，以及公钥颁发机构、版本号、算法等信息，可以以X.509为例看一下证书内容)</p><p>带有私钥的证书：（一般都有密码保护，使用的是DER编码）</p><ul><li><code>.pfx</code> 常用于Windows上的 IIS服务器</li><li><code>.p12</code> 常用于MAC OS、iOS中(PKCS#12由PFX进化而来的用于交换公共的和私有的对象的标准格式)</li><li><code>.jks</code> Java Key Storage，这是Java的专利，JAVA的专属格式，一般用于 Tomcat 服务器。</li></ul><p>不带私钥的证书：</p><ul><li><code>.cer/crt</code> 编码方式不一定，可能是DER也可能是PEM</li><li><code>.pem</code> 都是PEM编码格式</li><li><code>.der</code> 都是DER编码格式</li><li><code>.p7b</code> 以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥</li></ul><p>补充</p><ul><li>.der文件一般只放证书，<code>不含私钥</code></li><li>.pem文件中可以放证书或者私钥，或者两者都有，pem如果只含私钥的话，一般用<code>.key</code>扩展名，而且可以有密码保护</li><li>.csr，即证书签名请求(Certificate Signing Request, CSR)，<strong>这个并不是证书</strong>。<ul><li>在创建加解密的公钥私钥对时，我们也可以生成对应的CSR文件。CSR中包含了公钥和标识名称(Distinguished Name)等信息。</li><li>如果想让此公钥变成证书来使用，需要把CSR文件提交给证书颁发机构，机构会使用其根证书私钥签名，就生成了证书文件，然后颁发给申请者。</li><li>做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧。</li></ul></li></ul><p>可以使用命令行工具、代码、在线网站等实现不同后缀格式、不同证书标准之间的转换，比如这个网站<a href="http://www.metools.info/">http://www.metools.info/</a></p><h2 id="六、常用的openssl公私钥操作命令"><a href="#六、常用的openssl公私钥操作命令" class="headerlink" title="六、常用的openssl公私钥操作命令"></a>六、常用的openssl公私钥操作命令</h2><h3 id="6-1-Private-Key操作命令"><a href="#6-1-Private-Key操作命令" class="headerlink" title="6.1 Private Key操作命令"></a>6.1 Private Key操作命令</h3><h4 id="6-1-1-私钥创建"><a href="#6-1-1-私钥创建" class="headerlink" title="6.1.1 私钥创建"></a>6.1.1 私钥创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成PKCS1格式RSA Private Key</span></span><br><span class="line">openssl genrsa -out private-key.p1.pem 2048</span><br></pre></td></tr></table></figure><h4 id="6-1-2-私钥格式转换"><a href="#6-1-2-私钥格式转换" class="headerlink" title="6.1.2 私钥格式转换"></a>6.1.2 私钥格式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PKCS #1 -&gt; Unencrypted PKCS #8</span></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> private-key.p1.pem -out private-key.p8.pem -nocrypt</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #1 -&gt; Encrypted PKCS #8</span></span><br><span class="line"><span class="comment"># 过程中会让你输入密码，你至少得输入4位，所以PKCS #8相比PKCS #1更安全。</span></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> private-key.p1.pem -out private-key.p8.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #8 -&gt; PKCS #1</span></span><br><span class="line"><span class="comment"># 如果这个PKCS #8是加密的，那么你得输入密码。</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.p8.pem -out private-key.p1.pem</span><br></pre></td></tr></table></figure><h3 id="6-2-Public-Key操作命令"><a href="#6-2-Public-Key操作命令" class="headerlink" title="6.2 Public Key操作命令"></a>6.2 Public Key操作命令</h3><h4 id="6-2-1-从PKCS-1、-8私钥中提取公钥"><a href="#6-2-1-从PKCS-1、-8私钥中提取公钥" class="headerlink" title="6.2.1 从PKCS #1、#8私钥中提取公钥"></a>6.2.1 从PKCS #1、#8私钥中提取公钥</h4><p>提取指的是从Private Key中提取Public Key，<code>openssl rsa</code>同时支持PKCS #1和PKCS #8的RSA Private Key，唯一的区别是如果PKCS #8是加密的，会要求你输入密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取X.509格式RSA Public Key</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.pem -pubout -out public-key.x509.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取PKCS #1格式RSA Public Key</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private-key.pem -out public-key.p1.pem -RSAPublicKey_out</span><br></pre></td></tr></table></figure><h4 id="6-2-2-从X-509证书提取公钥"><a href="#6-2-2-从X-509证书提取公钥" class="headerlink" title="6.2.2 从X.509证书提取公钥"></a>6.2.2 从X.509证书提取公钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> cert.pem -pubkey -noout &gt; public-key.x509.pem</span><br></pre></td></tr></table></figure><h4 id="6-2-3-公钥格式转换"><a href="#6-2-3-公钥格式转换" class="headerlink" title="6.2.3 公钥格式转换"></a>6.2.3 公钥格式转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X.509 RSA Public Key -&gt; PKCS #1 RSA Public Key</span></span><br><span class="line">openssl rsa -pubin -<span class="keyword">in</span> public-key.x509.pem -RSAPublicKey_out -out public-key.p1.pem</span><br><span class="line"></span><br><span class="line"><span class="comment"># PKCS #1 RSA Public Key -&gt; X.509 RSA Public Key</span></span><br><span class="line">openssl rsa -RSAPublicKey_in -<span class="keyword">in</span> public-key.p1.pem -pubout -out public-key.x509.pem</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><p><a href="https://segmentfault.com/a/1190000019008423">X.509、PKCS文件格式介绍</a></p></li><li><p><a href="https://press.one/files/0d970f6bab501e9b4eac540dbf69dcf452551aa1c33f2e22cf87aec152f34e75">PKCS1与PKCS8的小知识</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;PKI(public key infrastructure)标准可以分为第一代标准和第二代标准。&lt;/p&gt;
&lt;p&gt;第一代PKI标准主要包括：&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] 位运算实现加、减、乘、除运算</title>
    <link href="https://tenloy.github.io/2021/11/22/bit-calculation.html"/>
    <id>https://tenloy.github.io/2021/11/22/bit-calculation.html</id>
    <published>2021-11-22T16:35:03.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原理的理解。</p><p>今天就来看看怎么不使用显式“ + - * /”运算符来实现加减乘除运算。</p><p>下面我们一个一个来看。</p><h2 id="一、加法运算"><a href="#一、加法运算" class="headerlink" title="一、加法运算"></a>一、加法运算</h2><h3 id="1-1-十进制-举例"><a href="#1-1-十进制-举例" class="headerlink" title="1.1 十进制 举例"></a>1.1 十进制 举例</h3><p>先来个我们最熟悉的十进制的加法运算：</p><blockquote><p>13 + 9 = 22</p></blockquote><p>我们像这样来拆分这个运算过程：分别对各位数进行相加</p><ol><li><p>不考虑进位(要进位的值丢弃)：结果为sum：个位数3加上9为2；十位数1加上0为1； 最终结果为12；</p></li><li><p>只考虑进位(只保留进位的值)，结果为carry： 3 + 9 有进位，进位的值为10；</p></li><li><p>如果步骤2所得进位结果carry不为0。那么把步骤1所得sum、步骤2所得carry当成操作数重复步骤1、 2、3；</p><p>如果carry为0则结束，最终结果为步骤1所得sum：</p><p>这里即是对sum = 12 和carry = 10重复以上三个步骤：</p><p>a. 不考虑进位，分别对各位数进行相加:sum = 22; </p><p>b. 只考虑进位: 上一步没有进位，所以carry = 0； </p><p>c. 步骤2carry = 0，结束，结果为sum = 22.</p></li></ol><h3 id="1-2-二进制-举例"><a href="#1-2-二进制-举例" class="headerlink" title="1.2 二进制 举例"></a>1.2 二进制 举例</h3><p>我们发现这三板斧行得通！那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。</p><p>13的二进制为0000 1101，9的二进制为0000 1001:</p><ol><li><p>不考虑进位：分别对各位数进行相加：sum = 0000 1101 + 0000 1001 = 0000 0100</p></li><li><p>只考虑进位： 有两处进位，第0位和第3位，只考虑进位的结果为：carry = 0001 0010</p></li><li><p>步骤2 carry == 0 ?，不为0，重复步骤1 、2 、3；本例中，</p><p> a. 不考虑进位sum = 0001 0110;</p><p> b. 只考虑进位carry  = 0;</p><p> c. carry == 0？为0，结束，结果为sum = 0001 0110。转换成十进制刚好是22.</p></li></ol><h3 id="1-3-结论"><a href="#1-3-结论" class="headerlink" title="1.3 结论"></a>1.3 结论</h3><p>我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，其实：</p><ul><li>第一步不考虑进位的加法其实就是<font color=red>异或运算</font>；</li><li>第二步只考虑进位就是<font color=red>与运算并左移一位</font>；</li><li>第三步就是<strong>重复前面两步操作直到第二步进位结果为0</strong>。</li></ul><p>这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0011</span>, b = <span class="number">1001</span>;</span><br><span class="line">start;</span><br><span class="line"></span><br><span class="line">first loop;</span><br><span class="line"> <span class="number">1.1</span> sum = <span class="number">1010</span></span><br><span class="line"> <span class="number">1.2</span> carry = <span class="number">0010</span></span><br><span class="line"> <span class="number">1.3</span> carry != <span class="number">0</span> , go on;</span><br><span class="line"></span><br><span class="line">second loop;</span><br><span class="line"> <span class="number">2.1</span> sum = <span class="number">1000</span>;</span><br><span class="line"> <span class="number">2.2</span> carry = <span class="number">0100</span>;</span><br><span class="line"> <span class="number">2.3</span> carry != <span class="number">0</span>, go on;</span><br><span class="line"></span><br><span class="line">third loop;</span><br><span class="line"> <span class="number">3.1</span> sum = <span class="number">1100</span>;</span><br><span class="line"> <span class="number">3.2</span> carry = <span class="number">0000</span>;</span><br><span class="line"> <span class="number">3.3</span> carry == <span class="number">0</span>, stop; result = sum;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。</p><h3 id="1-4-代码"><a href="#1-4-代码" class="headerlink" title="1.4 代码"></a>1.4 代码</h3><p>有了上面的分析，我们不难写出如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">add</span>(sum, carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = sum;</span><br><span class="line">        <span class="built_in">int</span> b = carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！</p><h2 id="二、减法运算"><a href="#二、减法运算" class="headerlink" title="二、减法运算"></a>二、减法运算</h2><p>我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把减法运算11 - 6变形为加法运算11 + (-6)，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。</p><p>怎么实现呢？</p><p>刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。</p><p>+8在计算机中表示为二进制的1000，那-8怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实计算机是通过2的补码来表示负数的，那什么是2的补码（同补码，英文是2’s complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：</p><ul><li>第一步，每一个二进制位都取相反值，0变成1，1变成0（即反码）。</li><li>第二步，将上一步得到的值（反码）加1。</li></ul><p>简单来说就是取反加一！</p><p>关于补码更详细的内容可参<a href="https://link.jianshu.com/?t=!https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">维基百科-补码</a>，这里不再赘述。</p><p>其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。</p><p>以上，我们很容易写出了位运算做减法运算的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* num1: 减数</span></span><br><span class="line"><span class="comment">* num2: 被减数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">substract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> subtractor = <span class="keyword">add</span>(~num2, <span class="number">1</span>);<span class="comment">// 先求减数的补码（取反加一）</span></span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">add</span>(num1, subtractor); <span class="comment">// add()即上述加法运算　　</span></span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、乘法运算"><a href="#三、乘法运算" class="headerlink" title="三、乘法运算"></a>三、乘法运算</h2><p>我们知道了加法运算的位运算实现，那很容易想到乘法运算可以转换成加法运算，被乘数加上乘数倍的自己不就行了么。这里还有一个问题，就是乘数和被乘数的正负号问题，我们这样处理，先处理乘数和被乘数的绝对值的乘积，然后根据它们的符号确定最终结果的符号即可。步骤如下：</p><blockquote><p>(1) 计算绝对值得乘积<br> (2) 确定乘积符号（同号为证，异号为负）</p></blockquote><p>有了这个思路，代码就不难写了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a: 被乘数</span></span><br><span class="line"><span class="comment">* b: 乘数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 取绝对值　　    </span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a;    </span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;<span class="comment">// 如果为负则取反加一得其补码，即正数　　    </span></span><br><span class="line">    <span class="comment">// 计算绝对值的乘积　　    </span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(count &lt; multiplier) &#123;        </span><br><span class="line">        product = <span class="keyword">add</span>(product, multiplicand);        </span><br><span class="line">        count = <span class="keyword">add</span>(count, <span class="number">1</span>);<span class="comment">// 这里可别用count++，都说了这里是位运算实现加法　　    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定乘积的符号　　    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;<span class="comment">// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        </span></span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的思路在步骤上没有问题，但是第一步对绝对值作乘积运算我们是通过不断累加的方式来求乘积的，这在乘数比较小的情况下还是可以接受的，但在乘数比较大的时候，累加的次数也会增多，这样的效率不是最高的。我们可以思考，如何优化求绝对值的乘积这一步。</p><p>考虑我们现实生活中手动求乘积的过程，这种方式同样适用于二进制，下面我以13*14为例，向大家演示如何用手动计算的方式求乘数和被乘数绝对值的乘积。</p><img src="/images/bit-cal/01.png" alt="01" style="zoom:95%;" /><p>从上图的计算过程可以看出，如果乘数当前位为1，则取被乘数左移一位的结果加到最终结果中；如果当前位为0，则取0加到乘积中（加0也就是什么也不做）；</p><p>整理成算法步骤：</p><blockquote><p>(1) 判断乘数是否为0，为0跳转至步骤(4)</p><p>(2) 将乘数与1作与运算，确定末尾位为1还是为0，如果为1，则相加数为当前被乘数；如果为0，则相加数为0；将相加数加到最终结果中；</p><p>(3) 被乘数左移一位，乘数右移一位；回到步骤(1)</p><p>(4) 确定符号位，输出结果；</p></blockquote><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;　　</span><br><span class="line">    <span class="comment">//将乘数和被乘数都取绝对值　</span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a; 　　</span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;　　</span><br><span class="line">    　</span><br><span class="line">    <span class="comment">//计算绝对值的乘积　　</span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;　　</span><br><span class="line">    <span class="keyword">while</span>(multiplier &gt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span>((multiplier &amp; <span class="number">0x1</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">// 每次考察乘数的最后一位　　　　</span></span><br><span class="line">            product = <span class="keyword">add</span>(product, multiplicand);　　　　</span><br><span class="line">        &#125; 　　　　</span><br><span class="line">        multiplicand = multiplicand &lt;&lt; <span class="number">1</span>;<span class="comment">// 每运算一次，被乘数要左移一位　　　　</span></span><br><span class="line">        multiplier = multiplier &gt;&gt; <span class="number">1</span>;<span class="comment">// 每运算一次，乘数要右移一位（可对照上图理解）　　</span></span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="comment">//计算乘积的符号　　</span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);　　</span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，第二种求乘积的方式明显要优于第一种。</p><h2 id="四、除法运算"><a href="#四、除法运算" class="headerlink" title="四、除法运算"></a>四、除法运算</h2><p>除法运算很容易想到可以转换成减法运算，即不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。这里需要注意的是符号的确定，商的符号和乘法运算中乘积的符号确定一样，即取决于除数和被除数，同号为证，异号为负；余数的符号和被除数一样。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a : 被除数</span></span><br><span class="line"><span class="comment">* b : 除数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="comment">// 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span></span><br><span class="line">    <span class="keyword">while</span>(dividend &gt;= divisor)&#123;<span class="comment">// 直到商小于被除数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span>);        </span><br><span class="line">        dividend = substract(dividend, divisor);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;<span class="comment">// 如果除数和被除数异号，则商为负数  </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有和简单版乘法运算一样的问题，如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？</p><p>上面的代码之所以比较慢是因为步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？</p><p>计算机是一个二元的世界，所有的int型数据都可以用[2^0, 2^1, … , 2^31]这样一组基来表示（int型最高31位）。不难想到用除数的2^31, 2^30, … , 2^2, 2^1, 2^0 倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。</p><p>2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide_v2</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span> &#123;   </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//比较dividend是否大于divisor的(1&lt;&lt;i)次方，不要将dividend与(divisor&lt;&lt;i)比较，而是用(dividend&gt;&gt;i)与divisor比较，</span></span><br><span class="line">        <span class="comment">//效果一样，但是可以避免因(divisor&lt;&lt;i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       </span></span><br><span class="line">        <span class="keyword">if</span>((dividend &gt;&gt; i) &gt;= divisor) &#123;            </span><br><span class="line">            quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span> &lt;&lt; i);            </span><br><span class="line">            dividend = substract(dividend, divisor &lt;&lt; i);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果除数和被除数异号，则商为负数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Git的使用总结</title>
    <link href="https://tenloy.github.io/2021/11/10/git-use.html"/>
    <id>https://tenloy.github.io/2021/11/10/git-use.html</id>
    <published>2021-11-10T11:06:05.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来交换修改。</li><li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。两个人的电脑之间可以相互推送修改。不过， 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li><li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB。(Microsoft的Word格式是二进制格式)。</li><li>文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</li></ul><h2 id="二、Git的安装"><a href="#二、Git的安装" class="headerlink" title="二、Git的安装"></a>二、Git的安装</h2><p>首先，试着输入<code>git</code>，看看系统有没有安装Git。</p><p>Mac OS X上安装Git：</p><h3 id="2-1-通过homebrew安装"><a href="#2-1-通过homebrew安装" class="headerlink" title="2.1 通过homebrew安装"></a>2.1 通过homebrew安装</h3><blockquote><p>引用官方的一句话：Homebrew是Mac OS 不可或缺的套件管理器。 </p><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p></blockquote><p>安装homebrew，然后通过homebrew安装Git。</p><h3 id="2-2-通过Command-Line-Tools安装"><a href="#2-2-通过Command-Line-Tools安装" class="headerlink" title="2.2 通过Command Line Tools安装"></a>2.2 通过Command Line Tools安装</h3><p>安装Xcode IDE附带的命令行工具—Command Line Tools(需要自己安装 <code>xcode-select--install</code> )</p><blockquote><p>Command Line Tools就是一个小型独立包，为mac终端用户提供了许多常用的命令行工具（实用程序、编译器等）。包括svn，git，make，GCC，clang，perl，size，strip，strings，libtool，cpp，what以及其他很多能够在Linux默认安装中找到的有用的命令。</p><p>安装目录： /Library/Developer/CommandLineTools/</p></blockquote><h2 id="三、Git的配置"><a href="#三、Git的配置" class="headerlink" title="三、Git的配置"></a>三、Git的配置</h2><h3 id="3-1-配置远程仓库"><a href="#3-1-配置远程仓库" class="headerlink" title="3.1 配置远程仓库"></a>3.1 配置远程仓库</h3><p>常见的本地、远程仓库几种模式：</p><ul><li><p>从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p></li><li><p>在GitHub上，可以任意Fork开源仓库(点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone)</p><ul><li>自己拥有Fork后的仓库的读写权限； </li><li>可以推送pull request给官方仓库来贡献代码( 当然，对方是否接受你的pull request就不一定了 )。</li></ul></li><li><p>将已存在的文件夹，变成 Git 仓库，并创建关联的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 本地文件夹名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把这个目录变成Git可以管理的仓库 ，会多一个.git的目录，是Git来跟踪管理版本库的，如非必要不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 </span></span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后，远程库的名字一般就是origin，这是Git默认的叫法，也可以改成别的，只不过origin这个名字一看就知道是远程库。</span></span><br><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url(ssh/https)&gt; </span><br><span class="line"><span class="comment"># 一个本地仓库是可以关联多个远程库的，多次执行上面命令即可，但不能重名</span></span><br><span class="line"><span class="comment"># 查看远程库信息（如果没有推送权限，就不会看到push的地址）</span></span><br><span class="line">git remote [-v/--verbose]</span><br><span class="line"><span class="comment"># 删除已有的远程库</span></span><br><span class="line">git remote rm &lt;remoteName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的master分支内容推送的远程新的master分支，并建立本地master与远程仓库的master分支的关联，详见git push命令</span></span><br><span class="line">git push -u &lt;remote-name&gt; master </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-配置忽略文件"><a href="#3-2-配置忽略文件" class="headerlink" title="3.2 配置忽略文件"></a>3.2 配置忽略文件</h3><h4 id="3-2-1-全局与局部忽略"><a href="#3-2-1-全局与局部忽略" class="headerlink" title="3.2.1 全局与局部忽略"></a>3.2.1 全局与局部忽略</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦。</p><p>此时，可以把要忽略的文件名填入忽略文件，Git就会自动忽略这些文件。可以定义忽略是全局的，还是局限于一个仓库。</p><ul><li>全局忽略文件：<code>/User/用户名/.gitignore_global</code> ;</li><li>仓库忽略文件：Git工作区的根目录下有一个特殊的 <code>.gitignore</code> 文件。</li></ul><h4 id="3-2-2-忽略文件的编写"><a href="#3-2-2-忽略文件的编写" class="headerlink" title="3.2.2 忽略文件的编写"></a>3.2.2 忽略文件的编写</h4><p>忽略文件的格式：</p><ul><li>注释格式同shell脚本： #注释；</li><li>忽略精确的文件名：文件名；</li><li>忽略所有此扩展名的文件：如 *.pbxuser 表示要忽略后缀名为.pbxuser的文件；</li><li>忽略文件夹下面的一切：如 build/ 表示要忽略 build 文件夹下的所有内容；</li><li><code>*</code> 表示通配符：如 fastlane/screenshots/<code>**/*.png</code>；</li><li><code>!</code> 表示取反：如 *.pbxuser 表示忽略所有后缀名为.pbxuser的文件，如果加上!default.pbxuser则表示，除了default.pbxuse忽略其它后缀名为pbxuse的文件。</li></ul><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件，比如IDE的一些个人偏好设置。</li></ul><p>不需要从头写.gitignore文件，<a href="https://github.com/github/gitignore">github/gitignore </a> 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。</p><p>如 iOS 项目忽略文件的几项配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## User settings</span></span><br><span class="line">xcuserdata/</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)</span></span><br><span class="line">*.xcscmblueprint</span><br><span class="line">*.xccheckout</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)</span></span><br><span class="line">build/</span><br><span class="line">DerivedData/</span><br><span class="line"></span><br><span class="line"><span class="comment">## App packaging</span></span><br><span class="line">*.ipa</span><br><span class="line">*.dSYM.zip</span><br><span class="line">*.dSYM</span><br></pre></td></tr></table></figure><h4 id="3-2-3-忽略文件的检查"><a href="#3-2-3-忽略文件的检查" class="headerlink" title="3.2.3 忽略文件的检查"></a>3.2.3 忽略文件的检查</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：The following paths are ignored by one of your .gitignore files，可以使用<code>git add -f &lt;file&gt;</code>强制添加。</p><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore -v &lt;file&gt;</code>命令检查， Git会告诉我们，.gitignore的第几行规则忽略了该文件。</p><h3 id="3-3-git-config配置"><a href="#3-3-git-config配置" class="headerlink" title="3.3 git config配置"></a>3.3 git config配置</h3><h4 id="3-3-1-三种优先级的配置"><a href="#3-3-1-三种优先级的配置" class="headerlink" title="3.3.1 三种优先级的配置"></a>3.3.1 三种优先级的配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config [--global | --system] &lt;oo&gt;.&lt;kk&gt; &lt;vv&gt;</span><br><span class="line"><span class="comment"># 如配置用户信息    git config user.name/email xx</span></span><br><span class="line"><span class="comment"># 如配置编辑器      git config core.editor emacs</span></span><br><span class="line"><span class="comment"># 如配置别名       git config alias.st status</span></span><br><span class="line"><span class="comment"># 如配置输出的着色  git config color.ui false</span></span><br></pre></td></tr></table></figure><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： </p><ul><li><code>/etc/gitconfig</code>：包含系统上每一个用户及他们仓库的通用配置，使用带有 <code>--system</code> 选项的git config时，会从此文件读写配置变量；</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。 </li><li>仓库目录下 <code>/.git/config</code>：只针对该仓库，在仓库中使用带有 <code>--local(默认)</code> 选项的git config时，会读写该文件；<br>在优先级方面，从上往下依次上升。</li></ul><p>git config 的配置项有很多，详细可以看 <a href="https://github.com/git/git/tree/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config">git文档</a>。下面只是列出常见的几种。</p><h4 id="3-3-2-配置用户信息"><a href="#3-3-2-配置用户信息" class="headerlink" title="3.3.2 配置用户信息"></a>3.3.2 配置用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面已经说过，用了--global参数表示这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</span></span><br><span class="line">git config --global user.name “Your Name”</span><br><span class="line">git config --global user.email “email@example.com”</span><br></pre></td></tr></table></figure><p>用户名和邮箱地址的作用：</p><ul><li>每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改；</li><li>github 的 contributions 统计就是按邮箱来统计的。</li><li>注意：<strong>name、email是不用作git权限校验的，只为commit时做记录，随便怎么改都行</strong>。<br>亲证：误操作，用了一个全局配置的git name/email(公司的)用户名和邮箱，成功推送到了我的私人仓库</li></ul><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h4 id="3-3-3-配置文本编辑器"><a href="#3-3-3-配置文本编辑器" class="headerlink" title="3.3.3 配置文本编辑器"></a>3.3.3 配置文本编辑器</h4><p>当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</p></blockquote><h4 id="3-3-4-配置Git别名"><a href="#3-3-4-配置Git别名" class="headerlink" title="3.3.4 配置Git别名"></a>3.3.4 配置Git别名</h4><p>别名可以使你的 Git 体验更简单、容易、熟悉。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout </span><br><span class="line">git config --global alias.ci commit </span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span>  <span class="comment">#使用git last查看最后一次提交</span></span><br></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-配置权限校验缓存"><a href="#3-3-5-配置权限校验缓存" class="headerlink" title="3.3.5 配置权限校验缓存"></a>3.3.5 配置权限校验缓存</h4><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>了解更多关于不同验证缓存的可用选项，查看 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</p><h4 id="3-3-6-配置Git的着色"><a href="#3-3-6-配置Git的着色" class="headerlink" title="3.3.6 配置Git的着色"></a>3.3.6 配置Git的着色</h4><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。</p><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.diff.meta <span class="string">&quot;blue black bold&quot;</span></span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="3-3-7-查看配置信息"><a href="#3-3-7-查看配置信息" class="headerlink" title="3.3.7 查看配置信息"></a>3.3.7 查看配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h2 id="四、服务器上的Git"><a href="#四、服务器上的Git" class="headerlink" title="四、服务器上的Git"></a>四、服务器上的Git</h2><h3 id="4-1-Git-的四种传输协议"><a href="#4-1-Git-的四种传输协议" class="headerlink" title="4.1 Git 的四种传输协议"></a>4.1 Git 的四种传输协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="4-1-1-哑协议与智能协议之分"><a href="#4-1-1-哑协议与智能协议之分" class="headerlink" title="4.1.1 哑协议与智能协议之分"></a>4.1.1 哑协议与智能协议之分</h4><p><a href="https://www.progit.cn/#_%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">原文链接</a> Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><blockquote><p>现在已经很少使用哑协议了。 使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。 一般情况下都建议使用智能协议。</p></blockquote><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><ul><li>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</li><li>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</li></ul><h4 id="4-1-2-本地协议"><a href="#4-1-2-本地协议" class="headerlink" title="4.1.2 本地协议"></a>4.1.2 本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /opt/git/project.git</span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><h4 id="4-1-3-SSH-协议"><a href="#4-1-3-SSH-协议" class="headerlink" title="4.1.3 SSH 协议"></a>4.1.3 SSH 协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@server/project.git</span></span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> user@server:project.git</span></span><br></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><h5 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h5><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="4-1-4-Git-协议"><a href="#4-1-4-Git-协议" class="headerlink" title="4.1.4 Git 协议"></a>4.1.4 Git 协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h4 id="4-1-5-HTTP-协议"><a href="#4-1-5-HTTP-协议" class="headerlink" title="4.1.5 HTTP 协议"></a>4.1.5 HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h5 id="1-智能（Smart）-HTTP-协议"><a href="#1-智能（Smart）-HTTP-协议" class="headerlink" title="1. 智能（Smart） HTTP 协议"></a>1. 智能（Smart） HTTP 协议</h5><p><a href="https://www.progit.cn/#_smart_http">Smart HTTP</a>：我们一般通过 SSH 进行授权访问，通过 git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>)，和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h5 id="2-哑（Dumb）-HTTP-协议"><a href="#2-哑（Dumb）-HTTP-协议" class="headerlink" title="2. 哑（Dumb） HTTP 协议"></a>2. 哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://www.progit.cn/#_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><h5 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h5><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><h5 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h5><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h3 id="4-2-搭建Git服务器"><a href="#4-2-搭建Git服务器" class="headerlink" title="4.2 搭建Git服务器"></a>4.2 搭建Git服务器</h3><p>搭建Git服务器非常简单，通常10分钟即可完成； </p><ul><li>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>； </li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite">Gitolite</a>。</li></ul><p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器</a></p><h3 id="4-3-error：hung-up-unexpectedly"><a href="#4-3-error：hung-up-unexpectedly" class="headerlink" title="4.3 error：hung up unexpectedly"></a>4.3 error：hung up unexpectedly</h3><p>使用场景：clone、push的时候报错<code>The remote end hung up unexpectedly</code>时</p><ul><li>git <code>config http.postBuffer 524288000 </code>(stackOverFlow上有人说好像对SSH协议报这个错时也有效)</li><li>也可能是：接口不通(Git默认端口22，可能运维改了)，或者网络不好</li><li>可以试试，具体还是以<code>“error: ...信息”</code>为准（ 如果改了postBuffer，问题解决之后，建议改回去 ）</li></ul><p>我当时因为传输了大量大文件，修改了http.postBuffer没用；</p><p>还有说修改http.lowSpeedLimit=0、http.lowSpeedTime=999999；设置允许的最低速度，最低速度时间(没试，我是SSH协议push的！）</p><p>修改了SSH的重连ServerAliveInterval=30、ServerAliveCountMax=5没用；</p><p>后来无奈，只能分批次上传。</p><h4 id="4-3-1-配置http-postBuffer"><a href="#4-3-1-配置http-postBuffer" class="headerlink" title="4.3.1 配置http.postBuffer"></a>4.3.1 配置http.postBuffer</h4><blockquote><p><a href="https://github.com/git/git/blob/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config/http.txt#L195-L209">官方链接</a></p><p>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally.  Default is 1 MiB, which is sufficient for most requests.</p><p>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard.  Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</p></blockquote><p>个人认为：这个参数是用来设置HTTP传输发送buffer池的大小(池子满了，或者数据已写入完毕就发送)</p><ul><li>客户端、服务端会根据这个参数来申请内存当做buffer池(所以如果太大了，会消耗内存，而且如果块太大，并不是所有的服务器系统都能正常接收处理的)</li><li>客户端推送的大小如果超过这个可能会失败(至于说是本地发送失败，还是因为服务端根据这个设置的接收buffer池大小，结果接收到的数据太大，缓冲区溢出造成的失败就不清楚了)</li><li>服务端应答的大小如果超过这个会分块传输</li><li>仅对禁用分块传输编码有效（因此仅在远程服务器或代理仅支持HTTP/1.0或不符合HTTP标准的情况下才应使用），意思是分块传输编码时，有自己的分块传输(块多大)策略，而且优先级更高</li></ul><p>服务端程序在接收客户端表单提交的数据时，需要先将数据存储到一个内存空间，然后做解析等后续工作，这个内存空间一般称之为接收缓冲区。对于post数据因为有Content-Length标记，服务端可以按标记的长度创建一个等于或稍大于提交数据的缓冲区；对于get，因为事先不知道提交的数据有多少，需要估计缓冲区长度，如果缓冲区很大而接收数据很小会造成内存浪费，而如果缓冲区小于接收数据，就可能造成缓冲区溢出。</p><p>“聪明的”黑客，会在溢出部分放置特殊的代码来攻陷你的服务器。<a href="https://www.cnblogs.com/meilibao/archive/2012/10/29/2744525.html">博客</a></p><h4 id="4-3-2-补充：Transfer-Encoding-chunked"><a href="#4-3-2-补充：Transfer-Encoding-chunked" class="headerlink" title="4.3.2 补充：Transfer-Encoding:chunked"></a>4.3.2 补充：Transfer-Encoding:chunked</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">维基百科</a></p><p>表示输出的内容长度不能确定， 通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度， 先把整个要输出的数据写到一个很大的字节数组里(如 ByteArrayOutputStream)，然后得到数组大小 -&gt; Content-Length。 </p><p>如果结合Transfer-Encoding: chunked使用，就不必申请一个很大的字节数组了，可以一块一块的输出，更科学，占用资源更少。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。</p><h2 id="五、Git的两种鉴权方式"><a href="#五、Git的两种鉴权方式" class="headerlink" title="五、Git的两种鉴权方式"></a>五、Git的两种鉴权方式</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是：</p><ul><li>前者采用账号密码进行校验；</li><li>后者采用SSH秘钥对进行校验。</li></ul><h3 id="5-1-SSH"><a href="#5-1-SSH" class="headerlink" title="5.1 SSH"></a>5.1 SSH</h3><p><a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">GitHub官网配置步骤指导</a></p><p>只要选择正确的密钥，本地的私钥加密，对应的远程仓库账号中事先添加的公钥能解开就能提交成功。</p><p>生成公钥时，需要指定GitHub的邮箱地址，配置在GitHub中的公钥串中也包含邮箱，GitHub是校验的这个邮箱账号。</p><h4 id="5-1-1-ssh-agent"><a href="#5-1-1-ssh-agent" class="headerlink" title="5.1.1 ssh-agent"></a>5.1.1 ssh-agent</h4><p>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。参考链接：<a href="https://www.zsythink.net/archives/2407">了解ssh代理：ssh-agent</a>。</p><p>个人理解： 类似VPN代理软件吧，会拦截我们的请求并针对性地加以处理。还有一点相同的是： 将私钥加入ssh-agent后，即使删除私钥文件，本地计算机仍可以正常访问 GitHub 代码仓库。</p><h4 id="5-1-2-修改SSH默认端口"><a href="#5-1-2-修改SSH默认端口" class="headerlink" title="5.1.2 修改SSH默认端口"></a>5.1.2 修改SSH默认端口</h4><p>为了安全起见，有时会修改服务器ssh连接端口，比如改为3222。此时我们需要在 <em>/etc/ssh/ssh_config</em> 或者 <em>~/.ssh/config</em> 中找到行 <em>port 22</em> 并修改(像这种配置文件最好使用vim编辑器)。</p><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p>https 除了速度慢以外，还有个最大的麻烦是每次与远程仓库交互时，都必须输入账号(可以是git用户名，也可以是邮箱地址)、口令进行校验。</p><p>可以记住密码：</p><ul><li>Mac中可以存储在keychain中，<strong>在开启Keychain机制的情况下，进行权限校验后会自动将账号密码保存至Keychain Access</strong>。</li><li>Mac、Windows共用—— git 提供的 credential helper机制：可以将账号密码以 cache 的形式在内存中缓存一段时间（默认 15 分钟），或者以文件的形式存储起来（~/.git-credentials）。</li></ul><h3 id="5-3-配置不同账号访问不同仓库"><a href="#5-3-配置不同账号访问不同仓库" class="headerlink" title="5.3 配置不同账号访问不同仓库"></a>5.3 配置不同账号访问不同仓库</h3><p>当一台计算机中需要以不同账号访问不同的仓库时：</p><ul><li>SSH：如果不同的仓库配置了不同的公钥，那么在使用本地私钥时，就要加以区分。(当然也可以所有仓库都使用一套公钥、私钥，理论上私钥只有自己知道)。</li><li>HTTPS：如果不记住账号密码，即每次都输入账号密码，那就不需要配置。<ul><li>如果使用Keychain记住了密码，此时会根据仓库的 host 去 Keychain 中寻找账户密码，因为 Keychain 中针对这个host 存储了多个账号、密码，那找出的可能是错误的，此时就会权限校验失败。此时我们需要处理一下我们的仓库URL。</li></ul></li></ul><h4 id="5-3-1-SSH的处理"><a href="#5-3-1-SSH的处理" class="headerlink" title="5.3.1 SSH的处理"></a>5.3.1 SSH的处理</h4><p>以SSH方式：通过远程仓库的url（clone之后存储在repo/.git/config中）的host </p><ul><li>找到host配置的对应SSH-Key(SSH-Key一般都存在~/.ssh文件夹中)<ul><li>当只有一个SSH账号时，/etc/ssh/ssh_config配置文件，默认直接指向~/.ssh/id_rsa</li><li>当有多个SSH账号时，<del>/.ssh/config配置文件中，分别配置每个host对应的</del>/.ssh中的SSH-Key</li></ul></li><li>通过密钥进行权限校验</li></ul><p>两个文件的影响范围：</p><ul><li>/etc/ssh/ssh_config下的配置是针对当前系统所有用户</li><li>~/.ssh/config(/User/用户名/.ssh/config)只针对当前用户(默认是没有该文件的，只有当有多个用户，需要做映射时，才创建、配置)</li></ul><p>如果两个仓库host不相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host github.com <span class="comment"># Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span></span><br><span class="line">    Port 22         <span class="comment"># 端口号（如果不是默认22号端口则需要指定） </span></span><br><span class="line">    HostName github.com  <span class="comment"># 是代码仓库服务器的主机(此处是github)</span></span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa  <span class="comment"># 指明User对应的identityFile路径，即SSH-Key</span></span><br><span class="line">    User loten   <span class="comment"># 登录名（如gitlab的username） </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个同上，如 smartgit</span></span><br></pre></td></tr></table></figure><p>如果两个仓库host也相同，则需要在Host中进行区分，然后经过 <code>CNAME</code> 映射到 <code>HostName</code>（<code>Host相当于是HostName的别名</code>），然后分别指向不同的SSH-key，即IdentityFile，从而实现了对两个 GitHub 账号的分离。（<code>HostName才是真正指定 GitHub 服务器主机的字段</code>）</p><p>在config文件修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debugtalk</span></span><br><span class="line">Host debugtalk</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># DJI</span></span><br><span class="line">Host djileolee</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/dji_id_rsa</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>此处改了还没完，还需要在各个项目中分别进行修改配置：代码提交、拉取时远程仓库的地址。 即<code>repo/.git/config</code>文件：可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将原先的远程仓库的URL  git@github.com:debugtalk/DroidMeter.git中的host改成我们刚设置的host(别名)</span></span><br><span class="line">git remote add origin git@debugtalk:debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure><h4 id="5-3-2-HTTPS的处理"><a href="#5-3-2-HTTPS的处理" class="headerlink" title="5.3.2 HTTPS的处理"></a>5.3.2 HTTPS的处理</h4><p>以HTTPS方式：通过远程仓库的url（clone之后存储在repo/.git/config中）。</p><p>比如：本来的HTTPS URL为 <code>https://github.com/loten/RSAHandle.git</code> 手动改为：<code>https://loten@github.com/loten/RSAHandle.git</code>。</p><p>注意：loten是GitHub的用户名，不能打错。在第一次拉取/推送的时候(钥匙串keychain中还没存储账号、密码)，会要求输入该用户名对应的密码：Password Required For user Roten8 on host github.com. 输入成功后，即可成功拉取/推送。</p><p>配置原理很容易理解，即将 GitHub 用户名添加到仓库的 Git 地址中，这样在执行 git 命令的时候，系统就会采用指定的 GitHub 用户名去<code>Keychain</code> 或 <code>~/.git-credentials</code> 中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p><p>然后可以发现使用这种方式修改之后，可以看到keychain中的存储信息的<code>账号</code>：<code>由邮箱号变为了Git用户名</code>。即不再仅仅通过host来寻找账号密码，而是找到keychain中，这个host下指定的用户名对应的密码，来使用。</p><p>参考链接： <a href="https://ruby-china.org/topics/30298">Git深入浅出 Git 权限校验 (最熟悉的陌生概念)</a></p><h2 id="六、从仓库目录角度了解Git工作原理"><a href="#六、从仓库目录角度了解Git工作原理" class="headerlink" title="六、从仓库目录角度了解Git工作原理"></a>六、从仓库目录角度了解Git工作原理</h2><h3 id="6-1-目录结构"><a href="#6-1-目录结构" class="headerlink" title="6.1 目录结构"></a>6.1 目录结构</h3><img src="/images/git/dir.png" alt="dir" style="zoom:80%;" /><ul><li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间。</li><li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间/工作区/工作目录，除了 .git 之外的都属于工作区。<ul><li>工作目录下的文件有两种状态：已跟踪tracked或未跟踪untracked（新创建的文件，没有被add到暂存区就是untracked状态）</li></ul></li><li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD 会只是当前的开发分支（branch）。</li><li>Stash：是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li></ul><blockquote><p>一个 modification 的提交要经历工作区——add到暂存区(staged)——commit到本地仓库——push到远程仓库</p></blockquote><p>文件的状态改变：</p><img src="/images/git/lifecycle.png" alt="lifecycle" style="zoom:80%;" /><h3 id="6-2-git文件夹-版本库"><a href="#6-2-git文件夹-版本库" class="headerlink" title="6.2 .git文件夹(版本库)"></a>6.2 .git文件夹(版本库)</h3><h4 id="6-2-1-index"><a href="#6-2-1-index" class="headerlink" title="6.2.1 index"></a>6.2.1 index</h4><p>暂存区是Git相比SVN的特色；</p><p>当修改了工作区里的一个文件时，这些修改一开始是<code>unstaged</code>状态，为了提交这些修改，你需要使用<code>git add</code>把它加入到index，使它成为<code>staged</code>状态。当你提交一个commit时，index里面的修改被提交；</p><p>当在工作区新增一个文件，文件是<code>untracked</code>状态，<code>git add &lt;file&gt;</code>添加到index，变为<code>tracked</code>状态。</p><h4 id="6-2-2-objects"><a href="#6-2-2-objects" class="headerlink" title="6.2.2 objects/"></a>6.2.2 objects/</h4><p>该文件夹下存储了所有数据内容。主要有四大对象：数据对象、树对象、提交对象、标签对象。</p><h5 id="1-数据对象-对应-文件"><a href="#1-数据对象-对应-文件" class="headerlink" title="1. 数据对象(对应 文件)"></a>1. 数据对象(对应 文件)</h5><p>Git 是一个内容寻址文件系统，即Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 </p><p>可以通过底层命令hash-object来<strong>演示</strong>上述效果——该命令可将任意数据保存于.git目录，并返回相应的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> | git hash-object -w --stdin</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span><br><span class="line">git hash-object -w test.txt</span><br></pre></td></tr></table></figure><ul><li>-w选项指示hash-object命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。</li><li>–stdin选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 </li><li>该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</li><li>可以在objects目录下看到一个文件， <strong>校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名</strong>。</li></ul><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据，这个命令简直就是一把剖析 Git 对象的瑞士军刀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 打印其内部存储的对象类型（SHA-1 值为目录名+文件名）：输出为：`blob`、`tree`、`commit`</span></span><br><span class="line">git cat-file -t &lt;SHA-1&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 打印对象里的内容  </span></span><br><span class="line">git cat-file -p &lt;SHA-1&gt;  <span class="comment"># -p: Pretty-print 自动判断内容的类型，并为我们显示格式友好的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - blob对象，打印出是可视化的，我们做的修改</span></span><br><span class="line"><span class="comment"># - tree对象，打印出其包含的数据对象和子树对象的SHA-1指针</span></span><br><span class="line"><span class="comment"># - commit对象，打印出：tree对象、parent父提交对象、author(name、email、时间戳)、commiter、留空一行、注释</span></span><br></pre></td></tr></table></figure><p><strong>每当一个文件修改时，就会生成一个数据对象。数据对象的内容是源文件当前的全部内容</strong>(<strong>而非存储的修改内容，保证了每次切换节点时，快速恢复！</strong>)。</p><p>不过， 记住文件的每一个版本所对应的 SHA-1 值并不现实。另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）</p><h5 id="2-树对象-对应-目录"><a href="#2-树对象-对应-目录" class="headerlink" title="2. 树对象(对应 目录)"></a>2. 树对象(对应 目录)</h5><p>树对象（tree object）能解决文件名保存的问题，也允许我们将多个文件组织到一起。 <strong>Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化</strong>：</p><ul><li><p>所有内容均以树对象和数据对象的形式存储，其中<font color='red'>树对象对应了 UNIX 中的目录项</font><strong>，</strong><font color='red'>数据对象则大致上对应了 inodes 或文件内容</font>；</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Inode">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p><strong>一、inode是什么？</strong></p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p><strong>二、inode的内容</strong></p><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li><p>文件的字节数</p></li><li><p>文件拥有者的User ID</p></li><li><p>文件的Group ID</p></li><li><p>文件的读、写、执行权限</p></li><li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li><li><p>链接数，即有多少文件名指向这个inode</p></li><li><p>文件数据block的位置</p></li></ul><p>可以用stat命令，查看某个文件的inode信息：<code>stat example.txt</code></p></blockquote></li><li><p>一个树对象包含了一条或多条树对象记录（tree entry）；</p></li><li><p>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><ul><li>文件模式为 <code>100644</code>，表明这是一个普通文件。 </li><li><code>100755</code>，表示一个可执行文件；</li><li><code>120000</code>，表示一个符号链接。</li><li> 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</li></ul></li></ul><p>通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p><p>可以通过<code>write-tree</code>命令将暂存区内容写入一个树对象。</p><p>例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master^&#123;tree&#125;语法表示 master 分支上最新的提交所指向的树对象</span></span><br><span class="line">git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，lib子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象</span></span><br><span class="line">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件、以及一个目录：</p><img src="/images/git/data-model-1.png" alt="data-model-3" style="zoom:70%;" /><p>下面是个（非常规操作…）举例，你可以将一个旧的树对象加入新的树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><img src="/images/git/data-model-2.png" alt="data-model-3" style="zoom:70%;" /><h5 id="3-提交对象"><a href="#3-提交对象" class="headerlink" title="3. 提交对象"></a>3. 提交对象</h5><p><strong>树对象代表了我们想要跟踪的不同项目快照</strong>。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><ul><li>可以通过调用<code>commit-tree</code>命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</li><li>提交对象的格式很简单：<ul><li>它先指定一个顶层树对象，代表当前项目快照；<strong>这个树对象记录了此刻工作目录所有文件的状态，这也是Git切换快速便捷的原理</strong>。</li><li>然后是作者/提交者信息（依据你的user.name和user.email配置来设定，外加一个时间戳）；</li><li>留空一行，最后是提交注释。(重要的两点：顶层树对象、父提交对象)</li></ul></li><li>提交对象的<strong>SHA-1值即为commit id</strong></li></ul><p><strong>提交对象对应的这个最顶层的树对象就对应了我们的工作目录，下面的每一个tree对象对应我们项目中的文件夹，每一个的blob对象就是此时该文件的最新全部内容</strong>。比如下面是一个大项目的master分支上最新提交对应的树对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob 17eb1b55d91525217c8615813a702207d038eec8.DS_Store</span><br><span class="line">100755 blob 47acf8552d011d70d98b1805a1f2fd00ca060356.gitignore</span><br><span class="line">040000 tree 7b19b9ca1fece9c204770f7ddfa3a362f12dbf2eLLBaseKit</span><br><span class="line">040000 tree 8f826ece85e875c00af345ab4b40c6661a512eb5LLIDCard</span><br><span class="line">040000 tree 3f96965ac93c24a71a4bff9bbfbc587d5889bc92LLLiveDetection</span><br><span class="line">100644 blob a42e52ed334aa15800dca69d256d0e340494551fPodfile</span><br><span class="line">100644 blob f0430fd46587a9c29a5385001adb89c6ae9ef759Podfile.lock</span><br><span class="line">040000 tree 44e5dd79ef5a0435e1f3a0ea112cbaf8b6b48071Pods</span><br><span class="line">040000 tree dd706fe8898be1a2a7ccdfc3fb61115a0aef4b01RTSu.xcodeproj</span><br><span class="line">040000 tree 65ac1588391931d47e65f7fc7c2032f6a738a819RTSu.xcworkspace</span><br><span class="line">040000 tree 221347dd21123109ffa63300c4003de34cfec8f4RTSu</span><br><span class="line">040000 tree bd7d6129ab1bbf677aaaab85f493ed437c976493RTSuJPush</span><br><span class="line">040000 tree 40152f8dc68864e779104a782278ee2bd3dcd9e4RTSuTests</span><br><span class="line">040000 tree b8397ded7e7b5efa1cc83bddc69a93fc2c6cc1c7RTSuUITests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 git cat-file -p 打印上面的树对象，打印出来即是我们的源文件</span></span><br></pre></td></tr></table></figure><h5 id="4-三种对象的关系图"><a href="#4-三种对象的关系图" class="headerlink" title="4. 三种对象的关系图"></a>4. 三种对象的关系图</h5><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><img src="/images/git/data-model-3.png" alt="data-model-3" style="zoom:80%;" /><h5 id="5-对象的存储"><a href="#5-对象的存储" class="headerlink" title="5. 对象的存储"></a>5. 对象的存储</h5><p>Git在存储内容时，会有个头部信息一并被保存</p><ul><li>以对象类型作为开头来构造一个头部信息：比如“blob”字符串，接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）<code>&quot;blob #&#123;content.length&#125;\0&quot;</code></li><li>将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和</li><li>通过 zlib 压缩这条新内容</li><li>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在则创建它。</li><li>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</li></ul><h4 id="6-2-3-refs"><a href="#6-2-3-refs" class="headerlink" title="6.2.3 refs/"></a>6.2.3 refs/</h4><p>存储指向数据（分支）的提交对象的指针；</p><p>GIT引用概述：由于一些地方需要用到SHA-1值，而SHA-1不易记录， 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><ul><li>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；可以在.git/refs目录下找到这类含有 SHA-1 值的文件。(<strong>帮助我们记忆最新提交所在的位置</strong>)；</li><li>这基本就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>， 当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</li></ul><img src="/images/git/data-model-4.png" alt="data-model-4" style="zoom:90%;" /><h5 id="1-heads-—-HEAD引用"><a href="#1-heads-—-HEAD引用" class="headerlink" title="1. heads/ — HEAD引用"></a>1. heads/ — HEAD引用</h5><p>现在的问题是，当你执行<code>git branch (branchname)</code>时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针：</p><ul><li>如果查看 HEAD 文件的内容，一般而言我们看到的类似这样： <code>ref: refs/heads/master(或者当前分支名)</code>；</li><li>当我们执行<code>git commit</code>时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</li></ul><p>/refs/heads/ 记录<code>本地</code>每个分支的提交之首</p><h5 id="2-tags-—-Tag引用"><a href="#2-tags-—-Tag引用" class="headerlink" title="2. tags/ — Tag引用"></a>2. tags/ — Tag引用</h5><p>标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 </p><p>主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><ul><li>轻量标签： 只是一个特定提交的固定引用</li><li>附注标签：Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象</li></ul><p>标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象(比如数据、树对象)打标签</p><h5 id="3-remotes-—-远程引用-remote-reference"><a href="#3-remotes-—-远程引用-remote-reference" class="headerlink" title="3. remotes/ — 远程引用(remote reference)"></a>3. remotes/ — 远程引用(remote reference)</h5><p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下每一个分支最近一次推送操作时所对应的SHA-1值，并保存在refs/remotes目录下(文件名为远程分支名)</p><ul><li>远程引用和分支（位于refs/heads目录下的引用）之间最主要的区别在于，远程引用是只读的（本地仓库的commit可以reset来修改HEAD的指向，但是remote repo的是不能的）</li></ul><p><strong>子文件夹为远程仓库的名称（如果有多个远程仓库(config文件中有多个[remote xxx])就有多个子文件夹），文件夹中的文件名称是远程仓库中执行过推送操作的远程分支名</strong>。</p><h5 id="4-for-—-Gerrit"><a href="#4-for-—-Gerrit" class="headerlink" title="4. for/ — Gerrit"></a>4. for/ — Gerrit</h5><p>如果我们使用的是Gerrit（一种开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件开发者，可以在评审网页上相互审阅彼此修改后的代码，决定是否能够提交，回退或是继续修改。它使用版本控制系统Git作为底层）</p><ul><li>Gerrit为了保证每次代码提交都强制开启代码评审，要求研发人员在提交代码的时候统一使用: git push [remote_name] HEAD:refs/for/[branch_name]，执行后会在评审界面创建一条新的code review，只有通过review之后才可以合入远程仓库。</li><li>此时如果执行<code>git push origin HEAD:refs/head/master</code>，那么就会有“! [remote rejected] master -&gt; master (prohibited by Gerrit)”的错误信息，命令失效。</li><li>对于那些希望将Code Review粒度控制在单次提交级别的研发团队，使用基于Gerrit机制的工具是比较合适的。( <a href="https://cloud.baidu.com/product/xly.html">百度效率云的iCode</a>就是基于Gerrit机制开发的 )</li></ul><img src="/images/git/gerrit.png" alt="gerrit" style="zoom:80%;" /><p>下面一段是对“refs/for”更详细的描述：</p><blockquote><p>The documentation for Gerrit explains that you push to the “magical refs/for/‘branch’ ref using any Git client tool”.</p><p>This image is taken from the Intro to Gerrit. When you push to Gerrit, you do git push gerrit HEAD:refs/for/<code>&lt;BRANCH&gt;</code>. This pushes your changes to the staging area (in the diagram, “Pending Changes”). Gerrit doesn’t actually have a branch called <code>&lt;BRANCH&gt;</code>; it lies to the git client.</p><p>Internally, Gerrit has it’s own implementation for the Git and SSH stacks. This allows it to provide the “magical” refs/for/<code>&lt;BRANCH&gt;</code> refs.</p><p>When a push request is received to create a ref in one of these namespaces Gerrit performs its own logic to update the database, and then lies to the client about the result of the operation. A successful result causes the client to believe that Gerrit has created the ref, but in reality Gerrit hasn’t created the ref at all.  </p><p>After a successful patch (i.e, the patch has been pushed to Gerrit, [putting it into the “Pending Changes” staging area], reviewed, and the review has passed), Gerrit pushes the change from the “Pending Changes” into the “Authoritative Repository”, calculating which branch to push it into based on the magic it did when you pushed to refs/for/<code>&lt;BRANCH&gt;</code>. This way, successfully reviewed patches can be pulled directly from the correct branches of the Authoritative Repository.</p></blockquote><h4 id="6-2-4-HEAD"><a href="#6-2-4-HEAD" class="headerlink" title="6.2.4 HEAD"></a>6.2.4 HEAD</h4><p>指向当前分支的当前提交；</p><h4 id="6-2-5-config"><a href="#6-2-5-config" class="headerlink" title="6.2.5 config"></a>6.2.5 config</h4><p>文件包含项目特有的配置选项，覆盖Git的全局配置</p><h4 id="6-2-6-description"><a href="#6-2-6-description" class="headerlink" title="6.2.6 description"></a>6.2.6 description</h4><p>仅供 GitWeb 程序使用，我们无需关心</p><h4 id="6-2-7-hooks"><a href="#6-2-7-hooks" class="headerlink" title="6.2.7 hooks/"></a>6.2.7 hooks/</h4><p>包含客户端或服务端的钩子脚本（hook scripts）, hook用户操作，拦截一些不合理的行为命令</p><h4 id="6-2-8-info"><a href="#6-2-8-info" class="headerlink" title="6.2.8 info/"></a>6.2.8 info/</h4><p>目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</p><h2 id="七、常用命令"><a href="#七、常用命令" class="headerlink" title="七、常用命令"></a>七、常用命令</h2><h3 id="7-1-提交、撤销与查看"><a href="#7-1-提交、撤销与查看" class="headerlink" title="7.1 提交、撤销与查看"></a>7.1 提交、撤销与查看</h3><h4 id="1-git-checkout-工作区的撤销"><a href="#1-git-checkout-工作区的撤销" class="headerlink" title="1. git checkout  工作区的撤销"></a>1. git checkout  工作区的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销文件在工作区的修改(处于暂存区的修改不受影响)</span></span><br><span class="line">git checkout -- &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果不加<code>--</code>，就变成了“切换到另一个分支”的命令</li><li>untracked的文件修改不受影响</li></ul><h4 id="2-git-add-暂存区的提交"><a href="#2-git-add-暂存区的提交" class="headerlink" title="2. git add 暂存区的提交"></a>2. git add 暂存区的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><p>是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区。</li><li>还能用于合并时把有冲突的文件标记为已解决状态</li></ul><h4 id="3-git-rm-暂存区的提交"><a href="#3-git-rm-暂存区的提交" class="headerlink" title="3. git rm 暂存区的提交"></a>3. git rm 暂存区的提交</h4><p>删除文件，并将这个删除添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt;</span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="4-git-commit-本地仓库的提交"><a href="#4-git-commit-本地仓库的提交" class="headerlink" title="4. git commit 本地仓库的提交"></a>4. git commit 本地仓库的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span></span><br><span class="line">git commit -am(-a -m) <span class="string">&#x27;commit message&#x27;</span> <span class="comment"># 将tracked状态的文件的修改`add+commit`(该命令对未跟踪状态的文件修改不生效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上一条提交的 commit message</span></span><br><span class="line">git commit --amend <span class="comment"># amend(修改，修订；纠正)。修改后是一次新的提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改之前提交的 commit message。比如说，我想修改距此版本之前的第3条 commit message</span></span><br><span class="line"><span class="comment"># 第一步：运行</span></span><br><span class="line">git rebase -i HEAD~3  <span class="comment"># 需要变基，也就是重新提交一遍。与上面的限制是一样，提交对象的commit msg不可修改，除非重新产生提交对象</span></span><br><span class="line"><span class="comment"># -i, --interactive(互动) 允许用户编辑要rebase的提交列表.</span></span><br><span class="line"><span class="comment"># 比如，此时显示</span></span><br><span class="line"><span class="comment"># pick 56b2308 feat(pages): home DONE</span></span><br><span class="line"><span class="comment"># pick 82f65eb fix(pages movie): slides bug fixed</span></span><br><span class="line"><span class="comment"># pick 08b2087 feat(pages home &amp; movie): add FABs animation </span></span><br><span class="line"><span class="comment"># 第二步：将要修改的那条 commit message，如 pick 56b2308 feat(pages): home DONE，pick 改为 edit，修改完成后保存退出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：然后仍然是运行下面的命令修改commit message</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：最后运行</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>将暂存区里所有的修改提交到本地仓库的当前分支：</p><ul><li>会显示： file changed(文件修改)、insertions(插入行)、deletions(删除行)</li><li>可以多次add，一次commit</li></ul><p>commit id解释说明： 看到的一串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><h4 id="5-git-reset-暂存区与本地仓库的撤销"><a href="#5-git-reset-暂存区与本地仓库的撤销" class="headerlink" title="5. git reset 暂存区与本地仓库的撤销"></a>5. git reset 暂存区与本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><p>将当前分支的HEAD指向给定的版本，并根据模式的不同决定是否修改index和working tree。</p><ul><li><p>–soft模式</p><ul><li>指定commit id之后的所有commit的修改、目前index中暂存的修改都被保留在index中；</li><li>working tree中还没暂存的修改保持原样。</li></ul></li><li><p>–mixed(默认)</p><ul><li>清空index</li><li>指定commit id之后的所有commit的修改、目前index中暂存的修改、目前working tree中还没暂存的修改都被保留在工作区中</li><li>可以巧用<code>git reset</code>来<strong>撤销添加到暂存区中的修改</strong>(放入了工作区)，即<code>git reset HEAD &lt;file&gt;</code></li></ul></li><li><p>–hard：</p><ul><li>清空index、workingtree，指定commit id之后的所有提交修改也不会保留。</li></ul></li></ul><p>需要注意：</p><ul><li>reset是<strong>操作的本地仓库</strong>，所以只能reset那些未push到remote仓库的commit。</li><li>Git的版本回退速度非常快，因为Git会保存所有修改，而reset实质上是重置本地仓库的HEAD到指定的commit id，即当你回退版本的时候，Git仅仅是在改变HEAD指向。</li><li>想从3回滚到1，可以使用<code>git log</code>来查看提交日志，获取commit id；</li><li>如果commit已经push到远程仓库，那么origin/HEAD是不受影响的(<code>提交的修改仍保留在远程仓库</code>)，还是指向最新的commit id，此时sourceTree会提示有提交未拉取。<br>如果在这个本地仓库的版本上做修改，提交的时候会失败：<code>Updates were rejected because the tip of your current branch is behind its remote counterpart</code>，即告诉你需要先pull再push。</li></ul><h5 id="撤销之后想恢复"><a href="#撤销之后想恢复" class="headerlink" title="撤销之后想恢复"></a>撤销之后想恢复</h5><p>假如我们刚刚使用了reset –hard从commit3回滚到了1（并清空了工作区），想再恢复到3：</p><blockquote><p>前提是被丢弃的分支或commit信息还没有被git gc清除，一般情况下，gc对那些无用的object会保留很长时间后才清除的。</p></blockquote><p>第一步：通过git log -g命令来找到需要恢复的信息对应的commitid。可以通过提交的时间和日期来辨别，找到执行reset –hard之前的那个commit对应的commitid。（使用 git reflog 从命令日志中找到commit对应的commitid也是可以的）。</p><p>第二步：</p><ol><li>仍然可以使用git reset：<code>git reset &lt;commitid&gt;</code></li><li>使用<code>git branch &lt;branchname&gt; &lt;commitid&gt;</code>，会新建分支，并将到commitid为止的代码、各种提交记录等信息都恢复到了新分支上。</li></ol><h4 id="6-git-revert-本地仓库的撤销"><a href="#6-git-revert-本地仓库的撤销" class="headerlink" title="6. git revert 本地仓库的撤销"></a>6. git revert 本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>回滚指定的提交，并产生一条新的commit。</p><p>在指定commit id的时候，除了通过<code>git log</code>、<code>git reflog</code>来查看，还可以指定通过HEAD(大写)来指定，<code>HEAD</code>表示当前分支当前版本， 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="7-git-status"><a href="#7-git-status" class="headerlink" title="7. git status"></a>7. git status</h4><p>查看仓库当前的状态：</p><ul><li>changes to be committed: 将要被提交的修改包括以下</li><li>no changes added to commit：没有被暂存修改要提交</li><li>changes not staged for commit：以下修改没有被暂存</li><li>no thing to commit, working tree clean：没有需要提交的修改，而且工作目录是干净的</li></ul><h4 id="8-git-log"><a href="#8-git-log" class="headerlink" title="8. git log"></a>8. git log</h4><p>显示从最近到最远的提交日志。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p><ul><li>–graph：显示 ASCII 图形表示的分支合并历史</li><li>–decorate 标记会让git log显示每个commit的引用(如:分支、tag等) </li><li>–simplify-by-decoration 只显示被branch或tag引用的commit(如果去掉该参数，分支图与GUI显示的基本一致了)</li><li>–all 表示显示所有的branch，这里也可以选择，比如我只想显示分支ABC的关系，则将–all替换为branchA branchB branchC</li><li>–abbrev-commit：仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</li><li>–pretty：使用其他格式显示历史提交信息。可用的选项包括 oneline(简写一行)，short，full，fuller 和 format（后跟指定格式）</li><li>-<code>&lt;num&gt;</code>：显示几条</li><li><a href="https://www.progit.cn/#_viewing_history">等等</a></li></ul><p>常用的git log命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --decorate --oneline --simplify-by-decoration --all</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> [branch_name] <span class="comment"># 打印指定分支的提交。如git log dev/3.27.0 --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定作者指定时间的记录</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;xxx&#x27;</span> <span class="comment">#指定人</span></span><br><span class="line">git <span class="built_in">log</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> <span class="comment">#指定时间段</span></span><br><span class="line">git <span class="built_in">log</span> --name-only <span class="comment"># 只列出提交文件的名称</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;zhangsan&#x27;</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> --name-only </span><br></pre></td></tr></table></figure><p>感觉再怎么着也没GUI清晰…</p><p>举例：一个统计代码仓库提交、去重的小脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出commit、然后手动去重(避免某些人不规范使用git，提msg一样的commit)即可</span></span><br><span class="line">array=(<span class="string">&quot;name1&quot;</span> <span class="string">&quot;name2&quot;</span> <span class="string">&quot;name3&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$element</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="variable">$element</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --since=<span class="string">&quot;2020-03-01&quot;</span> --until=<span class="string">&quot;2020-08-31&quot;</span> --no-merges &gt;~/xxxx.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计行数的命令</span></span><br><span class="line"><span class="comment"># 统计某个人、时间范围内、增删代码行数</span></span><br><span class="line">git <span class="built_in">log</span> --author=XX --since=<span class="string">&quot;2021-03-01&quot;</span> --until=<span class="string">&quot;2021-12-31&quot;</span> --no-merges --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added line s: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="9-git-reflog"><a href="#9-git-reflog" class="headerlink" title="9. git reflog"></a>9. git reflog</h4><p>显示命令历史，记录每一次命令</p><h4 id="10-git-push"><a href="#10-git-push" class="headerlink" title="10. git push"></a>10. git push</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [-u | --set-upstream] [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;]  [&lt;:远程分支名&gt;] </span><br></pre></td></tr></table></figure><p>将当前分支的修改推送到远程分支，如果没有该远程分支则创建；</p><p>远程分支名可以写为<code>refs/heads/xx</code>或直接写为<code>xx</code>，好像没区别。</p><ul><li>如果只省略<code>&lt;:远程分支&gt;</code>：将指定的本地分支上的修改推送到同名的远程主机分支上；</li><li>如果只省略<code>&lt;本地分支名&gt;</code>：表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 <code>git push origin --delete master</code>。注意：不会影响本地分支；</li><li>如果当前分支是某个远程仓库中某个分支的跟踪分支，且两者同名，git push后省略远程仓库名、本地分支名、远程分支名等一切参数；</li><li>不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式。如果想更改设置，可以使用git config命令。<code>git config --global push.default matching</code> OR <code>git config --global push.default simple</code>；可以使用<code>git config -l </code>查看配置</li><li>Tag对象与Commit对象十分相似，所以上面一些用法，在推送、删除tag对象时同样适用，比如git push origin :tagName 删除远程tag。</li></ul><h4 id="11-冲突处理"><a href="#11-冲突处理" class="headerlink" title="11. 冲突处理"></a>11. 冲突处理</h4><p><strong>执行git push之前，养成git pull的好习惯</strong>，如果有冲突，先处理冲突。</p><p>如果远程分支有别人的提交，而本地没有拉取，git push的时候，会失败</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27; hint: Updates were rejected because the remote contains work that you do not have locally.</span><br></pre></td></tr></table></figure><p>此时，应先拉取，再push，push之后发现，提交分支图上，出现了分叉，这是因为你的commit及远程他人的提交的父提交对象都是同一个commit对象，所以图谱上当然有分叉。且额外创建了一个新的commit：<code> Merge branch ‘&lt;branch&gt;’ of github.com...</code>，如果不想要这种情况可以使用<code>git rebase</code>。</p><h4 id="12-git-rebase"><a href="#12-git-rebase" class="headerlink" title="12. git rebase"></a>12. git rebase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch&gt;  <span class="comment"># 操作当前分支变基</span></span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>将当前分支(分叉)上的一系列提交的基(父提交)改为指定分支的最新提交</li><li>视觉效果：消除了分支、push的时候远程有提交未拉取造成的分叉</li><li>注意：只能变基本地的分支，如果commit已经推到了远程，就不要再在本地操作了，会弄混乱：此时操作之后根据rebase的工作原理，相当于本地分支新增了数个commit，然后远程仓库中的几个老commit因为被本地分支上删除就会被认成是未拉取的commit。可以先删除远程分支，再变基，再推送。</li></ul><img src="/images/git/rebase.png" alt="rebase" style="zoom:80%;" /><p>本质是：</p><ol><li>把当前分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中)</li><li>然后把当前分支的根commit更新为指定分支的最新commit</li><li>最后把保存的这些补丁重新应用到当前分支上</li><li>更新之后，老的commit会丢弃，而&lt;当前分支&gt;引用指向新创建的最新commit</li></ol><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h4 id="13-git-pull"><a href="#13-git-pull" class="headerlink" title="13. git pull"></a>13. git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [远程仓库名] [远程分支名][:&lt;本地分支名&gt;] <span class="comment"># git pull origin develop:develop (:前后无空格)</span></span><br></pre></td></tr></table></figure><ul><li>[:&lt;本地分支名&gt;] 可以省略，表示拉取并与当前分支合并；</li><li>如果当前分支是跟踪分支，那么可以直接<code>git pull</code>；</li><li>实质上，这等同于先做<code>git fetch</code>（从远程获取最新版本(即对象和引用)到本地，不会自动合并），再执行<code>git merge</code>；</li></ul><p>避免与本地的改动冲突：</p><ul><li>如果本地仓库没有commit：先stash，再pull，再应用stash；</li><li>如果本地仓库中有commit：加<code>--rebase</code>参数：与git rebase功能类似，表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到 <code>.git/rebase</code> 目录中)，然后把本地当前分支更新为最新的”origin”分支，最后把保存的这些补丁应用到本地当前分支上。 </li></ul><h3 id="7-2-分支-平行宇宙"><a href="#7-2-分支-平行宇宙" class="headerlink" title="7.2 分支(平行宇宙)"></a>7.2 分支(平行宇宙)</h3><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 </p><p>但Git的分支是与众不同的，无论创建、切换和删除分支都很快。</p><p>前面已经提到，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支，默认有一条分支叫主分支，即master分支。</p><h4 id="1-git-branch-创建-删除-查看分支"><a href="#1-git-branch-创建-删除-查看分支" class="headerlink" title="1. git branch 创建/删除/查看分支"></a>1. git branch 创建/删除/查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支。如果一个分支还没被合并，会删除失败， 提示：如果删除，将丢失掉修改，可以使用大写的-D参数强行删除</span></span><br><span class="line">git branch -d &lt;branch&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push &lt;remote&gt; &lt;:remote-branch&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支重命名(如果已经推送远程，那么需要删除远程，重新推送)</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有分支，当前分支前面会标一个*号</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><h4 id="2-git-checkout-切换"><a href="#2-git-checkout-切换" class="headerlink" title="2. git checkout 切换"></a>2. git checkout 切换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;    <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch&gt; <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>前面讲过，撤销修改是 <code>git checkout -- &lt;file&gt;</code>，为了避免混淆，最新版本的Git提供了新的git switch命令来切换分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;branch&gt;    <span class="comment"># 切换</span></span><br><span class="line">git switch -c &lt;branch&gt; <span class="comment"># 创建并切换</span></span><br></pre></td></tr></table></figure><h4 id="3-跟踪分支"><a href="#3-跟踪分支" class="headerlink" title="3. 跟踪分支"></a>3. 跟踪分支</h4><p>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入git pull、git push，Git 能自动地识别去<code>哪个服务器(仓库名指定的)</code>上的<code>哪个分支</code>pull、push。</p><h5 id="1-跟踪分支的设置"><a href="#1-跟踪分支的设置" class="headerlink" title="1) 跟踪分支的设置"></a>1) 跟踪分支的设置</h5><ul><li><p>从一个远程跟踪分支检出本地分支时，选择<strong>本地分支是否跟踪远程分支</strong>；</p></li><li><p>当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支；</p></li><li><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或–set-upstream-to选项运行git branch来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/mybranch1 mybranch1</span><br></pre></td></tr></table></figure><ul><li>后者可省略，表示当前本地分支</li><li>一定要加origin，否则表示本地分支，而且还能跟踪成功，表示当前本地分支跟踪了另一个本地分支</li></ul></li><li><p>git push的时候设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u/--set-upstream origin localBranch:remoteBranch  <span class="comment"># 后者可省略，表示远程同名分支</span></span><br></pre></td></tr></table></figure><p>表示把localBranch分支上的修改提交到remoteBranch上，并建立跟踪关联。相比之下这种方式比上面那种使用的更普遍，因为<strong>上面那个首先需要有那个远程分支才可以用</strong>。</p></li><li><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch -vv</code>： 会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p></li></ul><h5 id="2-如果未设置跟踪分支"><a href="#2-如果未设置跟踪分支" class="headerlink" title="2) 如果未设置跟踪分支"></a>2) 如果未设置跟踪分支</h5><p>无论是否存在同名的远程分支，git push、git pull时都要加上<code>&lt;远程主机名&gt; &lt;本地分支名&gt;</code></p><p>不然前者报错： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch &lt;localBranch&gt; has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use `git push --set-upstream origin &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><p>后者报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. </span><br><span class="line">`git pull &lt;remote&gt; &lt;branch&gt;`</span><br><span class="line">If you wish to set tracking information for this branch you can do so with: `git branch --set-upstream-to=origin/&lt;remoteBranch&gt; &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><h5 id="3-如果设置了跟踪分支"><a href="#3-如果设置了跟踪分支" class="headerlink" title="3) 如果设置了跟踪分支"></a>3) 如果设置了跟踪分支</h5><p>设置成功后，会提示：Branch ‘testBranch’ set up to track remote branch ‘testBranch’ from ‘origin’.</p><p>本地分支与跟踪的远程分支是否同名：</p><ul><li><p>是：可以直接使用git push、git pull，省略之后的参数</p></li><li><p>否：依然可以使用git pull。不能直接使用git push，省略之后报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match the name of your current branch.  </span><br><span class="line">To push to the upstream branch on the remote, use `git push origin HEAD:remoteBranch`</span><br><span class="line">To push to the branch of the same name on the remote, use `git push origin HEAD`</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-git-merge-合并"><a href="#4-git-merge-合并" class="headerlink" title="4. git merge 合并"></a>4. git merge 合并</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>如果合并发生冲突(两个分支都对一个文件进行修改)，需要解决冲突后，再手动commit。</p><ul><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li></ul><h5 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h5><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式：</p><ul><li>当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</li><li>举例：比如从master上创建分支A，在A上有了数个commit，master上没有提交，此时将A合并到master，实质是将master直接指向A的最新commit（将master引用指向的SHA-1值改为A最新的commit对象的SHA-1值）。</li><li>普通模式的合并有分叉，可以看出曾经做过合并，而fast forward合并看不出来曾经做过合并。</li></ul><p><strong>如果不是fast-forward模式，Git就会在merge时生成一个新的commit。</strong></p><p>可以强制禁用Fast forward模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &lt;“merge”&gt; &lt;branch&gt;   <span class="comment"># 要加commit message，因为会生成一个新commit对象</span></span><br></pre></td></tr></table></figure><img src="/images/git/git-merge-no-ff.png" alt="git-merge-no-ff" style="zoom:67%;" /><p>建议都加上 <code>--no-ff</code>：</p><ul><li>如果有些分支合并后删除，那么<code>--no-ff</code>可以很清楚的看到这些分支的历史存在的信息。反之，fast-forward模式就会导致不知道这些分支曾经存在过。</li><li>可以将所有一起实现了一项功能的 commit 组合在一起。否则，您必须手动读取所有日志消息，来判定一项功能实现所需要的commit。此时，撤销整个功能（即一组提交）是一个真正令人头疼的问题。</li><li>是的，它会创建更多（空）commit 对象，但收益远大于成本。</li></ul><h4 id="5-git-log-查看"><a href="#5-git-log-查看" class="headerlink" title="5. git log 查看"></a>5. git log 查看</h4><p>显示分支合并图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="6-git-cherry-pick"><a href="#6-git-cherry-pick" class="headerlink" title="6. git cherry-pick"></a>6. git cherry-pick</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得在另一个分支中单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。</span></span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移多个提交</span></span><br><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt; <span class="comment"># 将 A 和 B 两个提交应用到当前分支</span></span><br><span class="line">git cherry-pick A..B  <span class="comment"># 转移从 A 到 B 的所有提交</span></span><br><span class="line"><span class="comment"># 提交 A 必须早于提交 B，否则命令将失败，但不会报错。</span></span><br><span class="line"><span class="comment"># 提交 A 将不会包含在 Cherry pick 中，即(A, B]</span></span><br><span class="line">git cherry-pick A^..B <span class="comment"># 包含A，即[A, B]</span></span><br></pre></td></tr></table></figure><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><ul><li>–continue<br>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。<br><code>git cherry-pick --continue</code></li><li>–abort<br>发生代码冲突后，放弃合并，回到操作前的样子。</li><li>–quit<br>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</li></ul><h3 id="7-3-stash"><a href="#7-3-stash" class="headerlink" title="7.3 stash"></a>7.3 stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 将更改储藏在脏工作目录中，clean目前工作区</span></span><br><span class="line"></span><br><span class="line">git stash list <span class="comment"># 查看所有stash</span></span><br><span class="line"><span class="comment"># stash@&#123;0&#125;: WIP on master: 049d078 added the index file </span></span><br><span class="line"><span class="comment"># stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span></span><br><span class="line"></span><br><span class="line">git stash apply [&lt;stash&gt;]  <span class="comment"># 恢复，但是恢复后，stash内容并不删除</span></span><br><span class="line"><span class="comment"># 可以通过名字指定它，像这样：git stash apply stash@&#123;2&#125;。</span></span><br><span class="line"><span class="comment"># 如果不指明，Git 默认使用最近的储藏并尝试应用它</span></span><br><span class="line"></span><br><span class="line">git stash drop [&lt;stash&gt;]   <span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">git stash pop [&lt;stash&gt;]    <span class="comment"># 恢复的同时把stash内容也删掉</span></span><br></pre></td></tr></table></figure><h3 id="7-4-tag"><a href="#7-4-tag" class="headerlink" title="7.4 tag"></a>7.4 tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; [commit]    <span class="comment"># 打一个轻量标签，如果省略&lt;commit&gt;，则表示最新提交</span></span><br><span class="line"></span><br><span class="line">git tag -a &lt;name&gt; -m &lt;<span class="string">&quot;message&quot;</span>&gt; [commit]  <span class="comment"># 打附注标签(带有说明)，用-a指定标签名，-m指定说明文字</span></span><br><span class="line"></span><br><span class="line">git tag <span class="comment"># 查看所有标签， 标签不是按时间顺序列出，而是按字母排序</span></span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 推送标签到远程</span></span><br><span class="line">git push origin --tags    <span class="comment"># 一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line"></span><br><span class="line">git tag -d &lt;name&gt;  <span class="comment"># 删除标签</span></span><br><span class="line">git push &lt;remote&gt; &lt;:tagname | refs/tags/&lt;tagname&gt;&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>如果tag与分支同名，在/refs/heads/、/refs/tags/下都能找到文件名为这个名字的文件，此时操作时如果直接写标签名，可能会报错：<code>...match more than one</code>。</p><h3 id="7-5-补丁的创建与应用"><a href="#7-5-补丁的创建与应用" class="headerlink" title="7.5 补丁的创建与应用"></a>7.5 补丁的创建与应用</h3><p>Git 提供了两种补丁方案</p><ul><li>用 <code>git diff</code> 生成的UNIX标准补丁.diff文件： .diff文件只是记录文件改变的内容，不带有commit记录信息，多个commit可以合并成一个diff文件。 </li><li>用 <code>git format-patch</code> 生成的Git专用.patch 文件:  .patch文件带有记录文件改变的内容，也带有commit记录信息。每个commit对应一个patch文件。</li></ul><p><strong>在Git下，我们可以使用.diff文件也可以使用.patch 文件来打补丁，主要应用场景有：CodeReview、代码迁移等。</strong></p><h4 id="7-5-1-创建补丁git-diff"><a href="#7-5-1-创建补丁git-diff" class="headerlink" title="7.5.1 创建补丁git diff"></a>7.5.1 创建补丁git diff</h4><p>顾名思义就是查看<code>已跟踪tracked文件</code>的difference：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [--cached] [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [查看文件名] [&gt; diff补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>不加参数即默认比较工作区与暂存区；</li><li>如果加了一个commit id，表示比较目前代码与指定commit的差异 = 当前工作区+暂存区+指定commit后的commit修改；</li><li>如果加了两个commit id，表示比较后者与前者两次提交之间的差异；</li><li>如果加了–cached（后面即使没有commit id，默认相当于有个HEAD），意义是在上条的基础上忽略工作区的改动，即差异 = 当前暂存区 + 指定commit后的commit修改；</li><li>在上面的基础上，后面如果加了 <code>&gt; 文件名</code>，表示将上面比较出的差异，导出一个补丁，可以拷贝到另一机器或者另一个马甲项目中应用。</li></ul><h4 id="7-5-2-创建补丁git-patch"><a href="#7-5-2-创建补丁git-patch" class="headerlink" title="7.5.2 创建补丁git patch"></a>7.5.2 创建补丁git patch</h4><p>会将指定commit id 后的每一个commit分别单独生成patch文件。</p><p>patch文件按照commit的先后顺序从1开始编号。</p><p>patch文件会生成到当前目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [-n] [&gt; patch补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>commitId 如果省略，表示HEAD指针指向的commit</li><li>-n 表示为HEAD后的n个 commit 生成 patch</li></ul><h4 id="7-5-3-补丁应用git-apply"><a href="#7-5-3-补丁应用git-apply" class="headerlink" title="7.5.3 补丁应用git apply"></a>7.5.3 补丁应用git apply</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查patch/diff是否能正常打入。如果没有任何输出，那么表示可以顺利接受这个补丁</span></span><br><span class="line">git apply --check patch/diff文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用补丁</span></span><br><span class="line">git apply patch/diff文件名</span><br><span class="line"><span class="comment"># apply patch 成功后会自动commit，并且保留原来commit的comments，submittor等信息。但是commit id会新生成</span></span><br><span class="line"><span class="comment"># apply diff 成功后，会将修改放入工作区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</span></span><br><span class="line">git apply --reject patch/diff文件名</span><br></pre></td></tr></table></figure><p>此外，patch补丁文件，还可以使用git am命令来应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am &lt;path/to/xxx.patch&gt; </span><br></pre></td></tr></table></figure><p>补丁冲突解决：</p><p>在打补丁过程中有时候会出现冲突的情况，有冲突时会打入失败。此时需要解决冲突： </p><ol><li>首先使用 以下命令行，自动合入 patch 中不冲突的代码改动，同时保留冲突的部分： git apply –reject xxxx.patch . 此时会在终端中显示出冲突的大致代码， 同时会生成后缀为 .rej 的文件，保存没有合并进去的部分的内容，可以参考这个进行冲突解决。</li><li>解决完冲突后删除后缀为 .rej 的文件，并执行 <code>git add .</code> 添加改动到暂存区. </li><li>接着执行 <code>git am --resolved</code> 或者 <code>git am --continue</code></li></ol><p>说明：在打入patch冲突时，可以执行git am –skip跳过此次冲突，也可以执行git am –abort回退打入patch的动作，还原到操作前的状态。</p><h4 id="7-5-4-手动修改补丁文件"><a href="#7-5-4-手动修改补丁文件" class="headerlink" title="7.5.4 手动修改补丁文件"></a>7.5.4 手动修改补丁文件</h4><img src="/images/git/patch.png" alt="patch" style="zoom:90%;" /><p>有时候patch apply遇到问题，可以根据当前上下文，手动修改patch再进行apply。</p><p>上图就是修改前的patch。patch格式说明，其格式为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -[起始行号],[修改前的行数] +[起始行号],[修改后的行数]</span><br></pre></td></tr></table></figure><p>在新增或删除一行时，记得修改 [修改后的行数]</p><h2 id="八、分支管理策略"><a href="#八、分支管理策略" class="headerlink" title="八、分支管理策略"></a>八、分支管理策略</h2><blockquote><p>只有适合自己团队的，才是最好的。下面介绍的是一些经典的策略，但并不一定适合你。</p></blockquote><h3 id="8-1-develop—release—master"><a href="#8-1-develop—release—master" class="headerlink" title="8.1 develop—release—master"></a>8.1 develop—release—master</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">参考链接 — A successful Git branching model</a></p><img src="/images/git/git-model.png" alt="Snip20200423_10" style="zoom:70%;" /><p>如果项目是持续交付软件(比如前端/后端)，那建议采用更简单的工作流程(比如 <a href="https://guides.github.com/introduction/flow/">GitHub flow</a>)；如果您正在构建明确版本化的软件，或者需要支持软件的多个版本同时运营，那本文的分支模型还是很有帮助的。</p><p>中央仓库拥有两个具有无限生命周期的主要分支：master与develop。这个两个分支的生命周期是整个项目周期。</p><ul><li><strong>master</strong>与<strong>develop</strong>分支：<ul><li>master分支是创建git仓库时自动生成的，随即我们就会从master分支创建平行分支 — develop分支。</li><li>master分支的 <code>HEAD</code> 始终指向/反映当前生产环境的代码状态。</li><li>develop分支的 <code>HEAD</code> 始终指向/反映下一个交付版本的开发的最新状态。有人将其称为<strong>“集成分支”</strong>（<strong>integration branch</strong>）。</li><li>当develop分支中的源代码达到稳定点并准备发布时，所有更改都应该以某种方式(<em>中间经过Release branches处理，后面细讲</em>)合并回master，然后打个Tag（使用发布版本号命名）。</li><li><strong>严格遵守</strong>：每次将更改合并回master分支时，这必然表示是一个新的生产版本。即<strong>master 上的每个提交都是定义的新版本</strong>。因此理论上，每次在 master 上进行提交，我们可以使用 Git hook 脚本来自动构建我们的软件并将其推出到我们的生产服务器上。</li></ul></li></ul><p>之外，还有各种支持分支来实现团队成员之间的并行开发、生产版本的准备、快速修复生产问题。</p><p>与master和develop分支不同，这些分支的生命周期总是有限的，因为它们最终会被合并到 develop 或 master 分支，然后删除。（<strong>建议：merge分支时，都加上 <code>--no-ff</code> 参数</strong>）</p><p>这些分支中的每一个都有特定的目的，并且必须遵守严格的规则，即它们是从什么分支中创建，需要合并到什么分支。</p><ul><li><strong>Feature branches</strong>：功能分支，有时也称主题分支(topic branches)。<ul><li><strong>从develop分支创建，完成后合并回develop分支。</strong></li><li>用于为即将发布的、或遥远的未来版本开发新功能。</li><li>当我们开始开发一个特性时，这个特性将被合并到的目标发布版本很可能是未知的。只要特性处于开发阶段，feature 分支就会一直存在，直到最终被合并回develop分支（新特性确定要添加到即将发布的版本中）或丢弃（实验效果不佳）。</li><li>feature 分支通常仅存在于开发人员的仓库中，而不存在于 origin 中。(<em>取决于需不需要协作吧</em>)。使用完就可以删除了。</li></ul></li><li><strong>Release branches</strong>：发布分支。命名规范<code>release-*</code> （*最好是版本号）<ul><li><strong>从develop分支创建，完成后合并回develop和master分支。</strong></li><li>当 develop（几乎）达到了新版本的期望状态，至少所有新版本中需要的 feature 都合并到 develop 中时，我们从develop分支出一个release分支。在此分支上做一些发布版本的准备工作，准备一些发布的元数据，如版本号、构建日期等。此时，develop分支就可以接收/集成下一个大版本的功能。<ul><li>release分支创建之时，我们才能根据版本号更新规则确定新版本的版本号，此前，develop 分支只是反映了“下一个版本”的变化，但不清楚“下一个版本”最终会变成 0.3 还是 1.0 等。</li></ul></li><li>这个新分支可能会存在一段时间，直到发布可能确定推出。在此期间，可以在此分支（而不是develop）中修复一些小错误。严禁在此分支上添加新feature，它们必须合并到develop分支中，等待下一个发布版本。</li><li>当release分支真正准备好要发布时，我们需要：<ul><li>release 分支被<strong>合并到 master</strong> 中。对 master 上的此次提交<strong>打个Tag</strong>，以便将来参考此历史版本。</li><li>在release分支上所做的更改需要<strong>合并回 develop</strong>，以便将来的版本也包含这些错误修复。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">$ git tag -a 1.2</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line"><span class="comment"># 这一步很可能会导致合并冲突（因为我们已经更改了版本号）。如果是这样，修复它并提交。</span></span><br></pre></td></tr></table></figure></li></ul></li><li>此时，发布完成，release分支可以被删除，不再需要它。</li></ul></li><li><strong>Hotfix branches</strong>：热修复分支，命名规范 <code>hotfix-*</code> (*可以是版本号，也可以约定为其他)。主要为修复线上特别紧急的bug准备的。<ul><li><strong>从master分支创建，完成后合并回develop与master分支。</strong></li><li>hotfix 分支与 release 分支非常相似，因为它们也是在为新的生产版本做准备，尽管是计划外的…。当必须立即解决生产版本中的严重错误，等不到正常的版本迭代(develop/release分支代码还不够稳定)时，可以在 master 分支上，找到生产版本对应的Tag，从此处分支出一个 hotfix 分支。</li><li>后续跟release分支基本一致：确定版本号、通过一个或多个的commit修复错误、准备发布的元数据、测试完成合并回master、打tag标记发布版本、合并到develop。</li><li>此处规则有一个例外是，<strong>如果当前存在 release 分支，hotfix 分支需要合并到该 release 而不是 develop 分支中</strong>。一是因为 release 分支需要同步此修改，二是 release 完成时，会合并到develop 分支中，也会导致最终这个bugfix会合并develop分支中。（如果develop中的工作立即就需要这个bugfix，等不到release分支完成，那也可以将bugfix合并到develop中）</li><li>发布完成，hotfix 分支也可以删除了。</li></ul></li><li>关于bugfix，可以在release分支上直接进行，也可以每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</li></ul><p>下图剔除了一些说明，看起来简单些：</p><img src="/images/git/git-model-simple.png" alt="Snip20200423_10" style="zoom:80%;" /><h3 id="8-2-develop—release合并"><a href="#8-2-develop—release合并" class="headerlink" title="8.2 develop—release合并"></a>8.2 develop—release合并</h3><p>总结下来：develop、release分支是分别负责版本发布流程中的feature分支集成/合并 和 测试、发布两部分。</p><p>这两个分支有两种合并方案：</p><ul><li>省去release分支：在develop分支上合并feature分支、集成测试、发布准备。发布后合并master。</li></ul><img src="/images/git/Snip20200423_10.png" alt="Snip20200423_10" style="zoom:90%;" /><ul><li>省去develop分支：版本的集成、测试、发布，都在对应的 <code>release-*</code> / <code>release/xx</code> 分支上进行。如下图是据说是美团的命名示意图：</li></ul><img src="/images/git/Snip20200423_11.png" alt="Snip20200423_11" style="zoom:90%;" /><h3 id="8-3-develop—release—feature合并"><a href="#8-3-develop—release—feature合并" class="headerlink" title="8.3 develop—release—feature合并"></a>8.3 develop—release—feature合并</h3><p>如果团队规模较小，每次开发功能时，基本就能确定要上线的版本号，并且功能比较耦合，几个团队成员没必要单独开辟各自的 <code>feature/xxx</code> 分支。</p><p>此时，就可以省略 <code>feature</code> 这类分支。</p><p>每次开发时，直接开辟 <code>release/*</code> / <code>develop/*</code> / <code>daily/*</code> 分支（*建议为版本号）。在此分支上完成开发、(中间就没有集成这一步了)、测试、发布。</p><h2 id="九、报错集锦"><a href="#九、报错集锦" class="headerlink" title="九、报错集锦"></a>九、报错集锦</h2><h3 id="9-1-超过100M报错"><a href="#9-1-超过100M报错" class="headerlink" title="9.1 超过100M报错"></a>9.1 超过100M报错</h3><p>超过50M警告：remote: warning: File ppt/Implementing AutoML Techniques at Salesforce Scale.pdf is 66.68 MB; this is larger than GitHub’s recommended maximum file size of 50.00 MB</p><p>超过100M报错：remote: error: GH001: Large files detected. You may want to try Git Large File Storage - <a href="https://git-lfs.github.com/">https://git-lfs.github.com</a>. 报错信息，里面提供了解决办法，就是使用 <a href="https://www.iteblog.com/redirect.php?url=aHR0cHM6Ly9naXQtbGZzLmdpdGh1Yi5jb20v&article=true">Git Large File Storage (LFS)</a>。</p><p><strong>Find 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有超过100M的文件</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -size +102400k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索名字为xxx的文件/文件夹</span></span><br><span class="line">find ./ -iname <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜出并删除，删除过程中可能会出现override r-r--r-- xxxx(系统当前用户名)/staff for 文件名? 没有权限的意思，加sudo即可</span></span><br><span class="line">find ./ -name <span class="string">&quot;.git&quot;</span> -<span class="built_in">exec</span> rm -r <span class="string">&quot;&#123;&#125;&quot;</span> \;</span><br></pre></td></tr></table></figure><h2 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a>十、参考链接</h2><ul><li><a href="https://www.progit.cn/#_pro_git">《Pro Git》</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 — 廖雪峰</a></li></ul><p>GUI工具：</p><ul><li>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 </li><li>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;一、Git&quot;&gt;&lt;/a&gt;一、Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来</summary>
      
    
    
    
    <category term="Git" scheme="https://tenloy.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Objc Runtime总结</title>
    <link href="https://tenloy.github.io/2021/10/28/runtime-data-structure.html"/>
    <id>https://tenloy.github.io/2021/10/28/runtime-data-structure.html</id>
    <published>2021-10-28T10:26:09.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内容骨架来自戴铭老师文章<a href="https://ming1016.github.io/2015/04/01/objc-runtime/">Objc Runtime 总结</a>，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。</p><p>更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。</p></blockquote><h1 id="一、Runtime概述"><a href="#一、Runtime概述" class="headerlink" title="一、Runtime概述"></a>一、Runtime概述</h1><h2 id="1-1-Runtime做了什么？"><a href="#1-1-Runtime做了什么？" class="headerlink" title="1.1 Runtime做了什么？"></a>1.1 Runtime做了什么？</h2><p>Objective-C跟C、C++等语言有着很大的不同，是一门动态性比较强的编程语言。允许很多操作推迟到程序运行时再进行，其可以在运行过程中修改之前编译好的行为，比如程序运行时创建，检查，修改类、对象和它们的方法。</p><blockquote><p>维基：<strong>动态编程语言</strong>是高级编程语言的一个类别，是一类在运行时可以改变其结构的语言，或者说可以在运行时执行静态编程语言在编译期间执行的许多常见编程行为。例如：程序的扩展、添加新代码，已有的函数可以被删除或修改、扩展对象、定义或修改类型系统等。</p></blockquote><p>而Objective-C的动态性是由Runtime来支撑和实现的。</p><blockquote><p>很久之前孙源老师的一篇文章中说道：objc = C + objc编译器 + runtime</p></blockquote><p>Runtime做了什么：</p><ul><li>建立了支持objc语言的数据结构。使得C具有了面向对象能力</li><li>建立了消息机制</li></ul><img src="/images/runtime/04.jpg" alt="04" style="zoom:60%;" /><h2 id="1-2-学习链接"><a href="#1-2-学习链接" class="headerlink" title="1.2 学习链接"></a>1.2 学习链接</h2><ul><li>Runtime是C和汇编编写的，是开源的，<a href="https://opensource.apple.com/source/objc4/">下载地址</a>；</li><li>GNU也有一个开源的runtime版本，他们都努力的保持一致。</li><li>苹果官方的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a>。</li><li>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。可以在苹果官方文档<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C Runtime Reference</a>中查看 Runtime 库函数的详细解释。<ul><li>当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，如果发现没有代码提示，函数里面的参数和描述也没有了。可以在 <code>Build Setting</code> 中设置 <code>Enable Strict Checking of objc_msgSend Calls</code> 为 NO。</li></ul></li></ul><p>写在前面：</p><ul><li>后缀 <code>_t</code> 意味着 type/typedef(类型) ，是一种命名规范，类似于全局变量加前缀 <code>g_</code>。</li><li><code>_np</code>表示不可移植(np意指non portable, 不可移植)。</li></ul><h1 id="二、Object、Class与MetaClass"><a href="#二、Object、Class与MetaClass" class="headerlink" title="二、Object、Class与MetaClass"></a>二、Object、Class与MetaClass</h1><h2 id="关系简图"><a href="#关系简图" class="headerlink" title="关系简图"></a>关系简图</h2><img src="/images/compilelink/36.png" alt="36" style="zoom:88%;" /><p>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容。</p><p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p><p>objc_class 1.0和2.0的差别示意图：</p><img src="/images/runtime/08.png" alt="08" style="zoom:67%;" /><h2 id="2-1-objc-object与id"><a href="#2-1-objc-object与id" class="headerlink" title="2.1 objc_object与id"></a>2.1 objc_object与id</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 类的实例结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">//方法略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class. id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><h3 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h3><p><strong>看到 objc_object 的结构后，此处有个结论：任何结构体，只要以一个指向 Class 结构体的指针开始，都可以视为一个 objc_object (对象)。</strong></p><blockquote><ul><li><strong>32位中，只要一个数据结构的前4个字节，是个指针(Class isa)，就是个对象。</strong></li><li><strong>64位中，只要一个数据结构的前8个字节，是个isa_t类型的变量(isa_t isa)，就是个对象。</strong></li></ul></blockquote><p><strong>反之，Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;my name&#x27;s %@&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];  </span><br><span class="line">    <span class="comment">// obj的前8个字节是指向Class Sark的数据，所以其能视为Sark类对象的。</span></span><br><span class="line">    <span class="comment">// 但是在-speak中，取obj的name，本质是取obj后偏移的第9-16字节的数据，此处会取出-viewDidLoad函数栈中的数据，错乱掉。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br></pre></td></tr></table></figure><h2 id="2-2-objc-class"><a href="#2-2-objc-class" class="headerlink" title="2.2 objc_class"></a>2.2 objc_class</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Objc的类的本身也是一个Object，类的类型我们称为元类Meta Class，记录类方法、属性。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 指向父类的指针，用于组织类的继承链；</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// 缓存调用过的method。对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。(以前缓存指针pointer和vtable)</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line">       <span class="comment">// class_rw_t * plus custom rr/alloc flags. </span></span><br><span class="line">       <span class="comment">// 表示class_data_bits_t其实是class_rw_t* 加上自定义的rr/alloc标志，rr/alloc标志是指含有的retain/release/autorelease/retainCount/alloc等</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">// class_data_bits_t结构体主要用于记录，保存类的数据的`class_rw_t`结构体的内存地址。通过`date()`方法访问`bits`的有效位域指向的内存空间，返回`class_rw_t`结构体；`setData(class_rw_t *newData)`用于设置`bits`的值；</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-成员-isa-t-isa"><a href="#2-2-1-成员-isa-t-isa" class="headerlink" title="2.2.1 成员: isa_t isa"></a>2.2.1 成员: isa_t isa</h3><p>在arm64架构之前，isa就是一个普通的指针(Class _Nonnull isa)，存储着Class、Meta-Class对象的内存地址 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从arm64架构开始：</p><ul><li><p>明确的将objc_class定义为一个Object，继承自struct objc_object。</p></li><li><p>对isa进行了优化，变成了一个共用体（union）结构，使用位域来存储了更多的信息。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;   <span class="comment">// isa(is a)指向它的类。当向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;    // class的isa指针指向class的类(术语称为Meta Class)，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL  取类指针值的掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL  取MAGIC值的掩码</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 代表是否开启isa指针优化。0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否设置或曾经过关联对象(associatedObject)，如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++ 或者 Objc的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类指针。存储着Class、Meta-Class对象的内存地址信息。源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 对象被指向或者曾经指向一个 ARC 的弱变量。如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 里面存储的值是引用计数器减1（比如对象引用计数器是1，这里就是0）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure><h4 id="关于Tagged-Pointer"><a href="#关于Tagged-Pointer" class="headerlink" title="关于Tagged Pointer"></a>关于Tagged Pointer</h4><p>在2013年9月，苹果推出了<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/IPhone_5S">iPhone5s</a>，与此同时，iPhone5s配备了首个采用64位架构的<a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Apple_A7">A7双核处理器</a>，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p><p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer用于优化NSNumber、NSDate、NSString等小对象的存储，其存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p><p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。</p><p>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。如下图所示：</p><img src="/images/runtime/05.png" alt="05" style="zoom:75%;" /><h3 id="2-2-2-成员-cache-t-cache"><a href="#2-2-2-成员-cache-t-cache" class="headerlink" title="2.2.2 成员: cache_t cache"></a>2.2.2 成员: cache_t cache</h3><blockquote><p>cache: 用于缓存调用过的method</p></blockquote><p>Cache的作用主要是为了优化方法调用的性能。</p><p>假如，当对象receiver调用方法message时：</p><ol><li>首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法；</li><li>如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。</li></ol><p>这样查找方式效率就太低了，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>  <span class="comment">// 是一个散列表，用来存储Method的链表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;               <span class="comment">// 分配用来缓存bucket的总数。散列表的长度 - 1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;           <span class="comment">// 目前实际占用的缓存bucket的个数。因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uintptr_t</span> _imp;  <span class="comment">// 函数指针，指向了一个方法的具体实现</span></span><br><span class="line">  SEL _sel;        <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_hash</span><span class="params">(SEL sel, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(<span class="keyword">uintptr_t</span>)sel &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul><li><p><strong>不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存。</strong>详见4.3节</p></li><li><p>关于缓存的扩容以及限制：</p><ul><li>初始大小为4；</li><li>当缓存使用达到3/4后，进行缓存扩容，扩容系数为2；</li><li>扩容时，会清空缓存，否则hash值就不对了；</li><li>旧版本中，类的方法缓存大小是有没有限制的，在新的runtime中增加了限制；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br><span class="line">    MAX_CACHE_SIZE_LOG2  = <span class="number">16</span>,</span><br><span class="line">    MAX_CACHE_SIZE       = (<span class="number">1</span> &lt;&lt; MAX_CACHE_SIZE_LOG2),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        capacity = MAX_CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>);   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？这个问题么，我觉得有以下三个原因：</p><ul><li>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。</li><li>list的方法还保存了除了selector和imp之外其他很多属性</li><li>散列表是有空槽的，会浪费空间</li></ul></li></ul><h3 id="2-2-3-成员-class-data-bits-t-bits"><a href="#2-2-3-成员-class-data-bits-t-bits" class="headerlink" title="2.2.3 成员: class_data_bits_t bits"></a>2.2.3 成员: class_data_bits_t bits</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><blockquote><p><code>bits</code>：<code>class_data_bits_t</code>结构体类型，该结构体主要用于记录，保存类的数据的<code>class_rw_t</code>结构体的内存地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;  <span class="comment">// 仅有一个成员 bits 指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取类的数据。获取 bits 成员的 4~47 位域(FAST_DATA_MASK)中保存的 class_rw_t 结构体地址。</span></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 仅在类注册、构建阶段才允许调用setData</span></span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">data</span>()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        <span class="built_in">atomic_thread_fence</span>(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-class-rw-t与class-ro-t简介"><a href="#2-class-rw-t与class-ro-t简介" class="headerlink" title="2. class_rw_t与class_ro_t简介"></a>2. class_rw_t与class_ro_t简介</h4><p><code>class_rw_t</code>、<code>class_ro_t</code>结构体名中，<code>rw</code>是 read write 的缩写，<code>ro</code>是 read only 的缩写，可见<code>class_ro_t</code>的保存类的只读信息，这些信息在类完成注册后不可改变。</p><p>即分类等运行期添加的数据保存在<code>class_rw_t</code>结构体中，编译时期就能确定的部分保存在<code>ro</code>指针指向的<code>class_ro_t</code>结构体中。</p><p>以类的成员变量列表为例（成员变量列表保存在<code>class_ro_t</code>结构体中）。若应用类注册到内存后，使用类构建了若干实例，此时若能够添加成员变量，那必然需要对内存中的这些类重新分配内存，这个操作的花销是相当大的。若考虑再极端一些，为根类<code>NSObject</code>添加成员变量，则内存中基本所有 Objective-C 对象都需要重新分配内存，如此庞大的计算量在运行时是不可接受的。</p><h4 id="3-bits在编译、运行期间值的改变"><a href="#3-bits在编译、运行期间值的改变" class="headerlink" title="3. bits在编译、运行期间值的改变"></a>3. bits在编译、运行期间值的改变</h4><p>注意：<strong>在编译期，类的结构中的 class_data_bits_t的 class_rw_t</strong> *<strong>data() 取出的是一个指向 class_ro_t 的指针。</strong></p><img src="/images/runtime/06.png" alt="06" style="zoom:80%;" /><p>在运行时调用 realizeClass方法，会做以下3件事情：</p><ol><li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针；</li><li>初始化一个 class_rw_t结构体；</li><li>设置结构体 ro的值以及 flag；</li><li>最后设置正确的 <code>data</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;<span class="built_in">setData</span>(rw);</span><br></pre></td></tr></table></figure><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><img src="/images/runtime/07.png" alt="06" style="zoom:80%;" /><p>更加详细的分析，请看<a href="https://link.jianshu.com/?t=https://github.com/Draveness">@Draveness</a> 的这篇文章<a href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a>。</p><h3 id="2-2-4-方法-类加载过程中，状态读写"><a href="#2-2-4-方法-类加载过程中，状态读写" class="headerlink" title="2.2.4 方法: 类加载过程中，状态读写"></a>2.2.4 方法: 类加载过程中，状态读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class结构体中与类的加载过程相关的方法：</span></span><br><span class="line"><span class="comment">// 查询是否正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记为正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已完成初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class metacls;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    cls = (Class)<span class="keyword">this</span>;</span><br><span class="line">    metacls = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于alloc/dealloc/Retain/Release等特殊方法的判断及处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    metacls-&gt;<span class="built_in">changeInfo</span>(RW_INITIALIZED, RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取load方法的IMP</span></span><br><span class="line"><span class="function">IMP <span class="title">objc_class::getLoadMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的基础方法列表中查询load方法的IMP</span></span><br><span class="line">    mlist = <span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">&quot;load&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime是否已认识/实现类</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否future class</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFuture</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_FUTURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-方法-类状态获取"><a href="#2-2-5-方法-类状态获取" class="headerlink" title="2.2.5 方法: 类状态获取"></a>2.2.5 方法: 类状态获取</h3><p><code>objc_class</code>结构体中类的基本状态查询的函数代码如下。注意<code>Class getMeta()</code>获取元类时：对于元类，<code>getMeta()</code>返回的结果与<code>ISA()</code>返回的结果不相同，对于非元类，两者则是相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMetaClass</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> superclass == nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRealized</span>()  ||  <span class="built_in">isFuture</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)<span class="built_in">data</span>())-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">demangledName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-方法-内存分配"><a href="#2-2-6-方法-内存分配" class="headerlink" title="2.2.6 方法: 内存分配"></a>2.2.6 方法: 内存分配</h3><p>根据类的信息构建对象时，需要根据类的继承链上的所有成员变量的内存布局为成员变量数据分配内存空间，分配内存空间的大小固定的，并按 WORD 对齐，调用<code>size_t class_getInstanceSize(Class cls)</code>实际是调用了<code>objc_class</code>结构体的<code>uint32_t alignedInstanceSize()</code>函数。</p><p>成员变量在实例内存空间中偏移量同样也是固定的，同样也是按 WORD 对齐。实例的第一个成员变量内存空间的在实例空间中的偏移量，实际是通过调用<code>objc_class</code>结构体的<code>uint32_t alignedInstanceStart()</code>函数获取。</p><p><code>objc_class</code>结构体中涉及内存分配的函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类的实例的成员变量起始地址可能不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例的成员变量起始地址按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的实例大小可能因为ivar的alignment值而不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes. （TODO：不懂为啥）</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="keyword">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">if</span> (newSize != <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(&amp;<span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        bits.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-class-rw-t"><a href="#2-3-class-rw-t" class="headerlink" title="2.3 class_rw_t"></a>2.3 class_rw_t</h2><p>类的主要数据保存在<code>bits</code>中，<code>bits</code>以位图保存<code>class_rw_t</code>结构体，用于记录类的关键数据，如成员变量列表、方法列表、属性列表、协议列表等等，<code>class_rw_t</code>仅包含三个基本的位操作方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;       <span class="comment">// 标记类的状态;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;     <span class="comment">// 标记类的类型，0表示类为非元类，7表示类为元类；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro; <span class="comment">// 保存类的只读数据，注册类后ro中的数据标记为只读，成员变量列表保存在ro中；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_array_t</span> methods;      <span class="comment">// 方法列表，其类型method_array_t  为二维数组容器；</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">// 属性列表，其类型property_array_t为二维数组容器；</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;  <span class="comment">// 协议列表，其类型protocol_array_t为二维数组容器；</span></span><br><span class="line">    </span><br><span class="line">    Class firstSubclass;    <span class="comment">// 类的首个子类，与nextSiblingClass记录所有类的继承链组织成的继承树；</span></span><br><span class="line">    Class nextSiblingClass; <span class="comment">// 类的下一个兄弟类；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *demangledName;    <span class="comment">// 类名，来自Swift的类会包含一些特别前缀，demangledName是处理后的类名；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;      <span class="comment">// 标记类的对象的isa是否为index类型；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置set指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">uint32_t</span> set)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicOr32Barrier</span>(set, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearFlags</span><span class="params">(<span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicXor32Barrier</span>(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置set指定的位，清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlags</span><span class="params">(<span class="keyword">uint32_t</span> set, <span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | set) &amp; ~clear;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">OSAtomicCompareAndSwap32Barrier</span>(oldf, newf, (<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-class-ro-t"><a href="#2-4-class-ro-t" class="headerlink" title="2.4 class_ro_t"></a>2.4 class_ro_t</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标记类的状态。需要注意class_ro_t的flags的值和前面介绍的class_rw_t的flags的值是完全不同的；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart; <span class="comment">// 类的成员变量，在实例的内存空间中的起始偏移量；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// 类的实例占用的内存空间大小；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;     <span class="comment">// strong成员变量内存布局。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;              <span class="comment">// 类名；</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 基础方法列表，在类定义时指定的方法列表；</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;<span class="comment">// 协议列表；</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;      <span class="comment">// 成员变量列表；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; <span class="comment">// weak成员变量布局；</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;<span class="comment">// 基础属性列表，在类定义时指定的属性列表；</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_ro_t</span> *<span class="title">duplicate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>) + <span class="built_in"><span class="keyword">sizeof</span></span>(_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-ivarLayout与weakIvarLayout"><a href="#2-4-1-ivarLayout与weakIvarLayout" class="headerlink" title="2.4.1 ivarLayout与weakIvarLayout"></a>2.4.1 ivarLayout与weakIvarLayout</h3><h4 id="1-值的存储格式"><a href="#1-值的存储格式" class="headerlink" title="1. 值的存储格式"></a>1. 值的存储格式</h4><p>ivarLayout 和 weakIvarLayout 这两个编码值，结合起来，就可以确定<strong>自上而下</strong>，哪些 ivar 是strong、weak，确定了这两种之后，剩余的就都是基本类型和 __unsafe_unretained 的对象类型。</p><p>这两者都是 <code>const uint8_t *</code> 类型，但读取值的时候，需要注意，不是以char(1字节)为单位来读取的，而是：</p><ul><li><strong>4bit为一位，1字节为一对</strong>，即<strong>从两者首地址开始，1字节分为一对</strong>来读取</li><li>以两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li></ul><p>ivarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 strong</strong> 成员变量、多少个 <strong>strong</strong> 成员变量…(<strong>循环</strong>)…直到最后一个strong出现的位置(后面的就不记录了)。</p><p>weakIvarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 weak</strong> 成员变量、多少个 <strong>weak</strong> 成员变量…(<strong>循环</strong>)…直到最后一个weak出现的位置(后面的就不记录了)。</p><h4 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h4><p>这两个值可以通过 runtime 提供的几个 API 来访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getWeakIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br></pre></td></tr></table></figure><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar5;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar6;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar7;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> ivv;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> ivv1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> uint8_t * strongLayout = class_getIvarLayout(Foo.class);</span><br><span class="line"><span class="keyword">const</span> uint8_t * weakLayout = class_getWeakIvarLayout(Foo.class);</span><br><span class="line"></span><br><span class="line">(lldb) p strongLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">0</span> = <span class="number">0x000000010d6c1246</span> <span class="string">&quot;\U00000011!#&quot;</span></span><br><span class="line">(lldb) p weakLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">1</span> = <span class="number">0x000000010d6c124a</span> <span class="string">&quot;\U00000001!\U000000121&quot;</span></span><br><span class="line">(lldb) x/<span class="number">4</span>xb $<span class="number">0</span></span><br><span class="line"><span class="number">0x10d6c1246</span>: <span class="number">0x11</span> <span class="number">0x21</span> <span class="number">0x23</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x11: 1个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x21: 2个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x23: 2个非strong、3个strong （后面还有个weak就不记录了）</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">(lldb) x/<span class="number">5</span>xb $<span class="number">1</span></span><br><span class="line"><span class="number">0x10d6c124a</span>: <span class="number">0x01</span> <span class="number">0x21</span> <span class="number">0x12</span> <span class="number">0x31</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x01: 0个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x21: 2个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x12: 1个非weak、2个weak</span></span><br><span class="line"><span class="comment">   0x31: 3个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><p><a href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">原文链接：Objective-C Class Ivar Layout 探索</a></p><p>当我们定义一个类的实例变量的时候，可以指定其修饰符：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> _gayFriend; <span class="comment">// 无修饰符的对象默认会加 __strong</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> _girlFriend;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> _company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。</p><p>那么问题来了，假如这个类是动态生成的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure><p>该如何像上面一样来添加 ivar 的属性修饰符呢？假如依次设置strong、weak、strong修饰符</p><p>第一步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在objc_registerClassPair(class);前加上这么两句</span></span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br></pre></td></tr></table></figure><p>第二步：</p><p>此时，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixup_class_arc</span><span class="params">(Class class)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Class isa;</span><br><span class="line">        Class superclass;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">void</span> *_buckets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint32_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint32_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint16_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; cache;</span><br><span class="line">        <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    &#125; *objcClass = (__bridge <span class="built_in">typeof</span>(objcClass))class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        <span class="keyword">uint32_t</span> version;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        &#125; *ro;</span><br><span class="line">    &#125; *objcRWClass = (<span class="built_in">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARR 1&lt;&lt;7    </span></span><br><span class="line">    objcRWClass-&gt;ro-&gt;flags |= RO_IS_ARR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了。</p><p>完整的示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br><span class="line">fixup_class_arc(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> sark = [<span class="keyword">class</span> new];</span><br><span class="line">Ivar strongIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>);</span><br><span class="line">Ivar weakIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>);</span><br><span class="line">Ivar strongIvar2 = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> boy = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> girl = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> boy2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    object_setIvar(sark, strongIvar, boy);</span><br><span class="line">    object_setIvar(sark, weakIvar, girl);</span><br><span class="line">    object_setIvar(sark, strongIvar2, boy2);</span><br><span class="line">&#125; <span class="comment">// ARC 在这里会对大括号内的 girl、boy、boy2 做一次release</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@, %@&quot;</span>, object_getIvar(sark, strongIvar),  <span class="comment">//&lt;NSObject: 0x600000934660&gt;</span></span><br><span class="line">                     object_getIvar(sark, weakIvar),    <span class="comment">//nil</span></span><br><span class="line">                     object_getIvar(sark, strongIvar2));<span class="comment">//&lt;NSObject: 0x6000009346a0&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-几点总结"><a href="#2-4-2-几点总结" class="headerlink" title="2.4.2 几点总结"></a>2.4.2 几点总结</h3><ul><li>property在编译期会生成 _propertyName 的ivar，和相应的get/set方法。</li><li>ivars在编译期确定，但不完全确定，offset属性在运行时会修改。</li><li>对象的大小是由ivars决定的，当有继承体系时，父类的ivars永远放在子类之前。</li><li>class_ro_t 的 instanceStart 和 instanceSize 会在运行时调整。</li><li>class_ro_t 的 ivarLayout 和 weakIvarLayout 存放的是强ivar和弱ivar的存储规则。</li></ul><h2 id="2-5-元类-Meta-Class"><a href="#2-5-元类-Meta-Class" class="headerlink" title="2.5 元类(Meta Class)"></a>2.5 元类(Meta Class)</h2><h3 id="2-5-1-为什么存在元类？"><a href="#2-5-1-为什么存在元类？" class="headerlink" title="2.5.1 为什么存在元类？"></a>2.5.1 为什么存在元类？</h3><p><strong>在调用类方法的时候，为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</strong></p><ul><li>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</li><li>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</li></ul><p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有自己独一无二的meta-class，因为每个类的类方法基本不可能完全相同。</p><blockquote><p>以下元类的相关内容，都来自 <a href="https://link.jianshu.com/?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a> 这篇文章。</p></blockquote><h3 id="2-5-2-元类的isa-—-类"><a href="#2-5-2-元类的isa-—-类" class="headerlink" title="2.5.2 元类的isa — 类"></a>2.5.2 元类的isa — 类</h3><p>元类，和类的结构是一样的 objc_class，所以也是一个对象。这表示你能够对元类调用方法。自然的，这表示它必须也有一个类指针。</p><ul><li>类创建对象，调用的是实例方法</li><li>元类创建类对象，调用的是类方法。</li></ul><p>所有元类使用基类的元类（即继承链顶端的类的元类）作为它们的类，而所有类的基类都是 NSObject（大多数类是这样的），所以大多数元类使用 NSObject 的元类作为它的类。</p><p>根据规则所有元类使用基类的元类作为它们的类，那么基类的元类就是它自己的类（它们的isa指针指向了自己）。这表明NSObject的元类的指针指向的是它自己（它是一个它自己的实例）。</p><h3 id="2-5-3-元类的superclass-—-父类"><a href="#2-5-3-元类的superclass-—-父类" class="headerlink" title="2.5.3 元类的superclass — 父类"></a>2.5.3 元类的superclass — 父类</h3><p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。</p><p>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己 (<strong>NSObject-&gt;isa-&gt;superclass = NSObject</strong>)。</p><p>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p><h3 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4 总结"></a>2.5.4 总结</h3><p>所有这些用文字描述起来可能比较容易让人困惑。<a href="https://link.jianshu.com/?t=http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Greg Parker的文章</a>中有一张附图描述了实例、类和元类以及他们的super class是如何完美的共存的。</p><img src="/images/runtime/01.png" alt="01" style="zoom:85%;" /><p>可以看到，所有的meta class 与 Root class 的 isa 都指向 Root class 的meta class，这样能够形成一个闭环。</p><p>实现了：</p><ul><li>所有 NSObject 的实例方法，都能够被 <strong>任何实例、类、元类</strong> 来使用；</li><li>所有 NSObject 的类方法，都能够被 <strong>任何类、元类</strong> 来使用。</li></ul><p>即实现了<strong>Objc中的任意 objc_object 对象，都继承自NSObject。NSObject为所有的对象定义了一些相同的特性</strong>。</p><h2 id="2-6-类与对象操作函数"><a href="#2-6-类与对象操作函数" class="headerlink" title="2.6 类与对象操作函数"></a>2.6 类与对象操作函数</h2><p>runtime有很多的函数可以操作类和对象。通常，操作类的是class为前缀，操作对象的是objc或object_为前缀(因为class也是一种Object，所以有的objc或object为前缀的函数也可以操作类对象)。</p><h3 id="2-6-1-类型获取和判断函数"><a href="#2-6-1-类型获取和判断函数" class="headerlink" title="2.6.1 类型获取和判断函数"></a>2.6.1 类型获取和判断函数</h3><h4 id="1-类型获取"><a href="#1-类型获取" class="headerlink" title="1. 类型获取"></a>1. 类型获取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  传入字符串类名，返回对应的类对象</span></span><br><span class="line"><span class="comment">  Return the id of the named class.  If the class does not exist, call _objc_classLoader and then objc_classHandler, either of which may create a new class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">look_up_class</span>(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 传入的obj可能是instance对象、class对象、meta-class对象</span></span><br><span class="line"><span class="comment"> 返回:</span></span><br><span class="line"><span class="comment">  a) 如果是instance对象，返回class对象</span></span><br><span class="line"><span class="comment">  b) 如果是class对象，返回meta-class对象</span></span><br><span class="line"><span class="comment">  c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回的就是类对象</span></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">&#125;</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类型判断"><a href="#2-类型判断" class="headerlink" title="2. 类型判断"></a>2. 类型判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类</span></span><br><span class="line"><span class="comment">    id person = [[MJPerson alloc] init];</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[NSObject class]]);  // 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:object_getClass([MJPerson class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:[NSObject class]]); // 0 类对象的类怎么可能还是class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类、或者cls子类</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[NSObject class]]);  // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls、或者cls子类。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:object_getClass([NSObject class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[NSObject class]]); // 1 特殊的NSObject，NSObject是所有元类的最顶部父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="built_in">object_getClass</span>((id)self); tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-判断是否是元类"><a href="#3-判断是否是元类" class="headerlink" title="3. 判断是否是元类"></a>3. 判断是否是元类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-类相关操作函数"><a href="#2-6-2-类相关操作函数" class="headerlink" title="2.6.2 类相关操作函数"></a>2.6.2 类相关操作函数</h3><h4 id="1-获取name"><a href="#1-获取name" class="headerlink" title="1. 获取name"></a>1. 获取name</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getName</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span>;</span><br><span class="line">    <span class="comment">// fixme lldb calls class_getName() on unrealized classes (rdar://27258517)</span></span><br><span class="line">    <span class="comment">// ASSERT(cls-&gt;isRealized()  ||  cls-&gt;isFuture());</span></span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">demangledName</span>(<span class="comment">/* needs lock */</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>名字修饰</strong>（name decoration），也称为<strong>名字重整</strong>、<strong>名字改编</strong>（name mangling），是现代计算机程序设计语言的编译器用于解决由于程序实体的名字必须唯一而导致的问题的一种技术。</p><p>demangledName: 去除修饰的名称。</p></blockquote><h4 id="2-获取super-class"><a href="#2-获取super-class" class="headerlink" title="2. 获取super_class"></a>2. 获取super_class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-获取instance-size"><a href="#3-获取instance-size" class="headerlink" title="3. 获取instance_size"></a>3. 获取instance_size</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">alignedInstanceSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-成员变量-ivars-操作"><a href="#4-成员变量-ivars-操作" class="headerlink" title="4. 成员变量(ivars)操作"></a>4. 成员变量(ivars)操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !name) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> _class_getVariable(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getInstanceVariable</span>(cls-&gt;<span class="built_in">ISA</span>(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量(这个只能够向在runtime时创建的类添加成员变量)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint8_t</span> alignment, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取整个成员变量列表(必须使用free()来释放这个数组)</span></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h4 id="5-方法操作"><a href="#5-方法操作" class="headerlink" title="5. 方法操作"></a>5. 方法操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法。注意：如果这个类中没有实现selector这个方法，会沿着继承链向上找到为止，即可能会返回它某父类中的Method对象</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span> <span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span> <span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function">Method * <span class="title">class_copyMethodList</span> <span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法. 和成员变量不同的是可以为类动态添加方法。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  class_addMethod可以添加父类中方法实现的override，但不会替换该类中的现有实现。</span></span><br><span class="line"><span class="comment">  如果已有同名的方法实现（包含分类中的方法）会返回NO。要更改现有的实现，请使用method_setImplementation。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替代方法的实现。返回cls标识的类中，name标识的方法的以前实现。</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果通过名称标识的方法还不存在(本类、分类中都没实现)，就会像调用class_addMethod一样添加它。使用由types指定的类型编码。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回：NULL</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果通过名称标识的方法确实存在(本类或分类中实现了)，那么它的IMP将被替换，就像调用了method_setImplementation一样。类型指定的类型编码将被忽略。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回：SEL name之前的实现IMP</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回方法的具体实现</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation_stret</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_respondsToSelector</span><span class="params">(Class cls, SEL sel)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="6-协议操作"><a href="#6-协议操作" class="headerlink" title="6. 协议操作"></a>6. 协议操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span><span class="params">(Class cls, Protocol *protocol_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span><span class="params">(Class cls, Protocol *proto_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line"><span class="function">Protocol * <span class="title">class_copyProtocolList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-获取版本号"><a href="#7-获取版本号" class="headerlink" title="7. 获取版本号"></a>7. 获取版本号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号 0表示类为非元类，7表示类为元类；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">data</span>()-&gt;version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-示例"><a href="#8-示例" class="headerlink" title="8. 示例"></a>8. 示例</h4><p>通过示例来消化下上面的那些函数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</span><br><span class="line"><span class="built_in">NSInteger</span> _instance1;</span><br><span class="line"><span class="built_in">NSString</span> * _instance2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;call method method1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123; &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 : %ld, arg2 : %@&quot;</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// main.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MySubClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">          MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">          Class cls = myClass.class;</span><br><span class="line">          <span class="comment">// 类名</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));    </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 父类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;super class name: %s&quot;</span>, class_getName(class_getSuperclass(cls)));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 是否是元类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is %@ a meta-class&quot;</span>, (class_isMetaClass(cls) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot;not&quot;</span>));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&#x27;s meta-class is %s&quot;</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 变量实例大小</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;instance size: %zu&quot;</span>, class_getInstanceSize(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 成员变量</span></span><br><span class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Ivar ivar = ivars[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instance variable&#x27;s name: %s at index: %d&quot;</span>, ivar_getName(ivar), i);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(ivars);</span><br><span class="line"></span><br><span class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">&quot;_string&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instace variable %s&quot;</span>, ivar_getName(string));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 属性操作</span></span><br><span class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               objc_property_t property = properties[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property&#x27;s name: %s&quot;</span>, property_getName(property));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(properties);</span><br><span class="line"></span><br><span class="line">          objc_property_t array = class_getProperty(cls, <span class="string">&quot;array&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property %s&quot;</span>, property_getName(array));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 方法操作</span></span><br><span class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Method method = methods[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method&#x27;s signature: %s&quot;</span>, method_getName(method));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(methods);</span><br><span class="line"></span><br><span class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method %s&quot;</span>, method_getName(method1));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</span><br><span class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;class method : %s&quot;</span>, method_getName(classMethod));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>);</span><br><span class="line"></span><br><span class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          imp();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 协议</span></span><br><span class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">          Protocol * protocol;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               protocol = protocols[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;protocol name: %s&quot;</span>, protocol_getName(protocol));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsed to protocol %s&quot;</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>, protocol_getName(protocol));</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.452</span> RuntimeTest <span class="keyword">class</span> name: MyClass</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.453</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest <span class="keyword">super</span> <span class="keyword">class</span> name: <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass is not a meta-<span class="keyword">class</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass<span class="string">&#x27;s meta-class is MyClass</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance size: 48</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _instance1 at index: <span class="number">0</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _instance2 at index: 1</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _array at index: <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _string at index: 3</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest instance variable&#x27;</span>s name: _integer at index: <span class="number">4</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest instace variable _string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest property<span class="string">&#x27;s name: array</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest property&#x27;</span>s name: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest property<span class="string">&#x27;s name: integer</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest property array</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest method<span class="string">&#x27;s signature: method2</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method3WithArg1:arg2:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: integer</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setInteger:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: array</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: setString:</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setArray:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest method<span class="string">&#x27;s signature: .cxx_destruct</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest method method1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest class method : classMethod1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest MyClass is responsd to selector: method3WithArg1:arg2:</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest call method method1</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest =====================================================</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCopying</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCoding</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest MyClass is responsed to protocol NSCoding</span></span><br><span class="line"><span class="string">19:41:37.468 RuntimeTest ======================================</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-动态创建类和对象"><a href="#2-6-3-动态创建类和对象" class="headerlink" title="2.6.3 动态创建类和对象"></a>2.6.3 动态创建类和对象</h3><h4 id="1-动态创建类"><a href="#1-动态创建类" class="headerlink" title="1. 动态创建类"></a>1. 动态创建类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个新类和元类。Creates a new class and metaclass.</span></span><br><span class="line"><span class="comment"> * @prama superclass 如果创建的是root class，则superclass为Nil</span></span><br><span class="line"><span class="comment"> * @prama sextraBytes 通常为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新类后，使用class_addMethod，class_addIvar函数为新类添加方法、实例变量和属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类。再之后就能够用了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类。在运行中还存在或存在子类实例，就不能够调用这个。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>问题：什么是”class pair（类对）”？函数 objc_allocateClassPair 只返回一个值：类。那么这个”class pair（类对）”的另一半呢？从方法注释可以看出来，是元类。</p></blockquote><p>使用示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">&quot;MySubClass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_addIvar(cls, <span class="string">&quot;_ivar1&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; <span class="string">&quot;V&quot;</span>, <span class="string">&quot;_ivar1&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty(cls, <span class="string">&quot;property2&quot;</span>, attrs, <span class="number">3</span>);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="2-动态创建对象"><a href="#2-动态创建对象" class="headerlink" title="2. 动态创建对象"></a>2. 动态创建对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例。会在heap里给类分配内存。这个方法和+alloc方法类似。</span></span><br><span class="line"><span class="function">id <span class="title">class_createInstance</span><span class="params">(Class cls, <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在指定位置创建类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在bytes所指向的位置创建cls的实例。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * bytes必须至少指向对齐的零填充内存的class_getInstanceSize(cls)字节。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 设置新对象的isa。调用任何c++构造函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果成功返回bytes。如果cls或bytes为nil，或c++构造函数失败，则返回nil。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 注意: class_createInstance()和class_createInstances()对此进行了预检。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_constructInstance</span><span class="params">(Class cls, <span class="keyword">void</span> *bytes)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 销毁实例而不释放内存。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 C++ 析构函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 ARC ivar 清理。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 移除除关联引用。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回obj。如果obj为nil，则什么都不做。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>; <span class="comment">//不会释放移除任何相关引用</span></span><br></pre></td></tr></table></figure><p>测试下效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></span><br><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></span><br><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</span><br></pre></td></tr></table></figure><h3 id="2-6-4-实例对象相关操作函数"><a href="#2-6-4-实例对象相关操作函数" class="headerlink" title="2.6.4 实例对象相关操作函数"></a>2.6.4 实例对象相关操作函数</h3><p>这些函数是针对创建的实例对象的一系列操作函数。</p><h4 id="1-操作-整个对象-的函数"><a href="#1-操作-整个对象-的函数" class="headerlink" title="1. 操作 整个对象 的函数"></a>1. 操作 整个对象 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="function">id <span class="title">object_copy</span><span class="params">(id oldObj, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span></span>;</span><br></pre></td></tr></table></figure><p>应用场景</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></span><br><span class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</span><br><span class="line">object_setClass(newB, MyClass.class);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure><h4 id="2-操作-对象的类-的函数"><a href="#2-操作-对象的类-的函数" class="headerlink" title="2. 操作 对象的类 的函数"></a>2. 操作 对象的类 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">object_getClassName</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-6-5-获取类定义"><a href="#2-6-5-获取类定义" class="headerlink" title="2.6.5 获取类定义"></a>2.6.5 获取类定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表。返回值为已注册类的总数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span><span class="params">(Class *buffer, <span class="keyword">int</span> bufferLen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span></span><br><span class="line"><span class="function">Class *<span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定类的类定义</span></span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>; <span class="comment">// 与objc_getClass相同，但如果没有找到类，则终止进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br></pre></td></tr></table></figure><p>演示如何使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numClasses;</span><br><span class="line">Class * classes = <span class="literal">NULL</span>;</span><br><span class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">     numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;number of classes: %d&quot;</span>, numClasses);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">          Class cls = classes[i];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));</span><br><span class="line">     &#125;</span><br><span class="line">     free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] number of classes: <span class="number">1282</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: DDTokenRegexp</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _PFRoutines</span><br><span class="line">......还有大量输出</span><br></pre></td></tr></table></figure><h1 id="三、成员变量、属性与关联对象"><a href="#三、成员变量、属性与关联对象" class="headerlink" title="三、成员变量、属性与关联对象"></a>三、成员变量、属性与关联对象</h1><h2 id="3-1-实例变量类型Ivar"><a href="#3-1-实例变量类型Ivar" class="headerlink" title="3.1 实例变量类型Ivar"></a>3.1 实例变量类型Ivar</h2><blockquote><p>实例变量是指在类的声明中，属性是用变量来表示的。 这种变量就称为实例变量，也叫对象变量、类成员变量；</p></blockquote><h3 id="3-1-1-Ivar结构"><a href="#3-1-1-Ivar结构" class="headerlink" title="3.1.1 Ivar结构"></a>3.1.1 Ivar结构</h3><p>Ivar是指向 ivar_t 结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">ivar_getOffset</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar ivar)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-Ivar的获取"><a href="#3-1-2-Ivar的获取" class="headerlink" title="3.1.2 Ivar的获取"></a>3.1.2 Ivar的获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-实例变量操作函数"><a href="#3-1-3-实例变量操作函数" class="headerlink" title="3.1.3 实例变量操作函数"></a>3.1.3 实例变量操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_setInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_getInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **value)</span></span>;</span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">object_getIndexedIvars</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对象中实例变量的值</span></span></span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-2-属性类型property-t"><a href="#3-2-属性类型property-t" class="headerlink" title="3.2 属性类型property_t"></a>3.2 属性类型property_t</h2><h3 id="3-2-1-property-t结构和objc-property-t"><a href="#3-2-1-property-t结构和objc-property-t" class="headerlink" title="3.2.1 property_t结构和objc_property_t"></a>3.2.1 property_t结构和objc_property_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">// property的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// property的属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure><p>属性attributes是一个字符串：该字符串以T开头，后面跟着@encode类型和一个逗号，以V结尾，后面跟着后台实例变量的名称。在这些属性之间，由以下描述符指定，以逗号分隔。官方文档 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24">Declared Properties</a>。</p><img src="/images/runtime/02.png" alt="02" style="zoom:90%;" /><p>获取name、attributes的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-property的获取"><a href="#3-2-2-property的获取" class="headerlink" title="3.2.2 property的获取"></a>3.2.2 property的获取</h3><p>获取类和协议的属性列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回一个包含类中声明的属性的堆块(heap block)，如果类没有声明属性，则返回nil。呼叫者必须释放区块。</span></span><br><span class="line"><span class="comment"> * 不复制任何超类的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">class_copyPropertyList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><p>通过给出的名称来在类和协议中获取属性的引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">class_getProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-property的特性attributes"><a href="#3-2-3-property的特性attributes" class="headerlink" title="3.2.3 property的特性attributes"></a>3.2.3 property的特性attributes</h3><p>objc_property_attribute_t也是结构体，定义属性的attribute</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">property_copyAttributeValue</span><span class="params">(<span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span></span>;</span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_attribute_t</span> *<span class="title">property_copyAttributeList</span><span class="params">(<span class="keyword">objc_property_t</span> prop, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-示例"><a href="#3-2-4-示例" class="headerlink" title="3.2.4 示例"></a>3.2.4 示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Lender : NSObject &#123;</span><br><span class="line">     <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line">@property <span class="keyword">float</span> alone;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性列表</span></span><br><span class="line">id LenderClass = <span class="built_in">objc_getClass</span>(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line"><span class="keyword">objc_property_t</span> *properties = <span class="built_in">class_copyPropertyList</span>(LenderClass, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, <span class="built_in">property_getName</span>(property), <span class="built_in">property_getAttributes</span>(property)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount2, j;</span><br><span class="line">    <span class="keyword">objc_property_attribute_t</span> * attries = <span class="built_in">property_copyAttributeList</span>(property, &amp;outCount2);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; outCount2; j++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_attribute_t</span> attr = attries[j];</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%s %s\n&quot;</span>, attr.name, attr.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">log: ======= alone Tf,V_alone</span><br><span class="line">log: ======= T f</span><br><span class="line">log: ======= V _alone</span><br></pre></td></tr></table></figure><h2 id="3-3-关联对象"><a href="#3-3-关联对象" class="headerlink" title="3.3 关联对象"></a>3.3 关联对象</h2><p>关联对象是在运行时添加的类似成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置对象 的一个关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取对象 指定的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//移除对象 所有关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="built_in"><span class="keyword">void</span></span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">     UITapGestureRecognizer *gesture = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!gesture)</span><br><span class="line">     &#123;</span><br><span class="line">          gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@<span class="built_in">selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">          [self addGestureRecognizer:gesture];</span><br><span class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></span><br><span class="line">          <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手势识别对象的target和action</span></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (gesture.state == UIGestureRecognizerStateRecognized)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in"><span class="keyword">void</span></span>(^action)(<span class="keyword">void</span>) = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (action)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">action</span>();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Method和消息"><a href="#四、Method和消息" class="headerlink" title="四、Method和消息"></a>四、Method和消息</h1><h2 id="4-1-method-t、SEL和IMP"><a href="#4-1-method-t、SEL和IMP" class="headerlink" title="4.1 method_t、SEL和IMP"></a>4.1 method_t、SEL和IMP</h2><h3 id="4-1-1-method-t结构和Method"><a href="#4-1-1-method-t结构和Method" class="headerlink" title="4.1.1 method_t结构和Method"></a>4.1.1 method_t结构和Method</h3><p>method_t结构，用于表示类定义中的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 编码，是个char指针，存储着方法的返回值类型、参数类型</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向函数实现的指针(函数地址)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure><p>iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   v16@0:8</span></span><br><span class="line"><span class="comment">   v - 返回值void</span></span><br><span class="line"><span class="comment">   @ - 参数1: id self</span></span><br><span class="line"><span class="comment">   : - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)test:(<span class="keyword">int</span>)age height:(<span class="keyword">float</span>)height;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   i24@0:8i16f20</span></span><br><span class="line"><span class="comment">   i  - 返回值</span></span><br><span class="line"><span class="comment">   24 - 表示接下来的参数总共占多少个字节</span></span><br><span class="line"><span class="comment">   @  - 参数1: id self</span></span><br><span class="line"><span class="comment">   0  - 对应参数1，表示参数1的数据是从第几个字节开始的。后面的8 16 20分别对应参数234对应的开始位置</span></span><br><span class="line"><span class="comment">   :  - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">   i  - 参数3: int</span></span><br><span class="line"><span class="comment">   f  - 参数4: float</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-SEL"><a href="#4-1-2-SEL" class="headerlink" title="4.1.2 SEL"></a>4.1.2 SEL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似.(可以简单的理解为是个字符串).</span></span><br><span class="line">  <span class="comment">// 可以通过@selector()和sel_registerName()获得.</span></span><br><span class="line">  <span class="comment">// 可以通过sel_getName()和NSStringFromSelector()转成字符串.</span></span><br><span class="line">  <span class="comment">// 不同类中相同名字的方法，所对应的方法选择器是相同的.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></span><br><span class="line">SEL sel1 = @<span class="built_in">selector</span>(load);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;sel : %p&quot;</span>, sel1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52</span>:<span class="number">46</span>] sel : <span class="number">0x7fff606203c3</span></span><br></pre></td></tr></table></figure><h3 id="4-1-3-IMP"><a href="#4-1-3-IMP" class="headerlink" title="4.1.3 IMP"></a>4.1.3 IMP</h3><p>是函数指针，指向方法的首地址，得到了IMP，就可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMP代表函数的具体实现</span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure><h2 id="4-2-Method相关操作函数"><a href="#4-2-Method相关操作函数" class="headerlink" title="4.2 Method相关操作函数"></a>4.2 Method相关操作函数</h2><h3 id="4-2-1-获取Method的信息"><a href="#4-2-1-获取Method的信息" class="headerlink" title="4.2.1 获取Method的信息"></a>4.2.1 获取Method的信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法名。如果希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串：通过引用返回，这种参数又称为传出参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getReturnType</span><span class="params">(Method m, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串：通过引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">method_getDescription</span><span class="params">(Method m)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-获取和设置Method的IMP"><a href="#4-2-2-获取和设置Method的IMP" class="headerlink" title="4.2.2 获取和设置Method的IMP"></a>4.2.2 获取和设置Method的IMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span>;</span><br></pre></td></tr></table></figure><p>NSObject提供了一个methodForSelector:方法可以获得Method的IMP指针，通过指针调用实现代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel;</span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel;</span><br><span class="line">- (IMP)methodForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-3-直接调用Method"><a href="#4-2-3-直接调用Method" class="headerlink" title="4.2.3 直接调用Method"></a>4.2.3 直接调用Method</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></span><br><span class="line"><span class="function">id <span class="title">method_invoke</span><span class="params">(id receiver, Method m, ... )</span></span>;</span><br><span class="line"><span class="comment">// 调用 (返回一个数据结构的) 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_invoke_stret</span><span class="params">(id receiver, Method m, ...)</span> </span></span><br></pre></td></tr></table></figure><h3 id="4-2-4-SEL的操作函数"><a href="#4-2-4-SEL的操作函数" class="headerlink" title="4.2.4 SEL的操作函数"></a>4.2.4 SEL的操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_getUid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="function">BOOL <span class="title">sel_isEqual</span><span class="params">(SEL lhs, SEL rhs)</span></span>; <span class="comment">// Lhs --&gt; Left Hand Side，也就是算式左边的意思</span></span><br></pre></td></tr></table></figure><h2 id="4-3-Method调用流程objc-msgSend"><a href="#4-3-Method调用流程objc-msgSend" class="headerlink" title="4.3 Method调用流程objc_msgSend"></a>4.3 Method调用流程objc_msgSend</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。</p><p>OC中的方法调用，其实都是转换为下面几个函数的调用。编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。</p><ul><li>如果是传递给超类就会调用带super的函数；</li><li>如果返回是数据结构而不是一个值就会调用带stret的函数；</li><li>在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将消息接收者和方法名(选择器)作为基础参数。</span></span><br><span class="line">   <span class="comment">// 使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入</span></span><br><span class="line">   <span class="comment">// 还有方法选择器</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span></span><br></pre></td></tr></table></figure><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>objc_msgSend的执行流程可以分为3大阶段：消息发送、动态方法解析、消息转发</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息发送阶段</span></span><br><span class="line"><span class="comment">//在objc-msg-arm64.s中</span></span><br><span class="line">▼ _objc_msgSend</span><br><span class="line">  ▼ CacheLookup  <span class="comment">// 缓存查找</span></span><br><span class="line">    ▼ CheckMiss <span class="comment">// 如果缓存没有命中</span></span><br><span class="line">      ▼ __objc_msgSend_uncached</span><br><span class="line">        ▼ MethodTableLookup</span><br><span class="line">        <span class="comment">// 其中有一行 bl __class_lookupMethodAndLoadCache3. 此时在objc-msg-arm64.s已经查不到该方法了。前缀减去</span></span><br><span class="line">        <span class="comment">// 一个_（符号修饰）然后全局搜索，可以在objc-runtime-new.mm中找到该方法_class_lookupMethodAndLoadCache3</span></span><br><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line">  ▼ _class_lookupMethodAndLoadCache3</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   // 仅用于汇编中的方法查找。其他代码应该使用lookUpImp()。这种查找避免了乐观的缓存扫描，因为汇编中已经尝试过。</span></span><br><span class="line"><span class="comment">   IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;</span></span><br><span class="line"><span class="comment">        // NO是cache. cache==NO跳过乐观的解锁查找(但在其他地方使用缓存);</span></span><br><span class="line"><span class="comment">          return lookUpImpOrForward(cls, sel, obj, YES, NO, YES);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ▼ lookUpImpOrForward</span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找当前类的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找当前类的methods</span></span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找父类(父类的父类...)的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找父类(父类的父类...)的methods</span></span><br><span class="line">        ▼ search_method_list</span><br><span class="line">          ▶ findMethodInSortedMethodList  <span class="comment">//若有序，二分查找</span></span><br><span class="line">          ▶ <span class="comment">//若无序，线性查找</span></span><br><span class="line">      ▼ log_and_fill_cache  <span class="comment">// 不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存</span></span><br><span class="line">        ▼ cache_fill</span><br><span class="line">          ▶ cache_fill_nolock</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 动态方法解析</span></span><br><span class="line">      ▼ _class_resolveMethod      <span class="comment">// 动态方法解析. 在运行时(动态)向特定类添加特定方法实现。</span></span><br><span class="line">        ▶ _class_resolveClassMethod    <span class="comment">// 如果是元类对象，调用类的该类方法(需要自己实现)，在该方法中，将要调用的方法添加到class/meta-class中。见MJPerson.m</span></span><br><span class="line">        ▶ _class_resolveInstanceMethod <span class="comment">// 如果是类对象，同上...</span></span><br><span class="line">        <span class="comment">//..动态解析过后，会重新走“消息发送”的流程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息转发</span></span><br><span class="line">      ▶ _objc_msgForward_impcache <span class="comment">// 消息转发. No implementation found, and method resolver didn&#x27;t help. Use forwarding.</span></span><br></pre></td></tr></table></figure><p>大致流程图如下：</p><img src="/images/runtime/03.png" alt="03" style="zoom:80%;" /><h3 id="4-3-1-消息发送"><a href="#4-3-1-消息发送" class="headerlink" title="4.3.1 消息发送"></a>4.3.1 消息发送</h3><ul><li>消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行</li><li>没找到就在分发列表里查找方法的selector</li><li>没找到就通过objc_class结构体中指向父类的指针找到父类，然后在父类分发列表找</li><li>直到root class（NSObject）</li></ul><p>如果root class仍然找不到方法，不会直接报错，会进入以下两个补救阶段。不过安全起见，一些场景中，可以先添加方法能否响应的判断：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</span><br><span class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-动态方法解析"><a href="#4-3-2-动态方法解析" class="headerlink" title="4.3.2 动态方法解析"></a>4.3.2 动态方法解析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %p&quot;</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@&quot;method1&quot;</span>]) &#123;</span><br><span class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">&quot;@:&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。</span></span><br><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果是对象方法找不到，动态方法解析 会调用+(BOOL)resolveInstanceMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> 如果是类方法找不到， 动态方法解析 会调用+(BOOL)resolveClassMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></span><br><span class="line">        <span class="comment">// 最后用class_addMethod完成添加特定方法实现的操作</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-3-消息转发"><a href="#4-3-3-消息转发" class="headerlink" title="4.3.3 消息转发"></a>4.3.3 消息转发</h3><h4 id="1-重定向接收者"><a href="#1-重定向接收者" class="headerlink" title="1. 重定向接收者"></a>1. 重定向接收者</h4><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这个方法通常在对象内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实例方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 将消息转发给alternateObject来处理</span></span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">          <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是类方法</span></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">   <span class="comment">// 这个return，不仅限于类对象，也可以是实例对象，前提是这个实例对象有名为aSelector的实例方法。因为前面已经说了，底层代码得到return的对象后，就会调用objc_msgSend，如果返回的实例对象，就相当于objc_msgSend(obj, @selector(test))，最后是能完成消息发送的</span></span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-最后进行转发"><a href="#2-最后进行转发" class="headerlink" title="2. 最后进行转发"></a>2. 最后进行转发</h4><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。如果没有实现，或者返回nil，消息转发结束。</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure><p>范例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:_helper];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-消息转发和多继承"><a href="#4-3-4-消息转发和多继承" class="headerlink" title="4.3.4 消息转发和多继承"></a>4.3.4 消息转发和多继承</h3><p>OC是否支持多继承？有没有模拟多继承特性的办法？</p><p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p><p>消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p><p>虽然转发可以实现继承功能，但是NSObject还是必须表面上很严谨，像<code>respondsToSelector:</code>和<code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。</p><h3 id="4-3-5-Message消息的参考文章"><a href="#4-3-5-Message消息的参考文章" class="headerlink" title="4.3.5 Message消息的参考文章"></a>4.3.5 Message消息的参考文章</h3><ul><li><a href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html">Message forwarding</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html">objectivec messaging</a></li><li><a href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html">The faster objc_msgSend</a></li></ul><h2 id="4-4-super和objc-msgSendSuper"><a href="#4-4-super和objc-msgSendSuper" class="headerlink" title="4.4 super和objc_msgSendSuper"></a>4.4 super和objc_msgSendSuper</h2><p><code>NSStringFromClass([self class])</code> 和 <code>NSStringFromClass([super class])</code> 输出都是self的类名。原因如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[super message]的底层实现:</span></span><br><span class="line"><span class="comment">//super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></span><br><span class="line">         id receiver;         <span class="comment">// receiver是self，表示消息接收者仍然是子类对象</span></span><br><span class="line">         Class current_class; <span class="comment">// 会从父类current_class.superclass开始查找方法的实现</span></span><br><span class="line">     &#125;;</span><br><span class="line">     SEL</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param super 指向objc_super数据结构的指针。传递消息发送的上下文的值，包括要接收消息的类的实例和开始搜索方法实现的超类。including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由此可知，消息仍然是receiver来处理，superclass指定了`消息发送`阶段，方法从isa-&gt;superclass-&gt;superclass.superclass...-&gt;NSObject链中superclass为起点开始向上寻找。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param op SEL类型的指针。传递将处理消息的方法的选择器。</span></span><br><span class="line"><span class="comment"> * @param ... A variable argument list containing the arguments to the method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return The return value of the method identified by \e op.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see objc_msgSend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper2</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>结论：super只是改变了方法查找链的起始位置，调用者是不变的。</p><h2 id="4-5-Method-Swizzling"><a href="#4-5-Method-Swizzling" class="headerlink" title="4.5 Method Swizzling"></a>4.5 Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p><h3 id="4-5-1-使用method-swizzling需要注意的问题"><a href="#4-5-1-使用method-swizzling需要注意的问题" class="headerlink" title="4.5.1 使用method swizzling需要注意的问题"></a>4.5.1 使用method swizzling需要注意的问题</h3><ul><li><p><strong>Swizzling应该总在+load中执行</strong>：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载。</p><ul><li>Swizzling在+load中执行时，不要调用[super load]。原因同下面一条，如果是多继承，并且对同一个方法都进行了Swizzling（<em>没有在dispatch_once中执行</em>），那么调用[super load]以后，父类的Swizzling就失效了。</li></ul></li><li><p><strong>Swizzling应该总是在dispatch_once中执行</strong>：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。</p><ul><li>如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！</li></ul></li><li><p><strong>Swizzling时，需要注意class_getInstanceMethod的特性</strong>：该方法的实现中，如果这个类中没有实现selector这个方法，那么它会沿着继承链找到为止，即其可能返回的是它某父类的Method对象。所以提前判断很重要，避免错误的交换了父类中的方法。</p></li><li><p>交换的分类方法应尽量调用原实现。</p><ul><li>很多情况我们不清楚被交换的的方法具体做了什么内部逻辑，而且很多被交换的方法都是系统封装的方法，所以为了保证其逻辑性都应该在分类的交换方法中去调用原被交换方法。</li><li>注意：调用时方法交换已经完成，在分类方法中应该调用分类方法本身才正确。</li><li>作用：比如之前a应该和b互换了方法，c方法在不知情的状况下和a互换了方法。只有在交换的方法中调用原实现，才能保证c→b→a中的代码都能得到执行。</li></ul></li></ul><h3 id="4-5-2-实现一"><a href="#4-5-2-实现一" class="headerlink" title="4.5.2 实现一"></a>4.5.2 实现一</h3><p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">          <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></span><br><span class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line"></span><br><span class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">               originalSelector,</span><br><span class="line">               method_getImplementation(swizzledMethod),</span><br><span class="line">               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></span><br><span class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">               class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                    swizzledSelector,</span><br><span class="line">                    method_getImplementation(originalMethod),</span><br><span class="line">                    method_getTypeEncoding(originalMethod));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;viewWillAppear: %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>method_exchangeImplementations做的事情和如下代码是一样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = <span class="built_in">method_getImplementation</span>(m1);</span><br><span class="line">IMP imp2 = <span class="built_in">method_getImplementation</span>(m2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m1, imp2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m2, imp1);</span><br></pre></td></tr></table></figure><h3 id="4-5-3-实现二"><a href="#4-5-3-实现二" class="headerlink" title="4.5.3 实现二"></a>4.5.3 实现二</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(xxxx));</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(x_xxxxx));</span><br><span class="line">        <span class="comment">// 判断两个方法是不是空，本类和父类都找不到则直接return</span></span><br><span class="line">        <span class="keyword">if</span> (!originalMethod || !swizzledMethod) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 不管方法在不在本类，都执行class_addMethod方法，最后的结果是本类中两个方法都存在了，这样也不用管他们有没有被交换过。</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], method_getName(originalMethod), method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], method_getName(swizzledMethod), method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">// 交换，此时就不用再考虑本类父类的逻辑</span></span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-4-错误实现"><a href="#4-5-4-错误实现" class="headerlink" title="4.5.4 错误实现"></a>4.5.4 错误实现</h3><h4 id="1-不加判断直接exchange"><a href="#1-不加判断直接exchange" class="headerlink" title="1. 不加判断直接exchange"></a>1. 不加判断直接exchange</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Base</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)basePrint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Base</span></span></span><br><span class="line">- (<span class="keyword">void</span>)basePrint&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">Base</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)APrint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    Class cls = [B <span class="keyword">class</span>];</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(basePrint));</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(APrint));</span><br><span class="line">    <span class="comment">//这种不加判断的交换是不合理的。直接将父类的方法实现交换了</span></span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)APrint&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="2-错误使用class-replaceMethod"><a href="#2-错误使用class-replaceMethod" class="headerlink" title="2. 错误使用class_replaceMethod"></a>2. 错误使用class_replaceMethod</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(xxxx));</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(x_xxxxx));</span><br><span class="line"><span class="comment">// ===== 错误一：如果本类中已有实现</span></span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                          method_getName(originalMethod),</span><br><span class="line">                          method_getImplementation(swizzledMethod),</span><br><span class="line">                          method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                          method_getName(swizzledMethod),</span><br><span class="line">                          <span class="comment">//此时originalMethod已经被replace imp了，即其imp，实际上已经是swizzledMethod的IMP了</span></span><br><span class="line">                          method_getImplementation(originalMethod), </span><br><span class="line">                          method_getTypeEncoding(originalMethod));</span><br><span class="line"><span class="comment">// ===== 错误二：如果本类中没有实现</span></span><br><span class="line">        <span class="comment">// 当cls中此时没有origSelector的实现时，那class_replaceMethod实质上是class_addMethod，返回值为NULL</span></span><br><span class="line">        IMP previousIMP = class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                                      method_getName(originalMethod),,</span><br><span class="line">                                      method_getImplementation(swizzledMethod),</span><br><span class="line">                                      method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">// 如果previousIMP，那么replaceMethod失败，即保持原样。</span></span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                            method_getName(swizzledMethod),,</span><br><span class="line">                            previousIMP,</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个关于Method Swizzling的资源可以参考</p><ul><li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?</a></li><li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li><li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec">What are the Dangers of Method Swizzling in Objective C?</a></li><li><a href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></li></ul><h1 id="五、Category和Protocol"><a href="#五、Category和Protocol" class="headerlink" title="五、Category和Protocol"></a>五、Category和Protocol</h1><h2 id="5-1-分类Category"><a href="#5-1-分类Category" class="headerlink" title="5.1 分类Category"></a>5.1 分类Category</h2><h3 id="5-1-1-分类概述"><a href="#5-1-1-分类概述" class="headerlink" title="5.1.1 分类概述"></a>5.1.1 分类概述</h3><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">1</a></p><ul><li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li><li>声明私有方法</li></ul><p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p><ul><li>模拟多继承</li><li>把framework的私有方法公开</li></ul><p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p><h3 id="5-1-2-category-t结构和Category"><a href="#5-1-2-category-t结构和Category" class="headerlink" title="5.1.2 category_t结构和Category"></a>5.1.2 category_t结构和Category</h3><p>指向分类的结构体的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;    <span class="comment">// 指向扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>     <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">// category中添加的所有属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></span><br></pre></td></tr></table></figure><p>从category的定义也可以看出category的：</p><ul><li>可为 (可以添加实例方法，类方法，甚至可以实现协议，添加属性(属性添加、使用，编译是能通过的，运行会crash))</li><li>不可为 (无法添加实例变量）<ul><li>编译后的类已经注册在runtime中，类结构体中的 ivars (实例变量的链表) 和 instance_size (实例变量的内存大小) 已经确定。</li><li>category_t 中并没有空间来存放类的成员变量Ivar。</li></ul></li></ul><p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数<code>_objc_init</code>就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，<code>_read_images</code>开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。</p><h3 id="5-1-3-示例：分类的编译"><a href="#5-1-3-示例：分类的编译" class="headerlink" title="5.1.3 示例：分类的编译"></a>5.1.3 示例：分类的编译</h3><p>Lender+TT.h</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender.h&quot;</span></span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * lxyname;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>Lender+TT.m</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender+TT.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用clang的命令去看看category到底会变成什么(主要是看一下分类中的属性底层是什么)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(_objc_method),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">&quot;test&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_I_Lender_TT_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">_prop_t</span>),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;<span class="string">&quot;lxyname&quot;</span>,<span class="string">&quot;T@\&quot;NSString\&quot;,&amp;,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">Lender</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Lender_</span>$_<span class="title">TT</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Lender&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Lender,</span></span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Lender_$_TT,  <span class="comment">//属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时期给分类结构的.cls赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Lender_$_TT(<span class="keyword">void</span> ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Lender_$_TT.cls = &amp;OBJC_CLASS_$_Lender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))=</span> &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到：</p><ol><li><p>首先编译器生成了实例方法列表 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT</code> 和属性列表 <code>_OBJC_$_PROP_LIST_Lender_$_TT</code>，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在 <code>TT</code> 这个category里面写的方法 <code>test</code>，而属性列表里面填充的也正是我们在 <code>TT</code> 里添加的 <code>lxyname</code> 属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p></li><li><p>其次，编译器生成了category本身 <code>_OBJC_$_CATEGORY_Lender_$_TT</code>，并用前面生成的列表来初始化category本身。</p></li><li><p>最后，编译器在<strong>DATA segment(段)下的objc_catlist section(节)</strong> 里保存了一个大小为1的category_t的数组<code>L_OBJC_LABEL_CATEGORY_$</code>（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。</p></li></ol><h3 id="5-1-4-分类的运行时处理"><a href="#5-1-4-分类的运行时处理" class="headerlink" title="5.1.4 分类的运行时处理"></a>5.1.4 分类的运行时处理</h3><p>见<a href="https://tenloy.github.io/2021/09/28/dyld-objc.html#4-2-loadAllCategories-%E5%88%86%E7%B1%BB%E5%8A%A0%E8%BD%BD">dyld与Objc—_objc_init、map_images、load_images的4.2小节：分类的加载</a></p><h2 id="5-2-类扩展-Extension"><a href="#5-2-类扩展-Extension" class="headerlink" title="5.2 类扩展(Extension)"></a>5.2 类扩展(Extension)</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>）</p><p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p><h2 id="5-3-Protocol"><a href="#5-3-Protocol" class="headerlink" title="5.3 Protocol"></a>5.3 Protocol</h2><p>Protocol其实就是一个对象结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Protocol</span>;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-操作函数"><a href="#5-4-操作函数" class="headerlink" title="5.4 操作函数"></a>5.4 操作函数</h2><h3 id="5-4-1-Category操作函数"><a href="#5-4-1-Category操作函数" class="headerlink" title="5.4.1 Category操作函数"></a>5.4.1 Category操作函数</h3><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试objc_class中的方法列表是否包含分类中的方法&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     Method method = methodList[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;RuntimeCategoryClass&#x27;s method: %s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;分类方法method2在objc_class的方法列表中&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.213</span> [<span class="number">561</span>:<span class="number">151847</span>] 测试objc_class中的方法列表是否包含分类中的方法</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] RuntimeCategoryClass<span class="string">&#x27;s method: method2</span></span><br><span class="line"><span class="string">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&#x27;</span>s method: method1</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] 分类方法method2在objc_class的方法列表中</span><br></pre></td></tr></table></figure><h3 id="5-4-2-Protocol操作函数"><a href="#5-4-2-Protocol操作函数" class="headerlink" title="5.4.2 Protocol操作函数"></a>5.4.2 Protocol操作函数</h3><p>Runtime提供了Protocol的一系列函数操作，函数包括：</p><h4 id="1-获取协议"><a href="#1-获取协议" class="headerlink" title="1. 获取协议"></a>1. 获取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_getProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line"><span class="function">Protocol **<span class="title">objc_copyProtocolList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-查询协议的信息"><a href="#2-查询协议的信息" class="headerlink" title="2. 查询协议的信息"></a>2. 查询协议的信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">protocol_getName</span><span class="params">(Protocol *proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_isEqual</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法描述数组</span></span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">protocol_copyMethodDescriptionList</span><span class="params">(Protocol *p, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   BOOL isRequiredMethod,BOOL isInstanceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="function">struct objc_method_description <span class="title">protocol_getMethodDescription</span><span class="params">(Protocol *p, SEL aSel, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *p, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"><span class="comment">// 获取协议遵守的协议</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">protocol_copyProtocolList</span><span class="params">(Protocol *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否遵守了另一个协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_conformsToProtocol</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-动态创建协议"><a href="#3-动态创建协议" class="headerlink" title="3. 动态创建协议"></a>3. 动态创建协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_allocateProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addMethodDescription</span><span class="params">(Protocol *proto_gen, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProperty</span><span class="params">(Protocol *proto_gen, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attrs, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加一个已注册的协议。proto必须正在构造中。addition则不能，必须是已注册的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProtocol</span><span class="params">(Protocol *proto, Protocol *addition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议。</span></span><br><span class="line"><span class="comment">// 创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerProtocol</span><span class="params">(Protocol *proto_gen)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="六、Block"><a href="#六、Block" class="headerlink" title="六、Block"></a>六、Block</h1><p>runtime中一些支持block操作的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@&quot;hello world!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</span><br></pre></td></tr></table></figure><h1 id="七、Runtime的应用"><a href="#七、Runtime的应用" class="headerlink" title="七、Runtime的应用"></a>七、Runtime的应用</h1><h2 id="7-1-获取系统提供的库相关信息"><a href="#7-1-获取系统提供的库相关信息" class="headerlink" title="7.1 获取系统提供的库相关信息"></a>7.1 获取系统提供的库相关信息</h2><p>主要函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的objectivec框架和动态库的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyImageNames</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getImageName</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyClassNamesForImage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure><p>示例：通过这些函数获取某个类所在的库，以及某个库中包含哪些类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定类所在动态库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;UIView&#x27;s Framework: %s&quot;</span>, <span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定库或框架中所有类的类名&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = <span class="built_in">objc_copyClassNamesForImage</span>(<span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)), &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(@<span class="string">&quot;class name: %s&quot;</span>, classes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.689</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] UIView<span class="number">&#x27;</span>s Framework: /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTopFrame</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIOnePartImageView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewSelectionBar</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerWheelView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTestParameters</span><br></pre></td></tr></table></figure><h2 id="7-2-对App的用户行为进行追踪"><a href="#7-2-对App的用户行为进行追踪" class="headerlink" title="7.2 对App的用户行为进行追踪"></a>7.2 对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来实现swizzle方法</span></span><br><span class="line"><span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></span><br><span class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></span><br><span class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (gOriginalViewDidAppear)(id, SEL, BOOL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newViewDidAppear</span><span class="params">(UIViewController *self, SEL _cmd, BOOL animated)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     <span class="built_in">gOriginalViewDidAppear</span>(self, _cmd, animated); <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     Method originalMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:));</span><br><span class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)<span class="built_in">method_getImplementation</span>(originalMethod);</span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">class_addMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:), (IMP) newViewDidAppear, <span class="built_in">method_getTypeEncoding</span>(originalMethod))) &#123;</span><br><span class="line">          <span class="built_in">method_setImplementation</span>(originalMethod, (IMP) newViewDidAppear);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做<a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">Cross Cutting Concerns</a>。</p><p>用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>。</p><p>目前有些第三方库可以很方便的使用AOP，比如<a href="https://github.com/steipete/Aspects">Aspects</a>。这里是使用<a href="https://github.com/okcomp/AspectsDemo">Aspects的范例</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;内容骨架来自戴铭老师文章&lt;a href=&quot;https://ming1016.github.io/2015/04/01/objc-runtime/&quot;&gt;Objc Runtime 总结&lt;/a&gt;，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>(七) dyld与Objc—_objc_init、map_images、load_images</title>
    <link href="https://tenloy.github.io/2021/10/21/dyld-objc.html"/>
    <id>https://tenloy.github.io/2021/10/21/dyld-objc.html</id>
    <published>2021-10-21T10:20:00.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前文回顾"><a href="#一、前文回顾" class="headerlink" title="一、前文回顾"></a>一、前文回顾</h2><p>上一篇<a href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html">(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>，大概梳理了dyld的加载流程，这一次主要展开<strong>“第八步 执行初始化方法”</strong>，其是我们日常紧密接触的OBJC Runtime初始化启动的上文。</p><p>先简单回顾一下Runtime的初始化之前的流程：</p><ol><li>内核XNU加载Mach-O</li><li>从XNU内核态将控制权转移到dyld用户态</li><li>dyld：<ol><li>设置运行环境</li><li>实例化ImageLoader加载所需的动态库、并进行链接(符号绑定、重定位)。每个image对应一个ImageLoader实例</li><li>进行images的初始化：先初始化动态库，再初始化可执行文件。这步过程中，<strong>Runtime会向dyld中注册回调函数。dyld会在每个image加载、初始化、移除时分别调用Runtime的回调函数：map_images、load_images、unmap_images</strong>. </li><li>最后找到主程序的入口main()函数并返回。</li></ol></li></ol><p>可以在程序中，通过符号断点的形式<code>Debug → breakpoints → create symbolic breakpoint</code>来看这几个函数的调用堆栈：</p><p>添加符号断点：</p><img src="/images/compilelink/35.png" alt="35" style="zoom:90%;" /><p>load_images的调用堆栈(之一)：</p><img src="/images/compilelink/31.png" alt="35" style="zoom:90%;" /><p>在进入 <code>libobjc</code> 之前，我们必须要先了解 OC 中类的底层结构，可以先阅读<a href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html">下篇</a>(如果已经熟悉，那略过)。</p><h2 id="二、-objc-init"><a href="#二、-objc-init" class="headerlink" title="二、_objc_init()"></a>二、_objc_init()</h2><p>通过方法的文档注释，可以大概了解它的作用：启动初始化，注册dyld中image相关的回调通知，由libSystem在库(image)的初始化之前调用。</p><h3 id="2-1-objc-init-源码实现"><a href="#2-1-objc-init-源码实现" class="headerlink" title="2.1 _objc_init()源码实现"></a>2.1 _objc_init()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init()"></a>2.2 tls_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程局部/本地存储(Thread Local Storage, TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</span></span><br><span class="line"><span class="comment">// 线程私有数据(Thread Specific Data, TSD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc&#x27;s key for pthread_getspecific</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _objc_pthread_key TLS_DIRECT_KEY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">tls_key_t</span> _objc_pthread_key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> tls init：线程本地存储的初始化。</span></span><br><span class="line"><span class="comment"> _objc_pthread_destroyspecific 是线程的销毁函数。以 TLS_DIRECT_KEY 为 Key，在线程的本地存储空间中保存线程对应对销毁函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="built_in">pthread_key_init_np</span>(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = <span class="built_in">tls_create</span>(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_key_init_np</code> 是属于 <code>libpthread</code> 库中的方法了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为静态键设置析构函数，因为它不是用pthread_key_create()创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_init_np</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配用于表示进程中线程特定数据的键，键对进程中的所有线程来说是全局的。</span></span><br><span class="line"><span class="comment"> * 创建线程特定数据时，所有线程最初都具有与该键关联的NULL值。</span></span><br><span class="line"><span class="comment"> * @param key 指向从进程中已分配的键</span></span><br><span class="line"><span class="comment"> * @param destructor 指向析构函数，destuctor的形参是线程与键关联的数据。在线程终止时调用该函数，以达到释放内存的目的</span></span><br><span class="line"><span class="comment"> * @return 成功返回0.其他任何返回值都表示出现了错误。如果出现下列任一情况，pthread_key_create()将失败并返回相应的值</span></span><br><span class="line"><span class="comment">       EAGAIN：key名称空间已用完</span></span><br><span class="line"><span class="comment">       ENOMEM：此进程中虚拟内存不足，无法创建新键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-runtime-init"><a href="#2-3-runtime-init" class="headerlink" title="2.3 runtime_init()"></a>2.3 runtime_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> objc &#123;</span><br><span class="line">  <span class="comment">// 主要用来为类统计分类、追加分类到类、清除分类数据、清除类数据。</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnattachedCategories</span> :</span> <span class="keyword">public</span> ExplicitInitDenseMap&lt;Class, category_list&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> UnattachedCategories unattachedCategories; </span><br><span class="line">  <span class="comment">// allocatedClasses 是已使用 objc_allocateClassPair allocated 过的所有类（和元类）的表</span></span><br><span class="line">  <span class="keyword">static</span> ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">init</span>(<span class="number">32</span>); <span class="comment">// 初始化分类的存储容器, 是Map</span></span><br><span class="line">    objc::allocatedClasses.<span class="built_in">init</span>(); <span class="comment">// 初始化类的存储容器，是Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-cache-t-init"><a href="#2-4-cache-t-init" class="headerlink" title="2.4 cache_t::init()"></a>2.4 cache_t::init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/restartable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述用户空间的可恢复范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_vm_address_t</span> location;     <span class="comment">// 指向可重启动section开头的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    length;       <span class="comment">// 锚定在location的section的长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    recovery_offs;<span class="comment">// 应该用于恢复的初始位置的偏移量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      flags;</span><br><span class="line">&#125; <span class="keyword">task_restartable_range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">  <span class="comment">// mach_msg_type_number_t 当前是 unsigned int 的别名，定义别名利于不同的平台做兼容</span></span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// kern_return_t 当前是 int 的别名</span></span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计objc_restartableRanges数组中location成员值不为空的task_restartable_range_t的数量</span></span><br><span class="line">  <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前任务注册一组可重启范围。Register a set of restartable ranges for the current task.</span></span><br><span class="line">  kr = <span class="built_in">task_restartable_ranges_register</span>(<span class="built_in">mach_task_self</span>(),</span><br><span class="line">                                        objc_restartableRanges, count);</span><br><span class="line">  <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册失败则停止运行</span></span><br><span class="line">  _objc_fatal(<span class="string">&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;</span>,</span><br><span class="line">              kr, <span class="built_in">mach_error_string</span>(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索 <code>objc_restartableRanges</code> 可看到，在 <code>_collecting_in_critical</code> 函数中有看到有对其的遍历读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 第一次申请或扩容；扩容时，会清空现有数据. 扩容系数不同平台有3/4、7/8 */</span></span></span><br><span class="line">  ▼ void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld);</span><br><span class="line">  <span class="comment">// 或 void cache_t::eraseNolock(const char *func); // 将整个缓存重置为未缓存查找</span></span><br><span class="line">    <span class="comment">/* 将指定的malloc的内存添加到稍后要释放的内存列表中。</span></span><br><span class="line"><span class="comment">       size用于收集的阈值。它不必精确地与块的大小相同。*/</span></span><br><span class="line">    ▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::collect_free</span><span class="params">(<span class="keyword">bucket_t</span> *data, <span class="keyword">mask_t</span> capacity)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* 尝试释放累积的失效缓存. collectALot更努力地释放内存 */</span></span></span><br><span class="line">      ▼ void cache_t::collectNolock(bool collectALot); </span><br><span class="line">          <span class="comment">/* 用于判断当前是否可以对旧的方法缓存（扩容后的旧的方法缓存表）进行收集释放</span></span><br><span class="line"><span class="comment">             返回 true 表示objc_msgSend（或其他缓存读取器(cache reader)）当前正在缓存中查找，并</span></span><br><span class="line"><span class="comment">             且可能仍在使用某些garbage。返回 false 的话表示 garbage 中的 bucket_t 没有被在使用。</span></span><br><span class="line"><span class="comment">             即当前有其它线程正在读取使用我们的旧的方法缓存表时，此时不能对旧的方法缓存表进行内存释放*/</span></span><br><span class="line">        ▼ <span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>);  <span class="comment">//(critical 危急的；临界的；关键的)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-dyld-objc-notify-register"><a href="#2-5-dyld-objc-notify-register" class="headerlink" title="2.5 _dyld_objc_notify_register()"></a>2.5 _dyld_objc_notify_register()</h3><p><code>_dyld_objc_notify_register</code> 函数仅供 objc runtime 使用，注册当 mapped、unmapped 和 initialized objc images 时要调用的处理程序。Dyld 将使用包含 <code>objc-image-info</code> section 的 images 数组回调 <code>mapped</code> 函数。</p><blockquote><p>在iOS 13系统中，iOS将全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p></blockquote><p>在 dyld3 中，<code>_dyld_objc_notify_register</code> 函数的实现逻辑有一些改变，此处不再赘述了。</p><ul><li>map_images : dyld 将 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : dyld 初始化 image 会触发该方法，进行+load的调用</li><li>unmap_image : dyld 将 image 移除时 , 会触发该函数</li></ul><h2 id="三、map-images"><a href="#三、map-images" class="headerlink" title="三、map_images()"></a>三、map_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped(映射、加载) in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-map-images-nolock"><a href="#3-1-map-images-nolock" class="headerlink" title="3.1 map_images_nolock()"></a>3.1 map_images_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理由dyld映射的给定图像。</span></span><br><span class="line"><span class="comment"> * 执行所有的类注册和修复(或延迟查找丢失的超类等)，并调用+load方法。</span></span><br><span class="line"><span class="comment"> * Info[]是自底向上的顺序，即libobjc将在数组中比任何链接到libobjc的库更早。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态变量，表示第一次调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hList 是统计 mhdrs 中的每个 mach_header 对应的 header_info</span></span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有必要，执行首次初始化。</span></span><br><span class="line">    <span class="comment">// 此函数在 ordinary library 初始化程序之前调用。</span></span><br><span class="line">    <span class="comment">// 延迟初始化，直到找到使用 objc 的图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是第一次加载，则准备初始化环境</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="built_in">preopt_init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 OBJC_PRINT_IMAGES 环境变量时，启动时则打印 images 数量。</span></span><br><span class="line">    <span class="comment">// 如：objc[10503]: IMAGES: processing 296 newly-mapped images... </span></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 class 的数量。根据总数调整各种表格的大小。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// typedef struct mach_header_64 headerType;</span></span><br><span class="line">            <span class="comment">// 取得指定 image 的 header 指针</span></span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 以 mdr 构建其 header_info，并添加到全局的 header 列表中（是一个链表，大概看源码到现在还是第一次看到链表的使用）。</span></span><br><span class="line">            <span class="comment">// 且通过 GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;); 读取 __objc_classlist 区中的 class 数量添加到 totalClasses 中，</span></span><br><span class="line">            <span class="comment">// 以及未从 dyld shared cache 中找到 mhdr 的 header_info 时，添加 class 的数量到 unoptimizedTotalClasses 中。</span></span><br><span class="line">            <span class="keyword">auto</span> hi = <span class="built_in">addHeader</span>(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里有两种情况下 hi 为空：</span></span><br><span class="line">            <span class="comment">// 1. mhdr 的 magic 不是既定的 MH_MAGIC、MH_MAGIC_64、MH_CIGAM、MH_CIGAM_64 中的任何一个</span></span><br><span class="line">            <span class="comment">// 2. 从 dyld shared cache 中找到了 mhdr 的 header_info，并且 isLoaded 为 true（）</span></span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #define MH_EXECUTE 0x2 /* demand paged executable file demand 分页可执行文件 */ </span></span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable&#x27;s size</span></span><br><span class="line">                <span class="comment">// 根据主要可执行文件的大小调整一些数据结构的大小</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">size_t</span> count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ⬇️ GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">                <span class="comment">// 获取 __objc_selrefs 区中的 SEL 的数量</span></span><br><span class="line">                _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// GETSECT(_getObjc2MessageRefs, message_ref_t, &quot;__objc_msgrefs&quot;); </span></span><br><span class="line">                <span class="comment">// struct message_ref_t &#123;</span></span><br><span class="line">                <span class="comment">//     IMP imp;</span></span><br><span class="line">                <span class="comment">//     SEL sel;</span></span><br><span class="line">                <span class="comment">// &#125;;</span></span><br><span class="line">                <span class="comment">// ⬇️ 获取 __objc_msgrefs 区中的 message 数量</span></span><br><span class="line">                _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                <span class="comment">// 打印 image 信息</span></span><br><span class="line">                <span class="comment">// 如：objc[10565]: IMAGES: loading image for /usr/lib/system/libsystem_blocks.dylib (has class properties) (preoptimized)</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, </span><br><span class="line">                             hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>() ? <span class="string">&quot; (has class properties)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">optimizedByDyld</span>()?<span class="string">&quot; (preoptimized)&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️</span></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until the executable itself is found. </span></span><br><span class="line">    <span class="comment">// 执行 one-time runtime initialization，必须推迟到找到可执行文件本身。</span></span><br><span class="line">    <span class="comment">// This needs to be done before further initialization.</span></span><br><span class="line">    <span class="comment">// 这需要在进一步初始化之前完成。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The executable may not be present in this infoList if the executable does not contain</span></span><br><span class="line">    <span class="comment">// Objective-C code but Objective-C is dynamically loaded later.</span></span><br><span class="line">    <span class="comment">// 如果可执行文件不包含 Objective-C 代码但稍后动态加载 Objective-C，则该可执行文件可能不会出现在此 infoList 中。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="comment">// 初始化 selector 表并注册内部使用的 selectors。</span></span><br><span class="line">        <span class="built_in">sel_init</span>(selrefCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️⬇️⬇️ 这里的 arr_init 函数超重要，可看到它内部做了三件事：</span></span><br><span class="line">        <span class="comment">// 1. 自动释放池的初始化（实际是在 TLS 中以 AUTORELEASE_POOL_KEY 为 KEY 写入 tls_dealloc 函数（自动释放池的销毁函数：内部所有 pages pop 并 free））</span></span><br><span class="line">        <span class="comment">// 2. SideTablesMap 初始化，也可理解为 SideTables 的初始化（为 SideTables 这个静态全局变量开辟空间）</span></span><br><span class="line">        <span class="comment">// 3. AssociationsManager 的初始化，即为全局使用的关联对象表开辟空间</span></span><br><span class="line">        <span class="comment">// void arr_init(void) </span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     AutoreleasePoolPage::init();</span></span><br><span class="line">        <span class="comment">//     SideTablesMap.init();</span></span><br><span class="line">        <span class="comment">//     _objc_associations_init();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">arr_init</span>();</span><br><span class="line">        </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在较低版本下 DYLD_MACOSX_VERSION_10_13 之前的版本中禁用 +initialize fork safety，大致看看即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dyld_get_program_sdk_version</span>() &lt; DYLD_MACOSX_VERSION_10_13) &#123;</span><br><span class="line">            DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                             <span class="string">&quot;safety enforcement because the app is &quot;</span></span><br><span class="line">                             <span class="string">&quot;too old (SDK version &quot;</span> SDK_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                             <span class="built_in">FORMAT_SDK</span>(<span class="built_in">dyld_get_program_sdk_version</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;<span class="built_in">mhdr</span>();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getsectiondata</span>(hi-&gt;<span class="built_in">mhdr</span>(), <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                                 <span class="string">&quot;safety enforcement because the app has &quot;</span></span><br><span class="line">                                 <span class="string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️ 下面就来到了最核心的地方</span></span><br><span class="line">    <span class="comment">// 以 header_info *hList[mhCount] 数组中收集到的 images 的 header_info 为参，直接进行 image 的读取</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把开始时初始化的静态局部变量 firstTime 置为 NO</span></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️</span></span><br><span class="line">    <span class="comment">// _read_images 看完再看下面的 loadImageFuncs 函数  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="comment">// 一切设置完毕后调用 image 加载函数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            <span class="built_in">func</span>(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_images_nolock</code> 就是：</p><ul><li>对 <code>const struct mach_header * const mhdrs[]</code> 参数的处理，把数组中的 <code>mach_header</code> 转换为 <code>header_info</code> 并存在 <code>header_info *hList[mhCount]</code> 数组中。</li><li>并统计 <code>totalClasses</code> 和 <code>unoptimizedTotalClasses</code> 的数量</li><li>然后调用下面的 <code>_read_images</code> 函数</li></ul><blockquote><p>在阅读_read_images()函数前，先来了解一下class在加载过程都有哪些状态，在objc中以怎样的数据结构来记录的。</p></blockquote><h3 id="3-2-class加载过程中的flag标志"><a href="#3-2-class加载过程中的flag标志" class="headerlink" title="3.2 class加载过程中的flag标志"></a>3.2 class加载过程中的flag标志</h3><p>当调用 runtime API 动态创建类的过程，包括三个步骤：</p><ul><li>调用<code>Class objc_allocateClassPair(...)</code>构建类；</li><li>添加必要的成员变量、方法等元素；</li><li>调用<code>void objc_registerClassPair(Class cls)</code>注册类；</li></ul><p>然而，runtime 从镜像（image）加载类的过程会更加精细，在加载类的不同阶段会被标记为不同的类型（还是<code>objc_class</code>结构体，只是<code>flags</code>不同），例如：</p><ul><li><strong>future class</strong>（未来要解析的类，也称懒加载类）<ul><li>named class（已确定名称类）：将<code>cls</code>标记为 named class，以<code>cls-&gt;mangledName()</code>类名为关键字添加到全局记录的<code>gdb_objc_realized_classes</code>哈希表中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>allocated class（已分配内存类）：将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的<code>allocatedClasses</code>哈希表中（无需关键字），表示已为类分配固定内存空间；</li></ul></li><li><strong>remapped class</strong>（已重映射类）</li><li><strong>realized class</strong>（已认识/实现类）</li><li>loaded class（已加载类）：已执行<code>load</code>方法的类</li><li>initialized class（已初始化类）：已执行<code>initialize()</code>方法的类</li></ul><blockquote><p>realized: adj. 已实现的; v. 意识到，认识到，理解；实现；把（概念等）具体表现出来.</p><p>OC 类在被使用之前（譬如调用类方法），需要进行一系列的初始化，譬如：指定 <code>superclass</code>、指定 <code>isa</code> 指针、<code>attach categories</code> 等等；libobjc 在 runtime 阶段就可以做这些事情，但是有些过于浪费，更好的选择是懒处理，这一举措极大优化了程序的执行速度。而 runtime 把对类的惰性初始化过程称为「realize」。</p><p>利用已经被 <code>realize</code> 的类含有 <code>RW_REALIZED</code> 和 <code>RW_REALIZING</code> 标记的特点，可以为项目找出无用类；因为没有被使用的类，一定没有被 <code>realized</code>。</p></blockquote><h4 id="3-2-1-class-rw-t-gt-flags"><a href="#3-2-1-class-rw-t-gt-flags" class="headerlink" title="3.2.1 class_rw_t-&gt;flags"></a>3.2.1 class_rw_t-&gt;flags</h4><p><code>class_rw_t</code>的<code>flags</code>为可读写。其中比较重要的一些值定义列举如下，均以RW_为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类是已实现/已认识/已初始化处理过的类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// 该类是尚未解析的unresolved future class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// 该类已经初始化。完成执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZED        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// 该类正在初始化。正在执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZING       (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// class_rw_t-&gt;ro是class_ro_t的堆拷贝。此时类的class_rw_t-&gt;ro是可写入的，拷贝之前ro的内存区域锁死不可写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_COPIED_RO          (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// class allocated but not yet registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTING       (1&lt;&lt;26)</span></span><br><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">// 该类的load方法已经调用过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOADED             (1&lt;&lt;23)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="comment">// 该类的实例可能存在关联对象。默认编译选项下，无需定义该位，因为都可能有关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类的实例具有特定的GC layout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_INSTANCE_SPECIFIC_LAYOUT      (1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">// 该类禁止在其实例上使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FORBIDS_ASSOCIATED_OBJECTS        (1&lt;&lt;20)</span></span><br><span class="line"><span class="comment">// 该类正在实现，但是未实现完成</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZING          (1&lt;&lt;19)</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-class-ro-t-gt-flags"><a href="#3-2-2-class-ro-t-gt-flags" class="headerlink" title="3.2.2 class_ro_t-&gt;flags"></a>3.2.2 class_ro_t-&gt;flags</h4><p><code>class_ro_t</code>的<code>flags</code>成员为只读。其中比较重要的一些值定义列举如下，均以<code>RO_</code>为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类是元类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_META               (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// 类是根类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_ROOT               (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// 类有CXX构造/析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_STRUCTORS  (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// 类有实现load方法</span></span><br><span class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3)</span></span><br><span class="line"><span class="comment">// 隐藏类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HIDDEN             (1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION          (1&lt;&lt;5)</span></span><br><span class="line"><span class="comment">// class has ro field for Swift metadata initializer callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)</span></span><br><span class="line"><span class="comment">// 类使用ARC选项编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARC             (1&lt;&lt;7)</span></span><br><span class="line"><span class="comment">// 类有CXX析构函数，但没有CXX构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_DTOR_ONLY  (1&lt;&lt;8)</span></span><br><span class="line"><span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)</span></span><br><span class="line"><span class="comment">// 类禁止使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FROM_BUNDLE        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is unrealized future class - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is realized - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure><h3 id="3-3-read-images"><a href="#3-3-read-images" class="headerlink" title="3.3 _read_images()"></a>3.3 _read_images()</h3><p>观看下面内容之前，如果对 OC 中 <code>Class</code>、<code>Category</code>、<code>Protocol</code>的实现结构(底层的结构体实现及成员变量)不熟悉，建议先看一下<a href="">Runtime(一)：面向对象(Class和Object)的基本数据结构</a>、<a href="">Runtime(二)：Category、Protocol的实现与加载</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 headerList 开头的链表中的 headers 进行初始处理</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    </span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态局部变量，如果是第一次调用 _read_images 则 doneOnce 值为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> launchTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测量 image 加载步骤的持续时间</span></span><br><span class="line">    <span class="comment">// 对应 objc-env.h 中的 OPTION( PrintImageTimes, OBJC_PRINT_IMAGE_TIMES, &quot;measure duration of image loading steps&quot;)</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EACH_HEADER 是给下面的 for 循环使用的宏，遍历 hList 数组中的 header_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><h4 id="1-是否是第一次加载"><a href="#1-是否是第一次加载" class="headerlink" title="1. 是否是第一次加载"></a>1. 是否是第一次加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1⃣️</span></span><br><span class="line"><span class="comment">// 第一次调用 _read_images 时，doneOnce 值为 NO，会进入 if 执行里面的代码 </span></span><br><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">    <span class="comment">// 把静态局部变量 doneOnce 置为 YES，之后调用 _read_images 都不会再进来</span></span><br><span class="line">    <span class="comment">// 第一次调用 _read_images 的时候，class、protocol、selector、category 都没有，</span></span><br><span class="line">    <span class="comment">// 需要创建容器来保存这些东西，此 if 内部，最后是创建一张存 class 的表。</span></span><br><span class="line">    doneOnce = YES;</span><br><span class="line">    </span><br><span class="line">    launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在低版本（swifit3 之前、OS X 10.11 之前）下禁用 non-pointer isa 时的一些打印信息，</span></span><br><span class="line"><span class="comment">// 为了减少我们的理解负担，这里直接进行了删除，想要学习的同学可以去看一下源码</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointers, OBJC_DISABLE_TAGGED_POINTERS, &quot;disable tagged pointer optimization of NSNumber et al.&quot;)</span></span><br><span class="line">    <span class="comment">// 禁用 NSNumber 等的 Tagged Pointers 优化时</span></span><br><span class="line">    <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">        <span class="comment">// 内部直接把 Tagged Pointers 用到的 mask 全部置为 0</span></span><br><span class="line">        <span class="built_in">disableTaggedPointers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION, &quot;disable obfuscation of tagged pointers&quot;)</span></span><br><span class="line">    <span class="comment">// 可开启 OBJC_DISABLE_TAG_OBFUSCATION，禁用 Tagged Pointer 的混淆。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机初始化 objc_debug_taggedpointer_obfuscator。</span></span><br><span class="line">    <span class="comment">// tagged pointer obfuscator 旨在使攻击者在存在缓冲区溢出或其他对某些内存的写控制的情况下更难将特定对象构造为标记指针。</span></span><br><span class="line">    <span class="comment">// 在设置或检索有效载荷值（payload values）时， obfuscator 与 tagged pointers 进行异或。</span></span><br><span class="line">    <span class="comment">// 它们在第一次使用时充满了随机性。</span></span><br><span class="line">    <span class="built_in">initializeTaggedPointerObfuscator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OPTION( PrintConnecting, OBJC_PRINT_CLASS_SETUP, &quot;log progress of class and category setup&quot;)</span></span><br><span class="line">    <span class="comment">// objc[26520]: CLASS: found 25031 classes during launch 在 objc-781 下在启动时有 25031 个类（包含所有的系统类和自定义类）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// namedClasses</span></span><br><span class="line">    <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">    <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPreoptimized 如果我们有一个有效的优化共享缓存（valid optimized shared cache），则返回 YES。</span></span><br><span class="line">    <span class="comment">// 然后是不管三目运算符返回的是 unoptimizedTotalClasses 还是 totalClasses，它都会和后面的 4 / 3 相乘，</span></span><br><span class="line">    <span class="comment">// 注意是 4 / 3</span></span><br><span class="line">    <span class="keyword">int</span> namedClassesSize = (<span class="built_in">isPreoptimized</span>() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// gdb_objc_realized_classes 是一张全局的哈希表，虽然名字中有 realized，但是它的名字其实是一个误称，</span></span><br><span class="line">    <span class="comment">// 实际上它存放的是不在 dyld shared cache 中的 class，无论该 class 是否 realized。</span></span><br><span class="line">    gdb_objc_realized_classes = <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 objc-781 下执行到这里时，会有如下打印:</span></span><br><span class="line">    <span class="comment">// objc[19881]: 0.04 ms: IMAGE TIMES: first time tasks</span></span><br><span class="line">    <span class="comment">// 这个过程花了 0.04 毫秒</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修复预编译时-selector-错乱问题"><a href="#2-修复预编译时-selector-错乱问题" class="headerlink" title="2. 修复预编译时 @selector 错乱问题"></a>2. 修复预编译时 @selector 错乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 注册并修正 selector references. Fix up @selector references</span></span><br><span class="line">  <span class="comment">//（其实就是把 image 的 __objc_selrefs 区中的 selector 放进全局的 selector 集合中，修改其中不一致的地址）</span></span><br><span class="line"><span class="comment">// 也就是当 SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); 中的 SEL 和通过 SEL sel = sel_registerNameNoLock(name, isBundle); 注册返回的 SEL 不同时，就把 sels 中的 SEL 修正为 sel_registerNameNoLock 中返回的地址。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 加锁 selLock</span></span><br><span class="line">      <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历 header_info **hList 中的 header_info</span></span><br><span class="line">      <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 如果指定的 hi 不需要预优化则跳过</span></span><br><span class="line">          <span class="keyword">if</span> (hi-&gt;<span class="built_in">hasPreoptimizedSelectors</span>()) <span class="keyword">continue</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 根据 mhdr()-&gt;filetype 判断 image 是否是 MH_BUNDLE 类型</span></span><br><span class="line">          <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">          <span class="comment">// 获取 __objc_selrefs 区中的 SEL</span></span><br><span class="line">          SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 记录数量</span></span><br><span class="line">          UnfixedSelectors += count;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// static objc::ExplicitInitDenseSet&lt;const char *&gt; namedSelectors;</span></span><br><span class="line">          <span class="comment">// 是一个静态全局 set，用来存放 Selector（名字，Selector 本身就是字符串）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历把 sels 中的所有 selector 放进全局的 selector 集合中   </span></span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          </span><br><span class="line">              <span class="comment">// sel_cname 函数内部实现是返回：(const char *)(void *)sel; 即把 SEL 强转为 char 类型</span></span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(sels[i]);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 注册 SEL，并返回其地址</span></span><br><span class="line">              SEL sel = <span class="built_in">sel_registerNameNoLock</span>(name, isBundle);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 如果 SEL 地址发生变化，则把它设置为相同</span></span><br><span class="line">              <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                  sels[i] = sel;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里打印注册并修正 selector references 用的时间</span></span><br><span class="line">  <span class="comment">// 在 objc-781 下打印：objc[27056]: 0.44 ms: IMAGE TIMES: fix up selector references</span></span><br><span class="line">  <span class="comment">// 耗时 0.44 毫秒</span></span><br><span class="line">  ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-readClass-读取类信息，修复future-classes"><a href="#3-readClass-读取类信息，修复future-classes" class="headerlink" title="3. readClass()读取类信息，修复future classes"></a>3. readClass()读取类信息，修复future classes</h4><p>通过 readClass 读取出来类的信息，修复未解析的future classes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="comment">// 发现 classes。修复 unresolved future classes。标记 bundle classes。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if any OS dylib has overridden its copy in the shared cache</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exists in iPhoneOS 3.1 and later </span></span><br><span class="line"><span class="comment">// Exists in Mac OS X 10.10 and later</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = <span class="built_in">dyld_shared_cache_some_image_overridden</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">mustReadClasses</span>(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="comment">// Image 已充分优化，我们无需调用 readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 __objc_classlist 区中的 classref_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从编译后的类列表中取出所有类，获取到的是一个 classref_t 类型的指针 </span></span><br><span class="line">    <span class="comment">// classref_t is unremapped class_t* ➡️ classref_t 是未重映射的 class_t 指针</span></span><br><span class="line">    <span class="comment">// typedef struct classref * classref_t; // classref_t 是 classref 结构体指针</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点 ⚠️⚠️⚠️⚠️ 在这里：readClass。</span></span><br><span class="line">        <span class="comment">// 我们留在下面单独分析。</span></span><br><span class="line">        Class newCls = <span class="built_in">readClass</span>(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// 类被移动但未被删除。目前，这种情况只发生在新类解析未来类时。</span></span><br><span class="line">            <span class="comment">// 非惰性地实现下面的类</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// realloc 原型是 extern void *realloc(void *mem_address, unsigned int newsize);</span></span><br><span class="line">            <span class="comment">// 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，</span></span><br><span class="line">            <span class="comment">// 如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，</span></span><br><span class="line">            <span class="comment">// 而后释放原来 mem_address 所指内存区域（注意：原来指针是自动释放，不需要使用 free），</span></span><br><span class="line">            <span class="comment">// 同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。</span></span><br><span class="line">            </span><br><span class="line">            resolvedFutureClasses = (Class *)<span class="built_in">realloc</span>(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现 classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 3.17 ms: IMAGE TIMES: discover classes</span></span><br><span class="line"><span class="comment">// 耗时 3.17 毫秒（和前面的 0.44 毫秒比，多出不少）</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-future-class的生成"><a href="#1-future-class的生成" class="headerlink" title="1) future class的生成"></a>1) future class的生成</h5><p><code>objc_class</code>的<code>isFuture()</code>函数，用于判断类是否为 future class。future class 对理解类的加载过程有重要作用。</p><p>首先看 <strong>future class 是如何生成的</strong> — <code>addFutureNamedClass()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 安装cls作为类结构，用于命名类(如果之后出现)。 </span></span><br><span class="line"><span class="comment"> 将传入的 cls 参数，配置为类名为 name的 future class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配 cls 所需的 class_rw_t、class_ro_t 的内存空间；</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 将 cls 的类名置为 name；</span></span><br><span class="line">    ro-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">// 3. 将 class_rw_t 的 RO_FUTURE 位置为1，RO_FUTURE 等于 RW_FUTURE；</span></span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RO_FUTURE; </span><br><span class="line"><span class="comment">// 4. 以 name 为关键字(key)，将 cls 添加到一个全局的哈希表 futureNamedClasses；</span></span><br><span class="line">    old = <span class="built_in">NXMapKeyCopyingInsert</span>(<span class="built_in">futureNamedClasses</span>(), name, cls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="comment">/* 返回一个map，key为 classname, value 为 unrealized future classes(Class实例)*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF’s classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为给定的类名分配一个未解析的未来类 unresolved future class</span></span><br><span class="line"><span class="comment"> * 如果已经分配，则返回任何现有分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *map = <span class="built_in">futureNamedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)<span class="built_in">NXMapGet</span>(map, name))) &#123;</span><br><span class="line">        <span class="comment">// 存在名为name的future class</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分配用于保存objc_class的内存空间</span></span><br><span class="line">    cls = _calloc_class(<span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构建名为name的future class并全局记录到 futureNamedClasses 哈希表</span></span><br><span class="line">    <span class="built_in">addFutureNamedClass</span>(name, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> Return the id of the named class.</span></span><br><span class="line"><span class="comment"> 如果该类不存在，则返回一个未初始化的类结构，该结构将在类加载时使用。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Class look_up_class(const char *name, </span></span><br><span class="line"><span class="comment">              bool includeUnconnected __attribute__((unused)), </span></span><br><span class="line"><span class="comment">              bool includeClassHandler __attribute__((unused))) // unconnected is OK，因为总有一天它会成为真正的class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cls = <span class="built_in">look_up_class</span>(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;FUTURE: found %p already in use for %s&quot;</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还没有名为name的class或future class。做一个。</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链向上追溯到 <code>Class objc_getFutureClass</code>，该函数并没有在 runtime 源代码中被调用到。而用于从 <code>namedFutureClasses</code> 哈希表中获取 future class 的<code>popFutureClass(...)</code> 函数是有间接通过<code>readClass(...)</code>函数被广泛调用。因此，<strong>构建 future class 的逻辑大多隐藏在 runtime 的内部实现中未公布，只有使用 future class 的逻辑是开源的</strong>。</p><h5 id="2-future-class的获取"><a href="#2-future-class的获取" class="headerlink" title="2) future class的获取"></a>2) future class的获取</h5><p> <code>popFutureNamedClass</code> 用于从 <code>futureNamedClasses</code> 哈希表中弹出类名为<code>name</code>的 future class，这是获取全局记录的 future class 的唯一入口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Removes the named class from the unrealized future class list, because it has been realized.</span></span><br><span class="line"><span class="comment"> * Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)<span class="built_in">NXMapKeyFreeingRemove</span>(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; <span class="built_in">NXCountMapTable</span>(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NXFreeMapTable</span>(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-future-class的使用-—-readClass"><a href="#3-future-class的使用-—-readClass" class="headerlink" title="3) future class的使用 — readClass"></a>3) future class的使用 — readClass</h5><p>readClass 用于读取<code>cls</code>中的类数据，关键处理逻辑表述如下：</p><ul><li>若 <code>futureNamedClasses</code> 哈希表中存在 <code>cls-&gt;mangledName()</code> 类名的 future class，则将<code>cls</code>重映射（remapping）到新的类 <code>newCls</code>（具体重映射过程在下面4小节中详细讨论），然后将 <code>newCls</code> 标记为 remapped class，以<code>cls</code>为关键字添加到全局记录的 <code>remappedClasses()</code> 哈希表中；</li><li>将<code>cls</code>标记为 named class，以 <code>cls-&gt;mangledName()</code> 类名为关键字添加到全局记录的 <code>gdb_objc_realized_classes</code> 哈希map中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的 <code>allocatedClasses</code> 哈希set中，表示已为类分配固定内存空间；</li></ul><blockquote><p>注意：传入<code>readClass(...)</code>的<code>cls</code>参数是<code>Class</code>类型，而函数返回结果也是<code>Class</code>，为什么读取类信息是“从类中读取类信息”这样怪异的过程呢？</p><p>其实是因为<code>cls</code>参数来源于 runtime 未开源的、从镜像（image）中读取类的过程。该过程输出的<code>objc_class</code>存在特殊之处：要么输出 future class，要么输出正常(normal)类但是其<code>bits</code>指向的是<code>class_ro_t</code>结构体而非<code>class_rw_t</code>，之所以如此是因为从镜像读取的是编译时决议的静态数据，本来就应该保存在<code>class_ro_t</code>结构体中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;<span class="built_in">nonlazyMangledName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的继承链上，存在既不是根类（RO_ROOT位为0）又没有超类的类，则为missingWeakSuperclass</span></span><br><span class="line">    <span class="comment">// 注意：这是唯一的向remappedClasses中添加nil值的入口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">missingWeakSuperclass</span>(cls)) &#123;</span><br><span class="line">        <span class="built_in">addRemappedClass</span>(cls, nil);</span><br><span class="line">        cls-&gt;<span class="built_in">setSuperclass</span>(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容旧版本libobjc的配置，可忽略</span></span><br><span class="line">    cls-&gt;<span class="built_in">fixupBackwardDeployingStableSwift</span>();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// 这个name已经被分配为future class，全局记录。</span></span><br><span class="line">            <span class="comment">// 将cls的内容拷贝到newCls(也就是future class)中，保存future class的rw中的数据。将cls-&gt;data设置为rw-&gt;ro</span></span><br><span class="line">            <span class="comment">// 以cls为关键字将构建的newCls添加到全局记录的remappedClasses哈希表中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;<span class="built_in">isAnySwift</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot;</span></span><br><span class="line">                            <span class="string">&quot;because the real class is too big.&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;<span class="built_in">setSuperclass</span>(cls-&gt;<span class="built_in">getSuperclass</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">initIsa</span>(cls-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line"></span><br><span class="line">            rw-&gt;<span class="built_in">set_ro</span>((<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">            <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;<span class="built_in">getName</span>());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// 已存在该类名的named class</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(mangledName == <span class="literal">nullptr</span> || <span class="built_in">getClassExceptSomeSwift</span>(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">// 一些Swift泛型类可以惰性地生成它们的名称</span></span><br><span class="line">            <span class="comment">// 将类添加到 named classes</span></span><br><span class="line">            <span class="built_in">addNamedClass</span>(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() &amp;&amp; <span class="string">&quot;Metaclass with lazy name must have a pointer to the corresponding nonmetaclass.&quot;</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() == cls &amp;&amp; <span class="string">&quot;Metaclass nonmetaclass pointer must equal the original class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将类添加到 allocated classes</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="comment">// 设置RO_FROM_BUNDLE位</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-future-class小结"><a href="#4-future-class小结" class="headerlink" title="4) future class小结"></a>4) future class小结</h5><p>从上文<code>readClass(...)</code>代码<code>if (Class newCls = popFutureNamedClass(mangledName))</code>分支内<code>free((void *)old_ro)</code>语句，得出在<code>cls</code>映射到<code>newCls</code>过程中，完全丢弃了 future class 的<code>ro</code>数据。最后，结合以上所有代码，可以归纳以下结论：</p><ul><li><p>Future class 类的有效数据实际上仅有：类名和<code>rw</code>。<code>rw</code>中的数据作用也非常少，仅使用<code>flags</code>的<code>RO_FUTURE</code>（实际上就是<code>RW_FUTURE</code>）标记类是 future class；</p></li><li><p>Future class 的作用是为指定类名的类，提前分配好内存空间，调用<code>readClass(...)</code>函数读取类时，才正式写入类的数据。 Future class 是用于支持类的懒加载机制；</p></li></ul><h4 id="4-remapped-重新映射-classes"><a href="#4-remapped-重新映射-classes" class="headerlink" title="4. remapped(重新映射) classes"></a>4. remapped(重新映射) classes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class list 和 nonlazy class list 仍未映射。</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    <span class="comment">// Class refs 和 super refs 被重新映射为消息调度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是修复重映射 classes，!noClassesRemapped() 在这里为 false，所以一般走不进来，</span></span><br><span class="line">    <span class="comment">// 将未映射 class 和 super class 重映射，被 remap 的类都是非懒加载的类</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">noClassesRemapped</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2ClassRefs, Class, &quot;__objc_classrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_classrefs 区中的类引用</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历 classrefs 中的类引用，如果类引用已被重新分配或者是被忽略的弱链接类，</span></span><br><span class="line">            <span class="comment">// 就将该类引用重新赋值为从重映射类表中取出新类</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// Fix up a class ref, in case the class referenced has been reallocated or is an ignored weak-linked class.</span></span><br><span class="line">                <span class="comment">// 修复 class ref，以防所引用的类已 reallocated 或 is an ignored weak-linked class。</span></span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2SuperRefs, Class, &quot;__objc_superrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_superrefs 区中的父类引用</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里打印修复重映射 classes 用的时间</span></span><br><span class="line">    <span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: remap classes</span></span><br><span class="line">    <span class="comment">// 耗时 0 毫秒，即 Fix up remapped classes 并没有执行 </span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> cacheSupportsProtocolRoots = <span class="built_in">sharedCacheSupportsProtocolRoots</span>();</span><br></pre></td></tr></table></figure><h5 id="1-future-class-的重映射"><a href="#1-future-class-的重映射" class="headerlink" title="1) future class 的重映射"></a>1) future class 的重映射</h5><p>在上面 <code>readClass()</code> 中有提到类的重映射，重映射的类被标记为 remapped class，并以映射前的类为关键字，添加到全局的<code>remappedClass</code>哈希表中。回顾<code>readClass()</code>函数中，类的重映射代码如下，关于处理过程的详细描述已注释到代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 若该类名已被标记为future class，则弹出该类名对应的future class 赋值给newCls</span></span><br><span class="line"><span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">    <span class="comment">// 2. rw记录future class的rw</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 3. future class的ro记为old_ro，后面释放其占用的内存空间并丢弃</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line">    <span class="comment">// 4. 将cls中的数据拷贝到newCls，主要是要沿用cls的isa、superclass和cache数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">    <span class="comment">// 5. rw记录cls的ro</span></span><br><span class="line">    rw-&gt;ro = (<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 6. 沿用future class的rw、cls的ro</span></span><br><span class="line">    newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    <span class="comment">// 7. 释放future class的ro占用的空间</span></span><br><span class="line">    <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 将newCls以cls为关键字添加到remappedClasses哈希表中</span></span><br><span class="line">    <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line">    </span><br><span class="line">    replacing = cls;</span><br><span class="line">    cls = newCls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合上面代码的详细注释，可知<code>cls</code>重映射到<code>newCls</code>后，<code>newCls</code>的数据保留了<code>cls</code>中的<code>superclass</code>、<code>cache</code>成员，但是<code>bits</code>中指向<code>class_rw_t</code>结构体地址的位域（<code>FAST_DATA_MASK</code>）指向了<strong>新的<code>class_rw_t</code>结构体</strong>。该结构体的<code>ro</code>指针指向<code>cls-&gt;data()</code>所指向的内存空间中保存的<code>class_ro_t</code>结构体，其他数据则是直接沿用 从<code>namedFutureClasses</code>哈希表中弹出的 future class 的<code>class_rw_t</code>结构体（通过future class 的<code>data()</code>方法返回）中数据。</p><blockquote><p>注意：虽然<code>objc_class</code>的<code>data()</code>方法声明为返回<code>class_rw_t *</code>，但是究其本质，它只是返回了<code>objc_class</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>标记的位域中保存的内存地址，该内存地址实际上可以保存任何类型的数据。在<code>Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)</code>函数中，传入的<code>cls</code>所指向的<code>objc_class</code>结构体有其特殊之处：<code>cls</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>位域，指向的内存空间保存的是<code>class_ro_t</code>结构体，并不是通常的<code>class_rw_t</code>。</p></blockquote><h5 id="2-通用类的重映射"><a href="#2-通用类的重映射" class="headerlink" title="2) 通用类的重映射"></a>2) 通用类的重映射</h5><p>通用的类重映射调用<code>static class remapClass(Class cls)</code>，注意当传入的<code>cls</code>类不在<code>remappedClasses</code>哈希表中时，直接返回<code>cls</code>本身；<code>static void remapClassRef(Class *clsref)</code>可对传入的<code>Class* clsref</code>重映射（改变<code>*clsref</code>的值），返回时<code>clsref</code>将 指向<code>*clsref</code>重映射后的类。类的重映射相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取remappedClasses，保存已重映射的所有类的全局哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">remappedClasses</span><span class="params">(<span class="keyword">bool</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态的全局哈希表，没有找到remove接口，只会无限扩张</span></span><br><span class="line">    <span class="keyword">static</span> NXMapTable *remapped_class_map = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remapped_class_map) <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">    <span class="keyword">if</span> (!create) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remapped_class_map is big enough to hold CF’s classes and a few others</span></span><br><span class="line">    <span class="built_in">INIT_ONCE_PTR</span>(remapped_class_map, </span><br><span class="line">                  <span class="built_in">NXCreateMapTable</span>(NXPtrValueMapPrototype, <span class="number">32</span>), </span><br><span class="line">                  <span class="built_in">NXFreeMapTable</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将oldcls重映射得到的newcls，以oldcls为关键字插入到remappedClasses哈希表中</span></span><br><span class="line"><span class="comment">// 注意：从代码透露出来的信息是，remappedClasses中只保存 future class 重映射的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRemappedClass</span><span class="params">(Class oldcls, Class newcls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;FUTURE: using %p instead of %p for %s&quot;</span>, </span><br><span class="line">                     (<span class="keyword">void</span>*)newcls, (<span class="keyword">void</span>*)oldcls, oldcls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = <span class="built_in">NXMapInsert</span>(<span class="built_in">remappedClasses</span>(YES), oldcls, newcls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cls的重映射类</span></span><br><span class="line"><span class="comment">// 注意：当remappedClasses为空或哈希表中不存在`cls`关键字，是返回`cls`本身，否则返回`cls`重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *map = <span class="built_in">remappedClasses</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (!map  ||  <span class="built_in">NXMapMember</span>(map, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Class的指针的重映射，返回时传入的clsref将 指向*clsref重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remapClassRef</span><span class="params">(Class *clsref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class newcls = <span class="built_in">remapClass</span>(*clsref);    </span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) *clsref = newcls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remap小结"><a href="#3-remap小结" class="headerlink" title="3) remap小结"></a>3) remap小结</h5><p>最后归纳出以下结论：</p><ul><li>Future class 进行重映射后，会返回新的类，保存在<code>remappedClasses</code>全局哈希表中；</li><li>正常类重映射返回类本身；</li><li>重映射的真正的目的是支持类的懒加载，懒加载类暂存为 future class 只记录类名及 future class 属性，在调用<code>readClass</code>才正式载入类数据。</li></ul><h4 id="5-类中如果有协议，读取协议"><a href="#5-类中如果有协议，读取协议" class="headerlink" title="5. 类中如果有协议，读取协议"></a>5. 类中如果有协议，读取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="comment">// 发现 protocols，修正 protocol refs。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个长度是 16 的 NXMapTable</span></span><br><span class="line">    NXMapTable *protocol_map = <span class="built_in">protocols</span>();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedProtocols</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache and we support roots</span></span><br><span class="line">    <span class="comment">// 如果这是来自 shared cache 的 image 并且我们 support roots，则跳过 reading protocols</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol in the shared cache is marked with isCanonical()</span></span><br><span class="line">    <span class="comment">// and that may not be true if some non-shared cache binary was chosen as the canonical definition</span></span><br><span class="line">    <span class="comment">// 启动后，我们确实需要遍历协议，因为 shared cache 中的协议用 isCanonical() 标记，如果选择某些非共享缓存二进制文件作为规范定义，则可能不是这样</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized &amp;&amp; cacheSupportsProtocolRoots) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>, hi-&gt;<span class="built_in">fname</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolList, protocol_t * const, &quot;__objc_protolist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protolist 区下的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Read a protocol as written by a compiler.</span></span><br><span class="line">        <span class="built_in">readProtocol</span>(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现并修正 protocols 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 5.45 ms: IMAGE TIMES: discover protocols</span></span><br><span class="line"><span class="comment">// 耗时 05.45 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-映射协议"><a href="#6-映射协议" class="headerlink" title="6. 映射协议"></a>6. 映射协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right answer already but we don&#x27;t know for sure.</span></span><br><span class="line"><span class="comment">// Preoptimized images 可能已经有了正确的答案，但我们不确定。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the shared cache definition of a protocol.</span></span><br><span class="line">    <span class="comment">// 在启动时，我们知道 preoptimized image refs 指向协议的 shared cache 定义。</span></span><br><span class="line">    <span class="comment">// We can skip the check on launch, but have to visit @protocol refs for shared cache images loaded later.</span></span><br><span class="line">    <span class="comment">// 我们可以跳过启动时的检查，但必须访问 @protocol refs 以获取稍后加载的 shared cache images。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; cacheSupportsProtocolRoots &amp;&amp; hi-&gt;<span class="built_in">isPreoptimized</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolRefs, protocol_t *, &quot;__objc_protorefs&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protorefs 区的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Fix up a protocol ref, in case the protocol referenced has been reallocated.</span></span><br><span class="line">        <span class="comment">// 修复 protocol ref，以防 protocol referenced 已重新分配。</span></span><br><span class="line">        <span class="built_in">remapProtocolRef</span>(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 @protocol references 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: fix up @protocol references</span></span><br><span class="line"><span class="comment">// 因为是第一次启动，则并不进行</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-加载分类"><a href="#7-加载分类" class="headerlink" title="7. 加载分类"></a>7. 加载分类</h4><p>把 category 的数据追加到原类中去！很重要。</p><p>这里并不会执行，didInitialAttachCategories 是一个静态全局变量，默认是 false，对于启动时出现的 categories，discovery 被推迟到 <code>_dyld_objc_notify_register</code> 调用完成后的第一个 <code>load_images</code> 调用。所以这里 if 里面的 Discover categories 是不会执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. 发现类别。</span></span><br><span class="line"><span class="comment">// 仅在完成 initial category attachment 后才执行此操作。</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// didInitialAttachCategories 是一个静态全局变量，默认是 false，</span></span><br><span class="line"><span class="comment">// static bool didInitialAttachCategories = false; 在load_images()函数体中，才会置为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Discover categories. 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: discover categories</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 所以这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其他线程在该线程完成其修复(thread finishes its fixups)之前调用新的category代码时，category discovery必须延迟以避免潜在的竞争。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +load 由 prepare_load_methods() 处理</span></span><br></pre></td></tr></table></figure><h4 id="8-realize非懒加载类-—-realized-class"><a href="#8-realize非懒加载类-—-realized-class" class="headerlink" title="8. realize非懒加载类 — realized class"></a>8. realize非懒加载类 — realized class</h4><p>懒加载：类没有实现 +load 函数，在使用的第一次才会加载，当我们给这个类的发送消息时，如果是第一次，在消息查找的过程中就会判断这个类是否加载，没有加载就会加载这个类。懒加载类在首次调用方法的时候，才会去调用 <code>realizeClassWithoutSwift</code> 函数去进行加载。</p><p>非懒加载：类的内部实现了 +load 函数，类的加载就会提前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="comment">// 实现非懒加载类（为了+load调用、静态实例）</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_nlclslist 区中的非懒加载类（即实现了 +load 函数的类）</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重映射类， 获取正确的类指针</span></span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// static void addClassTableEntry(Class cls, bool addMeta = true) &#123; ... &#125;</span></span><br><span class="line">        <span class="comment">// 将一个类添加到用来存储所有类的全局的 set 中（auto &amp;set = objc::allocatedClasses.get();）。</span></span><br><span class="line">        <span class="comment">// 如果 addMeta 为 true（默认为 true），也自动添加类的元类到这个 set 中。</span></span><br><span class="line">        <span class="comment">// 这个类可以通过 shared cache 或 data segments 成为已知类，但不允许已经在 dynamic table 中。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// allocatedClasses 是 objc 命名空间中的一个静态变量。</span></span><br><span class="line">        <span class="comment">// A table of all classes (and metaclasses) which have been allocated with objc_allocateClassPair.</span></span><br><span class="line">        <span class="comment">// 已使用 objc_allocateClassPair 分配空间的存储所有 classes（和 metaclasses）的 Set。</span></span><br><span class="line">        <span class="comment">// namespace objc &#123;</span></span><br><span class="line">        <span class="comment">//     static ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把 cls 放入 allocatedClasses 中，然后递归把 metaclass 放入 allocatedClasses 中</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 cls 是否是来自稳定的 Swift ABI 的 Swift 类</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">swiftMetadataInitializer</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class %s with a metadata initializer &quot;</span></span><br><span class="line">                            <span class="string">&quot;is not allowed to be non-lazy&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes We can&#x27;t disallow all Swift classes because of classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">            <span class="comment">// 也禁止 relocatable classes 我们不能因为像 Swift.__EmptyArrayStorage 这样的类而禁止所有 Swift 类</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现 Swift 之外的 classes</span></span><br><span class="line">        <span class="comment">// 对类 cls 执行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回类的真实类结构。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 大概是设置 ro rw 和一些标识位的过程，也包括递归实现父类（supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass), nil);）</span></span><br><span class="line">        <span class="comment">// 和元类（metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);），</span></span><br><span class="line">        <span class="comment">// 然后更新 cls 的父类和元类（cls-&gt;superclass = supercls; cls-&gt;initClassIsa(metacls);），</span></span><br><span class="line">        <span class="comment">// 将 cls 连接到其父类的子类列表（addSubclass(supercls, cls);）（操作 class_rw_t 的 Class firstSubclass; 和 Class nextSiblingClass; 两个成员变量），</span></span><br><span class="line">        <span class="comment">// 修正 cls 的方法列表、协议列表和属性列表，</span></span><br><span class="line">        <span class="comment">// 以及最后的附加任何未完成的 categories（主要包含 method list、protocol list、property list）</span></span><br><span class="line">        <span class="comment">//（objc::unattachedCategories.attachToClass）。</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Realize non-lazy classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.23 ms: IMAGE TIMES: realize non-lazy classes</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-realizeClassWithoutSwift"><a href="#1-realizeClassWithoutSwift" class="headerlink" title="1) realizeClassWithoutSwift()"></a>1) realizeClassWithoutSwift()</h5><p>调用<code>readClass(...)</code>读取类数据只是载入了类的<code>class_ro_t</code>静态数据，因此仍需要进一步配置<code>objc_class</code>的<code>class_rw_t</code>结构体的数据。这个过程为 class realizing，姑且称之为认识/实现类。具体包括：</p><ul><li>配置<code>class_rw_t</code>的<code>RW_REALIZED</code>、<code>RW_REALIZING</code>位；</li><li>根据<code>class_ro_t</code>的<code>RO_META</code>位的值，配置<code>class_rw_t</code>的<code>version</code>；</li><li>因为静态载入的父类、元类有可能被重映射，因此要保证类的父类、元类完成class realizing；</li><li>配置<code>class_rw_t</code>的<code>superclass</code>；</li><li>初始化<code>objc_class</code>的<code>isa</code>指针；</li><li>配置<code>ivarLayout</code>、<code>instanceSize</code>、<code>instanceStart</code>。该步骤非常重要，新版本 runtime 支持 non-fragile instance variables，类的<code>instanceStart</code>、<code>instanceSize</code>会根据父类的<code>instanceSize</code>动态调整，且需要按 WORD 对齐（TODO：后续在独立的文章中详细介绍）；</li><li>配置<code>class_rw_t</code>的<code>RO_HAS_CXX_STRUCTORS</code>、<code>RO_HAS_CXX_DTOR_ONLY</code>、<code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>；</li><li>添加子类/根类；</li><li>将<code>class_ro_t</code>中的基本方法列表、属性列表、协议列表，类的分类（category）中的方法列表等信息添加到<code>class_rw_t</code>中（TODO：后续在独立的文章中详细介绍）；</li></ul><p>实现 class realizing 的代码主要在<code>static Class realizeClassWithoutSwift(Class cls)</code>函数中，只需要知道其大致过程即可。具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* 对类 cls 执行首次初始化，包括分配其读写(read-write)数据。</span></span><br><span class="line"><span class="comment">* 不执行任何 Swift 端初始化。</span></span><br><span class="line"><span class="comment">* 返回类的真实类结构(real class structure)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        <span class="built_in">validateAlreadyRealizedClass</span>(cls);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls == <span class="built_in">remapClass</span>(cls));  <span class="comment">// // 传入的类必须存在于remappedClasses全局哈希表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 曾经是 a future class. 所以 rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        ro = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();  <span class="comment">// cls的rw指向class_rw_t结构体，ro指向class_ro_t结构体，维持原状</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(!isMeta);</span><br><span class="line">        cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常类(Normal class). 需要为rw分配内存，并将ro指针指向 传入的cls-&gt;data()所指向的内存空间</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmptyOrPreoptimizedInDisguise</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) cls-&gt;cache.<span class="built_in">setBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose an index for this class.</span></span><br><span class="line">    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现父类和元类，如果它们还没有实现。</span></span><br><span class="line">    <span class="comment">//   对于根类，这需要在上面设置RW_REALIZED之后完成。</span></span><br><span class="line">    <span class="comment">//   对于根元类，这需要在选择类索引之后完成。</span></span><br><span class="line">    <span class="comment">// (假设这些类都没有 Swift 内容，或者 Swift 的初始化程序(initializers)已经被调用)</span></span><br><span class="line">    <span class="comment">// (如果我们添加对 Swift 类的 ObjC 子类的支持，请修复这个假设是错误的。)</span></span><br><span class="line">    supercls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">getSuperclass</span>()), nil); <span class="comment">// 父类 realizing</span></span><br><span class="line">    metacls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()), nil);  <span class="comment">// 元类 realizing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// 元类不需要来自non pointer ISA 的任何特性</span></span><br><span class="line">        <span class="comment">// 这允许在objc_retain/objc_release中为类提供一个faspath。</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(); <span class="comment">// 配置RW_REQUIRES_RAW_ISA位。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为一些类或平台禁用 non-pointer isa</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;<span class="built_in">getName</span>(), <span class="string">&quot;OS_object&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;<span class="built_in">getSuperclass</span>()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;<span class="built_in">instancesRequireRawIsa</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这也是通过addSubclass()传播的</span></span><br><span class="line">            <span class="comment">// 但是 nonpointer isa 设置需要更早.</span></span><br><span class="line">            <span class="comment">// 特殊情况：instancerequirerawisa不从根类传播到根元类</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 配置RW_REQUIRES_RAW_ISA位</span></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于存在class remapping的可能性，因此需要更新父类及元类</span></span><br><span class="line">    cls-&gt;<span class="built_in">setSuperclass</span>(supercls);</span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整ivarLayout —— Reconcile(协调) instance variable offsets / layout</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整instanceSize —— Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 ro 或从父类传播关联对象禁止标志。</span></span><br><span class="line">    <span class="keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||</span><br><span class="line">        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))</span><br><span class="line">    &#123;</span><br><span class="line">        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此类连接到其父类的子类列表</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);  <span class="comment">// 添加父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rw中需要保存ro中的一些数据，例如ro中的基础方法列表、属性列表、协议列表</span></span><br><span class="line">    <span class="comment">// rw还需要载入分类的方法列表</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="built_in">methodizeClass</span>(cls, previously);  <span class="comment">// methodize: vt. 使…有条理；为…定顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-methodizeClass"><a href="#2-methodizeClass" class="headerlink" title="2) methodizeClass"></a>2) methodizeClass</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls&#x27;s method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;<span class="built_in">ext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装类自己实现的方法和属性。Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 将ro中的基本方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *list = ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, &amp;list, <span class="number">1</span>, YES, <span class="built_in">isBundleClass</span>(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.<span class="built_in">attachLists</span>(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的属性列表添加到rw的属性列表中</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的协议列表添加到rw的协议列表中</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类特殊处理。</span></span><br><span class="line">    <span class="comment">// 根类可以获得额外的方法实现(如果它们还没有的话). 这些适用于类别替换(category replacements)之前。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRootMetaclass</span>()) &#123;</span><br><span class="line">        <span class="built_in">addMethod</span>(cls, @<span class="built_in">selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories. 将分类中的方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当类重定位时，带有类方法的类别categories可能会注册在类本身而不是元类metaclass上。告诉attachToClass去查找这些。</span></span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-处理没有使用的类"><a href="#9-处理没有使用的类" class="headerlink" title="9. 处理没有使用的类"></a>9. 处理没有使用的类</h4><p>第一次启动时并不会执行，我们也可以看到 <code>resolvedFutureClasses</code> 中并没有记录到需要执行 <code>realizeClassWithoutSwift</code> 的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="comment">// 实现 newly-resolved future classes，以防 CF 操作它们</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class is not allowed to be future&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将此类及其所有子类标记为需要原始 isa 指针</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc[56474]: 0.00 ms: IMAGE TIMES: realize future classes</span></span><br><span class="line"><span class="comment">// 打印时间为 0.00 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( DebugNonFragileIvars, OBJC_DEBUG_NONFRAGILE_IVARS, &quot;capriciously rearrange non-fragile ivars&quot;)</span></span><br><span class="line"><span class="comment">//（反复无常地重新排列非脆弱的 ivars）</span></span><br><span class="line"><span class="comment">// 如果开启了 OBJC_DEBUG_NONFRAGILE_IVARS 这个环境变量，则会执行 realizeAllClasses() 函数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-lazily realizes 所有已知 image 中所有未实现的类。(即对已知的 image 中的所有类：懒加载和非懒加载类全部进行实现)</span></span><br><span class="line"><span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">    <span class="built_in">realizeAllClasses</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print preoptimization statistics</span></span><br><span class="line"><span class="comment">// 打印预优化统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)</span></span><br><span class="line"><span class="comment">// 日志预优化由 dyld shared cache 提供</span></span><br></pre></td></tr></table></figure><h4 id="10-log输出"><a href="#10-log输出" class="headerlink" title="10. log输出"></a>10. log输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (PrintPreopt) &#123;</span><br><span class="line">        <span class="comment">// 一些 log 输出...</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、load-images"><a href="#四、load-images" class="headerlink" title="四、load_images()"></a>四、load_images()</h2><h3 id="4-1-load-images-源码实现"><a href="#4-1-load-images-源码实现" class="headerlink" title="4.1 load_images()源码实现"></a>4.1 load_images()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 处理 dyld 映射的 images 中的 +load </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// didInitialAttachCategories 标记加载分类的，默认值为 false，</span></span><br><span class="line">    <span class="comment">// didCallDyldNotifyRegister 标记 _dyld_objc_notify_register 是否调用完成</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">loadAllCategories</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mh 中不包含 +load 就直接不加锁 return（且 without taking locks）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hasLoadMethods 函数是根据 `headerType *mhdr` 的 `__objc_nlclslist` 区和 `__objc_nlcatlist` 区中是否有数据，来判断是否有 +load 函数要执行。(即是否包含非懒加载类和非懒加载分类) </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loadMethodLock 是一把递归互斥锁（加锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现(Discover) +load 方法</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// runtimeLock 加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有要调用的 +load 方法(Class、SuperClass、Category中的)</span></span><br><span class="line">        <span class="built_in">prepare_load_methods</span>((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 调用获取到的所有 +load 方法：从调用中，可以看到依次调用父类、子类、分类的load方法</span></span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-loadAllCategories-分类加载"><a href="#4-2-loadAllCategories-分类加载" class="headerlink" title="4.2 loadAllCategories() 分类加载"></a>4.2 loadAllCategories() 分类加载</h3><h4 id="4-2-1-loadAllCategories"><a href="#4-2-1-loadAllCategories" class="headerlink" title="4.2.1 loadAllCategories()"></a>4.2.1 loadAllCategories()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAllCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-load-categories-nolock"><a href="#4-2-2-load-categories-nolock" class="headerlink" title="4.2.2 load_categories_nolock()"></a>4.2.2 load_categories_nolock()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">isStubClass</span>()) &#123;</span><br><span class="line">                <span class="comment">// Stub(桩) classes永远不会实现(realized)。Stub classes在初始化之前不知道它们的元类，因此我们必须将带</span></span><br><span class="line">                <span class="comment">// 有类方法或属性的类别添加到Stub classes本身。methodizeClass() 将找到它们并将它们适当地添加到元类中。</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 首先，将category注册到其目标类(target class)。</span></span><br><span class="line">                <span class="comment">// 然后，如果class is realized，则重建类的方法列表（等）。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，实例方法、协议、属性添加到类.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  </span><br><span class="line">                    cat-&gt;protocols ||  </span><br><span class="line">                    cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，类方法、协议添加到元类</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  </span><br><span class="line">                    cat-&gt;protocols  ||  </span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对应</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList2, category_t * const, &quot;__objc_catlist2&quot;);</span></span><br><span class="line">    <span class="comment">// _getObjc2CategoryList 取得 DATA 段 &quot;__objc_catlist&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">    <span class="comment">// _getObjc2CategoryList2 取得 DATA 段 &quot;__objc_catlist2&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist2</span>(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-attachCategories"><a href="#4-2-3-attachCategories" class="headerlink" title="4.2.3 attachCategories()"></a>4.2.3 attachCategories()</h4><ul><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中。后面参与编译的Category数据，会在数组的前面。</p></li><li><p>将合并后的分类数据(方法、属性、协议)，插入到类原来数据的前面。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将方法列表、属性和协议从categories附加到class。</span></span><br><span class="line"><span class="comment">// 假设cats_list中的所有categories都已加载，并按加载顺序排序，最老的类别优先。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">attachCategories</span>(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintReplacedMethods)) &#123;</span><br><span class="line">        <span class="built_in">printReplacements</span>(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在发布期间，只有少数类的类别超过 64 个。</span></span><br><span class="line"><span class="comment"> 这使用了一个小stack，避免了 malloc。</span></span><br><span class="line"><span class="comment"> Categories 必须以正确的顺序添加，即从后到前。为了通过分块(chunking)来做到这一点，我们从前到后迭代cats_list，向后构建本地缓冲区，</span></span><br><span class="line"><span class="comment"> 并在块上调用attachLists。 attachLists将列表放在前面，因此最终结果按预期顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                <span class="built_in">prepareMethodLists</span>(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                           NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">            <span class="built_in">flushCaches</span>(cls, __func__, [](Class c)&#123;</span><br><span class="line">                <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">                <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">                <span class="keyword">return</span> !c-&gt;cache.<span class="built_in">isConstantOptimizedCache</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-hasLoadMethods"><a href="#4-3-hasLoadMethods" class="headerlink" title="4.3 hasLoadMethods()"></a>4.3 hasLoadMethods()</h3><p>根据 <code>headerType *mhdr</code> 的 <code>__objc_nlclslist</code> 区和 <code>__objc_nlcatlist</code> 区中是否有数据，来判断是否有 <code>+load</code> 函数要执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn&#x27;t take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 1. 首先去看类列表中，有没有load方法</span></span><br><span class="line">    <span class="comment">// 读取__DATA段(Segment)中的__objc_nlclslist区(section)中的非懒加载类的列表。判断count是否大于1，大于1说明有load方法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 去所有的category中看，是否有load方法</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 读取__DATA段中的__objc_nlcatlist区中非懒加载分类的列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-prepare-load-methods"><a href="#4-3-prepare-load-methods" class="headerlink" title="4.3 prepare_load_methods()"></a>4.3 prepare_load_methods()</h3><p>获取所有要调用的 +load 方法（父类、子类、分类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlclslist 区的数据，即获取所有非懒加载类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23) // class +load has been called</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span></span><br><span class="line">    <span class="comment">// 需要调用 +load 的 classes 列表</span></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span></span><br><span class="line">    <span class="comment">// 用于下面 call_load_methods 函数调用 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部会递归调用，从传入的cls依次向上查找superClass，并调用add_class_to_loadable_list方法，将实现了load方法的类的：Class cls、IMP method收集</span></span><br><span class="line">        <span class="comment">// 父类、子类都通过该方法收集出来，父类们先被收集，即先被调用</span></span><br><span class="line">        <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlcatlist 区的数据，即获取所有非懒加载分类</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历这些分类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// weak-linked class：</span></span><br><span class="line">        <span class="comment">//   如果我们在一个库中使用新版本系统的一些特性API，但又想程序可以在低版本系统上运行，这个时候对这些符号使用弱引用就好。</span></span><br><span class="line">        <span class="comment">//   使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL。</span></span><br><span class="line">        <span class="comment">//   有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用(weak link)整个framework就好</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果分类所属的类没有实现就先去实现</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要调用 +load 的 categories 列表</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          static struct loadable_category *loadable_categories = nil;</span></span><br><span class="line"><span class="comment">          struct loadable_category &#123;</span></span><br><span class="line"><span class="comment">              Category cat;  // may be nil</span></span><br><span class="line"><span class="comment">              IMP method;</span></span><br><span class="line"><span class="comment">          &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历这些分类，并将Category cat、IMP method收集到 loadable_categories 数组中保存</span></span><br><span class="line">        <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-1-schedule-class-load"><a href="#4-3-1-schedule-class-load" class="headerlink" title="4.3.1 schedule_class_load"></a>4.3.1 schedule_class_load</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule_class_load 将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法。（用于后续 call_load_methods 函数调用）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class +load has been called</span></span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RW_LOADED 是 class +load 已被调用的掩码</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">// 优先处理 superclass 的 +load 函数</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line">    <span class="comment">// struct loadable_class &#123;</span></span><br><span class="line">    <span class="comment">//    Class cls;  // may be nil</span></span><br><span class="line">    <span class="comment">//    IMP method;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span></span><br><span class="line">    <span class="comment">// loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span></span><br><span class="line">    <span class="comment">// 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 RW_LOADED 设置到类的 Flags 中</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class cls has just become connected. Schedule it for +load if it implements a +load method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 class 中获取 load 方法</span></span><br><span class="line">    method = cls-&gt;<span class="built_in">getLoadMethod</span>();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 判断当前 loadable_classes 这个数组是否已经被全部占用</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 3. 在当前数组的基础上扩大数组的大小：realloc</span></span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="built_in"><span class="keyword">sizeof</span></span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 把传入的 class 以及对应的方法的实现IMP加到列表中</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-call-load-methods"><a href="#4-4-call-load-methods" class="headerlink" title="4.4 call_load_methods()"></a>4.4 call_load_methods()</h3><p><code>+load</code> 函数的调用顺序：父类 -&gt; 子类 -&gt; 分类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment"> * Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment"> * Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="comment">// 重入调用什么都不做；最外层的调用将完成工作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果正在 loading 则 return，</span></span><br><span class="line">    <span class="comment">// 保证当前 +load 方法同时只有一次被调用</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自动释放池</span></span><br><span class="line">    <span class="keyword">void</span> *pool = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 不停调用类的 + load 方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span></span><br><span class="line">            <span class="built_in">call_class_loads</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 分类中的 +load 函数， 只调用一次 call_category_loads</span></span><br><span class="line">        <span class="comment">// 因为上面的 call_class_loads 函数内部，已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，否则循环就结束了。 </span></span><br><span class="line">        more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    <span class="comment">// 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动释放池进行 pop</span></span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记处理完成了，可以进行下一个了</span></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-关于-load-方法的几个QA"><a href="#4-5-关于-load-方法的几个QA" class="headerlink" title="4.5 关于 +load 方法的几个QA"></a>4.5 关于 +load 方法的几个QA</h3><p>Q: +load的应用？</p><p>A: <code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p><p>由于它的调用<em>不是惰性</em>(non-lazy)的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>的绝佳时机。</p><p>因为 load 调用时机过早，并且当多个 Class 没有关联（继承与派生），我们无法知道 Class 中 load 方法的优先调用关系，所以一般不会在 load 方法中引入其他的类，这是在开发当中需要注意的。</p><p>不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p><p>Q: 重载自己 Class 的 +load 方法时需不需要调父类？</p><p>A: runtime 负责按继承顺序递归调用，所以我们不能调 super</p><p>Q: 在自己 Class 的 +load 方法时能不能替换系统 framework（比如 UIKit）中的某个类的方法实现</p><p>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p><p>Q: 重载 +load 时需要手动添加 @autoreleasepool 么？</p><p>A: 不需要，在 runtime 调用 +load 方法前后是加了 objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop() 的。</p><p>Q: 想让一个类的 +load 方法被调用是否需要在某个地方 import 这个文件</p><p>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，+load 方法就会被调用（Reveal SDK 就是利用这一点，只要引入到工程中就能工作）</p><h2 id="五、类的加载过程总结"><a href="#五、类的加载过程总结" class="headerlink" title="五、类的加载过程总结"></a>五、类的加载过程总结</h2><p>类存在懒加载机制，懒加载类先标记为 future class，正式加载 future class 数据需要调用<code>readClass(...)</code>方法，对 future class 进行重映射（remapping）；</p><p>截止至完成 class realizing，类的加载过程大致如下图所示。</p><ul><li>future class列是懒加载类（future class）的流程，经过了“添加懒加载类-&gt;加载懒加载类信息-&gt;懒加载类重映射-&gt;实现懒加载类”四步；</li><li>normal class列是普通的非懒加载类的加载流程，只经过“加载类信息-&gt;实现类”两个步骤。</li></ul><img src="/images/compilelink/37.png" alt="36" style="zoom:88%;" /><p>类完成 class realizing 后，还需要执行类及分类中的<code>load()</code>方法，最后在程序运行过程中第一次调用类的方法时（实现逻辑在<code>IMP lookUpImpOrForward(...)</code>函数中）触发<code>isInitialized()</code>检查，若未初始化，则需要先执行类的<code>initialize()</code>方法。至此，类正式加载完成。</p><blockquote><p>注意：最后的 class initializing 严格意义上应该不属于类的加载过程，可以将其归为独立的类初始化阶段。类的加载在<code>load()</code>方法执行后就算是完成了。</p></blockquote><h2 id="六、unmap-images"><a href="#六、unmap-images" class="headerlink" title="六、unmap_images()"></a>六、unmap_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Process the given image which is about to be unmapped by dyld.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="built_in">unmap_image_nolock</span>(mh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-unmap-image-nolock"><a href="#6-1-unmap-image-nolock" class="headerlink" title="6.1 unmap_image_nolock()"></a>6.1 unmap_image_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image_nolock</span>(<span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing 1 newly-unmapped image...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find the runtime&#x27;s header_info struct for the image</span></span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;<span class="built_in">mhdr</span>() == (<span class="keyword">const</span> headerType *)mh) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: unloading image for %s%s%s\n&quot;</span>, </span><br><span class="line">                     hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                     hi-&gt;<span class="built_in">mhdr</span>()-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _unload_image(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove header_info from header list</span></span><br><span class="line">    <span class="built_in">removeHeader</span>(hi);</span><br><span class="line">    <span class="built_in">free</span>(hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-unload-image"><a href="#6-2-unload-image" class="headerlink" title="6.2 _unload_image()"></a>6.2 _unload_image()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _unload_image</span></span><br><span class="line"><span class="comment">* Only handles MH_BUNDLE for now.</span></span><br><span class="line"><span class="comment">* Locking: write-lock and loadMethodLock acquired by unmap_image</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _unload_image(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload unattached categories and categories waiting for +load.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore __objc_catlist2. We don&#x27;t support unloading Swift</span></span><br><span class="line">    <span class="comment">// and we never will.</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist = hi-&gt;<span class="built_in">catlist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme for MH_DYLIB cat&#x27;s class may have been unloaded already</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// unattached list</span></span><br><span class="line">        objc::unattachedCategories.<span class="built_in">eraseCategoryForClass</span>(cat, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +load queue</span></span><br><span class="line">        <span class="built_in">remove_category_from_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload classes.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather classes from both __DATA,__objc_clslist </span></span><br><span class="line">    <span class="comment">// and __DATA,__objc_nlclslist. arclite&#x27;s hack puts a class in the latter</span></span><br><span class="line">    <span class="comment">// only, and we need to unload that class if we unload an arclite image.</span></span><br><span class="line"></span><br><span class="line">    objc::DenseSet&lt;Class&gt; classes&#123;&#125;;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classlist = hi-&gt;<span class="built_in">nlclslist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First detach classes from each other. Then free each class.</span></span><br><span class="line">    <span class="comment">// This avoid bugs where this loop unloads a subclass before its superclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">remove_class_from_loadable_list</span>(cls);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls-&gt;<span class="built_in">ISA</span>(), YES);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">free_class</span>(cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        <span class="built_in">free_class</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX FIXME -- Clean up protocols:</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/9033191&gt; Support unloading protocols at dylib/image unload time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme DebugUnload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903965201530888#heading-0">Runtime源代码解读2（类和对象）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前文回顾&quot;&gt;&lt;a href=&quot;#一、前文回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前文回顾&quot;&gt;&lt;/a&gt;一、前文回顾&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://tenloy.github.io/2021/09/27/compil</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</title>
    <link href="https://tenloy.github.io/2021/10/18/compile-dynamic-link.html"/>
    <id>https://tenloy.github.io/2021/10/18/compile-dynamic-link.html</id>
    <published>2021-10-18T04:26:09.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、动态链接"><a href="#一、动态链接" class="headerlink" title="一、动态链接"></a>一、动态链接</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个个单独的可执行文件。</p><p>动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前主流的操作系统几乎都支持动态链接这种方式。</p><p>link 这个过程就是将加载进来的二进制变为可用状态的过程。简单来说就是：<code>rebase =&gt; binding</code>。先来介绍动态链接中的几个概念：</p><h3 id="1-1-rebase"><a href="#1-1-rebase" class="headerlink" title="1.1 rebase"></a>1.1 rebase</h3><p>rebase就是指针修正的过程。</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。而<strong>data</strong>段中的数据也会存在<strong>引用</strong>关系。 我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(相对于text段开始的偏移)。 </p><p>当二进制加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。 这个过程就是rebase的过程。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h3 id="1-2-bind"><a href="#1-2-bind" class="headerlink" title="1.2 bind"></a>1.2 bind</h3><blockquote><p>“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。</p></blockquote><p>bind就是符号绑定的过程。</p><p>为什么要bind? 因为符号在不同的库里面。</p><p>举个简单的例子，我们代码里面调用了 <code>NSClassFromString</code>. 但是<code>NSClassFromString</code>的代码和符号都是在 <code>Foundation.framework</code> 这个动态库里面。而在程序未加载之前，我们的代码是不知道<code>NSLog</code>在哪里的，于是编译器就编译了一个 <strong>stub</strong> 来调用 <code>NSClassFromString</code>:</p><img src="/images/compilelink/39.png" alt="39" style="zoom:97%;" /><p>可以看到，我们的代码里面直接从 pc + 0x3701c的地方取出来一个值，然后直接br， 也就是认为这个值就是 <code>NSClassFromString</code>的真实地址了。我们再看看这个位置的值是啥：</p><img src="/images/compilelink/40.png" alt="40" style="zoom:100%;" /><p>也就是说，这块地址的8个字节会在<strong>bind</strong>之后存入的就是 <code>NSClassFromString</code>的代码地址， 那么就实现了真正调用 <code>NSClassFromString</code>的过程。</p><p>上面我们知道了为啥要<strong>bind</strong>. 那是如何bind的呢？ bind又分为哪些呢？</p><h4 id="1-2-1-怎么bind"><a href="#1-2-1-怎么bind" class="headerlink" title="1.2.1 怎么bind"></a>1.2.1 怎么bind</h4><p>首先 mach-o 的 LoadCommand里面的会有一个cmd来描述 dynamic loader info，数据结构与示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下的偏移量是相对于目标文件/可执行文件的起始地址，注意后者的起始地址一般不会是0，寻址时要加上</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dyld_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmd;            <span class="comment">/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmdsize;        <span class="comment">/* sizeof(struct dyld_info_command) */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_off;     <span class="comment">/* file offset to rebase info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_size;    <span class="comment">/* size of rebase info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_off;       <span class="comment">/* file offset to binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_size;      <span class="comment">/* size of binding info  */</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Some C++ programs require dyld to unique symbols so that all images in the process use the same copy of some code/data. </span></span><br><span class="line"><span class="comment">    This step is done after binding. </span></span><br><span class="line"><span class="comment">    The content of the weak_bind info is an opcode stream like the bind_info. But it is sorted alphabetically by symbol name. This enable dyld to walk all images with weak binding information in order and look for collisions. </span></span><br><span class="line"><span class="comment">    If there are no collisions, dyld does no updating. That means that some fixups are also encoded in the bind_info. </span></span><br><span class="line"><span class="comment">    For instance, all calls to &quot;operator new&quot; are first bound to libstdc++.dylib using the information in bind_info. Then if some image overrides operator new that is detected when the weak_bind information is processed and the call to operator new is then rebound.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_off;  <span class="comment">/* file offset to weak binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_size; <span class="comment">/* size of weak binding info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_off;  <span class="comment">/* file offset to lazy binding info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_size; <span class="comment">/* size of lazy binding infs */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_off;     <span class="comment">/* file offset to export info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_size;    <span class="comment">/* size of export infs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析出来会得到这样的信息：</p><ul><li><code>rebase</code>：就是针对 “mach-o在加载到虚拟内存中不是固定的首地址” 这一现象做数据修正的过程。一般可执行文件在没有ASLR造成的首地址不固定的情况下，装载进虚拟地址中的首地址都是固定的，比如：Linux下一般都是<code>0x08040000</code>，Windows下一般都是<code>0x0040000</code>，Mach-O的TEXT地址在__PageZero之后的<code>0x100000000</code>地址.</li><li><code>binding</code>：就是将这个二进制调用的外部符号进行绑定的过程。 比如我们objc代码中需要使用到NSObject，即符号<code>_OBJC_CLASS_$_NSObject</code>，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</li><li><code>lazyBinding</code>：就是在加载动态库的时候不会立即binding，当时当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。 lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。</li><li><code>weakBinding</code>：OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</li></ul><img src="/images/compilelink/41.png" alt="41" style="zoom:90%;" /><p>可以看到，这里面记录了二进制data段里面哪些是 rebase信息，哪些是binding信息：</p><img src="/images/compilelink/42.png" alt="42" style="zoom:78%;" /><p>可以看到binding info的数据结构，bind的过程根据不同的opcode解析出不同的信息，在opcode为<code>BIND_OPCODE_DO_BIND</code>的时候，会执行<code>bindLocation</code>来进行bind。</p><p>截取了 bindLocation 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">ImageLoaderMachO::bindLocation</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context,...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// do actual update</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>* locationToFix = (<span class="keyword">uintptr_t</span>*)location;</span><br><span class="line">    <span class="keyword">uint32_t</span>* loc32;</span><br><span class="line">    <span class="keyword">uintptr_t</span> newValue = value+addend;</span><br><span class="line">    <span class="keyword">uint32_t</span> value32;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_POINTER:</span><br><span class="line">            <span class="comment">// test first so we don&#x27;t needless dirty pages</span></span><br><span class="line">            <span class="keyword">if</span> ( *locationToFix != newValue )</span><br><span class="line">                *locationToFix = newValue;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_ABSOLUTE32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)newValue;</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_PCREL32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)(newValue - (((<span class="keyword">uintptr_t</span>)locationToFix) + <span class="number">4</span>));</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad bind type %d&quot;</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， bind过程也不是单纯的就是把符号地址填过来就好了， 还有type和addend的逻辑。不过一般不多见，大部分都是<code>BIND_TYPE_POINTER</code>.</p><p>addend 一般用于要bind某个数组中的某个子元素时，记录这个子元素在数组的偏移。</p><h4 id="1-2-2-Lazy-Bind"><a href="#1-2-2-Lazy-Bind" class="headerlink" title="1.2.2 Lazy Bind"></a>1.2.2 Lazy Bind</h4><p>延迟加载是为了启动速度。上面看到bind的过程，发现bind的过程需要查到对应的符号再进行bind. 如果在启动的时候，所有的符号都立即bind成功，那么势必拖慢启动速度。</p><p>其实很多符号都是LazyBind的。就是第一次调用到才会真正的bind.</p><p>其实刚才截图的 <code>imp___la_symbol_ptr__objc_getClass</code> 就是一个 LazyBind 的符号。 图中的 0x10d6e8 指向了 <code>stub_helper</code> 这个section中的代码。</p><img src="/images/compilelink/43.png" alt="43" style="zoom:90%;" /><p>如上图中</p><ul><li>先取了 <code>0x10d6f0</code> 的 4个字节数据存入 w16. 这个数据其实是 lazy bind info段的偏移</li><li>然后走到 0x10d6d0, 取出 ImageLoader cache, 存入 x17</li><li>把 lazy bind info offset 和 ImageLoaderCache 存入栈上。</li><li>然后取出 dyld_stub_binder的地址，存入x16. 跳转 dyld_stub_binder</li><li>dyld_stub_binder 会根据传入的 lazy bind info的 offset来执行真正的bind. bind结束后，刚才看到的 <code>0x10d6e8</code> 这个地址就变成了 <code>NSClassFromString</code>。就完成了LazyBind的过程。</li></ul><p><code>dyld_stub_binder</code>的源码此处不再展示。</p><h4 id="1-2-3-Weak-Bind"><a href="#1-2-3-Weak-Bind" class="headerlink" title="1.2.3 Weak Bind"></a>1.2.3 Weak Bind</h4><p>OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</p><h2 id="二、库-静态库和动态库"><a href="#二、库-静态库和动态库" class="headerlink" title="二、库: 静态库和动态库"></a>二、库: 静态库和动态库</h2><p>库(Library)，是我们在开发中的重要角色，库的作用在于代码共享、模块分割以及提升良好的工程管理实践。说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p><p>为什么要用库？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件(<strong>静态库和动态库的共同点就是不会暴露内部具体的代码信息</strong>)。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p><p>根据库在使用的时候 Link 时机或者说方式(静态链接、动态链接)，库分为静态库和动态库。</p><h3 id="2-1-静态库"><a href="#2-1-静态库" class="headerlink" title="2.1 静态库"></a>2.1 静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，linux 下的.a，Mac 下的 .a .framework）。之所以叫做静态，是因为静态库在<code>链接时</code>会被完整地拷贝一份到可执行文件中(会使最终的可执行文件体积增大)。被多个程序使用就会有多份冗余拷贝。如果更新静态库，需要重新编译一次可执行文件，重新链接新的静态库。</p><h3 id="2-2-动态库"><a href="#2-2-动态库" class="headerlink" title="2.2 动态库"></a>2.2 动态库</h3><p>动态库即动态链接库。与静态库相反，动态库在编译时并不会被拷贝到可执行文件中，可执行文件中只会存储指向动态库的引用(使用了动态库的符号、及对应库的路径等)。等到程序<code>运行时</code>，动态库才会被真正加载进来，此时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。</p><p>动态库的优点是：</p><ul><li><strong>减少可执行文件体积</strong>：相比静态链接，动态链接在编译时不需要打进去(不需要拷贝到每个可执行文件中)，所以可执行文件的体积要小很多。</li><li><strong>代码共用</strong>：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份(因为这个原因，动态库也被称作<strong>共享库</strong>)。</li><li><strong>易于维护</strong>：使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</li></ul><p>常见的可执行文件的形式：</p><ul><li><p>Linux系统中，ELF动态链接文件被称为<strong>动态共享对象</strong>(<code>DSO，Dynamic SharedObjects</code>)，简称共享对象，一般都是以 <code>.so</code> 为扩展名的一些文件；</p></li><li><p>Windows系统中，动态链接文件被称为<strong>动态链接库</strong>(<code>Dynamical Linking Library</code>)，通常就是我们平时很常见的以 <code>.dll</code> 为扩展名的文件；</p></li><li><p>OS X 和其他 UN*X 不同，它的库不是“共享对象(.so)”，因为 OS X 和 ELF 不兼容，而且这个概念在 Mach-O 中不存在。OS 中的动态链接文件一般称为<strong>动态库</strong>文件，带有 <code>.dylib</code>、<code>.framework</code>及链接符号<code>.tbd</code>。</p><ul><li>库文件可以在 <code>/usr/lib</code> 目录下找到(这一点和其他所有的 UN*X 一样，不同的是在OS X 和 iOS 中没有/lib目录)，这些库已被设置全局可用。</li><li>我们在使用系统的.dylib动态库时，经常发现没有头文件，其实这些库的头文件都位于一个已知位置，如<code>/usr/local/include</code>、<code>/usr/include</code>等 (后者文件夹在新系统中由SDK附带了，见 <a href="https://apple.stackexchange.com/questions/372032/usr-include-missing-on-macos-catalina-with-xcode-11">/usr/include missing on macOS Catalina (with Xcode 11)</a> )。</li></ul></li><li><p>OS X 与其他 UN*X 另一点不同是：没有<code>libc</code>。开发者可能熟悉其他 UN*X 上的C运行时库(或Windows上的MSVCRT) 。但是在 OS X 上对应的库<code>/usr/lib/libc.dylib</code>只不过是指向<code>libSystem.B.dylib</code>的符号链接。</p></li><li><p>以C语言运行库为例，补充一下<strong>运行库</strong>的概念：任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。这样的一个代码集合称之为运行时库（Runtime Library）。而C语言的运行库，即被称为C运行库（CRT）。<strong>运行库顾名思义是让程序能正常运行的一个库。</strong></p></li></ul><h3 id="2-3-两个非常重要的库-LibSystem、libobjc"><a href="#2-3-两个非常重要的库-LibSystem、libobjc" class="headerlink" title="2.3  两个非常重要的库 LibSystem、libobjc"></a>2.3  两个非常重要的库 LibSystem、libobjc</h3><p>libSystem 提供了 LibC(运行库) 的功能，还包含了在其他 UN*X 上原本由其他一些库提供的功能，列几个熟知的：</p><ul><li>GCD libdispatch</li><li>C语言库 libsystem_c</li><li>Block libsystem_blocks</li><li>加密库(比如常见的md5函数) libcommonCrypto</li></ul><p>还有些库(如数学库 libm、线程库 libpthread)虽然在/usr/lib中看到虽然有这些库的文件，但都是libSystem.B.dylib的替身/快捷方式，即都是指向libSystem的符号链接。</p><p>libSystem 库是系统上所有二进制代码的绝对先决条件，即所有的二进制文件都依赖这个库，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。这个库还是/usr/ib/system目录下一些库的保护伞库(通过<code>LC_REEXPORT_LIB</code>加载命令重新导出了符号) 。</p><p>总结来说：<strong>libSystem在运行库的基础上，增加了一些对底层系统调用和内核服务的抽象接口。</strong>所以在下面的流程中，会发现<strong>libSystem是先于其他动态库初始化</strong>的。</p><p><strong>libobjc</strong>与libsystem一样，都是默认添加的lib，包含iOS开发天天接触的objc runtime.</p><h3 id="2-4-补充两个概念-模块与image"><a href="#2-4-补充两个概念-模块与image" class="headerlink" title="2.4 补充两个概念: 模块与image"></a>2.4 补充两个概念: 模块与image</h3><ul><li><code>程序模块</code>：从本质上讲，普通可执行程序和动态库中都包含指令和数据，这一点没有区别。在使用动态库的情况下，程序本身被分为了程序主要模块(<code>Program1</code>)和动态链接文件(<code>Lib.so</code> <code>Lib.dylib</code> <code>Lib.dll</code>)，但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程序模块时可以指程序主模块也可以指动态链接库。</li><li><code>映像(image)</code> ，通常也是指这两者。可执行文件/动态链接文件，在装载时被直接映射到进程的虚拟地址空间中运行，它是进程的虚拟空间的映像，所以很多时候，也被叫做映像/镜像文件(Image File)。</li></ul><h3 id="2-5-a-dylib与-framework的区别"><a href="#2-5-a-dylib与-framework的区别" class="headerlink" title="2.5 .a/.dylib与.framework的区别"></a>2.5 .a/.dylib与.framework的区别</h3><p>前者是纯二进制文件，文件不能直接使用，需要有.h文件的配合，后者除了二进制文件、头文件还有资源文件，代码可以直接导入使用(<code>.a + .h + sourceFile = .framework</code>)。</p><p>Framework 是苹果公司的 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件（nib/xib、图片、国际化文本）、说明文档等集中在一起，方便开发者使用。<strong>Framework 其实是资源打包的方式，和静态库动态库的本质是没有什么关系</strong>(<strong>所以framework文件可以是静态库也可以是动态库，iOS 中用到的所有系统 framework 都是动态链接的</strong>)。</p><p>在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。但是iOS平台在 iOS 8 之前，苹果不允许第三方框架使用动态方式加载，开发者可以使用的动态 Framework 只有苹果系统提供的 UIKit.Framework，Foundation.Framework 等。开发者要进行模块化，只能打包成静态库文件：<code>.a + 头文件</code>、<code>.framework</code>(这时候的 Framework 只支持打包成静态库的 Framework)，前种方式打包不够方便，使用时也比较麻烦，没有后者的便捷性。</p><p>iOS 8/Xcode 6 推出之后，允许开发者有条件地创建和使用动态库，支持了动态 Framework。开发者打包的动态 Framework 和系统的 UIKit.Framework 还是有很大区别。后者不需要拷贝到目标程序中，是一个链接。而前者在打包和提交 app 时会<strong>被放到 app  main bundle 的根目录中，运行在沙盒里</strong>，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载，因此苹果又把这种 Framework 称为 Embedded Framework(可植入性 Framework)。</p><p>不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p><p>数量上，苹果公司建议最多使用6个非系统动态库。</p><p>然后就是，在上传App Store打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有Embedded 的动态库，所以如果是动态从服务器更新的动态库，是签名不了的，sandbox验证动态库的签名非法时，就会造成crash。因此应用插件化、软件版本实时模块升级等功能在iOS上无法实现。不过在 in house(企业发布) 包和develop 包中可以使用。</p><h2 id="三、Mach-O-文件的动态链接-—-dyld"><a href="#三、Mach-O-文件的动态链接-—-dyld" class="headerlink" title="三、Mach-O 文件的动态链接 — dyld"></a>三、Mach-O 文件的动态链接 — dyld</h2><h3 id="3-1-dyld2与dyld3"><a href="#3-1-dyld2与dyld3" class="headerlink" title="3.1 dyld2与dyld3"></a>3.1 dyld2与dyld3</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。</p></blockquote><p>在2017WWDC，Apple推出了Dyld3。在iOS 13系统中，iOS全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p><p>Dyld2是从程序开始时才开始执行的，而Dyld3则将Dyld2的一些过程进行了分解。</p><img src="/images/compilelink/44.png" alt="44" style="zoom:60%;" /><p>Dyld3最大的特点是部分进程外的，分为out-of-process，和in-process。即操作系统在当前app进程之外完成了一部分dyld2在进程内的工作。以达到提升app启动性能和增强安全的目的。</p><p>out-process会做：</p><ul><li>分析Mach-O Headers</li><li>分析以来的动态库</li><li>查找需要的Rebase和Bind的符号</li><li>将上面的分析结果写入缓存。</li></ul><p>in-process会做：</p><ul><li>读取缓存的分析结果</li><li>验证分析结果</li><li>加载Mach-O文件</li><li>Rebase&amp;Bind</li><li>Initializers</li></ul><p>使用了Dyld3后，App的启动速度会进一步提高。</p><p>而WWDC2019 苹果宣布针对Dyld3做了以下优化：</p><ul><li><strong>避免链接无用的framework；</strong></li><li><strong>避免在app启动时链接动态库；</strong></li><li><strong>硬链接所有依赖项</strong></li></ul><h3 id="3-2-dyld的工作机制"><a href="#3-2-dyld的工作机制" class="headerlink" title="3.2 dyld的工作机制"></a>3.2 dyld的工作机制</h3><p>在<a href="https://www.jianshu.com/p/bff19e0a80d4">Mach-O 文件的装载</a>完成，即内核加载器做完相关的工作后，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DYLINKER</code>加载命令指定的动态链接器在用户态完成的。通常情况下，使用的是 <code>/usr/lib/dyld</code> 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。</p><p>链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。</p><blockquote><p>dyld是一个用户态的进程。dyld不属于内核的一部分，而是作为一个单独的开源项目由苹果进行维护的(当然也属于Darwin的一部分) ，点击查看<a href="http://www.opensource.apple.com/source/dyld">项目网址</a>。从内核的角度看，dyld是一个可插入的组件，可以替换为第三方的链接器。dyld对应的二进制文件有两个，分别是<code>/usr/lib/dyld</code>、<code>/urs/lib/system/libdyld.dylib</code>，前者<code>通用二进制格式(FAT)</code>，filetype为<code>MH_DYLINKER</code>，后者是普通的动态链接库格式(Mach-O)。</p></blockquote><img src="/images/compilelink/30.png" style="zoom:80%;" /><p>从调用堆栈上看dyld、libdyld.dylib的作用：</p><img src="/images/compilelink/31.png" style="zoom:90%;" /><p>前者<code>dyld</code>是<strong>一段可执行的程序</strong>，内核将其映射至进程地址空间，将控制权交给它进行执行，递归加载所需的动态库，其中也会将动态链接器的另一种形式的<code>libdyld.dylib</code>加载，因为动态链接器dyld其不但在应用的装载阶段起作用，在主程序运行的时候，其充当<strong>一个库</strong>的角色，还提供了<code>dlopen</code>、<code>dlsym</code>等api，可以让主程序<strong>显式运行时链接</strong>(见下文)。(关于这一点，没有找到明确的文档说明。如果有人有正确的理解，请一定要评论区告诉我一下，感激不尽)</p><blockquote><p>Linux中，动态链接库的存在形式稍有不同，Linux动态链接器本身是一个共享对象(动态库)，它的路径是/lib/ld-linux.so.2，这实际上是个软链接，它指向/lib/ld-x.y.z.so， 这个才是真正的动态连接器文件。共享对象其实也是ELF文件，它也有跟可执行文件一样的ELF文件头（包括e_entry、段表等）。动态链接器是个非常特殊的共享对象，它不仅是个共享对象，还是个可执行的程序，可以直接在命令行下面运行。因为ld.so是共享对象，又是动态链接器，所以本来应由动态链接器进行的共享对象的重定位，就要靠自己来，又称“自举”。自举完成后ld.so以一个共享对象的角色，来实现动态链接库的功能。</p></blockquote><p>我们需要了解一下<code>LC_LOAD_DYLIB</code>这个加载命令，这个命令会告诉链接器在哪里可以找到这些符号，即动态库的相关信息(ID、时间戳、版本号、兼容版本号等)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> <span class="title">name</span>;</span>              <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;             <span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;       <span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version; <span class="comment">/* library&#x27;s compatibility vers number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;         <span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;     <span class="comment">/* includes pathname string */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> <span class="title">dylib</span>;</span>   <span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接器要加载每一个指定的库，并且搜寻匹配的符号。每个被链接的库(Mach-O格式)都有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过<code>LC_SYMTAB</code>加载命令指定的 symoff 找到。对应的符号名称在 stroff， 总共有 nsyms 条符号信息。</p><p>下面是<code>LC_SYMTAB</code>的load_command：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 &lt;mach-o/dyld.h&gt; 动态库头文件中，也为我们提供了查询所有动态库 image 的方法(也可以使用<code>otool -L 文件路径</code>命令来查看，但看着没代码全)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listImages</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> ic = _dyld_image_count();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %d images\n&quot;</span>, ic);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %p\t%s\t(slide: %p)\n&quot;</span>,</span><br><span class="line">               i,</span><br><span class="line">               _dyld_get_image_header(i),</span><br><span class="line">               _dyld_get_image_name(i),</span><br><span class="line">               _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listImages();  <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: </span><br><span class="line">  ...</span><br><span class="line">  <span class="number">45</span>: <span class="number">0x1ab331000</span>/usr/lib/libobjc.A.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  <span class="number">46</span>: <span class="number">0x1e1767000</span>/usr/lib/libSystem.B.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br><span class="line">  <span class="number">70</span>: <span class="number">0x107220000</span>/usr/lib/system/introspection/libdispatch.dylib(slide: <span class="number">0x107220000</span>)</span><br><span class="line">  <span class="number">71</span>: <span class="number">0x1ab412000</span>/usr/lib/system/libdyld.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="四、dyld工作流程详解"><a href="#四、dyld工作流程详解" class="headerlink" title="四、dyld工作流程详解"></a>四、dyld工作流程详解</h2><p>通过源码来看一下dyld的工作流程，只是部分片段，详细的可以下载源码。</p><h3 id="4-1-dyld-start"><a href="#4-1-dyld-start" class="headerlink" title="4.1 __dyld_start"></a>4.1 __dyld_start</h3><p>下面的汇编代码很简单，如果不清楚，可以看一下这篇汇编入门文章<a href="https://www.jianshu.com/p/23a9110cff96">iOS需要了解的ARM64汇编</a>。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if __arm64__</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.align</span> <span class="number">2</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line"><span class="symbol">__dyld_start:</span></span><br><span class="line"><span class="comment">; 操作fp栈帧寄存器，sp栈指针寄存器，配置函数栈帧</span></span><br><span class="line"><span class="keyword">mov</span> x28, <span class="built_in">sp</span></span><br><span class="line"><span class="keyword">and</span>     <span class="built_in">sp</span>, x28, #~<span class="number">15</span><span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line"><span class="keyword">mov</span>x0, <span class="number">#0</span></span><br><span class="line"><span class="keyword">mov</span>x1, <span class="number">#0</span></span><br><span class="line">stpx1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!<span class="comment">// make aligned terminating frame</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">fp</span>, <span class="built_in">sp</span><span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line"><span class="keyword">sub</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="comment">; L(long 64位) P(point)，在前面的汇编一文中，我们已经知道：r0 - r30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 </span></span><br><span class="line"><span class="comment">; 当使用 x0 - x30访问时，它就是一个64位的数。</span></span><br><span class="line"><span class="comment">; 当使用 w0 - w30访问时，访问的是这些寄存器的低32位</span></span><br><span class="line"><span class="comment">#if __LP64__       </span></span><br><span class="line"><span class="keyword">ldr</span>     x0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     x1, [x28, <span class="number">#8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     x2, x28, <span class="number">#16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="keyword">ldr</span>     w0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     w1, [x28, <span class="number">#4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     w2, w28, <span class="number">#8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="keyword">adrp</span>x3,___dso_handle<span class="comment">@page</span></span><br><span class="line"><span class="keyword">add</span> x3,x3,___dso_handle<span class="comment">@pageoff // get dyld&#x27;s mh in to x4</span></span><br><span class="line"><span class="keyword">mov</span>x4,<span class="built_in">sp</span>                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"><span class="comment">; 从上面的汇编代码可以看到，主要是在设置dyldbootstrap::start函数调用栈的配置，在前面的汇编一文中，我们已经知道函数的参数，主要通过x0-x7几个寄存器来传递</span></span><br><span class="line"><span class="comment">; 可以看到函数需要的几个参数app_mh，argc，argv，dyld_mh，&amp;startGlue分别被放置到了x0 x1 x2 x4 x5寄存器上</span></span><br><span class="line">    <span class="comment">; call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line"><span class="keyword">bl</span>__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line"><span class="keyword">mov</span>x16,x0                  <span class="comment">// save entry point address in x16</span></span><br></pre></td></tr></table></figure><h3 id="4-2-dyldbootstrap-start"><a href="#4-2-dyldbootstrap-start" class="headerlink" title="4.2 dyldbootstrap::start()"></a>4.2 dyldbootstrap::start()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//  主要做的是dyld的引导工作，一般这个工作通常由 dyld 和 crt(C运行时库 C Run-Time Libray )来完成。但dyld自身加载的时候，只能由自己来做。</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有slide，那么需要重定位，必须在使用任何全局变量之前，进行该操作</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader); </span><br><span class="line">    <span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">    ++apple;</span><br><span class="line">    <span class="comment">// 为stack canary设置一个随机值</span></span><br><span class="line">    <span class="comment">// stack canary：栈的警惕标志(stack canary)，得名于煤矿里的金丝雀，用于探测该灾难的发生。具体办法是在栈的返回地址的存储位置之前放置一个整形值，该值在装入程序时随机确定。栈缓冲区攻击时从低地址向高地址覆盖栈空间，因此会在覆盖返回地址之前就覆盖了警惕标志。返回返回前会检查该警惕标志是否被篡改。</span></span><br><span class="line">    __guard_setup(apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">    <span class="comment">// 执行 dyld 中所有的C++初始化函数。run all C++ initializers inside dyld</span></span><br><span class="line">    runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 完成所有引导工作，调用dyld::main(). now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">    <span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-dyld-main"><a href="#4-3-dyld-main" class="headerlink" title="4.3 dyld::_main()"></a>4.3 dyld::_main()</h3><p>dyld也是Mach-O文件格式的，文件头中的 filetype 字段为<code>MH_DYLINKER</code>，区别与可执行文件的 <code>MH_EXECUTE</code>，所以dyld也是有main()函数的(默认名称是mian()，也可以自己修改入口地址的)。</p><p>因为这个函数太长，写在一起不好阅读，所以按照流程功能点，自上而下分为一个个代码片段。关键的函数会在代码中注释说明</p><h4 id="方法名及说明"><a href="#方法名及说明" class="headerlink" title="方法名及说明"></a>方法名及说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld的入口指针，内核加载dyld，跳转到__dyld_start函数：进行了一些寄存器设置，然后就调用了该函数。Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">// 返回主程序模块的mian()函数地址，__dyld_start中会跳到该地址。Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h4 id="第一步-配置上下文信息，设置运行环境，处理环境变量"><a href="#第一步-配置上下文信息，设置运行环境，处理环境变量" class="headerlink" title="第一步 配置上下文信息，设置运行环境，处理环境变量"></a>第一步 配置上下文信息，设置运行环境，处理环境变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第一步，设置运行环境</span></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">hexToBytes</span>(_simple_getenv(apple, <span class="string">&quot;executable_cdhash&quot;</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace dyld&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">&quot;dyld_file&quot;</span>));</span><br><span class="line"><span class="comment">// Trace the main executable&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>(mainExecutableMH, _simple_getenv(apple, <span class="string">&quot;executable_file&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">    ......</span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch started&quot;</span>);</span><br><span class="line"><span class="comment">// 传入Mach-O头部以及一些参数设置上下文信息</span></span><br><span class="line"><span class="built_in">setContext</span>(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getcwd</span>(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 获取进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式</span></span><br><span class="line">    <span class="built_in">configureProcessRestrictions</span>(mainExecutableMH, envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line"><span class="built_in">checkEnvironmentVariables</span>(envp);</span><br><span class="line"><span class="comment">// 在DYLD_FALLBACK为空时设置默认值</span></span><br><span class="line"><span class="built_in">defaultUninitializedFallbackPaths</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line"><span class="built_in">printOptions</span>(argv);</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line"><span class="built_in">printEnvironmentVariables</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 获取当前程序架构</span></span><br><span class="line"><span class="built_in">getHostInfo</span>(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure><h4 id="第二步-加载共享缓存"><a href="#第二步-加载共享缓存" class="headerlink" title="第二步 加载共享缓存"></a>第二步 加载共享缓存</h4><p>在iOS系统中，UIKit，Foundation等基础库是每个程序都依赖的，需要通过dyld（位于/usr/lib/dyld）一个一个加载到内存，然而如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。iOS的dyld采用了一个共享库预链接缓存，苹果从iOS 3.0开始将所有的基础库都移到了这个缓存中，合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下(OS X中是在/private/var/db/dyld目录)，按不同的架构保存分别保存着，如dyld_shared_cache_armv7。而且在OS X中还有一个辅助的.map文件，而iOS中没有。</p><p>如果在iOS上搜索大部分常见的库，比如所有二进制文件都依赖的libSystem，是搜索不到的，这个库的文件不在文件系统中，而是被缓存文件包含。关于如何从共享缓存中提取我们想看的库，可以参考链接<a href="https://www.dllhook.com/post/238.html#toc_1">dyld详解第一部分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第二步，加载共享缓存 <span class="comment">// load shared cache</span></span></span><br><span class="line">   <span class="comment">// 检查共享缓存是否开启，iOS必须开启</span></span><br><span class="line"><span class="built_in">checkSharedRegionDisable</span>((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * mapSharedCache加载共享缓存库，其中调用loadDyldCache函数，展开loadDyldCache，有这么几种情况：</span></span><br><span class="line"><span class="comment">        * 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程）</span></span><br><span class="line"><span class="comment">        * 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide</span></span><br><span class="line"><span class="comment">        * 共享缓存不是第一次被加载，那么就不做任何处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="built_in">mapSharedCache</span>();</span><br><span class="line">&#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="built_in">addDyldImageToUUIDList</span>();</span><br></pre></td></tr></table></figure><h4 id="第三步-实例化主程序image"><a href="#第三步-实例化主程序image" class="headerlink" title="第三步 实例化主程序image"></a>第三步 实例化主程序image</h4><h5 id="1-源码解读"><a href="#1-源码解读" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>ImageLoader：前面已经提到image(映像文件)常见的有可执行文件、动态链接库。ImageLoader 作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载。</strong></p><p>从下面可以看到大概的顺序：先将动态链接的 image 递归加载，再依次进行可执行文件的链接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 展开 instantiateFromLoadedImage 函数, 可以看到主要分三步:</span></span><br><span class="line"><span class="comment"> * isCompatibleMachO()：检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line"><span class="comment"> * instantiateMainExecutable()： 就是实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line"><span class="comment"> * addImage()： 添加到 allImages中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">gLinkContext.mainExecutableCodeSigned = <span class="built_in">hasCodeSignatureLoadCommand</span>(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line"><span class="built_in">checkVersionedPaths</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">proc_regionfilename</span>(<span class="built_in">getpid</span>(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = <span class="built_in">strdup</span>(dyldPathBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-instantiateFromLoadedImage"><a href="#2-instantiateFromLoadedImage" class="headerlink" title="2. instantiateFromLoadedImage"></a>2. instantiateFromLoadedImage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">//if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="built_in">addImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw &quot;main executable not a known format&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中，我们大致可以看到加载有三步：</p><ul><li><code>isCompatibleMachO</code> 是检查mach-o的subtype是否是当前cpu可以支持； </li><li><code>instantiateMainExecutable</code> 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </li><li><code>addImage</code> 添加到 allImages中。</li></ul><h4 id="第四步-加载插入的动态库"><a href="#第四步-加载插入的动态库" class="headerlink" title="第四步 加载插入的动态库"></a>第四步 加载插入的动态库</h4><p>通过遍历 DYLD_INSERT_LIBRARIES 环境变量，调用 loadInsertedDylib 加载。</p><p>在三方App的Mach-O文件中通过修改DYLD_INSERT_LIBRARIES的值来加入我们自己的动态库，从而注入代码，hook别人的App。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第四步 加载插入的动态库</span></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line"><span class="built_in">loadInsertedDylib</span>(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库数量</span></span><br><span class="line">sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="第五步-链接主程序-重点link"><a href="#第五步-链接主程序-重点link" class="headerlink" title="第五步 链接主程序(重点link())"></a>第五步 链接主程序(重点link())</h4><h5 id="1-源码解读-1"><a href="#1-源码解读-1" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第五步 链接主程序</span></span><br><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line"><span class="keyword">if</span> ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line"><span class="comment">// previous link() on main executable has already adjusted its internal pointers for ASLR </span></span><br><span class="line">    <span class="comment">// work around that by rebasing by inverse amount</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">rebase</span>(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        link() 函数的递归调用函数堆栈形式</span></span><br><span class="line"><span class="comment">          ▼ ImageLoader::link() //启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line"><span class="comment">            ▼ recursiveLoadLibraries() //进行所有需求动态库的加载</span></span><br><span class="line"><span class="comment">              ▶︎ //确定所有需要的库</span></span><br><span class="line"><span class="comment">              ▼ context.loadLibrary() //来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line"><span class="comment">                ▼ load() // 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line"><span class="comment">                  ▶︎ loadPhase0() → loadPhase1() → ... → loadPhase5() → loadPhase5load() → loadPhase5open() → loadPhase6() 递归调用  //每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line"><span class="comment">                  ▼ loadPhase6() // 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">sMainExecutable-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line"><span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-ImageLoader-link"><a href="#2-ImageLoader-link" class="headerlink" title="2. ImageLoader::link()"></a>2. ImageLoader::link()</h5><blockquote><p>加载二进制的过程： instantiate(实例化) –&gt; addImage –&gt; link –&gt; runInitializers </p><p>其中link就是动态链接的过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t0 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">  <span class="comment">// 1. recursiveLoadLibraries 这一步就是根据 LoadCommand 中的 LC_LOAD_DYLIB 把依赖的动态库和Framework加载进来。也就是对这些动态库 instantiate 的过程。 只是动态库不会用instantiateMainExecutable方法来加载了，最终用的是 instantiateFromFile 来加载。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only do the loading step for preflights</span></span><br><span class="line"><span class="keyword">if</span> ( preflightOnly )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">context.<span class="built_in">clearAllDepths</span>();</span><br><span class="line">  <span class="comment">// 2. recursiveUpdateDepth 刷新depth, 就是库依赖的层级。层级越深，depth越大。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  unsigned int ImageLoader::updateDepth(unsigned int maxDepth)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    STACK_ALLOC_ARRAY(ImageLoader*, danglingUpwards, maxDepth);</span></span><br><span class="line"><span class="comment">    unsigned int depth = this-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    for (auto&amp; danglingUpward : danglingUpwards) &#123;</span></span><br><span class="line"><span class="comment">      if ( danglingUpward-&gt;fDepth != 0)</span></span><br><span class="line"><span class="comment">        continue;</span></span><br><span class="line"><span class="comment">      danglingUpward-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return depth;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">updateDepth</span>(context.<span class="built_in">imageCount</span>());</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::<span class="built_in">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="comment">// 3. recursiveRebase rebase的过程，recursiveRebase就会把主二进制和依赖进来的动态库全部rebase.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void ImageLoader::recursiveRebaseWithAccounting(const LinkContext&amp; context)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      this-&gt;recursiveRebase(context);</span></span><br><span class="line"><span class="comment">      vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveRebaseWithAccounting</span>(context);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">t3 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 4. 主二进制和依赖进来的动态库全部执行 bind</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      void ImageLoader::recursiveBindWithAccounting(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;recursiveBind(context, forceLazysBound, neverUnload, nullptr);</span></span><br><span class="line"><span class="comment">        vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 5. weakBind. 执行weakBind，这里看到如果是主二进制在link的话，是不会在这个时候执行weak bind的，在dyld::_main里面可以看到，是在link完成之后再执行的weakBind.</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">weakBind</span>(context);</span><br><span class="line">t5 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 6. recursiveApplyInterposing. (主二进制link时候也不执行)</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveApplyInterposing</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t6 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveGetDOFSections</span>(context, dofs);</span><br><span class="line">    <span class="comment">// 7. registerDOFs. 注册DTrace Object Format。DTrace(Dynamic Trace)是一个提供了 zero disable cost 的动态追踪框架，也就是说当代码中的探针关闭时，不会有额外的资源消耗 - 即使在生产版本中我们也可以将探针留在代码中。只有使用的时候才产生消耗。</span></span><br><span class="line">    <span class="comment">// DTrace 是动态的，也就是说我们可以将它附加在一个已经在运行的程序上，也可以不打断程序将它剥离。不需要重新编译或启动。</span></span><br><span class="line">context.<span class="built_in">registerDOFs</span>(dofs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> t7 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with initial dylib loads</span></span><br><span class="line">fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-反向依赖"><a href="#3-反向依赖" class="headerlink" title="3. 反向依赖"></a>3. 反向依赖</h5><p>每个库之间的符号并非只能单向依赖。即库与库之间是可以相互依赖符号的。</p><blockquote><p>单向依赖：即 A.dylib 依赖 B.dylib。那么B中就不能依赖A中的符号。</p></blockquote><blockquote><p>一次dyld加载进来的二进制之间可以相互依赖符号。</p></blockquote><p>原因很简单，就是因为上面看到动态链接过程中，并不是完全加载完一个被依赖的动态库，再加载下一个的。而是 recursiveLoadLibraies，recursiveRebase，recursiveBind。 所有的单步操作都会等待前一步所有的库完成。因此当 recursiveBind的时候，所有的动态库二进制已经加载进来了，符号就可以互相找了。</p><p>一次dyld的过程只会一次动态link，这次link的过程中的库符号可以互相依赖的，但是如果你通过<code>dlopen</code>、<code>-[NSBundle loadBundle]</code>的方式来延迟加载的动态库就不能反向依赖了，必须单向依赖，因为这是另外一次dyld的过程了。</p><p>反向依赖还要有个条件，条件就是符号必须存在，如果因为编译优化把符号给strip了，那就没法bind了，还是会加载失败的。</p><h4 id="第六步-链接插入的动态库"><a href="#第六步-链接插入的动态库" class="headerlink" title="第六步 链接插入的动态库"></a>第六步 链接插入的动态库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第六步 链接插入的动态库</span></span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;<span class="built_in">inSharedCache</span>() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sImageRoots[i]-&gt;<span class="built_in">applyInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">gLinkContext.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">recursiveBind</span>(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第七步-弱符号绑定weakBind"><a href="#第七步-弱符号绑定weakBind" class="headerlink" title="第七步 弱符号绑定weakBind"></a>第七步 弱符号绑定weakBind</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第七步 执行弱符号绑定。weakBind: 从代码中可以看出这一步会对所有含有弱符号的镜像合并排序进行bind。OC中没发现应用场景，可能是C++的吧</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(gLinkContext);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch, running initializers&quot;</span>);</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h4 id="第八步-执行初始化方法initialize"><a href="#第八步-执行初始化方法initialize" class="headerlink" title="第八步 执行初始化方法initialize"></a>第八步 执行初始化方法initialize</h4><h5 id="1-源码解读-2"><a href="#1-源码解读-2" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>dyld会优先初始化动态库，然后初始化主程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第八步 执行初始化方法initialize() </span></span><br><span class="line">      <span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">//attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line"><span class="comment">//与之对应的是attribute((destructor))修饰的函数, 是主程序 main() 执行之后的一些全局函数析构操作, 也是记录在一个Section __mod_term_func中.</span></span><br><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有的监视进程，本进程要进入main()函数了。 notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="built_in">notifyMonitoringDyldMain</span>();</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h5 id="2-initializeMainExecutable"><a href="#2-initializeMainExecutable" class="headerlink" title="2. initializeMainExecutable()"></a>2. initializeMainExecutable()</h5><p>调用函数堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先初始化动态库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123; </span><br><span class="line">   sImageRoots[i]-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]); </span><br><span class="line">&#125;  <span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line"><span class="comment">// 再初始化可执行文件 </span></span><br><span class="line">  <span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line">▼ sMainExecutable-&gt;<span class="built_in">runInitializers</span>() </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">    ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()      <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">      ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()      <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doImageInit</span>()         <span class="comment">// 解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">        <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">      ▼ context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ▶︎ (*sNotifyObjCInit)(image-&gt;<span class="built_in">getRealPath</span>(), image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">        <span class="comment">// 通知objc, 该image已经完成初始化。objc会调用load_images()</span></span><br><span class="line">▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br></pre></td></tr></table></figure><p>在上面的<code>doImageInit</code>、<code>doModInitFunctions</code>函数中，会发现都有判断<code>libSystem</code>库是否已加载的代码，即<strong>libSystem要首先加载、初始化</strong>。在上文中，我们已经强调了这个库的重要性。之所以在这里又提到，是因为这个库也起到了将dyld与objc关联起来的作用：</p><img src="/images/compilelink/32.png" style="zoom:80%;" /><h5 id="2-dyld到objc的流程-详细见下篇"><a href="#2-dyld到objc的流程-详细见下篇" class="headerlink" title="2. dyld到objc的流程(详细见下篇)"></a>2. dyld到objc的流程(详细见下篇)</h5><p>可以从上面的调用堆栈中看到，从dyld到objc的流程：</p><ol><li><p><code>libSystem</code> 库的初始化</p></li><li><p><code>libdispatch</code> 库的初始化：<code>libdispatch</code> 是实现 GCD 的核心用户空间库。在 <code>void libdispatch_init(void)</code> 方法中会调用 <code>void _os_object_init(void)</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_include(<span class="meta-string">&lt;objc/objc-internal.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                                  <span class="comment">// __asm__ 使函数调用编译为“调用_objc_retain”</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> id _Nullable <span class="title">objc_retain</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_retain&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">objc_release</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_release&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_prepare(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_parent(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_child(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __has_include(&lt;objc/objc-internal.h&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>*_os_objc_destructInstance(id obj) &#123;</span><br><span class="line">    <span class="comment">// noop if only Libystem is loaded</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _os_object_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    Block_callbacks_RR callbacks = &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(Block_callbacks_RR),</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">    &#125;;</span><br><span class="line">    _Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v = <span class="built_in">getenv</span>(<span class="string">&quot;OBJC_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;DISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;LIBDISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后就是 <a href="https://opensource.apple.com/tarballs/objc4/">objc的源码</a> <code>objc-os.mm</code>中的 <code>_object_init</code> 函数了：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载，该方法是dyld提供的，内部调用了dyld::registerObjCNotifiers这个方法，记录了这三个分别对应map，init，unmap事件的回调函数。会在相应时机触发</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dyld_objc_notify_register</code> 这个方法在苹果开源的dyld里面可以找到，然后看到调用了<code>dyld::registerObjCNotifiers</code>这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// record functions to call</span></span><br><span class="line">  sNotifyObjCMapped   = mapped;</span><br><span class="line">  sNotifyObjCInit     = init;</span><br><span class="line">  sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class="line">       <span class="comment">// 第一次先触发一次ObjCMapped</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">notifyBatchPartial</span>(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//内部会触发sNotifyObjCMapped的调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">      <span class="comment">// ignore request to abort during registration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字面意思可以明白，传进来的分别是 map, init, unmap事件的回调。 dyld的事件通知有以下几种，分别会在特定的时机发送：(注意：map、init、unmap对应到下面枚举中的名称并不一致)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dyld_image_state_mapped                 = <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">  dyld_image_state_dependents_mapped      = <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">  dyld_image_state_rebased                = <span class="number">30</span>, </span><br><span class="line">  dyld_image_state_bound                  = <span class="number">40</span>,</span><br><span class="line">  dyld_image_state_dependents_initialized = <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">  dyld_image_state_initialized            = <span class="number">50</span>,</span><br><span class="line">  dyld_image_state_terminated             = <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个函数就很熟悉了，位于<code>objc-runtime-new.mm</code>中，objc运行时老生常谈的几个方法(关于OBJC的部分，内容太多，这里简单介绍，下篇细谈)，每次有新的镜像加载时都会在指定时机触发这几个方法：</p><ul><li>map_images : 每当 dyld 将一个 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : 每当 dyld 初始化一个 image 会触发该方法，会对该 image 进行+load的调用</li><li>unmap_image : 每当 dyld 将一个 image 移除时 , 会触发该函数</li></ul><img src="/images/compilelink/33.png" style="zoom:75%;" /><p>值得说明的是，这个初始化的过程远比写出来的要复杂，这里只提到了 runtime 这个分支，还有像 GCD、XPC 等重头的系统库初始化分支没有提及（当然，有缓存机制在，也不会重复初始化），总结起来就是 main 函数执行之前，系统做了非常多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p><p>然后，从上面最后的代码(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); 以及注释<code>register cxa_atexit() handler to run static terminators in all loaded images when this process exits</code>可以看出注册了<code>cxa_atexit()</code>函数，当此进程退出时，该处理程序会运行所有加载的image中的静态终止程序(static terminators)。</p><h4 id="第九步-查找主程序入口点并返回，-dyld-start会跳转进入"><a href="#第九步-查找主程序入口点并返回，-dyld-start会跳转进入" class="headerlink" title="第九步 查找主程序入口点并返回，__dyld_start会跳转进入"></a>第九步 查找主程序入口点并返回，__dyld_start会跳转进入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第九步 查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">    <span class="comment">// find entry point for main executable</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line"><span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_UNIXTHREAD</span>();</span><br><span class="line">*startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="built_in">syncAllImages</span>();</span><br><span class="line"><span class="built_in">halt</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: launch failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>引自<a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a>一文中的片段，<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html">《 Mike Ash 这篇 blog 》</a>对 dyld 作用顺序的概括：</p><ol><li> 从 kernel 留下的原始调用栈引导和启动自己</li><li> 将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li><li> non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li><li> Runs static initializers for the executable</li><li> 找到可执行文件的 main 函数，准备参数并调用</li><li> 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li><li> 程序main函数 return 后执行 static terminator</li><li> 某些场景下 main 函数结束后调 libSystem 的 <strong>_exit</strong> 函数</li></ol><p>然后，使用调用堆栈，来看下dyld的工作流程，只注释了认为重要的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 内核XNU加载Mach-O</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 从 XNU内核态 将控制权转移到 dyld用户态</span></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start   <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::<span class="built_in">start</span>()   <span class="comment">//dyldInitialization.cpp，负责dyld的引导工作</span></span><br><span class="line">      ▼ dyld::_main()   <span class="comment">// dyld.cpp</span></span><br><span class="line">    ▶︎ <span class="comment">// 第一步，设置运行环境</span></span><br><span class="line">    ▶︎ <span class="comment">// 第二步，加载共享缓存</span></span><br><span class="line">    ▶︎ <span class="comment">// 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line">    ▼ <span class="built_in">instantiateFromLoadedImage</span>()  </span><br><span class="line">        ▶︎ <span class="built_in">isCompatibleMachO</span>()  <span class="comment">// 检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line">        ▶︎ <span class="built_in">instantiateMainExecutable</span>()  <span class="comment">// 实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line">        ▶︎ <span class="built_in">addImage</span>()  <span class="comment">// 将可执行文件这个image，添加到 allImages中</span></span><br><span class="line">    ▶︎ <span class="comment">// 第四步，循环调用该函数，加载插入的动态库</span></span><br><span class="line">    ▶︎ <span class="built_in">loadInsertedDylib</span>()  </span><br><span class="line">    ▶︎ <span class="comment">// 第五步，调用link()函数，链接主程序</span></span><br><span class="line">    ▼ <span class="built_in">link</span>()  </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">link</span>() <span class="comment">//启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line">▼ <span class="built_in">recursiveLoadLibraries</span>() <span class="comment">//进行所有需求动态库的加载</span></span><br><span class="line">  ▶︎ <span class="comment">//确定所有需要的库</span></span><br><span class="line">  ▼ context.<span class="built_in">loadLibrary</span>() <span class="comment">//来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line">    ▼ <span class="built_in">load</span>() <span class="comment">// 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line">      ▶︎ <span class="built_in">loadPhase0</span>() → <span class="built_in">loadPhase1</span>() → ... → <span class="built_in">loadPhase5</span>() → <span class="built_in">loadPhase5load</span>() → <span class="built_in">loadPhase5open</span>() → <span class="built_in">loadPhase6</span>() 递归调用  <span class="comment">//每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line">      ▼ <span class="built_in">loadPhase6</span>() <span class="comment">// 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line">    ▶︎ <span class="comment">// 第六步，调用link()函数，链接插入的动态库</span></span><br><span class="line">    ▶︎ <span class="comment">// 第七步，对主程序进行弱符号绑定weakBind</span></span><br><span class="line">    ▶︎ sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">    ▶︎ <span class="comment">// 第八步，执行初始化方法 initialize。attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line">    ▼ <span class="built_in">initializeMainExecutable</span>()  <span class="comment">// dyld会优先初始化动态库，然后初始化主程序。</span></span><br><span class="line">          ▼ sMainExecutable-&gt;<span class="built_in">runInitializersrunInitializers</span>()  <span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">            ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">              ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()  <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">                ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()  <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doImageInit</span>()  <span class="comment">//解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">                  <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">          ▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">    ▶︎ <span class="comment">// 第九步，查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▶︎ (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br></pre></td></tr></table></figure><img src="/images/compilelink/34.png" style="zoom:80%;" /><p>关于更多的理论知识，可以阅读下<a href="https://juejin.im/post/6844903922654511112#heading-23">iOS程序员的自我修养-MachO文件动态链接（四）</a>、<a href="https://juejin.im/post/6844903926051897358">实践篇—fishhook原理</a>(：程序运行期间通过修改符号表(nl_symbol_ptr和la_symbol_ptr)，来替换要hook的符号对应的地址)，将《程序员的自我修养》中的理论结合iOS系统中的实现机制做了个对比介绍。</p><h2 id="五、加载动态库方式二-dlopen"><a href="#五、加载动态库方式二-dlopen" class="headerlink" title="五、加载动态库方式二: dlopen"></a>五、加载动态库方式二: dlopen</h2><blockquote><p>加载动态库的另一种方式：显式运行时链接dlopen</p></blockquote><p>上面的这种动态链接，其实还可以称为<strong>装载时链接</strong>，与静态链接相比，其实都是属于在程序运行之前进行的链接。还有另一种动态链接称为<strong>显式运行时链接</strong>(<strong>Explicit Runtime Linking</strong>)。</p><p>装载时链接：是在程序开始运行时(前)<strong>通过dyld动态加载</strong>。通过dyld加载的动态库需要在编译时进行链接，链接时会做标记，绑定的地址在加载后再决定。</p><p>显式运行时链接：即在运行时<strong>通过动态链接器dyld提供的API dlopen 和 dlsym 来加载</strong>。这种方式，在编译时是不需要参与链接的。</p><ul><li>dlopen会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。</li><li>dlopen也可以选择是立刻解析所有引用还是滞后去做。</li><li>dlopen打开动态库后返回的是模块的指针(句柄/文件描述符(FD))</li><li>dlsym的作用就是通过dlopen返回的动态库指针和函数的符号，得到函数的地址然后使用。</li></ul><p><strong>不过，通过这种运行时加载远程动态库的 App，苹果公司是不允许上线 App Store 的，所以只能用于线下调试环节。</strong></p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="https://www.cnblogs.com/guohai-stronger/p/11915571.html">MachO文件详解–逆向开发</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">Dyld之二: 动态链接过程</a></li><li><a href="https://www.dllhook.com/post/238.html#toc_14">dyld详解</a></li><li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li><li><a href="https://juejin.cn/post/6844904068867948552">iOS探索 浅尝辄止dyld加载流程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、动态链接&quot;&gt;&lt;a href=&quot;#一、动态链接&quot; class=&quot;headerlink&quot; title=&quot;一、动态链接&quot;&gt;&lt;/a&gt;一、动态链接&lt;/h2&gt;&lt;p&gt;动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</title>
    <link href="https://tenloy.github.io/2021/10/14/compile-vm-asrl.html"/>
    <id>https://tenloy.github.io/2021/10/14/compile-vm-asrl.html</id>
    <published>2021-10-14T04:26:04.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ASLR引入"><a href="#一、ASLR引入" class="headerlink" title="一、ASLR引入"></a>一、ASLR引入</h2><p>进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方式。然而，这意味着某个给定程序在某个给定架构上的进程初始虚拟内存镜像都是基本一致的。而且更严重的问题在于，即使是在进程正常运行的生命周期中，大部分内存分配的操作都是按照同样的方式进行的，因此使得内存中的地址分布具有非常强的可预测性。</p><p>尽管这有助于调试，但是也给黑客提供了更大的施展空间。黑客主要采用的方法是代码注入：通过重写内存中的函数指针，黑客就可以将程序的执行路径转到自己的代码，将程序的输入转变为自己的输入。重写内存最常用的方法是采用缓冲区溢出(即利用未经保护的内存复制操作越过上数组的边界)，可参考<a href="https://www.jianshu.com/p/4703ad3efbb9">缓冲区溢出攻击</a>，将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏printf()格式化字符串以及基于堆的缓冲区溢出。此外，任何用户指针甚至结构化的异常处理程序都可以导致代码注入。这里的关键问题在于判断重写哪些指针，也就是说，可靠地判断注入的代码应该在内存中的什么位置。</p><p>不论被破解程序的薄弱环节在哪里：缓冲区溢出、格式化字符串攻击或其他方式，黑客都可以花大力气破解一个不安全的程序，找到这个程序的地址空间布局，然后精心设计一种方法，这种方法可以可靠地重现程序中的薄弱环节，并且可以在类似的系统上暴露出一样的薄弱环节。</p><p>现在大部分操作系统中都采用了一种称为地址空间布局随机化(ASLR) 的技术，这是一种避免攻击的有效保护。进程每一次启动时，地址空间都会被简单地随机化：<strong>只是偏移，而不是搅乱</strong>。基本的布局(程序文本、数据和库)仍然是一样的。然而，这些部分具体的地址都不同了——区别足够大，可以阻挡黑客对地址的猜测。<strong>实现方法是通过内核将Mach-O的段“平移”某个随机系数</strong>。</p><h2 id="二、ASLR"><a href="#二、ASLR" class="headerlink" title="二、ASLR"></a>二、ASLR</h2><p>地址空间布局随机化(Address Space Layout Randomization，ASLR)是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。iOS4.3开始引入了ASLR技术。</p><p>下面分别来看一下，未使用ASLR、使用了ASLR下，进程虚拟地址空间内的分布。下图中左侧是mach-O可执行文件，右侧是链接之后的虚拟地址空间，如果对<code>__TEXT</code>、<code>__DATA</code>等Segment概念不清楚的地方，可以看一些第二篇关于Mach-O文件结构的介绍。</p><h3 id="2-1-未使用ASLR"><a href="#2-1-未使用ASLR" class="headerlink" title="2.1 未使用ASLR"></a>2.1 未使用ASLR</h3><ul><li>函数代码存放在__TEXT段中</li><li>全局变量存放在__DATA段中</li><li>可执行文件的内存地址是0x0</li><li>代码段（__TEXT）的内存地址就是LC_SEGMENT(__TEXT)中的VM Address：arm64设备下，为<code>0x100000000</code>；非arm64下为<code>0x4000</code></li><li>可以使用<code>size -l -m -x</code>来查看Mach-O的内存分布</li></ul><img src="/images/compilelink/26.png" alt="26" style="zoom:55%;" /><h3 id="2-2-使用了ASLR"><a href="#2-2-使用了ASLR" class="headerlink" title="2.2 使用了ASLR"></a>2.2 使用了ASLR</h3><ul><li>LC_SEGMENT(__TEXT)的VM Address为<code>0x100000000</code></li><li>ASLR随机产生的Offset（偏移）为<code>0x5000</code></li></ul><img src="/images/compilelink/27.png" alt="26" style="zoom:55%;" /><h3 id="2-3-符号地址计算"><a href="#2-3-符号地址计算" class="headerlink" title="2.3 符号地址计算"></a>2.3 符号地址计算</h3><blockquote><p>函数(变量)符号的内存地址、可执行文件地址计算</p></blockquote><h4 id="2-3-1-函数内存地址计算"><a href="#2-3-1-函数内存地址计算" class="headerlink" title="2.3.1 函数内存地址计算"></a>2.3.1 函数内存地址计算</h4><ul><li><strong>File Offset:</strong> 在当前架构(MachO)文件中的偏移量。</li><li> <strong>VM Address:</strong> 编译链接后，射到虚拟地址中的内存起始地址。 <code>VM Address = File Offset + __PAGEZERO Size</code>(__PAGEZERO段在MachO文件中没有实际大小，在VM中展开)</li><li><strong>Load Address:</strong> 在运行时加载到虚拟内存的起始位置。Slide是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同。<code>Load Address = VM Address + Slide(ASLR Offset)</code></li></ul><p>由于dsym符号表是编译时生成的地址，crash堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash日志里的符号地址被称为Stack Address，而编译后的符号地址被称为Symbol Address，他们之间的关系如下：<code>Stack Address = Symbol Address + Slide</code></p><p>符号化就是通过Stack Address到dsym文件中寻找对应符号信息的过程。</p><p>Hopper、IDA图形化工具中的地址都是未使用ASLR前的VM Address</p><h4 id="2-3-2-ASLR-Offset的获取"><a href="#2-3-2-ASLR-Offset的获取" class="headerlink" title="2.3.2 ASLR Offset的获取"></a>2.3.2 ASLR Offset的获取</h4><p>ASLR Offset有的地方也叫做<code>slide</code>，获取方法：</p><ul><li><p>在运行时由API <code>dyld_get_image_vmaddr_slide()</code>，来获取image虚拟地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型如下：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">intptr_t</span>   _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> image_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般使用方法如下：</span></span><br><span class="line"><span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> index  = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>lldb</code>命令<code>image list -o -f</code> 进行获取（本地、远程<code>debugserver</code>调试都可以），如下图：</p><img src="/images/compilelink/28.png" alt="26" style="zoom:80%;" /></li><li><p>根据运行时crash中的 <code>binary image</code>信息 和 ELF 文件的 <code>load command</code> 计算的到。比如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是crash信息，其中包括了抛出异常的线程的函数调用栈信息，日志下方有binary image信息，都只摘取了部分：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一列，调用顺序</span></span><br><span class="line"><span class="comment"> 第二列，对应函数所属的 binary image</span></span><br><span class="line"><span class="comment"> 第三列，stack address</span></span><br><span class="line"><span class="comment"> 第四列，地址的符号＋偏移的表示法，运算结果等于第三列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Last Exception Backtrace:  </span><br><span class="line"><span class="number">0</span>   CoreFoundation                <span class="number">0x189127100</span> __exceptionPreprocess + <span class="number">132</span>  </span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib               <span class="number">0x1959e01fc</span> objc_exception_throw + <span class="number">60</span>  </span><br><span class="line"><span class="number">2</span>   CoreFoundation                <span class="number">0x189127040</span> +[NSException raise:format:] + <span class="number">128</span>  </span><br><span class="line"><span class="number">3</span>   CrashDemo                     <span class="number">0x100a8666c</span> <span class="number">0x10003c000</span> + <span class="number">10790508</span>  </span><br><span class="line"><span class="number">4</span>   libsystem_platform.dylib      <span class="number">0x19614bb0c</span> _sigtramp + <span class="number">56</span>  </span><br><span class="line"><span class="number">5</span>   CrashDemo                     <span class="number">0x1006ef164</span> <span class="number">0x10003c000</span> + <span class="number">7024996</span>  </span><br><span class="line"><span class="number">6</span>   CrashDemo                     <span class="number">0x1006e8580</span> <span class="number">0x10003c000</span> + <span class="number">6997376</span>  </span><br><span class="line"><span class="number">7</span>   CrashDemo                     <span class="number">0x1006e8014</span> <span class="number">0x10003c000</span> + <span class="number">6995988</span>  </span><br><span class="line"><span class="number">8</span>   CrashDemo                     <span class="number">0x1006e7c94</span> <span class="number">0x10003c000</span> + <span class="number">6995092</span>  </span><br><span class="line"><span class="number">9</span>   CrashDemo                     <span class="number">0x1006f2460</span> <span class="number">0x10003c000</span> + <span class="number">7038048</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 第一列，虚拟地址空间区块；</span></span><br><span class="line"><span class="comment"> 第二列，映射文件名；</span></span><br><span class="line"><span class="comment"> 第三列：加载的image的UUID；</span></span><br><span class="line"><span class="comment"> 第四列，映射文件路径 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Binary Images:  </span><br><span class="line"><span class="number">0x10003c000</span> - <span class="number">0x100f7bfff</span> CrashDemo arm64  &lt;b5ae3570a013386688c7007ee2e73978&gt; /var/mobile/Applications/<span class="number">05</span>C398CE<span class="number">-21E9</span><span class="number">-43</span>C2<span class="number">-967F</span><span class="number">-26</span>DD0A327932/CrashDemo.app/CrashDemo  </span><br><span class="line"><span class="number">0x12007c000</span> - <span class="number">0x1200a3fff</span> dyld arm64  &lt;<span class="number">628</span>da833271c3f9bb8d44c34060f55e0&gt; /usr/lib/dyld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是使用 otool 工具查看到的 MedicalRecordsFolder（我的程序）的 加载命令 。</span></span><br><span class="line">$otool -l CrashDemo.app/CrashDemo   </span><br><span class="line">CrashDemo.app/CrashDemo:  </span><br><span class="line">Load command <span class="number">0</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">72</span>  </span><br><span class="line">  segname __PAGEZERO  </span><br><span class="line">   vmaddr <span class="number">0x0000000000000000</span>  </span><br><span class="line">   vmsize <span class="number">0x0000000100000000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">0</span>  </span><br><span class="line">  maxprot <span class="number">0x00000000</span>  </span><br><span class="line"> initprot <span class="number">0x00000000</span>  </span><br><span class="line">   nsects <span class="number">0</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">Load command <span class="number">1</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">792</span>  </span><br><span class="line">  segname __TEXT  </span><br><span class="line">   vmaddr <span class="number">0x0000000100000000</span>  </span><br><span class="line">   vmsize <span class="number">0x000000000000c000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">49152</span>  </span><br><span class="line">  maxprot <span class="number">0x00000005</span>  </span><br><span class="line"> initprot <span class="number">0x00000005</span>  </span><br><span class="line">   nsects <span class="number">9</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">……  </span><br><span class="line">Load command <span class="number">2</span> </span><br><span class="line">……  </span><br></pre></td></tr></table></figure><p>在 binary image 第一行可以看出进程空间的 0x10003c000 - 0x100f7bfff 这个区域在运行时被映射为 CrashDemo 内的内容，也就是我们的 ELF 文件(区域起始地址为0x10003c000)。<br>而在 Load Command 中看到的<code>__TEXT</code>的段起始地址却是 0x0000000100000000。<br>显而易见：slide = 0x10003c000(Load Address) - 0x100000000(VM Address) = 0x3c000；之后，就可以通过公式<code>symbol address = stack address - slide;</code> 来计算stack address 在crash log 中已经找到了。</p></li></ul><h4 id="2-3-3-Symbol-Address符号化"><a href="#2-3-3-Symbol-Address符号化" class="headerlink" title="2.3.3 Symbol Address符号化"></a>2.3.3 Symbol Address符号化</h4><ul><li><p>利用<code>dwarfdump</code>可以从dsym文件中得到symbol Address对应的内容：</p><ul><li>拿到crash日志后，我们要先确定dsym文件是否匹配。可以使用下面命令查看dsym文件所有架构的UUID：<code>dwarfdump --uuid CrashDemo.app.dSYM </code>，然后跟crash日志中Binary Images中的UUID相比对。</li><li>用得到的Symbol Address去 dsym 文件中查询，命令如下：<code>dwarfdump --arch arm64 --lookup [Symbol Address] CrashDemo.app.dSYM</code>，就可以定位下来具体的代码、函数名、所处的文件、行等信息了</li></ul></li><li><p>如果只是简单的获取符号名，可以用<code>atos</code>来符号化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -o [dsym file path] -l [Load Address] -arch [arch <span class="built_in">type</span>] [Stack Address]</span><br></pre></td></tr></table></figure><ul><li>不需要指定Symbol Address，只需要Load Address、Stack Address即可。</li></ul></li></ul><h2 id="三、进程地址空间"><a href="#三、进程地址空间" class="headerlink" title="三、进程地址空间"></a>三、进程地址空间</h2><p>由于ASLR的作用，进程的地址空间变得流动性非常大。但是尽管具体的地址会随机“滑动”某个小的偏移量，但整体布局保持不变。</p><p>内存空间分为以下几个段：</p><ul><li><strong>__PAGEZERO</strong>：在32位的系统中，这是内存中单独的一个页面(4KB)，而且这个页面所有的访问权限都被撤消了。在 64 位系统上，这个段对应了一个完整的32位地址空间(即前4GB)。这个段有助于捕捉空指针引用(因为空指针实际上就是 0)，或捕捉将整数当做指针引用(因为32位平台下的 4095 以下的值，以及64位平台下4GB以下的值都在这个范围内)。由于这个范围内所有访问权限(读、写和执行)都被撤消了，所以在这个范围内的任何解引用操作都会引发来自 MMU 的硬件页错误， 进而产生一个内核可以捕捉的陷阱。内核将这个陷阱转换为C++异常或表示总线错误的POSIX信号(SIGBUS) 。</li></ul><blockquote><p>PAGEZERO不是设计给进程使用的，但是多少成为了恶意代码的温床。想要通过“额外”代码感染Mach-O的攻击者往往发现可以很方便地通过PAGEZERO实现这个目的。PAGEZERO通常不属于目标文件的一部分(其对应的加载指令LC_SEGMENT将filesize指定为0)，但是对此并没有严格的要求.</p></blockquote><ul><li><strong>__TEXT</strong>：这个段存放的是程序代码。和其他所有操作系统一样，文本段被设置为r-x，即只读且可执行。这不仅可以防止二进制代码在内存中被修改，还可以通过共享这个只读段优化内存的使用。通过这种方式，同一个程序的多个实例可以仅使用一份TEXT副本。文本段通常包含多个区，实际的代码在_text区中。文本段还可以包含其他只读数据，例如常量和硬编码的字符串。</li><li><strong>__LINKEDIT</strong>：由dyld使用，这个区包含了字符串表、符号表以及其他数据。</li><li><strong>__IMPORT</strong>：用于 i386 的二进制文件的导入表。</li><li><strong>__DATA</strong>：用于可读/可写的数据。</li><li><strong>__MALLOC_TINY</strong>：用于小于一个页面大小的内存分配。</li><li><strong>__MALLOC_SMALL</strong>：用于几个页面大小的内存分配。</li></ul><p>下面是使用<code>vmmap(1)</code>输出的一个实例<code>程序a</code>在<code>32位</code>硬件设备上运行的进程地址空间，显示了区域的名称、地址范围、权限(当前权限和最高权限)以及映射的名称(通常对应的是Mach-O目标文件，如果有的话)。</p><p>32位进程的虚拟地址空间布局：</p><img src="/images/compilelink/29.png" alt="26" style="zoom:90%;" /><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>应该注意的是，尽管ASLR是很显著的改进，但也不是万能药。黑客仍然能找到聪明的方法破解程序。事实上，目前臭名昭著的“Star 3.0”漏洞就攻破了ASLR，这个漏洞越狱了 iPad 2 上的iOS 4.3。这种破解使用了Retum-Oriented Programming(ROP)攻击技术，通过缓冲区溢出破坏栈，以设置完整的栈帧， 模拟对libSystem的调用。同样的技术也用在iOS 5.0.1的“corona”漏洞中，这个漏洞成功地攻入了所有的苹果设备，包括当时最新的iPhone 4S。</p><p>预防攻击的唯一之道就是编写更加安全的代码，并且采用严格的代码审查，既要包含自动的技术，也要有人工的介入。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li>《深入解析Mac OS X &amp; iOS 操作系统》</li><li><a href="https://blog.csdn.net/zhongad007/article/details/90022617">动态调试之ASLR</a></li><li><a href="https://blog.csdn.net/xiaofei125145/article/details/50456614">iOS crash log 解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ASLR引入&quot;&gt;&lt;a href=&quot;#一、ASLR引入&quot; class=&quot;headerlink&quot; title=&quot;一、ASLR引入&quot;&gt;&lt;/a&gt;一、ASLR引入&lt;/h2&gt;&lt;p&gt;进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(四) Mach-O 文件的装载</title>
    <link href="https://tenloy.github.io/2021/10/10/compile-load.html"/>
    <id>https://tenloy.github.io/2021/10/10/compile-load.html</id>
    <published>2021-10-10T04:26:00.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/compilelink/25.png" alt="25" style="zoom:80%;" /><p>先附上源码地址：结合 <a href="https://opensource.apple.com/tarballs/xnu/">XNU</a> 源码(应该不是最新的，且不怎么全，不过用来分析学习也差不多了)，来看加载器的流程，效果更好。重要的两个类：</p><ul><li><code>bsd/kern/kern_exec.c</code>：进程执行的相关操作：线程创建、数据初始化等。</li><li><code>bsd/kern/mach_loader.c</code>：Mach-O文件解析加载相关。第二节中提到的Mach-O文件中的内核加载器负责处理的load command 对应的内核中处理的函数都在该文件中，比如处理<code>LC_SEGMET</code>命令的<code>load_segment</code>函数、处理<code>LC_LOAD_DYLINKER</code>命令的<code>load_dylinker</code>函数(负责调用命令指定的动态链接器)。</li></ul><h2 id="一、装载概述"><a href="#一、装载概述" class="headerlink" title="一、装载概述"></a>一、装载概述</h2><p>在链接完成之后，应用开始运行之前，有一段装载过程，我们都知道程序执行时所需要的指令和数据必须在内存中才能够被正常运行。</p><p>最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的<code>静态装入</code>的办法。</p><p>但是很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量不够时，根本的解决办法就是添加内存。相对于磁盘来说，内存是昂贵且稀有的，这种情况自计算机磁盘诞生以来一直如此。所以人们想尽各种办法，希望能够在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。后来研究发现，程序运行时是有<code>局部性原理</code>的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是<code>动态装入</code>的基本原理。（这也是<code>虚拟地址空间</code>机制要解决的问题，这里不再赘述，大学都学过）</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><h2 id="二、装载理论篇"><a href="#二、装载理论篇" class="headerlink" title="二、装载理论篇"></a>二、装载理论篇</h2><p>在虚拟存储中，现代的硬件MMU都提供地址转换的功能。有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。</p><p>事实上，从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那么我们就来看看这种最通常的情形：<strong>创建一个进程，然后装载相应的可执行文件并且执行</strong>。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间。</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><p><strong>首先是创建虚拟地址空间</strong>。一个虚拟空间由<code>一组页映射函数</code>将<code>虚拟空间的各个页</code>映射至相应的<code>物理空间</code>，所以创建一个虚拟空间实际上并不是创建空间而是<code>创建映射函数所需要的相应的数据结构</code>，在i386 的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</p><p><strong>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</strong>。上面那一步的<code>页映射关系函数是虚拟空间到物理内存的映射关系</code>，这一步所做的是<code>虚拟空间与可执行文件的映射关系</code>。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。</p><p>但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p><blockquote><p>由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。</p></blockquote><p>很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做<strong>虚拟内存区域</strong>（VMA, Virtual Memory Area）；在Windows中将这个叫做<strong>虚拟段</strong>（Virtual Section），其实它们都是同一个概念。</p><blockquote><p>VMA是一个很重要的概念，它对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。</p></blockquote><p>操作系统在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以<code>通过查找这样的一个数据结构来定位错误页在可执行文件中的位置</code>。</p><p><strong>将CPU指令寄存器设置成可执行文件入口，启动运行</strong>。第三步其实也是最简单的一步，操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址(通常是text区的地址)。</p><ul><li>ELF文件头中，有<code>e_entry</code>字段保存入口地址</li><li>Mach-O文件中的<code>LC_MAIN</code>加载指令作用就是设置程序主程序的入口点地址和栈大小)</li></ul><h2 id="三、Mach-O文件的装载"><a href="#三、Mach-O文件的装载" class="headerlink" title="三、Mach-O文件的装载"></a>三、Mach-O文件的装载</h2><p><a href="https://www.jianshu.com/p/332b183c055a">(二) Mach-O 文件结构</a> 介绍 <code>Mach Heade</code> 中的 <code>Load Command</code> 加载命令，结合其用途，就可以简单看出可执行文件的装载流程：</p><ul><li><p>首先，是由内核加载器(定义在<code>bsd/kern/mach_loader.c</code>文件中)来处理一些需要由内核加载器直接使用的加载命令。<strong>内核的部分(内核加载器)负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作</strong>。（这也是本篇内容主要讲的）</p></li><li><p>接着，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DY LINKER</code>命令指定的<code>动态链接器</code>在用户态完成的。（下一篇文章再细讲<code>dyld</code>及<code>动态链接</code>）</p></li></ul><p>下面通过代码来看一下具体的过程。下面通过一个调用栈图来说明， 这里面每个方法都做了很多事情，这里只注释了到_dyld_start的关键操作，很简略。有兴趣可以详细看源码<code>kern_exec.c</code>、<code>mach_loader.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">▼ execve       <span class="comment">// 用户点击了app，用户态会发送一个系统调用 execve 到内核</span></span><br><span class="line">  ▼ __mac_execve  <span class="comment">// 主要是为加载镜像进行数据的初始化，以及资源相关的操作，以及创建线程</span></span><br><span class="line">    ▼ exec_activate_image <span class="comment">// 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。</span></span><br><span class="line">      <span class="comment">// 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 该方法为Mach-o Binary对应的执行方法；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Fat Binary，对应方法为exec_fat_imgact；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Interpreter Script，对应方法为exec_shell_imgact</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ▼ exec_mach_imgact   </span><br><span class="line">        ▶︎ <span class="comment">// 首先对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，判断魔数、cputype、cpusubtype等信息。如果image无效，会直接触发assert(exec_failure_reason == OS_REASON_NULL); 退出。</span></span><br><span class="line">          <span class="comment">// 拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载。然后把Mach-O映射到内存中去，调用load_machfile()</span></span><br><span class="line">        ▼ load_machfile</span><br><span class="line">          ▶︎ <span class="comment">// load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。</span></span><br><span class="line">            <span class="comment">// 真正负责对加载命令解析的是parse_machfile()</span></span><br><span class="line">          ▼ parse_machfile  <span class="comment">//解析主二进制macho</span></span><br><span class="line">            ▶︎ <span class="comment">/* </span></span><br><span class="line"><span class="comment">               * 首先，对image头中的filetype进行分析，可执行文件MH_EXECUTE不允许被二次加载(depth = 1)；动态链接编辑器MH_DYLINKER必须是被可执行文件加载的(depth = 2)</span></span><br><span class="line"><span class="comment">               * 然后，循环遍历所有的load command，分别调用对应的内核函数进行处理</span></span><br><span class="line"><span class="comment">               *   LC_SEGMET：load_segment函数：对于每一个段，将文件中相应的内容加载到内存中：从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。</span></span><br><span class="line"><span class="comment">               *   LC_UNIXTHREAD：load_unixthread函数，见下文</span></span><br><span class="line"><span class="comment">               *   LC_MAIN：load_main函数</span></span><br><span class="line"><span class="comment">               *   LC_LOAD_DYLINKER：获取动态链接器相关的信息，下面load_dylinker会根据信息，启动动态链接器</span></span><br><span class="line"><span class="comment">               *   LC_CODE_SIGNATURE：load_code_signature函数，进行验证，如果无效会退出。理论部分，回见第二节load_command `LC_CODE_SIGNATURE `部分。</span></span><br><span class="line"><span class="comment">               *   其他的不再多说，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            ▼ load_dylinker <span class="comment">// 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span></span><br><span class="line">              ▼ parse_machfile <span class="comment">// 开始解析 dyld 这个mach-o文件</span></span><br><span class="line">                ▼ load_unixthread <span class="comment">// 解析 dyld 的 LC_UNIXTHREAD 命令，这个过程中会解析出entry_point</span></span><br><span class="line">                  ▼ load_threadentry  <span class="comment">// 获取入口地址</span></span><br><span class="line">                    ▶︎ thread_entrypoint  <span class="comment">// 里面只有i386和x86架构的，没有arm的，但是原理是一样的</span></span><br><span class="line">                  ▶︎ <span class="comment">//上一步获取到地址后，会再加上slide，ASLR偏移，到此，就获取到了dyld的入口地址，也就是 _dyld_start 函数的地址</span></span><br><span class="line">        ▼ activate_exec_state</span><br><span class="line">          ▶︎ thread_setentrypoint <span class="comment">// 设置entry_point。直接把entry_point地址写入到用户态的寄存器里面了。</span></span><br><span class="line">          <span class="comment">//这一步开始，_dyld_start就真正开始执行了。</span></span><br><span class="line"></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start() </span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▼ 这是下篇内容</span><br></pre></td></tr></table></figure><h2 id="四、Linux-ELF文件的装载（了解）"><a href="#四、Linux-ELF文件的装载（了解）" class="headerlink" title="四、Linux ELF文件的装载（了解）"></a>四、Linux ELF文件的装载（了解）</h2><p>首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用 <code>execve()</code>系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 execve() 系统调用被定义在unistd.h，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三个参数分别是被执行的程序文件名、执行参数和环境变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </span><br></pre></td></tr></table></figure><p>Glibc对该系统调用进行了包装，提供了 execl()、execlp()、execle()、execv()、execvp()等5个不同形式的exec系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到 execve() 这个系统中。</p><p>在进入 execve() 系统调用之后，Linux内核就开始进行真正的装载工作。</p><ul><li><p><code>sys_execve()</code>，在内核中，该函数是execve()系统调用相应的入口，定义在arch\i386\kernel\Process.c。 该函数进行一些参数的检查复制之后，调用 do_execve()。</p></li><li><p><code>do_execve()</code>，该函数会首先查找被执行的文件，如果找到文件，则读取文件的前128个字节。目的是判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做<code>魔数</code>（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如：</p><ul><li>ELF的可执行文件格式的头4个字节为0x7F、’e’、’l’、’f’；</li><li>Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’；</li><li>如果被执行的是Shell脚本或perl、python等这种解释型语言的脚本，那么它的第一行往往是 “#!/bin/sh” 或 “#!/usr/bin/perl” 或 “#!/usr/bin/python” ，这时候前两个字节<code>&#39;#&#39;</code>和<code>&#39;!&#39;</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</li></ul><p>当do_execve()读取了这128个字节的文件头部之后，然后调用search_binary_handle()。</p></li><li><p><code>search_binary_handle()</code>，该函数会去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，此函数会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如：</p><ul><li>ELF可执行文件的装载处理过程叫做 load_elf_binary()； </li><li>a.out可执行文件的装载处理过程叫做 load_aout_binary()；</li><li>装载可执行脚本程序的处理过程叫做 load_script()。</li></ul></li><li><p><code>load_elf_binary()</code>，这个函数被定义在fs/Binfmt_elf.c，代码比较长，它的主要步骤是：</p><ol><li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li><li>寻找动态链接的“.interp”段，设置动态链接器路径。</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是 DT_FINI 的地址（动态链接相关）。</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中 <code>e_entry</code> 所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li></ol></li></ul><p>当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时， 上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序(或动态链接器)的入口地址了。所以当 <code>sys_execve()</code>系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/">Dyld系列之一：_dyld_start之前</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/compilelink/25.png&quot; alt=&quot;25&quot; style=&quot;zoom:80%;&quot; /&gt;

&lt;p&gt;先附上源码地址：结合 &lt;a href=&quot;https://opensource.apple.com/tarballs/xnu/&quot;&gt;XNU&lt;</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(三) Mach-O 文件的静态链接</title>
    <link href="https://tenloy.github.io/2021/10/08/compile-static-link.html"/>
    <id>https://tenloy.github.io/2021/10/08/compile-static-link.html</id>
    <published>2021-10-08T04:25:56.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接概述"><a href="#一、链接概述" class="headerlink" title="一、链接概述"></a>一、链接概述</h2><p>链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？</p><p>很久以前，人们编写程序时，将所有源代码都写在同一个文件中，发展到后来一个程序源代码的文件长达数百万行，以至于人们没有能力维护这个程序。</p><p>后来，出现了模块化。现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。</p><p>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。<code>模块之间如何组合的问题可以归结为模块之间如何通信的问题</code>，最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的<strong>函数调用</strong>，另外一种是模块间的<strong>变量访问</strong>。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是<code>模块间符号的引用</code>。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼接刚好完美组合。这个模块的拼接过程就是：<strong>链接</strong></p><img src="/images/compilelink/18.jpg" alt="18" style="zoom:100%;" /><p>综上所述，链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。现代的高级语言的诸多特性和功能，使得编译器、链接器更为复杂，功能更为强大，但从原理上来讲，链接器的工作无非就是把一些指令对其他符号地址的引用加以修正。<strong>链接过程主要包括了地址和空间分配（Address and StorageAllocation）、符号决议（Symbol Resolution）和重定位 （Relocation）等这些步骤。</strong>（<code>符号可以理解为函数名和变量名</code>）</p><p>链接分为静态链接、动态链接。本篇只讲静态链接及静态链接器。</p><ul><li>静态链接是把目标文件（一个或多个）和需要的静态库链接成可执行文件。</li><li>动态链接是在可执行文件<code>装载</code>、<code>运行</code>时进行的文件的链接。</li></ul><h2 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h2><h3 id="2-1-链接器"><a href="#2-1-链接器" class="headerlink" title="2.1 链接器"></a>2.1 链接器</h3><p>lld链接器是LLVM的一个子项目，旨在为LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。</p><p>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p><h3 id="2-2-静态链接过程"><a href="#2-2-静态链接过程" class="headerlink" title="2.2 静态链接过程"></a>2.2 静态链接过程</h3><h4 id="2-2-1-两步链接"><a href="#2-2-1-两步链接" class="headerlink" title="2.2.1 两步链接"></a>2.2.1 两步链接</h4><p>我们知道，可执行文件中的代码段和数据段都是由输入的目标文件中合并而成的。那么链接过程就产生了第一个问题：对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p><ol><li><p><strong>按序叠加</strong>：一个最简单的方案就是将输入的目标文件按照次序叠加起来。（比如按照编译顺序，先编译的在前）。</p><p><strong>缺点</strong>：在有很多输入文件的情况下，输出文件将会有很多零散的段。假如有数百个目标文件，且都分别有.text段、.data段、.bss段，那最后的输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都须要有一定的地址和空间对齐要求(<strong>x86中，段的装载地址和空间的对齐单位是页，也就是4096字节</strong>)。</p></li><li><p><strong>相似段合并</strong>：将相同性质的段合并到一起。</p></li></ol><img src="/images/compilelink/19.jpg" alt="18" style="zoom:90%;" /><p>现在的链接器空间分配的策略基本上都会使相似段(Section)合并，使用这种方法的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。也就是说整个链接过程分两步：</p><h4 id="2-2-2-符号表与符号"><a href="#2-2-2-符号表与符号" class="headerlink" title="2.2.2 符号表与符号"></a>2.2.2 符号表与符号</h4><p>以下示例来自<a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a>，过程很简单，就是对于目标文件、可执行文件的MachOView的分析，目标文件、可执行文件是链接过程的输入、输出，通过对两个文件中的<code>符号表Symbols</code>、<code>代码段__TEXT.__text</code>来看一下引用符号的空间与地址分配、地址绑定过程。关于目标文件、可执行文件的生成上一篇文章已经讲过，本篇文章就直接看分析结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_var;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    func(a+global_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="keyword">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    global_var = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成a.o b.o</span></span><br><span class="line">xcrun -sdk iphoneos clang -c a.c b.c -target arm64-apple-ios12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o和b.o链接成可执行文件ab</span></span><br><span class="line">xcrun -sdk iphoneos clang a.o b.o -o ab -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure><p>请注意，生成的a.o和b.o目标文件，都是基于arm64。a.o和b.o目标文件通过静态链接后生成可执行文件ab。（由于基于arm64，其实链接过程，也有动态链接库libSystem.B.dylib(系统库)参与,但本文忽略动态链接的参与，只讨论静态链接）。</p><img src="/images/compilelink/20.png" alt="18" style="zoom:80%;" /><p>在可执行文件ab中，之所以<code>__TEXT.text</code>段的虚拟地址为<code>0x100000000</code>，而在文件中的位置(偏移)为<code>0</code>，是因为在链接生成可执行文件时，产生的一个特殊的段<code>__PAGEZERO</code>，这个段，在可执行文件中不占空间<code>File Offest</code>、<code>File Size</code>都为0，而在虚拟地址空间中，占用了很大的空间，<code>VMSize</code>为<code>0x100000000(4G)</code>.</p><p>在进入重定位之前，这里还需要再介绍一下符号表相关的知识点：符号表的加载命令、符号表的结构。</p><h5 id="1-符号表的加载命令"><a href="#1-符号表的加载命令" class="headerlink" title="1. 符号表的加载命令"></a>1. 符号表的加载命令</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2. 符号表"></a>2. 符号表</h5><p>符号表也是一个数组，里面元素是结构体nlist_64。符号表示意图见下方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> n_strx;   <span class="comment">/* 字符串表的index，可以找到符号对应的字符串（index into the string table） */</span></span><br><span class="line">    &#125; n_un;                <span class="comment">/* 历史原因，忽略 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_type;       <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_sect;       <span class="comment">/* section的编号或NO_SECT（section number or NO_SECT） */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* 符号的地址值（value of this symbol (or stab offset)） */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它先不管，要是有兴趣，可以去头文件&lt;mach-o/nlist.h&gt;查看。</span></span><br></pre></td></tr></table></figure><p>左侧是a.o的符号表，右侧是可执行文件的(全局)符号表：</p><img src="/images/compilelink/21.png" alt="18" style="zoom:80%;" /><p>相比于<code>a.o</code>、<code>b.o</code>目标文件，此时，可执行文件<code>ab</code>中的全局符号表中，每个符号都有了对应的(虚拟空间)地址，这是重定位的前提。</p><h5 id="3-符号表中符号的几种类型"><a href="#3-符号表中符号的几种类型" class="headerlink" title="3. 符号表中符号的几种类型"></a>3. 符号表中符号的几种类型</h5><blockquote><p><a href="https://www.jianshu.com/p/bda60193808d">引自-符号和符号表</a></p></blockquote><p>每个可重定位模块都有一个符号表，它包含了在本模块中定义和引用的符号，有三种链接器符号：</p><table><thead><tr><th>类型</th><th>特征</th><th>举例</th></tr></thead><tbody><tr><td><strong>Global symbols</strong>（模块内部定义的<strong>全局符号</strong>）</td><td>由本模块定义并能被其他模块引用的符号</td><td>例如，非static C函数和非 static的C全局变量（指不带static的全局变量）</td></tr><tr><td><strong>External symbols</strong>（外部定义的<strong>全局符号</strong>）</td><td>由其他模块定义并被本模块引用了的全局符号</td><td>例如，在本模块中extern声明的其它模块中定义的符号</td></tr><tr><td><strong>Local symbols</strong>（本模块的<strong>局部符号</strong>）</td><td>仅由本模块内定义和引用的本地符号</td><td>例如，在本模块中定义的带static 的C函数和全局变量。</td></tr></tbody></table><p><strong>注意：链接器局部符号</strong></p><ul><li><strong>不是指程序中的局部变量</strong>（分配在栈中的临时性变量），链接器是不关心这种局部变量的。</li><li><strong>个人理解</strong>：局部符号在本模块内定义并引用，按照符号解析的功能来看，其是不参与符号解析的。这也是为什么多个目标文件中出现同名的局部符号，在链接时，却不会报<code>符号重定义</code>的原因。并且查看链接后的可执行文件，符号表中，是可以同时存在多个同名局部符号的。</li></ul><h4 id="2-2-3-第一步-空间与地址分配"><a href="#2-2-3-第一步-空间与地址分配" class="headerlink" title="2.2.3 第一步 空间与地址分配"></a>2.2.3 第一步 空间与地址分配</h4><p>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：</p><ul><li>第一个是在输出的可执行文件中的空间；</li><li>第二个是在装载后的虚拟地址中的虚拟地址空间。</li></ul><p>对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接过程关系并不是很大。</p><h5 id="1-相似段合并"><a href="#1-相似段合并" class="headerlink" title="1. 相似段合并"></a>1. 相似段合并</h5><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<code>全局符号表</code>。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p><p>应该说地址与空间分配，地址：分配到哪；空间：分配多大。链接器的地址与空间分配，既是指在可执行文件中的分配，也指在虚拟地址空间中的分配。</p><ul><li><code>可执行文件的地址空间</code>与目标文件中一样，地址从0开始。</li><li><code>虚拟地址空间</code>中的地址并非从0开始，比如Linux下，ELF可执行文件中的数据，在进程虚拟地址空间中，默认从0x08048000开始分配。</li></ul><p>我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到下一步重定位中，关于地址计算的步骤(重定位中，地址修正是修正为符号的虚拟地址空间中的地址)，而且可执行文件本身的空间分布、分配与链接过程关系并不是很大。</p><p>这一步过程：</p><ul><li>会将多个输入模块(目标文件)的数据收集，相似段进行合并，见上图。</li><li>重新计算段在可执行文件中的偏移、大小。</li><li>重新计算段在虚拟地址空间中的偏移、大小。</li></ul><p>这些信息在<code>LC_SEGMENT_64</code>中看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 初始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* segment包含的section的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号地址的确定-rebase"><a href="#2-符号地址的确定-rebase" class="headerlink" title="2. 符号地址的确定(rebase)"></a>2. 符号地址的确定(rebase)</h5><p>当前面一步完成之后，链接器开始计算各个符号的虚拟地址。(这一步修正地址的符号是本文件内定义的(数据、函数)符号，关于外部符号的引用重定位在第二步)</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(<strong>目标文件中符号表中的符号的地址，都是相对于text段起始的偏移</strong>)。</p><p>当目标文件、动态库文件等二进制文件加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h4 id="2-2-4-第二步-符号解析与重定位"><a href="#2-2-4-第二步-符号解析与重定位" class="headerlink" title="2.2.4 第二步 符号解析与重定位"></a>2.2.4 第二步 符号解析与重定位</h4><p>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。</p><h5 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1. 符号解析"></a>1. 符号解析</h5><p>符号解析：解析每个模块中<code>引用的符号</code>，将其与某个目标模块中的<code>符号定义</code>建立关联。</p><ul><li>每个定义的符号在代码段或数据段中都被分配了存储空间，将符号引用与符号定义建立关联后，就可在重定位时将引用的符号的地址重定位为相关联的定义的符号的地址。</li><li>如果没找到定义，会给出一个类似<code>“undefined reference to &#39;xxx&#39;”</code>、<code> “Undefined symbols”</code>类似的链接错误。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库、输入目标文件路径不正确、符号的声明与定义不一样等。</li><li>如果找到了，进行符号决议(绑定)：<ul><li>如果找到了一个，直接绑定；</li><li>如果链接器在输入模块中找到了一个以上的外部符号定义，会按照它的规则选择其中一个符号定义或者报错。<code>强弱符号</code>规则：<ul><li>对于C/C++语言来说，编译器默认函数和已初始化的全局变量为强符号，未初始化的全局变量为弱符号。</li><li>强符号只能被定义一次，否则报符号重复定义错误。符号的重复定义错误与类型无关，只要经过符号修饰机制后产生的符号相同，就报符号重复<code>“ld: dumplicate symbols”</code></li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选强符号。(Xcode中默认设置了clang编译参数，遇到强弱符号会报重复定义错误)</li><li>如果一个符号在所有目标文件中都是弱符号，会选择占用空间最大的一个（《程序员的自我修养》）</li></ul></li><li>动态库链接中还有<code>全局符号介入</code>规则(如果相同符号名的符号已存在，则后加入的符号被忽略))。</li></ul></li></ul><blockquote><p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定 （Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的。</p><p>大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p></blockquote><p><strong>符号解析时会选择一个确切的定义，即每个全局符号仅占一处存储空间。</strong></p><p><strong>编码建议：</strong></p><ul><li>尽量避免使用全局变量</li><li>一定要用时：<ul><li>尽量使用内部链接定义，如用static修饰</li><li>全局变量要赋初值，<strong>避免潜在的强弱符号造成的不可知错误</strong>，赋初值后，编译器检测到重复定义会报错，提醒开发者修正。</li></ul></li><li><strong>头文件中，不能写<code>Global symbols</code>的定义</strong>(否则若头文件若被多处<code>#include</code>，预处理后展开，文件内容替换该行，就相当于直接在多个源文件中出现全局符号定义，会报错)。如果要定义全局变量，一定要用static修饰，设置为<code>Local symbols</code>。</li></ul><p>符号解析完成，全局符号表中符号都有对应的定义处的地址。接下来就是重定位工作：<strong>根据重定位表<code>Relocations</code>中符号信息，在全局符号表<code>Symbols</code>中找到符号的<code>定义地址</code>，然后找到符号在代码段<code>__TEXT.text</code>中的使用地址，进行指令的地址修正。</strong></p><h5 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2. 重定位"></a>2. 重定位</h5><p>重定位就是指针修正的过程。</p><p>假设有A、B两个目标文件，B中引用了A中的一个变量并对其进行赋值，对应AT&amp;T汇编为<code>movl $0x2a, var</code>。</p><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为 0，等待链接器在将目标文件A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relocation Entry）</strong>。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p><p>从上面的示例中，可以看到：a文件使用了B文件中的global_var和func两个符号，那是怎么知道这两个符号的地址呢？</p><p>在a.o目标文件中：</p><img src="/images/compilelink/22.png" alt="18" style="zoom:70%;" /><ul><li>global_var（地址0）和func（地址0x2c，这条指令本身地址）都是假地址。编译器暂时用0x0和0x2c替代着，把真正地址计算工作留给链接器。</li><li>通过前面的空间与地址分配可以得知，链接器在完成地址与空间分配后，就可以确定所有符号的虚拟地址了。</li><li>此时，链接器根据符号的地址对每个需要重定位的指令进行地址修正。</li></ul><p>在链接后的ab可执行文件中：</p><img src="/images/compilelink/23.png" alt="18" style="zoom:70%;" /><p>可以看到global_var（地址0x100008000，指向data段，值为1）和func（地址0x100007f90，指向func函数地址）都是真正的地址。</p><p>链接器是怎么知道a模块里哪些指令要被调整，这些指令如何调整。事实上a.o里，有一个重定位表，专门保存这些与重定位相关的信息。而且每个section的section_64的header的reloff（重定位入口的文件偏移，即在重定位表里的偏移）和nreloc（几个需要重定位的符号），让链接器知道a模块的哪个section里的指令需要调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-重定位表"><a href="#3-重定位表" class="headerlink" title="3. 重定位表"></a>3. 重定位表</h5><p>重定位表可以认为是一个数组，数组里的元素为结构体relocation_info。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/reloc.h&gt;里</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> &#123;</span></span><br><span class="line">   <span class="keyword">int32_t</span>    r_address;<span class="comment">/* 重定位的符号在自己所在section中的偏移(地址)；offset in the section to what is being relocated */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   r_symbolnum:<span class="number">24</span>,<span class="comment">/* 如果r_extern == 0(外部符号)，则表示符号在符号表中的索引，如果r_extern == 0，则表示section的序数；symbol index if r_extern == 1 or section ordinal if r_extern == 0 */</span></span><br><span class="line">              r_pcrel:<span class="number">1</span>, <span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">              r_length:<span class="number">2</span>,<span class="comment">/* 重定位符号的长度；0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">              r_extern:<span class="number">1</span>,<span class="comment">/* 不包含引用符号的值(即为外部符号)；does not include value of sym referenced */</span></span><br><span class="line">              r_type:<span class="number">4</span>;        <span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r_address和r_length足够让我们知道要重定位的字节了；</span></span><br></pre></td></tr></table></figure><img src="/images/compilelink/24.png" alt="18" style="zoom:70%;" /><p>可以看出：</p><ul><li>a.o文件的重定位表中记录符号了_func和_global_var两个需要重定位的符号，并且<code>r_address</code>给出了两个符号在代码段section的位置，<code>r_symbolnum</code>指向了符号在符号表的index。</li><li>链接时候，a.o里面有这两符号的引用，然后b.o里面有这两符号的定义，一起合并到全局符号表里（见下方符号表部分中的示意图）。</li><li>在全局符号表里，可以找到这两个符号的虚拟内存位置和其它信息，就可以完成重定位工作(对指令进行地址修正)了。</li></ul><h3 id="2-3-静态库链接"><a href="#2-3-静态库链接" class="headerlink" title="2.3 静态库链接"></a>2.3 静态库链接</h3><p>一个静态库可以简单看成一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件。</p><p>静态库链接：是指自己的模块与静态库里的某个模块（用到的某个目标文件，或多个目标文件）链接成可执行文件。其实和静态链接概念一样，只是这里，我们这里取了静态库里的某个/多个目标文件与我们自己的目标文件一起作为输入。</p><p>Q：为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a静态库里面printf.o只有printf()函数、strlen.o只有strlen()函数，为什么要这样组织？</p><p>A：我们知道，<strong>链接器在链接静态库的时候是<code>以目标文件为单位</code>的</strong>。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件（函数）就不要链接到最终的输出文件中。</p><h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a></li><li><a href="">《程序员的自我修养》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、链接概述&quot;&gt;&lt;a href=&quot;#一、链接概述&quot; class=&quot;headerlink&quot; title=&quot;一、链接概述&quot;&gt;&lt;/a&gt;一、链接概述&lt;/h2&gt;&lt;p&gt;链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) Mach-O 文件结构</title>
    <link href="https://tenloy.github.io/2021/10/06/compile-macho.html"/>
    <id>https://tenloy.github.io/2021/10/06/compile-macho.html</id>
    <published>2021-10-06T04:25:50.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式<code>Mach-O的结构</code>，方便了解之后的<code>链接</code>生成可执行文件的过程。</p><p>先附上相关源码地址：与Mach-O 文件格式有关的结构体定义都可以从 <code>/usr/include/mach-o/loader.h</code> 中找到(直接在xcode项目中找到<code>loader.h</code>，然后Show In Finder即可)。</p><h2 id="一、进程与二进制格式"><a href="#一、进程与二进制格式" class="headerlink" title="一、进程与二进制格式"></a>一、进程与二进制格式</h2><p>进程在众多操作系统中都有提及，它是作为一个正在执行的程序的实例，这是 UNIX 的一个基本概念。而进程的出现是特殊文件在内从中加载得到的结果，这种文件必须使用操作系统可以认知的格式，这样才对该文件引入依赖库，初始化运行环境以及顺利地执行创造条件。</p><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）。macOS 支持三种可执行格式：解释器脚本格式、通用二进制格式和 Mach-O 格式(关于三者区别，在下面说到Mach-O Header的时候介绍)。</p><h2 id="二、相关工具"><a href="#二、相关工具" class="headerlink" title="二、相关工具"></a>二、相关工具</h2><p>命令行工具</p><ul><li><p>file 命令，查看Mach-O文件的基本信息：<code>file 文件路径</code></p></li><li><p>otool 命令，查看Mach-O特定部分和段的内容</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Mach-O文件的header信息</span></span><br><span class="line">otool -h 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件的load commands信息</span></span><br><span class="line">otool -l 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件所使用到的动态库</span></span><br><span class="line">otool -L 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多使用方法，终端输入otool -help查看</span></span><br></pre></td></tr></table></figure><ul><li>lipo 命令，来处理多架构Mach-O文件，常用命令如下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看架构信息</span></span><br><span class="line">lipo -info 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出某种类型的架构</span></span><br><span class="line">lipo 文件路径 -thin 架构类型 -output 输出文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并多种架构类型</span></span><br><span class="line">lipo 文件路径1 文件路径2 -output 输出文件路径</span><br></pre></td></tr></table></figure><p>GUI工具</p><ul><li>MachOView：文件浏览。<a href="https://github.com/gdbinit/MachOView">MachOView官网</a></li><li>hopper：反汇编工具</li></ul><h2 id="三、Mach-O-文件格式"><a href="#三、Mach-O-文件格式" class="headerlink" title="三、Mach-O 文件格式"></a>三、Mach-O 文件格式</h2><p>Mach-O 文件格式在官方文档中有一个描述图，很多教程中都引用到。<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html">官网文档</a></p><img src="/images/compilelink/12.png" alt="12" style="zoom:90%;" /><p>可以看的出 Mach-O 主要由 3 部分组成，下面一一讲述。Load Command的作用是指导内核加载器、动态链接器怎么将可执行文件装载到内存进行执行。所以Load Command放到最后一部分。</p><h3 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h3><p>用 helloworld 来做个试验：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// main.cpp</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>clang -g main.cpp -o main</code> 生成执行文件。然后拖入到 <em>MachOView</em> 中来查看一下加载 Segment 的结构（当然使用 <em>Synalyze It!</em> 也能捕捉到这些信息的，但是 <em>MachOView</em> 更对结构的分层更加一目了然）：</p><img src="/images/compilelink/13.jpg" alt="12" style="zoom:80%;" /><h3 id="3-2-Mach-O-头"><a href="#3-2-Mach-O-头" class="headerlink" title="3.2 Mach-O 头"></a>3.2 Mach-O 头</h3><p>Mach-O 头（Mach Header）描述了 Mach-O 的 CPU 架构、大小端、文件类型以及加载命令等信息。它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p><p>以下只给出 64 位定义的代码，因为 32 位的区别是缺少了一个预留字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC    0xfeedface    <span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM    0xcefaedfe    <span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;            <span class="comment">/* magic(魔数)：用来确认文件的格式，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。 */</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>    cputype;        <span class="comment">/* CPU架构 */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>    cpusubtype;  <span class="comment">/* CPU子版本 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filetype;         <span class="comment">/* 文件类型，常见的Mach-O文件有：MH_OBJECT(目标文件)、MH_EXECUTABLE(可执行二进制文件)、MH_DYLIB(动态库)等等。这些文件类型定义在 loader.h 文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    ncmds;            <span class="comment">/* 加载器中加载命令的数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sizeofcmds;       <span class="comment">/* 加载器中所有加载命令的总大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;            <span class="comment">/* dyld 加载需要的一些标志，其中MH_PIE表示启用地址空间布局随机化(ASLR)。其他的值在loader.h文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved;         <span class="comment">/* 64位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>魔数会表明文件的格式。filetype会表明具体是什么文件类型(都是猫，也分黑猫、白猫)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// magic：常见的魔数(Mac是小端模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mach-O文件。用途：macOS 的原生二进制格式</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC0xfeedface  <span class="comment">/* 32位设备上的魔数，大端模式(符合人类阅读习惯，高位数据在前) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM0xcefaedfe  <span class="comment">/* 32位、小端(高位地址在后)，CIGAM就是MAGIC反过来写，从命名上也可以看出端倪 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC_64 0xfeedfacf  <span class="comment">/* 64位、大端 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM_64 0xcffaedfe  <span class="comment">/* 64位、小端 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用二进制格式FAT。用途：包含多种架构支持的二进制格式，只在 macOS 上支持。(在文章末尾简单介绍一下，有兴趣可以瞜一眼)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC     0xcafebabe</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM     0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC_64  0xcafebabf</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM_64  0xbfbafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC_64) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//脚本格式。用途：主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 `#!` 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令。</span></span><br><span class="line">  <span class="comment">// 魔数为 \x7FELF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filetype：常见的Mach-O格式的文件类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_OBJECT  0x1<span class="comment">/* 可重定位的目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_EXECUTE0x2<span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLIB  0x6<span class="comment">/* 动态绑定共享库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLINKER0x7<span class="comment">/* 动态链接编辑器，如dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_BUNDLE  0x8<span class="comment">/* 动态绑定bundle(包)文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DSYM  0xa<span class="comment">/* 调试所用的符号文件 */</span></span></span><br></pre></td></tr></table></figure><p>举例：利用otool工具查看Mach-o文件的头部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -hv bibi.decrypted </span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">   MH_MAGIC     ARM         V7  0x00     EXECUTE    59       6016   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br><span class="line"></span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    59       6744   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br></pre></td></tr></table></figure><h3 id="3-3-Data"><a href="#3-3-Data" class="headerlink" title="3.3 Data"></a>3.3 Data</h3><p>数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码。</p><blockquote><p>Raw segment data存放了所有的原始数据，而Load commands相当于Raw segment data的索引目录</p></blockquote><h4 id="3-3-1-Segment-段"><a href="#3-3-1-Segment-段" class="headerlink" title="3.3.1 Segment(段)"></a>3.3.1 Segment(段)</h4><p>其中，LC_SEGMENT_64定义了一个64位的段，当文件加载后映射到地址空间(包括段里面节的定义)。64位段的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护，用八进制表示(4=r(read)，2=w(write)，1=x(execute执行权限)) */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 段页面最初始的内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* 段(segment)包含的区(section)的个数(如果存在的话) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>系统将 fileoff 偏移处 filesize 大小的内容加载到虚拟内存的 vmaddr 处，大小为vmsize，段页面的权限由initprot进行初始化。它的权限可以动态改变，但是不能超过maxprot的值，例如 _TEXT 初始化和最大权限都是可读/可执行/不可写。</strong></p><p>常见的<code>LC_SEGMENT</code> Segment (cmd为<code>LC_SEGMET</code>)，其<code>segname[16]</code>有以下几种值：</p><ul><li><strong>__PAGEZERO</strong>：空指针陷阱段，映射到虚拟内存空间的第1页，用于捕捉对 NULL 指针的引用。</li><li><strong>__TEXT</strong>：代码段/只读数据段。</li><li><strong>__DATA</strong>：读取和写入数据的段。</li><li><strong>__LINKEDIT</strong>：动态链接器需要使用的信息，包括符号表、重定位表、绑定信息、懒加载信息等。</li><li><strong>__OBJC</strong>：包含会被Objective Runtime使用到的一些数据。(从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述)</li></ul><h4 id="3-3-2-Section-节"><a href="#3-3-2-Section-节" class="headerlink" title="3.3.2 Section(节)"></a>3.3.2 Section(节)</h4><p>从示例图中可以看到，部分的 Segment (<code>__TEXT</code> 和 <code>__DATA</code>) 可以进一步分解为 Section。</p><p>之所以按照 Segment(段) -&gt; Section(节) 的结构组织方式，是因为在同一个 Segment 下的 Section，在内存中的权限相同(编译时，编译器把相同权限的section放在一起，成为segment)，可以不完全按照 Page 的大小进行内存对齐，节省内存的空间。而 Segment 对外整体暴露，在装载程序时，完整映射成一个vma(Virtual Memory Address)，更好的做到内存对齐，减少内存碎片（可以参考《OS X &amp; iOS Kernel Programming》第一章内容）。</p><p>Section 具体的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合示例图，下面列举一些常见(并非全部)的 Section：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __TEXT Segment(段)下面的节：</span></span><br><span class="line">  __text              <span class="comment">// 程序可执行的代码区域</span></span><br><span class="line">  __stubs             <span class="comment">// 间接符号存根。本质上是一小段代码，跳转到懒加载/延迟绑定(lazybinding)指针表(即__DATA.la_symbol_ptr)。找到对应项指针指向的地址。</span></span><br><span class="line">  __sub_helper        <span class="comment">// 辅助函数。帮助解决懒加载符号加载，上述提到的lazybinding的表(__DATA.la_symbol_ptr)中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span></span><br><span class="line">  __objc_methname     <span class="comment">// 方法名</span></span><br><span class="line">  __objc_classname    <span class="comment">// 类名</span></span><br><span class="line">  __objc_methtype     <span class="comment">// 方法签名</span></span><br><span class="line">  __cstring           <span class="comment">// 去重后的只读的C风格字符串，包含OC的部分字符串和属性名</span></span><br><span class="line">  __const             <span class="comment">// 初始化过的常量</span></span><br><span class="line">  __unwind_info       <span class="comment">// 用户存储处理异常情况信息</span></span><br><span class="line">  __eh_frame          <span class="comment">// 调试辅助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __DATA Segment(段)下面的节：</span></span><br><span class="line">  __data              <span class="comment">// 初始化过的可变的数据</span></span><br><span class="line">  __const             <span class="comment">// 没有初始化过的常量</span></span><br><span class="line">  __bss               <span class="comment">// 没有初始化的静态变量</span></span><br><span class="line">  __common            <span class="comment">// 没有初始化过的符号声明</span></span><br><span class="line">  __nl_symbol_ptr     <span class="comment">// 非延迟导入/非懒加载(lazy-binding)符号指针表，每个表项中的指针都指向一个在dyld加载过程中，搜索完成的符号。即在dyld加载时会立即绑定值。</span></span><br><span class="line">  __la_symbol_ptr     <span class="comment">// 延迟导入/懒加载(lazy-binding)符号指针表，每个表项中的指针一开始指向stub_helper。在第 1 次调用时才会绑定值。</span></span><br><span class="line">  __got               <span class="comment">// 非懒加载全局指针表</span></span><br><span class="line">  __mod_init_func     <span class="comment">// 初始化/constructor(构造)函数</span></span><br><span class="line">  __mod_term_func     <span class="comment">// destructor(析构)函数</span></span><br><span class="line">  __cfstring          <span class="comment">// OC字符串</span></span><br><span class="line">  __objc_classlist    <span class="comment">// 程序中的类列表</span></span><br><span class="line">  __objc_nlclslist    <span class="comment">// 程序中自己实现了+load方法的类</span></span><br><span class="line">  __objc_protolist    <span class="comment">// 协议的列表</span></span><br><span class="line">  __objc_classrefs    <span class="comment">// 被引用的类列表</span></span><br><span class="line">  __objc_ivar         <span class="comment">// 成员变量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-stubs-与-stub-helper"><a href="#3-4-stubs-与-stub-helper" class="headerlink" title="3.4 __stubs 与 __stub_helper"></a>3.4 <code>__stubs</code> 与 <code>__stub_helper</code></h3><blockquote><p>用来实现 LazyBind 的两个section：<code>__TEXT.__stubs</code>、<code>__TEXT.__stub_helper</code></p></blockquote><p>在 wikipedia 有一个关于 <a href="https://en.wikipedia.org/wiki/Method_stub">Method stub</a> 的词条，大意就是：Stub 是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。</p><p>总结来说：</p><ul><li>stub就是一段代码，功能为：跳转到 <code>__DATA.__la_symbol_ptr</code>( <code>__DATA</code> Segment 中的 <code>__la_symbol_ptr</code> Section) 对应表项的数据，所指向的地址。</li><li><code>__la_symbol_ptr</code> 里面的所有表项的数据在初始时都会被 binding 成 <code>__stub_helper</code>。</li><li>当懒加载符号第一次使用到的时候，按照上面的结构，会跳转到<code>__stub_helper</code>这个section的代码，然后代码中会调用<code>dyld_stub_binder</code>来执行真正的bind。 bind结束后，就将<code>__la_symbol_ptr</code>中该懒加载符号 原本对应的指向<code>__stub_helper</code>的地址 修改为 符号的真实地址。</li><li>之后的调用中，虽然依旧会跳到 <code>__stub</code> 区域，但是 <code>__la_symbol_ptr</code>表由于在之前的调用中获取到了符号的真实地址而已经修正完成，所以无需在进入 <code>dyld_stub_binder</code> 阶段，可以直接使用符号。</li></ul><p>这样就完成了LazyBind的过程。Stub 机制 其实和 <code>wikipedia</code> 上的说法一致，设置一个桩函数(模拟、占位函数)并采用 <strong>lazy</strong> 思想做成延迟 binding 的流程。</p><p>在《深入解析 Mac OS X &amp; iOS操作系统》中有详细的验证，也可以参考<a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a> 自己动手验证一下。</p><h3 id="3-5-Load-Command"><a href="#3-5-Load-Command" class="headerlink" title="3.5 Load Command"></a>3.5 Load Command</h3><p>Mach-O文件头中包含了非常详细的指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。这些指令，或称为“加载命令”，紧跟在基本的mach_header之后。</p><p>每一条命令，在<code>load.c</code>文件中，都有对应的结构体，来记录信息。共同点是都采用“<code>类型-长度-值</code>”的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmd;       <span class="comment">/* 32位的cmd值(表示类型) ，下面列举了部分 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmdsize;   <span class="comment">/* 32位的cmdsize值(32位二进制为4的倍数，64位二进制为8的倍数) */</span></span><br><span class="line">  ...                      <span class="comment">/* 记录命令本身的一些信息 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面列举一些load command的类型(对应的cmd值)，这里只列举了部分，全面的可以看源码，总共50多种load command。按照加载命令是由内核加载器、动态链接器处理分开记录。</span></span><br><span class="line"><span class="comment">// 内核加载器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SEGMENT                0x1  <span class="comment">/* 定义一个段(Segment)，加载后被映射到内存中，包括里面的节(Section) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLINKER          0xe  <span class="comment">/* 默认的加载器路径。通常路径是“/usr/lib/dyld” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_UUID                   0x1b   <span class="comment">/* 用于标识Mach-0文件的ID，匹配二进制文件与符号表。在分析崩溃堆栈信息能用到，通过地址在符号表中找到符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_CODE_SIGNATURE         0x1d  <span class="comment">/* 代码签名信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ENCRYPTION_INFO_64     0x2C   <span class="comment">/* 文件是否加密的标志，加密内容的偏移和大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SYMTAB                 0x2  <span class="comment">/* 为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的 external 符号被链接器使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYSYMTAB               0xb  <span class="comment">/* 将符号表中给出符号的额外符号信息提供给动态链接器。 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLIB             0xc    <span class="comment">/* 加载动态链接库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ID_DYLIB               0xd  <span class="comment">/* 动态库的标识，包括动态库名称、当前版本号、兼容版本号。可以使用“otool-L xxx”命令查看 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_RPATH                 (0x1c | LC_REQ_DYLD)    <span class="comment">/* RunpathSearchPaths，@rpath搜索的路径 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_DYLD_INFO              0x22  <span class="comment">/* compressed dyld information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYLD_INFO_ONLY        (0x22 | LC_REQ_DYLD)  <span class="comment">/* 记录了有关链接的重要信息，包括在__LINKEDIT中动态链接相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的链接器无法识别它，程序就会出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_VERSION_MIN_IPHONEOS   0x25   <span class="comment">/* 系统要求的最低版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_FUNCTION_STARTS        0x26   <span class="comment">/* 函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_MAIN                  (0x28 | LC_REQ_DYLD)    <span class="comment">/* 程序的入口。dyld获取该地址，然后跳转到该处执行。replacement for LC_UNIXTHREAD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DATA_IN_CODE           0x29   <span class="comment">/* 定义在代码段内的非指令的表   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SOURCE_VERSION         0x2A   <span class="comment">/* 构建二进制文件的源代码版本号 */</span></span></span><br></pre></td></tr></table></figure><p>有一些命令是由<code>内核加载器</code>(定义在<code>bsd/kern/mach_loader.c</code>文件中) 直接使用的， 其他命令是由<code>动态链接器</code>处理的。</p><img src="/images/compilelink/14.png" alt="12" style="zoom:70%;" /><img src="/images/compilelink/15.png" alt="12" style="zoom:70%;" /><p>在Mach-O文件加载解析时，多个Load Command会告诉操作系统应当如何加载文件中每个Segment的数据，对系统内核加载器和动态链接器起引导作用。(不同的数据对应不同的加载命令，可以看到<code>segment_command_64</code>、<code>symtab_command</code>、<code>dylib_command</code>等，下面我们会讲解Segment的加载命令，下一节讲静态链接时，会涉及符号表symtab的加载命令)。</p><p>下面，以三个内核加载器负责解析处理的load command，来简单看下：</p><h4 id="3-5-1-LC-LOAD-DYLIB与LC-ID-DYLIB"><a href="#3-5-1-LC-LOAD-DYLIB与LC-ID-DYLIB" class="headerlink" title="3.5.1 LC_LOAD_DYLIB与LC_ID_DYLIB"></a>3.5.1 LC_LOAD_DYLIB与LC_ID_DYLIB</h4><p>可执行文件（MH_EXECUTE类型）的Mach-O都会存在LC_LOAD_DYLIB类型的Load Command，该Load Command指定了当前Mach-O需要依赖的动态库（可以是系统的动态库也可以是开发者创建的动态库）。</p><p>LC_LOAD_DYLIB类型的Load Command在内存中对应struct dylib_command结构，dylib_command结构包含struct dylib结构，struct dylib结构中name字段标记了动态库的路径。那么这个路径是从哪里来的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态链接库由两个东西标识。</span></span><br><span class="line"><span class="comment">   路径名（为执行而找到的库的名称）和兼容性版本号。 路径名必须匹配，并且库的用户中的兼容性号必须大于或等于正在使用的库。 </span></span><br><span class="line"><span class="comment">   时间戳用于记录库的构建和复制到用户的时间，因此它可以用来确定运行时使用的库是否与构建程序时使用的完全相同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>  <span class="title">name</span>;</span><span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;<span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;<span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version;<span class="comment">/* library&#x27;s compatibility vers number*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态链接库（mach header中的filetype == MH_DYLIB）包含一个 dylib_command (cmd == LC_ID_DYLIB) 来标识库。</span></span><br><span class="line"><span class="comment"> 使用动态链接库的模块包含它使用到的每个动态库的 dylib_command（cmd == LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB 或 LC_REEXPORT_DYLIB）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* includes pathname string */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span><span class="title">dylib</span>;</span><span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LC_ID_DYLIB：动态库的Mach-O是MH_DYLIB类型的，一个动态库中必须包含一个LC_ID_DYLIB类型的Load Command（一般位于__LINKEDIT之后），它在内存中也是一个struct dylib_command结构，会有name字段。</p><ul><li>这里的dylib_command信息会在LINK时作为LC_LOAD_DYLIB类型的Load Command插入进可执行文件（MH_EXECUTE 类型的Mach-O）中。</li></ul><p>打开APP时，dyld会先递归遍历所有类型为LC_LOAD_DYLIB的Load Command从而查找依赖库，查找的路径即是由对应的dylib_command结构的name指定，一般为@rpath/DYNAME.framework/DYNAME。如果在指定各种查找路径都找不到，就会出现”dyld: Library not loaded”错误。</p><h4 id="3-5-2-LC-CODE-SIGNATURE-数字签名"><a href="#3-5-2-LC-CODE-SIGNATURE-数字签名" class="headerlink" title="3.5.2 LC_CODE_SIGNATURE(数字签名)"></a>3.5.2 LC_CODE_SIGNATURE(数字签名)</h4><p>Mach-O二进制文件有一个重要特性就是可以进行数字签名。尽管在 OS X 中仍然没怎么使用数字签名，不过由于代码签名和新改进的沙盒机制绑定在一起，所以签名的使用率也越来越高。在 iOS 中，代码签名是强制要求的，这也是苹果尽可能对系统封锁的另一种尝试：在 iOS 中只有苹果自己的签名才会被认可。在 OS X 中，code sign(1) 工具可以用于操纵和显示代码签名。man手册页，以及 Apple’s code signing guide 和 Mac OS X Code Signing In Depth文档都从系统管理员的角度详细解释了代码签名机制。</p><p><code>LC_CODE_SIGNATURE</code> 包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配(或者如果在iOS上这条命令不存在)，那么内核会立即给进程发送一个SIGKILL信号将进程杀掉，没有商量的余地，毫不留情。</p><p>在iOS 4之前，还可以通过两条sysctl(8)命令覆盖负责强制执行(利用内核的MAC，即Mandatory AccessControl)的内核变量，从而实现禁用代码签名检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w security.mac.proc_enforce &#x3D; 0 &#x2F;&#x2F;禁用进程的MAC</span><br><span class="line">sysctl -w security.mac.vnode_enforce&#x3D;0 &#x2F;&#x2F;禁用VNode的MAC</span><br></pre></td></tr></table></figure><p>而在之后版本的iOS中，苹果意识到只要能够获得root权限，越狱者就可以覆盖内核变量。因此这些变量变成了只读变量。untethered越狱(即完美越狱)因为利用了一个内核漏洞所以可以修改这些变量。由于这些变量的默认值都是启用签名检查，所以不完美越狱会导致非苹果签名的应用程序崩溃——除非i设备以完美越狱的方式引导。</p><p>此外，通过 Saurik 的 ldid 这类工具可以在 Mach-O 中嵌入伪代码签名。这个工具可以替代OS X的code sign(1)，允许生成自我签署认证的伪签名。这在iOS中尤为重要，因为签名和沙盒模型的应用程序“entitlement”绑定在一起， 而后者在iOS中是强制要求的。entitlement 是声明式的许可(以plist的形式保存)，必须内嵌在Mach-O中并且通过签名盖章，从而允许执行安全敏感的操作时具有运行时权限。</p><p>OS X 和 iOS 都有一个特殊的系统调用csops(#169)用于代码签名的操作</p><h4 id="3-5-3-LC-SEGMENT-进程虚拟内存设置"><a href="#3-5-3-LC-SEGMENT-进程虚拟内存设置" class="headerlink" title="3.5.3 LC_SEGMENT(进程虚拟内存设置)"></a>3.5.3 LC_SEGMENT(进程虚拟内存设置)</h4><p>LC_SEGMENT(或LC_SEGMENT_64) 命令是最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些“段”直接从Mach-O二进制文件加载到内存中。</p><p>每一条LC_SEGMENT[64] 命令都提供了段布局的所有必要细节信息。见上文的数据结构成员变量。</p><p>有了LC_SEGMENT命令，设置进程虚拟内存的过程就变成遵循LC_SEGMENT命令的简单操作。对于每一个段，将文件中相应的内容加载到内存中：<strong>从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节</strong>。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。段的保护设置可以动态改变，但是不能超过 maxprot 中指定的值(在iOS中，+x和+w是互斥的)。</p><h4 id="3-5-4-LC-MAIN-设置主线程入口地址"><a href="#3-5-4-LC-MAIN-设置主线程入口地址" class="headerlink" title="3.5.4 LC_MAIN(设置主线程入口地址)"></a>3.5.4 LC_MAIN(设置主线程入口地址)</h4><p>从Mountain Lion开始，一条新的加载命令<code>LC_MAIN</code>替代了<code>LC_UNIX_THREAD</code>命令。</p><ul><li>后者的作用是：开启一个unix线程，初始化栈和寄存器，通常情况下，除了指令指针(Intel的IP)或程序计数器(ARM的r15)之外，所有的寄存器值都为0。</li><li>前者作用是<strong>设置程序主线程的入口点地址和栈大小</strong>。</li></ul><p>这条命令比LC_UNIXTHREAD命令更实用一些， 因为无论如何除了程序计数器之外所有的寄存器都设置为0了。由于没有LC_UNIXTHREAD命令， 所以不可以在之前版本的 OS X 上运行使用了LC_MAIN的二进制文件(在加载时会导致dyld(1)崩溃)。</p><img src="/images/compilelink/16.png" alt="12" style="zoom:90%;" /><p>LC_Main对应的加载命令如下，记录了可执行文件的入口函数<code>int main(int argc, char * argv[])</code>的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmd;        <span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmdsize;    <span class="comment">/* 24 */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  entryoff;   <span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  stacksize;  <span class="comment">/* if not zero, initial stack size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义上可以看到入口函数的地址计算：<code>Entry Point = vm_addr(__TEXT) + entryOff + Slide</code></p><p>从<a href="https://opensource.apple.com/source/dyld/">dyld的源码</a>里能看到对Entry Point的获取和调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start()   <span class="comment">// dyldInitialization.cpp</span></span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dyldbootstrap &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line">    <span class="comment">// sets up some registers and call this function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uintptr_t</span></span><br><span class="line">    _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">            <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">            <span class="keyword">uintptr_t</span>* startGlue) &#123;</span><br><span class="line">        <span class="comment">// find entry point for main executable</span></span><br><span class="line">        result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下这几种load command所表示的信息。关于进程地址空间分布、线程入口在第四节 —— 装载会从进程启动到运行详细梳理一下流程。</p><h2 id="四、通用二进制格式（Universal-Binary）"><a href="#四、通用二进制格式（Universal-Binary）" class="headerlink" title="四、通用二进制格式（Universal Binary）"></a>四、通用二进制格式（Universal Binary）</h2><p>通常也被称为<code>胖二进制格式（Fat Binary）</code>，Apple 提出这个概念是为了解决一些历史原因，macOS（更确切的应该说是 OS X）最早是构建于 PPC 架构智商，后来才移植到 Intel 架构（从 Mac OS X Tiger 10.4.7 开始），通用二进制格式的二进制文件可以在 PPC 和 x86 两种处理器上执行。</p><p>说到底，通用二进制格式只不过是对多架构的二进制文件的打包集合文件，而 macOS 中的多架构二进制文件也就是适配不同架构的 Mach-O 文件。即一个通用二进制格式包含了很多个 Mach-O 格式文件。它有以下特点：</p><ul><li>因为需要存储多种架构的代码，所以通用二进制文件要比单架构二进制文件要大</li><li>因为两种种架构之间可以共用一些资源，所以两种架构的通用二进制文件大小不会达到单一架构版本的两倍。</li><li>运行过程中只会调用其中的部分代码，所以运行起来不会占用额外的内存</li></ul><p><strong>Fat Header</strong> 的数据结构在 <code>&lt;mach-o/fat.h&gt;</code> 头文件中有定义，可以参看 <code>/usr/include/mach-o/fat.h</code> 找到定义头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC    0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM    0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;           <span class="comment">/* FAT_MAGIC 或 FAT_MAGIC_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nfat_arch;       <span class="comment">/* 结构体实例的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>     cputype;      <span class="comment">/* cpu 说明符 (int) */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>  cpusubtype;   <span class="comment">/* 指定 cpu 确切型号的整数 (int) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       offset;       <span class="comment">/* CPU 架构数据相对于当前文件开头的偏移值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       size;         <span class="comment">/* 数据大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       align;        <span class="comment">/* 数据内润对其边界，取值为 2 的幂 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>cputype</code> 和 <code>cpusubtype</code> 两个字段这里不讲述，可以参看 <code>/usr/include/mach/machine.h</code> 头中对其的定义，另外 <a href="https://developer.apple.com/documentation/kernel/mach_header?language=objc">Apple 官方文档</a>中也有简单的描述。</p><p>在 <code>fat_header</code> 中，<code>magic</code> 也就是我们之前在表中罗列的 <em>magic</em> 标识符，也可以类比成 UNIX 中 ELF 文件的 <em>magic</em> 标识。加载器会通过这个符号来判断这是什么文件，通用二进制的 <em>magic</em> 为 <code>0xcafebabe</code>。<code>nfat_arch</code> 字段指明当前的通用二进制文件中包含了多少个不同架构的 Mach-O 文件。<code>fat_header</code> 后会跟着多个 <code>fat_arch</code>，并与多个 Mach-O 文件及其描述信息（文件大小、CPU 架构、CPU 型号、内存对齐方式）相关联。</p><p>这里可以通过 <code>file</code> 命令来查看简要的架构信息，这里以 iOS 平台 WeChat 4.5.1 版本为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ file Desktop/WeChat.app/WeChat</span><br><span class="line">Desktop/WeChat.app/WeChat: Mach-O universal binary with 2 architectures: [arm_v7: Mach-O executable arm_v7] [arm64]</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture armv7):    Mach-O executable arm_v7</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture arm64):    Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><p>进一步，也可以使用 <code>otool</code> 工具来打印其 <code>fat_header</code> 详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ otool -f -V Desktop/WeChat.app/WeChat</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic FAT_MAGIC</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture armv7</span><br><span class="line">    cputype CPU_TYPE_ARM</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM_V7</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 56450224</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture arm64</span><br><span class="line">    cputype CPU_TYPE_ARM64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 56475648</span><br><span class="line">    size 64571648</span><br><span class="line">    align 2^14 (16384)</span><br></pre></td></tr></table></figure><p>之后我们用 <em>Synalyze It!</em> 来查看 WeChat 的 Mach64 Header 的效果：</p><img src="/images/compilelink/17.jpg" alt="12" style="zoom:80%;" /><ul><li>  从第一个段中得到 <code>magic = 0xcafebabe</code> ，说明是 <code>FAT_MAGIC</code>。</li><li>  第二段中所存储的字段为 <code>nfat_arch = 0x00000002</code>，说明该 App 中包含了两种 CPU 架构。</li><li>  后续的则是 <code>fat_arch</code> 结构体中的内容，<code>cputype(0x0000000c)</code>、<code>cpusubtype(0x00000009)</code>、<code>offset(0x00004000)</code>、<code>size(0x03505C00)</code> 等等。如果只含有一种 CPU 架构，是没有 fat 头定义的，这部分则可跳过，从而直接过去 <code>arch</code> 数据。</li></ul><blockquote><p><strong>注意，在mach-o中，数据结构中的地址表示：如果是value、address等，那一般是绝对地址；如果是偏移量offset等，一般都是相对于目标文件/可执行文件（注意，尤其是后者，起始地址不会是0，寻址时要加上起始地址）。</strong></p></blockquote><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903959618912263#heading-10">iOS逆向学习之四（初识Mach-O）</a></li><li><a href="https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html">Mach-O 文件格式探索</a></li><li><a href="">《iOS应用逆向与安全》— 刘培庆</a></li><li><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho(1)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式&lt;code&gt;Mach-O的结构&lt;/code&gt;，方便了解之后的&lt;code&gt;链接&lt;/code&gt;生成可执行文件的过程。&lt;/p&gt;
&lt;p&gt;先附上相关源码地址：与Mach-O 文件格</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(一) Clang/LLVM 介绍、OC 程序的编译过程</title>
    <link href="https://tenloy.github.io/2021/10/05/compile-clang-llvm.html"/>
    <id>https://tenloy.github.io/2021/10/05/compile-clang-llvm.html</id>
    <published>2021-10-05T04:25:45.000Z</published>
    <updated>2022-06-21T10:15:46.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编译、链接工具-—-Clang-LLVM"><a href="#一、编译、链接工具-—-Clang-LLVM" class="headerlink" title="一、编译、链接工具 — Clang/LLVM"></a>一、编译、链接工具 — Clang/LLVM</h2><blockquote><p><a href="https://llvm.org/">官网定义：</a></p><ul><li>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies(LLVM项目是一系列分模块、可重用的编译<strong>工具链</strong>). Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</li><li>Clang is an “LLVM native” C/C++/Objective-C compiler. </li></ul></blockquote><h3 id="1-1-LLVM的诞生"><a href="#1-1-LLVM的诞生" class="headerlink" title="1.1 LLVM的诞生"></a>1.1 LLVM的诞生</h3><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的克里斯·拉特纳(Chris Lattner，twitter为 <a href="https://twitter.com/clattner_llvm">clattner_llvm</a>） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。</p><p>2005年，由于GCC 对于 Objective-C 的支持比较差，效率和性能都没有办法达到苹果公司的要求，而且它还难以推动 GCC 团队。于是，苹果公司决定自己来掌握编译相关的工具链，于是将Chris Lattner招入麾下，发起了 Clang 软件项目。</p><ul><li>Clang 作为 LLVM 编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。Clang支持C、C++、Objective C。</li><li>测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</li><li>此后，苹果使用的 GCC 全面替换成了 LLVM。</li></ul><p>2010年，Chris Lattner开始主导开发 Swift 语言。这也使得 Swift 这门集各种高级语言特性的语言，能够在非常高的起点上，出现在开发者面前。</p><p>2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p><h3 id="1-2-LLVM及其子项目"><a href="#1-2-LLVM及其子项目" class="headerlink" title="1.2 LLVM及其子项目"></a>1.2 LLVM及其子项目</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p>llvm特点：</p><ul><li>模块化</li><li>统一的中间代码IR，而前端、后端可以不一样。而GCC的前端、后端耦合在了一起，所以支持一门新语言或者新的平台，非常困难。</li><li>功能强大的Pass系统，根据依赖性自动对Pass（包括分析、转换和代码生成Pass）进行排序，管道化以提高效率。</li></ul><p>llvm有广义和狭义两种定义：</p><ul><li>在广义中，llvm特指一整个编译器框架，<strong>是一个模块化和可重用的编译器和工具链技术的集合</strong>，由前端、优化器、后端组成，clang只是用于c/c++的一种前端，llvm针对不同的语言可以设计不同的前端，同样的针对不同的平台架构（amd，arm，misp），也会有不同后端设计</li><li>在狭义中 ，特指llvm后端，指优化器（pass）对IR进行一系列优化直到目标代码生成的过程</li></ul><p>简单罗列LLVM几个主要的子项目，详见<a href="https://llvm.org/">官网</a>：</p><ul><li><p>LLVM Core libraries：LLVM核心库提供了一个独立于源和目标架构的现代<a href="https://llvm.org/docs/Passes.html">优化器optimizer</a>，以及对许多流行cpu(以及一些不太常见的cpu)的<a href="https://llvm.org/docs/CodeGenerator.html">代码生成(code generation)</a>支持。这些库是围绕一种被称为LLVM中间表示(“LLVM IR”)的良好指定的代码表示构建的。</p></li><li><p>Clang：一个 C/C++/Objective-C 编译器，提供高效快速的编译效率，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。(见下文详述)</p></li><li><p>lld： 是LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。<br>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p></li><li><p>LLDB：基于 LLVM 和 Clang提供的库构建的一个优秀的本地调试器，使用了 Clang ASTs、表达式解析器、LLVM JIT、LLVM 反汇编器等。</p></li></ul><h4 id="1-2-2-Clang"><a href="#1-2-2-Clang" class="headerlink" title="1.2.2 Clang"></a>1.2.2 Clang</h4><p>从<a href="http://llvm.org/svn/llvm-project/cfe/trunk/lib/">Clang的源码</a>目录中可以大致看出Clang提供的功能：</p><img src="/images/compilelink/01.png" alt="01" style="zoom:80%;" /><h5 id="1-Clang提供了哪些功能？"><a href="#1-Clang提供了哪些功能？" class="headerlink" title="1. Clang提供了哪些功能？"></a>1. Clang提供了哪些功能？</h5><p>Clang 为一些需要分析代码语法、语义信息的工具提供了基础设施。分别是：</p><ul><li><p><strong>LibClang</strong>。LibClang提供了一个稳定的高级 C 接口，Xcode 使用的就是 LibClang。LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有 Token、遍历语法树、代码补全等。由于 API 很稳定，Clang 版本更新对其 影响不大。但是，LibClang 并不能完全访问到 Clang AST 信息。</p></li><li><p><strong>Clang Plugins</strong>。可以在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。插件是在运 行时由编译器加载的动态库，方便集成到构建系统中。<br>使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。<br>应用：实现命名规范、代码规范等一些扩展功能</p></li><li><p><strong>LibTooling</strong>。是一个 C++ 接口，所写的工具不依赖于构建系统，可以作为一个命令单独使用。与 Clang Plugins 相比，LibTooling 无法影响编译过程；与 LibClang 相比，LibTooling 的接口没有那么稳定。<br>应用：做代码转换，比如把 OC 转 JavaScript 或 Swift；代码检查。</p></li></ul><h5 id="2-Clang的优点"><a href="#2-Clang的优点" class="headerlink" title="2. Clang的优点"></a>2. Clang的优点</h5><p>Clang 是 C、C++、Objective-C 的编译前端，而 Swift 有自己的编译前端 （也就是 Swift 前端多出的 SIL optimizer）。Clang 有哪些优势？</p><ul><li>对于使用者来说，Clang 编译的速度非常快，对内存的使用率非常低，并且兼容 GCC。</li><li>对于代码诊断来说， Clang 也非常强大，Xcode 也是用的 Clang。使用 Clang 编译前端，可以精确地显示出问题所在的行和具体位置，并且可以确切地说明出现这个问题的原因，并指出错误的类型是什么，使得我们可以快速掌握问题的细节。这样的话，我们不用看源码，仅通过 Clang 突出标注的问题范围也能够了解到问题的情况。</li><li>Clang 对 typedef 的保留和展开也处理得非常好。typedef 可以缩写很长的类型，保留 typedef 对于粗粒度诊断分析很有帮助。但有时候，我们还需要了解细节，对 typedef 进行展开即可。</li><li>Fix-it 提示也是 Clang 提供的一种快捷修复源码问题的方式。在宏的处理上，很多宏都是深度嵌套的， Clang 会自动打印实例化信息和嵌套范围信息来帮助你进行宏的诊断和分析。</li><li>Clang 的架构是模块化的。除了代码静态分析外，利用其输出的接口还可以开发用于代码转义、代码生成、代码重构的工具，方便与 IDE 进行集成。</li></ul><p>Clang 是基于 C++ 开发的，如果你想要了解 Clang 的话，需要有一定的 C++ 基础。但是，Clang 源码本身质量非常高，有很多值得学习的地方，比如说目录清晰、功能解耦做得很好、分类清晰方便组合和复用、代码风格统一而且规范、注释量大便于阅读等。</p><h3 id="1-3-Clang-LLVM架构"><a href="#1-3-Clang-LLVM架构" class="headerlink" title="1.3 Clang-LLVM架构"></a>1.3 Clang-LLVM架构</h3><p>Clang-LLVM架构，即用Clang作为前端的LLVM(编译工具集)。</p><p>Clang-LLVM下，一个源文件的编译过程：</p><img src="/images/compilelink/02.png" alt="01" style="zoom:65%;" /><p>iOS 开发完整的编译流程图：</p><img src="/images/compilelink/03.png" alt="01" style="zoom:80%;" /><p>LLVM架构的主要组成部分：</p><ul><li><p><strong>前端</strong>：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang(Clang-LLVM)。<br>LLVM支持三种表达形式：人类可读的汇编(<code>.ll</code>后缀，是LLVM IR文件，其有自己的语法)、在C++中对象形式、序列化后的bitcode形式(<code>.bc</code>后缀)。</p></li><li><p><strong>Pass</strong>(v.通过/传递/变化 n.经过/通行证/<strong>通道</strong>/<strong>流程</strong>/<strong>阶段</strong>) ：是 LLVM 优化(optimize)工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。<br>Pass用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。我们可以自己编写Pass，做一些代码混淆优化等操作。</p></li><li><p><strong>后端</strong>：后端用来生成实际的机器码。至3.4版本的LLVM已经支持多种后端指令集，比如主流的x86、x86-64、z/Architecture、ARM和PowerPC等</p></li></ul><p>虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。传统的编译器的架构如下:</p><img src="/images/compilelink/04.png" alt="01" style="zoom:100%;" /><p>LLVM的架构如下：</p><img src="/images/compilelink/05.png" alt="01" style="zoom:75%;" /><p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端，其它部分完成可以复用，不用重新设计。在基于LLVM进行代码混淆时，只需要关注中间层代码(IR)表示。</p><h3 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h3><ul><li>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</li><li>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</li><li>Gallium3D 中使用 LLVM 进行 JIT 优化</li><li>Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度</li><li>LLVM-Lua 用LLVM 来编译 lua 代码</li><li>gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</li></ul><p>下面，通过具体的代码、命令，来看一下iOS中源代码详细的编译、链接过程</p><h2 id="二、编译、静态链接过程"><a href="#二、编译、静态链接过程" class="headerlink" title="二、编译、静态链接过程"></a>二、编译、静态链接过程</h2><blockquote><p>从源码到可执行文件 — iOS应用编译、静态链接过程</p></blockquote><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p><p>我们先来一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINEEight 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eight = DEFINEEight;</span><br><span class="line">    <span class="keyword">int</span> six = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = eight + six;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</span><br><span class="line">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</span><br></pre></td></tr></table></figure><p>然后将该可执行文件copy到手机目录 /usr/bin 下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx-iPhone:/usr/bin root<span class="comment"># ./main</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>下面深入剖析其中的过程。</p><h3 id="Clang常用命令与参数"><a href="#Clang常用命令与参数" class="headerlink" title="Clang常用命令与参数"></a>Clang常用命令与参数</h3><p><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">参考链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看编译的步骤</span></span><br><span class="line">clang -ccc-print-phases main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewrite Objective-C source to C++，将OC源代码重写为C++(仅供参考，与真正的运行时代码还是有细微差别的)</span></span><br><span class="line"><span class="comment">// 如果想了解真正的代码，可以使用-emit-llvm参数查看.ll中间代码</span></span><br><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作内部命令</span></span><br><span class="line">clang -##<span class="meta"># main.m -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接生成可执行文件</span></span><br><span class="line">clang main.m <span class="comment">// 默认生成的文件名为a.out</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">    -cc1：Clang编译器前端具有几个额外的Clang特定功能，这些功能不通过GCC兼容性驱动程序接口公开。 -cc1参数表示将使用编译器前端，而不是驱动程序。 clang -cc1功能实现了核心编译器功能。</span></span><br><span class="line"><span class="comment">-E：只进行预编译处理(preprocessor)</span></span><br><span class="line"><span class="comment">-S：只进行预编译、编译工作</span></span><br><span class="line"><span class="comment">-c：只进行预处理、编译、汇编工作</span></span><br><span class="line"><span class="comment">-fmodules：允许modules的语言特性。</span></span><br><span class="line"><span class="comment">在使用#include、#import时，会看到预处理时已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation。</span></span><br><span class="line"><span class="comment">所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</span></span><br><span class="line"><span class="comment">后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入。现在Xcode中默认是打开的，即编译源码时会加上-fmodules参数。也是因为modules机制的出现，pch不再默认自动创建。</span></span><br><span class="line"><span class="comment">使用了该参数，在导入库的地方，只需要 @import Foundation; 就行</span></span><br><span class="line"><span class="comment">可以看到使用了@import之后，clang -fmodules xx 生成的文件中，不再有上万行的系统库的代码引入，精简了很多。</span></span><br><span class="line"><span class="comment">-fsyntax-only：防止编译器生成代码,只是语法级别的说明和修改</span></span><br><span class="line"><span class="comment">-Xclang &lt;arg&gt;：向clang编译器传递参数</span></span><br><span class="line"><span class="comment">-dump-tokens：运行预处理器,拆分内部代码段为各种token</span></span><br><span class="line"><span class="comment">-ast-dump：构建抽象语法树AST,然后对其进行拆解和调试</span></span><br><span class="line"><span class="comment">-fobjc-arc：为OC对象生成retain和release的调用</span></span><br><span class="line"><span class="comment">-emit-llvm：使用LLVM描述汇编和对象文件</span></span><br><span class="line"><span class="comment">-o &lt;file&gt;：输出到目标文件</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>查看更多的<code>clang</code>使用方法可以在终端输入<code>clang --hep</code>查看,也可以点击下面的链接:<a href="https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110">https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110</a></p><h3 id="2-1-预处理（Preprocess）"><a href="#2-1-预处理（Preprocess）" class="headerlink" title="2.1 预处理（Preprocess）"></a>2.1 预处理（Preprocess）</h3><p>预编译过程主要处理源代码文件中的以”#”开头的预编译指令，<strong>不检查语法错误</strong>。规则如下：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。 </li><li>处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件内容插入到(全部复制到)该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。#include 可以导入任何(合法/不合法)文件，都能展开。</li><li>删除所有的注释“//”和“/* */”，会变成空行。 </li><li>保留所有的 #pragma 编译器指令，因为编译器须要使用它们。</li><li>添加行号和文件名标识，比如# 2 “main.m” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。<br>  格式是“<code># 行号 文件名 标志</code>”，参数解释如下：<ul><li>行号与文件名：表示从它后一行开始的内容来源于哪一个文件的哪一行</li><li>标志：可以是1,2,3,4四个数字，每个数字的含义如下：<br>1：表示新文件的开始<br>2：表示从一个被包含的文件中返回<br>3：表示后面的内容来自系统头文件<br>4：表示后面的内容应当被当做一个隐式的extern ‘C’块</li></ul></li></ul><p>经过预编译后的<code> .i 文件</code>不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><p>可以通过执行以下命令，<code>-E</code>表示只进行预编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">clang -E -fmodules main.m <span class="comment"># 此时需要源码中改为@import</span></span><br></pre></td></tr></table></figure><p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"># 408 &quot;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4</span><br><span class="line"># 2 &quot;main.m&quot; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int eight &#x3D; 8;</span><br><span class="line">    int six &#x3D; 6;</span><br><span class="line">    int rank &#x3D; eight + six;</span><br><span class="line">    printf(&quot;%d\n&quot;,rank);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。</p><h3 id="2-2-词法分析-Lexical-Analysis"><a href="#2-2-词法分析-Lexical-Analysis" class="headerlink" title="2.2 词法分析 (Lexical Analysis)"></a>2.2 词法分析 (Lexical Analysis)</h3><p>预处理之后，就是编译。编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p><p>首先，Clang 会对代码进行词法分析，将代码切分成 Token。你可以在<a href="https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">这个链接</a><br>中，看到 Clang 定义的所有 Token 类型。我们可以把这些 Token 类型，分为下面这 4 类。 </p><ul><li>关键字：语法中的关键字，比如 if、else、while、for 等;</li><li>标识符：变量名;</li><li>字面量：值、数字、字符串; </li><li>特殊符号：加减乘除、左右括号等符号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure><p>每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int &#39;int&#39; [StartOfLine]Loc&#x3D;&lt;main.m:4:1&gt;</span><br><span class="line">identifier &#39;main&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:4:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:4:9&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:4:10&gt;</span><br><span class="line">l_brace &#39;&#123;&#39;Loc&#x3D;&lt;main.m:4:11&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:5:5&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:15&gt;</span><br><span class="line">numeric_constant &#39;8&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:17 &lt;Spelling&#x3D;main.m:2:21&gt;&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:5:28&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:6:5&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:13&gt;</span><br><span class="line">numeric_constant &#39;6&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:15&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:6:16&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:7:5&gt;</span><br><span class="line">identifier &#39;rank&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:14&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:16&gt;</span><br><span class="line">plus &#39;+&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:22&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:24&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:7:27&gt;</span><br><span class="line">identifier &#39;printf&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:8:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:8:11&gt;</span><br><span class="line">string_literal &#39;&quot;%d\n&quot;&#39;Loc&#x3D;&lt;main.m:8:12&gt;</span><br><span class="line">comma &#39;,&#39;Loc&#x3D;&lt;main.m:8:18&gt;</span><br><span class="line">identifier &#39;rank&#39;Loc&#x3D;&lt;main.m:8:19&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:8:23&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:8:24&gt;</span><br><span class="line">return &#39;return&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:9:5&gt;</span><br><span class="line">numeric_constant &#39;0&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:9:12&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:9:13&gt;</span><br><span class="line">r_brace &#39;&#125;&#39; [StartOfLine]Loc&#x3D;&lt;main.m:10:1&gt;</span><br><span class="line">eof &#39;&#39;Loc&#x3D;&lt;main.m:10:2&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-语法、语义分析"><a href="#2-3-语法、语义分析" class="headerlink" title="2.3 语法、语义分析"></a>2.3 语法、语义分析</h3><p>这个阶段有两个模块Parser(语法syntax分析器)、Sema(语义分析Semantic)配合完成：</p><ul><li>Parser：遍历每个Token做词句分析，根据当前语言的语法，验证语法是否正确，最后生成一个 节点（Nodes）并记录相关的信息。</li><li>Semantic：在Lex 跟 syntax Analysis之后, 已经确保 词 句已经是正确的形式，semantic 接着做return values, size boundaries, uninitialized variables 等检查，如果发现语义上有错误给出提示；如果没有错误就会将 Token 按照语法组合成语义，生成 Clang 语义节点(Nodes)，然后将这些节点按照层级关系构成抽象语法树(AST)。</li></ul><p>AST可以说是Clang的核心，大部分的优化, 判断都在AST处理（例如寻找Class, 替换代码…等)。此步骤会将 Clang Attr  转换成 AST 上的 AttributeList，能在clang插件上透过 <code>Decl::getAttr&lt;T&gt;</code> 获取</p><blockquote><p>Clang Attributes：是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程, 一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中, Ex: <code>NS_CLASS_AVAILABLE_IOS(9_0)</code></p></blockquote><p>结构跟其他Compiler的AST相同。与其他编译器不同的是 Clang的AST是由C++构成类似Class、Variable的层级表示，其他的则是以汇编语言编写。这代表着AST也能有对应的api，这让AST操作, 获取信息都比较容易，甚至还夹带着地址跟代码位置。</p><blockquote><p>AST Context: 存储所有AST相关资讯, 且提供ASTMatcher等遍历方法</p></blockquote><p>在 Clang的定义中，节点主要分成：Type(类型)，Decl(声明)，Stmt(陈述)，其他的都是这三种的派生。Type具体到某个语言的类型时便可以派生出 PointerType(指针类型)、ObjCObjectType(objc对象类型)、BuiltinType(内置基础数据类型)这些表示。通过这三者的联结、重复或选择（alternative)就能构成一门编程语言。举个例子，下图的一段代码：详细可以看<a href="https://www.stephenw.cc/2018/01/08/clang-ast/">了解 Clang AST</a></p><img src="/images/compilelink/06.png" alt="01" style="zoom:70%;" /><p>FunctionDecl、ParmVarDecl 都是基于 Decl派生的类，CompoundStmt、ReturnStmt、DeclStmt都是基于 Stmt派生的类。）</p><p>从上图中可以看到：</p><ul><li>一个FunctionDecl（函数的实现）由一个 ParmVarDecl联结 CompoundStmt组成。</li><li>函数的 CompoundStmt 由 DeclStmt和 ReturnStmt联结组成。</li><li>还可以发现这段代码的ParmVarDecl由 BuiltinType 和一个标识符字面量联结组成。</li></ul><p>很明显一门编程语言中还有很多其他形态，我们都可以用这种方式描述出来。所以说从抽象的角度看，拥有无限种形态的编程语言便可以用有限的形式来表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&#96;-FunctionDecl 0x7fcbb9947b20 &lt;main.m:4:1, line:10:1&gt; line:4:5 main &#39;int ()&#39;</span><br><span class="line">  &#96;-CompoundStmt 0x7fcbb9947fc8 &lt;col:11, line:10:1&gt;</span><br><span class="line">    |-DeclStmt 0x7fcbb9947c50 &lt;line:5:5, col:28&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947bd0 &lt;col:5, line:2:21&gt; line:5:9 used eight &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947c30 &lt;line:2:21&gt; &#39;int&#39; 8</span><br><span class="line">    |-DeclStmt 0x7fcbb9947d00 &lt;line:6:5, col:16&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947c80 &lt;col:5, col:15&gt; col:9 used six &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947ce0 &lt;col:15&gt; &#39;int&#39; 6</span><br><span class="line">    |-DeclStmt 0x7fcbb9947e20 &lt;line:7:5, col:27&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947d30 &lt;col:5, col:24&gt; col:9 used rank &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-BinaryOperator 0x7fcbb9947e00 &lt;col:16, col:24&gt; &#39;int&#39; &#39;+&#39;</span><br><span class="line">    |     |-ImplicitCastExpr 0x7fcbb9947dd0 &lt;col:16&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |     | &#96;-DeclRefExpr 0x7fcbb9947d90 &lt;col:16&gt; &#39;int&#39; lvalue Var 0x7fcbb9947bd0 &#39;eight&#39; &#39;int&#39;</span><br><span class="line">    |     &#96;-ImplicitCastExpr 0x7fcbb9947de8 &lt;col:24&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |       &#96;-DeclRefExpr 0x7fcbb9947db0 &lt;col:24&gt; &#39;int&#39; lvalue Var 0x7fcbb9947c80 &#39;six&#39; &#39;int&#39;</span><br><span class="line">    |-CallExpr 0x7fcbb9947f20 &lt;line:8:5, col:23&gt; &#39;int&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f08 &lt;col:5&gt; &#39;int (*)(const char *, ...)&#39; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | &#96;-DeclRefExpr 0x7fcbb9947e38 &lt;col:5&gt; &#39;int (const char *, ...)&#39; Function 0x7fcbb9932e70 &#39;printf&#39; &#39;int (const char *, ...)&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f68 &lt;col:12&gt; &#39;const char *&#39; &lt;NoOp&gt;</span><br><span class="line">    | | &#96;-ImplicitCastExpr 0x7fcbb9947f50 &lt;col:12&gt; &#39;char *&#39; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">    | |   &#96;-StringLiteral 0x7fcbb9947e98 &lt;col:12&gt; &#39;char [4]&#39; lvalue &quot;%d\n&quot;</span><br><span class="line">    | &#96;-ImplicitCastExpr 0x7fcbb9947f80 &lt;col:19&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |   &#96;-DeclRefExpr 0x7fcbb9947eb8 &lt;col:19&gt; &#39;int&#39; lvalue Var 0x7fcbb9947d30 &#39;rank&#39; &#39;int&#39;</span><br><span class="line">    &#96;-ReturnStmt 0x7fcbb9947fb8 &lt;line:9:5, col:12&gt;</span><br><span class="line">      &#96;-IntegerLiteral 0x7fcbb9947f98 &lt;col:12&gt; &#39;int&#39; 0</span><br></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><p>语法树直观图:</p><img src="/images/compilelink/07.png" alt="01" style="zoom:90%;" /><h4 id="2-3-1-静态分析-Static-Analyzer"><a href="#2-3-1-静态分析-Static-Analyzer" class="headerlink" title="2.3.1 静态分析 (Static Analyzer)"></a>2.3.1 静态分析 (Static Analyzer)</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg      Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when casting a malloc&#39;ed type T, whether the size is a multiple of the size of T</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><a href="http://clang-analyzer.llvm.org/scan-build.html">scan-build</a> 是用于静态分析代码的工具，它包含在 clang 的源码包中。使用scan-build可以从命令行运行分析器，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">roten@localhost scan-build % .&#x2F;scan-build --use-analyzer&#x3D;xcode xcodebuild -project Demo123.xcodeproj    &#x2F;&#x2F; 需要设置 --use-analyzer指定 clang 的路径</span><br><span class="line"></span><br><span class="line">scan-build: Using &#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang&#39; for static analysis</span><br><span class="line">Build settings from command line:</span><br><span class="line">    CLANG_ANALYZER_EXEC &#x3D; &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS &#x3D; </span><br><span class="line">    CLANG_ANALYZER_OUTPUT &#x3D; plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR &#x3D; &#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER &#x3D; YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">** BUILD SUCCEEDED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory &#39;&#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1&#39; because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure><p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org/">Clang 静态分析器</a></p><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。</p><h3 id="2-4-IR代码生成-CodeGen"><a href="#2-4-IR代码生成-CodeGen" class="headerlink" title="2.4 IR代码生成 (CodeGen)"></a>2.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.m&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.m&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 &#x3D; alloca i32, align 4</span><br><span class="line">  %2 &#x3D; alloca i32, align 4</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  store i32 8, i32* %2, align 4</span><br><span class="line">  store i32 6, i32* %3, align 4</span><br><span class="line">  %5 &#x3D; load i32, i32* %2, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6</span><br><span class="line">  store i32 %7, i32* %4, align 4</span><br><span class="line">  %8 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %9 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %8)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1, !2, !3, !4, !5, !6, !7&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!8&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 2, !&quot;SDK Version&quot;, [2 x i32] [i32 10, i32 15]&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!3 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA,__objc_imageinfo,regular,no_dead_strip&quot;&#125;</span><br><span class="line">!4 &#x3D; !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!5 &#x3D; !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!6 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!7 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!8 &#x3D; !&#123;!&quot;Apple clang version 11.0.0 (clang-1100.0.33.12)&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-1-中间代码优化-Optimize"><a href="#2-4-1-中间代码优化-Optimize" class="headerlink" title="2.4.1 中间代码优化 (Optimize)"></a>2.4.1 中间代码优化 (Optimize)</h4><p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>对应着不同的入参，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p><img src="/images/compilelink/08.png" alt="01" style="zoom:95%;" /><img src="/images/compilelink/09.png" alt="01" style="zoom:85%;" /><p>我们还可以去写一些自己的Pass，官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 5 documentation</a>。</p><h3 id="2-5-生成字节码-LLVM-Bitcode"><a href="#2-5-生成字节码-LLVM-Bitcode" class="headerlink" title="2.5 生成字节码 (LLVM Bitcode)"></a>2.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在，开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p><blockquote><p>Bitcode是编译后的程序的中间表现，包含Bitcode并上传到App Store Connect的Apps会在App Store上编译和链接。包含Bitcode可以在不提交新版本App的情况下，允许Apple在将来的时候再次优化你的App 二进制文件。<br>对于iOS Apps，Enable bitcode 默认为YES，是可选的（可以改为NO）。对于WatchOS和tvOS，bitcode是强制的。如果你的App支持bitcode，App Bundle（项目中所有的target）中的所有的Apps和frameworks都需要包含Bitcode。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure><img src="/images/compilelink/10.png" alt="01" style="zoom:90%;" /><h3 id="2-6-生成相关汇编"><a href="#2-6-生成相关汇编" class="headerlink" title="2.6 生成相关汇编"></a>2.6 生成相关汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">10</span>, <span class="number">15</span>sdk_version <span class="number">10</span>, <span class="number">15</span></span><br><span class="line">.globl_main                   ## -- Begin <span class="meta">function</span> main</span><br><span class="line">.p2align<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## <span class="comment">@main</span></span><br><span class="line">.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq<span class="number">$32</span>, %rsp</span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">movl<span class="number">$8</span>, -<span class="number">8</span>(%rbp)</span><br><span class="line">movl<span class="number">$6</span>, -<span class="number">12</span>(%rbp)</span><br><span class="line">movl-<span class="number">8</span>(%rbp), %eax</span><br><span class="line">addl-<span class="number">12</span>(%rbp), %eax</span><br><span class="line">movl%eax, -<span class="number">16</span>(%rbp)</span><br><span class="line">movl-<span class="number">16</span>(%rbp), %esi</span><br><span class="line">leaqL_.str(%rip), %rdi</span><br><span class="line">movb<span class="number">$0</span>, %al</span><br><span class="line">callq_printf</span><br><span class="line">xorl%esi, %esi</span><br><span class="line">movl%eax, -<span class="number">20</span>(%rbp)         ## <span class="number">4</span>-byte Spill</span><br><span class="line">movl%esi, %eax</span><br><span class="line">addq<span class="number">$32</span>, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line"><span class="meta">.section</span>__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## <span class="comment">@.str</span></span><br><span class="line"><span class="meta">.asciz</span><span class="string">&quot;%d\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.section</span>__<span class="meta">DATA</span>,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line"><span class="symbol">L_OBJC_IMAGE_INFO:</span></span><br><span class="line"><span class="meta">.long</span><span class="number">0</span></span><br><span class="line"><span class="meta">.long</span><span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure><h3 id="2-7-生成目标文件"><a href="#2-7-生成目标文件" class="headerlink" title="2.7 生成目标文件"></a>2.7 生成目标文件</h3><p>编译阶段完成，接下来就是汇编阶段。汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。</p><p>这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure><img src="/images/compilelink/11.png" alt="01" style="zoom:90%;" /><h3 id="2-8-生成可执行文件"><a href="#2-8-生成可执行文件" class="headerlink" title="2.8 生成可执行文件"></a>2.8 生成可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main  <span class="comment"># 生成可执行文件</span></span><br><span class="line">./main  <span class="comment"># 执行 可执行文件 代码</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果：14</span><br></pre></td></tr></table></figure><h3 id="2-9-记录一个Clang命令报错"><a href="#2-9-记录一个Clang命令报错" class="headerlink" title="2.9 记录一个Clang命令报错"></a>2.9 记录一个Clang命令报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:59:11: error: #include nested too deeply  </span><br><span class="line"># include &lt;stdint.h&gt;  </span><br><span class="line">          ^  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:82:11: error: #include nested too deeply</span><br><span class="line"># include &lt;inttypes.h&gt;</span><br><span class="line">          ^</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>可能是xcode-select 没装，于是执行xcode-select –install 进行工具安装。</p></li><li><p>如果问题还在。brew doctor一下就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/includes</span><br><span class="line">brew doctor 2&gt;&amp;1 | grep <span class="string">&quot;/usr/local/include&quot;</span> | awk <span class="string">&#x27;&#123;$1=$1;print&#125;&#x27;</span> | xargs -I _ mv _ /tmp/includes </span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://github.com/SOHU-Co/kafka-node/issues/881">https://github.com/SOHU-Co/kafka-node/issues/881</a></p></li></ol><h2 id="三、小结：iOS从编码到打包"><a href="#三、小结：iOS从编码到打包" class="headerlink" title="三、小结：iOS从编码到打包"></a>三、小结：iOS从编码到打包</h2><ul><li>首先我们编写完成代码之后，会通过LLVM编译器预处理我们的代码，比如将宏放在指定的位置</li><li>预处理结束之后，LLVM会对代码进行词法分析和语法分析，生成AST。AST是抽象语法树，主要用来进行快速遍历，实现静态代码检查的功能。</li><li>AST会生成IR，IR是一种更加接近机器码的语言，通过IR可以生成不同平台的机器码。对于iOS平台，IR生成的可执行文件就是Mach-O.</li><li>然后通过链接器将符号和地址绑定在一起，并且将项目中的多个Mach-O文件(目标文件)合并成一个Mach-O文件(可执行文件)。(<strong>关于Mach-O、链接下一节讲</strong>)</li><li>将可执行文件与资源文件、storyboard、xib等打包，最后通过签名等操作生成.app文件，然后对.app文件进行压缩就生成了我们可以安装的ipa包。</li><li>当然，ipa包的安装途径有两种：<ul><li>通过开发者账号上传到App Store，然后在App Store上下载安装。</li><li>通过PP助手、iFunBox、Xcode等工具来安装</li></ul></li></ul><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="http://blog.alonemonkey.com/2016/12/21/learning-llvm/">关于LLVM，这些东西你必须知道!</a> 本篇文章大部分来自此文章。按照自己的理解记忆方式删减、添加了一些知识。原文中还补充有：<ul><li>Clang的三大基础设施(libclang、LibTooling、ClangPlugin)的应用、代码示例</li><li>动手写Pass的代码示例</li></ul></li><li><a href="https://xiaozhuanlan.com/topic/4916328705">深入剖析 iOS 编译 Clang / LLVM — 戴铭</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://juejin.im/post/6844903716709990414#heading-6">(Xcode) 編譯器小白筆記 - LLVM前端Clang</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编译、链接工具-—-Clang-LLVM&quot;&gt;&lt;a href=&quot;#一、编译、链接工具-—-Clang-LLVM&quot; class=&quot;headerlink&quot; title=&quot;一、编译、链接工具 — Clang/LLVM&quot;&gt;&lt;/a&gt;一、编译、链接工具 — Clang/LL</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
</feed>
