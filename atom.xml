<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-09-17T10:59:07.437Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图形处理(三) - 图形处理实践案例</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing.html</id>
    <published>2021-09-15T15:54:07.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。<a href="https://juejin.cn/post/6846687599591948301">原文链接 — iOS图片处理实践</a>、<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">项目代码</a>。</p><h2 id="一、图片手动解码"><a href="#一、图片手动解码" class="headerlink" title="一、图片手动解码"></a>一、图片手动解码</h2><p>写在前面：图片编码解码理论见上上篇</p><p>场景：适用于需要快速显示图片的地方，例如tableCell，先把图片进行bitmap解码操作加入缓存。同时如果是超大图可以和下面第三节的图片压缩方法搭配使用。</p><p>解决方案：通过CGBitmapContextCreate 重绘图片，这种压缩的图片等于手动进行了一次解码，可以加快图片的展示</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片处理-强制解压缩操作-把元数据绘制到当前的上下文-压缩图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithBitmap:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">   <span class="comment">//获取当前图片数据源</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//设置大小改变压缩图片</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">   <span class="comment">//创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建绘制当前图片的上下文</span></span><br><span class="line"><span class="comment">    CGBitmapContextCreate(void * __nullable data,</span></span><br><span class="line"><span class="comment">     size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span></span><br><span class="line"><span class="comment">     CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span></span><br><span class="line"><span class="comment">     data：所需要的内存空间 传nil会自动分配</span></span><br><span class="line"><span class="comment">     width/height：当前画布的大小</span></span><br><span class="line"><span class="comment">     bitsPerComponent：每个颜色分量的大小 RGBA 每一个分量占1个字节</span></span><br><span class="line"><span class="comment">     bytesPerRow：每一行使用的字节数 4*width</span></span><br><span class="line"><span class="comment">     bitmapInfo：RGBA绘制的顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef =</span><br><span class="line">   <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>,</span><br><span class="line">                         width,</span><br><span class="line">                         height,</span><br><span class="line">                         <span class="number">8</span>,</span><br><span class="line">                         <span class="number">4</span>*width,</span><br><span class="line">                         colorSpace,</span><br><span class="line">                         kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//根据数据源在上下文（画板）绘制图片</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   </span><br><span class="line">   imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、大图在本地的高效显示"><a href="#二、大图在本地的高效显示" class="headerlink" title="二、大图在本地的高效显示"></a>二、大图在本地的高效显示</h2><p>项目场景：1、下载大图后需要显示在屏幕上；2、本地读取大图显示在屏幕上。特别是对性能和图片要求较高的时候。</p><p>最佳解决方案：WWDC2018 苹果给的方案，见上上篇最后一节。</p><h2 id="三、图片压缩"><a href="#三、图片压缩" class="headerlink" title="三、图片压缩"></a>三、图片压缩</h2><p>写在前面：首先介绍两种最简单最常见的压缩方式，下面复杂的压缩方式也是在此之上的扩展，可以根据实际情况进行调整；</p><p>关于质量的压缩，苹果提供了一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br></pre></td></tr></table></figure><p>关于这个方法，理论上值越小表示图片质量越低，图片文件自然越小。但是并不是 compression 取 0，就是0b大小，取 1 就是原图。而且如果你是一张很大的图，即使compression = 0.0001等或更小，图片压缩到一定大小后，都无法再被压缩下去。</p><h3 id="3-1-按照指定压缩比例压缩图片"><a href="#3-1-按照指定压缩比例压缩图片" class="headerlink" title="3.1 按照指定压缩比例压缩图片"></a>3.1 按照指定压缩比例压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照质量压缩</span></span><br><span class="line"><span class="comment">//主要弊端：如果有大图按这个方法，尺寸有可能依然很大</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQuality:(<span class="built_in">CGFloat</span>)rate &#123;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, rate);</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-按照指定尺寸压缩图片"><a href="#3-2-按照指定尺寸压缩图片" class="headerlink" title="3.2 按照指定尺寸压缩图片"></a>3.2 按照指定尺寸压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照尺寸压缩</span></span><br><span class="line"><span class="comment">// 主要弊端：图片可能会变形，质量也无法保证</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">   <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">   [<span class="keyword">self</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-具体的应用场景分析"><a href="#3-3-具体的应用场景分析" class="headerlink" title="3.3 具体的应用场景分析"></a>3.3 具体的应用场景分析</h3><h4 id="1-上传或存储有大小要求的图片"><a href="#1-上传或存储有大小要求的图片" class="headerlink" title="1. 上传或存储有大小要求的图片"></a>1. 上传或存储有大小要求的图片</h4><p>循环逐渐减小图片尺寸，直到图片稍小于指定大小，这样做的好处是可以在我们限定图片大小后，图片尺寸也是此时最大的。问题是循环次数多，效率低，耗时长。可以用二分法来提高效率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环逐渐减小图片尺寸，直到图片稍小于指定大小</span></span><br><span class="line"><span class="comment">// 同样的问题是循环次数多，效率低，耗时长。可以用二分法来提高效率，具体代码省略。这里介绍另外一种方法，比二分法更好，压缩次数少，而且可以使图片压缩后刚好小于指定大小(不只是 &lt; maxLength， &gt; maxLength * 0.9)。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleSize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="keyword">self</span>;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">       lastDataLength = data.length;</span><br><span class="line">       <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">       <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">       <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">       <span class="comment">// Use image to draw (drawInRect:), image is larger but more compression time</span></span><br><span class="line">       <span class="comment">// Use result image to draw, image is smaller but less compression time</span></span><br><span class="line">       [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">       resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">       <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">       data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-上传或存储有质量要求的图片"><a href="#2-上传或存储有质量要求的图片" class="headerlink" title="2. 上传或存储有质量要求的图片"></a>2. 上传或存储有质量要求的图片</h4><p>循环压缩图片质量直到图片稍小于指定大小，默认循环6次，循环太多次后面也再也压不下去，当然这个次数可以自行配置。好处就是最大限度的保证了图片质量。同样用二分法来提高效率。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环压缩图片质量直到图片稍小于指定大小。</span></span><br><span class="line"><span class="comment">// ⚠️：注意：当图片质量低于一定程度时，继续压缩没有效果。默认压缩最多6次,通过二分法来优化循环次数多</span></span><br><span class="line"><span class="comment">// 压缩图片质量的优点在于，尽可能保留图片清晰度，图片不会明显模糊；缺点在于，不能保证图片压缩后小于指定大小。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleQulity:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在大小有上限的情况下尽量保证质量"><a href="#3-在大小有上限的情况下尽量保证质量" class="headerlink" title="3. 在大小有上限的情况下尽量保证质量"></a>3. 在大小有上限的情况下尽量保证质量</h4><p>两种图片压缩方法结合 尽量兼顾质量和大小。以确保大小合适为标准。好处就是在大小限定的情况下最大保证了质量和尺寸。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQulitySize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="comment">// Compress by quality</span></span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> resultImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Compress by size</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">        lastDataLength = data.length;</span><br><span class="line">        <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                 (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">        [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">        resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, compression);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、图片像素修改操作"><a href="#四、图片像素修改操作" class="headerlink" title="四、图片像素修改操作"></a>四、图片像素修改操作</h2><p>写在前面：这部分的理论都是通过图片重绘来修改修该图片位图中的像素值，从而达到图片的修改。</p><h3 id="4-1-图片灰度图-黑白图"><a href="#4-1-图片灰度图-黑白图" class="headerlink" title="4.1 图片灰度图(黑白图)"></a>4.1 图片灰度图(黑白图)</h3><p>灰度图的三种颜色转换算法：</p><ol><li><p>浮点算法：R = G = B = 0.3<em>R + 0.59</em>G + 0.11*B</p></li><li><p>平均值法：R = G = B = (R+G+B)/3</p></li><li><p>任取一个分量色：R = G = B = R或G或B</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToGray:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">    <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">            <span class="comment">//计算平均值重新存储像素点-直接操作像素点</span></span><br><span class="line">            uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">            <span class="comment">//rgbPiexl[0],rgbPiexl[1],rgbPiexl[2];</span></span><br><span class="line">            <span class="comment">//(rgbPiexl[0]+rgbPiexl[1]+rgbPiexl[2])/3;</span></span><br><span class="line">            uint32_t gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">                gray = (rgbPiexl[<span class="number">0</span>]+rgbPiexl[<span class="number">1</span>]+rgbPiexl[<span class="number">2</span>])/<span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rgbPiexl[<span class="number">0</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">1</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">2</span>] = gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文绘制</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-修改图片的RGB值"><a href="#4-2-修改图片的RGB值" class="headerlink" title="4.2 修改图片的RGB值"></a>4.2 修改图片的RGB值</h3><p>通过修改图片的RGB值来控制图片的颜色显示。或者替换某种颜色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToRGB:(<span class="built_in">CGFloat</span>)rk g:(<span class="built_in">CGFloat</span>)gk b:(<span class="built_in">CGFloat</span>)bk &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//1、获取图片宽高</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="comment">//2、创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">   <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">   <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">   <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">           <span class="comment">//操作像素点</span></span><br><span class="line">           uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">           <span class="comment">//该色值下不做处理</span></span><br><span class="line">           <span class="keyword">if</span> (rgbPiexl[<span class="number">0</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">1</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">2</span>]&gt;<span class="number">245</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;该色值下不做处理&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               rgbPiexl[<span class="number">0</span>] = rgbPiexl[<span class="number">0</span>]*rk;</span><br><span class="line">               rgbPiexl[<span class="number">1</span>] = rgbPiexl[<span class="number">1</span>]*gk;</span><br><span class="line">               rgbPiexl[<span class="number">2</span>] = rgbPiexl[<span class="number">2</span>]*bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据上下文绘制</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="comment">//释放用过的内存</span></span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">   free(imagePiexl);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-图片打码"><a href="#4-3-图片打码" class="headerlink" title="4.3 图片打码"></a>4.3 图片打码</h3><p>马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置马赛克</span></span><br><span class="line"><span class="comment">//马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</span></span><br><span class="line"><span class="comment">//同样使用强制解压缩操作，操作像素点，马赛克部分实际操作</span></span><br><span class="line"><span class="comment">//1、设置区域大小；</span></span><br><span class="line"><span class="comment">//2、在该区域获取一个像素点（第一个）作为整个区域的取色；</span></span><br><span class="line"><span class="comment">//3、将取色设置到区域中；</span></span><br><span class="line"><span class="comment">//4、取下一个区域同上去色设置区域</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageToMosaic:(<span class="built_in">NSInteger</span>)size; &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="comment">//5、获取像素数组</span></span><br><span class="line">    <span class="built_in">UInt8</span> *bitmapPixels = <span class="built_in">CGBitmapContextGetData</span>(contextRef);</span><br><span class="line">    <span class="built_in">UInt8</span> *pixels[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentPixels = <span class="number">0</span>;<span class="comment">//当前的像素点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> preCurrentPiexls = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> mosaicSize = size;<span class="comment">//马赛克尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>;  i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span> ; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            currentPixels = i * width + j;</span><br><span class="line">            <span class="keyword">if</span> (i % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    memcpy(pixels, bitmapPixels + <span class="number">4</span> * currentPixels, <span class="number">4</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, pixels, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCurrentPiexls = (i - <span class="number">1</span>) * width + j;</span><br><span class="line">                memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, bitmapPixels + <span class="number">4</span> * preCurrentPiexls, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文创建图片数据源</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、图形框架合成图片"><a href="#五、图形框架合成图片" class="headerlink" title="五、图形框架合成图片"></a>五、图形框架合成图片</h2><p>使用不同图形框架合成图片，添加滤镜水印等。</p><p>写在前面：理论和上面像素修改一样，通过操作像素达到修改图片的目的，但是这里使用了系统提供的不同框架和第三方GPUImage。不同框架效率也有所不一样。这里每段代码都加入了对应像素（黑白处理），只是为了学习，后面可以根据需求在对应代码块添加或替换对应对像素的操作，亦可后面加入参数进行封装。</p><h3 id="5-1-直接绘图合成"><a href="#5-1-直接绘图合成" class="headerlink" title="5.1 直接绘图合成"></a>5.1 直接绘图合成</h3><p>此方案原理上就是通过绘图，将多张图片的像素按照自己的设计绘制在一张图片上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingPixels:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line">   <span class="comment">// 1. Get the raw pixels of the image</span></span><br><span class="line">   <span class="built_in">UInt32</span> * backPixels;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGImageRef</span> backCGImage = [backImage <span class="built_in">CGImage</span>];</span><br><span class="line">   <span class="built_in">NSUInteger</span> backWidth = <span class="built_in">CGImageGetWidth</span>(backCGImage);</span><br><span class="line">   <span class="built_in">NSUInteger</span> backHeight = <span class="built_in">CGImageGetHeight</span>(backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> backBytesPerRow = bytesPerPixel * backWidth;</span><br><span class="line"></span><br><span class="line">   backPixels = (<span class="built_in">UInt32</span> *)calloc(backHeight * backWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(backPixels, backWidth, backHeight,</span><br><span class="line">                                                bitsPerComponent, backBytesPerRow, colorSpace,</span><br><span class="line">                                                kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, backWidth, backHeight), backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. Blend the pattern onto the image</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> frontCGImage = [frontImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.1 Calculate the size &amp; position of the pattern</span></span><br><span class="line">   <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line">   <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line">   <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"> <span class="comment">//    CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line">       <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 Scale &amp; Get pixels of the pattern</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> frontBytesPerRow = bytesPerPixel * frontSize.width;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UInt32</span> *frontPixels = (<span class="built_in">UInt32</span> *)calloc(frontSize.width * frontSize.height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> frontContext = <span class="built_in">CGBitmapContextCreate</span>(frontPixels, frontSize.width, frontSize.height,</span><br><span class="line">                                                     bitsPerComponent, frontBytesPerRow, colorSpace,</span><br><span class="line">                                                     kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(frontContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, frontSize.width, frontSize.height),frontCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 Blend each pixel</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> offsetPixelCountForInput = frontOrigin.y * backWidth + frontOrigin.x;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; frontSize.height; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; frontSize.width; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> *backPixel = backPixels + j * backWidth + i + offsetPixelCountForInput;</span><br><span class="line">           <span class="built_in">UInt32</span> backColor = *backPixel;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">UInt32</span> * frontPixel = frontPixels + j * (<span class="keyword">int</span>)frontSize.width + i;</span><br><span class="line">           <span class="built_in">UInt32</span> frontColor = *frontPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Blend the pattern with 50% alpha</span></span><br><span class="line"><span class="comment">//            CGFloat frontAlpha = 0.5f * (A(frontColor) / 255.0);</span></span><br><span class="line">           <span class="built_in">CGFloat</span> frontAlpha = <span class="number">1.0</span>f * (A(frontColor) / <span class="number">255.0</span>);</span><br><span class="line">           <span class="built_in">UInt32</span> newR = R(backColor) * (<span class="number">1</span> - frontAlpha) + R(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newG = G(backColor) * (<span class="number">1</span> - frontAlpha) + G(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newB = B(backColor) * (<span class="number">1</span> - frontAlpha) + B(frontColor) * frontAlpha;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Clamp, not really useful here :p</span></span><br><span class="line">           newR = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newR));</span><br><span class="line">           newG = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newG));</span><br><span class="line">           newB = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newB));</span><br><span class="line"></span><br><span class="line">           *backPixel = RGBAMake(newR, newG, newB, A(backColor));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Convert the image to Black &amp; White</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; backHeight; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; backWidth; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> * currentPixel = backPixels + (j * backWidth) + i;</span><br><span class="line">           <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Average of RGB = greyscale</span></span><br><span class="line">           <span class="built_in">UInt32</span> averageColor = (R(color) + G(color) + B(color)) / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">           *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Create a new UIImage</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">   <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5. Cleanup!</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(frontContext);</span><br><span class="line">   free(backPixels);</span><br><span class="line">   free(frontPixels);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-CoreGraphics-框架合成图片"><a href="#5-2-CoreGraphics-框架合成图片" class="headerlink" title="5.2 CoreGraphics 框架合成图片"></a>5.2 CoreGraphics 框架合成图片</h3><p>使用CoreGraphics框架合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingCoreGraphics:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line"> <span class="built_in">CGRect</span> imageRect = &#123;<span class="built_in">CGPointZero</span>,backImage.size&#125;;</span><br><span class="line"> <span class="built_in">NSInteger</span> backWidth = <span class="built_in">CGRectGetWidth</span>(imageRect);</span><br><span class="line"> <span class="built_in">NSInteger</span> backHeight = <span class="built_in">CGRectGetHeight</span>(imageRect);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. Blend the pattern onto our image</span></span><br><span class="line"> <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line"> <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"><span class="comment">//  CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line"> <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">CGRect</span> frontRect = &#123;frontOrigin, frontSize&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIGraphicsBeginImageContext</span>(backImage.size);</span><br><span class="line"> <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// flip drawing context</span></span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flip = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flipThenShift = <span class="built_in">CGAffineTransformTranslate</span>(flip,<span class="number">0</span>,-backHeight);</span><br><span class="line"> <span class="built_in">CGContextConcatCTM</span>(context, flipThenShift);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.1 Draw our image into a new CGContext</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [backImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.2 Set Alpha to 0.5 and draw our pattern on</span></span><br><span class="line"> <span class="built_in">CGContextSetBlendMode</span>(context, kCGBlendModeSourceAtop);</span><br><span class="line"> <span class="built_in">CGContextSetAlpha</span>(context,<span class="number">0.5</span>);</span><br><span class="line"> <span class="built_in">CGRect</span> transformedpatternRect = <span class="built_in">CGRectApplyAffineTransform</span>(frontRect, flipThenShift);</span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, transformedpatternRect, [frontImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIImage</span> * imageWithFront = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"> <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 2. Convert our image to Black and White</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.1 Create a new context with a gray color space</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, backWidth, backHeight,</span><br><span class="line">                          <span class="number">8</span>, <span class="number">0</span>, colorSpace, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.2 Draw our image into the new context</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [imageWithFront <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.3 Get our new B&amp;W Image</span></span><br><span class="line"> <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"> <span class="built_in">UIImage</span> * finalImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Cleanup</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"> <span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> finalImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-CoreImage-框架合成图片"><a href="#5-3-CoreImage-框架合成图片" class="headerlink" title="5.3 CoreImage 框架合成图片"></a>5.3 CoreImage 框架合成图片</h3><p>使用CoreImage 框架以添加滤镜形式合成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)processUsingCoreImage:(UIImage *)backImage frontImage:(UIImage *)frontImage &#123;</span><br><span class="line">  CIImage * backCIImage &#x3D; [[CIImage alloc] initWithImage:backImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 1. Create a grayscale filter</span><br><span class="line">  CIFilter * grayFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorControls&quot;];</span><br><span class="line">  [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. Create our pattern filter</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Cheat: create a larger pattern image</span><br><span class="line">  UIImage * patternFrontImage &#x3D; [self createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">  CIImage * frontCIImage &#x3D; [[CIImage alloc] initWithImage:patternFrontImage];</span><br><span class="line"></span><br><span class="line">  CIFilter * alphaFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorMatrix&quot;];</span><br><span class="line">&#x2F;&#x2F;  CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:0.5 W:0];</span><br><span class="line">     CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:1.0 W:0];</span><br><span class="line">  [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;];</span><br><span class="line">  </span><br><span class="line">  CIFilter * blendFilter &#x3D; [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. Apply our filters</span><br><span class="line">  [alphaFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  frontCIImage &#x3D; [alphaFilter outputImage];</span><br><span class="line"></span><br><span class="line">  [blendFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  [blendFilter setValue:backCIImage forKeyPath:@&quot;inputBackgroundImage&quot;];</span><br><span class="line">  CIImage * blendOutput &#x3D; [blendFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  CIImage * outputCIImage &#x3D; [grayFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. Render our output image</span><br><span class="line">  CIContext * context &#x3D; [CIContext contextWithOptions:nil];</span><br><span class="line">  CGImageRef outputCGImage &#x3D; [context createCGImage:outputCIImage fromRect:[outputCIImage extent]];</span><br><span class="line">  UIImage * outputImage &#x3D; [UIImage imageWithCGImage:outputCGImage];</span><br><span class="line">  CGImageRelease(outputCGImage);</span><br><span class="line">  </span><br><span class="line">  return outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createPaddedPatternImageWithSize 这是个生成滤镜图案的代码块具体请看<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">DEMO</a></p><h3 id="5-4-GPUImage-框架合成图片"><a href="#5-4-GPUImage-框架合成图片" class="headerlink" title="5.4 GPUImage 框架合成图片"></a>5.4 GPUImage 框架合成图片</h3><p>使用GPUImage 框架以添加滤镜形式合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingGPUImage:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 1. Create our GPUImagePictures</span></span><br><span class="line">   GPUImagePicture * backGPUImage = [[GPUImagePicture alloc] initWithImage:backImage];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> *fliterImage = [<span class="keyword">self</span> createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">   GPUImagePicture * frontGPUImage = [[GPUImagePicture alloc] initWithImage:fliterImage];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2. Setup our filter chain</span></span><br><span class="line">   GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init];</span><br><span class="line">   alphaBlendFilter.mix = <span class="number">0.5</span>;</span><br><span class="line">   </span><br><span class="line">   [backGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">0</span>];</span><br><span class="line">   [frontGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">   GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init];</span><br><span class="line">   </span><br><span class="line">   [alphaBlendFilter addTarget:grayscaleFilter];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3. Process &amp; grab output image</span></span><br><span class="line">   [backGPUImage processImage];</span><br><span class="line">   [frontGPUImage processImage];</span><br><span class="line">   [grayscaleFilter useNextFrameForImageCapture];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> * output = [grayscaleFilter imageFromCurrentFramebuffer];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-对比总结"><a href="#5-5-对比总结" class="headerlink" title="5.5 对比总结"></a>5.5 对比总结</h3><ul><li>从代码量来看：明显1直接绘图合成的代码量明显高出许多。CoreImage，和GPUImage的方案要自己加入pattern图，其实代码量也不算少。因此仅从合成图这个功能来看。代码量上 CoreGraphic方案最优。</li><li>从性能来看：本地测试，CoreGraphic，直接绘图合成，速度最快。GPUImage也差不多，CoreImage添加滤镜方案最慢。</li><li>从可控多样性需求来说：GPUImage本来就提供很多滤镜，同时开源。无疑当前最佳，但是其他的都可以自己进行对应功能封装。</li></ul><p>总的来说还是要看项目需求，个人觉得一般性添加水印，合成图片什么如果要直接用CoreGraphic是个不错的选择，以后有时间可以基于CoreGraphic封装功能。</p><h2 id="六、参考文档"><a href="#六、参考文档" class="headerlink" title="六、参考文档"></a>六、参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/822841145b52">iOS图片压缩</a></li><li><a href="https://link.juejin.cn/?target=https://www.raywenderlich.com/sessions/new?return_path=/2335-image-processing-in-ios-part-1-raw-bitmap-modification">Image-Processing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。&lt;a href=&quot;https://juejin.cn/post/68466875</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(二) - 图形与视频处理相关的框架</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing.html</id>
    <published>2021-09-15T15:54:01.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 - <a href="https://juejin.cn/post/6844903645272604679">iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，OpenCV等</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚接触iOS图形相关框架的小白，有一些图形框架在字面上和功能上非常容易混淆。这里旨在总结一下各种框架，区分它们的概念和功能，以作日后进一步细分学习的指引。因而，<strong>本文并不会针对具体框架作详解，只作区分引导</strong>，读者可自行选择方向继续深造。为此，笔者总结了一张各种框架关系图，如下所示：</p><img src="/images/graphics/GraphicsFrames.png" alt="GraphicsFrames" style="zoom:40%;" /><img src="/images/iosrender/01.png" alt="01" style="zoom:90%;" /><p>总的来说，iOS与图形图像处理相关的框架都在这里了：</p><ul><li>界面图形框架 – UIKit</li><li>核心动画框架 – Core Animation</li><li>苹果封装的图形框架 – Core Graphics &amp; Quartz 2D</li><li>传统跨平台图形框架 – OpenGL ES</li><li>苹果最新力推的图形框架 – Metal</li><li>适合图片的苹果滤镜框架 – Core Image</li><li>适合视频的第三方滤镜方案 – GPUImage</li><li>游戏引擎 – Scene Kit (3D) 和 Sprite Kit (2D)</li><li>计算机视觉在iOS的应用 – OpenCV for iOS</li></ul><h2 id="一、界面图形-—-UIKit"><a href="#一、界面图形-—-UIKit" class="headerlink" title="一、界面图形 — UIKit"></a>一、界面图形 — UIKit</h2><h3 id="1-1-UIKit"><a href="#1-1-UIKit" class="headerlink" title="1.1 UIKit"></a>1.1 UIKit</h3><p>UIKit是一组Objective-C API，为线条图形、Quartz图像和颜色操作提供Objective-C 封装，并提供2D绘制、图像处理及用户接口级别的动画。</p><p>UIKit包括UIBezierPath（绘制线、角度、椭圆及其它图形）、UIImage（显示图像）、UIColor（颜色操作）、UIFont和UIScreen（提供字体和屏幕信息）等类以及在位图图形环境、PDF图形环境上进行绘制和 操作的功能等, 也提供对标准视图的支持，也提供对打印功能的支持。</p><h3 id="1-2-UIKit与Core-Graphics的关系"><a href="#1-2-UIKit与Core-Graphics的关系" class="headerlink" title="1.2 UIKit与Core Graphics的关系"></a>1.2 UIKit与Core Graphics的关系</h3><p>在UIKit中，UIView类本身在绘制时<strong>自动创建一个图形环境，即Core Graphics层的CGContext类型，作为当前的图形绘制环境</strong>。在绘制时可以调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">    &#x2F;&#x2F; Drawing code</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#x2F;&#x2F;1.获取上下文</span><br><span class="line">    CGContextRef contextRef &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;2.描述路径</span><br><span class="line">    UIBezierPath * path &#x3D; [UIBezierPath bezierPath];</span><br><span class="line">    &#x2F;&#x2F;起点</span><br><span class="line">    [path moveToPoint:CGPointMake(10, 10)];</span><br><span class="line">    &#x2F;&#x2F;终点</span><br><span class="line">    [path addLineToPoint:CGPointMake(100, 100)];</span><br><span class="line">    &#x2F;&#x2F;设置颜色</span><br><span class="line">    [[UIColor whiteColor]setStroke];</span><br><span class="line">    &#x2F;&#x2F;3.添加路径</span><br><span class="line">    CGContextAddPath(contextRef, path.CGPath);</span><br><span class="line">    &#x2F;&#x2F;显示路径</span><br><span class="line">    CGContextStrokePath(contextRef);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这段代码就是在UIView的子类中调用 <code>UIGraphicsGetCurrentContext</code> 函数获得当前的图形环境，然后向该图形环境添加路径，最后绘制。</p><h2 id="二、核心动画-—-Core-Animation"><a href="#二、核心动画-—-Core-Animation" class="headerlink" title="二、核心动画 — Core Animation"></a>二、核心动画 — Core Animation</h2><h3 id="2-1-Core-Animation"><a href="#2-1-Core-Animation" class="headerlink" title="2.1 Core Animation"></a>2.1 Core Animation</h3><p>Core Animation 是一套Objective-C API，实现了一个高性能的复合引擎，并提供一个简单易用的编程接口，给用户UI添加平滑运动和动态反馈能力。</p><p>Core Animation 是 UIKit 实现动画和变换的基础，也负责视图的复合功能。使用Core Animation可以实现定制动画和细粒度的动画控制，创建复杂的、支持动画和变换的layered 2D视图。</p><p>Core Animation 不属于绘制系统，但它是以硬件复合和操作显示内容的基础设施。这个基础设施的核心是layer对象，用来管理和操作显示内容。在 iOS 中 <strong>每一个视图都对应Core Animation的一个层对象</strong>，与视图一样，层之间也组织为层关系树。一个层捕获视图内容为一个被图像硬件容易操作的位图。在多数应用中层作为管理视图的方式使用，但也可以创建独立的层到一个层关系树中来显示视图不够支持的显示内容。</p><p>OpenGL ES的内容也可以与Core Animation内容进行集成。</p><p>为了使用Core Animation实现动画，可以修改 <strong>层的属性值</strong> 来触发一个action对象的执行，不同的action对象实现不同的动画。</p><h3 id="2-2-Core-Animatio相关基类及子类"><a href="#2-2-Core-Animatio相关基类及子类" class="headerlink" title="2.2 Core Animatio相关基类及子类"></a>2.2 Core Animatio相关基类及子类</h3><p>Core Animation 提供了一下一组应用可以采用的类来提供对不同动画类型的支持：</p><ul><li><strong>CAAnimation</strong> 是一个抽象公共基类，CAAnimation采用CAMediaTiming 和CAAction协议为动画提供时间（如周期、速度、重复次数等）和action行为（启动、停止等）。</li><li><strong>CAPropertyAnimation</strong> 是  CAAnimation的抽象子类，为动画提供一个由一个key路径规定的层属性的支持；</li><li><strong>CABasicAnimation</strong> 是CAPropertyAnimation的具体子类，为一个层属性提供简单插入能力。</li><li><strong>CAKeyframeAnimation</strong> 也是CAPropertyAnimation的具体子类，提供key帧动画支持。</li></ul><h2 id="三、苹果封装的图形框架-—-Core-Graphics"><a href="#三、苹果封装的图形框架-—-Core-Graphics" class="headerlink" title="三、苹果封装的图形框架 — Core Graphics"></a>三、苹果封装的图形框架 — Core Graphics</h2><blockquote><p><a href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphics</a> 框架基于 Quartz 高级绘图引擎。 它提供具有无与伦比的输出保真度的低级、轻量级 2D 渲染。 您可以使用此框架来处理基于路径的绘图、转换、离屏渲染、抗锯齿渲染、颜色管理、渐变和阴影、图案、图像数据管理、图像创建和图像遮罩，以及 PDF 文档的创建、显示和解析。 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html?language=objc#//apple_ref/doc/uid/TP30001066">Quartz 2D Programming Guide</a></p><p>在 macOS 中，Core Graphics 还包括用于处理显示硬件、低级用户输入事件和窗口系统的服务。</p></blockquote><h3 id="3-1-Core-Graphics"><a href="#3-1-Core-Graphics" class="headerlink" title="3.1 Core Graphics"></a>3.1 Core Graphics</h3><p>Core Graphics是一套C-based API， 支持向量图形，线、形状、图案、路径、剃度、位图图像和pdf 内容的绘制。</p><h3 id="3-2-Quartz-2D"><a href="#3-2-Quartz-2D" class="headerlink" title="3.2 Quartz 2D"></a>3.2 Quartz 2D</h3><p>Quartz 2D是Core Graphics中的2D 绘制呈现引擎。Quartz是资源和设备无关的,提供路径绘制，anti-aliased呈现，剃度填充图案，图像，透明绘制和透明层、遮蔽和阴影、颜色管理，坐标转换，字体、offscreen呈现、pdf文档创建、显示和分析等功能。</p><p>Quartz 2D能够与所有的图形和动画技术（如Core Animation, OpenGL ES, 和 UIKit 等）一起使用。</p><p>Quartz 2D采用paint模式进行绘制。</p><h3 id="3-3-图形环境Context"><a href="#3-3-图形环境Context" class="headerlink" title="3.3 图形环境Context"></a>3.3 图形环境Context</h3><p>Quartz 2D中使用的图形环境也由一个类CGContext表示。</p><p>在Quartz 2D中可以把一个图形环境作为一个绘制目标。当使用Quartz 2D进行绘制时，所有设备特定的特性被包含在你使用的特定类型的图形环境中，因此通过给相同的图像操作函数提供不同的图像环境你就能够画相同的图像到不同的设备上，因此做到了图像绘制的设备无关性。</p><p>图形环境Context是个比较抽象的东西，它不仅仅是一个可以绘制的图层，还包含为当前图层设置的参数，如阴影，线条粗细，绘制模式等。可以类比成一个新建的Photoshop图层以及当前笔触，颜色等配置。</p><p>对于移动平台，有三种常见的图形环境Context：</p><ul><li>位图上下文（A bitmap graphics context）：一般用于绘制图片或者自定义控件。<ul><li>View Graphics Context: 由UIView自动创建，你重写UIView drawRect方法时，你的内容会画在这个上下文上。</li><li>Bitmap Graphics Context: 绘制在该上下文的内容会以点阵形式存储在一块内存中。简单说，就是为图片开辟一块内存，然后在里面画东西，上下文帮你把图片内存抽象成一个Context(图层)了。</li></ul></li><li>PDF上下文（A PDF graphics context）：用于生成pdf文件。</li><li>图层上下文（A layer context）：用于离屏绘制（ offscreen drawing）。</li></ul><h3 id="3-4-Quartz-2D提供的主要类包括"><a href="#3-4-Quartz-2D提供的主要类包括" class="headerlink" title="3.4 Quartz 2D提供的主要类包括"></a>3.4 Quartz 2D提供的主要类包括</h3><ul><li>CGContext：表示一个图形环境；</li><li>CGPath：使用向量图形来创建路径，并能够填充和stroke；</li><li>CGImage：用来表示位图；</li><li>CGLayer：用来表示一个能够用于重复绘制和offscreen绘制的绘制层；</li><li>CGPattern：用来表示Pattern，用于重复绘制；</li><li>CGShading和 CGGradient：用于绘制剃度；</li><li>CGColor 和 CGColorSpace；用来进行颜色和颜色空间管理；</li><li>CGFont, 用于绘制文本；</li><li>CGPDFContentStream、CGPDFScanner、CGPDFPage、CGPDFObject,CGPDFStream, CGPDFString等用来进行pdf文件的创建、解析和显示。</li></ul><h2 id="四、传统跨平台图形框架-—-OpenGL-ES"><a href="#四、传统跨平台图形框架-—-OpenGL-ES" class="headerlink" title="四、传统跨平台图形框架 — OpenGL ES"></a>四、传统跨平台图形框架 — OpenGL ES</h2><h3 id="4-1-OpenGL-ES"><a href="#4-1-OpenGL-ES" class="headerlink" title="4.1 OpenGL ES"></a>4.1 OpenGL ES</h3><p>OpenGL ES是一套多功能开放标准的用于嵌入系统的C-based的图形库，用于2D和3D数据的可视化。OpenGL被设计用来转换一组图形调用功能到底层图形硬件（GPU），由GPU执行图形命令，用来实现复杂的图形操作和运算，从而能够高性能、高帧率利用GPU提供的2D和3D绘制能力。</p><p>OpenGL ES规范本身不定义绘制表面和绘制窗口，因此ios为了使用它必须提供和创建一个OpenGL ES 的呈现环境，创建和配置存储绘制命令结果的framebuffer 及创建和配置一个或多个呈现目标。</p><h3 id="4-2-EAGL"><a href="#4-2-EAGL" class="headerlink" title="4.2 EAGL"></a>4.2 EAGL</h3><p>在 iOS中使用EAGL提供的EAGLContext类 来实现和提供一个呈现环境，用来保持OpenGL ES使用到的硬件状态。EAGL是一个Objective-C API，提供使OpenGL ES与Core Animation和UIKIT集成的接口。</p><p>在调用任何OpenGL ES 功能之前必须首先初始化一个EAGLContext 对象。每一个IOS应用的每一个线程都有一个当前context，在调用OpenGL ES函数时，使用或改变此context中的状态。</p><p>EAGLContext 的类方法setCurrentContext: 用来设置当前线程的当前context。EAGLContext 的类方法currentContext 返回当前线程的当前context。在切换相同线程的两个上下文之前，必须调用glFlush函数来确保先前已提交的命令被提交到图形硬件中。</p><h3 id="4-3-GLKit"><a href="#4-3-GLKit" class="headerlink" title="4.3 GLKit"></a>4.3 GLKit</h3><p>可以采用不同的方式使用OpenGL ES以便呈现OpenGL ES内容到不同的目标：GLKit和CAEAGLLayer。</p><p>为了创建全屏幕的视图或使OpenGL ES内容与UIKit视图集成，可以使用GLKit。在使用GLKit时，GLKit提供的类GLKView类本身实现呈现目标及创建和维护一个framebuffer。</p><p>GLKit是一组Objective-C 类，为使用OpenGL ES 提供一个面向对象接口，用来简化OpenGL ES应用的开发。</p><h3 id="4-4-CAEAGLLayer"><a href="#4-4-CAEAGLLayer" class="headerlink" title="4.4 CAEAGLLayer"></a>4.4 CAEAGLLayer</h3><p>为了使OpenGL ES内容作为一个Core Animation层的部分内容时，可以使用CAEAGLLayer 作为呈现目标，并需要另外创建framebuffer以及自己实现和控制整个绘制流程。</p><h3 id="4-5-GLKit支持四个3D应用开发的关键领域"><a href="#4-5-GLKit支持四个3D应用开发的关键领域" class="headerlink" title="4.5 GLKit支持四个3D应用开发的关键领域"></a>4.5 GLKit支持四个3D应用开发的关键领域</h3><ol><li><p>GLKView 和 GLKViewController 类提供一个标准的OpenGL ES视图和相关联的呈现循环。GLKView可以作为OpenGL ES内容的呈现目标，GLKViewController提供内容呈现的控制和动画。视图管理和维护一个framebuffer，应用只需在framebuffer进行绘画即可。</p></li><li><p>GLKTextureLoader 为应用提供从IOS支持的各种图像格式的源自动加载纹理图像到OpenGL ES 图像环境的方式，并能够进行适当的转换，并支持同步和异步加载方式。</p></li><li><p>数学运算库，提供向量、矩阵、四元数的实现和矩阵堆栈操作等OpenGL ES 1.1功能。</p></li><li><p>Effect效果类提供标准的公共着色效果的实现。能够配置效果和相关的顶点数据，然后创建和加载适当的着色器。GLKit 包括三个可配置着色效果类：GLKBaseEffect实现OpenGL ES 1.1规范中的关键的灯光和材料模式, GLKSkyboxEffect提供一个skybox效果的实现, GLKReflectionMapEffect 在GLKBaseEffect基础上包括反射映射支持。</p></li></ol><h2 id="五、苹果最新力推的图形框架-—-Metal"><a href="#五、苹果最新力推的图形框架-—-Metal" class="headerlink" title="五、苹果最新力推的图形框架 — Metal"></a>五、苹果最新力推的图形框架 — Metal</h2><p>Metal框架支持GPU硬件加速、高级3D图形渲染以及大数据并行运算。且提供了先进而精简的API来确保框架的细粒度(fine-grain)，并且在组织架构、程序处理、图形呈现、运算指令以及指令相关数据资源的管理上都支持底层控制。其核心目的是尽可能的减少CPU开销，而将运行时产生的大部分负载交由GPU承担。</p><p>编写基于底层图形 API 的渲染引擎时，除了 Metal 以外的其他选择还有 OpenGL 和 OpenGL ES。</p><p>OpenGL 不仅支持包括 OSX，Windows，Linux 和 Android 在内的几乎所有平台，还有大量的教程，书籍和最佳实践指南等资料。目前，Metal 的资源非常有限，并且仅限于搭载了 64 位处理器的 iPhone 和 iPad。但另外一方面，因为 OpenGL 的限制，其性能与 Metal 相比并不占优势，毕竟后者是专门用来解决这些问题的。</p><p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenGL 在 iOS 上是私有框架，而 Core Image (使用了 OpenGL) 对这样的任务来说既不够强大又不够灵活。</p><h2 id="六、适合图片的苹果滤镜框架-—-Core-Image"><a href="#六、适合图片的苹果滤镜框架-—-Core-Image" class="headerlink" title="六、适合图片的苹果滤镜框架 — Core Image"></a>六、适合图片的苹果滤镜框架 — Core Image</h2><h3 id="6-1-滤镜术语"><a href="#6-1-滤镜术语" class="headerlink" title="6.1 滤镜术语"></a>6.1 滤镜术语</h3><p>摄影滤光镜，简称滤光镜、滤色镜或滤镜（Filter），是摄影时放在照相机镜头前端的一种玻璃或塑料镜片，能够对光的不同波段进行选择性吸收，从而对摄影作品产生特殊的效果。种类很多。一些图像处理软件也可以向图片中加入滤镜的模拟效果。</p><p>常用滤镜：</p><ul><li>UV镜 可降低紫外线射入镜头，另外常被做为保护镜：以保护镜头前方镜片</li><li>偏振镜 又称PL镜：可消除反光、增加色彩鲜艳</li><li>中性灰度滤镜 又称中灰镜、ND镜或减光镜：可以延长曝光时间，或在强光下可以使用大光圈正确曝光</li><li>渐变中灰滤镜 又称中灰渐变镜：可以应付大光比场景</li><li>暖色滤镜：可以暖化肤色</li></ul><p>一些图像处理软件针对性地提供了一些对传统滤镜效果的模拟功能，使图像达到一种特殊效果。滤镜通常需要同通道、图层、色阶等联合使用，才能使图像取得最佳艺术效果。</p><p>滤镜在软件界面中也直接以“滤镜”（Filter）称呼；日久便约定俗成，软件中将一些特定效果（effect）或预设（preset）以‘滤镜’统一称呼，特别于一些简单化傻瓜化软件中较为常见，如美图秀秀以及智能手机appInstagram等。如今智能手机自带的相机系统中也常见诸多滤镜。</p><h3 id="6-2-Core-Image"><a href="#6-2-Core-Image" class="headerlink" title="6.2 Core Image"></a>6.2 Core Image</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH1-TPXREF101">Core Image</a> 是一种图像处理和分析技术，旨在为静态和视频图像提供近乎实时的处理。它使用 GPU 或 CPU 渲染路径对来自 Core Graphics、Core Video 和 Image I/O 框架的图像数据类型进行操作。 </p><p>Core Image 通过提供易于使用的应用程序编程接口 (API) 来隐藏底层图形处理的细节。您无需了解 OpenGL、OpenGL ES 或 Metal 的详细信息即可利用 GPU 的强大功能，也无需了解 Grand Central Dispatch (GCD) 的任何相关信息即可获得多核处理的优势。 Core Image 为您处理细节。</p><p>Image I/O 编程接口框架允许应用程序读取和写入大多数图像文件格式。 该框架提供了高效率的色彩管理和对图像元数据的访问。</p></blockquote><img src="/images/graphics/architecture_2x.png" alt="" style="zoom:50%;" /><p>Core Image 是 iOS5 新加入到 iOS 平台的一个图像处理框架，提供了强大高效的图像处理功能， 用来对基于像素的图像进行操作与分析， 内置了很多强大的滤镜(Filter) (目前数量超过了180种)， 这些Filter 提供了各种各样的效果， 并且还可以通过 <code>滤镜链</code> 将各种效果的 <code>Filter叠加</code> 起来形成强大的自定义效果。</p><p>一个 <strong>滤镜</strong> 是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</p><p>一个 <strong>滤镜链</strong> 是一个链接在一起的滤镜网络，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。</p><p>iOS8 之后更是支持自定义 CIFilter，可以定制满足业务需求的复杂效果。</p><p>Core Image 的 API 主要就是三类：</p><ul><li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li><li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。它对所有的像素进行操作，用一些键-值设置来决定具体操作的程度。</li><li>CIContext 表示上下文，如 Core Graphics 以及 Core Data 中的上下文用于处理绘制渲染以及处理托管对象一样，Core Image 的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。</li></ul><p>Core Image 的另外一个优势，就是可以根据需求选择 CPU 或者 GPU 来处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建基于 CPU 的 CIContext 对象 (默认是基于 GPU，CPU 需要额外设置参数)</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: [<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:kCIContextUseSoftwareRenderer]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithOptions: <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于 GPU 的 CIContext 对象</span></span><br><span class="line">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">context = [<span class="built_in">CIContext</span> contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure><h2 id="七、适合视频的第三方滤镜方案-—-GPUImage"><a href="#七、适合视频的第三方滤镜方案-—-GPUImage" class="headerlink" title="七、适合视频的第三方滤镜方案 — GPUImage"></a>七、适合视频的第三方滤镜方案 — GPUImage</h2><p>GPUImage 优势： 最低支持 iOS 4.0，iOS 5.0 之后就支持自定义滤镜。 在低端机型上，GPUImage 有更好的表现。（这个我没用真正的设备对比过，GPUImage 的主页上是这么说的） GPUImage 在视频处理上有更好的表现。 GPUImage 的代码完成公开，实现透明。 可以根据自己的业务需求，定制更加复杂的管线操作。可定制程度高。</p><h2 id="八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D"><a href="#八、游戏引擎-—-Scene-Kit-3D-和-Sprite-Kit-2D" class="headerlink" title="八、游戏引擎 — Scene Kit (3D) 和 Sprite Kit (2D)"></a>八、游戏引擎 — <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D)</h2><p>对于寻找游戏引擎的开发者来说，Metal 不是最佳选择。苹果官方的的 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://link.juejin.cn/?target=https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D) 是更好的选择。这些 API 提供了包括物理模拟在内的更高级别的游戏引擎。</p><p>另外还有功能更全面的 3D 引擎，例如 Epic 的 <a href="https://link.juejin.cn/?target=https://www.unrealengine.com/">Unreal Engine</a> 或 <a href="https://link.juejin.cn/?target=http://unity3d.com/">Unity</a>，二者都是跨平台的。使用这些引擎，你无需直接使用 Metal 的 API，就可以从 Metal 中获益。</p><h3 id="8-1-2D渲染-–-SpriteKit"><a href="#8-1-2D渲染-–-SpriteKit" class="headerlink" title="8.1 2D渲染 – SpriteKit"></a>8.1 2D渲染 – SpriteKit</h3><p>SpriteKit 让开发者可以开发高性能、省电节能的 2D 游戏。在 iOS 8 中，我们新添了多项增强功能，这将使 2D 游戏体验更加精彩。这些新技术有助于使游戏角色的动作更加自然，并让开发者可以更轻松地在游戏中加入力场、检测碰撞和生成新的灯光效果。</p><h3 id="8-2-3D渲染-–-SceneKit"><a href="#8-2-3D渲染-–-SceneKit" class="headerlink" title="8.2 3D渲染 – SceneKit"></a>8.2 3D渲染 – SceneKit</h3><p>SceneKit 专为休闲 3D 游戏而设计，可让开发者渲染 3D 游戏场景。SceneKit 内置了物理引擎、粒子发生器和各种易用工具，可以轻松快捷地为 3D 物体编写动作。不仅如此，它还与 SpriteKit 完全集成，所以开发者可以直接在 3D 游戏中加入 SpriteKit 的素材。</p><h2 id="九、计算机视觉在iOS的应用-—-OpenCV-for-iOS"><a href="#九、计算机视觉在iOS的应用-—-OpenCV-for-iOS" class="headerlink" title="九、计算机视觉在iOS的应用 — OpenCV for iOS"></a>九、计算机视觉在iOS的应用 — OpenCV for iOS</h2><p>OpenCV 的 API 是 C++ 的。它由不同的模块组成，这些模块中包含范围极为广泛的各种方法，从底层的图像颜色空间转换到高层的机器学习工具。这里提供一个入门PDF文档 <a href="https://link.juejin.cn/?target=http://www.opencv.org.cn/forum.php?mod=viewthread&tid=33549">下载入口</a>。</p><p>使用 C++ API 并不是绝大多数 iOS 开发者每天都做的事，你需要使用 Objective-C++ 文件来调用 OpenCV 的函数。 也就是说，你不能在 Swift 或者 Objective-C 语言内调用 OpenCV 的函数。 这篇 OpenCV 的 <a href="https://link.juejin.cn/?target=http://docs.opencv.org/doc/tutorials/ios/video_processing/video_processing.html%23opencviosvideoprocessing">iOS 教程</a>告诉你只要把所有用到 OpenCV 的类的文件后缀名改为 <code>.mm</code> 就行了，包括视图控制器类也是如此。这么干或许能行得通，却不是什么好主意。正确的方式是给所有你要在 app 中使用到的 OpenCV 功能写一层 Objective-C++ 封装。这些 Objective-C++ 封装把 OpenCV 的 C++ API 转化为安全的 Objective-C API，以方便地在所有 Objective-C 类中使用。</p><p>走封装的路子，你的工程中就可以只在这些封装中调用 C++ 代码，从而避免掉很多让人头痛的问题，比如直接改文件后缀名会因为在错误的文件中引用了一个 C++ 头文件而产生难以追踪的编译错误。</p><p>OpenCV 声明了命名空间 <code>cv</code>，因此 OpenCV 的类的前面会有个 <code>cv::</code> 前缀，就像 <code>cv::Mat</code>、 <code>cv::Algorithm</code> 等等。你也可以在 <code>.mm</code> 文件中使用 <code>using namespace cv</code> 来避免在一堆类名前使用 <code>cv::</code>前缀。但是，在某些类名前你必须使用命名空间前缀，比如 <code>cv::Rect</code> 和 <code>cv::Point</code>，因为它们会跟定义在 <code>MacTypes.h</code> 中的 <code>Rect</code> 和 <code>Point</code> 相冲突。尽管这只是个人偏好问题，我还是偏向在任何地方都使用 <code>cv::</code>以保持一致性。</p><p>一般讲的OpenCV是基于CPU的，相关资料和支持也是最完善的。当然，也有基于GPU模块，但提供的接口非常坑爹，相当一部分不支持浮点类型（像histogram、integral这类常用的都不支持）；又如，遇到阈值判断的地方，就必须传回cpu处理，因为gpu函数都是并行处理的，每改写完一个算法模块，就测试一下运行效率，有的时候是振奋人心，有的时候则是当头棒喝——比CPU还慢。详情可参阅 <a href="https://link.juejin.cn/?target=https://blog.csdn.net/kelvin_yan/article/details/41804357">这里</a>。</p><h2 id="十、参考文献"><a href="#十、参考文献" class="headerlink" title="十、参考文献"></a>十、参考文献</h2><ul><li><p>Core Animations</p><ul><li><a href="https://www.sohu.com/a/203987045_468740">https://www.sohu.com/a/203987045_468740</a> </li><li><a href="https://blog.csdn.net/huangznian/article/details/42919221">https://blog.csdn.net/huangznian/article/details/42919221</a> </li><li><a href="https://www.jianshu.com/p/446a6b72f981">https://www.jianshu.com/p/446a6b72f981</a> </li><li><a href="https://www.jianshu.com/p/439e158b44de">https://www.jianshu.com/p/439e158b44de</a></li></ul></li><li><p>Metal</p><ul><li><a href="https://juejin.cn/post/6844903494072139789">https://juejin.cn/post/6844903494072139789</a> </li><li><a href="https://www.jianshu.com/p/ce53d0178f20">https://www.jianshu.com/p/ce53d0178f20</a> </li><li><a href="https://blog.csdn.net/pizi0475/article/details/50232029">https://blog.csdn.net/pizi0475/article/details/50232029</a> </li><li><a href="https://baike.baidu.com/item/Metal/10917053?fr=aladdin">https://baike.baidu.com/item/Metal/10917053?fr=aladdin</a> </li><li><a href="https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral">https://zhuanlan.zhihu.com/p/24623380?utm_source=tuicool&amp;utm_medium=referral</a></li></ul></li><li><p>Core Image</p><ul><li><a href="https://objccn.io/issue-21-6/">https://objccn.io/issue-21-6/</a> </li><li><a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral">http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral</a> </li><li><a href="https://blog.csdn.net/jingcheng345413/article/details/54967640">https://blog.csdn.net/jingcheng345413/article/details/54967640</a> </li><li><a href="https://www.cnblogs.com/try2do-neo/p/3601546.html">https://www.cnblogs.com/try2do-neo/p/3601546.html</a></li></ul></li><li><p>Core Graphics</p><ul><li><a href="https://www.jianshu.com/p/e7a50dcbe7c8">https://www.jianshu.com/p/e7a50dcbe7c8</a> </li><li><a href="https://www.jianshu.com/p/55cc1587e618">https://www.jianshu.com/p/55cc1587e618</a> </li><li><a href="https://www.jianshu.com/p/494c57f49479">https://www.jianshu.com/p/494c57f49479</a> </li><li><a href="https://my.oschina.net/flyfishbay/blog/1504698">https://my.oschina.net/flyfishbay/blog/1504698</a></li></ul></li><li><p>OpenCV</p><ul><li><a href="https://blog.csdn.net/zhonggaorong/article/details/78191514">https://blog.csdn.net/zhonggaorong/article/details/78191514</a> </li><li><a href="http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549">http://www.opencv.org.cn/forum.php?mod=viewthread&amp;tid=33549</a> </li><li><a href="https://blog.csdn.net/kelvin_yan/article/details/41804357">https://blog.csdn.net/kelvin_yan/article/details/41804357</a> </li><li><a href="https://blog.csdn.net/sinat_31135199/article/details/53053188">https://blog.csdn.net/sinat_31135199/article/details/53053188</a> </li><li><a href="https://blog.csdn.net/liyuefeilong/article/details/46292339">https://blog.csdn.net/liyuefeilong/article/details/46292339</a></li></ul></li><li><p>GPUImage</p><ul><li><a href="https://blog.csdn.net/fanbird2008/article/details/51707430">https://blog.csdn.net/fanbird2008/article/details/51707430</a></li></ul></li><li><p>其它</p><ul><li><a href="https://blog.csdn.net/goohong/article/details/40743883">https://blog.csdn.net/goohong/article/details/40743883</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 - &lt;a href=&quot;https://juejin.cn/post/6844903645272604679&quot;&gt;iOS图形处理概论：OpenGL ES，Metal，Core Graphics，Core Image，GPUImage，Open</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(一) - 图片的加载与编解码</title>
    <link href="https://tenloy.github.io/2021/09/13/image-encode-decode.html"/>
    <id>https://tenloy.github.io/2021/09/13/image-encode-decode.html</id>
    <published>2021-09-13T19:01:06.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、位图、色彩空间"><a href="#一、位图、色彩空间" class="headerlink" title="一、位图、色彩空间"></a>一、位图、色彩空间</h2><h3 id="1-1-色彩空间"><a href="#1-1-色彩空间" class="headerlink" title="1.1 色彩空间"></a>1.1 色彩空间</h3><p><a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93">色彩空间</a>（Color space）是对色彩的组织方式/表示方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定<strong>模拟</strong>和<strong>数字</strong>表示。数字表示，如Adobe RGB、sRGB、RGBA。</p><p>色彩空间并不唯一，比如：</p><ul><li><strong>当在计算机监视器上显示颜色的时候，通常使用RGB（红色、绿色、蓝色）色彩空间定义</strong>，这是另外一种生成同样颜色的方法，红色、绿色、蓝色被当作X、Y和Z坐标轴。</li><li>许多人都知道在绘画时可以使用红色、黄色和蓝色这三种原色生成不同的颜色，这些颜色就定义了一个色彩空间。我们将品红色的量定义为X 坐标轴、青色的量定义为Y坐标轴、黄色的量定义为Z坐标轴，这样就得到一个三维空间，每种可能的颜色在这个三维空间中都有唯一的一个位置。</li><li>另外一个生成同样颜色的方法是使用色相（X轴）、饱和度（色度）（Y轴）和明度（Z轴）表示，这种方法称为HSV色彩空间。</li><li>另外还有许多其它的色彩空间，许多可以按照这种方法用三维（X、Y、Z）、更多或者更少维表示，但是有些根本不能用这种方法表示。</li></ul><p>常见的六种色彩空间：RGB、HSV、CMY、HSL、Lab、YUV</p><h3 id="1-2-像素格式-pixel-format"><a href="#1-2-像素格式-pixel-format" class="headerlink" title="1.2 像素格式(pixel format)"></a>1.2 像素格式(pixel format)</h3><h4 id="1-2-1-像素格式"><a href="#1-2-1-像素格式" class="headerlink" title="1.2.1 像素格式"></a>1.2.1 像素格式</h4><p>像素格式（pixel format）是指像素色彩分量的大小和排列。</p><ul><li>规定了每个像素所使用的总位数以及用于存储像素色彩的红、绿、蓝和 alpha 分量的位数。(每个分量也称为通道)</li><li>描述了像素数据存储所用的格式。定义了像素在内存中的编码方式。</li></ul><h4 id="1-2-2-常见的像素格式"><a href="#1-2-2-常见的像素格式" class="headerlink" title="1.2.2 常见的像素格式"></a>1.2.2 常见的像素格式</h4><ul><li><p>位组格式Byte formats(PF_BYTE_*)：每个通道对应一个byte</p></li><li><p>Short格式(PF_SHORT_*)：每个通道对应一个unsigned short数据(16 bit整型)</p></li><li><p>Float16 格式(PF_FLOAT16_*)：每个通道对应一个16 bit 浮点数</p></li><li><p>Float32格式(PF_FLOAT32_*)：每个通道对应一个32 bit 浮点数</p></li><li><p>压缩格式formats (PF_DXT[1-5])：S3TC压缩纹理格式</p></li><li><p>本地格式 (PF_A8R8G8B8 以及其他大量的不同的类型)：这意味着在内存中使用了本地储存方式（big endian或者little endian，包括16，24，32位）的整形数据。同时意味着可以把PF_A8R8G8B8格式的图片看作一个32位的整形<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84">数组</a>，在16进制表现为0xAARRGGBB。这些字母的意义我们在稍后会提供。</p></li></ul><h4 id="1-2-3-颜色通道"><a href="#1-2-3-颜色通道" class="headerlink" title="1.2.3 颜色通道"></a>1.2.3 颜色通道</h4><p>颜色通道中R,G,B,A,L 以及 X 的意义是：</p><p>R：红色成分，通常范围从0.0（没有红色）到1.0（全部的红色）。</p><p>G：绿色成分，通常范围从0.0（没有绿色）到1.0（全部的绿色）。</p><p>B：蓝色成分，通常范围从0.0（没有蓝色）到1.0（全部的蓝色）。</p><p>A：alpha（不透明度）成分，通常范围从0.0（完全透明）到1.0（不透明）。</p><p>L：亮度成分，通常范围从0.0（黑暗）到1.0（全白）。最终这个成分会被分散到<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>每个中完成最终的图像效果。</p><p>X：这个是被系统忽略的成分。</p><p>对于RGBL通道来说，默认的情况下设置为0。而<a href="https://baike.baidu.com/item/Alpha%E9%80%9A%E9%81%93/3163191">Alpha通道</a>却不同，在默认的情况下被设定为1，代表不透明。</p><h3 id="1-3-位图"><a href="#1-3-位图" class="headerlink" title="1.3 位图"></a>1.3 位图</h3><blockquote><p>A bitmap image (or sampled(采样) image) is an array of pixels (or samples).  Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images. </p></blockquote><p>位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，就可以在屏幕上渲染整张图片了。</p><p>一堆像素点组成的二维数组，其中每个像素点都记录该点位的颜色等信息。显示出来就是一张图了。</p><p>既然像素要存储颜色数据，这里就又引出一个颜色存储格式的概念。我们就以最简单普遍的PF_BYTE_RGBA (32-bit RGBA) 像素格式为例子，一个像素点存储的色彩所需空间是32bits或是4bytes、1byte或8bit存储是一个通道，对应下来就是：</p><ul><li>R = red (占1byte或8bit)</li><li>G = green (占1byte或8bit)</li><li>B = blue (占1byte或8bit)</li><li>A = alpha (占1byte或8bit)</li></ul><p>这样你就知道 32-bit RGBA 格式能够显示的颜色是 2^8 * 2^8* 2^8 (256 * 256 * 256)，将近一千七百多万个颜色。还有颜色空间(Color Spaces)的概念这里就不再扩展了。</p><p>而位图是装载像素点的数组，这样你大概可以理解下一张普通位图包含着多少数据！同时，这里解释颜色是为了下面计算位图大小，便于理解我们为什么要进行图片编码。</p><h2 id="二、图片、编解码"><a href="#二、图片、编解码" class="headerlink" title="二、图片、编解码"></a>二、图片、编解码</h2><h3 id="2-1-编码与解码"><a href="#2-1-编码与解码" class="headerlink" title="2.1 编码与解码"></a>2.1 编码与解码</h3><p>图片的编码： 在当前APP的开发中，图片是经常会使用到的，关于图片有很多种格式，例如JPEG，PNG等。其实这些各种各样的图片格式都对应了位图(bitmap)经过不同算法编码(压缩)后的图片。 苹果提供2种图片编码格式，PNG和JPEG：</p><ul><li>PNG图片是无损压缩，并且支持alpha通道</li><li>JPEG图片则是有损压缩，可以指定0-100%的压缩比。</li></ul><p>图片的解码： </p><ul><li><p>app从磁盘中读入编码后的图片，需要经过解码把图片变成位图(bitmap)读入，这样才能显示在屏幕上。 </p></li><li><p>iOS 默认会在主线程对图像进行解码，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位图大小 = 图片的像素宽  * 图片的像素高  * 每个像素所占的字节数(取决于像素格式)</span><br></pre></td></tr></table></figure><h3 id="2-2-位图为什么要压缩编码"><a href="#2-2-位图为什么要压缩编码" class="headerlink" title="2.2 位图为什么要压缩编码"></a>2.2 位图为什么要压缩编码</h3><p>都知道，<strong>图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</strong>既然如此，图片不编码也就不用解码，都使用位图可以吗？</p><p>举例：一张位图的宽和高分别都是100个像素，那这个位图的大小是多少呢？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算一张位图size的公式</span></span><br><span class="line"><span class="comment">//bytesPerPixel每个像素点所需空间 </span></span><br><span class="line"><span class="comment">//32-bit RGBA 格式图片 bytesPerPixel = 4 (R,G,B,A各一个byte)，理论看上面</span></span><br><span class="line">size = width * height * bytesPerPixel </span><br></pre></td></tr></table></figure><p>这样把我们100x100 的位图代入该公式，可以得到其大小：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="number">100</span> * <span class="number">100</span> * <span class="number">4</span> = <span class="number">40000</span>B = <span class="number">39</span>KB</span><br></pre></td></tr></table></figure><p>正常一张PNG或JPEG格式的100x100的图片，大概只有几KB。如果更大的图，位图所占空间更大，所以位图必须进行编码进行存储。</p><h3 id="2-3-硬解码与软解码"><a href="#2-3-硬解码与软解码" class="headerlink" title="2.3 硬解码与软解码"></a>2.3 硬解码与软解码</h3><p>硬解码：由显卡核心GPU来对高清视频进行解码工作，通过解码电路实现，CPU占用率很低，画质效果比软解码略差一点，需要对播放器进行设置。(省电、对硬件要求高) </p><ul><li>优点：播放流畅、低功耗 </li><li>缺点：受视频格式限制、功耗大、画质没有软解码好 </li></ul><p>软解码：由CPU负责解码，通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码。(省电、对硬件要求不高) </p><ul><li>优点：不受视频格式限制、画质略好于硬解 </li><li>缺点：会占用过高的资源、对于高清视频可能没有硬解码流畅(主要看CPU的能力）</li></ul><h2 id="三、图片的加载及解码流程"><a href="#三、图片的加载及解码流程" class="headerlink" title="三、图片的加载及解码流程"></a>三、图片的加载及解码流程</h2><h3 id="3-1-图片的加载"><a href="#3-1-图片的加载" class="headerlink" title="3.1 图片的加载"></a>3.1 图片的加载</h3><h4 id="3-1-1-三种-Buffer-理念"><a href="#3-1-1-三种-Buffer-理念" class="headerlink" title="3.1.1 三种 Buffer 理念"></a>3.1.1 三种 Buffer 理念</h4><p>通常 Buffer 是表示一片连续的内存空间。在这里，我们说的 Buffer 是指一系列内部结构相同、大小相同的元素组成的内存区域。有三种Buffer：Data Buffer、Image Buffer、Frame Buffer。这个理论是2018WWDC苹果上描述的概念，具体可看<a href="https://link.juejin.cn/?target=https://asciiwwdc.com/2018/sessions/219">Image and Graphics Best Practices</a></p><ul><li>Data Buffer 是指存储在内存中的原始数据，图像可以使用不同的格式保存，如 jpg、png。Data Buffer 的信息不能用来描述图像的位图像素信息。</li><li>Image Buffer 是指图像在内存中的存在方式，其中每个元素描述了一个像素点。Image Buffer 的大小和位图的大小相等。</li><li>Frame Buffer 和 Image Buffer 内容相同，不过其存储在 vRAM（video RAM）中，而 Image Buffer 存储在 RAM 中。</li></ul><h4 id="3-1-2-两种生成UIImage的方法"><a href="#3-1-2-两种生成UIImage的方法" class="headerlink" title="3.1.2 两种生成UIImage的方法"></a>3.1.2 两种生成UIImage的方法</h4><p>iOS中根据本地icon加载出一个UIImage对象有两种方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img1 =  [<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pic1&quot;</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *img2 =  [<span class="built_in">UIImage</span> imageWithContentsOfFile:filePath];</span><br></pre></td></tr></table></figure><p><code>imageNamed</code>方法</p><ul><li>后面的参数是icon的名字。图片可以存在项目中，也可以存在Assets中。</li><li>这个方法加载完图片后会存在Cache里面，当用这个方法加载的时候，它会在系统缓存中查找并返回一个对象，如果缓存中没有找到对应的对象，这个方法会从指定的文档中加载，再返回对象。</li><li>优点是提高了运行速度，缺点是消耗内存。如果是不会复用的、大图，最好不要用该方法加载。</li></ul><p><code>imageWithContentsOfFile</code>方法</p><ol><li>后面的参数是图片的路径，格式是字符串</li><li>加载图片时，会根据路径查找，直接加载，使用完后释放，不会存入内存.</li><li>优点是节省内存，缺点是消耗性能。适用于一些不常用的图片或icon，或者资源比较大图片。</li></ol><p>总结：一些小的icon可以存在Assets里面，用imageNamed加载。一些比较大的，使用频率低的可以建立一个bundle存放图片，使用imageWithContentsOfFile 加载。</p><h3 id="3-3-图片的解码"><a href="#3-3-图片的解码" class="headerlink" title="3.3 图片的解码"></a>3.3 图片的解码</h3><h4 id="3-3-1-解码触发时机"><a href="#3-3-1-解码触发时机" class="headerlink" title="3.3.1 解码触发时机"></a>3.3.1 解码触发时机</h4><p>UIImage 是 iOS 中处理图像的高级类。创建一个 UIImage 实例只会加载 Data Buffer，也就是说以上只是把图片转为UIImage对象，该对象存储在Data Buffer里。此时并没有对图片进行解码。</p><p>当将图像显示到屏幕上会触发隐式解码（<strong>必须同时满足图像被设置到 UIImageView 中、UIImageView 添加到视图，才会触发图像解码</strong>）。也就是说你就算实例了一个UIImageView，但是没有把他addSubview，显示到视图上，系统也是不会进行解码的。</p><h4 id="3-3-2-主线程解码的性能问题"><a href="#3-3-2-主线程解码的性能问题" class="headerlink" title="3.3.2  主线程解码的性能问题"></a>3.3.2  主线程解码的性能问题</h4><p>这个解码过程默认是发生在主线程上面的，而且非常消耗 CPU，所以到如果在 tableView 或者 collectionView 中有相当多的图片需要显示的话，这些图片在主线程的解码操作必然会影响滑动的顺畅度。所以我们是否可以在子线程强制将其解码，然后在主线程让系统渲染解码之后的图片呢？当然可以，现在基本上所有的开源图片库都会实现这个操作。例如：YYImage\SDWebImage。</p><h4 id="3-3-3-手动解码的原理"><a href="#3-3-3-手动解码的原理" class="headerlink" title="3.3.3 手动解码的原理"></a>3.3.3 手动解码的原理</h4><p>自己手动解码的原理就是对图片进行重新绘制，得到一张新的解码后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(</span><br><span class="line">  <span class="keyword">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">                                  size_t width, </span><br><span class="line">                                  size_t height, </span><br><span class="line">                                  size_t bitsPerComponent, </span><br><span class="line">                                  size_t bytesPerRow,</span><br><span class="line">                                  <span class="built_in">CGColorSpaceRef</span> cg_nullable space, </span><br><span class="line">                                  uint32_t bitmapInfo) <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>这个方法是创建一个图片处理的上下文 CGContext 对象，因为上面方法的返回值 CGContextRef 实际上就是 CGContext *。关于这个函数的详细讲解博文有很多，官方文档<a href="https://link.juejin.cn/?target=https://developer.apple.com/documentation/coregraphics/1455939-cgbitmapcontextcreate?language=objc">CGBitmapContextCreate</a>。博客<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/e9843d5b70a2">图片解码</a>。</p><h4 id="3-3-4-开源框架解码实现"><a href="#3-3-4-开源框架解码实现" class="headerlink" title="3.3.4 开源框架解码实现"></a>3.3.4 开源框架解码实现</h4><p>开源框架的解决方案基础也是基于这个API：</p><h5 id="1-YYImage-中的解码"><a href="#1-YYImage-中的解码" class="headerlink" title="1. YYImage 中的解码"></a>1. YYImage 中的解码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="built_in">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!imageRef) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">       <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">       <span class="built_in">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">       <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">           alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">           alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">           alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">           hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">       <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">       <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">       bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">       <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">       <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">       <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">       <span class="built_in">CFRelease</span>(context);</span><br><span class="line">       <span class="keyword">return</span> newImage;</span><br><span class="line">       </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上, 这个方法的作用是创建一个图像的拷贝，它接受一个原始的位图参数 imageRef ，最终返回一个新的解码后的位图 newImage ，中间主要经过了以下三个步骤：</p><ul><li>使用 CGBitmapContextCreate 函数创建一个位图上下文；</li><li>使用 CGContextDrawImage 函数将原始位图绘制到上下文中;</li><li>使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。</li></ul><h5 id="2-SDWebImage的解码实现"><a href="#2-SDWebImage的解码实现" class="headerlink" title="2. SDWebImage的解码实现"></a>2. SDWebImage的解码实现</h5><p>事实上，SDWebImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">   <span class="keyword">if</span> (![<span class="built_in">UIImage</span> shouldDecodeImage:image]) &#123;</span><br><span class="line">       <span class="keyword">return</span> image;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</span></span><br><span class="line">   <span class="comment">// on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">   <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">       <span class="built_in">CGColorSpaceRef</span> colorspaceRef = [<span class="built_in">UIImage</span> colorSpaceForImageRef:imageRef];</span><br><span class="line">       </span><br><span class="line">       size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">       size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">       size_t bytesPerRow = kBytesPerPixel * width;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></span><br><span class="line">       <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></span><br><span class="line">       <span class="comment">// to create bitmap graphics contexts without alpha info.</span></span><br><span class="line">       <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                    width,</span><br><span class="line">                                                    height,</span><br><span class="line">                                                    kBitsPerComponent,</span><br><span class="line">                                                    bytesPerRow,</span><br><span class="line">                                                    colorspaceRef,</span><br><span class="line">                                                    kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);</span><br><span class="line">       <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> image;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Draw the image into the context and retrieve the new bitmap image without alpha</span></span><br><span class="line">       <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">       <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">       <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithoutAlpha</span><br><span class="line">                                                        scale:image.scale</span><br><span class="line">                                                  orientation:image.imageOrientation];</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">       <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">   <span class="comment">// Prevent &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; error</span></span><br><span class="line">   <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// do not decode animated images</span></span><br><span class="line">   <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">   <span class="built_in">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                    alpha == kCGImageAlphaLast ||</span><br><span class="line">                    alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                    alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">   <span class="comment">// do not decode images with alpha</span></span><br><span class="line">   <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDWebImage 中和其他不一样的地方，就是如果一张图片有 alpha 分量，那就直接返回原始图片，不再进行解码操作。这么做是因为alpha 分量不可知，为了保证原图完整信息故不做处理。</p><p>SDWebImage 在解码操作外面包了 autoreleasepool，这样在大量图片需要解码的时候，可以使得局部变量尽早释放掉，不会造成内存峰值过高。</p><h2 id="四、大图显示"><a href="#四、大图显示" class="headerlink" title="四、大图显示"></a>四、大图显示</h2><p>大的图片会占用较多的内存资源，解码和传输到 GPU 也会耗费较多时间。 因此，实际需要显示的图像尺寸可能并不是很大，如果能将大图缩小，便能达到优化的目的。</p><p>以下是WWDC给的大图显示方案，功能是缩小图像并解码：</p><h3 id="4-1-Objective-C："><a href="#4-1-Objective-C：" class="headerlink" title="4.1 Objective-C："></a>4.1 Objective-C：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大图缩小为显示尺寸的图</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)downsampleImageAt:(<span class="built_in">NSURL</span> *)imageURL to:(<span class="built_in">CGSize</span>)pointSize scale:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">    <span class="comment">// 利用图像文件地址创建 image source</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *imageSourceOptions =</span><br><span class="line">  @&#123;</span><br><span class="line">    (__bridge <span class="built_in">NSString</span> *)kCGImageSourceShouldCache: @NO <span class="comment">// 原始图像不要解码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> imageSource =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)imageURL, (__bridge <span class="built_in">CFDictionaryRef</span>)imageSourceOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下采样</span></span><br><span class="line">    <span class="built_in">CGFloat</span> maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *downsampleOptions =</span><br><span class="line">    @&#123;</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailFromImageAlways: @YES,</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceShouldCacheImmediately: @YES,  <span class="comment">// 缩小图像的同时进行解码</span></span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailWithTransform: @YES,</span><br><span class="line">      (__bridge <span class="built_in">NSString</span> *)kCGImageSourceThumbnailMaxPixelSize: @(maxDimensionInPixels)</span><br><span class="line">       &#125;;</span><br><span class="line">    <span class="built_in">CGImageRef</span> downsampledImage =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, (__bridge <span class="built_in">CFDictionaryRef</span>)downsampleOptions);</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:downsampledImage];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(downsampledImage);</span><br><span class="line">    <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Swift"><a href="#4-2-Swift" class="headerlink" title="4.2 Swift"></a>4.2 Swift</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Downsampling large images for display at smaller size</span></span><br><span class="line">func downsample(imageAt imageURL: URL, to pointSize: <span class="built_in">CGSize</span>, scale: <span class="built_in">CGFloat</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache: <span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale</span><br><span class="line">    let downsampleOptions =</span><br><span class="line">    [kCGImageSourceCreateThumbnailFromImageAlways: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">    kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels] as <span class="built_in">CFDictionary</span></span><br><span class="line"> </span><br><span class="line">    let downsampledImage =</span><br><span class="line">    <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://devstreaming-cdn.apple.com/videos/wwdc/2018/219mybpx95zm9x/219/219_image_and_graphics_best_practices.pdf?dl=1">WWDC2018</a></li><li><a href="https://juejin.cn/post/6847902216238399496">图片显示相关理论</a></li><li><a href="https://link.juejin.cn/?target=https://asciiwwdc.com/2018/sessions/219">Image and Graphics Best Practices</a></li><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/72dd074728d8">探讨iOS 中图片的解压缩到渲染过程</a></li><li><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/dins/p/ios-tu-pian.html">iOS 图片的解压缩</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、位图、色彩空间&quot;&gt;&lt;a href=&quot;#一、位图、色彩空间&quot; class=&quot;headerlink&quot; title=&quot;一、位图、色彩空间&quot;&gt;&lt;/a&gt;一、位图、色彩空间&lt;/h2&gt;&lt;h3 id=&quot;1-1-色彩空间&quot;&gt;&lt;a href=&quot;#1-1-色彩空间&quot; class=&quot;</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] iOS离屏渲染原理及优化</title>
    <link href="https://tenloy.github.io/2021/09/12/iOS-Render.html"/>
    <id>https://tenloy.github.io/2021/09/12/iOS-Render.html</id>
    <published>2021-09-12T20:24:55.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a>、<a href="https://juejin.cn/post/6846687603316490254">iOS圆角的离屏渲染</a></p></blockquote><p>作为一个客户端工程师，把控渲染性能是最关键、最独到的技术要点之一，如果仅仅了解表面知识，到了实际应用时往往会失之毫厘谬以千里，无法得到预期的效果。</p><h2 id="一、先来了解iOS的渲染流程"><a href="#一、先来了解iOS的渲染流程" class="headerlink" title="一、先来了解iOS的渲染流程"></a>一、先来了解iOS的渲染流程</h2><blockquote><p>如果对下图没有疑问，可以直接向下阅读。反之，可以先阅读上篇文章 <a href="https://tenloy.github.io/2021/09/11/core-animation03.html">渲染流程探究及性能分析</a></p></blockquote><img src="/images/iosrender/15.png" alt="01" style="zoom:39%;" /><h2 id="二、GPU的两种渲染方式"><a href="#二、GPU的两种渲染方式" class="headerlink" title="二、GPU的两种渲染方式"></a>二、GPU的两种渲染方式</h2><p>OpenGL中，GPU屏幕渲染有以下两种方式当前屏幕渲染：</p><h3 id="2-1-On-Screen-Rendering"><a href="#2-1-On-Screen-Rendering" class="headerlink" title="2.1 On-Screen Rendering"></a>2.1 On-Screen Rendering</h3><blockquote><p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p></blockquote><p>正常情况下，如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的帧缓冲区(frame buffer)，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。流程如图：</p><img src="/images/iosrender/03.png" alt="01" style="zoom:90%;" /><h3 id="2-2-Off-Screen-Rendering"><a href="#2-2-Off-Screen-Rendering" class="headerlink" title="2.2 Off-Screen Rendering"></a>2.2 Off-Screen Rendering</h3><blockquote><p>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个（离屏）缓冲区进行渲染操作。</p></blockquote><p>如果有时因为一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。流程如图：</p><img src="/images/iosrender/04.png" alt="01" style="zoom:90%;" /><h2 id="三、GPU离屏渲染"><a href="#三、GPU离屏渲染" class="headerlink" title="三、GPU离屏渲染"></a>三、GPU离屏渲染</h2><h3 id="3-1-为什么及何时需要离屏渲染"><a href="#3-1-为什么及何时需要离屏渲染" class="headerlink" title="3.1 为什么及何时需要离屏渲染"></a>3.1 为什么及何时需要离屏渲染</h3><p>在上面的渲染流水线示意图中我们可以看到，主要的渲染操作都是由CoreAnimation的Render Server模块，通过调用显卡驱动所提供的OpenGL/Metal接口来执行的。通常对于每一层layer，Render Server会遵循“<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Painter%27s_algorithm">画家算法</a>”，按次序输出到frame buffer，后一层覆盖前一层，就能得到最终的显示结果（值得一提的是，与一般桌面架构不同，在iOS中，设备主存和GPU的显存<a href="https://link.zhihu.com/?target=https://apple.stackexchange.com/questions/54977/how-much-gpu-memory-do-iphones-and-ipads-have">共享物理内存</a>，这样可以省去一些数据传输开销）。</p><p>画家算法通过按深度对图像中的物体进行排序，并按从（距离观察者）最远到最近的顺序，依次将每一层绘制输出到画布，来创建图像。</p><img src="/images/iosrender/05.png" alt="01" style="zoom:90%;" /><p>然而有些场景并没有那么简单。作为“画家”的GPU虽然可以一层一层往画布上进行输出，但是无法在某一层渲染完成之后，再回过头来擦除/改变其中的某个部分——因为在这一层之前的若干层layer像素数据，已经在渲染中被永久覆盖了。这就意味着，<strong>对于每一层layer，要么能找到一种通过单次遍历就能完成渲染的算法，要么就不得不另开一块内存，借助这个临时中转区域来完成一些更复杂的、多次的修改/剪裁操作</strong>。</p><p>以绘制一个带有圆角并剪切圆角以外内容的容器，会触发离屏渲染为例。我的猜想是（如果读者中有图形学专家希望能指正）：</p><ul><li>将一个layer的内容裁剪成圆角，可能不存在一次遍历就能完成的方法</li><li>容器的子layer因为父容器有圆角，那么也会需要被裁剪，而这时它们还在渲染队列中排队，尚未被组合到一块画布上，自然也无法统一裁剪</li></ul><p>此时我们就不得不开辟一块独立于frame buffer的空白内存，先把容器以及其所有子layer依次画好，然后把四个角“剪”成圆形，再把结果画到frame buffer中。这就是GPU的离屏渲染。</p><p>个人总结：什么场景下需要离屏渲染</p><img src="/images/iosrender/06.png" alt="01" style="zoom:90%;" /><ul><li>当一个属性的设置需要对一个以上的图层修改时。<ul><li>如设置<code>cornerRadius</code>以及<code>masksToBounds</code>进行圆角+裁剪时，<code>masksToBounds</code>裁剪属性会应用到所有的图层上。如果此时View、layer中不止一个图层，那就会触发离屏渲染了。</li><li>如设置<code> group opacity</code></li></ul></li><li>当一个图层，按照画家算法本应该先绘制，但由于依赖后续图层的数据，只能延后绘制时<ul><li>阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。但矛盾在于<strong>此时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢？</strong></li></ul></li></ul><h3 id="3-2-GPU离屏渲染的性能影响"><a href="#3-2-GPU离屏渲染的性能影响" class="headerlink" title="3.2 GPU离屏渲染的性能影响"></a>3.2 GPU离屏渲染的性能影响</h3><p>离屏渲染增大了系统的负担，会形象App性能。主要表现在以下几个方面：</p><ul><li>离屏渲染需要额外的存储空间，渲染空间大小的上限是2.5倍的屏幕像素大小，超过无法使用离屏渲染。</li><li>容易掉帧：一旦因为离屏渲染导致最终存入帧缓存区的时候，已经超过了16.67ms，则会出现掉帧的情况，造成卡顿。</li></ul><p>GPU的操作是高度流水线化的。本来所有计算工作都在有条不紊地正在向frame buffer输出，此时突然收到指令，需要输出到另一块内存，那么流水线中正在进行的一切都不得不被丢弃，切换到只能服务于我们当前的“切圆角”操作。等到完成以后再次清空，再回到向frame buffer输出的正常流程。</p><p>在tableView或者collectionView中，滚动的每一帧变化都会触发每个cell的重新绘制，因此一旦存在离屏渲染，上面提到的<strong>上下文切换</strong>就会每秒发生60次，并且很可能每一帧有几十张的图片要求这么做，对于GPU的性能冲击可想而知（GPU非常擅长大规模并行计算，但是我想频繁的上下文切换显然不在其设计考量之中）</p><p>每16ms就需要根据当前滚动位置渲染整个tableView，是个不小的性能挑战：</p><img src="/images/iosrender/12.jpg" alt="01" style="zoom:70%;" /><h3 id="3-3-善用离屏渲染-shouldRasterize"><a href="#3-3-善用离屏渲染-shouldRasterize" class="headerlink" title="3.3 善用离屏渲染 shouldRasterize"></a>3.3 善用离屏渲染 shouldRasterize</h3><p>尽管离屏渲染开销很大，但是当我们无法避免它的时候，可以想办法把性能影响降到最低。优化思路也很简单：既然已经花了不少精力把图片裁出了圆角，如果我能把结果缓存下来，那么下一帧渲染就可以复用这个成果，不需要再重新画一遍了。</p><p>CALayer为这个方案提供了对应的解法：shouldRasterize。一旦被设置为true，Render Server就会强制把layer的渲染结果（包括其子layer，以及圆角、阴影、group opacity等等）保存在一块内存中，这样一来在下一帧仍然可以被复用，而不会再次触发离屏渲染。有几个需要注意的点：</p><ul><li>首先，layer不复用，没必要打开shouldRasterize。</li><li>shouldRasterize的主旨在于<strong>降低性能损失，但总是至少会触发一次离屏渲染</strong>。如果你的layer本来并不复杂，也没有圆角阴影等等，打开这个开关反而会增加一次不必要的离屏渲染</li><li>离屏渲染缓存有空间上限，最多不超过屏幕总像素的2.5倍大小</li><li>一旦缓存超过100ms没有被使用，会自动被丢弃</li><li>layer的内容（包括子layer）必须是静态的，因为一旦发生变化（如resize，动画），之前辛苦处理得到的缓存就失效了。如果这件事频繁发生，我们就又回到了“每一帧都需要离屏渲染”的情景，而这正是开发者需要极力避免的。针对这种情况，Xcode提供了“Color Hits Green and Misses Red”的选项，帮助我们查看缓存的使用是否符合预期</li><li>其实除了解决多次离屏渲染的开销，shouldRasterize在另一个场景中也可以使用：如果layer的子结构非常复杂，渲染一次所需时间较长，同样可以打开这个开关，把layer绘制到一块缓存，然后在接下来复用这个结果，这样就不需要每次都重新绘制整个layer树了</li></ul><h2 id="四、GPU离屏渲染常见场景分析及优化"><a href="#四、GPU离屏渲染常见场景分析及优化" class="headerlink" title="四、GPU离屏渲染常见场景分析及优化"></a>四、GPU离屏渲染常见场景分析及优化</h2><h3 id="4-1-关于cornerRadius"><a href="#4-1-关于cornerRadius" class="headerlink" title="4.1 关于cornerRadius"></a>4.1 关于cornerRadius</h3><p>我们经常看到，圆角会触发离屏渲染。但其实这个说法是<strong>不准确的</strong>，因为圆角触发离屏渲染也是<strong>有条件</strong>的。</p><h4 id="4-1-1-cornerRadius的官方释义"><a href="#4-1-1-cornerRadius的官方释义" class="headerlink" title="4.1.1 cornerRadius的官方释义"></a>4.1.1 cornerRadius的官方释义</h4><p>我们先来看看苹果官方文档对于<code>cornerRadius</code>的描述：</p><blockquote><p>Setting the radius to a value greater than <code>0.0</code> causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s <code>contents</code> property; it applies only to the background color and border of the layer. However, setting the <code>masksToBounds</code> property to <code>true</code> causes the content to be clipped to the rounded corners.</p></blockquote><p>设置<code>cornerRadius</code>大于0时，只会为layer的<code>backgroundColor</code>和<code>border</code>设置圆角。</p><p>只有同时设置了<code>layer.masksToBounds</code>为<code>true</code>（对应UIView的<code>clipsToBounds</code>属性）时，才会同时对layer的<code>contents</code>设置圆角。</p><ul><li><p>clipsToBounds：是类View的属性，如果设置为yes，则不显示超出父View的部分</p></li><li><p>masksToBounds：是类CALayer的属性，如果设置为yes，则不显示超出父View layer的部分</p></li></ul><p>如果这时，你认为<code>layer.masksToBounds</code>或者<code>clipsToBounds</code>设置为<code>true</code>就会触发离屏渲染，这是不完全正确的。</p><h4 id="4-1-2-测试用例及现象"><a href="#4-1-2-测试用例及现象" class="headerlink" title="4.1.2 测试用例及现象"></a>4.1.2 测试用例及现象</h4><blockquote><p>测试环境：Xcode 11.5  、iPhone 11 Pro Simulator  、iOS 13.5</p><p>测试手段：模拟器Simulator — Debug — Color Off-screen Rendered</p></blockquote><p>测试用例及结论：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200.0</span>, <span class="number">200.0</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 不设置layer.masksToBounds或者clipsToBounds，其默认值为NO  ———— 不会触发离屏渲染</span></span><br><span class="line">view1.backgroundColor = <span class="built_in">UIColor</span>.redColor;</span><br><span class="line">view1.layer.borderWidth = <span class="number">2.0</span>;</span><br><span class="line">view1.layer.borderColor = <span class="built_in">UIColor</span>.blackColor.CGColor;</span><br><span class="line">view1.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置layer.masksToBounds或者clipsToBounds为YES  ———— 同样的没有触发离屏渲染</span></span><br><span class="line">view1.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置layer.masksToBounds或者clipsToBounds为YES，同时设置图片 ———— 触发离屏渲染</span></span><br><span class="line">view1.layer.contents = (__bridge <span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pkq&quot;</span>].CGImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 除了如3设置图片。设置layer.masksToBounds或者clipsToBounds为YES，为视图添加一个有颜色、内容或边框等有图像信息（有图像信息还包括在视图或者layer的draw方法中进行绘制等）的子视图也会触发离屏渲染。  ————  触发离屏渲染</span></span><br><span class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100.0</span>, <span class="number">100.0</span>)];</span><br><span class="line"><span class="comment">// 下面3个任何一个属性</span></span><br><span class="line"><span class="comment">// 设置背景色</span></span><br><span class="line">view2.backgroundColor = <span class="built_in">UIColor</span>.blueColor;</span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">view2.layer.contents = (__bridge <span class="keyword">id</span>)([<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;pkq&quot;</span>].CGImage);</span><br><span class="line"><span class="comment">// 设置边框</span></span><br><span class="line">view2.layer.borderWidth = <span class="number">2.0</span>; </span><br><span class="line">view2.layer.borderColor = <span class="built_in">UIColor</span>.blackColor.CGColor;</span><br><span class="line">[view1 addSubview:view2];</span><br></pre></td></tr></table></figure><h4 id="4-1-3-圆角触发离屏渲染的原因"><a href="#4-1-3-圆角触发离屏渲染的原因" class="headerlink" title="4.1.3 圆角触发离屏渲染的原因"></a>4.1.3 圆角触发离屏渲染的原因</h4><p>当我们设置了<code>cornerRadius</code>以及<code>masksToBounds</code>进行圆角+裁剪时，<code>masksToBounds</code>裁剪属性会应用到所有的图层上。</p><p>本来我们从后往前绘制，绘制完一个图层就可以丢弃了。但现在需要依次在 <strong>Offscreen Buffer</strong>中保存，等待圆角+裁剪处理，即引发了 <strong>离屏渲染</strong> 。</p><ul><li><p>背景色、边框、背景色+边框，再加上圆角+裁剪，根据文档说明，因为 <strong>contents = nil</strong> 没有需要裁剪处理的内容，所以<code>masksToBounds</code>设置为<code>YES</code>或者<code>NO</code>都没有影响。</p></li><li><p>一旦我们 <strong>为contents设置了内容</strong> ，无论是图片、绘制内容、有图像信息的子视图等，再加上圆角+裁剪，就会触发离屏渲染。</p><blockquote><p>不一定是直接为contents赋值！</p></blockquote></li></ul><p>原因就如同上面提到的，不得已只能另开一块内存来操作。而如果只是设置cornerRadius（如不需要剪切内容，只需要一个带圆角的边框），或者只是需要裁掉矩形区域以外的内容（虽然也是剪切，但是稍微想一下就可以发现，对于纯矩形而言，实现这个算法似乎并不需要另开内存），并不会触发离屏渲染。</p><h4 id="4-1-4-iOS9及以后的优化"><a href="#4-1-4-iOS9及以后的优化" class="headerlink" title="4.1.4 iOS9及以后的优化"></a>4.1.4 iOS9及以后的优化</h4><p>关于圆角，iOS 9及之后的系统版本，苹果进行了一些优化。</p><ul><li><p><code>layer.contents</code>/<code>imageView.image</code></p><ul><li><p>我们只设置<code>contents</code>或者<code>UIImageView</code>的<code>image</code>，并加上圆角+裁剪，是不会产生离屏渲染的。但如果加上了背景色、边框或其他有图像内容的图层，还是会产生离屏渲染。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200.0</span>, <span class="number">200.0</span>)];</span><br><span class="line"><span class="comment">//设置图片</span></span><br><span class="line">view1.layer.contents = (__bridge <span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;qiyu&quot;</span>].CGImage;</span><br><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">view1.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">view1.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li><li><p>其实这也是可以理解的，因为只有 <strong>单层</strong> 内容需要添加圆角和裁切，所以可以不需要用到离屏渲染技术。</p></li><li><p>但如果加上了背景色、边框或其他有图像内容的图层，就会产生为 <strong>多层</strong> 添加圆角和裁切，所以还是会触发离屏渲染(如2中的第3个例子)。</p></li></ul></li><li><p>UIButton：使用类似于<code>UIButton</code>的视图的时候需要注意：为<code>UIButton</code>设置一个图片，其实会添加一个<code>UIImageView</code>。</p><ul><li><p>为设置了图片的<code>UIButton</code>添加圆角和裁剪，则会触发离屏渲染。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">button.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">button.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li><li><p>为设置了背景色的<code>UIButton</code>添加圆角和裁剪，不会触发离屏渲染。</p></li><li><p>如果改为<code>UIButton</code>中的<code>UIImageView</code>添加圆角和裁剪，则 <strong>不会触发离屏渲染</strong>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">button.imageView.layer.cornerRadius = <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">// 设置裁剪</span></span><br><span class="line">button.imageView.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-1-5-实现圆角造成的离屏渲染优化"><a href="#4-1-5-实现圆角造成的离屏渲染优化" class="headerlink" title="4.1.5 实现圆角造成的离屏渲染优化"></a>4.1.5 实现圆角造成的离屏渲染优化</h4><p>方案一：使用切图</p><p>方案二：贝塞尔曲线绘制圆角</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageWithCornerRadius:(<span class="built_in">CGFloat</span>)radius ofSize:(<span class="built_in">CGSize</span>)size&#123;</span><br><span class="line">    <span class="comment">/* 当前UIImage的可见绘制区域 */</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="number">0.</span>f,<span class="number">0.</span>f,size&#125;;</span><br><span class="line">    <span class="comment">/* 创建基于位图的上下文 */</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="built_in">UIScreen</span>.mainScreen.scale);</span><br><span class="line">    <span class="comment">/* 在当前位图上下文添加圆角绘制路径 */</span></span><br><span class="line">    <span class="built_in">CGContextAddPath</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>(), [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);</span><br><span class="line">    <span class="comment">/* 当前绘制路径和原绘制路径相交得到最终裁剪绘制路径 */</span></span><br><span class="line">    <span class="built_in">CGContextClip</span>(<span class="built_in">UIGraphicsGetCurrentContext</span>());</span><br><span class="line">    <span class="comment">/* 绘制 */</span></span><br><span class="line">    [<span class="keyword">self</span> drawInRect:rect];</span><br><span class="line">    <span class="comment">/* 取得裁剪后的image */</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="comment">/* 关闭当前位图上下文 */</span></span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案三：CAShapeLayer + UIBezierPath 绘制圆角来实现UITableViewCell圆角并绘制边框颜色（这种方式比直接设置圆角方式好，但也会触发离屏渲染）,代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *maskLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    maskLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CAShapeLayer</span> *borderLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">    borderLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height);</span><br><span class="line">    borderLayer.lineWidth = <span class="number">1.</span>f;</span><br><span class="line">    borderLayer.strokeColor = COLOR_LINE.CGColor;</span><br><span class="line">    borderLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cell.width, cell.height) cornerRadius:kRadiusCard];</span><br><span class="line">    maskLayer.path = bezierPath.CGPath;</span><br><span class="line">    borderLayer.path = bezierPath.CGPath;</span><br><span class="line"></span><br><span class="line">    [cell.contentView.layer insertSublayer:borderLayer atIndex:<span class="number">0</span>];</span><br><span class="line">    [cell.layer setMask:maskLayer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于方案三的解释：</p><ul><li>CAShapeLayer继承于CALayer，因而可以使用CALayer的所有属性值；</li><li>CAShapeLayer需要和贝塞尔曲线配合使用才能够实现效果；</li><li>CAShapeLayer(属于CoreAnimation)与贝塞尔曲线配合使用可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出想要的图形；</li><li>CAShapeLayer动画渲染是驱动GPU，而view的drawRect方法使用CPU渲染，相比其效率更高，消耗内存更少。</li></ul><p>总的来说使用CAShapeLayer的内存消耗少，渲染速度快。</p></blockquote><p>关于剪切圆角的性能优化，根据场景不同有几个方案可供选择，非常推荐阅读<a href="https://link.zhihu.com/?target=https://texturegroup.org/docs/corner-rounding.html">AsyncDisplayKit中的一篇文档</a>。</p><p>ASDK中对于如何选择圆角渲染策略的流程图，非常实用：</p><img src="/images/iosrender/07.jpg" alt="01" style="zoom:70%;" /><p>YYKit是开发中经常用的三方库，YYImage对图片圆角的处理方法是值得推荐的，附上实现源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageByRoundCornerRadius:(<span class="built_in">CGFloat</span>)radius</span><br><span class="line">                              corners:(<span class="built_in">UIRectCorner</span>)corners</span><br><span class="line">                          borderWidth:(<span class="built_in">CGFloat</span>)borderWidth</span><br><span class="line">                          borderColor:(<span class="built_in">UIColor</span> *)borderColor</span><br><span class="line">                       borderLineJoin:(<span class="built_in">CGLineJoin</span>)borderLineJoin &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (corners != <span class="built_in">UIRectCornerAllCorners</span>) &#123;</span><br><span class="line">        <span class="built_in">UIRectCorner</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerTopLeft</span>) tmp |= <span class="built_in">UIRectCornerBottomLeft</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerTopRight</span>) tmp |= <span class="built_in">UIRectCornerBottomRight</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerBottomLeft</span>) tmp |= <span class="built_in">UIRectCornerTopLeft</span>;</span><br><span class="line">        <span class="keyword">if</span> (corners &amp; <span class="built_in">UIRectCornerBottomRight</span>) tmp |= <span class="built_in">UIRectCornerTopRight</span>;</span><br><span class="line">        corners = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, <span class="keyword">self</span>.scale);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, -rect.size.height);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> minSize = MIN(<span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height);</span><br><span class="line">    <span class="keyword">if</span> (borderWidth &lt; minSize / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="built_in">CGRectInset</span>(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(radius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">        [path addClip];</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, rect, <span class="keyword">self</span>.CGImage);</span><br><span class="line">        <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (borderColor &amp;&amp; borderWidth &lt; minSize / <span class="number">2</span> &amp;&amp; borderWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> strokeInset = (floor(borderWidth * <span class="keyword">self</span>.scale) + <span class="number">0.5</span>) / <span class="keyword">self</span>.scale;</span><br><span class="line">        <span class="built_in">CGRect</span> strokeRect = <span class="built_in">CGRectInset</span>(rect, strokeInset, strokeInset);</span><br><span class="line">        <span class="built_in">CGFloat</span> strokeRadius = radius &gt; <span class="keyword">self</span>.scale / <span class="number">2</span> ? radius - <span class="keyword">self</span>.scale / <span class="number">2</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:<span class="built_in">CGSizeMake</span>(strokeRadius, borderWidth)];</span><br><span class="line">        [path closePath];</span><br><span class="line">        </span><br><span class="line">        path.lineWidth = borderWidth;</span><br><span class="line">        path.lineJoinStyle = borderLineJoin;</span><br><span class="line">        [borderColor setStroke];</span><br><span class="line">        [path stroke];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-shadow"><a href="#4-2-shadow" class="headerlink" title="4.2 shadow"></a>4.2 shadow</h3><p>一般情况下是用以下代码，但是不要用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *imageViewLayer = cell.imageView.layer;</span><br><span class="line">imageViewLayer.shadowColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</span><br><span class="line">imageViewLayer.shadowOpacity = <span class="number">1.0</span>;</span><br><span class="line">imageViewLayer.shadowRadius = <span class="number">2.0</span>;</span><br><span class="line">imageViewLayer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>请用更高效的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageViewLayer.shadowPath = <span class="built_in">CGPathCreateWithRect</span>(imageRect, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>其原因在于，虽然layer本身是一块矩形区域，但是阴影默认是作用在其中”非透明区域“的，而且需要显示在所有layer内容的下方，因此根据画家算法必须被渲染在先。</p><p>Core Animation 必须要知道阴影的形状和位置。但矛盾在于<strong>时阴影的本体（layer和其子layer）都还没有被组合到一起，怎么可能在第一步就画出只有完成最后一步之后才能知道的形状呢</strong>？这样一来又只能另外申请一块内存，把本体内容都先画好，再查看其 alpha channel 来找出阴影的位置，渲染阴影到frame buffer，最后把内容画上去（实际情况有些复杂）。</p><p>不过如果我们能够预先告诉CoreAnimation（通过shadowPath属性）阴影的几何形状，那么阴影当然可以先被独立渲染出来，不需要依赖layer本体，也就不再需要离屏渲染了。</p><p>阴影会作用在所有子layer所组成的形状上，那就只能等全部子layer画完才能得到：</p><img src="/images/iosrender/08.jpg" alt="01" style="zoom:70%;" /><h3 id="4-3-group-opacity"><a href="#4-3-group-opacity" class="headerlink" title="4.3 group opacity"></a>4.3 group opacity</h3><p>设置了组透明度为 YES，并且透明度不为 1 的layer (layer.allowsGroupOpacity/ layer.opacity)。</p><p>其实从名字就可以猜到，alpha并不是分别应用在每一层之上，而是只有到整个layer树画完之后，再统一加上alpha，最后和底下其他layer的像素进行组合。显然也无法通过一次遍历就得到最终结果。将一对蓝色和红色layer叠在一起，然后在父layer上设置opacity=0.5，并复制一份在旁边作对比。左边关闭group opacity，右边保持默认（从iOS7开始，如果没有显式指定，group opacity会默认打开），然后打开offscreen rendering的调试，我们会发现右边的那一组确实是离屏渲染了。</p><p>同样的两个view，右边打开group opacity（默认行为）的被标记为Offscreen rendering：</p><img src="/images/iosrender/09.jpg" alt="01" style="zoom:50%;" /><h3 id="4-4-mask"><a href="#4-4-mask" class="headerlink" title="4.4 mask"></a>4.4 mask</h3><p>我们知道mask是应用在layer和其所有子layer的组合之上的，而且可能带有透明度，那么其实和group opacity的原理类似，不得不在离屏渲染中完成。</p><p>WWDC中苹果的解释，mask需要遍历至少三次：</p><img src="/images/iosrender/10.jpg" alt="01" style="zoom:90%;" /><h3 id="4-5-UIBlurEffect"><a href="#4-5-UIBlurEffect" class="headerlink" title="4.5 UIBlurEffect"></a>4.5 UIBlurEffect</h3><p>同样无法通过一次遍历完成，其原理在WWDC中提到：</p><img src="/images/iosrender/11.jpg" alt="01" style="zoom:90%;" /><h3 id="4-6-shouldRasterize"><a href="#4-6-shouldRasterize" class="headerlink" title="4.6 shouldRasterize"></a>4.6 shouldRasterize</h3><p>shouldRasterize的主旨在于<strong>降低性能损失，但总是至少会触发一次离屏渲染</strong>。</p><p>shouldRasterize光栅化开启后，会将layer作为位图保存到OffscreenBuffer中。下次直接与其他内容进行混合。这样下次需要再次渲染的时候，就可以直接拿来使用了。</p><h3 id="4-7-其他"><a href="#4-7-其他" class="headerlink" title="4.7 其他"></a>4.7 其他</h3><p>其他还有一些，类似绘制了文字的 layer (UILabel, CATextLayer, Core Text 等)、allowsEdgeAntialiasing等等也可能会触发离屏渲染，原理也都是类似：如果你无法仅仅使用frame buffer来画出最终结果，那就只能另开一块内存空间来储存中间结果。这些原理并不神秘。</p><h2 id="五、CPU”离屏渲染“？"><a href="#五、CPU”离屏渲染“？" class="headerlink" title="五、CPU”离屏渲染“？"></a>五、CPU”离屏渲染“？</h2><h3 id="5-1-CPU渲染"><a href="#5-1-CPU渲染" class="headerlink" title="5.1 CPU渲染"></a>5.1 CPU渲染</h3><p>特殊的离屏渲染：</p><p>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么是不是还有另一种特殊的“离屏渲染”方式： CPU渲染？</p><p>大家知道，如果我们在UIView中重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地完成，渲染得到的bitmap最后再交由GPU用于显示。（就算函数体内部实际没有代码，系统也会为这个view申请一块内存区域，等待CoreGraphics可能的绘画操作）。</p><blockquote><p>备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程</p></blockquote><p>对于类似上面这种“新开一块CGContext来画图“的操作，有很多文章和视频也称之为“离屏渲染”（因为像素数据是暂时存入了CGContext，而不是直接到了frame buffer）。进一步来说，其实所有CPU进行的光栅化操作（如文字渲染、图片解码），都无法直接绘制到由GPU掌管的frame buffer，只能暂时先放在另一块内存之中，说起来都属于“离屏渲染”。</p><p>自然我们会认为，因为CPU不擅长做这件事，所以我们需要尽量避免它，就误以为这就是需要避免离屏渲染的原因。但是<a href="https://link.zhihu.com/?target=https://lobste.rs/s/ckm4uw/performance_minded_take_on_ios_design%23c_itdkfh">根据苹果工程师的说法</a>，CPU渲染并非真正意义上的离屏渲染。另一个证据是，如果你的view实现了drawRect，此时打开Xcode调试的“Color offscreen rendered yellow”开关，你会发现这片区域不会被标记为黄色，说明Xcode并不认为这属于离屏渲染。</p><p>其实通过CPU渲染就是俗称的“软件渲染”，而<strong>真正的离屏渲染发生在GPU</strong>。</p><h3 id="5-2-什么时候需要CPU渲染"><a href="#5-2-什么时候需要CPU渲染" class="headerlink" title="5.2 什么时候需要CPU渲染"></a>5.2 什么时候需要CPU渲染</h3><p>渲染性能的调优，其实始终是在做一件事：<strong>平衡CPU和GPU的负载，让他们尽量做各自最擅长的工作</strong>。</p><p>平衡CPU和GPU的负载：</p><img src="/images/iosrender/13.jpg" alt="01" style="zoom:80%;" /><p>绝大多数情况下，得益于GPU针对图形处理的优化，我们都会倾向于让GPU来完成渲染任务，而给CPU留出足够时间处理各种各样复杂的App逻辑。为此Core Animation做了大量的工作，尽量把渲染工作转换成适合GPU处理的形式（也就是所谓的硬件加速，如layer composition，设置backgroundColor等等）。</p><p>但是对于一些情况，如文字（CoreText使用CoreGraphics渲染）和图片（ImageIO）渲染，由于GPU并不擅长做这些工作，不得不先由CPU来处理好以后，再把结果作为texture传给GPU。除此以外，有时候也会遇到GPU实在忙不过来的情况，而CPU相对空闲（GPU瓶颈），这时可以让CPU分担一部分工作，提高整体效率。</p><p>来自WWDC18 session 221，可以看到Core Text基于Core Graphics：</p><img src="/images/iosrender/14.jpg" alt="01" style="zoom:80%;" /><p>一个典型的例子是，我们经常会使用CoreGraphics给图片加上圆角（将图片中圆角以外的部分渲染成透明）。整个过程全部是由CPU完成的。这样一来既然我们已经得到了想要的效果，就不需要再另外给图片容器设置cornerRadius。另一个好处是，我们可以灵活地控制裁剪和缓存的时机，巧妙避开CPU和GPU最繁忙的时段，达到平滑性能波动的目的。</p><p>这里有几个需要注意的点：</p><ul><li>渲染不是CPU的强项，调用CoreGraphics会消耗其相当一部分计算时间，并且我们也不愿意因此阻塞用户操作，因此一般来说CPU渲染都在后台线程完成（这也是AsyncDisplayKit的主要思想），然后再回到主线程上，把渲染结果传回CoreAnimation。这样一来，多线程间数据同步会增加一定的复杂度</li><li>同样因为CPU渲染速度不够快，因此只适合渲染静态的元素，如文字、图片（想象一下没有硬件加速的视频解码，性能惨不忍睹）</li><li>作为渲染结果的bitmap数据量较大（形式上一般为解码后的UIImage），消耗内存较多，所以应该在使用完及时释放，并在需要的时候重新生成，否则很容易导致OOM</li><li>如果你选择使用CPU来做渲染，那么就没有理由再触发GPU的离屏渲染了，否则会同时存在两块内容相同的内存，而且CPU和GPU都会比较辛苦</li><li>一定要使用Instruments的不同工具来测试性能，而不是仅凭猜测来做决定</li></ul><h2 id="六、优化实践"><a href="#六、优化实践" class="headerlink" title="六、优化实践"></a>六、优化实践</h2><p>由于在iOS10之后，系统的设计风格慢慢从扁平化转变成圆角卡片，很多APP的设计风格也随之发生变化，加入了大量圆角与阴影效果，如果在处理上稍有不慎，就很容易触发离屏渲染。为此我们采取了以下一些措施：</p><ul><li>大量应用AsyncDisplayKit(Texture)作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看<a href="https://link.zhihu.com/?target=https://medium.com/jike-engineering/asyncdisplaykit%E4%BB%8B%E7%BB%8D-%E4%B8%80-6b871d29e005">之前的一些介绍</a></li><li>对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角</li><li>对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果</li><li>对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做</li><li>对于所有的阴影，使用shadowPath来规避离屏渲染</li><li>对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存</li><li>对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果</li></ul><h2 id="七、总结与资料推荐"><a href="#七、总结与资料推荐" class="headerlink" title="七、总结与资料推荐"></a>七、总结与资料推荐</h2><p>离屏渲染牵涉了很多Core Animation、GPU和图形学等等方面的知识，在实践中也非常考验一个工程师排查问题的基本功、经验和判断能力——如果在不恰当的时候打开了shouldRasterize，只会弄巧成拙。</p><p>从一个更广阔的视角看，离屏渲染也仅仅是渲染性能优化中的一部分，而能否保证UI性能过关，将会直接影响到用户日常的操作体验。渲染技术作为客户端工程师的关键技术能力之一，值得持续研究。</p><p>推荐资料：</p><ul><li><a href="https://link.zhihu.com/?target=https://lobste.rs/s/ckm4uw/performance_minded_take_on_ios_design%23c_itdkfh">Andy Matuschak关于离屏渲染的解释</a></li><li><a href="https://link.zhihu.com/?target=https://www.objc.io/issues/3-views/moving-pixels-onto-the-screen">Objc.io: Moving Pixels onto the Screen</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/seedante/iOS-Note/wiki/Mastering-Offscreen-Render">Mastering Offscreen Render</a></li><li>WWDC 2011 421 Core Animation Essentials</li><li>WWDC 2011 121 Understanding UIKit Rendering</li><li>WWDC 2014 419 Advanced Graphics and Animations for iOS Apps</li><li>WWDC 2010 135 Advanced Performance Optimization on iPhone OS Part 1</li><li><a href="https://link.zhihu.com/?target=https://www.amazon.com/iOS-Core-Animation-Advanced-Techniques-ebook/dp/B00EHJCORC">《Core Animation: Advanced Techniques》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/72653360&quot;&gt;关于iOS离屏渲染的深入研究&lt;/a&gt;、&lt;a href=&quot;https://juejin.cn/post/6846687603316490254&quot;</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core-Animation(三) - 渲染流程探究及性能分析</title>
    <link href="https://tenloy.github.io/2021/09/11/core-animation03.html"/>
    <id>https://tenloy.github.io/2021/09/11/core-animation03.html</id>
    <published>2021-09-11T20:04:46.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://joakimliu.github.io/2019/03/02/wwdc-2014-419/">原文</a>，摘自 <a href="https://developer.apple.com/videos/play/wwdc2014/419/">Advanced Graphics and Animations for iOS Apps</a> （WWDC14 419，关于UIKit和Core Animation基础的session在早年的WWDC中比较多），字幕在 <a href="https://asciiwwdc.com/2014/sessions/419">transcripts</a> ，当然也可以下载 <a href="https://wwdc.io/">WWDC</a> 在桌面上看带有字幕的视频。这篇挺实用的，讲解了渲染的基本流程，以及怎么发现并解决渲染性能的问题。</p></blockquote><h2 id="一、iOS渲染架构总览"><a href="#一、iOS渲染架构总览" class="headerlink" title="一、iOS渲染架构总览"></a>一、iOS渲染架构总览</h2><h3 id="1-1-简易架构图"><a href="#1-1-简易架构图" class="headerlink" title="1.1 简易架构图"></a>1.1 简易架构图</h3><p>iOS APP 图形图像渲染的基本流程：</p><img src="/images/iosrender/15.png" alt="01" style="zoom:35%;" /><ol><li><p>CPU(Central Processing Unit，中央处理器)：完成对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）。</p></li><li><p>GPU(Graphics Processing Unit，图形处理器)：GPU拿到CPU计算好的显示内容，完成纹理的渲染， 渲染完成后将渲染结果放入帧缓冲区。</p></li><li><p>帧缓冲区（Frame Buffer）（双缓冲机制，不再赘述）</p><p>正常情况下，在当前屏幕显示的内容，由 GPU 渲染完成后放到当前屏幕的帧缓存区，不需要额外的渲染空间。我们知道 iPhone 的屏幕刷新率是 60Hz，也就是刷新一帧的时间是 16.67 ms， 每隔这段时间视频控制器就会去读一次缓存区的内容来显示。 </p><p>假如 GPU 遇到性能瓶颈，导致无法在一帧内更新渲染结果到帧缓存区，那么从缓存区读到的会是上一帧的内容，导致帧率降低界面卡顿。</p></li><li><p>视频控制器读取 Frame Buffer 中的数据 （视频控制器一般由显卡驱动程序或DirectX(微软公司创建的一系列专为多媒体以及游戏开发的应用程序接口)中自带，是芯片与显示平台的数据接口）</p><p>视频控制器会按照 VSync信号(开始新的帧缓冲的读取)、HSync信号(开始帧缓冲新的一行的读取)读取前帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p>GPU开始会绘制后缓存里的画面，然后视频控制器读取完前缓存的画面， 就会去读取后缓存里的画面。</p><p>然后GPU再去绘制前缓存里的画面，即两者交替进行。</p></li></ol><p>将上图更细化一点：</p><img src="/images/iosrender/01.png" alt="01" style="zoom:90%;" /><img src="/images/iosrender/16.png" alt="01" style="zoom:60%;" /><p><a href="https://github.com/Tenloy/iOS-Core-Animation-Advanced-Techniques/blob/master/12-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">(原文)</a>关于绘图和动画有两种处理的方式：CPU（中央处理器）和GPU（图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。</p><p>总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因，我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）</p><p>大多数动画性能优化都是关于智能利用GPU和CPU，使得它们都不会超出负荷。于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。</p><h3 id="1-2-CoreAnimation渲染架构图"><a href="#1-2-CoreAnimation渲染架构图" class="headerlink" title="1.2 CoreAnimation渲染架构图"></a>1.2 CoreAnimation渲染架构图</h3><p>我们知道 Core Animation 是 iOS 上可用的图形渲染和动画基础结构，它将大部分实际绘图工作交给图形硬件以加速渲染(摘自官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a>)。 我们先来看看 Core Animation 渲染的管道图：</p><img src="/images/iosrender/02.jpg" alt="01" style="zoom:90%;" /><p>我们看到：</p><ul><li>在应用程序(Application)和渲染服务器(Render Server)中都有 Core Animation 。我们也可以把iOS下的Core Animation可以理解为一个<strong>复合引擎，主要职责包含：渲染、构建和实现动画</strong>。</li><li>可以看到，渲染工作并不是在应用程序里(尽管它有 Core Animation)完成的，这一层主要是CPU在操作。它只是将视图层级(view hierarchy)打包(encode)提交给**渲染服务器(一个单独的进程，也有 Core Animation)**， 视图层级才会被渲染。(“The view hierarchy is then rendered with Core Animation with OpenGL or metal, that’s the GPU.”) </li><li>CPU和GPU双方同处于一个流水线中，协作完成整个渲染工作。</li></ul><p>大致流程如下：</p><ul><li>Handle Events：它代表 touch, 即一切要更新视图层级的事情；</li><li>Commit Transaction：编码打包视图层级，发送给渲染服务器；</li><li>Decode：渲染服务器第一件事就是解码这些视图层级；</li><li>Draw Calls：渲染服务器必须等待下一次重新同步，以便等待缓冲区从 它们实现渲染的显示器 返回，然后最终开始为 GPU 绘制，这里就是 OpenGL or metal 。（<strong>以前是call OpenGL ES，现在慢慢转到了Metal</strong>）。</li><li>Render：一旦视图资源可用， GPU 就开始它的渲染工作，希望在下个重新同步完成，因为要交换缓冲区给用户。</li><li>Display：显示给用户看。</li></ul><p>在上述情况下，这些不同的步骤总共跨越三帧。在最后一个步骤 display 后，是可以平行操作的，在 Draw call 的时候可以处理下一个 handler event 和 Commit Transaction 。如下图所示</p><img src="/images/caa/pipeline2.png" alt="Animation Pipeline2" style="zoom:80%;" /><h2 id="二、渲染步骤详解"><a href="#二、渲染步骤详解" class="headerlink" title="二、渲染步骤详解"></a>二、渲染步骤详解</h2><h3 id="2-1-APP-—-Commit-Transaction"><a href="#2-1-APP-—-Commit-Transaction" class="headerlink" title="2.1 APP — Commit Transaction"></a>2.1 APP — Commit Transaction</h3><h4 id="2-1-1-事务提交的4个阶段"><a href="#2-1-1-事务提交的4个阶段" class="headerlink" title="2.1.1 事务提交的4个阶段"></a>2.1.1 事务提交的4个阶段</h4><p>先聚焦 Commit transaction（事务是什么就不再赘述了）这个阶段，因为这是开发者接触最多的，主要有四个阶段，如下图所示：</p><img src="/images/caa/commit-transaction.png" alt="Commit Transaction" style="zoom:95%;" /><h5 id="1-布局-Layout"><a href="#1-布局-Layout" class="headerlink" title="1. 布局(Layout)"></a>1. 布局(Layout)</h5><p>Set up the views. 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段</p><ul><li>重载的 <code>layoutSubviews</code> 方法会在这个阶段被调用；</li><li>视图的创建，被添加到视图层级上；</li><li>计算内容，比如：字符串，用来布局 label ；</li><li>这个阶段通常是 CPU 或者 I/O 限制，所以做的事情要轻量</li></ul><h5 id="2-显示-Display"><a href="#2-显示-Display" class="headerlink" title="2. 显示(Display)"></a>2. 显示(Display)</h5><p>Draw the views. 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<code>-drawRect:</code>和<code>-drawLayer:inContext:</code>方法的调用路径。</p><ul><li>主要是 core graphics 用来绘制，调用重载的 <code>drawRect:</code> 方法来绘制，绘制字符串；这个阶段通常是 CPU 或者内存限制，所以减少 core graphics 的工作</li></ul><h5 id="3-准备-Prepare"><a href="#3-准备-Prepare" class="headerlink" title="3. 准备(Prepare)"></a>3. 准备(Prepare)</h5><p>Additional Core Animation work. 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</p><ul><li>主要是图片解码和图片转换。所以，图片大小和格式都是被 GPU 支持的，不然转换是发生在 CPU 上的，最好是 index bitmap ，可以免去转换</li></ul><h5 id="4-提交-Commit"><a href="#4-提交-Commit" class="headerlink" title="4. 提交(Commit)"></a>4. 提交(Commit)</h5><p>Package up the layers and send them to the render server.  这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</p><ul><li>视图层级不要太复杂，尽量扁平，因为这里的打包是循环处理的</li></ul><p>以上这些仅仅阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。</p><h4 id="2-1-2-Animation的渲染"><a href="#2-1-2-Animation的渲染" class="headerlink" title="2.1.2  Animation的渲染"></a>2.1.2  Animation的渲染</h4><p>动画分为三个阶段，前面两个阶段在应用程序，最后一个在渲染服务器，如下图所示</p><p><img src="/images/caa/animation-process.png" alt="Animation Process"></p><p>跟<strong>视图的不同的</strong>是，这里提交的不是视图层级，而是动画。这是出于效率的原因，方便我们可以继续更新动画，因为如果提交视图层级的话，动画一更新，又得返回到应用程序提交新的视图层级，很耗时。</p><h3 id="2-2-Render-Server"><a href="#2-2-Render-Server" class="headerlink" title="2.2 Render Server"></a>2.2 Render Server</h3><h4 id="2-2-1-渲染服务"><a href="#2-2-1-渲染服务" class="headerlink" title="2.2.1 渲染服务"></a>2.2.1 渲染服务</h4><p>Core Animation处在iOS的核心地位：应用内和应用间都会用到它。一个简单的动画可能同步显示多个app的内容，例如当在iPad上多个程序之间使用手势切换，会使得多个程序同时显示在屏幕上。在一个特定的应用中用代码实现它是没有意义的，因为在iOS中不可能实现这种效果（App都是被沙箱管理，不能访问别的视图）。</p><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的*渲染服务(Render Server)*。在iOS5和之前的版本是 SpringBoard 进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做<code>BackBoard</code>。</p><p>一旦 commit Transition 打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<em>渲染树</em>的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p><ul><li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li><li>在屏幕上渲染可见的三角形</li></ul><p>加上前面事务提交时的<strong>布局</strong>、<strong>显示</strong>、<strong>准备</strong>、<strong>提交</strong>，一共有六个阶段（在动画过程中，最后两个阶段不停地重复）。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。</p><p>这并不是个问题，因为在布局和显示阶段，你可以决定哪些由CPU执行，哪些交给GPU去做。那么该如何判断呢？</p><h4 id="2-2-2-GPU相关的操作"><a href="#2-2-2-GPU相关的操作" class="headerlink" title="2.2.2 GPU相关的操作"></a>2.2.2 GPU相关的操作</h4><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非你想绕开Core Animation并编写你自己的OpenGL着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。</p><p>宽泛的说，大多数<code>CALayer</code>的属性都是用GPU来绘制。比如如果你设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个<code>contents</code>属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。</p><p>但是有一些事情会降低（基于GPU）图层绘制效率，比如：</p><ul><li><strong>太多的几何结构</strong>：这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。<ul><li>现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。</li><li>但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见后续“CPU相关操作”）。</li></ul></li><li><strong>重绘</strong>：主要由重叠的半透明图层引起。<ul><li>GPU的<em>填充比率</em>（用颜色填充像素的比率）是有限的，所以需要避免<em>重绘</em>（每一帧用相同的像素填充多次）的发生。</li><li>在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并仍然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。</li></ul></li><li><strong>离屏绘制</strong>：这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。<ul><li>离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。</li><li>对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。</li></ul></li><li><strong>过大的图片</strong>：如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</li></ul><h4 id="2-2-3-CPU相关的操作"><a href="#2-2-3-CPU相关的操作" class="headerlink" title="2.2.3 CPU相关的操作"></a>2.2.3 CPU相关的操作</h4><p>大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p><p>以下CPU的操作都会延迟动画的开始时间：</p><ul><li><strong>布局计算</strong>：如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。</li><li><strong>视图惰性加载</strong>：iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。</li><li><strong>Core Graphics绘制</strong>：如果对视图实现了<code>-drawRect:</code>方法，或者<code>CALayerDelegate</code>的<code>-drawLayer:inContext:</code>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</li><li><strong>解压图片</strong>PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（<strong>通常等同于图片宽 x 长 x 4个字节</strong>）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用<code>UIImageView</code>）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</li></ul><p>当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树中的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU每一帧的渲染，即使这些事情不是你的应用程序可控的。</p><h4 id="2-2-4-IO相关操作"><a href="#2-2-4-IO相关操作" class="headerlink" title="2.2.4 IO相关操作"></a>2.2.4 IO相关操作</h4><p>还有一项没涉及的就是IO相关工作。上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从闪存（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。</p><p>IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和投机加载（提前加载当前不需要的资源，但是之后可能需要用到）。</p><h3 id="2-3-OpenGL-ES"><a href="#2-3-OpenGL-ES" class="headerlink" title="2.3 OpenGL ES"></a>2.3 OpenGL ES</h3><h4 id="2-3-1-OpenGL是什么？"><a href="#2-3-1-OpenGL是什么？" class="headerlink" title="2.3.1 OpenGL是什么？"></a>2.3.1 OpenGL是什么？</h4><p>从上面的渲染架构图可以看到，OpenGL位于硬件驱动层和软件层之间，</p><p>OpenGL（Open Graphics Library，译名：开放图形库或者“开放式图形库”）是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API）。这个接口由近350个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。而另一种程序接口系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟现实、科学可视化程序和电子游戏开发。</p><p>OpenGL 是一套图形图像开发规范，OpenGL架构评审委员会（ARB）维护。其实现一般由显示设备(GPU/显卡)厂商提供，而且非常依赖于该厂商提供的硬件。OpenGL的高效实现（利用图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。</p><ul><li>OpenGL规范描述了绘制2D和3D图形的抽象API。尽管这些API可以完全通过软件实现，但它是为大部分或者全部使用硬件加速而设计的。</li><li>OpenGL不仅语言无关，而且平台无关。</li><li>OpenGL是一个不断进化的API。每个版本的细节由开发组织(Khronos Group)的成员一致决定，包括显卡厂商、操作系统设计人员以及类似Mozilla和谷歌的一般性科技公司。</li><li>除了核心API要求的功能之外，GPU供应商可以通过扩展的形式提供额外功能。扩展可能会引入新功能和新常量，并且可能放松或取消现有的OpenGL函数的限制。然后一个扩展就分成两部分发布：包含扩展函数原型的头文件和作为厂商的设备驱动。</li></ul><p>OpenGL ES（OpenGL for Embedded Systems）是三维图形应用程序接口OpenGL的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。</p><h4 id="2-3-2-OpenGL用来干嘛？"><a href="#2-3-2-OpenGL用来干嘛？" class="headerlink" title="2.3.2 OpenGL用来干嘛？"></a>2.3.2 OpenGL用来干嘛？</h4><p>从操作粒度来理解它，它是基于GPU硬件驱动层的API，它直接操作的对象是显示屏幕上的每个像素点(Pixel)。我们可以利用这套API来操作屏幕上的每一个像素点的排列组合，颜色，深度等等来实现各种各样的图形图像。</p><p>总而言之，它是用来操作GPU显示图形图像的API。</p><h4 id="2-3-3-OpenGL-—-状态机"><a href="#2-3-3-OpenGL-—-状态机" class="headerlink" title="2.3.3 OpenGL — 状态机"></a>2.3.3 OpenGL — 状态机</h4><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文(Contex)来渲染。</p><p>OpenGL会保持状态，除非我们调用OpenGL函数来改变它。就像一个时间点的快照一样，除非对这个OpenGL的上下文进行修改，否则它呈现的内容是不会改变的。</p><p>每个OpenGL的上下文都是独立，我们在不同上下文做的工作是互不影响的，在实际操作过程中要注意是否在同一个上下文中。</p><h3 id="2-4-GPU-—-基于图块的渲染"><a href="#2-4-GPU-—-基于图块的渲染" class="headerlink" title="2.4 GPU — 基于图块的渲染"></a>2.4 GPU — 基于图块的渲染</h3><p>先来了解渲染的一些概念(Rendering Concepts)。</p><blockquote><p>tile 图块，瓦片； tiling 铺瓦于，铺以瓷砖</p></blockquote><p>“first tile based rendering is how all GPUs work.”  基于图块的渲染(Tile Based Rendering)是所有 GPU 的工作方式。</p><img src="/images/caa/tile-based-rendering.png" alt="Tile Based Rendering" style="zoom:80%;" /><ul><li>屏幕被分割成 N*N 个像素块，就像之前讲 <a href="http://joakimliu.github.io/2019/02/24/wwdc-2011-129/">Points vs Pixels</a> 中的例子一样；</li><li>每块都适应 Soc 缓存。(Soc: 苹果 A9 是一款由苹果公司设计的系统芯片(Soc)。可以理解为系统芯片。 维基百科上面写的，这个芯片是 2015.9.9 才首次发布)。</li><li>几何体被分割成图块桶(tile buckets)，这一步发生在 tiler stage (后面有提到)。这里举了 iPhone icon 的例子，从上图中可以看到，这个 icon 被分割成多个很小的三角形，使得这些三角形块可以单独的渲染，分割这样做的思路可以决定哪一块显示，哪一块渲染。 因为每个像素只有一个像素着色器，所以混合的话还是有问题的，涉及到覆盖绘制。</li><li>几何体提交后，光栅化才开始。(所以光栅化能提升性能，因为几何体都提交了，下次渲染的时候就可以省略这一步。)</li></ul><h4 id="2-4-1-Rendering-pass"><a href="#2-4-1-Rendering-pass" class="headerlink" title="2.4.1 Rendering pass"></a>2.4.1 Rendering pass</h4><blockquote><p>Pass:  v. 通过; 传递; 变化; 放弃    n. 经过; 通行证; <strong>通道</strong>; <strong>流程</strong>; <strong>阶段</strong>。此处应是译作阶段</p></blockquote><img src="/images/caa/rendering-pass.png" alt="Rendering pass" style="zoom:90%;" /><p>如上图所示，我们假设视图层级已经被提交到渲染服务器，并且 Core Animation 已经解码它，现在需要用 OpenGL 或者 metal 去渲染了，文章讲师举例是用的 OpenGL (所以这里的 Slide 比前面讲 Core Animation Pipeline 的 Slide 在 Render Server 这一栏，多了 OpenGL 在里面)。具体流程如下：</p><ul><li>GPU 收到 Command Buffer ；</li><li>顶点着色器(Vertex Shader)开始运行，思路就是先将所有的顶点转换到屏幕空间，然后平铺处理，平铺成**瓷砖桶(tile bucket)**的几何图形。<ul><li>这里分两步走，先顶点处理然后平铺，统称为 <strong>Tiler stage</strong>，在 Instrument 的 OpenGL ES tiler utilization 能看到这一步。</li><li>这一步的产出被写入 Parameter Buffer，下一阶段不会马上启动。相反，会等待，直到 <ul><li>a. 处理完所有的几何体，并且都位于 Parameter Buffer 中；或者 </li><li>b. Parameter buffer 已满（满了的话，必须刷新它）。</li></ul></li></ul></li><li>像素着色器(Pixel Shader)处理，这一步被称为 <strong>Renderer stage</strong>，产出被写入 Render Buffer 。(在 Instrument 的 OpenGL ES renderer utilization 能看到这一步。)</li></ul><h4 id="2-4-2-示例：渲染遮罩"><a href="#2-4-2-示例：渲染遮罩" class="headerlink" title="2.4.2 示例：渲染遮罩"></a>2.4.2 示例：渲染遮罩</h4><p>举了一个渲染遮罩的例子，步骤如下图：</p><img src="/images/caa/masking-rendering-pass.png" alt="" style="zoom:35%;" /><p>分三步走，两步渲染，一步合成。</p><ol><li>将遮罩层(相机 icon)渲染到纹理(texture)上；</li><li>将内容层渲染到纹理上；</li><li>将遮罩添加到内容纹理上。</li></ol><h2 id="三、图形相关概念补充"><a href="#三、图形相关概念补充" class="headerlink" title="三、图形相关概念补充"></a>三、图形相关概念补充</h2><h3 id="3-1-显卡与GPU"><a href="#3-1-显卡与GPU" class="headerlink" title="3.1 显卡与GPU"></a>3.1 显卡与GPU</h3><p><a href="https://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E5%8D%A1">显卡</a>是个人电脑最基本组成部分之一，用途是将计算机系统所需要的显示信息进行转换驱动电脑，并提供逐行或隔行扫描信号，控制电脑的正确显示，是连接显示器和个人电脑主板的重要 组件 ，是“人机对话”的重要设备之一。 </p><ul><li>显卡是插在主板上的扩展槽里的(现在一般是PCI-E插槽，此前还有AGP、PCI、ISA等插槽)。它主要负责把主机向显示器发出的显示信号转化为一般电器信号，使得显示器能明白个人电脑 在让它做什么。</li><li>显卡的主要芯片叫“显示芯片”（Video chipset，也叫GPU或VPU，图形处理器或视觉处理器），是显卡的主要处理单元。</li><li>显卡上也有和电脑存储器相似的存储器，称为 “显示存储器”，简称显存。 </li><li>早期的显卡只是单纯意义的显卡，只起到信号转换的作用；目前的显卡一般都带有3D画面运算和图形加速功能 ，所以也叫做“图形加速卡”或“3D加速卡”。</li></ul><p>显卡通常由总线接口、PCB板、显示芯片、显示存储器、RAMDAC、VGA BIOS、VGA端子及其他外围组件构成，现在的显卡大多使用VGA、DVI、HDMI接口或DisplayPort接口。</p><h3 id="3-2-驱动"><a href="#3-2-驱动" class="headerlink" title="3.2 驱动"></a>3.2 驱动</h3><p>设备驱动程序(device driver，简称驱动程序driver)，是一个允许高端电脑软件与硬件交互的程序，这种程序创建了一个硬件与硬件，或硬件与软件沟通的接口，经由主板上的总线(bus)或其它沟通子系统(subsystem)与硬件形成连接的机制，这样的机制使得硬件设备上的资料交换成为可能。</p><h3 id="3-3-硬件加速"><a href="#3-3-硬件加速" class="headerlink" title="3.3 硬件加速"></a>3.3 硬件加速</h3><p>硬件加速是指在计算机中通过把计算量非常大的工作分配给专门的硬件来处理以减轻中央处理器的工作量之技术。尤其是在图像处理中这个技术经常被使用。</p><p>例如，雷神之锤3是第一个必须要求硬件加速的3D游戏。Google Chrome浏览器也设置了“硬件加速”功能，用户可根据需求开启或关闭此功能。</p><h3 id="3-4-图元"><a href="#3-4-图元" class="headerlink" title="3.4 图元"></a>3.4 图元</h3><p>任何一个图形表达都是由若干不同的点、线、面图案或相同的图案循环组合而成的。这些点、线、面图案即为基本图形元素。</p><p>不同的图形系统有不同的图形元素：</p><ul><li>GKS标准规定了6种基本图形元素，即折线、多点记号、填充区、正文、像素阵列和GDP（广义绘图元素）。</li><li>CGM标准除6种基本图形元素外，附加了圆弧、椭圆弧、样条曲线等等图形元素</li></ul><p>基本图形元素所具有的特征有：颜色、亮度、线型、线宽、字符大小、字符间距、字体、图元检索名以及用户定义的其他特征等</p><h3 id="3-5-纹理"><a href="#3-5-纹理" class="headerlink" title="3.5 纹理"></a>3.5 纹理</h3><h4 id="3-5-1-纹理"><a href="#3-5-1-纹理" class="headerlink" title="3.5.1 纹理"></a>3.5.1 纹理</h4><p>计算机图形学中的纹理既包括通常意义上物体表面的纹理即使物体表面呈现凹凸不平的沟纹，同时也包括在物体的光滑表面上的彩色图案，通常我们更多地称之为花纹。</p><ul><li>对于花纹而言，就是在物体表面绘出彩色花纹或图案，产生了纹理后的物体表面依然光滑如故。</li><li>对于沟纹而言，实际上也是要在表面绘出彩色花纹或图案，同时要求视觉上给人以凹凸不平感即可。凹凸不平的图案一般是不规则的。</li></ul><p>在计算机图形学中，这两种类型的纹理的生成方法完全一致，这也是计算机图形学中把他们统称为纹理的原因所在。</p><h4 id="3-5-2-纹理映射"><a href="#3-5-2-纹理映射" class="headerlink" title="3.5.2 纹理映射"></a>3.5.2 纹理映射</h4><p>纹理映射就是在物体的表面上绘制图案。</p><ul><li>Direct3D中的纹理：表示物体表面细节的一幅或几幅二维图形，也称纹理贴图（texture mapping）当把纹理按照特定的方式映射到物体表面上的时候能使物体看上去更加真实。</li><li>Photoshop中的纹理：Photoshop使用“纹理”滤镜赋予图像一种深度或物质的外观，或添加一种有机外观。如龟裂缝、颗粒、马赛克拼贴、拼缀图、染色玻璃、纹理化等。</li><li>Word中也有设置纹理填充。</li></ul><h4 id="3-5-3-材质、贴图、纹理"><a href="#3-5-3-材质、贴图、纹理" class="headerlink" title="3.5.3 材质、贴图、纹理"></a>3.5.3 材质、贴图、纹理</h4><p>整个 CG 领域中这三个概念都是差不多的，在一般的实践中，大致上的层级关系是：</p><blockquote><p>材质 Material 包含 贴图 Map，Map 包含 纹理 Texture。</p><p>日常口语勘误：有人习惯用贴图(Map)指代纹理(Texture)。导致有些场景下贴图就是贴图，有些场景下贴图是在指纹理。这个需要个人区分清楚</p></blockquote><ul><li><p>纹理是最基本的数据输入单位，游戏领域基本上都用的是位图。此外还有程序化生成的纹理 Procedural Texture。</p></li><li><p>贴图的英语 Map 其实包含了另一层含义就是“映射”。其功能就是把纹理通过 UV 坐标映射到3D 物体表面。贴图包含了除了纹理以外其他很多信息，比方说 UV 坐标、贴图输入输出控制等等。</p></li><li><p>材质是一个数据集，主要功能就是给渲染器提供数据和光照算法。</p><ul><li><p>贴图就是其中数据的一部分，根据用途不同，贴图也会被分成不同的类型，比方说 Diffuse Map，Specular Map，Normal Map 和 Gloss Map 等等。</p></li><li><p>另外一个重要部分就是光照模型 Shader ，用以实现不同的渲染效果。</p><p>光照与物体表面的相互作用可以通过将一些数学公式应用于基于per pixel（区别于基于顶点）的着色，从而模拟出真实生活中的各种材质效果。比如浮雕效果，波浪效果，油漆效果等。</p></li></ul></li></ul><h3 id="3-6-着色器"><a href="#3-6-着色器" class="headerlink" title="3.6 着色器"></a>3.6 着色器</h3><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h4><p>计算机图形学领域中，<strong>着色器(shader)是一种计算机程序</strong>，原本用于进行图像的浓淡处理（计算图像中的光照、亮度、颜色等），但近来，它也被用于完成很多不同领域的工作，比如处理CG特效、进行与浓淡处理无关的视频后期处理、甚至用于一些与计算机图形学无关的其它领域。更多介绍见<a href="https://zh.wikipedia.org/wiki/%E7%9D%80%E8%89%B2%E5%99%A8">WIKI</a>。</p><p>功能：构成最终图像的像素、顶点、纹理，它们的位置、色相、饱和度、亮度、对比度也都可以利用着色器中定义的算法进行动态调整。调用着色器的外部程序，也可以利用它向着色器提供的外部变量、纹理来修改这些着色器中的参数。</p><p>常用的着色器有以下三种：</p><ul><li>二维着色器<ul><li>像素着色器</li></ul></li><li>三维着色器</li></ul><h4 id="3-6-2-二维着色器"><a href="#3-6-2-二维着色器" class="headerlink" title="3.6.2 二维着色器"></a>3.6.2 二维着色器</h4><p>二维着色器处理的是数字图像，也叫纹理，着色器可以修改它们的像素。二维着色器也可以参与三维图形的渲染。目前只有“像素着色器”一种二维着色器。</p><h5 id="像素着色器"><a href="#像素着色器" class="headerlink" title="像素着色器"></a>像素着色器</h5><p>像素着色器(pixel shader，也叫片段着色器fragment shader)，用于计算“片段”的颜色和其它属性，此处的“片段”通常是指单独的像素。</p><ul><li>最简单的像素着色器只有输出颜色值；复杂的像素着色器可以有多个输入输出。</li><li>像素着色器既可以永远输出同一个颜色，也可以考虑光照、做凹凸贴图、生成阴影和高光，还可以实现半透明等效果。</li><li>像素着色器还可以修改片段的深度，也可以为多个渲染目标输出多个颜色。</li></ul><p>三维图形学中，单独一个像素着色器并不能实现非常复杂的效果，因为它只能处理单独的像素，没有场景中其它几何体的信息。不过，像素着色器有屏幕坐标信息，如果将屏幕上的内容作为纹理传入，它就可以对当前像素附近的像素进行采样。利用这种方法，可以实现大量二维后期特效，例如模糊和边缘检测。</p><p>像素着色器还可以处理管线中间过程中的任何二维图像，包括精灵和纹理。因此，如果需要在栅格化后进行后期处理，像素着色器是唯一选择。</p><h4 id="3-6-3-三维着色器"><a href="#3-6-3-三维着色器" class="headerlink" title="3.6.3 三维着色器"></a>3.6.3 三维着色器</h4><p>三维着色器处理的是三维模型或者其它几何体，可以访问用来绘制模型的颜色和纹理。</p><ul><li>顶点着色器是最早的三维着色器；</li><li>几何着色器可以在着色器中生成新的顶点；</li><li>细分曲面着色器（tessellation shader）则可以向一组顶点中添加细节。</li></ul><p>顶点着色器处理每个顶点，将顶点的空间位置投影在屏幕上，即计算顶点的二维坐标。同时，它也负责顶点的深度缓冲（Z-Buffer）的计算。顶点着色器可以掌控顶点的位置、颜色和纹理坐标等属性，但无法生成新的顶点。</p><p>顶点着色器的输出传递到流水线的下一步。如果有之后定义了几何着色器，则几何着色器会处理顶点着色器的输出数据，否则，光栅化器继续流水线任务。</p><p>几何着色器可以从多边形网格中增删顶点。它能够执行对CPU来说过于繁重的生成几何结构和增加模型细节的工作。几何着色器的输出连接光栅化器的输入。</p><h4 id="3-6-4-简化图形流水线"><a href="#3-6-4-简化图形流水线" class="headerlink" title="3.6.4 简化图形流水线"></a>3.6.4 简化图形流水线</h4><p>这些类型的着色器终究会用在GPU的流水线中，<strong>简述</strong>它们是如何被安排在流水线中的，简化图形管线/流水线(pipeline)：</p><ul><li>中央处理器（CPU）发送指令（编译的着色器程序）和几何数据到位于显卡内的图形处理器（GPU）。</li><li>顶点着色器执行几何变换和光照计算。</li><li>若几何着色器位于图形处理器内，它便会修改一些几何信息。</li><li>计算后的几何模型被三角化（分割为三角形）。</li><li>三角形被映射为2×2的像素块。</li></ul><h2 id="四、OpenGL-Pipeline"><a href="#四、OpenGL-Pipeline" class="headerlink" title="四、OpenGL Pipeline"></a>四、OpenGL Pipeline</h2><h3 id="图形渲染管线图"><a href="#图形渲染管线图" class="headerlink" title="图形渲染管线图"></a>图形渲染管线图</h3><p>Contex为我们提供OpenGL的运行环境，而具体的操作则是在OpenGL的渲染管线中进行的。</p><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的**图形渲染管线(Graphics Pipeline)**管理的。图形渲染管线可以被划分为两个主要部分：</p><ul><li>第一部分把你的3D坐标转换为2D坐标，</li><li>第二部分是把2D坐标转变为实际的有颜色的像素。</li></ul><blockquote><p>Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></blockquote><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段：</p><ul><li>每个阶段将会把前一个阶段的输出作为输入。</li><li>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做**着色器(Shader)**。</li><li>着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li></ul><blockquote><p>着色器(Shader)是运行在GPU上的小程序。这些小程序为完成图形渲染管线的某个特定部分的功能而运行。</p></blockquote><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的。</p><p>下图一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p><img src="/images/iosrender/pipeline.png" alt="" style="zoom:85%;" /><p>(几何着色器是可选的，通常使用它默认的着色器就行了)。</p><img src="/images/iosrender/17.jpg" alt="" style="zoom:75%;" /><p>如图所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。概括性地解释一下渲染管线的每个部分：</p><h3 id="4-1-顶点数组"><a href="#4-1-顶点数组" class="headerlink" title="4.1 顶点数组"></a>4.1 顶点数组</h3><p>传递一个顶点数组作为图形渲染管线的输入。这个数组叫做顶点数据(Vertex Data)。一个顶点(Vertex)是一个3D坐标的数据的集合。(简单起见，可以假定每个顶点只由一个3D位置和一些颜色值组成)</p><h3 id="4-2-顶点着色器-Vertex-Shader"><a href="#4-2-顶点着色器-Vertex-Shader" class="headerlink" title="4.2 顶点着色器(Vertex Shader)"></a>4.2 顶点着色器(Vertex Shader)</h3><p>它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为OpenGL的内部坐标信息，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>顶点着色器负责坐标和图形的描述。在OpenGL中有三种基本的图形<strong>点、线、三角形</strong>，只能通过这三种基本图形去描述一个图形。其中在OpenGL中我们的显示区域位于x,y均为[-1,1]之内的空间。</p><img src="/images/iosrender/18.jpg" alt="" style="zoom:85%;" /><ul><li><strong>点</strong>：点存在于三维空间，坐标用（x,y,z）表示。</li><li><strong>线</strong>：由两个三维空间中的点组成。</li><li><strong>三角形</strong>：由三个三维空间的点组成。</li></ul><p><strong>输出：顶点</strong>。</p><h3 id="4-3-图元装配阶段-Primitive-Assembly"><a href="#4-3-图元装配阶段-Primitive-Assembly" class="headerlink" title="4.3 图元装配阶段(Primitive Assembly)"></a>4.3 图元装配阶段(Primitive Assembly)</h3><p>将上阶段输出的 — 所有顶点作为输入，进行组装和裁剪，将所有的点装配成指定图元的形状，更准确的说是将所有3D的图元转化为屏幕上2D的图元。</p><img src="/images/iosrender/19.jpg" alt="" style="zoom:85%;" /><p><strong>输出：图元</strong>。（图元由顶点组成）</p><h3 id="4-4-几何着色器-Geometry-Shader"><a href="#4-4-几何着色器-Geometry-Shader" class="headerlink" title="4.4 几何着色器(Geometry Shader)"></a>4.4 几何着色器(Geometry Shader)</h3><p>将上阶段输出的 — 图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。</p><p>(几何着色器是可选的，通常使用它默认的着色器就行了)</p><p><strong>输出：新的图元</strong>。</p><p>到这一步我们已经为OpenGL描述了一个图形的样子，但是要转换为图像还需要颜色信息。↓</p><h3 id="4-5-光栅化阶段-Rasterization-Stage"><a href="#4-5-光栅化阶段-Rasterization-Stage" class="headerlink" title="4.5 光栅化阶段(Rasterization Stage)"></a>4.5 光栅化阶段(Rasterization Stage)</h3><p>将上阶段输出的 — 图元映射为最终屏幕上相应的像素，生成供片段着色器使用的片段(Fragment)，即实现通过插值运算将连续的值用一个个像素片段表示出来。</p><img src="/images/iosrender/20.png" alt="" style="zoom:55%;" /><p>在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p>**输出：片元/片段(Fragment)**。 </p><ul><li>光栅化：将图转化为一个个栅格组成的图像，每个栅格此处又称为片元/片段(Fragment)，OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</li><li>片元其实已经很接近像素了，但是它还不是像素。片元包含了比RGBA更多的信息，比如可能有深度值，法线，纹理坐标等等信息。</li><li>片元需要在通过一些测试（如深度测试）后才会最终成为像素。可能会有多个片元竞争同一个像素，而这些测试会最终筛选出一个合适的片元，丢弃法线和纹理坐标等不需要的信息后，成为像素。</li></ul><h3 id="4-6-片段着色器-Fragment-Shader"><a href="#4-6-片段着色器-Fragment-Shader" class="headerlink" title="4.6 片段着色器(Fragment Shader)"></a>4.6 片段着色器(Fragment Shader)</h3><p>到了这一步我们已经有了一个个的像素片段（Fragament），我们在这个阶段给它涂上颜色值就可以变成一个完整的像素点。包括位置，颜色，纹理坐标等信息。</p><p>片段着色器的主要目的就是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。</p><p>通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><blockquote><p>同时我们可以编写Fragament Shader的脚本来实现对每个像素颜色的变换来达到一些效果，如纹理贴图，光照，环境光，阴影。</p></blockquote><p><strong>输出：一个像素的最终颜色</strong>。像素 — 影像的最小的完整取样。最终呈现在屏幕上的包含RGBA值的图像最小单元就是像素了。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段。</p><h3 id="4-7-Alpha测试和混合-Blending-阶段"><a href="#4-7-Alpha测试和混合-Blending-阶段" class="headerlink" title="4.7 Alpha测试和混合(Blending)阶段"></a>4.7 Alpha测试和混合(Blending)阶段</h3><p>主要是检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。</p><p>这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>有的书中，称这个阶段也称<strong>片段测试阶段</strong>，对每个像素点进行测试保证这些像素点是正确可用的，最后在输入到帧缓冲（Frambuffer）中。</p><img src="/images/iosrender/21.jpg" alt="" style="zoom:85%;" /><blockquote><p>混合：当图像叠加时，上方图层和下方图层的像素进行混合，从而得到另外一种图像效果。</p></blockquote><blockquote><p>抖动(Dither)是在数字信号处理领域的中一项用于降低量化误差的技术。透过在较低比特中加入噪声，借此破坏谐波的排序，使谐波的影响受到压制，并减少量化误差在低频的影响。抖动常用于音视频处理，且是CD压制过程的最后一步。经过抖动处理过的音乐，将听起来更柔顺、背景更黑；而经过抖动处理过的影像，也会更加地柔顺耐看。</p><p>抖动最重要的用途之一是将灰阶图像转为黑白。透过使用抖动算法，可以令黑白图案的黑点密度接近原图案的大致灰度。</p><p>在数字图像处理中，经常使用抖动混合几种颜色，在颜色数量受限时产生出新的“颜色深度”。</p></blockquote><h3 id="4-8-渲染帧缓存-Renderbuffer"><a href="#4-8-渲染帧缓存-Renderbuffer" class="headerlink" title="4.8 渲染帧缓存(Renderbuffer)"></a>4.8 渲染帧缓存(Renderbuffer)</h3><h4 id="4-8-1-帧缓存-Framebuffer）"><a href="#4-8-1-帧缓存-Framebuffer）" class="headerlink" title="4.8.1 帧缓存 (Framebuffer）"></a>4.8.1 帧缓存 (Framebuffer）</h4><p>经过上述处理流程，我们想要看到的图形图像数据最后都会存储到<strong>帧缓存区（Framebuffer）</strong>中。我们可以同时存在很多帧缓存（Framebuffer），并且可以通过OpenGL让GPU把渲染结果存储到任意数量的帧缓存中（这里引申出一个离屏渲染的工作概念）。</p><p>但是，只有将内容绘制到视窗体提供的<strong>帧缓存（Renderbuffer）</strong>中，才能将内容输出到显示设备。在实现上渲染缓存（Renderbuffer）是直接跟屏幕映射的，可以绕开CPU进行工作。</p><img src="/images/iosrender/22.jpg" alt="" style="zoom:85%;" /><h4 id="4-8-2-帧缓存的渲染"><a href="#4-8-2-帧缓存的渲染" class="headerlink" title="4.8.2 帧缓存的渲染"></a>4.8.2 帧缓存的渲染</h4><p>基本工作原理是存在两个缓存（前缓存和后缓存），当屏幕的刷新同步信号到达时让系统将后缓存交换到前缓存区上。</p><p>这个刷新的时间是由系统决定的，比如在iOS中屏幕刷新率是60fps即每16.75ms会发生一次前后缓存的交换。我们只需要准备好后缓存的数据提供给系统就能进行屏幕刷新渲染了。</p><img src="/images/iosrender/23.png" alt="" style="zoom:85%;" /><h3 id="4-8-小结"><a href="#4-8-小结" class="headerlink" title="4.8 小结"></a>4.8 小结</h3><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p><p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p><p>以上就是OpenGL整体工作流程。首先OpenGL是用来操作GPU进行图形图像渲染工作的，它的操作粒度可以到每个像素点，同时它是直接操作GPU硬件工作的。而之后的工作核心（2D图形图像渲染）基本是集中在对顶点着色器和片段着色器的脚本实现上（酷炫的滤镜效果和动画效果）。</p><h2 id="五、案例1-—-UIBlurEffect的渲染过程"><a href="#五、案例1-—-UIBlurEffect的渲染过程" class="headerlink" title="五、案例1 — UIBlurEffect的渲染过程"></a>五、案例1 — UIBlurEffect的渲染过程</h2><p>UIBlurEffect 是 iOS8 新出的用来实现模糊效果的类。</p><h3 id="5-1-渲染步骤"><a href="#5-1-渲染步骤" class="headerlink" title="5.1 渲染步骤"></a>5.1 渲染步骤</h3><p>它的渲染过程如下：</p><img src="/images/caa/blureffect-rendering-pass.png" alt="" style="zoom:37%;" /><ol><li>渲染 layer 的 content，在这种情况下，它只是一个简单的图像，因此如果我们涉及 UI ，可能需要更长的时间；</li><li>截获 layer 的 content，进行缩放，它实际上相当快。这几乎是不变的成本；</li><li>对缩放内容进行横向模糊，也非常快，因为是小区域。</li><li>对缩放内容进行纵向模糊，同上</li><li>合成操作，合并所有模糊结果。</li></ol><h3 id="5-2-每一步中的三事件"><a href="#5-2-每一步中的三事件" class="headerlink" title="5.2 每一步中的三事件"></a>5.2 每一步中的三事件</h3><p>再看下图，聚焦在一帧。我们可以看到每个渲染步骤所需的时间，每个渲染步骤都牵扯到了下面要提到的三个事件(tile/render/VBlank interrupt)。</p><img src="/images/caa/blureffect1.png" alt="UIBlurEffect1" style="zoom:85%;" /><p>我们可以看到有三行，每一行代表一个事件</p><ul><li>tile activity</li><li>render activity</li><li>VBlank interrupt, “and the last row I put in the VBlank interrupt and we can actually see what our frame boundaries are.” (我们实际上可以看到我们的帧边界是什么)</li></ul><h3 id="5-3-步骤间隙"><a href="#5-3-步骤间隙" class="headerlink" title="5.3 步骤间隙"></a>5.3 步骤间隙</h3><p>我们注意到下图，每个步骤之间的间隙，用橘色标记了</p><img src="/images/caa/blureffect2.png" alt="UIBlurEffect2" style="zoom:87%;" /><p>5 个步骤中间有 4 个间隙，之所以存在，是因为这是发生在 GPU 上切换所花的时间。在空闲时间，每个步骤所花费的时间大概在 0.1<code>~~</code>0.2ms, 所以总共 0.4<code>~~</code>0.8ms, 所以这个是 16.67ms 的一个重要组成部分。</p><p>还列举了不同设备间的耗时，有一种设备某个 Dark style 下的时间是 18.15ms, 超过 16.67ms, 所以不可能在 60 hert 渲染完成。所以 Apple 在这些设备上不支持 blur 。</p><p>UIBlurEffect 有三种 style: Extra light, Light, Dark ，它们消耗的资源各不相同， Dark 最少， Extra light 最多。</p><h2 id="六、案例2-—-UIVibrancyEffect的渲染过程"><a href="#六、案例2-—-UIVibrancyEffect的渲染过程" class="headerlink" title="六、案例2 — UIVibrancyEffect的渲染过程"></a>六、案例2 — UIVibrancyEffect的渲染过程</h2><p>UIVibrancyEffect 是在模糊之上使用的效果，它可以<strong>确保内容突出，而不会被模糊</strong>。它的渲染过程如下：</p><img src="/images/caa/vibrancyeffect-rendering-pass.png" alt="" style="zoom:45%;" /><p>比 UIBlurEffect 多了两个步骤，最后一个步骤 filter 是最昂贵的，所以作用区域越小越好，千万别作用到全屏上。</p><img src="/images/caa/vibrancyeffect1.png" alt="" style="zoom:90%;" /><p>所以也会比 UIBlurEffect 多两个间隙，所以总共 0.6~1.2ms.</p><img src="/images/caa/vibrancyeffect2.png" alt="UIVibrancyEffect2" style="zoom:90%;" /><h2 id="七、分析工具-Profiling-tools"><a href="#七、分析工具-Profiling-tools" class="headerlink" title="七、分析工具(Profiling tools)"></a>七、分析工具(Profiling tools)</h2><h3 id="7-1-性能关注点"><a href="#7-1-性能关注点" class="headerlink" title="7.1 性能关注点"></a>7.1 性能关注点</h3><p>性能调查要考虑以下点</p><img src="/images/caa/performance-inverstigation-mindset.png" alt="" style="zoom:80%;" /><ul><li>What is the frame rate? Goal is always 60 fps. <ul><li>检查工具： Instrument — Core Animation template / OpenGL ES driver template</li></ul></li><li>CPU or GPU bound? Lower utilization is desired and saves battery. <ul><li>更少的 CPU 或者 GPU 利用率，让电池更持久。</li><li>检查工具： Instrument — OpenGL ES driver template</li></ul></li><li>Any unnecessary CPU rendering? GPU is desirable but know when CPU makes sense. <ul><li>得知道渲染什么和怎么渲染， <code>drawRect</code> 方法尽量少用，减少让 CPU 的工作，让 GPU 做更多的渲染。</li><li>检查工具： Instrument — Core Animation template / OpenGL ES driver template</li></ul></li><li>Too many offscreen passes? Fewer is better. <ul><li>前面说 UIBlurEffect 的时候有说到，橘色的间隙就是用在 GPU 切换时间，每个间隙大概 0.1~0.2ms 。 离屏渲染也会出现这样的情况，因为它必须进行切换，所以得减少。因为前面有提到，我们减少 CPU 或者 GPU 的使用时间。</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Too much blending? less is better. <ul><li>GPU 处理 blending 合成的时候，操作昂贵，消耗性能</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Any strange image formats or sizes? Avoida on-the-fly conversions or resizing. <ul><li>会转给 CPU 去处理，增加 CPU 的负担</li><li>检查工具： Instrument — Core Animation template</li></ul></li><li>Any expensive views or effects? Understand the cost of what is in use. <ul><li>避免昂贵的效果，例如 Blur 和 Vibrancy ，得去考量。</li><li>检查工具： Xcode view debugging</li></ul></li><li>Anything unexpected in the view hierarchy? Know the actual view hierarchy. <ul><li>添加和移除要匹配。</li><li>检查工具： Xcode view debugging</li></ul></li></ul><h3 id="7-2-检查工具"><a href="#7-2-检查工具" class="headerlink" title="7.2 检查工具"></a>7.2 检查工具</h3><p>上面每个例子后面都有提到一个检测工具，这里来讲讲相应检测工具的作用。请注意一点，在开始挖掘代码以试图找出正在发生的事情之前，这总是一个很好的起点(<strong>先看大概发生什么问题，再深入研究代码</strong>)。</p><h4 id="7-2-1-Core-Animation-template"><a href="#7-2-1-Core-Animation-template" class="headerlink" title="7.2.1 Core Animation template"></a>7.2.1 Core Animation template</h4><ul><li>看 fps</li><li>color blended layers, green 表示不透明， red 代表需要去 blend 混合。 增加 GPU 的工作。 绿多红少，是理想中的状态。</li><li>color hit screens and misses red, 展示如何使用或滥用 CALayer’rasterize 属性，没命中缓存就是红色。第一次启动会有很多红色，因为必须在它被缓存之前渲染一次，后面就没有了，因为缓存了。</li><li>color copied images, 如果是 GPU 不支持的图片就会让 CPU 去转换(在 commit phase)，增加了 CPU 的工作。 显示为蓝绿色(cyan)就表示让 CPU 去转换，影响滚动体验。 所以 size and color/image format 最好提前在后台处理好，不要阻塞主线程。</li><li>color misaligned images, 黄色表示需要缩放，紫色表示像素没对齐。</li><li>color offscreen-rendered yellow, 黄色代表离屏渲染。 nav bar 和 tool bar 是黄色，因为这些图层的模糊实际上模糊了它背后的内容(前面 blur 有讲过)。</li><li>color OpenGL fast path blue, 蓝色是好事，由显示硬件去 blend ，这样就会减少 GPU 的工作。</li><li>flash updated regions, 正在更新的部分为黄色。 理想状况下，黄色区域越少越好。它意味着 CPU 和 GPU 的工作都减少了。</li></ul><h4 id="6-2-2-OpenGL-ES-driver-template"><a href="#6-2-2-OpenGL-ES-driver-template" class="headerlink" title="6.2.2 OpenGL ES driver template"></a>6.2.2 OpenGL ES driver template</h4><ul><li>device utilization, which will show you how much the GPU is in use during the trace. (使用率越少越好，这里举例的是 30% vs 70%(心中的理想值))</li><li>render and tiler utilization, correspond to the renderer and tiler phases.</li><li>CoreAnimationFramesPerSecond, what the actual frame rate is that we’re seeing.</li></ul><h4 id="6-2-3-Time-Profiler-template"><a href="#6-2-3-Time-Profiler-template" class="headerlink" title="6.2.3 Time Profiler template"></a>6.2.3 Time Profiler template</h4><ul><li>看调用栈耗时，看 CPU 在干什么；</li></ul><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_5">Learn OpenGL</a> (已fork，备丢)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://joakimliu.github.io/2019/03/02/wwdc-2014-419/&quot;&gt;原文&lt;/a&gt;，摘自 &lt;a href=&quot;https://developer.apple.com/videos/play/w</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation(二) - 隐式动画、CATransaction与CAAction</title>
    <link href="https://tenloy.github.io/2021/09/09/core-animation02.html"/>
    <id>https://tenloy.github.io/2021/09/09/core-animation02.html</id>
    <published>2021-09-09T19:36:17.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques/blob/master/7-%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB/%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB.md">原文地址</a> 译自《iOS Core Animation Advanced Techniques》</p></blockquote><p>动画是Core Animation库一个非常显著的特性。这一章我们来看看它是怎么工作的。具体来说，我们先来讨论框架自动实现的<em>隐式动画</em>（除非你明确禁用了这个功能）。</p><h2 id="一、可动画、事务与RunLoop"><a href="#一、可动画、事务与RunLoop" class="headerlink" title="一、可动画、事务与RunLoop"></a>一、可动画、事务与RunLoop</h2><h3 id="1-1-可动画的图层属性"><a href="#1-1-可动画的图层属性" class="headerlink" title="1.1 可动画的图层属性"></a>1.1 可动画的图层属性</h3><p>Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。你并不需要在Core Animation中手动打开动画，但是你需要明确地关闭它，否则它会一直存在。</p><p>当你改变<code>CALayer</code>一个可做动画的属性时，这个改变并不会立刻在屏幕上体现出来。相反，该属性会从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作 —— 这就是可动画的(隐式动画)。</p><blockquote><p>可动画的(animatable)：当改变时，会触发一个从旧的值过渡到新值的简单动画；</p></blockquote><p><strong>几乎所有的图层的属性都是隐性可动画的。</strong>你可以在文档中看到它们的简介是以 ‘animatable’ 结尾的。这不仅包括了比如位置，尺寸，颜色或者透明度这样的绝大多数的数值属性，甚至也囊括了像 isHidden 和 doubleSided 这样的布尔值。 像 paths 这样的属性也是 animatable 的，但是它不支持隐式动画。</p><h3 id="1-2-CATransaction"><a href="#1-2-CATransaction" class="headerlink" title="1.2 CATransaction"></a>1.2 CATransaction</h3><p><a href="https://developer.apple.com/documentation/quartzcore/catransaction">CATransaction</a>是Core Animation中的事务类，负责批量的把多个对图层树(layer-tree)的修改作为一个原子更新到渲染树。</p><ul><li>事务是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可动画的图层属性都不会立刻发生变化，而是当事务一旦<em>提交</em>的时候开始用一个动画过渡到新值。</li><li>事务是通过<code>CATransaction</code>类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。<code>CATransaction</code>没有属性或者实例方法，并且也不能用<code>+alloc</code>和<code>-init</code>方法创建它。而是用类方法<code>+begin</code>和<code>+commit</code>分别来入栈或者出栈。</li><li>支持嵌套事务。</li></ul><p>在iOS中的图层中，<strong>对图层树的每次修改都必须是事务的一部分</strong>。任何可动画的图层属性，发生改变产生的动画都会被添加到栈顶的事务，你可以通过<code>+setAnimationDuration:</code>方法设置当前事务的动画时间，或者通过<code>+animationDuration</code>方法来获取时长值（默认0.25秒）。</p><p>Core Animation支持两种类型的事务：隐式事务和显式事务。</p><ul><li><p><strong>当图层树被没有显式事务的线程修改时，隐式事务会自动创建，并在线程的 runloop 下一次迭代时自动提交</strong>。</p><ul><li>即Core Animation会监测修改，然后在每个<em>runloop</em>周期中自动开始一次新的事务（runloop是iOS负责收集用户输入，处理未完成的定时器或者网络事件，最终重新绘制屏幕的东西），即使你不显式地使用<code>[CATransaction begin]</code>开始一次事务，在一个特定runloop循环中的任何属性的变化都会被收集起来，然后做一次0.25秒的动画。</li></ul></li><li><p>当应用程序在修改图层树之前向 CATransaction 类发送 begin() 消息，然后向 CATransaction 类发送 commit() 消息时，就会发生显式事务。</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CATransaction</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和提交事物（Creating and Committing Transactions）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前线程创建一个新的事物(Transaction)，可嵌套 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)begin;   </span><br><span class="line"><span class="comment">/* 提交当前事物中的所有改动，如果事物不存在将会出现异常 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)commit;  </span><br><span class="line"><span class="comment">/* 提交任意的隐式动画，将被延迟一直到嵌套的显示事物被完成 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)flush;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写动画时间（Overriding Animation Duration and Timing）</span></span><br><span class="line"><span class="comment">/* 获取动画时间，默认0.25秒 */</span></span><br><span class="line">+ (<span class="built_in">CFTimeInterval</span>)animationDuration;</span><br><span class="line"><span class="comment">/* 设置动画时间 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationDuration:(<span class="built_in">CFTimeInterval</span>)dur;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认nil，设置和获取CAMediaTimingFunction（速度控制函数） */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">CAMediaTimingFunction</span> *)animationTimingFunction;</span><br><span class="line">+ (<span class="keyword">void</span>)setAnimationTimingFunction:(<span class="keyword">nullable</span> <span class="built_in">CAMediaTimingFunction</span> *)function;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止属性更改而触发的action(隐式动画)（Temporarily Disabling Property Animations）</span></span><br><span class="line"><span class="comment">/* 每条线程事物，都有disableActions属性的存取器，即设置和获取方法，默认为false，允许隐式动画 */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)disableActions;</span><br><span class="line">+ (<span class="keyword">void</span>)setDisableActions:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调闭包（Getting and Setting Completion Block Objects）</span></span><br><span class="line"><span class="comment">/* 动画完成之后被调用 */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionBlock;</span><br><span class="line">+ (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理并发（Managing Concurrency）</span></span><br><span class="line"><span class="comment">/* 两个方法用于动画事物的加锁与解锁 在多线程动画中，保证修改属性的安全 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)lock;</span><br><span class="line">+ (<span class="keyword">void</span>)unlock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置和获取事物属性（Getting and Setting Transaction Properties）</span></span><br><span class="line"><span class="comment">/* 支持的事务属性包括:&quot;animationDuration&quot;， &quot;animationTimingFunction&quot;， &quot;completionBlock&quot;， &quot;disableActions&quot;。*/</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">+ (<span class="keyword">void</span>)setValue:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="二、隐式动画"><a href="#二、隐式动画" class="headerlink" title="二、隐式动画"></a>二、隐式动画</h2><h3 id="2-1-演示"><a href="#2-1-演示" class="headerlink" title="2.1 演示"></a>2.1 演示</h3><p>隐式动画看起来这太棒了，似乎不太真实，我们用一个demo来解释一下：首先和第一章“图层树”一样创建一个蓝色的方块，然后添加一个按钮，随机改变它的颜色。点击按钮，你会发现图层的颜色平滑过渡到一个新值，而不是跳变。代码及显示效果如下：</p><p>清单7.1 随机改变图层颜色</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create sublayer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">    <span class="comment">//add it to our view</span></span><br><span class="line">    [<span class="keyword">self</span>.layerView.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;                                                                                       ￼</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><img src="/images/caa/7.1.jpg" alt="" style="zoom:40%;" /><p>这其实就是所谓的<em>隐式</em>动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。Core Animaiton同样支持<em>显式</em>动画，下章详细说明。</p><p>当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前<em>事务</em>的设置，动画类型取决于*图层行为(action)*。</p><p>我们当然可以用当前事务的<code>+setAnimationDuration:</code>方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</p><p>修改后的代码见清单7.2。运行程序，你会发现色块颜色比之前变得更慢了。</p><p>清单7.2 使用<code>CATransaction</code>控制动画时间</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    ￼<span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-UIView动画的底层事务"><a href="#2-2-UIView动画的底层事务" class="headerlink" title="2.2 UIView动画的底层事务"></a>2.2 UIView动画的底层事务</h3><p>如果你用过<code>UIView</code>的动画方法做过一些动画效果，那么应该对这个模式不陌生。<code>UIView</code>有两个方法，<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>，和<code>CATransaction</code>的<code>+begin</code>和<code>+commit</code>方法类似。实际上在<code>+beginAnimations:context:</code>和<code>+commitAnimations</code>之间所有视图或者图层属性的改变而做的动画都是由于设置了<code>CATransaction</code>的原因。</p><p>在iOS4中，苹果对UIView添加了一种基于block的动画方法：<code>+animateWithDuration:animations:</code>。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。</p><p><code>CATransaction</code>的<code>+begin</code>和<code>+commit</code>方法在<code>+animateWithDuration:animations:</code>内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对<code>+begin</code>和<code>+commit</code>匹配的失误造成的风险。</p><h3 id="2-3-事务完成block"><a href="#2-3-事务完成block" class="headerlink" title="2.3 事务完成block"></a>2.3 事务完成block</h3><p>基于<code>UIView</code>的block的动画允许你在动画结束的时候提供一个完成的动作。<code>CATranscation</code>接口提供的<code>+setCompletionBlock:</code>方法也有同样的功能。我们来调整上个例子，在颜色变化结束之后执行一些操作。我们来添加一个完成之后的block，用来在每次颜色变化结束之后切换到另一个旋转90的动画。</p><p>示例：在颜色动画完成之后添加一个回调，比如再做一次旋转</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//add the spin animation on completion</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;</span><br><span class="line">        <span class="comment">//rotate the layer 90 degrees</span></span><br><span class="line">        <span class="built_in">CGAffineTransform</span> transform = <span class="keyword">self</span>.colorLayer.affineTransform;</span><br><span class="line">        transform = <span class="built_in">CGAffineTransformRotate</span>(transform, M_PI_2);</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.affineTransform = transform;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    <span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/caa/7.2.jpg" alt="" style="zoom:40%;" /><p>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p><h2 id="三、图层行为-action"><a href="#三、图层行为-action" class="headerlink" title="三、图层行为(action)"></a>三、图层行为(action)</h2><h3 id="3-1-UIView所关联layer禁止隐式动画"><a href="#3-1-UIView所关联layer禁止隐式动画" class="headerlink" title="3.1 UIView所关联layer禁止隐式动画"></a>3.1 UIView所关联layer禁止隐式动画</h3><p>在 iOS 中也有一些单独的 layer，比如 <code>AVCaptureVideoPreviewLayer</code> 和 <code>CAShapeLayer</code>，它们不需要附加到 view 上就可以在屏幕上显示内容。两种情况下其实都是 layer 在起决定作用。</p><p>当然了，附加到 view 上的 layer 和单独的 layer 在行为上还是稍有不同的。</p><ul><li><p>基本上你改变一个单独的 layer 的任何属性的时候，都会触发一个从旧的值过渡到新值的简单动画（这就是所谓的可动画 <code>animatable</code>）。</p></li><li><p>然而，如果你改变的是 view 中 layer 的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有 layer，但是当 layer 附加在 view 上时，它的默认的隐式动画的 layer 行为就不起作用了。</p></li></ul><p>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对<em>为什么</em>会这样做出了一个解释：</p><blockquote><p>UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们</p></blockquote><p>这正是我们所看到的行为；当一个属性在动画 block 之外被改变时，没有动画，但是当属性在动画 block 内被改变时，就带上了动画。对于这是_如何_发生的这一问题的答案十分简单和优雅，它优美地阐明和揭示了 view 和 layer 之间是如何协同工作和被精心设计的。</p><p>示例：现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。</p><p>下面代码是对上面代码的一点修改，移除了<code>colorLayer</code>，并且直接设置<code>layerView</code>关联图层的背景色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//set the color of our layerView backing layer directly</span></span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//begin a new transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">//set the animation duration to 1 second</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1.0</span>];</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.layerView.layer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    <span class="comment">//commit the transaction</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。发生了什么呢？隐式动画好像被<code>UIView</code>关联图层给禁用了。</p><p>UIKit建立在Core Animation之上，而Core Animation默认对<code>CALayer</code>的所有属性（可动画的属性）做动画，但是<code>UIView</code>把它关联的图层的这个特性关闭了。</p><p>那么隐式动画是如何被UIKit禁用掉呢？为了更好说明这一点，我们需要知道隐式动画是如何实现的。</p><h3 id="3-2-CAAction"><a href="#3-2-CAAction" class="headerlink" title="3.2 CAAction"></a>3.2 CAAction</h3><p>无论何时，一个可动画的 layer 属性改变时，layer 都会寻找并运行合适的 ‘action’ 来实行这个改变。在 Core Animation 的专业术语中把这种改变属性时<code>CALayer</code>自动应用的动画称为action，或者 <code>CAAction</code>，中文译作动作，也称行为（<strong>以下统称 行为</strong>）。</p><p><strong>行为通常是一个被Core Animation<em>隐式</em>调用的<em>显式</em>动画对象。</strong></p><h4 id="1-2-1-CALayer与CAAction协议"><a href="#1-2-1-CALayer与CAAction协议" class="headerlink" title="1.2.1 CALayer与CAAction协议"></a>1.2.1 CALayer与CAAction协议</h4><blockquote><p>CAAction：技术上来说，这是一个接口，并可以用来做各种事情。但是实际中，某种程度上你可以只把它理解为用来处理动画。</p></blockquote><blockquote><p>是一个接口，允许对象响应 CALayer 改变触发的 actions</p></blockquote><p>下面是摘的CALayer中，有关CAAction的部分属性、方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Action (event handler) protocol. **/</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAction</span></span></span><br><span class="line"><span class="comment">//当一个 action object 被调用时，它接收三个参数：事件的名称、事件发生的对象（layer）以及特定于每种事件类型的命名参数字典。</span></span><br><span class="line">- (<span class="keyword">void</span>)runActionForKey:(<span class="built_in">NSString</span> *)event object:(<span class="keyword">id</span>)anObject arguments:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)dict;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CALayer</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">CALayerDelegate</span>&gt; delegate;</span><br><span class="line"><span class="comment">/* A dictionary mapping keys to objects implementing the CAAction protocol. Default value is nil. */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;&gt; *actions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *style;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)defaultActionForKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此方法搜索 layer 的给定action object。Actions 为 layer 定义了一些动态行为。</span></span><br><span class="line"><span class="comment"> * @param event/key action标识符（a key path、外部action名称或预定义action标识符）</span></span><br><span class="line"><span class="comment"> * @return 返回为key提供的action object。该对象必须实现 CAAction 协议</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/* 如果已定义，则由 -actionForKey: 方法的默认实现调用。 */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>CALayer 的 animatable 属性通常都具有相应的 action object 来启动实际动画，也就是说<strong>当 <code>CALayer</code> 改变属性时会自动应用动画</strong>。</p><p>当<code>CALayer</code>的属性被修改时候，它会调用<code>-actionForKey:</code>方法，传递属性的名称。来查找到与该属性名称关联的 action object （遵守 CAAction 协议，并能接收 <code>run(forKey:object:arguments:)</code> 消息）并执行它。</p><p>您还可以将自定义 action objects 与你的 layer 相关联，以实现一些 APP 特定的操作。</p><h4 id="1-2-2-actionForKey-查找流程"><a href="#1-2-2-actionForKey-查找流程" class="headerlink" title="1.2.2 actionForKey:查找流程"></a>1.2.2 actionForKey:查找流程</h4><p>layer 将像 <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410844-actionforkey">CALayer 的 actionForKey: 文档</a> 中所写的的那样去寻找对应属性变化的 action，整个过程分为四个步骤：</p><ol><li>如果该 layer 具有实现 <code>actionForLayer:forKey:</code> 方法的 delegate，则 layer 调用该方法并返回结果。返回值：<ul><li>返回给定 key 的 action object，这种情况下 layer 将使用这个行为。</li><li>如果它不处理 action，则返回 NSNull 对象，告诉 layer 这里不需要执行一个行为，明确地强制不再进行进一步的搜索。</li><li>返回一个 <code>nil</code>， 这样 layer 就会到其他地方继续寻找。</li></ul></li><li>如果没有委托，或者委托没有实现<code>-actionForLayer:forKey</code>方法，图层接着检查包含属性名称对应行为映射的<code>actions</code>字典。</li><li>如果<code>actions</code>字典没有包含对应的属性，那么图层接着在它的<code>style</code>字典接着搜索属性名。</li><li>最后，如果在<code>style</code>里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的<code>-defaultActionForKey:</code>方法。</li></ol><p>如果上述任何步骤返回 NSNull 的实例，则在继续之前将其转换为 nil。</p><p>所以一轮完整的搜索结束之后，<code>-actionForKey:</code>要么返回空（这种情况下将不会有动画发生），要么是<code>CAAction</code>协议对应的对象，最后<code>CALayer</code>拿这个结果去对先前和当前的值做动画。</p><p><strong>上面的步骤，是对于单独的 layer 来说的。对于 view 中的 layer，对行为的搜索只会到第一步为止（至少我没有见过 view 返回一个 <code>nil</code> 然后导致继续搜索行为的情况）。</strong></p><p>让这一切变得有趣的是，当 layer 在背后支持一个 view 的时候，view 就是它的 delegate；</p><blockquote><p>在 iOS 中，如果 layer 与一个 UIView 对象关联时，这个属性<code>必须</code>被设置为持有这个 layer 的那个 view。</p></blockquote><p>理解这些之后，就很容易解释UIKit是如何禁用隐式动画的：属性改变时 layer 会向 view 请求一个行为，而一般情况下 view 将返回一个 <code>NSNull</code>，只有当属性改变发生在动画 block 中时，view 才会返回实际的行为。</p><h4 id="1-2-3-验证示例1"><a href="#1-2-3-验证示例1" class="headerlink" title="1.2.3 验证示例1"></a>1.2.3 验证示例1</h4><p>对一个一般来说可以动画的 layer 属性向 view 询问行为就可以了，比如对于 ‘position’：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;outside animation block: %@&quot;</span>,</span><br><span class="line">      [myView actionForLayer:myView.layer forKey:<span class="string">@&quot;position&quot;</span>]);</span><br><span class="line"></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;inside animation block: %@&quot;</span>,</span><br><span class="line">          [myView actionForLayer:myView.layer forKey:<span class="string">@&quot;position&quot;</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>运行上面的代码，可以看到在 block 外 view 返回的是 NSNull 对象，而在 block 中时返回的是一个 CABasicAnimation。很优雅，对吧？值得注意的是打印出的 NSNull 是带着一对尖括号的 (“<code>&lt;null&gt;</code>“)，这和其他对象一样，而打印 nil 的时候我们得到的是普通括号(<code>(null)</code>)：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outside animation block: &lt;null&gt;</span><br><span class="line">inside animation block: &lt;<span class="built_in">CABasicAnimation</span>: <span class="number">0x8c2ff10</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-验证示例2"><a href="#1-2-4-验证示例2" class="headerlink" title="1.2.4 验证示例2"></a>1.2.4 验证示例2</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//test layer action when outside of animation block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Outside: %@&quot;</span>, [<span class="keyword">self</span>.layerView actionForLayer:<span class="keyword">self</span>.layerView.layer forKey:<span class="string">@&quot;backgroundColor&quot;</span>]);</span><br><span class="line">    <span class="comment">//begin animation block</span></span><br><span class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//test layer action when inside of animation block</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Inside: %@&quot;</span>, [<span class="keyword">self</span>.layerView actionForLayer:<span class="keyword">self</span>.layerView.layer forKey:<span class="string">@&quot;backgroundColor&quot;</span>]);</span><br><span class="line">    <span class="comment">//end animation block</span></span><br><span class="line">    [<span class="built_in">UIView</span> commitAnimations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行程序，控制台显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LayerTest[21215:c07] Outside: &lt;null&gt;</span><br><span class="line">$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;</span><br></pre></td></tr></table></figure><h3 id="3-3-setDisableActions"><a href="#3-3-setDisableActions" class="headerlink" title="3.3 +setDisableActions"></a>3.3 +setDisableActions</h3><p>当然返回<code>NSNull</code>并不是禁用隐式动画唯一的办法，<code>CATransaction</code>有个方法叫做<code>+setDisableActions:</code>，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的<code>[CATransaction begin]</code>之后添加下面的代码，同样也会阻止动画的发生：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>总结一下，我们知道了如下几点</p><ul><li><code>UIView</code>关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用<code>UIView</code>的动画函数（而不是依赖<code>CATransaction</code>），或者继承<code>UIView</code>，并覆盖<code>-actionForLayer:forKey:</code>方法，或者直接创建一个显式动画。</li><li>对于单独存在的图层，我们可以通过实现图层的<code>-actionForLayer:forKey:</code>委托方法，或者提供一个<code>actions</code>字典来控制隐式动画。</li></ul><p>我们来对颜色渐变的例子使用一个不同的行为，通过给<code>colorLayer</code>设置一个自定义的<code>actions</code>字典。我们也可以使用委托来实现，但是<code>actions</code>字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？</p><h3 id="3-5-自定义图层属性行为"><a href="#3-5-自定义图层属性行为" class="headerlink" title="3.5 自定义图层属性行为"></a>3.5 自定义图层属性行为</h3><p>行为通常是一个被Core Animation<em>隐式</em>调用的<em>显式</em>动画对象。这里我们使用的是一个实现了<code>CATransition</code>的实例，叫做<em>推进过渡</em>（代码如下）。</p><p>显式动画中的过渡，不再赘述，对于现在，只要知道<code>CATransition</code>响应<code>CAAction</code>协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。</p><p>实现自定义行为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *layerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create sublayer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</span><br><span class="line">    <span class="comment">//add a custom action</span></span><br><span class="line">    <span class="built_in">CATransition</span> *transition = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">    transition.type = kCATransitionPush;</span><br><span class="line">    transition.subtype = kCATransitionFromLeft;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.actions = @&#123;<span class="string">@&quot;backgroundColor&quot;</span>: transition&#125;;</span><br><span class="line">    <span class="comment">//add it to our view</span></span><br><span class="line">    [<span class="keyword">self</span>.layerView.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//randomize the layer background color</span></span><br><span class="line">    <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用推进过渡的色值动画：</p><img src="/images/caa/7.3.jpg" alt="" style="zoom:40%;" /><h2 id="四、呈现图层与模型图层"><a href="#四、呈现图层与模型图层" class="headerlink" title="四、呈现图层与模型图层"></a>四、呈现图层与模型图层</h2><h3 id="4-1-presentationLayer与modelLayer"><a href="#4-1-presentationLayer与modelLayer" class="headerlink" title="4.1 presentationLayer与modelLayer"></a>4.1 presentationLayer与modelLayer</h3><p><code>CALayer</code>的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？</p><p>当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。</p><p>当设置<code>CALayer</code>的属性，实际上是在定义当前事务结束之后图层如何显示的<em>模型</em>。Core Animation扮演了一个<em>控制器</em>的角色，并且负责根据图层行为和事务设置去不断更新<em>视图</em>的这些属性在屏幕上的状态。</p><p>我们讨论的就是一个典型的<em>微型MVC模式</em>。<code>CALayer</code>是一个连接用户界面（就是MVC中的<em>view</em>）虚构的类，但是在界面本身这个场景下，<code>CALayer</code>的行为更像是存储了视图如何显示和动画的数据模型。实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。</p><p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着<code>CALayer</code>除了“真实”值（就是你设置的值）之外，必须要知道当前<em>显示</em>在屏幕上的属性值的记录。</p><p>每个图层属性的显示值都被存储在一个叫做<em>呈现图层</em>的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以<strong>通过呈现图层的值来获取当前屏幕上真正显示出来的值</strong>。</p><p>如图，一个移动的图层是如何通过数据模型呈现的：</p><img src="/images/caa/7.4.jpg" alt="" style="zoom:35%;" /><p>我们在本书的第一章中提到除了图层树，另外还有<em>呈现树</em>。<strong>呈现树通过图层树中所有图层的呈现图层所形成</strong>。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p><p>你可能注意到有一个叫做<code>–modelLayer</code>的方法。在呈现图层上调用<code>–modelLayer</code>将会返回它正在呈现所依赖的<code>CALayer</code>。通常在一个图层上调用<code>-modelLayer</code>会返回<code>–self</code>（实际上我们已经创建的原始图层就是一种数据模型）。</p><h3 id="4-2-呈现图层的使用场景"><a href="#4-2-呈现图层的使用场景" class="headerlink" title="4.2 呈现图层的使用场景"></a>4.2 呈现图层的使用场景</h3><p>大多数情况下，你不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p><ul><li>如果你在实现一个基于定时器的动画（见第11章“基于定时器的动画”），而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li><li>如果你想让你做动画的图层响应用户输入，你可以使用<code>-hitTest:</code>方法（见第三章“图层几何学”）来判断指定图层是否被触摸，这时候对<em>呈现</em>图层而不是<em>模型</em>图层调用<code>-hitTest:</code>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li></ul><p>我们可以用一个简单的案例来证明后者（代码如下）。在这个例子中，点击屏幕上的任意位置将会让图层平移到那里。点击图层本身可以随机改变它的颜色。我们通过对呈现图层调用<code>-hitTest:</code>来判断是否被点击。</p><p>如果修改代码让<code>-hitTest:</code>直接作用于<em>colorLayer</em>而不是呈现图层，你会发现当图层移动的时候它并不能正确工作。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是<strong>用呈现图层来响应hit test</strong>的原因）。</p><p>使用<code>presentationLayer</code>图层来判断当前图层位置：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CALayer</span> *colorLayer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//create a red layer</span></span><br><span class="line">    <span class="keyword">self</span>.colorLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.position = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.bounds.size.width / <span class="number">2</span>, <span class="keyword">self</span>.view.bounds.size.height / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> redColor].CGColor;</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:<span class="keyword">self</span>.colorLayer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//get the touch point</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = [[touches anyObject] locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="comment">//check if we&#x27;ve tapped the moving layer</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.colorLayer.presentationLayer hitTest:point]) &#123;</span><br><span class="line">        <span class="comment">//randomize the layer background color</span></span><br><span class="line">        <span class="built_in">CGFloat</span> red = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="built_in">CGFloat</span> green = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="built_in">CGFloat</span> blue = arc4random() / (<span class="built_in">CGFloat</span>)INT_MAX;</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//otherwise (slowly) move the layer to new position</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        [<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">4.0</span>];</span><br><span class="line">        <span class="keyword">self</span>.colorLayer.position = point;</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="五、实践篇"><a href="#五、实践篇" class="headerlink" title="五、实践篇"></a>五、实践篇</h2><blockquote><p>原文 — <a href="https://objccn.io/issue-12-4/">View-Layer 协作</a></p></blockquote><h3 id="5-1-从-UIKit-中学习"><a href="#5-1-从-UIKit-中学习" class="headerlink" title="5.1 从 UIKit 中学习"></a>5.1 从 UIKit 中学习</h3><p>我很确定我们都会同意 UIView 动画是一组非常优秀的 API，它简洁明确。实际上，它使用了 Core Animation 来执行动画，这给了我们一个绝佳的机会来深入研究 UIKit 是如何使用 Core Animation 的。在这里甚至还有很多非常棒的实践和技巧可以让我们借鉴。:)</p><h4 id="5-1-1-addAnimation-forKey"><a href="#5-1-1-addAnimation-forKey" class="headerlink" title="5.1.1 addAnimation:forKey:"></a>5.1.1 addAnimation:forKey:</h4><p>当属性在动画 block 中改变时，view 将向 layer 返回一个基本动画，然后动画通过图层的 <code>addAnimation:forKey:</code> 方法被添加到 layer 中，就像显式地添加动画那样。再一次，别直接信我，让我们实践检验一下。</p><p>归功于 UIView 的 <code>+layerClass</code> 类方法，view 和 layer 之间的交互很容易被观测到。通过这个方法我们可以在为 view 创建 layer 时为其指定要使用的类。通过子类一个 UIView，以及用这个方法返回一个自定义的 layer 类，我们就可以重写 layer 子类中的 <code>addAnimation:forKey:</code> 并输出一些东西来验证它是否确实被调用。唯一要记住的是我们需要调用 super 方法，不然的话我们就把要观测的行为完全改变了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRInspectionLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRInspectionLayer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)addAnimation:(<span class="built_in">CAAnimation</span> *)anim forKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;adding animation: %@&quot;</span>, [anim debugDescription]);</span><br><span class="line">    [<span class="keyword">super</span> addAnimation:anim forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRInspectionView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRInspectionView</span></span></span><br><span class="line">+ (Class)layerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [DRInspectionLayer <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过输出动画的 debug 信息，我们不仅可以验证它确实如预期一样被调用了，还可以看到动画是如何组织构建的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CABasicAnimation</span>:<span class="number">0x8c73680</span>; </span><br><span class="line">    delegate = &lt;<span class="built_in">UIViewAnimationState</span>: <span class="number">0x8e91fa0</span>&gt;;</span><br><span class="line">    fillMode = both; </span><br><span class="line">    timingFunction = easeInEaseOut; </span><br><span class="line">    duration = <span class="number">0.3</span>; </span><br><span class="line">    fromValue = <span class="built_in">NSPoint</span>: &#123;<span class="number">5</span>, <span class="number">5</span>&#125;; </span><br><span class="line">    keyPath = position</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当动画刚被添加到 layer 时，属性的新值还没有被改变。在构建动画时，只有 <code>fromValue</code> (也就是当前值) 被显式地指定了。<a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CABasicAnimation_class/Introduction/Introduction.html">CABasicAnimation 的文档</a>向我们简单介绍了这么做对于动画的插值来说，意味着什么：</p><blockquote><p>fromValue、toValue、byValue三个对象定义了要插入的属性值。三者都是可选的，并且不应该超过两个非nil。</p><p>当只有 <code>fromValue</code> 不是 <code>nil</code> 时，在 <code>fromValue</code> 和属性当前显示层的值之间进行插值。</p><p>插值指利用某一个函数来计算出2个或更多的值之间的值，最简单的比如算术平均数(x+y)/2就是x,y的线性插值。在图形图像中例如旋转，放大，缩小等操作中，往往变化后图像中的点对应源图片中的点是不存在的，例如（2.1，3）这个点，那么在计算目标图像的在该点像素值的时候，就 需要进行插值运算来计算出该点的像素值。</p></blockquote><p>这也是我在处理显式动画时选择的做法，将一个属性改变为新的值，然后将动画对象添加到 layer 上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *fadeIn = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@&quot;opacity&quot;</span>];</span><br><span class="line">fadeIn.duration  = <span class="number">0.75</span>;</span><br><span class="line">fadeIn.fromValue = @<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">myLayer.opacity = <span class="number">1.0</span>; <span class="comment">// 更改 model 的值 ...</span></span><br><span class="line"><span class="comment">// ... 然后添加动画对象</span></span><br><span class="line">[myLayer addAnimation:fadeIn forKey:<span class="string">@&quot;fade in slowly&quot;</span>];</span><br></pre></td></tr></table></figure><p>这很简洁，你也不需要在动画被移除的时候做什么额外操作。如果动画是在一段延迟后才开始的话，你可以使用 backward 填充模式 (或者 ‘both’ 填充模式)，就像 UIKit 所创建的动画那样。</p><h4 id="5-1-2-UIViewAnimationState类"><a href="#5-1-2-UIViewAnimationState类" class="headerlink" title="5.1.2 UIViewAnimationState类"></a>5.1.2 UIViewAnimationState类</h4><p>可能你看见上面输出中的动画的 delegate 了，想知道这个 UIViewAnimationState 类是用来做什么的吗？</p><p>在此之前，先来看一下这个 CAAnimationDelegate 协议：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CAAnimation</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>, <span class="title">CAMediaTiming</span>, <span class="title">CAAction</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> &lt;<span class="built_in">CAAnimationDelegate</span>&gt; delegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CAAnimationDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">/* Called when the animation begins its active duration. */</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the animation either completes its active duration or is removed from the object</span></span><br><span class="line"><span class="comment"> * it is attached to (i.e. the layer). &#x27;flag&#x27; is true if the animation reached the end of its active </span></span><br><span class="line"><span class="comment"> * duration without being removed. */</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后我们可以来看看这个实现了上次协议的类做了什么，<a href="https://github.com/rpetrich/iphoneheaders/blob/master/UIKit/UIViewAnimationState.h">dump 出来的头文件</a>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewAnimationState</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationState</span>* _nextState;</span><br><span class="line">    <span class="built_in">NSString</span>* _animationID;</span><br><span class="line">    <span class="keyword">void</span>* _context;</span><br><span class="line">    <span class="keyword">id</span> _delegate;  <span class="comment">// </span></span><br><span class="line">    <span class="keyword">double</span> _duration;</span><br><span class="line">    <span class="keyword">double</span> _delay;</span><br><span class="line">    <span class="keyword">double</span> _frameInterval;</span><br><span class="line">    <span class="keyword">double</span> _start;</span><br><span class="line">    <span class="keyword">int</span> _curve;</span><br><span class="line">    <span class="keyword">float</span> _repeatCount;</span><br><span class="line">    <span class="keyword">int</span> _transition;</span><br><span class="line">    <span class="built_in">UIView</span>* _transitionView;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_3_2</span></span><br><span class="line">    <span class="keyword">int</span> _filter;</span><br><span class="line">    <span class="built_in">UIView</span>* _filterView;</span><br><span class="line">    <span class="keyword">float</span> _filterValue;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SEL _willStartSelector;</span><br><span class="line">    SEL _didEndSelector;</span><br><span class="line">    <span class="keyword">int</span> _didEndCount;</span><br><span class="line">    <span class="built_in">CGPoint</span> _position;</span><br><span class="line">    <span class="keyword">unsigned</span> _willStartSent : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _useCurrentLayerState : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _cacheTransition : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _autoreverses : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> _roundsToInteger : <span class="number">1</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &lt; __IPHONE_3_2</span></span><br><span class="line">    <span class="keyword">unsigned</span> _reserved : <span class="number">27</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)pushViewAnimationState:(<span class="keyword">id</span>)state context:(<span class="keyword">void</span>*)context;</span><br><span class="line">+ (<span class="keyword">void</span>)popAnimationState;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line">- (<span class="keyword">void</span>)setAnimationAttributes:(<span class="keyword">id</span>&lt;<span class="built_in">CAMediaTiming</span>&gt;)attributes;<span class="comment">// save the attributes of the animation state *into* the argument.</span></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="keyword">id</span>)animation;</span><br><span class="line">- (<span class="keyword">void</span>)sendDelegateAnimationDidStop:(<span class="keyword">id</span>)sendDelegateAnimation finished:(<span class="built_in">BOOL</span>)finished;</span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="keyword">id</span>)animation finished:(<span class="built_in">BOOL</span>)finished;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到，它主要用来维护动画的一些状态 (持续时间，延时，重复次数等等)。它还负责对一个栈做 push 和 pop，这是为了在多个动画 block 嵌套时能够获取正确的动画状态。这些都是些实现细节，除非你想要写一套自己的基于 block 的动画 API，否则可能你不会用到它们 (实际上这是一个很有趣的点子)。</p><p>然后真正<em>有意思</em>的是这个 delegate 实现了 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code>，并将信息传给了它自己的 delegate。</p><blockquote><p><strong>编者注</strong> 这里不太容易理解，加以说明：从上面的头文件中可以看出，作为 CAAnimation 的 delegate 的私有类 <code>UIViewAnimationState</code> 中还有一个 <code>_delegate</code> 成员，并且 <code>animationDidStart:</code> 和 <code>animationDidStop:finished:</code> 也是典型的 delegate 的实现方法。</p></blockquote><h4 id="5-1-3-UIViewAnimationBlockDelegate类"><a href="#5-1-3-UIViewAnimationBlockDelegate类" class="headerlink" title="5.1.3 UIViewAnimationBlockDelegate类"></a>5.1.3 UIViewAnimationBlockDelegate类</h4><p>通过打印这个 delegate 的 delegate，我们可以发现它也是一个私有类：UIViewAnimationBlockDelegate。同样进行 <a href="https://github.com/EthanArbuckle/IOS-7-Headers/blob/master/Frameworks/UIKit.framework/UIViewAnimationBlockDelegate.h">class dump 得到它的头文件</a>，这是一个很小的类，只负责一件事情：响应动画的 delegate 回调并且执行相应的 block。如果我们使用自己的 Core Animation 代码，并且选择 block 而不是 delegate 做回调的话，添加这个是很容易的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRAnimationBlockDelegate</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="keyword">void</span>(^start)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="keyword">void</span>(^stop)(<span class="built_in">BOOL</span>);</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">instancetype</span>)animationDelegateWithBeginning:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))beginning</span><br><span class="line">                                   completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DRAnimationBlockDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)animationDelegateWithBeginning:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))beginning</span><br><span class="line">                                    completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completion</span><br><span class="line">&#123;</span><br><span class="line">    DRAnimationBlockDelegate *result = [DRAnimationBlockDelegate new];</span><br><span class="line">    result.start = beginning;</span><br><span class="line">    result.stop  = completion;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.start) &#123;</span><br><span class="line">        <span class="keyword">self</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.start = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stop) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stop(flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.stop = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>虽然是我个人的喜好，但是我觉得像这样的基于 block 的回调风格可能会比实现一个 delegate 回调更适合你的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fadeIn.delegate = [DRAnimationBlockDelegate animationDelegateWithBeginning:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;beginning to fade in&quot;</span>);</span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;did fade %@&quot;</span>, finished ? <span class="string">@&quot;to the end&quot;</span> : <span class="string">@&quot;but was cancelled&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="5-2-自定义基于-block-的动画-APIs"><a href="#5-2-自定义基于-block-的动画-APIs" class="headerlink" title="5.2 自定义基于 block 的动画 APIs"></a>5.2 自定义基于 block 的动画 APIs</h3><p>一旦你知道了 <code>actionForKey:</code> 的机理之后，UIView 就远没有它一开始看起来那么神秘了。实际上我们完全可以按照我们的需求量身定制地写出一套自己的基于 block 的动画 APIs。我所设计的动画将通过在 block 中用一个很激进的时间曲线来做动画，以吸引用户对该 view 的注意，之后做一个缓慢的动画回到原始状态。你可以把它看作一种类似 pop (请不要和 Facebook 的 Pop 框架弄混了)的行为。</p><h4 id="5-2-1-效果展示"><a href="#5-2-1-效果展示" class="headerlink" title="5.2.1 效果展示"></a>5.2.1 效果展示</h4><p>与一般使用 <code>UIViewAnimationOptionAutoreverse</code> 的动画 block 不同，因为动画设计和概念上的需要，我自己实现了将 model 值改变回原始值的过程。自定义的动画 API 的使用方法就像这样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> DR_popAnimationWithDuration:<span class="number">0.7</span></span><br><span class="line">                         animations:^&#123;</span><br><span class="line">                                myView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(M_PI_2);</span><br><span class="line">                              &#125;];</span><br></pre></td></tr></table></figure><p>当我们完成后，效果是这个样子的 (对四个不同的 view 为位置，尺寸，颜色和旋转进行动画)：</p><p>The custom block animation API, used to animate the position, size, color, and rotation of four different views：</p><img src="/images/caa/custom-block-animations.gif" alt="custom-block-animations" style="zoom:60%;" /><h4 id="5-2-2-代码实现"><a href="#5-2-2-代码实现" class="headerlink" title="5.2.2 代码实现"></a>5.2.2 代码实现</h4><h5 id="1-Method-Swizzle"><a href="#1-Method-Swizzle" class="headerlink" title="1. Method Swizzle"></a>1. Method Swizzle</h5><p>要开始实现它，我们首先要做的是当一个 layer 属性变化时获取 delegate 的回调。因为我们无法事先预测 layer 要改变什么，所以我选择在一个 UIView 的 category 中 swizzle <code>actionForLayer:forKey:</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">DR_CustomBlockAnimations</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;        </span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(actionForLayer:forKey:);</span><br><span class="line">    SEL extendedSelector = <span class="keyword">@selector</span>(DR_actionForLayer:forKey:);</span><br><span class="line"></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, originalSelector);</span><br><span class="line">    Method extendedMethod = class_getInstanceMethod(<span class="keyword">self</span>, extendedSelector);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(originalMethod, <span class="string">@&quot;original method should exist&quot;</span>);</span><br><span class="line">    <span class="built_in">NSAssert</span>(extendedMethod, <span class="string">@&quot;exchanged method should exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(class_addMethod(<span class="keyword">self</span>, originalSelector, method_getImplementation(extendedMethod), method_getTypeEncoding(extendedMethod))) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">self</span>, extendedSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, extendedMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-上下文变量控制"><a href="#2-上下文变量控制" class="headerlink" title="2. 上下文变量控制"></a>2. 上下文变量控制</h5><p>为了保证我们不破坏其他依赖于 <code>actionForLayer:forKey:</code> 回调的代码，我们使用一个静态变量来判断现在是不是处于我们自己定义的上下文中。对于这个例子来说一个简单的 <code>BOOL</code> 其实就够了，但是如果我们之后要写更多内容的话，上下文的话就要灵活得多了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *DR_currentAnimationContext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *DR_popAnimationContext     = &amp;DR_popAnimationContext;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)DR_actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DR_currentAnimationContext == DR_popAnimationContext) &#123;</span><br><span class="line">        <span class="comment">// 这里写我们自定义的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始方法</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> DR_actionForLayer:layer forKey:event]; <span class="comment">// 没错，你没看错。因为它们已经被交换了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的实现中，我们要确保在执行动画 block 之前设置动画的上下文，并且在执行后恢复上下文：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)DR_popAnimationWithDuration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                         animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">&#123;</span><br><span class="line">    DR_currentAnimationContext = DR_popAnimationContext;</span><br><span class="line">    <span class="comment">// 执行动画 (它将触发交换后的 delegate 方法)</span></span><br><span class="line">    animations();</span><br><span class="line">    <span class="comment">/* 一会儿再添加 */</span></span><br><span class="line">    DR_currentAnimationContext = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-定义动画状态存储类"><a href="#3-定义动画状态存储类" class="headerlink" title="3. 定义动画状态存储类"></a>3. 定义动画状态存储类</h5><p>如果我们想要做的不过是添加一个从旧的值向新的值过度的动画的话，我们可以直接在 delegate 的回调中来做。然而因为我们想要更精确地控制动画，我们需要用一个帧动画来实现。帧动画需要所有的值都是已知的，而对我们的情况来说，新的值还没有被设定，因此我们也就无从知晓。</p><p>有意思的是，iOS 添加的一个基于 block 的动画 API 也遇到了同样的问题。使用和上面一样的观察手段，我们就能知道它是如何绕开这个麻烦的。对于每个关键帧，在属性变化时，view 返回 <code>nil</code>，但是却存储下需要的状态。这样就能在所有关键帧 block 执行后创建一个 <code>CAKeyframeAnimation</code> 对象。</p><p>受到这种方法的启发，我们可以创建一个小的类来存储我们创建动画时所需要的信息：什么 layer 被更改了，什么 key path 的值被改变了，以及原来的值是什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DRSavedPopAnimationState</span> : <span class="title">NSObject</span> @<span class="title">property</span> (<span class="title">strong</span>) <span class="title">CALayer</span>  *<span class="title">layer</span>; @<span class="title">property</span> (<span class="title">copy</span>)   <span class="title">NSString</span> *<span class="title">keyPath</span>; @<span class="title">property</span> (<span class="title">strong</span>) <span class="title">id</span>        <span class="title">oldValue</span>; + (<span class="title">instancetype</span>)<span class="title">savedStateWithLayer</span>:(<span class="title">CALayer</span> *)<span class="title">layer</span>                             <span class="title">keyPath</span>:(<span class="title">NSString</span> *)<span class="title">keyPath</span>; @<span class="title">end</span> @<span class="title">implementation</span> <span class="title">DRSavedPopAnimationState</span> + (<span class="title">instancetype</span>)<span class="title">savedStateWithLayer</span>:(<span class="title">CALayer</span> *)<span class="title">layer</span>                             <span class="title">keyPath</span>:(<span class="title">NSString</span> *)<span class="title">keyPath</span> </span>&#123;     DRSavedPopAnimationState *savedState = [DRSavedPopAnimationState new];     savedState.layer    = layer;     savedState.keyPath  = keyPath;     savedState.oldValue = [layer valueForKeyPath:keyPath];     <span class="keyword">return</span> savedState; &#125; <span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>接下来，在我们的交换后的 delegate 回调中，我们简单地将被变更的属性的状态存入一个静态可变数组中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)DR_actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event&#123;    <span class="keyword">if</span> (DR_currentAnimationContext == DR_popAnimationContext) &#123;        <span class="comment">// 这里写我们自定义的代码...        [[UIView DR_savedPopAnimationStates] addObject:[DRSavedPopAnimationState savedStateWithLayer:layer                                                                                 keyPath:event]];        // 没有隐式的动画 (稍后添加)        return (id&lt;CAAction&gt;)[NSNull null];    &#125;    // 调用原始方法    return [self DR_actionForLayer:layer forKey:event]; // 没错，你没看错。因为它们已经被交换了&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-创建关键帧动画"><a href="#4-创建关键帧动画" class="headerlink" title="4. 创建关键帧动画"></a>4. 创建关键帧动画</h5><p>在动画 block 执行完毕后，所有的属性都被变更了，它们的状态也被保存了。现在，创建关键帧动画：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)DR_popAnimationWithDuration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                         animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">&#123;</span><br><span class="line">    DR_currentAnimationContext = DR_popAnimationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行动画 (它将触发交换后的 delegate 方法)</span></span><br><span class="line">    animations();</span><br><span class="line"></span><br><span class="line">    [[<span class="keyword">self</span> DR_savedPopAnimationStates] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        DRSavedPopAnimationState *savedState   = (DRSavedPopAnimationState *)obj;</span><br><span class="line">        <span class="built_in">CALayer</span> *layer    = savedState.layer;</span><br><span class="line">        <span class="built_in">NSString</span> *keyPath = savedState.keyPath;</span><br><span class="line">        <span class="keyword">id</span> oldValue       = savedState.oldValue;</span><br><span class="line">        <span class="keyword">id</span> newValue       = [layer valueForKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CAKeyframeAnimation</span> *anim = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGFloat</span> easing = <span class="number">0.2</span>;</span><br><span class="line">        <span class="built_in">CAMediaTimingFunction</span> *easeIn  = [<span class="built_in">CAMediaTimingFunction</span> functionWithControlPoints:<span class="number">1.0</span> :<span class="number">0.0</span> :(<span class="number">1.0</span>-easing) :<span class="number">1.0</span>];</span><br><span class="line">        <span class="built_in">CAMediaTimingFunction</span> *easeOut = [<span class="built_in">CAMediaTimingFunction</span> functionWithControlPoints:easing :<span class="number">0.0</span> :<span class="number">0.0</span> :<span class="number">1.0</span>];</span><br><span class="line"></span><br><span class="line">        anim.duration = duration;</span><br><span class="line">        anim.keyTimes = @[@<span class="number">0</span>, @(<span class="number">0.35</span>), @<span class="number">1</span>];</span><br><span class="line">        anim.values = @[oldValue, newValue, oldValue];</span><br><span class="line">        anim.timingFunctions = @[easeIn, easeOut];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不带动画地返回原来的值</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">        [layer setValue:oldValue forKeyPath:keyPath];</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 &quot;pop&quot; 动画</span></span><br><span class="line">        [layer addAnimation:anim forKey:keyPath];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫除工作 (移除所有存储的状态)</span></span><br><span class="line">    [[<span class="keyword">self</span> DR_savedPopAnimationStates] removeAllObjects];</span><br><span class="line"></span><br><span class="line">    DR_currentAnimationContext = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意老的 model 值被设到了 layer 上，所以在当动画结束和移除后，model 的值和 presentation 的值是相符合的。</p><p>创建像这样的你自己的 API 不会对每种情况都很适合，但是如果你需要在你的应用中的很多地方都做同样的动画的话，这可以帮助你写出整洁的代码，并减少重复。就算你之后从来不会使用这种方法，实际做一遍也能帮助你搞懂 UIView block 动画的 APIs，特别是你已经在 Core Animation 的舒适区的时候，这非常有助于你的提高。</p><h3 id="5-3-其他的动画灵感"><a href="#5-3-其他的动画灵感" class="headerlink" title="5.3 其他的动画灵感"></a>5.3 其他的动画灵感</h3><p>UIImageView 动画是一个完全不同的更高层次的动画 API 的实现方式，我会把它留给你来探索。表面上，它只不过是重新组装了一个传统的动画 API。你所要做的事情就是指定一个图片数组和一段时间，然后告诉 image view 开始动画。在抽象背后，其实是一个添加在 image view 的 layer 上的 contents 属性的离散的关键帧动画：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">CAKeyframeAnimation</span>:<span class="number">0x8e5b020</span>; </span><br><span class="line">    removedOnCompletion = <span class="number">0</span>; </span><br><span class="line">    delegate = &lt;_UIImageViewExtendedStorage: <span class="number">0x8e49230</span>&gt;; </span><br><span class="line">    duration = <span class="number">2.5</span>; </span><br><span class="line">    repeatCount = <span class="number">2.14748e+09</span>; </span><br><span class="line">    calculationMode = discrete; </span><br><span class="line">    values = (</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d6ce80&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d6d2d0&gt;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&lt;CGImage 0x8d5cd30&gt;&quot;</span></span><br><span class="line">    ); </span><br><span class="line">    keyPath = contents</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>动画 APIs 可以以很多不同形式出现，而对于你自己写的动画 API 来说，也是这样的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章讨论了：</p><ul><li>隐式动画，还有Core Animation对指定属性选择合适的动画行为的机制。</li><li>UIKit是如何充分利用Core Animation的隐式动画机制来强化它的显式系统，</li><li>以及动画是如何被默认禁用并且当需要的时候启用的。</li><li>最后，你了解了呈现和模型图层，以及Core Animation是如何通过它们来判断出图层当前位置以及将要到达的位置。</li></ul><p>下一章将研究Core Animation提供的<em>显式</em>动画类型，既可以直接对图层属性做动画，也可以覆盖默认的图层行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques/blob/master/7-%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Core Animation(一) - UIView与CALayer</title>
    <link href="https://tenloy.github.io/2021/09/07/core-animation01.html"/>
    <id>https://tenloy.github.io/2021/09/07/core-animation01.html</id>
    <published>2021-09-07T14:50:38.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<p>Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做<em>Layer Kit</em>这么一个不怎么和动画有关的名字演变而来。</p><p>Core Animation是一个<em>复合引擎</em>，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的<em>图层</em>，存储在一个叫做<strong>图层树</strong>的体系之中。于是这个树形成了<strong>UIKit</strong>以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p><h2 id="一、View与Layer"><a href="#一、View与Layer" class="headerlink" title="一、View与Layer"></a>一、View与Layer</h2><h3 id="1-1-CALayer图层"><a href="#1-1-CALayer图层" class="headerlink" title="1.1 CALayer图层"></a>1.1 CALayer图层</h3><blockquote><p>CALayer： 管理基于图像的内容，并允许你对该内容执行动画</p></blockquote><p>在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。layer给view提供了基础设施，使得绘制内容和呈现更高效动画更容易、更低耗；layer不参与view的事件处理、不参与响应链。</p><img src="/images/caa/7.5.png" alt="" style="zoom:100%;" /><p>UIKit 中的每个视图都有自己的 CALayer 。 这个图层通常有一个缓存区/后备存储(Backing Store)，它是像素位图。这个后备存储实际上是渲染到显示器上的。</p><blockquote><p>术语“后备存储”通常用于图形用户界面的上下文中。 是一块记忆，其中包含窗户的图像。 如果窗口被覆盖（甚至部分）然后被覆盖，则后备存储用于重绘。</p></blockquote><blockquote><p>测试：分别修改、打印MyView与.layer的backgroundColor，可以看到这两者是同步变化的。<strong>所以其实UIView的背景色就是CALayer的背景色。</strong></p></blockquote><p>为什么iOS要基于<code>UIView</code>和<code>CALayer</code>提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。</p><ul><li><p>在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和<code>UIView</code>，但是Mac OS有AppKit和<code>NSView</code>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p></li><li><p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p></li></ul><h3 id="1-2-四个层级关系"><a href="#1-2-四个层级关系" class="headerlink" title="1.2 四个层级关系"></a>1.2 四个层级关系</h3><p>在整个Core Animation机制中，存在4个层级关系：</p><h4 id="1-2-1-视图层级"><a href="#1-2-1-视图层级" class="headerlink" title="1.2.1 视图层级"></a>1.2.1 视图层级</h4><p>视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。</p><h4 id="1-2-2-图层树"><a href="#1-2-2-图层树" class="headerlink" title="1.2.2 图层树"></a>1.2.2 图层树</h4><p>每一个<code>UIView</code>都有一个<code>CALayer</code>实例的图层属性，也就是所谓的<em>backing layer</em>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p><h4 id="1-2-3-呈现树"><a href="#1-2-3-呈现树" class="headerlink" title="1.2.3 呈现树"></a>1.2.3 呈现树</h4><p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着<code>CALayer</code>除了“真实”值（就是你设置的值）之外，必须要知道当前<em>显示</em>在屏幕上的属性值的记录。</p><p>每个图层属性的显示值都被存储在一个叫做<em>呈现图层</em>的独立图层当中，他可以通过<code>-presentationLayer</code>方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值。</p><p>呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被<em>提交</em>（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p><h4 id="1-2-4-渲染树"><a href="#1-2-4-渲染树" class="headerlink" title="1.2.4 渲染树"></a>1.2.4 渲染树</h4><p>详见<a href="https://tenloy.github.io/2021/09/11/core-animation03.html">下下篇 iOS渲染流程探究</a></p><p>图层树的改动会在Application这一层以事务的形式完成打包提交，一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做<em>渲染树</em>的图层树。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p><ul><li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li><li>在屏幕上渲染可见的三角形</li></ul><h2 id="二、View的绘制"><a href="#二、View的绘制" class="headerlink" title="二、View的绘制"></a>二、View的绘制</h2><blockquote><p>苹果文档 —— <a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html">The View Drawing Cycle</a></p></blockquote><h3 id="2-1-绘制机制"><a href="#2-1-绘制机制" class="headerlink" title="2.1 绘制机制"></a>2.1 绘制机制</h3><p>UIView 类使用按需绘制模型来呈现内容。</p><ul><li>当一个视图第一次出现在屏幕上时，系统要求它绘制它的内容。系统捕获此内容的快照并将该快照用作视图的视觉表示。</li><li>如果您从不更改视图的内容，则视图的绘制代码可能永远不会被再次调用。大多数涉及视图的操作都会重复使用快照图像。</li><li>如果您确实更改了内容，则会通知系统视图已更改。然后视图重复绘制视图和捕获新结果的快照的过程。</li></ul><p>当视图的内容发生更改时，不要直接重绘这些更改。可以使用 setNeedsDisplay 或 setNeedsDisplayInRect: 方法使视图无效。这些方法告诉系统视图的内容发生了变化，需要在下一次重绘。</p><h3 id="2-2-绘制周期"><a href="#2-2-绘制周期" class="headerlink" title="2.2 绘制周期"></a>2.2 绘制周期</h3><p><strong>系统会等到当前 run loop 执行结束(一个loop也就是一个绘制周期)，才启动任何绘图操作</strong>。这种延迟使您有机会一次性使多个视图无效、在层次结构中添加或删除视图、隐藏视图、调整视图大小和重新定位视图。然后，所做的所有更改都会同时反映出来。</p><h3 id="2-3-Custom-Drawing"><a href="#2-3-Custom-Drawing" class="headerlink" title="2.3 Custom Drawing"></a>2.3 Custom Drawing</h3><blockquote><p>寄宿图：CALayer类除了简单的设置背景颜色外，还能够包含一张图片。又称CALayer的寄宿图（即图层中包含的图）。</p></blockquote><p>当需要渲染视图的内容时，实际的绘制过程取决于视图及其配置。系统视图通常实现私有绘图方法来呈现其内容。这些相同的系统视图经常公开接口，您可以使用这些接口来配置视图的实际外观。</p><ul><li>直接设置layer的contents属性</li><li>对于自定义 UIView 子类，可以重写 drawRect: 方法并使用该方法绘制视图的内容。（最常用）</li></ul><h4 id="2-3-1-contents属性"><a href="#2-3-1-contents属性" class="headerlink" title="2.3.1 contents属性"></a>2.3.1 contents属性</h4><p>CALayer 有一个属性叫做<code>contents</code>，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给<code>contents</code>属性赋任何值，你的app都能够编译通过。但是，在实践中，如果你给<code>contents</code>赋的不是CGImage，那么你得到的图层将是空白的。</p><p><code>contents</code>这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p><p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的<code>contents</code>，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p><p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），它们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.contents &#x3D; (__bridge id)image.CGImage;</span><br></pre></td></tr></table></figure><p>如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p><h4 id="2-3-2-drawRect"><a href="#2-3-2-drawRect" class="headerlink" title="2.3.2 drawRect"></a>2.3.2 drawRect</h4><p><code>-drawRect:</code> 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到<code>-drawRect:</code> 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 <code>contentsScale</code>的值。</p><p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：<strong>如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法</strong>。</p><p>当视图在屏幕上出现的时候 <code>-drawRect:</code>方法就会被自动调用。<code>-drawRect:</code>方法里面的代码利用Core Graphics去绘制一个寄宿图，然后<strong>内容就会被缓存起来直到它需要被更新</strong>（比如手动调用了<code>-setNeedsDisplay</code>方法。当影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如<code>bounds</code>属性）。虽然<code>-drawRect:</code>方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p><p>CALayer有一个可选的<code>delegate</code>属性，实现了<code>CALayerDelegate</code>协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（<code>delegate</code>属性被声明为id类型，所有的代理方法都是可选的）。</p><p>当需要被重绘时，CALayer会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br></pre></td></tr></table></figure><p>趁着这个机会，如果代理想直接设置<code>contents</code>属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现<code>-displayLayer:</code>方法，CALayer就会转而尝试调用下面这个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由<code>bounds</code>和<code>contentsScale</code>决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。</p><h2 id="三、View的重绘"><a href="#三、View的重绘" class="headerlink" title="三、View的重绘"></a>三、View的重绘</h2><h3 id="3-1-重绘流程图"><a href="#3-1-重绘流程图" class="headerlink" title="3.1 重绘流程图"></a>3.1 重绘流程图</h3><p>写在前面：注意：<strong>更改视图的几何形状不会自动导致系统重绘视图的内容</strong>。视图的内容模式(contentMode)属性决定了如何解释视图几何的变化。大多数content modes会在视图边界内拉伸或重新定位现有快照，并且不会创建新快照。有关内容模式如何影响视图的绘制周期的更多信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html">Content Modes</a>。</p><p>先来看一下<strong>更新-绘制流程图</strong>，然后梳理一下其中的重要方法</p><img src="/images/caa/viewredraw.png" alt="viewredraw" style="zoom:80%;" /><ul><li><p>当我们调用 <code>[UIView setNeedsDisplay]</code> 这个方法时，其实并没有立即进行绘制工作，系统会立刻调用CALayer的同名方法，并且<strong>会在当前layer上打上一个标记，然后会在当前runloop将要结束的时候（下一个绘制周期）</strong>调用 <code>[CALayer display]</code> 这个方法，然后进入我们视图的真正绘制过程。</p></li><li><p>在 <code>[CALayer display]</code> 这个方法的内部实现中会判断这个 layer 的 delegate 是否响应 displayLayer: 这个方法，如果响应这个方法，就会进入到系统绘制流程中；如果不响应这个方法，那么就会为我们提供<strong>异步绘制</strong>的入口。</p></li><li><p>在异步绘制中，会先判断代理是否有实现协议的 <code>drawLayer:inContext</code> 方法，如果有实现，就会创建一个空的寄宿图和 Core Craphics 的绘制上下文，为绘制寄宿图做准备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGBitmapContextCreate(...);</span><br><span class="line"><span class="comment">// Core Craphics API...</span></span><br><span class="line">CGBitmapContextCreateImage(...);</span><br></pre></td></tr></table></figure><p>然后会在一个合适的时候调用一个我们非常熟悉的方法<code>[UIView drawRect:]</code> 来获取寄宿图内容。<code>[UIView drawRect:]</code> 这个方法默认是什么都不做，系统给我们开这个口子是为了让我们可以再做一些其他的绘制工作。</p></li><li><p>无论是哪个分支，<strong>最终都会由CALayer上传对应的backing store(寄宿图，也即位图bitmap)给GPU</strong>，然后就结束了本次绘制流程。</p></li></ul><h3 id="3-2-内容重绘-—-Layer方法"><a href="#3-2-内容重绘-—-Layer方法" class="headerlink" title="3.2 内容重绘 — Layer方法"></a>3.2 内容重绘 — Layer方法</h3><h4 id="3-2-1-display"><a href="#3-2-1-display" class="headerlink" title="3.2.1 -display"></a>3.2.1 -display</h4><p>重新加载该图层的内容。调用 -drawInContext: 方法，然后更新图层的’contents’属性。</p><p>通常这不会被直接调用。</p><h4 id="3-2-2-setNeedsDisplay"><a href="#3-2-2-setNeedsDisplay" class="headerlink" title="3.2.2 -setNeedsDisplay"></a>3.2.2 -setNeedsDisplay</h4><p>将图层的内容标记为需要更新。</p><p>调用此方法会导致图层重新缓存其内容。 这导致图层可能调用其委托的 displayLayer: 或 drawLayer:inContext: 方法。 删除图层 contents 属性中的现有内容，为新内容让路。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘范围是整个边界矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay;</span><br><span class="line"><span class="comment">// 重绘范围是参数指定的矩形(应在接收器的坐标系中指定, 且只对该图层有效)</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(<span class="built_in">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-drawInContext"><a href="#3-2-3-drawInContext" class="headerlink" title="3.2.3 -drawInContext:"></a>3.2.3 -drawInContext:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用指定的图形上下文绘制图层的内容。</span></span><br><span class="line"><span class="comment"> * @param ctx 在其中绘制内容的图形上下文。可以剪裁上下文以保护有效的层内容。</span></span><br><span class="line"><span class="comment"> * 希望找到要绘制的实际区域的子类可以调用 CGContextGetClipBoundingBox。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br></pre></td></tr></table></figure><p>此方法的默认实现本身不进行任何绘图。 如果图层的委托实现了 drawLayer:inContext: 方法，则调用该方法来进行实际绘制。</p><p>子类可以覆盖此方法并使用它来绘制图层的内容。 绘制时，所有坐标都应在逻辑坐标空间中以点为单位指定。</p><h4 id="3-2-4-CALayerDelegate"><a href="#3-2-4-CALayerDelegate" class="headerlink" title="3.2.4 CALayerDelegate"></a>3.2.4 CALayerDelegate</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-display方法的默认实现调用，在这种情况下，它应该实现整个 display 过程(通常通过设置&#x27; contents&#x27;属性)。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-drawInContext的默认实现调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义了，则由layer的-display方法的默认实现调用。</span></span><br><span class="line"><span class="comment"> 允许delegate在-drawLayer:InContext之前配置任何影响内容的图层状态，如&#x27;contentsFormat&#x27;和&#x27; opaque&#x27;。如果委托实现了-displayLayer，它将不会被调用。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)layerWillDraw:(<span class="built_in">CALayer</span> *)layer</span><br><span class="line">  API_AVAILABLE(macos(<span class="number">10.12</span>), ios(<span class="number">10.0</span>), watchos(<span class="number">3.0</span>), tvos(<span class="number">10.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果实现了，则由layer的-layoutSublayers方法的默认实现调用(在检查layoutManager之前)。</span></span><br><span class="line"><span class="comment">   注意，如果调用委托方法，布局管理器将被忽略。*/</span></span><br><span class="line">- (<span class="keyword">void</span>)layoutSublayersOfLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 隐式动画中用到的 */</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">CAAction</span>&gt;)actionForLayer:(<span class="built_in">CALayer</span> *)layer forKey:(<span class="built_in">NSString</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-3-内容重绘-—-View方法"><a href="#3-3-内容重绘-—-View方法" class="headerlink" title="3.3 内容重绘 — View方法"></a>3.3 内容重绘 — View方法</h3><h4 id="3-3-1-setNeedsDisplay"><a href="#3-3-1-setNeedsDisplay" class="headerlink" title="3.3.1 -setNeedsDisplay"></a>3.3.1 -setNeedsDisplay</h4><p>通知系统你的视图内容需要重绘。此方法将指定的矩形添加到视图的当前无效矩形列表中并立即返回。直到下一个绘制周期才会真正重绘视图，此时所有无效的视图都会更新。</p><p>你应该仅在视图的内容或外观发生更改时，使用此方法请求重绘视图。<strong>如果只是更改视图的几何形状，通常不会重新绘制视图，它的现有内容根据视图的 contentMode 属性中的值进行调整。</strong></p><p> 注意：如果您的视图由 CAEAGLLayer 对象支持，则此方法无效。它仅适用于使用原生绘图技术（例如 UIKit 和 Core Graphics）来呈现其内容的视图。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘范围是整个边界矩形</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplay;</span><br><span class="line"><span class="comment">// 重绘范围是参数指定的矩形(应在接收器的坐标系中指定, 且只对该图层有效)</span></span><br><span class="line">- (<span class="keyword">void</span>)setNeedsDisplayInRect:(<span class="built_in">CGRect</span>)rect;</span><br></pre></td></tr></table></figure><h3 id="3-4-布局重新计算-—-Layer方法"><a href="#3-4-布局重新计算-—-Layer方法" class="headerlink" title="3.4 布局重新计算 — Layer方法"></a>3.4 布局重新计算 — Layer方法</h3><h4 id="3-4-1-layoutSublayers"><a href="#3-4-1-layoutSublayers" class="headerlink" title="3.4.1 -layoutSublayers"></a>3.4.1 -layoutSublayers</h4><p>告诉图层更新其布局 </p><p>子类可以覆盖此方法并使用它来实现自己的布局算法。您的实现必须设置每个子层的frame。</p><p>此方法的默认实现：</p><ul><li><p>如果 layer 有delegate对象，且实现了 layoutSublayersOfLayer: 方法，调用它。</p></li><li><p>否则，该方法调用 layoutManager 属性对象(Mac OS API)的 layoutSublayersOfLayer: 方法。 </p></li></ul><h4 id="3-4-2-setNeedsLayout-做标记"><a href="#3-4-2-setNeedsLayout-做标记" class="headerlink" title="3.4.2 -setNeedsLayout(做标记)"></a>3.4.2 -setNeedsLayout(做标记)</h4><p>使图层的布局无效并将其标记为需要更新。会在下一个更新周期中触发布局更新。系统调用任何需要布局更新的图层的 layoutSublayers 方法。</p><p>当图层的边界发生变化或添加或删除子图层时，系统通常会自动调用此方法。   </p><h4 id="3-4-3-layoutIfNeeded-立即"><a href="#3-4-3-layoutIfNeeded-立即" class="headerlink" title="3.4.3 -layoutIfNeeded(立即)"></a>3.4.3 -layoutIfNeeded(立即)</h4><p> 如果需要，立即重新计算图层的布局。</p><p> 收到此消息后，将遍历该图层的父图层，直到找到不需要布局的祖先图层。然后在该祖先下的整个层树上执行布局。</p><h3 id="3-5-布局重新计算-—-View方法"><a href="#3-5-布局重新计算-—-View方法" class="headerlink" title="3.5 布局重新计算 — View方法"></a>3.5 布局重新计算 — View方法</h3><h4 id="3-5-1-layoutSubviews"><a href="#3-5-1-layoutSubviews" class="headerlink" title="3.5.1 -layoutSubviews"></a>3.5.1 -layoutSubviews</h4><p>默认实现使用您设置的任何约束来确定每一个子视图的大小和位置。</p><p>子类可以根据需要覆盖此方法以对其子视图执行更精确的布局。 仅当子视图的自动调整大小和基于约束的行为不提供您想要的行为时，您才应该覆盖此方法。 您可以使用您的实现直接设置子视图的框架矩形。</p><p>您<strong>不应直接调用</strong>此方法。 如果要强制更新布局，请在下一次绘图更新之前调用 setNeedsLayout 方法。 如果您想立即更新视图的布局，请调用 layoutIfNeeded 方法。</p><h4 id="3-5-2-setNeedsLayout-做标记"><a href="#3-5-2-setNeedsLayout-做标记" class="headerlink" title="3.5.2 -setNeedsLayout(做标记)"></a>3.5.2 -setNeedsLayout(做标记)</h4><p>使当前布局无效并在下一个更新周期触发布局更新。</p><p>当您想要调整视图子视图的布局时，请<strong>在应用程序的主线程上调用此方法</strong>。此方法记录请求并立即返回。</p><p>由于此方法不会强制立即更新，而是等待下一个更新周期，因此您可以使用它在更新任何视图之前使多个视图的布局无效。此行为<strong>允许您将所有布局更新合并到一个更新周期，这通常对性能更好</strong>。</p><h4 id="3-5-3-layoutIfNeeded-立即"><a href="#3-5-3-layoutIfNeeded-立即" class="headerlink" title="3.5.3 -layoutIfNeeded(立即)"></a>3.5.3 -layoutIfNeeded(立即)</h4><p>如果有待办的(pending)布局更新，则立即布局子视图。</p><p>使用此方法强制视图立即更新其布局。使用“自动布局”时，布局引擎会根据需要更新视图的位置，以满足约束的更改。用接收此消息的视图作为根视图开始布局视图子树。</p><p>如果没有待处理的布局更新，则此方法退出而不修改布局或调用任何与布局相关的回调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做&lt;em&gt;Layer Kit&lt;/em&gt;这么一个不怎么和动画有关的名字演变而来。&lt;/p&gt;
&lt;p&gt;Core Animation是一个&lt;em&gt;复合引擎&lt;/em&gt;，它的职责就是尽</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] AFN框架实现解析</title>
    <link href="https://tenloy.github.io/2021/09/05/AFN-Analyse.html"/>
    <id>https://tenloy.github.io/2021/09/05/AFN-Analyse.html</id>
    <published>2021-09-05T18:53:12.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">原文链接</a>，有一些细节修改</p></blockquote><img src="/images/AFN/AFN-01.png" alt="img" style="zoom:70%;" /><ul><li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li><li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li><li>本文将从源码的角度去分析AF的实际作用。 <strong>或许看完这篇文章，你心里会有一个答案。</strong></li></ul><h1 id="一、框架结构"><a href="#一、框架结构" class="headerlink" title="一、框架结构"></a>一、框架结构</h1><p>先从最新的AF3.x讲起吧：</p><p>首先，我们就一起分析一下该框架的组成。 将AF下载导入工程后，下面是AF代码结构图，相对于2.x变得非常简单了：</p><img src="/images/AFN/AFN-02.jpg" alt="img" style="zoom:60%;" /><p>除去Support Files，可以看到AF分为如下5个功能模块：</p><ul><li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li><li>网络状态监听模块(Reachability)</li><li>网络通信安全策略模块(Security)</li><li>网络通信信息序列化/反序列化模块(Serialization)</li><li>对于iOS UIKit库的扩展(UIKit)</li></ul><p>这五个模块所对应的类的结构关系图（AF架构图）如下所示：</p><ul><li><strong>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</strong></li><li>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></li></ul><img src="/images/AFN/AFN-03.jpg" alt="img" style="zoom:55%;" /><h1 id="二、AFURL-amp-HTTPSessionManager"><a href="#二、AFURL-amp-HTTPSessionManager" class="headerlink" title="二、AFURL&amp;HTTPSessionManager"></a>二、AFURL&amp;HTTPSessionManager</h1><h2 id="2-1-AFHTTPSessionManager的初始化"><a href="#2-1-AFHTTPSessionManager的初始化" class="headerlink" title="2.1 AFHTTPSessionManager的初始化"></a>2.1 AFHTTPSessionManager的初始化</h2><h3 id="2-1-1-初始化源码"><a href="#2-1-1-初始化源码" class="headerlink" title="2.1.1 初始化源码"></a>2.1.1 初始化源码</h3><p>首先我们简单的写个get请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:<span class="string">@&quot;http://localhost&quot;</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="1-AFHTTPSessionManager"><a href="#1-AFHTTPSessionManager" class="headerlink" title="1. AFHTTPSessionManager"></a>1. AFHTTPSessionManager</h4><p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:url sessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span> sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化都调用到这个方法中来了</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li><li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li></ul><h4 id="2-AFURLSessionManager"><a href="#2-AFURLSessionManager" class="headerlink" title="2. AFURLSessionManager"></a>2. AFURLSessionManager</h4><p>直接来到父类AFURLSessionManager的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">      configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">  <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">  <span class="comment">// 重点：这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。至于这里为什么要这么做，我们先留一个坑，等我们讲完AF2.x之后再来分析这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span></span><br><span class="line">  <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//各种响应转码</span></span><br><span class="line">  <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认安全策略</span></span><br><span class="line">  <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">  <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点2：这个字典是用来让每一个请求task和我们自定义的AF代理来建立映射用的。</span></span><br><span class="line">    <span class="comment">// 在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理</span></span><br><span class="line">    <span class="comment">// 其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span></span><br><span class="line">  <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点3：置空task关联的代理。</span></span><br><span class="line">    <span class="comment">// 作用：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。</span></span><br><span class="line">    <span class="comment">// 但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：https://github.com/AFNetworking/AFNetworking/issues/3499。原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</span></span><br><span class="line">  [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;        </span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-NSURLSession概述"><a href="#2-1-2-NSURLSession概述" class="headerlink" title="2.1.2 NSURLSession概述"></a>2.1.2 NSURLSession概述</h3><ul><li>用于替代 <code>NSURLConnection</code></li><li>支持后台运行的网络任务</li><li>暂停、停止、重启网络任务，不再需要 <code>NSOperation</code> 封装</li><li>请求可以使用同样的<code>配置容器</code></li><li>不同的 <code>session</code> 可以使用不同的私有存储</li><li><code>block</code> 和<code>代理</code>可以同时起作用</li><li>直接从文件系统上传、下载</li><li>为了方便程序员使用，苹果提供了一个全局 <code>session</code></li><li>所有的 <code>任务(Task)</code> 都是由 <code>Session</code> 发起的</li><li>所有的任务默认是<code>挂起</code>的，需要 <code>Resume</code></li></ul><p>协议支持：</p><ul><li>NSURLSession 类支持data、file、ftp、http 和 https URL schemes，透明支持代理服务器和 SOCKS 网关，如用户系统首选项中配置的那样。</li><li>NSURLSession 支持 HTTP/1.1、HTTP/2 和 HTTP/3 协议。 如 RFC 7540 所述，HTTP/2 支持需要支持应用层协议协商 (ALPN) 的服务器。</li><li>还可以通过继承 NSURLProtocol 来添加对开发者自定义的网络协议和 URL 方案的支持（供您的应用程序私人使用）。</li></ul><p>线程安全：</p><p>URL Session API 是线程安全的。 可以在任何线程上下文中自由创建 sessions 和 tasks。 当调用提供的 completion handlers 时，工作会自动安排在正确的 delegate queue 中。</p><h3 id="2-1-3-NSURLSessionConfigration概述"><a href="#2-1-3-NSURLSessionConfigration概述" class="headerlink" title="2.1.3 NSURLSessionConfigration概述"></a>2.1.3 NSURLSessionConfigration概述</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">    configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>对于NSURLSession对象的初始化需要使用NSURLSessionConfiguration。会话配置文件用于设置网络会话属性，包括：身份验证，超时时长，缓存策略，Cookie等。</p><h4 id="1-三种模式"><a href="#1-三种模式" class="headerlink" title="1. 三种模式"></a>1. 三种模式</h4><p>NSURLSessionConfiguration有三个类工厂方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通模式（default）：返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的网络堆栈（networking stack）是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享NSURLCredentialStorage。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//临时模式（ephemeral）：返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration; </span><br><span class="line"></span><br><span class="line"><span class="comment">//后台模式（background）：特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在按下home键后，即应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。</span></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfiguration:(<span class="built_in">NSString</span> *)identifier; </span><br></pre></td></tr></table></figure><p>一般基本上都是使用默认设置。</p><h4 id="2-HTTPMaximumConnectionsPerHost属性"><a href="#2-HTTPMaximumConnectionsPerHost属性" class="headerlink" title="2. HTTPMaximumConnectionsPerHost属性"></a>2. HTTPMaximumConnectionsPerHost属性</h4><p>与给定主机建立的最大同时连接数。</p><p>此属性决定了根据本configuration创建的 sessions 中的任务与每个主机建立的最大同时连接数。</p><p>此限制是针对每个 session 的，因此如果使用了多个 session，那应用程序作为一个整体可能会超过此限制。 此外，根据与 Internet 的连接，session 使用的限制可能低于指定的限制。</p><p>macOS 中的默认值为 6，iOS 中的默认值为 4。</p><ul><li>如果 session 是用上面三个类工厂方法创建的，那么将共享 HTTPMaximumConnectionsPerHost 的设置，即最后一次的配置为所有session使用的最终的配置。</li><li>最好不要为了增加并发而创建多个Session，创建多个Session的目的应该是为了对不同的Task使用不同的策略，来实现更符合我们需求的交互。</li></ul><h3 id="2-1-4-AF-maxConcurrentOperationCount设置"><a href="#2-1-4-AF-maxConcurrentOperationCount设置" class="headerlink" title="2.1.4 AF maxConcurrentOperationCount设置"></a>2.1.4 AF maxConcurrentOperationCount设置</h3><p>回到初始化的这行代码上：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里先说结论，有些内容是在下面陈述的：</p><ul><li><p>首先我们要明确一个概念，<strong>这里的并发数仅仅是回调代理的线程并发数。而不是请求网络的线程并发数。请求网络是由NSURLSession来做的，它内部维护了一个线程池，用来做网络请求</strong>。它调度线程，基于底层的CFSocket去发送请求和接收数据。这些<strong>线程是并发的</strong>。</p></li><li><p>明确了这个概念之后，我们来梳理一下AF3.x的整个流程和线程的关系：</p><ul><li>我们一开始初始化sessionManager的时候，一般都是在主线程，（当然不排除有些人喜欢在分线程初始化…）</li><li>然后我们调用get或者post等去请求数据，接着会进行request拼接，AF代理的字典映射，progress的KVO添加等等，到NSUrlSession的resume之前这些准备工作，仍旧是在主线程中的。</li><li>然后我们调用NSUrlSession的resume，接着就跑到NSUrlSession内部去对网络进行数据请求了,在它内部是多线程并发的去请求数据的。</li><li>紧接着数据请求完成后，回调回来在我们一开始生成的并发数为1的NSOperationQueue中，这个时候会是多线程串行的回调回来的。（注：不明白的朋友可以看看雷纯峰大神这篇<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues</a>）</li><li>然后我们到返回数据解析那一块，我们自己又创建了并发的多线程，去对这些数据进行了各种类型的解析。</li><li>最后我们如果有自定义的completionQueue，则在自定义的queue中回调回来，也就是分线程回调回来，否则就是主队列，主线程中回调结束。</li></ul></li><li><p>最后我们来解释解释为什么回调Queue要设置并发数为1：个人认为AF这么做有以下两点原因：</p><ul><li><p>众所周知，AF2.x所有的回调是在一条线程（<em>参考6.7小节</em>），这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。</p></li><li><p>因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。<strong>反而多task回调导致的多线程并发，平白浪费了部分性能。</strong></p><p>而设置Queue的并发数为1（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFURLSessionManager的那些方法）至少回调的事件，是不需要多线程并发的。<strong>回调没有了NSLock的等待时间，所以对时间并没有多大的影响。</strong></p></li><li><p>注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程：<font color='red'>response的解析是并发线程执行的</font>（<em>参考2.3.6-1小节</em>）。</p></li></ul></li></ul><p>初始化方法到这就全部完成了。</p><h2 id="2-2-AFHTTPSessionManager创建GET-Task"><a href="#2-2-AFHTTPSessionManager创建GET-Task" class="headerlink" title="2.2 AFHTTPSessionManager创建GET Task"></a>2.2 AFHTTPSessionManager创建GET Task</h2><h3 id="2-2-1-源码实现"><a href="#2-2-1-源码实现" class="headerlink" title="2.2.1 源码实现"></a>2.2.1 源码实现</h3><p>接着我们来看看网络请求:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//生成一个系统的NSURLSessionDataTask实例</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始网络请求</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                          uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                        downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                 success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                 failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 用self.requestSerializer把各种参数转化为一个我们最终请求网络需要的NSMutableURLRequest实例。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span>  <span class="comment">// 这里是用来忽略 ?: 带来的警告</span></span></span><br><span class="line">            <span class="comment">// 当解析错误，我们直接调用传进来的 failure 的 Block 失败返回了，这里有一个 self.completionQueue ，这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</span></span><br><span class="line">            <span class="comment">// 实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-AFURLRequestSerialization创建request"><a href="#2-2-2-AFURLRequestSerialization创建request" class="headerlink" title="2.2.2 AFURLRequestSerialization创建request"></a>2.2.2 AFURLRequestSerialization创建request</h3><p>AFURLRequestSerialization文件中定义了三个请求参数序列化的类：</p><ul><li>AFHTTPRequestSerializer<ul><li>符合 <code>AFURLRequestSerialization</code> 和 <code>AFURLResponseSerialization</code> 协议，提供 query 字符串 / URL form-encoded 参数序列化和默认请求头的具体基础实现，以及响应状态代码和内容类型验证。</li><li>鼓励任何处理 HTTP 请求序列化的程序继承 <code>AFHTTPRequestSerializer</code> ，以确保一致的默认行为。</li><li>当请求的 Content-Type 是 <code>application/x-www-form-urlencoded</code> 时使用。<font color='red'>默认</font></li></ul></li><li>AFJSONRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSJSONSerialization</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/json</code>。</li><li>当请求的 Content-Type 是 <code>application/json</code> 时使用。</li></ul></li><li>AFPropertyListRequestSerializer<ul><li>继承自AFHTTPRequestSerializer，使用 <code>NSPropertyListSerializer</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/x-plist</code>。</li><li>当请求的 Content-Type 是 <code>application/x-plist</code> 时使用。</li></ul></li></ul><p>此处主要看的也是 AFHTTPRequestSerializer 序列化类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，debug模式下，如果缺少改参数，crash</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将request的各种观察属性循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="comment">//如果该观察属性已经发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           <span class="comment">//把给自己设置的属性给request设置</span></span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲一下这个方法，这个方法做了3件事：</p><h4 id="1-设置request请求类型"><a href="#1-设置request请求类型" class="headerlink" title="1. 设置request请求类型"></a>1. 设置request请求类型</h4><p>设置request的请求类型，get、post、put…等</p><h4 id="2-添加request配置参数"><a href="#2-添加request配置参数" class="headerlink" title="2. 添加request配置参数"></a>2. 添加request配置参数</h4><p>往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span></span><br><span class="line">    <span class="comment">// HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//就是一个数组里装了很多方法的名字,</span></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个函数就是封装了一些属性的名字，这些都是NSURLRequest的属性。</p><p>再来看看<code>self.mutableObservedChangedKeyPaths</code>，这个是 AFHTTPRequestSerializer 类的一个属性，在 init 方法中对这个集合进行了初始化，<strong>并对当前类的和NSURLRequest相关的那些属性添加了KVO监听</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *mutableObservedChangedKeyPaths;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 每次都会重置变化</span></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给这些key添加观察者为自己，就是request的各种属性，set方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO触发的方法：</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span></span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。</p><p>接下来调用下面的代码，用KVC的方式，把属性值都设置到我们请求的request中去。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure><h4 id="3-编码及设置请求参数"><a href="#3-编码及设置请求参数" class="headerlink" title="3. 编码及设置请求参数"></a>3. 编码及设置请求参数</h4><p>把需要传递的参数进行编码，并且设置到request中去：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从自己的head里去遍历，如果有值则设置给request的head</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来把各种类型的参数，array dic set转化成字符串，给request</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">//自定义的解析方式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认解析方式</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//post put请求</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了3件事：</p><h5 id="1-设置header中的参数"><a href="#1-设置header中的参数" class="headerlink" title="1) 设置header中的参数"></a>1) 设置header中的参数</h5><p>从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去</p><h5 id="2-将请求参数转换为字符串"><a href="#2-将请求参数转换为字符串" class="headerlink" title="2) 将请求参数转换为字符串"></a>2) 将请求参数转换为字符串</h5><p>把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span></span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分数组返回参数字符串</span></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="comment">//往下调用</span></span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span></span><br><span class="line">    <span class="comment">// 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span></span><br><span class="line">    <span class="comment">// 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;description&quot;</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[%@]&quot;</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[]&quot;</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</p><p>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.field = field;</span><br><span class="line">    <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@=%@&quot;</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     <span class="string">@&quot;phone&quot;</span>: @&#123;<span class="string">@&quot;mobile&quot;</span>: <span class="string">@&quot;xx&quot;</span>, <span class="string">@&quot;home&quot;</span>: <span class="string">@&quot;xx&quot;</span>&#125;, </span><br><span class="line">     <span class="string">@&quot;families&quot;</span>: @[<span class="string">@&quot;father&quot;</span>, <span class="string">@&quot;mother&quot;</span>], </span><br><span class="line">     <span class="string">@&quot;nums&quot;</span>: [NSSet setWithObjects:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: <span class="string">@&quot;name&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[mobile]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[home]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;father&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;mother&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;1&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;2&quot;</span>, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=<span class="number">1</span>&amp;num=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p><h5 id="3-根据请求类型设置请求参数"><a href="#3-根据请求类型设置请求参数" class="headerlink" title="3) 根据请求类型设置请求参数"></a>3) 根据请求类型设置请求参数</h5><p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//post put请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求体</span></span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们生成了一个request。</p><h3 id="2-2-3-AFURLSessionManger父类创建task"><a href="#2-2-3-AFURLSessionManger父类创建task" class="headerlink" title="2.2.3 AFURLSessionManger父类创建task"></a>2.2.3 AFURLSessionManger父类创建task</h3><p>现在弄清楚request的创建流程中，我们跳出当前方法，再回到上层AFHTTPSessionManager类中的 <code>dataTaskWithHTTPMethod:URLString:...</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                      uploadProgress:uploadProgress</span><br><span class="line">                    downloadProgress:downloadProgress</span><br><span class="line">                   completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            failure(dataTask, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(dataTask, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这是调用了继承自父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                    uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                  downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                 completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//第一件事，创建NSURLSessionDataTask，里面适配了iOS 8以下taskIdentifiers，函数创建task对象。</span></span><br><span class="line">    <span class="comment">//其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span></span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</p><h4 id="1-create-task-safely"><a href="#1-create-task-safely" class="headerlink" title="1. create_task_safely()"></a>1. create_task_safely()</h4><p>我们到这先到这个函数里去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="comment">// Fix of bug</span></span><br><span class="line">        <span class="comment">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line">        <span class="comment">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span></span><br><span class="line">      <span class="comment">//第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span></span><br><span class="line">      <span class="comment">//这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">//保证了即使是在多线程的环境下，也不会创建其他队列</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.creation&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用 <code>dataTask = [self.session dataTaskWithRequest:request];</code> 非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</p><p><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</p><p>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</p><h4 id="2-addDelegateForDataTask"><a href="#2-addDelegateForDataTask" class="headerlink" title="2. addDelegateForDataTask:"></a>2. addDelegateForDataTask:</h4><p>我们接着看到：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure><p>一起来看一下主要的调用流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</span><br><span class="line">﹂setDelegate:forTask:</span><br><span class="line">﹂setupProgressForTask:</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 生成一个AFURLSessionManagerTaskDelegate，这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系。代理把AFURLSessionManager这个类作为属性了，属性是weak声明的，所以不会存在循环引用的问题。</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. ***** 将AF delegate对象与 dataTask建立关系</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置AF delegate的上传进度，下载进度块。</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，如果没有这个参数，debug下crash在这</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁保证字典线程安全。要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为AF delegate 设置task 的progress监听</span></span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加task开始和暂停的通知</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为task设置progress</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 设置 downloadProgress 与 uploadProgress 的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么...）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//拿到上传下载期望的数据大小</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span></span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.downloadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 给task和progress的各个属及添加KVO监听</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//观察task的这些属性</span></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察progress这两个属性</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                            forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                               context:<span class="literal">NULL</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                          forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                             options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                             context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KVO 触发的监听方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是task</span></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]] || [object isKindOfClass:[<span class="built_in">NSURLSessionDownloadTask</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//给进度条赋新值</span></span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的赋新值会触发这两个，调用block回调，用户拿到进度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法非常简单直观，主要就是如果task触发KVO，则给progress进度赋值，因为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</p><p>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</p><p>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</p><p>到这里我们整个对task的处理就完成了。</p><h2 id="2-3-AFURLSessionManager中Session代理实现及转发"><a href="#2-3-AFURLSessionManager中Session代理实现及转发" class="headerlink" title="2.3 AFURLSessionManager中Session代理实现及转发"></a>2.3 AFURLSessionManager中Session代理实现及转发</h2><h3 id="2-3-1-代理方法概览"><a href="#2-3-1-代理方法概览" class="headerlink" title="2.3.1 代理方法概览"></a>2.3.1 代理方法概览</h3><p>接着task就开始请求网络了，还记得我们初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure><p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，下图这些NSUrlSession的代理开始调用了：</p><img src="/images/AFN/AFN-04.jpg" alt="img" style="zoom:60%;" /><p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p><p>而只转发了其中3条到下图中AF自定义的delegate中：</p><img src="/images/AFN/AFN-05.jpg" alt="img" style="zoom:60%;" /><p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p><p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSURLSession这么多代理呢？我们点到NSURLSession.h中去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionTaskDelegate</span> &lt;<span class="title">NSURLSessionDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDataDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDownloadDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionStreamDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</p><p>而AF还重写了<code>respondsToSelector</code>方法:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复写了selector的方法，这几个方法是在本类有实现的，但这些代理方法实现中只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。所以返回NO，相当于没有实现！也就不会去回调这些代理。</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:willCacheResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSessionDidFinishEventsForBackgroundURLSession:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[self <span class="class"><span class="keyword">class</span>] <span class="title">instancesRespondToSelector</span>:<span class="type">selector];</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这，我们顺便看看AFURLSessionManager的一些自定义Block：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure><p>各自对应的还有一堆这样的set方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法都是一样的，就不重复粘贴占篇幅了。主要谈谈这个设计思路</p><ul><li>作者用@property把这些Block属性在.m文件中声明，然后复写了set方法。</li><li>然后在.h中去声明这些set方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br></pre></td></tr></table></figure><p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p><p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p><h3 id="2-3-2-NSURLSessionDelegate实现"><a href="#2-3-2-NSURLSessionDelegate实现" class="headerlink" title="2.3.2 NSURLSessionDelegate实现"></a>2.3.2 NSURLSessionDelegate实现</h3><h4 id="01-URLSession-didBecomeInvalidWithError"><a href="#01-URLSession-didBecomeInvalidWithError" class="headerlink" title="01. URLSession:didBecomeInvalidWithError"></a>01. URLSession:didBecomeInvalidWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前这个session已经失效时，该代理方法被调用。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span></span><br><span class="line"><span class="comment"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span></span><br><span class="line"><span class="comment"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li><li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li></ul><h4 id="02-URLSession-didReceiveChallenge"><a href="#02-URLSession-didReceiveChallenge" class="headerlink" title="02. URLSession:didReceiveChallenge"></a>02. URLSession:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、用作https认证的，详细看第四节AFSecurityPolicy</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="03-URLSessionDidFinishEventsForBackgro"><a href="#03-URLSessionDidFinishEventsForBackgro" class="headerlink" title="03. URLSessionDidFinishEventsForBackgro.."></a>03. URLSessionDidFinishEventsForBackgro..</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li>函数讨论：<ul><li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler: 消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li><li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li></ul></li></ul><h3 id="2-3-3-NSURLSessionTaskDelegate实现"><a href="#2-3-3-NSURLSessionTaskDelegate实现" class="headerlink" title="2.3.3 NSURLSessionTaskDelegate实现"></a>2.3.3 NSURLSessionTaskDelegate实现</h3><h4 id="04-URLSession-task-willPerformHTTPRedirection"><a href="#04-URLSession-task-willPerformHTTPRedirection" class="headerlink" title="04. URLSession:task:willPerformHTTPRedirection"></a>04. URLSession:task:willPerformHTTPRedirection</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被服务器重定向的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        <span class="comment">//用自己自定义的一个重定向的block实现，返回一个新的request。</span></span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        <span class="comment">// step2. 用request重新请求</span></span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">&#x27;BASEPATH&#x27;</span>) <span class="keyword">OR</span> <span class="keyword">exit</span>(<span class="string">&#x27;No direct script access allowed&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        header(<span class="string">&quot;location: http://www.huixionghome.cn/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p><p>关于这个代理还有一些需要注意的地方：此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。（这里指的模式是我们一开始初始化 session时的模式）。</p><h4 id="05-URLSession-task-didReceiveChallenge"><a href="#05-URLSession-task-didReceiveChallenge" class="headerlink" title="05.URLSession:task:didReceiveChallenge"></a>05.URLSession:task:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https认证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：</p><ul><li>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li><li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li><li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li></ul><h4 id="06-URLSession-task-needNewBodyStream"><a href="#06-URLSession-task-needNewBodyStream" class="headerlink" title="06. URLSession:task:needNewBodyStream"></a>06. URLSession:task:needNewBodyStream</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代理方法会在下面两种情况被调用：</p><ol><li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li><li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li></ol><h4 id="07-URLSession-task-didSendBodyData"><a href="#07-URLSession-task-didSendBodyData" class="headerlink" title="07. URLSession:task:didSendBodyData"></a>07. URLSession:task:didSendBodyData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 周期性地通知代理发送到服务器端数据的进度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span></span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Length&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li><li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li></ul><h4 id="08-URLSession-task-didCompleteWithError"><a href="#08-URLSession-task-didCompleteWithError" class="headerlink" title="08. URLSession:task:didCompleteWithError"></a>08. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> task完成之后的回调，成功和失败都会回调这里</span></span><br><span class="line"><span class="comment"> 函数讨论：</span></span><br><span class="line"><span class="comment"> 注意这里的error不会报告服务期端的error，他表示的是客户端这边的error，比如无法解析hostname或者连不上host主机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//根据task去取我们一开始创建绑定的delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//把代理转发给我们绑定的delegate</span></span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        <span class="comment">//转发完移除delegate</span></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Block回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理就是task完成了的回调，方法内做了下面这几件事：</p><ul><li><p>在这里我们拿到了之前和这个task对应绑定的AF的delegate:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>去转发了调用了AF代理的方法。这个等我们下面讲完NSUrlSession的代理之后会详细说。</p></li><li><p>然后把这个AF的代理和task的绑定解除了，并且移除了相关的progress和通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">  <span class="comment">//移除跟AF代理相关的东西</span></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  [delegate cleanUpProgressForTask:task];</span><br><span class="line">  [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用了自定义的Blcok:self.taskDidComplete(session, task, error);</p><p>代码还是很简单的，至于这个通知，我们等会再来补充吧。</p></li></ul><h3 id="2-3-4-NSURLSessionDataDelegate实现"><a href="#2-3-4-NSURLSessionDataDelegate实现" class="headerlink" title="2.3.4 NSURLSessionDataDelegate实现"></a>2.3.4 NSURLSessionDataDelegate实现</h3><h4 id="09-URLSession-dataTask-didReceiveResponse"><a href="#09-URLSession-dataTask-didReceiveResponse" class="headerlink" title="09. URLSession:dataTask:didReceiveResponse"></a>09. URLSession:dataTask:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务器响应后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置默认为继续进行</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义去设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><p>函数作用：告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：</p><ul><li>NSURLSessionResponseAllow 该task正常进行</li><li>NSURLSessionResponseCancel 该task会被取消</li><li>NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task</li><li>NSURLSessionResponseBecomeStream 转成一个StreamTask</li></ul><p>函数讨论：</p><p>该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。</p><p>总结一下：</p><ul><li>当你把添加content-type的类型为 multipart/x-mixed-replace 那么服务器的数据会分片的传回来。然后这个方法是每次接受到对应片响应的时候会调被调用。你可以去设置上述4种对这个task的处理。</li><li>如果我们实现了自定义Block，则调用一下，不然就用默认的NSURLSessionResponseAllow方式。</li></ul><h4 id="10-URLSession-dataTask-didBecomeDownloadTask"><a href="#10-URLSession-dataTask-didBecomeDownloadTask" class="headerlink" title="10. URLSession:dataTask:didBecomeDownloadTask"></a>10. URLSession:dataTask:didBecomeDownloadTask</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代理如果设置为NSURLSessionResponseBecomeDownload，则会触发调用这个方法，作用就是新建一个downloadTask，替换掉当前的dataTask。所以我们在这里做了AF自定义代理的重新绑定操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为转变了task，所以要对task做一个重新绑定</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照顺序来，其实还有个AF没有去实现的代理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF没实现的代理</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeStreamTask:(<span class="built_in">NSURLSessionStreamTask</span> *)streamTask;</span><br></pre></td></tr></table></figure><p>这个也是之前的那个代理，设置为NSURLSessionResponseBecomeStream则会调用到这个代理里来。会新生成一个NSURLSessionStreamTask来替换掉之前的dataTask。</p><h4 id="11-URLSession-dataTask-didReceiveData"><a href="#11-URLSession-dataTask-didReceiveData" class="headerlink" title="11. URLSession:dataTask:didReceiveData"></a>11. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们获取到数据就会调用，会被反复调用，请求到的数据就在这被拼装完整</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和上面didCompleteWithError算是NSUrlSession的代理中最重要的两个方法了。</p><p>我们转发了这个方法到AF的代理中去，所以数据的拼接都是在AF的代理中进行的。这也是情理中的，毕竟每个响应数据都是对应各个task，各个AF代理的。在AFURLSessionManager都只是做一些公共的处理。</p><h4 id="12-URLSession-dataTask-willCacheResponse"><a href="#12-URLSession-dataTask-willCacheResponse" class="headerlink" title="12. URLSession:dataTask:willCacheResponse"></a>12. URLSession:dataTask:willCacheResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当task接收到所有期望的数据后，session会调用此代理方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译如下：</p><ul><li><p>函数作用：</p><ul><li>询问data task或上传任务（upload task）是否缓存response。</li></ul></li><li><p>函数讨论：</p><ul><li>当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。</li><li>该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：<ul><li>该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）</li><li>确保request请求是成功的（返回的status code为200-299）</li><li>返回的response是来自服务器端的，而非缓存中本身就有的</li><li>提供的NSURLRequest对象的缓存策略要允许进行缓存</li><li>服务器返回的response中与缓存相关的header要允许缓存</li><li>该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）</li></ul></li></ul></li><li><p>总结一下就是一个用来缓存response的方法，方法中调用了我们自定义的Block，自定义一个response用来缓存。</p></li></ul><h3 id="2-3-5-NSURLSessionDownloadDelegate实现"><a href="#2-3-5-NSURLSessionDownloadDelegate实现" class="headerlink" title="2.3.5 NSURLSessionDownloadDelegate实现"></a>2.3.5 NSURLSessionDownloadDelegate实现</h3><h4 id="13-URLSession-downloadTask-didFinishDown…"><a href="#13-URLSession-downloadTask-didFinishDown…" class="headerlink" title="13. URLSession:downloadTask:didFinishDown…"></a>13. URLSession:downloadTask:didFinishDown…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载完成的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//这个是session的，也就是全局的，后面的个人代理也会做同样的这件事</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用自定义的block拿到文件存储的地址</span></span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">//从临时的下载路径移动至我们需要的路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            <span class="comment">//如果移动出错</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发代理</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法和之前的两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)taskdidCompleteWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure><p>总共就这3个方法，被转调到AF自定义delegate中。</p><p>方法做了什么看注释应该很简单，就不赘述了。</p><h4 id="14-URLSession-downloadTask-didWriteData"><a href="#14-URLSession-downloadTask-didWriteData" class="headerlink" title="14. URLSession:downloadTask:didWriteData"></a>14. URLSession:downloadTask:didWriteData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//周期性地通知下载进度调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说一下这几个参数:</p><ul><li>bytesWritten表示自上次调用该方法后，接收到的数据字节数</li><li>totalBytesWritten表示目前已经接收到的数据字节数</li><li>totalBytesExpectedToWrite表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown。</li></ul><h4 id="15-URLSession-downloadTask-didResumeAtOffset"><a href="#15-URLSession-downloadTask-didResumeAtOffset" class="headerlink" title="15. URLSession:downloadTask:didResumeAtOffset"></a>15. URLSession:downloadTask:didResumeAtOffset</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当下载被取消或者失败后重新恢复下载时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交给自定义的Block去调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档翻译：</p><ul><li><p>函数作用：</p><ul><li>告诉代理，下载任务重新开始下载了。</li></ul></li><li><p>函数讨论：</p><ul><li>如果一个正在下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。</li><li>随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。</li></ul></li></ul><p>总结一下：</p><ul><li><strong>其实这个就是用来做断点续传的代理方法。</strong>可以在下载失败的时候，拿到我们失败的拼接的部分resumeData，然后用去调用downloadTaskWithResumeData：就会调用到这个代理方法来了。</li><li>其中注意：fileOffset这个参数，如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。否则，该值表示当前已经下载data的偏移量。</li><li>方法中仅仅调用了downloadTaskDidResume自定义Block。</li></ul><p>至此NSUrlSesssion的delegate讲完了。大概总结下：</p><ul><li>每个代理方法对应一个我们自定义的Block,如果Block被赋值了，那么就调用它。</li><li>在这些代理方法里，我们做的处理都是相对于这个sessionManager所有的request的。<strong>是公用的处理。</strong></li><li>转发了3个代理方法到AF的deleagate中去了，AF中的deleagate是需要对应每个task去<strong>私有化处理的</strong>。</li></ul><h3 id="2-3-6-转发到AFURLSxxMxxTaskDelegate的方法"><a href="#2-3-6-转发到AFURLSxxMxxTaskDelegate的方法" class="headerlink" title="2.3.6 转发到AFURLSxxMxxTaskDelegate的方法"></a>2.3.6 转发到AFURLSxxMxxTaskDelegate的方法</h3><p>接下来我们来看从 AFURLSessionManager 中转发到 AFURLSessionManagerTaskDelegate 的deleagate，一共3个方法：</p><h4 id="1-URLSession-task-didCompleteWithError"><a href="#1-URLSession-task-didCompleteWithError" class="headerlink" title="1. URLSession:task:didCompleteWithError"></a>1. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF实现的代理！被从urlsession那转发到这</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block</span></span><br><span class="line"></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储一些相关信息，来发送通知用的</span></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//存储responseSerializer响应解析对象</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续给userinfo填数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以自己自定义完成组 和自定义完成queue,完成回调</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//主线程中发送完成通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//url_session_manager_processing_queue AF的并行队列</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析数据</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是下载文件，那么responseObject为下载的路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入userInfo</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果解析错误</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回调结果</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是NSURLSession任务完成的代理方法中，主动调用过来的。配合注释，应该代码很容易读，这个方法大概做了以下几件事：</p><ol><li><p>生成了一个存储这个task相关信息的字典：userInfo，这个字典是用来作为发送任务完成的通知的参数。</p></li><li><p>判断了参数error的值，来区分请求成功还是失败。</p></li><li><p>如果成功则在一个AF的并行queue中，去做数据解析等后续操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意AF的优化的点：<font color='red'>虽然代理回调是串行的(参考2.1.4小节 maxConcurrentOperationCount属性)。但是数据解析这种费时操作，确是用并行线程来做的。</font></p></li><li><p>然后根据我们一开始设置的responseSerializer来解析data。如果解析成功，调用成功的回调，否则调用失败的回调。我们重点来看看返回数据解析这行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br></pre></td></tr></table></figure><p>我们点进去看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                         data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>原来就是这么一个协议方法，各种类型的responseSerializer类，都是遵守这个协议方法，实现了一个把我们请求到的data转换为我们需要的类型的数据的方法。至于各种类型的responseSerializer如何解析数据，我们到代理讲完再来补充。</p></li><li><p>这边还做了一个判断，如果自定义了GCD完成组completionGroup和完成队列的话completionQueue，会在加入这个组和在队列中回调Block。否则默认的是AF的创建的组：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和主队列回调。<strong>AF没有用这个GCD组做任何处理，只是提供这个接口，让我们有需求的自行调用处理。</strong>如果有对多个任务完成度的监听，可以自行处理。<br>而队列的话，如果你不需要回调主线程，可以自己设置一个回调队列。</p></li><li><p>回到主线程，发送了任务完成的通知：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>这个通知这回AF有用到了，在我们对UIKit的扩展中，用到了这个通知。</p></li></ol><h4 id="2-URLSession-dataTask-didReceiveData"><a href="#2-URLSession-dataTask-didReceiveData" class="headerlink" title="2. URLSession:dataTask:didReceiveData"></a>2. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拼接数据</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样被NSUrlSession代理转发到这里，拼接了需要回调的数据。</p><h4 id="3-URLSession-downloadTask-didFinishDownload…"><a href="#3-URLSession-downloadTask-didFinishDownload…" class="headerlink" title="3. URLSession:downloadTask:didFinishDownload…"></a>3. URLSession:downloadTask:didFinishDownload…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF代理的自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//得到自定义下载路径</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="comment">//把下载路径移动到我们自定义的下载路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误发通知</span></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载成功了被NSUrlSession代理转发到这里，这里有个地方需要注意下：</p><ul><li><p>之前的NSUrlSession代理和这里都移动了文件到下载路径，而NSUrlSession代理的下载路径是所有request公用的下载路径，一旦设置，所有的request都会下载到之前那个路径。</p></li><li><p>而这个是对应的每个task的，每个task可以设置各自下载路径,还记得AFHttpManager的download方法么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[manager downloadTaskWithRequest:resquest progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个地方return的path就是对应的这个代理方法里的path，我们调用最终会走到这么一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                     destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">  delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">  delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回地址的Block</span></span><br><span class="line">  <span class="keyword">if</span> (destination) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//有点绕，就是把一个block赋值给我们代理的downloadTaskDidFinishDownloading，这个Block里的内部返回也是调用Block去获取到的，这里面的参数都是AF代理传过去的。</span></span><br><span class="line">      delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">          <span class="comment">//把Block返回的地址返回</span></span><br><span class="line">          <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">  delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清楚的可以看到地址被赋值给AF的Block了。</p></li></ul><p>至此AF的代理也讲完了，<strong>数据或错误信息随着AF代理成功失败回调，回到了用户的手中。</strong></p><h2 id="2-4-AFURLSessionTaskSwizzling类"><a href="#2-4-AFURLSessionTaskSwizzling类" class="headerlink" title="2.4 _AFURLSessionTaskSwizzling类"></a>2.4 _AFURLSessionTaskSwizzling类</h2><p>在AFURLSessionManager中，有这么一个类：_AFURLSessionTaskSwizzling。这个类大概的作用就是替换掉NSURLSession中的resume和suspend方法。正常处理原有逻辑的同时，多发送一个通知，以下是我们需要替换的新方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被替换掉的方法，只要有TASK开启或者暂停，都会执行</span></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块知识是关于OC的Runtime:method swizzling的，如果有不清楚的地方，可以看看这里<a href="http://www.jianshu.com/p/db6dc23834e3">method swizzling–by冰霜</a>或者自行查阅。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionTask&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">&quot;-Wnonnull&quot;</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 2) 获取到af_resume实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 检查当前class是否实现了resume。如果实现了，继续第4步。</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 获取到当前class的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) 获取到当前class对于resume实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  6) 获取到父类对于resume实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                <span class="comment">//执行交换的函数</span></span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8) 设置当前操作的class为其父类class，重复步骤3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原方法中有大量的英文注释，我把它翻译过来如下：</p><ul><li><p>iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick</p><p>关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的</p></li><li><p>目前我们所知的：</p><ul><li>NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）</li><li>简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。</li><li>iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 <strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自__NSCFURLSessionTask。</li><li>iOS 8上，localDataTask的类型为<strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自NSURLSessionTask</li><li>iOS 7上，<strong>NSCFLocalSessionTask和</strong>NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外<strong>NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即</strong>NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。</li><li>iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类</li><li>因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。</li></ul></li><li><p>一些假设前提:</p><ul><li>目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理。</li><li>没有哪个后台task会重写resume和suspend函数</li></ul></li></ul><p>其余的一部分翻译在注释中，对应那一行代码。大概总结下这个注释：</p><ul><li>其实这是被社区大量讨论的一个bug，之前AF因为这个替换方法，会导致偶发性的crash，如果不要这个swizzle则问题不会再出现，但是这样会导致AF中很多UIKit的扩展都不能正常使用。</li><li><strong>原来这是因为iOS7和iOS8的NSURLSessionTask的继承链不同导致的，</strong>而且在iOS7继承链中会有两个类都实现了resume和suspend方法。而且子类没有调用父类的方法，我们则需要对着两个类都进行方法替换。而iOS8只需要对一个类进行替换。</li><li>对着注释看，上述方法代码不难理解，用一个while循环，一级一级去获取父类，如果实现了resume方法，则进行替换。</li></ul><p>但是有几个点大家可能会觉得疑惑的，我们先把这个方法调用的替换的函数一块贴出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其引用的交换的函数：</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有小伙伴问到过，所以我们来分析分析大家可能会觉得疑惑的地方：</p><ol><li><p>首先可以注意class_getInstanceMethod这个方法，它会获取到当前类继承链逐级往上，第一个实现的该方法。所以说它获取到的方法不能确定是当前类还是父类的。而且这里也没有用dispatch_once_t来保证一个方法只交换一次，那万一这是父类的方法，当前类换一次，父类又换一次，不是等于没交换么？…请注意这行判断：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line"><span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; </span><br><span class="line">      <span class="comment">//执行交换的函数</span></span><br><span class="line">     [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件就杜绝了这种情况的发生，只有当前类实现了这个方法，才可能进入这个if块。</p></li><li><p>那iOS7两个类都交换了af_resume，那岂不是父类换到子类方法了?…只能说又是没仔细看代码的…注意AF是去向当前类添加af_resume方法，然后去交换当前类的af_resume。所以说根本不会出现这种情况…</p></li></ol><h1 id="三、AFURLResponseSerialization"><a href="#三、AFURLResponseSerialization" class="headerlink" title="三、AFURLResponseSerialization"></a>三、AFURLResponseSerialization</h1><p>接下来我们来补充之前AFURLResponseSerialization这一块是如何解析数据的：</p><img src="/images/AFN/AFN-06.jpg" alt="img" style="zoom:70%;" /><p>如图所示，AF用来解析数据的一共上述这些方法。第一个实际是一个协议方法，协议方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>而后面6个类都是遵守这个协议方法，去做数据解析。**这地方可以再次感受一下AF的设计模式…**接下来我们就来主要看看这些类对这个协议方法的实现：</p><h2 id="3-1-AFHTTPResponseSerializer"><a href="#3-1-AFHTTPResponseSerializer" class="headerlink" title="3.1 AFHTTPResponseSerializer"></a>3.1 AFHTTPResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法调用了一个另外的方法之后，就把data返回来了，我们继续往里看这个方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是可接受类型和可接受code，不是则填充error</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//response是否合法标识</span></span><br><span class="line">  <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">//验证的error</span></span><br><span class="line">  <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果存在且是NSHTTPURLResponse</span></span><br><span class="line">  <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要判断自己能接受的数据类型和response的数据类型是否匹配，</span></span><br><span class="line">    <span class="comment">//如果有接受数据类型，如果不匹配response，而且响应类型不为空，数据长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">        !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入If块说明解析数据肯定是失败的，这时候要把解析错误信息放到error里。</span></span><br><span class="line">        <span class="comment">//如果数据长度大于0，而且有响应url</span></span><br><span class="line">        <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误信息字典，填充一些错误信息</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: unacceptable content-type: %@&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">            &#125; mutableCopy];</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成错误</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断自己可接受的状态吗</span></span><br><span class="line">    <span class="comment">//如果和response的状态码不匹配，则进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">        <span class="comment">//填写错误信息字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">             <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: %@ (%ld)&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">             <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">             AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">        &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成错误</span></span><br><span class="line">        validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给我们传过来的错误指针赋值</span></span><br><span class="line">  <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">      *error = validationError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回是否错误标识</span></span><br><span class="line">  <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看注释应该很容易明白这个方法有什么作用。简单来说，<strong>这个方法就是来判断返回数据与咱们使用的解析器是否匹配，需要解析的状态码是否匹配。</strong>如果错误，则填充错误信息，并且返回NO，否则返回YES，错误信息为nil。</li><li>其中里面出现了两个属性值，一个acceptableContentTypes，一个acceptableStatusCodes，两者在初始化的时候有给默认值，我们也可以去自定义，但是如果给acceptableContentTypes定义了不匹配的类型，那么数据仍旧会解析错误。</li><li>而AFHTTPResponseSerializer仅仅是调用验证方法，然后就返回了data。</li></ul><h2 id="3-2-AFJSONResponseSerializer"><a href="#3-2-AFJSONResponseSerializer" class="headerlink" title="3.2 AFJSONResponseSerializer"></a>3.2 AFJSONResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断是不是可接受类型和可接受code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空，或者有错误，去函数里判断。</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="comment">//返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">&quot; &quot;</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//没空格去json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要移除Null值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿着json解析的error去填充错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回解析结果</span></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，大概需要讲一下的是以下几个函数: （之前注释已经写清楚了这些函数的作用）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain))</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">AFErrorWithUnderlyingError(serializationError, *error);</span><br></pre></td></tr></table></figure><p>第一个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是我们自己之前生成的错误信息，是的话返回YES</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域名和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果userInfo的NSUnderlyingErrorKey有值，则在判断一次。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以注意，我们这里传过去的code和domain两个参数分别为NSURLErrorCannotDecodeContentData、AFURLResponseSerializationErrorDomain，这两个参数是我们之前判断response可接受类型和code时候自己去生成错误的时候填写的。</p><p>第二个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//分数组和字典</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个数组，只需要JSONObject.count个，感受到大神写代码的严谨态度了吗...</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            <span class="comment">//调用自己</span></span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看我们解析类型是mutable还是非muatable,返回mutableArray或者array</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="comment">//value空则移除</span></span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//如果数组还是去调用自己</span></span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要还是通过递归的形式实现。比较简单。</p><p>第三个：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要是把json解析的错误，赋值给我们需要返回给用户的error上。比较简单，小伙伴们自己看看就好。</p><p>至此，AFJSONResponseSerializer就讲完了。而我们ResponseSerialize还有一些其他的类型解析，大家可以自行去阅读，代码还是很容易读的，在这里就不浪费篇幅去讲了。</p><p>至此我们AF3.X业务层的逻辑，基本上结束了。</p><h1 id="四、AFSecurityPolicy"><a href="#四、AFSecurityPolicy" class="headerlink" title="四、AFSecurityPolicy"></a>四、AFSecurityPolicy</h1><p>关于TLS的连接过程、单向认证/双向认证、证书信任链等概念，这里不再赘述了。</p><p>AF就是用AFSecurityPolicy这个类来满足我们各种https认证需求。在这之前我们来看看AF实现的 NSURLSessionDelegate 中用来做https认证的代理方法：</p><h2 id="4-1-session-didReceiveChallenge代理方法"><a href="#4-1-session-didReceiveChallenge代理方法" class="headerlink" title="4.1 session:didReceiveChallenge代理方法"></a>4.1 session:didReceiveChallenge代理方法</h2><p>这个方法就是做https认证的。把官方文档对这个方法的描述翻译一下：</p><ul><li><p>函数作用：</p><ul><li>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</li><li>接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential。<ul><li>disposition是应对这个挑战的认证方式，而credential是客户端应对这个挑战生成的证书。</li><li>注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书。</li></ul></li><li>最后调用completionHandler回应服务器端的挑战。</li></ul></li><li><p>函数讨论：</p><ul><li>该代理方法会在下面两种情况调用：<ul><li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li><li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）</li></ul></li><li>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 首先指定了https为默认的认证方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理。就像这个delegate方法没实现，credential被忽略</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书(证书可能为nil)</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战。整个请求都将被取消，credential被忽略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. sessionDidReceiveAuthenticationChallenge属性是一个自定义的做认证的Block，判断是否有值。</span></span><br><span class="line">    <span class="comment">// 若有，则调用，会生成一个认证方式，并给 credential 赋值，即我们需要接受认证的证书。</span></span><br><span class="line">    <span class="comment">// 若无，则去执行默认的认证步骤</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 3. 判断如果服务端的认证方法要求是 NSURLAuthenticationMethodServerTrust ，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust。也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。该证书需要使用credentialForTrust:来创建一个NSURLCredential对象。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 执行AFSecurityPolicy的方法，做一个AF内部的https认证：基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 用服务器返回的一个 serverTrust 去生成了一个认证证书。然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。</span></span><br><span class="line">                <span class="comment">// 注1：这个 serverTrust 是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）</span></span><br><span class="line">                <span class="comment">// 注2：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; <span class="comment">// 证书挑战</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;  <span class="comment">// 默认挑战</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回NO，说明AF内部认证失败，则取消挑战，即取消请求。</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 最后调用 completionHandler 传递认证方式和要认证的证书，去做系统根证书验证。</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下这里 <code>securityPolicy</code> 存在的作用就是，<strong>使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。</strong>如果通不过，则直接越过系统的验证，取消https的网络请求。否则，继续去走系统根证书的验证。</p><h2 id="4-2-AFSecurityPolicy内部"><a href="#4-2-AFSecurityPolicy内部" class="headerlink" title="4.2 AFSecurityPolicy内部"></a>4.2 AFSecurityPolicy内部</h2><p>接下来我们看看<code>AFSecurityPolicy</code>内部是如何做https认证的:</p><h3 id="4-2-1-五个属性"><a href="#4-2-1-五个属性" class="headerlink" title="4.2.1 五个属性"></a>4.2.1 五个属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFSSLPinningMode 共提供了3种验证方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    <span class="comment">//验证证书</span></span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFSecurityPolicy，一共有4个公有属性：</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https验证模式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="comment">// if pinning(固定) is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否去验证证书域名是否匹配</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如下方式，我们可以创建一个<code>securityPolicy</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">  AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  securityPolicy.SSLPinningMode = AFSSLPinningModeNone; <span class="comment">// 默认指定了SSLPinningMode模式为AFSSLPinningModeNone</span></span><br><span class="line">  <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFSecurityPolicy 还有一个私有属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br></pre></td></tr></table></figure><p>AF复写了 pinnedCertificates 属性的setter方法，会同时把证书中每个公钥放在了self.pinnedPublicKeys中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置证书数组</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    </span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应公钥集合</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="comment">//创建公钥集合</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//从证书中拿到公钥。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-evaluateServerTrust-方法"><a href="#4-2-2-evaluateServerTrust-方法" class="headerlink" title="4.2.2 evaluateServerTrust:方法"></a>4.2.2 evaluateServerTrust:方法</h3><h4 id="1-参数SecTrustRef与源码实现解读"><a href="#1-参数SecTrustRef与源码实现解读" class="headerlink" title="1. 参数SecTrustRef与源码实现解读"></a>1. 参数SecTrustRef与源码实现解读</h4><p>我们接着回到代理https认证的这行代码上：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>我们传了两个参数进去，一个是<code>SecTrustRef</code>类型的serverTrust，这是什么呢？我们看到苹果的文档介绍如下：</p><blockquote><p>CFType used for performing X.509 certificate trust evaluations.  </p><p>大概意思是用于执行X.509证书信任评估，再讲简单点，其实就是一个容器，装了服务器端需要验证的证书的基本信息、公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，这个客户端的证书，可以用来和服务端的证书去匹配验证的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Security.framework 源码 https://opensource.apple.com/tarballs/Security/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> &#123;</span></span><br><span class="line">    CFRuntimeBase           _base;</span><br><span class="line">    CFArrayRef              _certificates;  <span class="comment">//证书</span></span><br><span class="line">    CFArrayRef              _anchors; <span class="comment">// 锚点</span></span><br><span class="line">    CFTypeRef               _policies; <span class="comment">// 评估信任的策略</span></span><br><span class="line">    CFArrayRef              _responses;</span><br><span class="line">    CFArrayRef              _SCTs;</span><br><span class="line">    CFArrayRef              _trustedLogs;</span><br><span class="line">    CFDateRef               _verifyDate;</span><br><span class="line"><span class="comment">// 证书链。什么是证书链？百科：证书链由两个环节组成：信任锚（CA证书）环节和已签名证书环节。自我签名的证书仅有一个环节的长度：信任锚环节就是已签名证书本身。简单来说，证书链就是就是根证书，和根据根证书签名派发得到的证书。</span></span><br><span class="line">  CFArrayRef              _chain; </span><br><span class="line">    SecKeyRef               _publicKey;</span><br><span class="line">    CFArrayRef              _details;</span><br><span class="line">    CFDictionaryRef         _info;</span><br><span class="line">    CFArrayRef              _exceptions;</span><br><span class="line"></span><br><span class="line">    SecTrustResultType      _trustResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If true we don&#x27;t trust any anchors other than the ones in _anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _anchorsOnly;</span><br><span class="line">    <span class="comment">/* If false we shouldn&#x27;t search keychains for parents or anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _keychainsAllowed;</span><br><span class="line">    <span class="comment">/* Dispatch queue for thread-safety */</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span>        _trustQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> *<span class="title">SecTrustRef</span>;</span>  <span class="comment">// trust management object(信任管理对象)，包括要验证的证书以及用于评估信任的一个或多个策略</span></span><br></pre></td></tr></table></figure><p>这个方法是<code>AFSecurityPolicy</code>最核心的方法，其他的都是为了配合这个方法。这个方法完成了服务端的证书的信任评估。代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 验证服务端是否值得信任</span></span><br><span class="line"><span class="comment"> * serverTrust SecTrustRef </span></span><br><span class="line"><span class="comment"> * domain 服务器域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判断矛盾的条件</span></span><br><span class="line">    <span class="comment">//判断有域名，且允许自建证书，需要验证域名，</span></span><br><span class="line">    <span class="comment">//因为要验证域名，所以必须不能是后者两种：AFSSLPinningModeNone或者添加到项目里的证书为0个。</span></span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;</span>);</span><br><span class="line">        <span class="comment">//不受信任，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 为serverTrust设置验证策略</span></span><br><span class="line"><span class="comment">// 用来装验证策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">//要验证域名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">        <span class="comment">//添加验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要验证domain，就使用默认的BasicX509验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//serverTrust：X.509服务器的证书信任。</span></span><br><span class="line">    <span class="comment">//为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 判断模式，如果是AFSSLPinningModeNone，按照下面的逻辑肯定是返回YES，不论是自签还是公信机构的证书。</span></span><br><span class="line">    <span class="comment">//有验证策略了，可以去验证了。如果是AFSSLPinningModeNone，是自签名，直接返回可信任，否则不是自签名的就去系统根证书里去找是否有匹配的证书。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="comment">//如果支持自签名，直接返回YES，不允许才去判断第二个条件，判断serverTrust是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是AFSSLPinningModeNone，且验证无效AFServerTrustIsValid，而且allowInvalidCertificates不允许自签，返回NO</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SSLPinningMode</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="comment">// 理论上，上面那个部分已经解决了self.SSLPinningMode 为 AFSSLPinningModeNone 等情况，所以此处再遇到，就直接返回NO</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 如果是AFSSLPinningModeCertificate(验证证书类型)，则从serverTrust中去获取证书链，然后和我们一开始初始化设置的证书集合self.pinnedCertificates去匹配，如果有一对能匹配成功的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把证书data，用系统api转成 SecCertificateRef 类型的数据，SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 将pinnedCertificates设置成评估 信任管理对象 时使用的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书）</span></span><br><span class="line">            <span class="comment">//serverTrust是服务器来的验证，有需要被验证的证书。在不调用SecTrustSetAnchorCertificatesOnly()的情况下调用此函数将禁用对锚证书中锚之外的任何锚的信任。</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自签在之前是验证通过不了的，在这一步，把我们自己设置的证书加进去之后，就能验证成功了。</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//在设置锚点证书之后，再调用SecTrustEvaluate来验证一下serverTrust的证书是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#x27;s the Root CA)</span></span><br><span class="line">            <span class="comment">//注意，这个方法和我们之前的锚点证书没关系了，是去从我们需要被验证的服务端证书，去拿证书链。</span></span><br><span class="line">            <span class="comment">//服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//reverseObjectEnumerator逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果我们的证书中，有一个和它证书链中的证书匹配的，就返回YES</span></span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有匹配的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 5. 如果是AFSSLPinningModePublicKey公钥验证，则和第二步一样还是从serverTrust，获取证书链每一个证书的公钥，放到数组中。和我们的self.pinnedPublicKeys，去配对，如果有一个相同的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="comment">//公钥验证 AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历服务端公钥</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//遍历本地公钥</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="comment">//判断如果相同 trustedPublicKeyCount+1</span></span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中关联了一系列的函数，我在这边按照调用顺序一一列出来（有些是系统函数，不在这里列出，会在下文集体描述作用）：</p><h4 id="2-调用函数一-AFServerTrustIsValid"><a href="#2-调用函数一-AFServerTrustIsValid" class="headerlink" title="2. 调用函数一: AFServerTrustIsValid"></a>2. 调用函数一: AFServerTrustIsValid</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断serverTrust是否有效</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认无效</span></span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//用来装验证结果，枚举</span></span><br><span class="line">    SecTrustResultType result;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//__Require_noErr_Quiet 用来判断前者是0还是非0，如果0则表示没错，就跳到后面的表达式所在位置去执行，否则表示有错就继续往下执行。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//SecTrustEvaluate系统评估证书的是否可信的函数，去系统根目录找，然后把结果赋值给result。评估结果匹配，返回0，否则出错返回非0</span></span><br><span class="line">    <span class="comment">//do while 0 ,只执行一次，为啥要这样写....</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评估没出错走掉这，只有两种结果能设置为有效，isValid= 1</span></span><br><span class="line">    <span class="comment">//当result为kSecTrustResultUnspecified（此标志表示serverTrust评估成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书）。</span></span><br><span class="line">    <span class="comment">//或者当result为kSecTrustResultProceed（此标志表示评估成功，和上面不同的是该评估得到了用户认可），这两者取其一就可以认为对serverTrust评估成功</span></span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out函数块,如果为SecTrustEvaluate，返回非0，则评估出错，则isValid为NO</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来验证serverTrust是否有效，其中主要是交由系统API<code>SecTrustEvaluate</code>来验证的，它验证完之后会返回一个<code>SecTrustResultType</code>枚举类型的result，然后我们根据这个result去判断是否证书是否有效。</p><p>其中比较有意思的是，它调用了一个系统定义的宏函数<code>__Require_noErr_Quiet</code>，函数定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __Require_noErr_Quiet</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">      <span class="keyword">do</span>                                                                          \</span><br><span class="line">      &#123;                                                                           \</span><br><span class="line">          <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            \</span><br><span class="line">          &#123;                                                                       \</span><br><span class="line">              <span class="keyword">goto</span> exceptionLabel;                                                \</span><br><span class="line">          &#125;                                                                       \</span><br><span class="line">      &#125; <span class="keyword">while</span> ( <span class="number">0</span> ) <span class="comment">// 在Linux内核和其它一些著名的C库中都会有许多使用do&#123;...&#125;while(0)的宏定义。作用：使用do&#123;...&#125;while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数主要作用就是，判断errorCode是否为0，不为0则，程序用<code>goto</code>跳到<code>exceptionLabel</code>位置去执行。这个<code>exceptionLabel</code>就是一个代码位置标识，类似上面的<code>_out</code>。</p><h4 id="3-调用函数二、三获取证书链证书-公钥"><a href="#3-调用函数二、三获取证书链证书-公钥" class="headerlink" title="3. 调用函数二、三获取证书链证书/公钥"></a>3. 调用函数二、三获取证书链证书/公钥</h4><p>函数二、三（两个函数类似，所以放在一起）：获取serverTrust证书链证书，获取serverTrust证书链公钥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取证书链</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//使用SecTrustGetCertificateCount函数获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。</span></span><br><span class="line">    <span class="comment">//安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//遍历serverTrust里证书的证书链。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        <span class="comment">//从证书链取证书</span></span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="comment">//CF数组</span></span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据给定的certificates和policy来生成一个trust对象</span></span><br><span class="line">        <span class="comment">//不成功跳到 _out。</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用SecTrustEvaluate来评估上面构建的trust</span></span><br><span class="line">        <span class="comment">//评估失败跳到 _out</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的一组公钥</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法功能类似，都是调用了一些系统的API，利用For循环，获取证书链上每一个证书或者公钥。具体内容看源码很好理解。唯一需要注意的是，这个获取的证书排序，是从证书链的叶节点，到根节点的。</p><h4 id="4-调用函数四-判断公钥是否相同"><a href="#4-调用函数四-判断公钥是否相同" class="headerlink" title="4. 调用函数四: 判断公钥是否相同"></a>4. 调用函数四: 判断公钥是否相同</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个公钥是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">AFSecKeyIsEqualToKey</span><span class="params">(SecKeyRef key1, SecKeyRef key2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">    <span class="comment">//iOS 判断二者地址</span></span><br><span class="line">    <span class="keyword">return</span> [(__bridge id)key1 isEqual:(__bridge id)key2];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AFSecKeyGetData</span>(key1) isEqual:<span class="built_in">AFSecKeyGetData</span>(key2)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法适配了各种运行环境，做了匹配的判断。</p><h4 id="5-验证过程中调用的系统原生函数"><a href="#5-验证过程中调用的系统原生函数" class="headerlink" title="5. 验证过程中调用的系统原生函数"></a>5. 验证过程中调用的系统原生函数</h4><p>接下来列出验证过程中调用过得系统原生函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个验证SSL的策略，两个参数，第一个参数true则表示验证整个证书链</span></span><br><span class="line"><span class="comment">//第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">SecPolicyCreateSSL(&lt;#Boolean server#&gt;, &lt;#CFStringRef  _Nullable hostname#&gt;)</span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.默认的BasicX509验证策略,不验证域名。</span></span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">SecTrustSetPolicies(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#CFTypeRef  _Nonnull policies#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.验证serverTrust,并且把验证结果返回给第二参数 result</span></span><br><span class="line">SecTrustEvaluate(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#SecTrustResultType * _Nullable result#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判断前者errorCode是否为0，为0则跳到exceptionLabel处执行代码</span></span><br><span class="line">__Require_noErr(&lt;#errorCode#&gt;, &lt;#exceptionLabel#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.根据证书data,去创建SecCertificateRef类型的数据。</span></span><br><span class="line">SecCertificateCreateWithData(&lt;#CFAllocatorRef  _Nullable allocator#&gt;, &lt;#CFDataRef  _Nonnull data#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.给serverTrust设置锚点证书，即如果以后再次去验证serverTrust，会从锚点证书去找是否匹配。</span></span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.拿到证书链中的证书个数</span></span><br><span class="line">CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="function">CFIndex <span class="title">SecTrustGetCertificateCount</span><span class="params">(SecTrustRef trust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    __block CFIndex certCount = <span class="number">1</span>;</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            certCount = CFArrayGetCount(trust-&gt;_chain);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> certCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.去取得证书链中对应下标的证书。</span></span><br><span class="line">SecTrustGetCertificateAtIndex(serverTrust, i)</span><br><span class="line">  </span><br><span class="line"><span class="function">SecCertificateRef <span class="title">SecTrustGetCertificateAtIndex</span><span class="params">(SecTrustRef trust,</span></span></span><br><span class="line"><span class="function"><span class="params">    CFIndex ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block SecCertificateRef cert = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == <span class="number">0</span>) &#123;</span><br><span class="line">        dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_certificates, <span class="number">0</span>);  <span class="comment">// SecTrustRef成员_certificates</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cert;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_chain, ix);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.根据证书获取公钥。</span></span><br><span class="line">SecTrustCopyPublicKey(trust)</span><br></pre></td></tr></table></figure><p>其功能如注释，大家可以对比着源码，去加以理解~</p><h2 id="4-3-关于HTTPS-开发者需要做什么"><a href="#4-3-关于HTTPS-开发者需要做什么" class="headerlink" title="4.3 关于HTTPS, 开发者需要做什么"></a>4.3 关于HTTPS, 开发者需要做什么</h2><p>可能看到这，又有些小伙伴迷糊了，讲了这么多，<strong>那如果做https请求，真正需要我们自己做的到底是什么呢？</strong></p><h3 id="4-3-1-如果只想访问能通"><a href="#4-3-1-如果只想访问能通" class="headerlink" title="4.3.1 如果只想访问能通"></a>4.3.1 如果只想访问能通</h3><p>分为以下两种情况：</p><ol><li>如果你用的是付费的公信机构颁发的证书，标准的https，<strong>那么无论你用的是AF还是NSUrlSession,什么都不用做，代理方法也不用实现。</strong>你的网络请求就能正常完成。</li><li>如果你用的是自签名的证书:</li></ol><ul><li>首先你需要在plist文件中，设置可以返回不安全的请求（关闭该域名的ATS）。</li><li>其次，如果是<code>NSUrlSesion</code>，那么需要在代理方法实现如下（其实就是AF的相对于自签证书的实现的简化版）</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust]; </span><br><span class="line">    <span class="comment">// 确定挑战的方式</span></span><br><span class="line">    <span class="keyword">if</span> (credential) &#123; </span><br><span class="line">    <span class="comment">//证书挑战 则跑到这里</span></span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">       completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是AF，你则需要设置policy：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许自签名证书，必须的</span></span><br><span class="line">policy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//是否验证域名的CN字段</span></span><br><span class="line"><span class="comment">//不是必须的，但是如果写YES，则必须导入证书。</span></span><br><span class="line">policy.validatesDomainName = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-如果想验证服务器来源"><a href="#4-3-2-如果想验证服务器来源" class="headerlink" title="4.3.2 如果想验证服务器来源"></a>4.3.2 如果想验证服务器来源</h3><p>当然还可以根据需求，你可以去验证证书或者公钥，这一步的目的是实现：要求数据必须来自指定的服务器。</p><ul><li>如果是自签证书，需要把自签的服务端证书，或者自签的CA根证书导入到项目中。</li><li>如果是付费的公信机构颁发的证书，那也要把证书导入到项目中。</li></ul><img src="/images/AFN/AFN-07.jpg" alt="img" style="zoom:83%;" /><p>并且如下设置证书：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *certFilePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;AFUse_server.cer&quot;</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:certFilePath];</span><br><span class="line"><span class="built_in">NSSet</span> *certSet = [<span class="built_in">NSSet</span> setWithObjects:certData,certData, <span class="literal">nil</span>]; </span><br><span class="line">policy.pinnedCertificates = certSet;</span><br></pre></td></tr></table></figure><p>这样你就可以使用AF的不同<code>AFSSLPinningMode</code>去验证了。</p><p>这一步实现了防中间人攻击劫持，比如如果用 Charles 代理抓包，那么客户端中的请求 https 认证是无法通过的，<font color='red'><strong>报错：已取消。</strong></font>（一般AF中证书错误的code码是 -999，报错信息是已取消）。</p><h2 id="4-4-总结-AF之于https到底做了什么"><a href="#4-4-总结-AF之于https到底做了什么" class="headerlink" title="4.4 总结: AF之于https到底做了什么"></a>4.4 总结: AF之于https到底做了什么</h2><p>最后总结一下，AF之于https到底做了什么：</p><ul><li><strong>AF可以让你在系统验证证书之前，就去自主验证。</strong>然后如果自己验证不正确，直接取消网络请求。否则验证通过则继续进行系统验证。</li><li>讲到这，顺便提一下，系统验证的流程：首先是去系统的根证书找，看是否有能匹配服务端的证书，如果匹配，则验证成功，返回https的安全数据。</li><li>如果不匹配则去判断ATS是否关闭，如果关闭，则返回https不安全连接的数据。如果开启ATS，则拒绝这个请求，请求失败。</li></ul><p>总之一句话：<strong>AF的验证方式不是必须的，但是对有特殊验证需求的用户确是必要的</strong>。</p><p>写在结尾：</p><ul><li>看完之后，有些小伙伴可能还是会比较迷惑，建议还是不清楚的小伙伴，可以自己生成一个自签名的证书或者用百度地址等做请求，然后设置<code>AFSecurityPolicy</code>不同参数，打断点，一步步的看AF是如何去调用函数作证书验证的。相信这样能加深你的理解。</li><li>最后关于自签名证书的问题，等2017年1月1日，也没多久了…一个月不到。除非有特殊原因说明，否则已经无法审核通过了。详细的可以看看这篇文章：<a href="https://www.jianshu.com/p/36ddc5b009a7">iOS 10 适配 ATS（app支持https通过App Store审核）</a>。</li><li>苹果官网最新消息：原定于2017.1.1强制的https被延期了，具体延期到什么时候不确定，得等官方通知：</li></ul><h1 id="五、UIKit扩展与缓存实现"><a href="#五、UIKit扩展与缓存实现" class="headerlink" title="五、UIKit扩展与缓存实现"></a>五、UIKit扩展与缓存实现</h1><p>我们来看看AF对<code>UIkit</code>的扩展:</p><img src="/images/AFN/AFN-08.jpg" alt="img" style="zoom:67%;" /><p>一共如上这个多类，下面我们开始着重讲其中两个UIKit的扩展：</p><ul><li>一个是我们网络请求时状态栏的小菊花。</li><li>一个是我们几乎都用到过请求网络图片的如下一行方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url ;</span><br></pre></td></tr></table></figure><h2 id="5-1-AFNetworkActivityIndicatorManager"><a href="#5-1-AFNetworkActivityIndicatorManager" class="headerlink" title="5.1 AFNetworkActivityIndicatorManager"></a>5.1 AFNetworkActivityIndicatorManager</h2><p>这个类的作用相当简单，就是当网络请求的时候，状态栏上的小菊花就会开始转:</p><img src="/images/AFN/AFN-09.jpg" alt="img" style="zoom:100%;" /><p>需要的代码也很简单，只需在你需要它的位置中（比如AppDelegate）导入类，并加一行代码即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;AFNetworkActivityIndicatorManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>接下来我们来讲讲这个类的实现：</p><ul><li>这个类的实现也非常简单，还记得我们之前讲的AF对<code>NSURLSessionTask</code>中做了一个<strong>Method Swizzling</strong>吗？大意是把它的<code>resume</code>和<code>suspend</code>方法做了一个替换，在原有实现的基础上添加了一个通知的发送。</li><li>这个类就是基于这两个通知和task完成的通知来实现的。</li></ul><h3 id="5-1-1-初始化方法"><a href="#5-1-1-初始化方法" class="headerlink" title="5.1.1 初始化方法"></a>5.1.1 初始化方法</h3><p>首先我们来看看它的初始化方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkActivityManagerState) &#123;</span><br><span class="line">    <span class="comment">//没有请求</span></span><br><span class="line">    AFNetworkActivityManagerStateNotActive,</span><br><span class="line">    <span class="comment">//请求延迟开始</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingStart,</span><br><span class="line">    <span class="comment">//请求进行中</span></span><br><span class="line">    AFNetworkActivityManagerStateActive,</span><br><span class="line">    <span class="comment">//请求延迟结束</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingEnd</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* state一共如上4种状态，其中两种应该很好理解，而延迟开始和延迟结束怎么理解呢？</span></span><br><span class="line"><span class="comment">- 原来这是AF对请求菊花显示做的一个优化处理，试问如果一个请求时间很短，那么菊花很可能闪一下就结束了。如果很多请求过来，那么菊花会不停的闪啊闪，这显然并不是我们想要的效果。</span></span><br><span class="line"><span class="comment">- 所以多了这两个参数：</span></span><br><span class="line"><span class="comment">1）在一个请求开始的时候，我延迟一会在去转菊花，如果在这延迟时间内，请求结束了，那么我就不需要去转菊花了。</span></span><br><span class="line"><span class="comment">  2）但是一旦转菊花开始，哪怕很短请求就结束了，我们还是会去转一个时间再去结束，这时间就是延迟结束的时间。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerActivationDelay = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerCompletionDelay = <span class="number">0.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFNetworkActivityIndicatorManager</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkActivityIndicatorManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _sharedManager = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1. 设置状态为没有request活跃</span></span><br><span class="line">    <span class="keyword">self</span>.currentState = AFNetworkActivityManagerStateNotActive;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 监听了三个通知，用来监听当前正在进行的网络请求的状态。</span></span><br><span class="line">    <span class="comment">//开始下载通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidStart:) name:AFNetworkingTaskDidResumeNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//挂起通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidSuspendNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//完成通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 设置了我们前面提到的这个转菊花延迟开始和延迟结束的时间，</span></span><br><span class="line">    <span class="comment">//开始延迟</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelay = kDefaultAFNetworkActivityManagerActivationDelay;</span><br><span class="line">    <span class="comment">//结束延迟</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelay = kDefaultAFNetworkActivityManagerCompletionDelay;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2-通知触发调用的方法"><a href="#5-1-2-通知触发调用的方法" class="headerlink" title="5.1.2 通知触发调用的方法"></a>5.1.2 通知触发调用的方法</h3><p>接着我们来看看三个通知触发调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求开始</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidStart:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//增加请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> incrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidFinish:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//AFNetworkRequestFromNotification(notification)返回这个通知的request,用来判断request是否是有效的</span></span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//减少请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> decrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，就是开始的时候增加了请求活跃数，结束则减少。调用了如下两个方法进行加减：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)incrementActivityCount &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//活跃的网络数+1，并手动发送KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        _activityCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程去做</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)decrementActivityCount &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">        _activityCount = MAX(_activityCount - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法做了什么应该很容易看明白，这里需要注意的是，<strong>task的几个状态的通知，是会在多线程的环境下发送过来的</strong>。所以这里对活跃数的加减，都用了<code>@synchronized</code>这种方式的锁，进行了线程保护。然后回到主线程调用了<code>updateCurrentStateForNetworkActivityChange</code></p><p>我们接着来看看这个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateCurrentStateForNetworkActivityChange &#123;</span><br><span class="line">    <span class="comment">//1. 判断了我们一开始设置是否需要菊花的`self.enabled`，如果需要，才执行。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.enabled) &#123;</span><br><span class="line">        <span class="comment">// 2. 这里主要是根据当前的状态，来判断下一个状态应该是什么。</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.currentState) &#123;</span><br><span class="line">            <span class="comment">//不活跃</span></span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                <span class="comment">//判断活跃数，大于0为YES</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    <span class="comment">//设置状态为延迟开始</span></span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingStart];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                <span class="comment">//No op. Let the delay timer finish out.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingEnd];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有这么一个属性<code>self.isNetworkActivityOccurring</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否活跃</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isNetworkActivityOccurring &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activityCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-3-重写currentState的setter"><a href="#5-1-3-重写currentState的setter" class="headerlink" title="5.1.3 重写currentState的setter"></a>5.1.3 重写currentState的setter</h3><p>这个类复写了currentState的set方法，每当我们改变这个state，就会触发set方法，而怎么该转菊花也在该方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前小菊花状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setCurrentState:(AFNetworkActivityManagerState)currentState &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != currentState) &#123;</span><br><span class="line">            <span class="comment">//KVO</span></span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">            _currentState = currentState;</span><br><span class="line">            <span class="keyword">switch</span> (currentState) &#123;</span><br><span class="line">                <span class="comment">//如果为不活跃</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                    <span class="comment">//取消两个延迟用的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelActivationDelayTimer];</span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//设置小菊花不可见</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">NO</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                    <span class="comment">//开启一个定时器延迟去转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> startActivationDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果是活跃状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                    <span class="comment">//取消延迟完成的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//开始转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">YES</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//延迟完成状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                    <span class="comment">//开启延迟完成timer</span></span><br><span class="line">                    [<span class="keyword">self</span> startCompletionDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个set方法就是这个类最核心的方法了。它的作用如下：</p><ul><li>这里根据当前状态，是否需要开始执行一个延迟开始或者延迟完成，又或者是否需要取消这两个延迟。</li><li>还判断了，是否需要去转状态栏的菊花，调用了<code>setNetworkActivityIndicatorVisible:</code>方法：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setNetworkActivityIndicatorVisible:(<span class="built_in">BOOL</span>)networkActivityIndicatorVisible &#123;</span><br><span class="line">    <span class="keyword">if</span> (_networkActivityIndicatorVisible != networkActivityIndicatorVisible) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">             _networkActivityIndicatorVisible = networkActivityIndicatorVisible;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//支持自定义的Block，去自己控制小菊花</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityActionBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.networkActivityActionBlock(networkActivityIndicatorVisible);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则默认AF根据该Bool，去控制状态栏小菊花是否显示</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法就是用来控制菊花是否转。并且支持一个自定义的Block,我们可以自己去拿到这个菊花是否应该转的状态值，去做一些自定义的处理。</li><li>如果我们没有实现这个Block，则调用下面的方法去转菊花。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br></pre></td></tr></table></figure><p>回到state的set方法中，我们除了控制菊花去转，还调用了以下4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始任务到结束的时间，默认为1秒，如果1秒就结束，那么不转菊花，延迟去开始转</span></span><br><span class="line">- (<span class="keyword">void</span>)startActivationDelayTimer &#123;</span><br><span class="line">    <span class="comment">//只执行一次</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelayTimer = [<span class="built_in">NSTimer</span></span><br><span class="line">                                 timerWithTimeInterval:<span class="keyword">self</span>.activationDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(activationDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//添加到主线程runloop去触发</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.activationDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成任务到下一个任务开始，默认为0.17秒，如果0.17秒就开始下一个，那么不停  延迟去结束菊花转</span></span><br><span class="line">- (<span class="keyword">void</span>)startCompletionDelayTimer &#123;</span><br><span class="line">    <span class="comment">//先取消之前的</span></span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">    <span class="comment">//延迟执行让菊花不在转</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelayTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.completionDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(completionDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.completionDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelActivationDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.activationDelayTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelCompletionDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这4个方法分别是开始延迟执行一个方法，和结束的时候延迟执行一个方法，和对应这两个方法的取消。其作用，注释应该很容易理解。</p><p>我们继续往下看，这两个延迟调用的到底是什么：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)activationDelayTimerFired &#123;</span><br><span class="line">    <span class="comment">//活跃状态，即活跃数大于1才转</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityOccurring) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)completionDelayTimerFired &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个开始，一个完成调用，都设置了不同的currentState的值，又回到之前<code>state</code>的<code>set</code>方法中了。</p><p>至此这个<code>AFNetworkActivityIndicatorManager</code>类就讲完了，代码还是相当简单明了的。</p><h2 id="5-2-UIImageView-AFNetworking"><a href="#5-2-UIImageView-AFNetworking" class="headerlink" title="5.2 UIImageView+AFNetworking"></a>5.2 UIImageView+AFNetworking</h2><p>接下来我们来讲一个我们经常用的方法，这个方法的实现类是：<code>UIImageView+AFNetworking.h</code>。</p><p>这是个类目，并且给UIImageView扩展了4个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个UIImageView去异步的请求一张图片，并且可以设置一张占位图。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line"> placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一张图，并且可以拿到成功和失败的回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">      placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前的图片设置请求</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask;</span><br></pre></td></tr></table></figure><p><code>SDWebImage</code>、<code>YYKit</code>、<code>AF</code>都实现了这么个类目。AF关于这个类目<code>UIImageView+AFNetworking</code>的实现，<strong>依赖于这么两个类：<code>AFImageDownloader</code>，<code>AFAutoPurgingImageCache</code>。</strong></p><p>当然<code>AFImageDownloader</code>中，关于图片数据请求的部分，还是使用<code>AFURLSessionManager</code>来实现的。</p><h3 id="5-2-1-AFImageDownloader"><a href="#5-2-1-AFImageDownloader" class="headerlink" title="5.2.1 AFImageDownloader"></a>5.2.1 AFImageDownloader</h3><h4 id="1-先看初始化方法"><a href="#1-先看初始化方法" class="headerlink" title="1. 先看初始化方法"></a>1. 先看初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类为单例，上述方法中，创建了一个 sessionManager, 这个 sessionManager 将用于我们之后的网络请求。从这里我们可以看到，这个类的网络请求都是基于之前AF自己封装的 AFHTTPSessionManager。</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> AFImageDownloader *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="comment">// 在这里初始化了一系列的对象</span></span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *defaultConfiguration = [<span class="keyword">self</span>.class defaultURLSessionConfiguration];</span><br><span class="line">    AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:defaultConfiguration];</span><br><span class="line">    sessionManager.responseSerializer = [AFImageResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //这个枚举值代表着，一堆图片下载，执行任务的顺序</span></span><br><span class="line"><span class="comment">      typedef NS_ENUM(NSInteger, AFImageDownloadPrioritization) &#123;</span></span><br><span class="line"><span class="comment">          //先进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationFIFO,</span></span><br><span class="line"><span class="comment">          //后进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationLIFO</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionManager:sessionManager</span><br><span class="line">                 downloadPrioritization:AFImageDownloadPrioritizationFIFO <span class="comment">// </span></span><br><span class="line">                 maximumActiveDownloads:<span class="number">4</span></span><br><span class="line">                             imageCache:[[AFAutoPurgingImageCache alloc] init]]; </span><br><span class="line">  <span class="comment">// AFAutoPurgingImageCache这个类是AF做图片缓存用的。这里我们暂时就这么理解它，讲完当前类，我们再来补充它。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultURLSessionConfiguration &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO set the default HTTP headers</span></span><br><span class="line">  </span><br><span class="line">    configuration.HTTPShouldSetCookies = <span class="literal">YES</span>;</span><br><span class="line">    configuration.HTTPShouldUsePipelining = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    configuration.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</span><br><span class="line">    <span class="comment">//是否允许蜂窝网络，手机网</span></span><br><span class="line">    configuration.allowsCellularAccess = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//默认超时</span></span><br><span class="line">    configuration.timeoutIntervalForRequest = <span class="number">60.0</span>;</span><br><span class="line">    <span class="comment">//设置的图片缓存对象</span></span><br><span class="line">    configuration.URLCache = [AFImageDownloader defaultURLCache];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面我们看到除了<code>[[AFAutoPurgingImageCache alloc] init]</code>，还创建了一个cache：<code>[AFImageDownloader defaultURLCache]</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个系统缓存，内存缓存为20M，磁盘缓存为150M，</span></span><br><span class="line"><span class="comment">//这个是系统级别维护的缓存。</span></span><br><span class="line"> + (<span class="built_in">NSURLCache</span> *)defaultURLCache &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                         diskCapacity:<span class="number">150</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                             diskPath:<span class="string">@&quot;com.alamofire.imagedownloader&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到这可能迷惑了，怎么这么多cache，那AF做图片缓存到底用哪个呢？答案是AF自己控制的图片缓用 <code>AFAutoPurgingImageCache</code>，而 <code>NSUrlRequest</code> 的缓存由它自己内部根据策略去控制，用的是<code>NSURLCache</code>，不归AF处理，只需在configuration中设置上即可。</p><ul><li>那么看到这有些小伙伴又要问了，为什么不直接用<code>NSURLCache</code>，还要自定义一个<code>AFAutoPurgingImageCache</code>呢？原来是因为<code>NSURLCache</code>的诸多限制，例如只支持get请求等等。而且因为是系统维护的，我们自己的可控度不强，并且如果需要做一些自定义的缓存处理，无法实现。</li><li>更多关于<code>NSURLCache</code>的内容，大家可以自行查阅。</li></ul><p>接着上面的方法调用到这个最终的初始化方法中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionManager:(AFHTTPSessionManager *)sessionManager</span><br><span class="line">                downloadPrioritization:(AFImageDownloadPrioritization)downloadPrioritization</span><br><span class="line">                maximumActiveDownloads:(<span class="built_in">NSInteger</span>)maximumActiveDownloads</span><br><span class="line">                            imageCache:(<span class="keyword">id</span> &lt;AFImageRequestCache&gt;)imageCache &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">//持有</span></span><br><span class="line">        <span class="keyword">self</span>.sessionManager = sessionManager;</span><br><span class="line">        <span class="comment">//定义下载任务的顺序，默认FIFO，先进先出-队列模式，还有后进先出-栈模式</span></span><br><span class="line">        <span class="keyword">self</span>.downloadPrioritizaton = downloadPrioritization;</span><br><span class="line">        <span class="comment">//最大的下载数</span></span><br><span class="line">        <span class="keyword">self</span>.maximumActiveDownloads = maximumActiveDownloads;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义的cache</span></span><br><span class="line">        <span class="keyword">self</span>.imageCache = imageCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列中的任务，待执行的</span></span><br><span class="line">        <span class="keyword">self</span>.queuedMergedTasks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">//合并的任务，所有任务的字典</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">        <span class="comment">//活跃的request数</span></span><br><span class="line">        <span class="keyword">self</span>.activeRequestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用UUID来拼接名字</span></span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.synchronizationqueue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建一个串行的queue</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.responsequeue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建并行queue</span></span><br><span class="line">        <span class="keyword">self</span>.responseQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边初始化了一些属性，这些属性跟着注释看应该很容易明白其作用。主要需要注意的就是，这里创建了两个queue：<strong>一个串行的请求queue，和一个并行的响应queue。</strong></p><ul><li>这个串行queue,是用来做内部生成task等等一系列业务逻辑的。它保证了我们在这些逻辑处理中的线程安全问题（迷惑的接着往下看）。</li><li>这个并行queue，被用来做网络请求完成的数据回调。</li></ul><h4 id="2-再看创建请求task的方法"><a href="#2-再看创建请求task的方法" class="headerlink" title="2. 再看创建请求task的方法"></a>2. 再看创建请求task的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">        success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">UIImage</span> * ))success</span><br><span class="line">        failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">NSError</span> * ))failure </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> downloadImageForURLRequest:request withReceiptID:[<span class="built_in">NSUUID</span> UUID] </span><br><span class="line">            success:success failure:failure];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                  withReceiptID:(<span class="keyword">nonnull</span> <span class="built_in">NSUUID</span> *)receiptID</span><br><span class="line">        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="comment">//还是类似之前的，同步串行去做下载的事 生成一个task,这些事情都是在当前线程中串行同步做的，所以不用担心线程安全问题。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//url字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</span><br><span class="line">        <span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                <span class="comment">//错误返回，没Url</span></span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    failure(request, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个任务已经存在，则添加成功失败Block,然后直接返回，即一个url用一个request,可以响应好几个block</span></span><br><span class="line">        <span class="comment">//从自己task字典中根据Url去取AFImageDownloaderMergedTask，里面有task id url等等信息</span></span><br><span class="line">        AFImageDownloaderMergedTask *existingMergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        <span class="keyword">if</span> (existingMergedTask != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//里面包含成功和失败Block和UUid</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</span><br><span class="line">            <span class="comment">//添加handler</span></span><br><span class="line">            [existingMergedTask addResponseHandler:handler];</span><br><span class="line">            <span class="comment">//给task赋值</span></span><br><span class="line">            task = existingMergedTask.task;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据request的缓存策略，加载缓存</span></span><br><span class="line">        <span class="keyword">switch</span> (request.cachePolicy) &#123;</span><br><span class="line">            <span class="comment">//这3种情况都会去加载缓存</span></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</span><br><span class="line">                <span class="comment">//从cache中根据request拿数据</span></span><br><span class="line">                <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(request, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这说明即没有请求中的request,也没有cache,开始请求</span></span><br><span class="line">        <span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        <span class="comment">//task</span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *createdTask;</span><br><span class="line">        __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用sessionManager的去请求，注意，只是创建task,还是挂起状态</span></span><br><span class="line">        createdTask = [<span class="keyword">self</span>.sessionManager</span><br><span class="line">                       dataTaskWithRequest:request</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">//在responseQueue中回调数据,初始化为并行queue</span></span><br><span class="line">                           <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.responseQueue, ^&#123;</span><br><span class="line">                               __<span class="keyword">strong</span> __typeof__(weakSelf) strongSelf = weakSelf;</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//拿到当前的task</span></span><br><span class="line">                               AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//如果之前的task数组中，有这个请求的任务task，则从数组中移除</span></span><br><span class="line">                               <span class="keyword">if</span> ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</span><br><span class="line">                                   <span class="comment">//安全的移除，并返回当前被移除的AF task</span></span><br><span class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">                                   <span class="comment">//请求错误</span></span><br><span class="line">                                   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                       <span class="comment">//去遍历task所有响应的处理</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="comment">//主线程，调用失败的Block</span></span><br><span class="line">                                           <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.failureBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, error);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                       <span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                                       <span class="comment">//调用成功Block</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="keyword">if</span> (handler.successBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.successBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, responseObject);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                       </span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">//减少活跃的任务数</span></span><br><span class="line">                               [strongSelf safelyDecrementActiveTaskCount];</span><br><span class="line">                               [strongSelf safelyStartNextTaskIfNecessary];</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) Store the response handler for use when the request completes</span></span><br><span class="line">        <span class="comment">//创建handler</span></span><br><span class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</span><br><span class="line">                                                                                                   success:success</span><br><span class="line">                                                                                                   failure:failure];</span><br><span class="line">        <span class="comment">//创建task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</span><br><span class="line">                                                   initWithURLIdentifier:URLIdentifier</span><br><span class="line">                                                   identifier:mergedTaskIdentifier</span><br><span class="line">                                                   task:createdTask];</span><br><span class="line">        <span class="comment">//添加handler</span></span><br><span class="line">        [mergedTask addResponseHandler:handler];</span><br><span class="line">        <span class="comment">//往当前任务字典里添加任务</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) Either start the request or enqueue it depending on the current active request count</span></span><br><span class="line">        <span class="comment">//如果小于，则开始任务下载resume</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到最终生成的task</span></span><br><span class="line">        task = mergedTask.task;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        <span class="comment">//创建一个AFImageDownloadReceipt并返回，里面就多一个receiptID。</span></span><br><span class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么一个非常非常长的方法，这个方法执行的内容都是在我们之前创建的串行queue中，同步的执行的，这是因为这个方法绝大多数的操作都是需要线程安全的。可以对着源码和注释来看，我们在这讲下它做了什么：</p><h5 id="1-判断url是否为空"><a href="#1-判断url是否为空" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>首先做了一个url的判断，如果为空则返回失败Block。</p><h5 id="2-判断是否是已生成task"><a href="#2-判断是否是已生成task" class="headerlink" title="2) 判断是否是已生成task"></a>2) 判断是否是已生成task</h5><p>判断这个需要请求的url，是不是已经被生成的task中，如果是的话，则多添加一个回调处理就可以。</p><h5 id="2-1-AFImageDownloaderResponseHandler"><a href="#2-1-AFImageDownloaderResponseHandler" class="headerlink" title="2-1) AFImageDownloaderResponseHandler"></a>2-1) AFImageDownloaderResponseHandler</h5><p>回调处理对象为<code>AFImageDownloaderResponseHandler</code>。这个类非常简单，总共就如下3个属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderResponseHandler</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderResponseHandler</span></span></span><br><span class="line"><span class="comment">//初始化回调对象</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithUUID:(<span class="built_in">NSUUID</span> *)uuid</span><br><span class="line">                     success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">                     failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.uuid = uuid;</span><br><span class="line">        <span class="keyword">self</span>.successBlock = success;</span><br><span class="line">        <span class="keyword">self</span>.failureBlock = failure;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个task完成的时候，会调用我们添加的回调。</p><h5 id="2-2-AFImageDownloaderMergedTask"><a href="#2-2-AFImageDownloaderMergedTask" class="headerlink" title="2-2) AFImageDownloaderMergedTask"></a>2-2) AFImageDownloaderMergedTask</h5><p>关于<code>AFImageDownloaderMergedTask</code>，我们在这里都用的是这种类型的task，其实这个task也很简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderMergedTask</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;AFImageDownloaderResponseHandler*&gt; *responseHandlers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderMergedTask</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier identifier:(<span class="built_in">NSUUID</span> *)identifier task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URLIdentifier = URLIdentifier;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line">        <span class="keyword">self</span>.responseHandlers = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)addResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers addObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)removeResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers removeObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>其实就是除了<code>NSURLSessionDataTask</code>，多加了几个参数，<code>URLIdentifier</code>和<code>identifier</code>都是用来标识这个task的，responseHandlers是用来存储task完成后的回调的，里面可以存一组，当任务完成时候，里面的回调都会被调用。</p><h5 id="3-判断缓存是否存在"><a href="#3-判断缓存是否存在" class="headerlink" title="3. 判断缓存是否存在"></a>3. 判断缓存是否存在</h5><p>接着去根据缓存策略，去加载缓存，如果有缓存，从<code>self.imageCache</code>中返回缓存，否则继续往下走。</p><h5 id="4-创建NSURLSessionDataTask并设置完成回调"><a href="#4-创建NSURLSessionDataTask并设置完成回调" class="headerlink" title="4. 创建NSURLSessionDataTask并设置完成回调"></a>4. 创建NSURLSessionDataTask并设置完成回调</h5><p>走到这说明没相同url的task，也没有cache，那么就开始一个新的task，调用的是<code>AFUrlSessionManager</code>里的请求方法生成了一个task（前面已经说过，不赘述）。</p><p>同时做了请求完成的处理。注意，这里处理是在我们一开始初始化的并行queue:<code>self.responseQueue</code>中的，这里的响应处理是多线程并发进行的。</p><p>完成后：</p><ol><li>调用如下方法把这个task从全局字典中移除：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除task相关，用同步串行的形式，防止移除中出现重复移除一系列问题</span></span><br><span class="line">- (AFImageDownloaderMergedTask*)safelyRemoveMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    __block AFImageDownloaderMergedTask *mergedTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        mergedTask = [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据task的成功或失败情况，去循环这个task的<code>responseHandlers</code>，分别调用它的成功或者失败的回调。</li><li>如果成功，把成功请求到的数据，加到AF自定义的cache中：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">[<span class="meta">strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil</span>];</span><br></pre></td></tr></table></figure><ol start="4"><li>并且调用下面两个方法，去减少正在请求的任务数，和开启下一个任务：</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//减少活跃的任务数</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</span><br><span class="line">    <span class="comment">//回到串行queue去-</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果可以，则开启下一个任务</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyStartNextTaskIfNecessary &#123;</span><br><span class="line">    <span class="comment">//回到串行queue</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//先判断并行数限制</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">self</span>.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取数组中第一个task</span></span><br><span class="line">                AFImageDownloaderMergedTask *mergedTask = [<span class="keyword">self</span> dequeueMergedTask];</span><br><span class="line">                <span class="comment">//如果状态是挂起状态</span></span><br><span class="line">                <span class="keyword">if</span> (mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，跟我们本类的一些数据相关的操作，<strong>都是在我们一开始的串行queue中同步进行的。</strong></p><h5 id="5-创建ResponseHandler和MergedTask"><a href="#5-创建ResponseHandler和MergedTask" class="headerlink" title="5. 创建ResponseHandler和MergedTask"></a>5. 创建ResponseHandler和MergedTask</h5><p>用<code>NSUUID</code>生成的唯一标识，去生成<code>AFImageDownloaderResponseHandler</code>，然后生成一个<code>AFImageDownloaderMergedTask</code>，把之前第5步生成的<code>createdTask</code>和回调都绑定给这个AF自定义可合并回调的task，然后这个task加到全局的task映射字典中，key为url:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br></pre></td></tr></table></figure><h5 id="6-判断当前并行数是否超限"><a href="#6-判断当前并行数是否超限" class="headerlink" title="6. 判断当前并行数是否超限"></a>6. 判断当前并行数是否超限</h5><p>判断当前正在下载的任务是否超过最大并行数，如果没有则开始下载，否则先加到等待的数组中去:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果小于最大并行数，则开始任务下载resume</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断并行数限制</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isActiveRequestCountBelowMaximumLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeRequestCount &lt; <span class="keyword">self</span>.maximumActiveDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载</span></span><br><span class="line"> - (<span class="keyword">void</span>)startMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    [mergedTask.task resume];</span><br><span class="line">    <span class="comment">//任务活跃数+1</span></span><br><span class="line">    ++<span class="keyword">self</span>.activeRequestCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把任务先加到数组里</span></span><br><span class="line"> - (<span class="keyword">void</span>)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.downloadPrioritizaton) &#123;</span><br><span class="line">            <span class="comment">//先进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationFIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks addObject:mergedTask];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//后进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationLIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks insertObject:mergedTask atIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断并行数限制，如果小于最大限制，则开始下载，把当前活跃的request数量+1。</li><li>如果暂时不能下载，被加到等待下载的数组中去的话，会根据我们一开始设置的下载策略，是先进先出，还是后进先出，去插入这个下载任务。</li></ul><h5 id="7-创建AFImageDownloadReceipt"><a href="#7-创建AFImageDownloadReceipt" class="headerlink" title="7. 创建AFImageDownloadReceipt"></a>7. 创建AFImageDownloadReceipt</h5><p>最后判断这个mergeTask是否为空。不为空，我们生成了一个<code>AFImageDownloadReceipt</code>，绑定了一个UUID，否则为空返回nil。这个<code>AFImageDownloadReceipt</code>仅仅是多封装了一个UUID:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloadReceipt</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloadReceipt</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithReceiptID:(<span class="built_in">NSUUID</span> *)receiptID task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.receiptID = receiptID;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么封装是为了标识每一个task，我们后面可以根据这个<code>AFImageDownloadReceipt</code>来对task做取消操作。</p><h4 id="3-取消task"><a href="#3-取消task" class="headerlink" title="3. 取消task"></a>3. 取消task</h4><p>这个<code>AFImageDownloader</code>中最核心的方法基本就讲完了，还剩下一些方法没讲，像前面讲到的task的取消的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据AFImageDownloadReceipt来取消任务，即对应一个响应回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//拿到url</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</span><br><span class="line">        <span class="comment">//根据url拿到task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快速遍历查找某个下标，如果返回YES，则index为当前下标</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> index = [mergedTask.responseHandlers indexOfObjectPassingTest:^<span class="built_in">BOOL</span>(AFImageDownloaderResponseHandler * _Nonnull handler, __unused <span class="built_in">NSUInteger</span> idx, __unused <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> handler.uuid == imageDownloadReceipt.receiptID;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">//移除响应处理</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</span><br><span class="line">            [mergedTask removeResponseHandler:handler];</span><br><span class="line">            <span class="built_in">NSString</span> *failureReason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ImageDownloader cancelled URL request: %@&quot;</span>,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>:failureReason&#125;;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorCancelled</span> userInfo:userInfo];</span><br><span class="line">            <span class="comment">//并调用失败block，原因为取消</span></span><br><span class="line">            <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果任务里的响应回调为空或者状态为挂起，则取消task,并且从字典中移除</span></span><br><span class="line">        <span class="keyword">if</span> (mergedTask.responseHandlers.count == <span class="number">0</span> &amp;&amp; mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">            [mergedTask.task cancel];</span><br><span class="line">            [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据URLIdentifier移除task</span></span><br><span class="line">- (AFImageDownloaderMergedTask *)removeMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">    [<span class="keyword">self</span>.mergedTasks removeObjectForKey:URLIdentifier];</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法比较简单，大家自己看看就好。至此```AFImageDownloader``这个类讲完了。如果大家看的感觉比较绕，没关系，等到最后我们一起来总结一下，捋一捋。</p><h3 id="5-2-2-AFAutoPurgingImageCache"><a href="#5-2-2-AFAutoPurgingImageCache" class="headerlink" title="5.2.2 AFAutoPurgingImageCache"></a>5.2.2 AFAutoPurgingImageCache</h3><p>我们之前讲到<code>AFAutoPurgingImageCache</code>这个类略过去了，现在我们就来补充一下这个类的相关内容：</p><p>首先来讲讲这个类的作用，它是AF自定义用来做图片缓存的。</p><h4 id="1-下文要用到的AFCachedImage"><a href="#1-下文要用到的AFCachedImage" class="headerlink" title="1. 下文要用到的AFCachedImage"></a>1. 下文要用到的AFCachedImage</h4><p>关于这个<code>AFCachedImage</code>，其实就是Image之外封装了几个关于这个缓存的参数，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFCachedImage</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;  <span class="comment">//url标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;   <span class="comment">//总大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;  <span class="comment">//上次获取时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage; <span class="comment">//这个参数没被用到过</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFCachedImage</span></span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"> -(<span class="keyword">instancetype</span>)initWithImage:(<span class="built_in">UIImage</span> *)image identifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = image;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerPixel = <span class="number">4.0</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        <span class="keyword">self</span>.totalBytes = (<span class="built_in">UInt64</span>)bytesPerPixel * (<span class="built_in">UInt64</span>)bytesPerSize;</span><br><span class="line">        <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次获取缓存的时间</span></span><br><span class="line"> - (<span class="built_in">UIImage</span>*)accessImage &#123;</span><br><span class="line">    <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2. 初始化方法"></a>2. 初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//默认为内存100M，后者为缓存溢出后保留的内存</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithMemoryCapacity:<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span> preferredMemoryCapacity:<span class="number">60</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMemoryCapacity:(<span class="built_in">UInt64</span>)memoryCapacity preferredMemoryCapacity:(<span class="built_in">UInt64</span>)preferredMemoryCapacity &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//1. 声明了一个默认的内存缓存大小100M，还有一个意思是如果超出100M之后，我们去清除缓存，此时仍要保留的缓存大小60M。（如果还是不理解，可以看后文，源码中会讲到）</span></span><br><span class="line">        <span class="keyword">self</span>.memoryCapacity = memoryCapacity;</span><br><span class="line">        <span class="keyword">self</span>.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 创建了一个cache字典，我们所有的缓存数据，都被保存在这个字典中，key为url，value为`AFCachedImage`。</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.autopurgingimagecache-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 创建了一个并行queue，这个并行queue，这个类除了初始化以外，所有的方法都是在这个并行queue中调用的。</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//4. 添加了一个通知，监听内存警告，当发生内存警告，调用该方法，移除所有的缓存，并且把当前缓存数置为0：</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">         addObserver:<span class="keyword">self</span></span><br><span class="line">         selector:<span class="keyword">@selector</span>(removeAllImages)</span><br><span class="line">         name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">         object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有图片</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)removeAllImages &#123;</span><br><span class="line">    __block <span class="built_in">BOOL</span> removed = <span class="literal">NO</span>;</span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cachedImages.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cachedImages removeAllObjects];</span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage = <span class="number">0</span>;</span><br><span class="line">            removed = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类大量的使用了<code>dispatch_barrier_sync</code>与<code>dispatch_barrier_async</code>，小伙伴们如果对这两个方法有任何疑惑，可以看看这篇文章：<a href="http://blog.csdn.net/u013046795/article/details/47057585">dispatch_barrier_async与dispatch_barrier_sync异同</a>。</p><ul><li><p>这里我们可以看到使用了<code>dispatch_barrier_sync</code>，这里没有用锁，但是因为使用了<code>dispatch_barrier_sync</code>，不仅同步了<code>synchronizationQueue</code>队列，而且阻塞了当前线程，所以保证了里面执行代码的线程安全问题。</p></li><li><p>在这里其实使用锁也可以，但是AF在这的处理却是使用同步的机制来保证线程安全，<strong>或许这跟图片的加载缓存的使用场景，高频次有关系</strong>，在这里使用sync，并不需要在去开辟新的线程，浪费性能，只需要在原有线程，提交到<code>synchronizationQueue</code>队列中，阻塞的执行即可。这样省去大量的开辟线程与使用锁带来的性能消耗。（当然这仅仅是我的一个猜测，有不同意见的朋友欢迎讨论~）</p><ul><li>在这里用了<code>dispatch_barrier_sync</code>，因为<code>synchronizationQueue</code>是个并行queue，所以在这里不会出现死锁的问题。</li><li>关于保证线程安全的同时，同步还是异步，与性能方面的考量，可以参考这篇文章：<a href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a>。</li></ul></li></ul><h4 id="3-核心方法addImage"><a href="#3-核心方法addImage" class="headerlink" title="3. 核心方法addImage:"></a>3. 核心方法addImage:</h4><p>接着我们来看看这个类最核心的一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加image到cache里</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image withIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用dispatch_barrier_async，来同步这个并行队列</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//生成cache对象</span></span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去之前cache的字典里取</span></span><br><span class="line">        AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//如果有被缓存过</span></span><br><span class="line">        <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//当前已经使用的内存大小减去图片的大小</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新cache的image加上去</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</span><br><span class="line">        <span class="comment">//加上内存大小</span></span><br><span class="line">        <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做缓存溢出的清除，清除的是早期的缓存</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//如果使用的内存大于我们设置的内存容量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</span><br><span class="line">            <span class="comment">//拿到使用内存 - 被清空后首选内存 =  需要被清除的内存</span></span><br><span class="line">            <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</span><br><span class="line">            <span class="comment">//拿到所有缓存的数据</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据lastAccessDate排序 升序，越晚的越后面</span></span><br><span class="line">            <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@&quot;lastAccessDate&quot;</span></span><br><span class="line">                                                                           ascending:<span class="literal">YES</span>];</span><br><span class="line">            </span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//移除早期的cache bytesToPurge大小</span></span><br><span class="line">            <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减去被清掉的内存</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释应该很容易明白，这个方法做了两件事：</p><ol><li>设置缓存到字典里，并且把对应的缓存大小设置到当前已缓存的数量属性中。</li><li>判断是缓存超出了我们设置的最大缓存100M，如果是的话，则清除掉部分早时间的缓存，清除到缓存小于我们溢出后保留的内存60M以内。</li></ol><p>当然在这里更需要说一说的是<code>dispatch_barrier_async</code>，这里整个类都没有使用<code>dispatch_async</code>，所以不存在是为了做一个栅栏，来同步上下文的线程。其实它在本类中的作用很简单，就是一个串行执行。</p><ul><li>讲到这，小伙伴们又疑惑了，既然就是只是为了串行，那为什么我们不用一个串行queue就得了？非得用<code>dispatch_barrier_async</code>干嘛？其实小伙伴要是看的仔细，就明白了，上文我们说过，我们要用<code>dispatch_barrier_sync</code>来保证线程安全。<strong>如果我们使用串行queue,那么线程是极其容易死锁的。</strong></li></ul><h4 id="4-其他几个方法"><a href="#4-其他几个方法" class="headerlink" title="4. 其他几个方法"></a>4. 其他几个方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id获取图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//用同步的方式获取，防止线程安全问题</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//并且刷新获取的时间</span></span><br><span class="line">        image = [cachedImage accessImage];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier添加cache</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image forRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    [<span class="keyword">self</span> addImage:image withIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier移除图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeImageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> removeImageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据request和additionalIdentifier获取图片</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> imageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成id的方式为Url字符串+additionalIdentifier</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</span><br><span class="line">    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>) &#123;</span><br><span class="line">        key = [key stringByAppendingString:additionalIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法都很简单，大家自己看看就好了，就不赘述了。至此<code>AFAutoPurgingImageCache</code>也讲完了，我们还是等到最后再来总结。</p><h3 id="5-2-3-UIImageView-AFNetworking"><a href="#5-2-3-UIImageView-AFNetworking" class="headerlink" title="5.2.3 UIImageView+AFNetworking"></a>5.2.3 UIImageView+AFNetworking</h3><p>我们绕了一大圈，总算回到了<code>UIImageView+AFNetworking</code>这个类，现在图片下载的方法，和缓存的方法都有了，实现这个类也是水到渠成的事了。</p><h4 id="1-setImageWithURL"><a href="#1-setImageWithURL" class="headerlink" title="1. setImageWithURL:"></a>1. setImageWithURL:</h4><p>我们来看下面我们绝大多数人很熟悉的方法，看看它的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> setImageWithURL:url placeholderImage:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">       placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置head，可接受类型为image</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    [request addValue:<span class="string">@&quot;image/*&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Accept&quot;</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setImageWithURLRequest:request placeholderImage:placeholderImage success:<span class="literal">nil</span> failure:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法按顺序往下调用，第二个方法给head的Accept类型设置为Image。接着调用到第三个方法，也是这个类目唯一一个重要的方法：</p><h4 id="2-setImageWithURLRequest"><a href="#2-setImageWithURLRequest" class="headerlink" title="2. setImageWithURLRequest:"></a>2. setImageWithURLRequest:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">              placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//url为空，则取消</span></span><br><span class="line">    <span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消task</span></span><br><span class="line">        [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line">        <span class="comment">//设置为占位图</span></span><br><span class="line">        <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看设置的当前的回调的request和需要请求的request是不是为同一个，是的话为重复调用，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveTaskURLEqualToURLRequest:urlRequest])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始请求前，先取消之前的task,即解绑回调</span></span><br><span class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到downloader</span></span><br><span class="line">    AFImageDownloader *downloader = [[<span class="keyword">self</span> <span class="keyword">class</span>] sharedImageDownloader];</span><br><span class="line">    <span class="comment">//拿到cache</span></span><br><span class="line">    <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Use the image from the image cache if it exists</span></span><br><span class="line">    <span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//去获取cachedImage</span></span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//有的话直接设置，并且置空回调</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = cachedImage;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无缓存，如果有占位图，先设置</span></span><br><span class="line">        <span class="keyword">if</span> (placeholderImage) &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        AFImageDownloadReceipt *receipt;</span><br><span class="line">        <span class="comment">//去下载，并得到一个receipt，可以用来取消回调</span></span><br><span class="line">        receipt = [downloader</span><br><span class="line">                   downloadImageForURLRequest:urlRequest</span><br><span class="line">                   withReceiptID:downloadID</span><br><span class="line">                   success:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> * _Nonnull responseObject) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//判断receiptID和downloadID是否相同 成功回调，设置图片</span></span><br><span class="line">                       <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                               success(request, response, responseObject);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(responseObject) &#123;</span><br><span class="line">                               strongSelf.image = responseObject;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//置空回调</span></span><br><span class="line">                           [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   failure:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//失败有failuerBlock就回调，</span></span><br><span class="line">                        <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                failure(request, response, error);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//置空回调对象</span></span><br><span class="line">                            [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                        &#125;</span><br><span class="line">                   &#125;];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">self</span>.af_activeImageDownloadReceipt = receipt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，细节的地方可以关注注释，这里总结一下做了什么：</p><h5 id="1-判断url是否为空-1"><a href="#1-判断url是否为空-1" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>如果为空则取消task，调用如下方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearActiveDownloadInformation &#123;</span><br><span class="line">    <span class="keyword">self</span>.af_activeImageDownloadReceipt = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意<code>cancelImageDownloadTask</code>中，调用了<code>self.af_activeImageDownloadReceipt</code>这么一个属性，看看定义的地方：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">setter</span> = af_setActiveImageDownloadReceipt:) AFImageDownloadReceipt *af_activeImageDownloadReceipt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="comment">//绑定属性 AFImageDownloadReceipt，就是一个事件响应的接受对象，包含一个task，一个uuid</span></span><br><span class="line"> - (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</span><br><span class="line">    <span class="keyword">return</span> (AFImageDownloadReceipt *)objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"> - (<span class="keyword">void</span>)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们现在是给<code>UIImageView</code>添加的一个类目，所以我们无法直接添加属性，而是使用的是runtime的方式来生成set和get方法生成了一个<code>AFImageDownloadReceipt</code>类型的属性。看过上文应该知道这个对象里面就一个task和一个UUID。这个属性就是我们这次下载任务相关联的信息。</p><h5 id="2-做了一系列判断，见注释"><a href="#2-做了一系列判断，见注释" class="headerlink" title="2) 做了一系列判断，见注释"></a>2) 做了一系列判断，见注释</h5><h5 id="3-创建AFImageDownloader并判断缓存"><a href="#3-创建AFImageDownloader并判断缓存" class="headerlink" title="3) 创建AFImageDownloader并判断缓存"></a>3) 创建AFImageDownloader并判断缓存</h5><p>然后生成了一个我们之前分析过得<code>AFImageDownloader</code>，然后去获取缓存，如果有缓存，则直接读缓存。还记得<code>AFImageDownloader</code>里也有一个读缓存的方法么？那个是和cachePolicy相关的，而这个是有缓存的话直接读取。不明白的可以回过头去看看。</p><h5 id="4-请求图片"><a href="#4-请求图片" class="headerlink" title="4) 请求图片"></a>4) 请求图片</h5><p>走到这说明没缓存了，然后就去用<code>AFImageDownloader</code>，我们之前讲过的方法，去请求图片。完成后，则调用成功或者失败的回调，并且置空属性<code>self.af_activeImageDownloadReceipt</code>，成功则设置图片。</p><h4 id="3-cancelImageDownloadTask"><a href="#3-cancelImageDownloadTask" class="headerlink" title="3. cancelImageDownloadTask"></a>3. cancelImageDownloadTask</h4><p>还有一个取消这次任务的方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也是去调用我们之前讲过的<code>AFImageDownloader</code>的取消方法。</p><p>这个类总共就这么几行代码，就完成了我们几乎没有人不用的，设置ImageView图片的方法。当然真正的难点在于<code>AFImageDownloader</code>和<code>AFAutoPurgingImageCache</code>。</p><h3 id="5-2-4-总结"><a href="#5-2-4-总结" class="headerlink" title="5.2.4 总结"></a>5.2.4 总结</h3><p>接下来我们来总结一下整个请求图片，缓存，然后设置图片的流程：</p><ul><li>调用<code>- (void)setImageWithURL:(NSURL *)url;</code>时，我们生成 <code>AFImageDownloader</code>单例，并替我们请求数据。</li><li>而<code>AFImageDownloader</code>会生成一个<code>AFAutoPurgingImageCache</code>替我们缓存生成的数据。当然我们设置的时候，给<code>session</code>的<code>configuration</code>设置了一个系统级别的缓存<code>NSUrlCache</code>,这两者是互相独立工作的，互不影响的。</li><li>然后<code>AFImageDownloader</code>，就实现下载和协调<code>AFAutoPurgingImageCache</code>去缓存，还有一些取消下载的方法。然后通过回调把数据给到我们的类目<code>UIImageView+AFNetworking</code>,如果成功获取数据，则由类目设置上图片，整个流程结束。</li></ul><p>经过这三个文件： <code>UIImageView+AFNetworking</code>、<code>AFImageDownloader</code>、<code>AFAutoPurgingImageCache</code>，至此整个设置网络图片的方法结束了。</p><p>写在最后：对于UIKit的总结，我们就到此为止了，其它部分的扩展，小伙伴们可以自行阅读，都很简单，基本上每个类200行左右的代码。核心功能基本上都是围绕<code>AFURLSessionManager</code>实现的。</p><h1 id="六、AF2-x与AF3-x"><a href="#六、AF2-x与AF3-x" class="headerlink" title="六、AF2.x与AF3.x"></a>六、AF2.x与AF3.x</h1><p>以下是<strong>涉及AF2.x的核心实现，与AF3.x最新版本之间的对比，以及本系列的一个最终总结：AFNetworking到底做了什么？</strong></p><h2 id="6-1-源码结构"><a href="#6-1-源码结构" class="headerlink" title="6.1 源码结构"></a>6.1 源码结构</h2><p>首先我们来看看AF2.x的项目目录:</p><img src="/images/AFN/AFN-10.jpg" alt="img" style="zoom:70%;" /><p>除了UIKit扩展外，大概就是上述这么多类，其中最重要的有3个类：</p><ul><li>AFURLConnectionOperation：大家都知道，AF2.x是基于<code>NSURLConnection</code>来封装的，而<code>NSURLConnection</code>的创建以及数据请求，就被封装在这个类中。所以这个类基本上是AF2.x最底层也是最核心的类。</li><li>AFHTTPRequestOperation：继承自<code>AFURLConnectionOperation</code>，对它父类一些方法做了些封装。</li><li>AFHTTPRequestOperationManager：则是一个管家，去管理这些这些<code>operation</code>。</li></ul><p>我们接下来按照网络请求的流程去看看AF2.x的实现：</p><p>注：本文会涉及一些<code>NSOperationQueue</code>、<code>NSOperation</code>方面的知识，如果对这方面的内容不了解的话，可以先看看雷纯峰的这篇：<a href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues </a></p><p>首先，我们来写一个get或者post请求：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:url parameters:params</span><br><span class="line">     success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure><p>就这么简单的几行代码，完成了一个网络请求。</p><h2 id="6-2-AFHTTPRequestOperationManager"><a href="#6-2-AFHTTPRequestOperationManager" class="headerlink" title="6.2 AFHTTPRequestOperationManager"></a>6.2 AFHTTPRequestOperationManager</h2><h3 id="6-2-1-初始化方法"><a href="#6-2-1-初始化方法" class="headerlink" title="6.2.1 初始化方法"></a>6.2.1 初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    <span class="comment">//用来调度所有请求的queue</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="comment">//是否做证书验证</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法很简单，基本和AF3.x类似，除了以下两点：</p><ol><li>设置了一个<code>operationQueue</code>，这个队列，用来调度里面所有的<code>operation</code>，在AF2.x中，每一个<code>operation</code>就是一个网络请求。</li><li>设置<code>shouldUseCredentialStorage</code>为YES，这个后面会传给<code>operation</code>，<code>operation</code>会根据这个值，去返回给代理，系统是否做https的证书验证。</li></ol><h3 id="6-2-2-get方法及AFHTTPRequestOperation创建"><a href="#6-2-2-get方法及AFHTTPRequestOperation创建" class="headerlink" title="6.2.2 get方法及AFHTTPRequestOperation创建"></a>6.2.2 get方法及AFHTTPRequestOperation创建</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                     parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                        success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                        failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 用 self.requestSerializer 生成了一个request，至于如何生成，可以参考之前的文章，这里就不赘述了。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2. 生成了一个 AFHTTPRequestOperation，然后把这个 operation 加到我们一开始创建的 queue 中。</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [<span class="keyword">self</span> HTTPRequestOperationWithRequest:request success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中创建<code>AFHTTPRequestOperation</code>方法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 方法创建了一个 AFHTTPRequestOperation ，并把自己的一些参数交给了这个 operation 处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建自定义的AFHTTPRequestOperation</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">    operation.responseSerializer = <span class="keyword">self</span>.responseSerializer;</span><br><span class="line">    operation.shouldUseCredentialStorage = <span class="keyword">self</span>.shouldUseCredentialStorage;</span><br><span class="line">    operation.credential = <span class="keyword">self</span>.credential;</span><br><span class="line">    <span class="comment">//设置自定义的安全策略</span></span><br><span class="line">    operation.securityPolicy = <span class="keyword">self</span>.securityPolicy;</span><br><span class="line"></span><br><span class="line">    [operation setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    operation.completionQueue = <span class="keyword">self</span>.completionQueue;</span><br><span class="line">    operation.completionGroup = <span class="keyword">self</span>.completionGroup;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AFHTTPRequestOperation的初始化方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h2 id="6-3-AFURLConnectionOperation"><a href="#6-3-AFURLConnectionOperation" class="headerlink" title="6.3 AFURLConnectionOperation"></a>6.3 AFURLConnectionOperation</h2><h3 id="6-3-1-初始化方法"><a href="#6-3-1-初始化方法" class="headerlink" title="6.3.1 初始化方法"></a>6.3.1 初始化方法</h3><p>首先我们要明确<strong>这个类是继承自NSOperation的</strong>，然后我们接着往下看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(urlRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为ready</span></span><br><span class="line">    _state = AFOperationReadyState;</span><br><span class="line">    <span class="comment">//递归锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = kAFNetworkingLockName;</span><br><span class="line">    <span class="keyword">self</span>.runLoopModes = [<span class="built_in">NSSet</span> setWithObject:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="keyword">self</span>.request = urlRequest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否应该咨询证书存储连接</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//https认证策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法中，初始化了一些属性，下面我们来简单的介绍一下这些属性：</p><h3 id="6-3-2-成员变量和属性"><a href="#6-3-2-成员变量和属性" class="headerlink" title="6.3.2 成员变量和属性"></a>6.3.2 成员变量和属性</h3><h4 id="1-属性state和重写setter"><a href="#1-属性state和重写setter" class="headerlink" title="1. 属性state和重写setter"></a>1. 属性state和重写setter</h4><p><code>_state</code>设置为<code>AFOperationReadyState</code> 准备就绪状态，这是个枚举：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFOperationState) &#123;</span><br><span class="line">    AFOperationPausedState      = <span class="number">-1</span>,  <span class="comment">//停止</span></span><br><span class="line">    AFOperationReadyState       = <span class="number">1</span>,   <span class="comment">//准备就绪</span></span><br><span class="line">    AFOperationExecutingState   = <span class="number">2</span>,  <span class="comment">//正在进行中</span></span><br><span class="line">    AFOperationFinishedState    = <span class="number">3</span>,  <span class="comment">//完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本类重写了state的setter方法，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setState:(AFOperationState)state &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断从当前状态到另一个状态是不是合理，在加上现在是否取消。。大神的框架就是屌啊，这判断严谨的。。一层层</span></span><br><span class="line">    <span class="keyword">if</span> (!AFStateTransitionIsValid(<span class="keyword">self</span>.state, state, [<span class="keyword">self</span> isCancelled])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到对应的父类管理当前线程周期的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *oldStateKey = AFKeyPathFromOperationState(<span class="keyword">self</span>.state);</span><br><span class="line">    <span class="built_in">NSString</span> *newStateKey = AFKeyPathFromOperationState(state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:oldStateKey];</span><br><span class="line">    _state = state;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:oldStateKey];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_state</code>标志着这个网络请求的状态，一共如上4种状态。这些状态其实对应着<code>operation</code>如下的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射这个operation的各个状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NSString * <span class="title">AFKeyPathFromOperationState</span><span class="params">(AFOperationState state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFOperationReadyState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isReady&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationExecutingState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isExecuting&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationFinishedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isFinished&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationPausedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isPaused&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wunreachable-code&quot;</span></span></span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;state&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重写父类NSOperation的属性getter"><a href="#2-重写父类NSOperation的属性getter" class="headerlink" title="2. 重写父类NSOperation的属性getter"></a>2. 重写父类NSOperation的属性getter</h4><p>复写了这些属性的get方法，用来和自定义的state一一对应：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写这些方法，与自己的定义的state对应</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isReady &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationReadyState &amp;&amp; [<span class="keyword">super</span> isReady];</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationExecutingState;</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationFinishedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-属性lock"><a href="#3-属性lock" class="headerlink" title="3. 属性lock"></a>3. 属性lock</h4><p><code>self.lock</code>这个锁是用来提供给本类一些数据操作的线程安全，至于为什么要用递归锁，是因为有些方法可能会存在递归调用的情况，例如有些需要锁的方法可能会在一个大的操作环中，形成递归。<strong>而AF使用了递归锁，避免了这种情况下死锁的发生</strong>。</p><h4 id="4-属性runLoopModes"><a href="#4-属性runLoopModes" class="headerlink" title="4. 属性runLoopModes"></a>4. 属性runLoopModes</h4><p>初始化了<code>self.runLoopModes</code>，默认为<code>NSRunLoopCommonModes</code>。</p><h4 id="5-属性securityPolicy"><a href="#5-属性securityPolicy" class="headerlink" title="5. 属性securityPolicy"></a>5. 属性securityPolicy</h4><p>生成了一个默认的 <code>self.securityPolicy</code>，关于这个policy执行的https认证，可以见楼主之前的文章。</p><h3 id="6-3-3-复写operation的start方法"><a href="#6-3-3-复写operation的start方法" class="headerlink" title="6.3.3 复写operation的start方法"></a>6.3.3 复写operation的start方法</h3><p>这个类为了自定义<code>operation</code>的各种状态，而且更好的掌控它的生命周期，复写了<code>operation</code>的<code>start</code>方法。</p><h4 id="1-源码实现"><a href="#1-源码实现" class="headerlink" title="1. 源码实现"></a>1. 源码实现</h4><p>当这个<code>operation</code>在一个新线程被调度执行的时候，首先就调入这个<code>start</code>方法中，接下来我们它的实现看看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果被取消了就调用取消的方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//在AF常驻线程中去执行</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备好了，才开始</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="comment">//改变状态，开始执行</span></span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，发起请求和取消请求都是在同一个线程！！包括回调都是在一个线程</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法判断了当前的状态，是取消还是准备就绪，然后去调用了各自对应的方法。</p><h4 id="2-开辟新线程"><a href="#2-开辟新线程" class="headerlink" title="2. 开辟新线程"></a>2. 开辟新线程</h4><p>注意这些方法都是在另外一个线程中去调用的，我们来看看这个线程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">//添加端口，防止runloop直接退出</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法基本上是被许多人举例用过无数次了…</p><ul><li>这是一个单例，用<code>NSThread</code>创建了一个线程，并且为这个线程添加了一个<code>runloop</code>，并且加了一个<code>NSMachPort</code>，来防止<code>runloop</code>直接退出。</li><li><strong>这条线程就是AF用来发起网络请求，并且接受网络请求回调的线程，仅仅就这一条线程</strong>（到最后我们来讲为什么要这么做）。和我们之前讲的AF3.x发起请求，并且接受请求回调时的处理方式，遥相呼应。</li></ul><h4 id="3-start调用流程"><a href="#3-start调用流程" class="headerlink" title="3. start调用流程"></a>3. start调用流程</h4><p>我们接着来看如果准备就绪，start调用的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态，开始执行</span></span><br><span class="line"><span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br></pre></td></tr></table></figure><p>接着在常驻线程中,并且不阻塞的方式，在我们<code>self.runLoopModes</code>的模式下调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationDidStart &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//如果没取消</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//设置为startImmediately YES 请求发出，回调会加入到主线程的 Runloop 下，RunloopMode 会默认为 NSDefaultRunLoopMode</span></span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line">            <span class="comment">//把connection和outputStream注册到当前线程runloop中去，只有这样，才能在这个线程中回调</span></span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开输出流</span></span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line">        <span class="comment">//开启请求</span></span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了以下几件事：</p><h5 id="1-创建NSURLConnection"><a href="#1-创建NSURLConnection" class="headerlink" title="1) 创建NSURLConnection"></a>1) 创建NSURLConnection</h5><p>首先这个方法创建了一个<code>NSURLConnection</code>，设置代理为自己，startImmediately为NO，至于这个参数干什么用的，我们来看看官方文档：</p><blockquote><p>startImmediately<br> YES if the connection should begin loading data immediately, otherwise NO. If you pass NO, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling scheduleInRunLoop:forMode: .</p></blockquote><p>大意是，这个值默认为YES，而且任务完成的结果会在主线程的runloop中回调。如果我们设置为NO，则需要调用我们下面看到的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.connection scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>去注册一个runloop和mode，它会在我们指定的这个runloop所在的线程中回调结果。</p><h5 id="2-outputStream的创建及注册"><a href="#2-outputStream的创建及注册" class="headerlink" title="2) outputStream的创建及注册"></a>2) outputStream的创建及注册</h5><p>值得一提的是这里调用了:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure><p>这个<code>outputStream</code>在getter方法中被初始化了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_outputStream) &#123;</span><br><span class="line">        <span class="comment">//一个写入到内存中的流，可以通过NSStreamDataWrittenToMemoryStreamKey拿到写入后的数据</span></span><br><span class="line">        <span class="keyword">self</span>.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _outputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里数据请求和拼接并没有用<code>NSMutableData</code>，而是用了<code>outputStream</code>，而且把写入的数据，放到内存中。</p><ul><li>其实讲道理来说<code>outputStream</code>的优势在于下载大文件的时候，可以以流的形式，将文件直接保存到本地，<strong>这样可以为我们节省很多的内存</strong>，调用如下方法设置：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:<span class="string">@&quot;filePath&quot;</span> append:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><ul><li>但是这里是把流写入内存中，这样其实这个节省内存的意义已经不存在了。那为什么还要用呢？这里我猜测的是就是为了用它这个可以注册在某一个<code>runloop</code>的指定<code>mode</code>下。 虽然AF使用这个<code>outputStream</code>是肯定在这个常驻线程中的，不会有线程安全的问题。但是要注意它是被声明在.h中的：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *outputStream;</span><br></pre></td></tr></table></figure><p>难保外部不会在其他线程对这个数据做什么操作，所以它相对于<code>NSMutableData</code>作用就体现出来了，就算我们在外部其它线程中去操作它，也不会有线程安全的问题。</p><h5 id="3-开始执行connection"><a href="#3-开始执行connection" class="headerlink" title="3) 开始执行connection"></a>3) 开始执行connection</h5><h5 id="4-到主线程发送任务开始执行的通知"><a href="#4-到主线程发送任务开始执行的通知" class="headerlink" title="4) 到主线程发送任务开始执行的通知"></a>4) 到主线程发送任务开始执行的通知</h5><h3 id="6-3-4-实现NSURLConnectionDelegate"><a href="#6-3-4-实现NSURLConnectionDelegate" class="headerlink" title="6.3.4 实现NSURLConnectionDelegate"></a>6.3.4 实现NSURLConnectionDelegate</h3><p>接下来网络请求开始执行了，就开始触发<code>connection</code>的代理方法了：</p><img src="/images/AFN/AFN-11.jpg" alt="img" style="zoom:74%;" /><p> AF2.x一共实现了如上这么多代理方法，这些代理方法，作用大部分和我们之前讲的<code>NSURLSession</code>的代理方法类似，我们重点讲下面这四个代理：</p><p>注意，有一点需要说明，我们之前是把connection注册在我们常驻线程的runloop中了，<strong>所以以下所有的代理方法，都是在这仅有的一条常驻线程中回调。</strong></p><h4 id="1-connection-didReceiveResponse"><a href="#1-connection-didReceiveResponse" class="headerlink" title="1. connection:didReceiveResponse"></a>1. connection:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到响应，响应头类似相关数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的，就是收到响应后，把response赋给自己的属性。</p><h4 id="2-connection-didReceiveData"><a href="#2-connection-didReceiveData" class="headerlink" title="2. connection:didReceiveData"></a>2. connection:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接获取到的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [data length];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> totalNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果outputStream 还有空余空间</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//创建一个buffer流缓冲区，大小为data的字节数</span></span><br><span class="line">            <span class="keyword">const</span> uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//当写的长度小于数据的长度，在循环里</span></span><br><span class="line">            <span class="keyword">while</span> (totalNumberOfBytesWritten &lt; (<span class="built_in">NSInteger</span>)length) &#123;</span><br><span class="line">                <span class="comment">//往outputStream写数据，系统的方法，一次就写一部分，得循环写</span></span><br><span class="line">                numberOfBytesWritten = [<span class="keyword">self</span>.outputStream write:&amp;dataBuffer[(<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten)];</span><br><span class="line">                <span class="comment">//如果 numberOfBytesWritten写入失败了。跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加上每次写的长度</span></span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.outputStream.streamError) &#123;</span><br><span class="line">            <span class="comment">//取消connection</span></span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            <span class="comment">//调用失败的方法</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(connection:didFailWithError:) withObject:<span class="keyword">self</span>.connection withObject:<span class="keyword">self</span>.outputStream.streamError];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程回调下载数据大小</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.totalBytesRead += (<span class="keyword">long</span> <span class="keyword">long</span>)length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgress) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress(length, <span class="keyword">self</span>.totalBytesRead, <span class="keyword">self</span>.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看起来长，其实容易理解而且简单，它只做了3件事：</p><ol><li>给<code>outputStream</code>拼接数据，具体如果拼接，大家可以读注释自行理解下。</li><li>如果出错则调用：<code>connection:didFailWithError:</code>也就是网络请求失败的代理，我们一会下面就会讲。</li><li>在主线程中回调下载进度。</li></ol><h4 id="3-connectionDidFinishLoading"><a href="#3-connectionDidFinishLoading" class="headerlink" title="3. connectionDidFinishLoading"></a>3. connectionDidFinishLoading</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成了调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> __unused *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从outputStream中拿到数据 NSStreamDataWrittenToMemoryStreamKey写入到内存中的流</span></span><br><span class="line">    <span class="keyword">self</span>.responseData = [<span class="keyword">self</span>.outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">       <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空connection</span></span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理是任务完成之后调用。我们从<code>outputStream</code>拿到了最后下载数据，然后关闭置空了<code>outputStream</code>。并且清空了<code>connection</code>。调用了<code>finish</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)finish &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//修改状态</span></span><br><span class="line">    <span class="keyword">self</span>.state = AFOperationFinishedState;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送完成的通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把当前任务状态改为已完成，并且到主线程发送任务完成的通知。<strong>这里我们设置状态为已完成。注意上面已经讲过：本类是复写了state的setter方法的</strong>，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p><p>大家了解<code>NSOperationQueue</code>就知道，如果对应的operation的属性<code>finnished</code>被设置为YES，则代表当前<code>operation</code>结束了，会把<code>operation</code>从队列中移除，并且调用<code>operation</code>的<code>completionBlock</code>。<strong>这点很重要，因为我们请求到的数据就是从这个<code>completionBlock</code>中传递回去的</strong>（下面接着讲这个完成Block，就能从这里对接上了）。</p><h4 id="4-connection-didFailWithError"><a href="#4-connection-didFailWithError" class="headerlink" title="4. connection:didFailWithError"></a>4. connection:didFailWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求失败的回调，在cancel connection的时候，自己也主动调用了</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到error</span></span><br><span class="line">    <span class="keyword">self</span>.error = error;</span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一需要说一下的就是这里给<code>self.error</code>赋值，之后完成Block会根据这个error，去判断这次请求是成功还是失败。</p><p>至此我们把<code>AFURLConnectionOperation</code>的业务主线讲完了。</p><p>我们此时数据请求完了，数据在<code>self.responseData</code>中，那它是怎么回到我们手里的呢。需要回到<code>AFURLConnectionOperation</code>子类<code>AFHTTPRequestOperation</code>，有这么一个方法：<code>setCompletionBlockWithSuccess:failure:</code></p><h2 id="6-4-AFHTTPRequestOperation"><a href="#6-4-AFHTTPRequestOperation" class="headerlink" title="6.4 AFHTTPRequestOperation"></a>6.4 AFHTTPRequestOperation</h2><h3 id="6-4-1-初始化方法"><a href="#6-4-1-初始化方法" class="headerlink" title="6.4.1 初始化方法"></a>6.4.1 初始化方法</h3><p>前面已经看过这个AFHTTPRequestOperation的初始化方法，这里再整合一下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p><h3 id="6-4-2-设置completionBlock"><a href="#6-4-2-设置completionBlock" class="headerlink" title="6.4.2 设置completionBlock"></a>6.4.2 设置completionBlock</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                              failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">    <span class="keyword">self</span>.completionBlock = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">            dispatch_group_enter(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(http_request_operation_processing_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> responseObject = <span class="keyword">self</span>.responseObject;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(<span class="keyword">self</span>, responseObject);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">                dispatch_group_leave(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我们在<code>AFHTTPRequestOperationManager</code>中是调用过这个方法的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation setCompletionBlockWithSuccess:success failure:failure];</span><br></pre></td></tr></table></figure><ul><li>我们在把成功和失败的Block传给了这个方法。</li><li>这个方法也很好理解，就是设置我们之前提到过得<code>completionBlock</code>，<strong>当自己数据请求完成，就会调用这个Block。然后我们在这个Block中调用传过来的成功或者失败的Block。</strong>如果error为空，说明请求成功，把数据传出去，否则为失败，把error信息传出。</li><li>这里也类似AF3.x，可以自定义一个完成组和完成队列。数据可以在我们自定义的完成组和队列中回调出去。</li><li>除此之外，还有一个有意思的地方：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure><p>之前我们说过，这是在忽略编译器的一些警告。</p><ul><li><code>-Wgnu</code>就不说了，是忽略 ?: 。</li><li>值得提下的是<code>-Warc-retain-cycles</code>，这里忽略了循环引用的警告。我们仔细看看就知道<code>self</code>持有了<code>completionBlock</code>，而<code>completionBlock</code>内部持有<code>self</code>。这里确实循环引用了。那么AF是如何解决这个循环引用的呢？</li></ul><p>我们在回到<code>AFURLConnectionOperation</code>，还有一个方法我们之前没讲到，它复写了setCompletionBlock这个方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写setCompletionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:^ &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">            <span class="comment">//看有没有自定义的完成组，否则用AF的组</span></span><br><span class="line">            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</span><br><span class="line">            <span class="comment">//看有没有自定义的完成queue，否则用主队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用设置的Block,在这个组和队列中</span></span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                block();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结束时候置nil，防止循环引用</span></span><br><span class="line">            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&#123;</span><br><span class="line">                [strongSelf setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，它在我们设置的block调用结束的时候，主动的调用:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">strongSelf setCompletionBlock:nil</span>];</span><br></pre></td></tr></table></figure><p>把Block置空，这样循环引用不复存在了。</p><h3 id="6-4-3-数据解析的调用"><a href="#6-4-3-数据解析的调用" class="headerlink" title="6.4.3 数据解析的调用"></a>6.4.3 数据解析的调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObject &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!_responseObject &amp;&amp; [<span class="keyword">self</span> isFinished] &amp;&amp; !<span class="keyword">self</span>.error) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//做数据解析</span></span><br><span class="line">        <span class="keyword">self</span>.responseObject = [<span class="keyword">self</span>.responseSerializer responseObjectForResponse:<span class="keyword">self</span>.response data:<span class="keyword">self</span>.responseData error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">self</span>.responseSerializationError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> _responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestOperation</code> 复写了 <code>responseObject</code> 的getter方法，并且把数据按照我们需要的类型（json、xml等等）进行解析。</p><h2 id="6-5-ResponseSerializer与SecurityPolicy"><a href="#6-5-ResponseSerializer与SecurityPolicy" class="headerlink" title="6.5 ResponseSerializer与SecurityPolicy"></a>6.5 ResponseSerializer与SecurityPolicy</h2><p>关于数据的序列化、SecurityPolicy，前面已经详细的讲过，AF2.x与AF3.x基本差不多，不再赘述。<code>AFSecurityPolicy</code> 在  <code>AFURLConnectionOperation</code>中https认证的代理中被调用</p><p>至此，AF2.x整个业务流程就结束了。</p><h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><p>接下来，我们来总结总结AF2.x整个业务请求的流程：</p><img src="/images/AFN/AFN-12.jpg" alt="img" style="zoom:65%;" /><p>如上图，我们来梳理一下整个流程：</p><ul><li>最上层的是<code>AFHTTPRequestOperationManager</code>,我们调用它进行get、post等等各种类型的网络请求</li><li>然后它去调用<code>AFURLRequestSerialization</code>做request参数拼装。然后生成了一个<code>AFHTTPRequestOperation</code>实例，并把request交给它。然后把<code>AFHTTPRequestOperation</code>添加到一个<code>NSOperationQueue</code>中。</li><li>接着<code>AFHTTPRequestOperation</code>拿到request后，会去调用它的父类<code>AFURLConnectionOperation</code>的初始化方法，并且把相关参数交给它，除此之外，当父类完成数据请求后，它调用了<code>AFURLResponseSerialization</code>把数据解析成我们需要的格式（json、XML等等）。</li><li>最后就是我们AF最底层的类<code>AFURLConnectionOperation</code>，它去数据请求，并且如果是https请求，会在请求的相关代理中，调用<code>AFSecurityPolicy</code>做https认证。最后请求到的数据返回。</li></ul><p>这就是AF2.x整个做网络请求的业务流程。</p><h2 id="6-7-遗留问题：一条常驻线程"><a href="#6-7-遗留问题：一条常驻线程" class="headerlink" title="6.7 遗留问题：一条常驻线程"></a>6.7 遗留问题：一条常驻线程</h2><p>我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？</p><p>首先如果我们用<code>NSURLConnection</code>，我们为了获取请求结果有以下三种选择：</p><ol><li>在主线程调异步接口</li><li>每一个请求用一个线程，对应一个runloop，然后等待结果回调。</li><li>只用一条线程，一个runloop，所有结果回调在这个线程上。</li></ol><p>很显然AF选择的是第3种方式，创建了一条常驻线程专门处理所有请求的回调事件，这个模型跟<code>nodejs</code>有点类似，我们来讨论讨论不选择另外两种方式的原因：</p><p>先说第一种。试想如果我们所有的请求都在主线程中异步调用，好像没什么不可以？那为什么AF不这么做呢…在这里有两点原因（楼主个人总结的，有不同意见，欢迎讨论）：</p><ol><li><p>第一，如果我们放到主线程去做，势必要这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>] </span><br></pre></td></tr></table></figure><p>这样NSURLConnection的回调会被放在主线程中<code>NSDefaultRunLoopMode</code>中，这样我们在其它类似<code>UITrackingRunLoopMode</code>模式下，我们是得不到网络请求的结果的，这显然不是我们想要的，那么我们势必需要调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>]; </span><br></pre></td></tr></table></figure><p>把它加入 <code>NSRunLoopCommonModes</code> 中，试想如果有大量的网络请求，同时回调回来，就会影响我们的UI体验了。</p></li><li><p>另外一点原因是，如果我们请求数据返回，势必要进行数据解析，解析成我们需要的格式，那么这些解析都在主线程中做，给主线程增加额外的负担。又或者我们回调回来开辟一个新的线程去做数据解析，那么我们有n个请求回来开辟n条线程带来的性能损耗，以及线程间切换带来的损耗，是不是一笔更大的开销。</p></li></ol><p>所以综述两点原因，我们并不适合在主线程中回调。</p><p>再说第二种。我们一开始就开辟n条线程去做请求，然后设置runloop保活住线程，等待结果回调。其实看到这，大家想想都觉得这个方法很傻，为了等待不确定的请求结果，阻塞住线程，白白浪费n条线程的开销。</p><p>综上所述，这就是<strong>AF2.x需要一条常驻线程的原因了</strong>。</p><p>至此我们把AF2.x核心流程分析完了。</p><h1 id="七、总结AFNetworking到底做了什么？"><a href="#七、总结AFNetworking到底做了什么？" class="headerlink" title="七、总结AFNetworking到底做了什么？"></a>七、总结AFNetworking到底做了什么？</h1><p>接着到我们本系列一个最终总结了: <strong>AFNetworking到底做了什么？</strong></p><p>相信如果从头看到尾的小伙伴，心里都有了一个属于自己的答案。其实在楼主心里，实在不想去总结它，因为<code>AFNetworking</code>中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。但是想想也知道，如果我说不总结，估计有些看到这的朋友杀人的心都有…所以我还是赶鸭子上架，来总结总结它。</p><p>AFNetworking的作用总结：</p><p>一、首先我们需要明确一点的是：<strong>相对于AFNetworking2.x，AFNetworking3.x确实没那么有用了。</strong>AFNetworking之前的核心作用就是为了帮我们去调度所有的请求。但是最核心地方却被苹果的<code>NSURLSession</code>给借鉴过去了，嗯…是借鉴。这些请求的调度，现在完全由<code>NSURLSession</code>给做了，AFNetworking3.x的作用被大大的削弱了。</p><p>二、但是除此之外，其实它还是很有用的：</p><ol><li><strong>首先它帮我们做了各种请求方式request的拼接。</strong>想想如果我们用<code>NSURLSession</code>，我们去做请求，是不是还得自己去考虑各种请求方式下，拼接参数的问题。</li><li><strong>它还帮我们做了一些公用参数（session级别的），和一些私用参数（task级别的）的分离</strong>。它用Block的形式，支持我们自定义一些代理方法，如果没有实现的话，AF还帮我们做了一些默认的处理。而如果我们用<code>NSURLSession</code>的话，还得参照AF这么一套代理转发的架构模式去封装。</li><li><strong>它帮我们做了自定义的https认证处理</strong>。看过楼主之前那篇<a href="https://www.jianshu.com/p/a84237b07611">AFNetworking之于https认证</a>的朋友就知道，如果我们自己用<code>NSURLSession</code>实现那几种自定义认证，需要多写多少代码…</li><li><strong>对于请求到的数据，AF帮我们做了各种格式的数据解析，并且支持我们设置自定义的code范围，自定义的数据方式</strong>。如果不在这些范围中，则直接调用失败block。如果用<code>NSURLSession</code>呢？这些都自己去写吧…（你要是做过各种除json外其他的数据解析,就会知道这里面坑有多少…）</li><li><strong>对于成功和失败的回调处理。</strong>AF帮我们在数据请求到，到回调给用户之间，做了各种错误的判断，保证了成功和失败的回调，界限清晰。在这过程中，AF帮我们做了太多的容错处理，而<code>NSURLSession</code>呢？只给了一个完成的回调，我们得多做多少判断，才能拿到一个确定能正常显示的数据？</li><li>……</li><li>…</li></ol><p>光是这些网络请求的业务逻辑，AF帮我们做的就太多太多，当然还远不仅于此。它用凝聚着许多大牛的经验方式，帮我在有些处理中做了最优的选择，比如我们之前说到的，回调线程数设置为1的问题…帮我们绕开了很多的坑，比如系统内部并行创建<code>task</code>导致id不唯一等等…</p><p>三、而如果我们需要一些UIKit的扩展，AF则提供了最稳定，而且最优化实现方式：</p><ul><li>就比如之前说到过得那个状态栏小菊花，如果是我们自己去做，得多写多少代码，而且实现的还没有AF那样质量高。</li><li>又或者<code>AFImageDownloader</code>，它对于组图片之间的下载协调，以及缓存使用的之间线程调度。对于线程，锁，以及性能各方面权衡，找出最优化的处理方式，试问小伙伴们自己基于<code>NSURLSession</code>去写，能到做几分…</li></ul><p>所以最后的结论是：<strong>AFNetworking虽然变弱了，但是它还是很有用的。</strong>用它真的不仅仅是习惯，而是因为它确实帮我们做了太多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F&quot;&gt;原文链接&lt;/a&gt;，有一些细节修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;im</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="AFN" scheme="https://tenloy.github.io/tags/AFN/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络相关知识汇总</title>
    <link href="https://tenloy.github.io/2021/09/03/computer-network-knowledge.html"/>
    <id>https://tenloy.github.io/2021/09/03/computer-network-knowledge.html</id>
    <published>2021-09-03T18:53:12.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程：是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</p><p>我们处于互联网时代，我们可以随时随地通过 Internet 上网、浏览新闻、玩LOL、上淘宝购物等等。</p><p>这些过程都发生了网络数据的交互：</p><ul><li>bs：browser server 浏览器和服务器的网络编程模型</li><li>cs：client server 客户端和服务器的网络编程模型</li></ul><p>强调：网络编程重在思想，node只是一个可以帮助我们网络编程的一个工具而已。使用其他编程语言或者操作系统进行网络编程，思想都是一样的。</p><h1 id="一、服务器与服务器容器"><a href="#一、服务器与服务器容器" class="headerlink" title="一、服务器与服务器容器"></a>一、服务器与服务器容器</h1><h2 id="1-1-服务器-server"><a href="#1-1-服务器-server" class="headerlink" title="1.1 服务器(server)"></a>1.1 服务器(server)</h2><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li>一个管理资源并为用户<font color='red'>提供服务</font>的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</li><li>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h3 id="1-1-1-作为硬件"><a href="#1-1-1-作为硬件" class="headerlink" title="1.1.1 作为硬件"></a>1.1.1 作为硬件</h3><p>服务器就是一台特殊的、功能强大、没有外接设备(屏幕、键盘、鼠标)的电脑。一个服务器一个IP，有些大公司，拥有成千上万个服务器，我们通过主机域名来访问资源，服务器是随机分配给我们的。</p><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li><li>服务器不需要比较复杂的可视化操作界面，因为比较耗资源。服务器一旦部署好服务后，一般动的比较少。</li></ul><h3 id="1-1-2-作为软件"><a href="#1-1-2-作为软件" class="headerlink" title="1.1.2 作为软件"></a>1.1.2 作为软件</h3><h4 id="1-常见分类"><a href="#1-常见分类" class="headerlink" title="1. 常见分类"></a>1. 常见分类</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，按提供的服务类型不同可分为：</p><ul><li><strong>应用程序服务器(application server/AP server)</strong></li><li><strong>网页服务器(Web server)</strong> —— Apache、Nginx、IIS、Tomcat、NodeJS等；</li><li>文件服务器(file server)或网络存储设备(network attached storage) —— Server-U、FileZilla、VsFTP等；</li><li>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</li><li>邮件服务器(mail server) —— Postfix、Sendmail等；</li><li>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</li><li>域名服务器（DNS server）—— 如BIND等</li><li>代理服务器（proxy server）—— 如Squid cache</li><li>其他，如Active Directory服务器、Minecraft游戏服务器等</li></ul><img src = "/images/ComNet/servers.jpg" width = '50%' align:left style='margin-left:10%'><h4 id="2-应用程序服务器"><a href="#2-应用程序服务器" class="headerlink" title="2. 应用程序服务器"></a>2. 应用程序服务器</h4><p><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</p><p>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong></p><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul><h4 id="3-网页服务器-Web-server"><a href="#3-网页服务器-Web-server" class="headerlink" title="3. 网页服务器(Web server)"></a>3. 网页服务器(Web server)</h4><p>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</p><p>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。如Apache（静态）、Apache Tomcat（静态、动态）、Node.js、lighttpd、nginx、微软的IIS等；</p><img src="/images/ComNet/web-server.jpg" alt="图片" style="zoom:90%;" /><h4 id="4-WEB应用服务器"><a href="#4-WEB应用服务器" class="headerlink" title="4. WEB应用服务器"></a>4. WEB应用服务器</h4><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p><h3 id="1-1-3-服务器的其它分类"><a href="#1-1-3-服务器的其它分类" class="headerlink" title="1.1.3 服务器的其它分类"></a>1.1.3 服务器的其它分类</h3><p><strong>按操作系统分</strong></p><ul><li>Linux服务器、Windows服务器等；</li></ul><p><strong>按照浏览器的访问权限来分</strong></p><ul><li><p>外网服务器<br>别名：远程服务器，<font color=red>任何网段的设备都能访问的服务器</font><br>应用场景：应用上线后使用的服务器<br>使用人群：供全体用户使用<br>速度：取决于服务器的性能、用户的网速</p></li><li><p>内网服务器<br>别名：本地服务器，<font color=red>只有连同样内网的设备才能访问到的服务器</font><br>应用场景：应用处于开发、测试阶段使用的服务器<br>使用人群：仅供公司内部的开发人员、测试人员使用<br>速度：由于是局域网，所以速度飞快，有助于提高开发测试效率</p></li><li><p>一般公司会有三套服务器：本地测试服务器、外网测试服务器、外网正式服务器<br>内网测试可以直接测试服务器的并发连接性能<br>外网的话首先要考验你的互联网导致的延时和掉包的因素</p></li></ul><h3 id="1-1-4-内网和外网的区别"><a href="#1-1-4-内网和外网的区别" class="headerlink" title="1.1.4 内网和外网的区别"></a>1.1.4 内网和外网的区别</h3><p><font color=red>内网可以访问外网服务器，也可以设置不能访问。</font></p><p><font color=red>外网肯定不能访问内网服务器。</font></p><h4 id="1-内网"><a href="#1-内网" class="headerlink" title="1. 内网"></a>1. 内网</h4><p>内网就是我们平常说的局域网。</p><p>局域网就是在固定的一个地理区域内由2台以上的电脑用网线和其他网络设备搭建而成的一个封闭的计算机组。</p><ul><li>它可以是邻居之间的2台电脑，也可以是一幢100层大楼里的1000台电脑。</li><li><font color=red>可以是独立封闭运行的</font>（配置了服务器，建立了内部的web网页，论坛等等，但时不能上QQ、MSN等等，不能与外部发生通信），也可以是和外网相连接的</li></ul><h4 id="2-外网"><a href="#2-外网" class="headerlink" title="2. 外网"></a>2. 外网</h4><p>外网就是与internet连接的网络，可以跟世界上任何地方取得联系，但不能访问人家的内网服务器。外网就不经路由器或交换机就可以上网的网络，可以直接被外界所访问到。无需经如何设备，直接连接电脑。</p><h4 id="3-区分内网与外网"><a href="#3-区分内网与外网" class="headerlink" title="3. 区分内网与外网"></a>3. 区分内网与外网</h4><ul><li>用猫、路由器连接的都是外网。内网只用交换机<br>但是：有些光纤到楼、小区宽带、教育网、有线电视Cable Modem上网虽然地域范围比较大但本质上还是基于以太网技术，所以仍然属于内网。</li><li>判断内网和外网最简单的方法：判断网段 (有专业的方法，不会)</li><li><font color=red>内网IP的网段</font><ul><li>10.0.0.0 / 8:10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 / 12.172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 / 16.192.168.0.0 ~ 192.168.255.255</li></ul></li></ul><h4 id="4-为什么生活中很多的局域网？"><a href="#4-为什么生活中很多的局域网？" class="headerlink" title="4. 为什么生活中很多的局域网？"></a>4. 为什么生活中很多的局域网？</h4><p>其实<font color=red>外网IP是比较紧张的，现在的电脑的普及使得外网IP根本不够用，根本做不到一台电脑一个外网IP</font>，内网的产生就是为了解决这个难题的！</p><p>路由器只需一个外网IP就可以供下面的N多电脑联网。因为不同的内网IP是可以重复使用（任何一台电脑要上网，都必须在网络上有一个唯一的IP地址。在局域网内，这个IP地址是唯一的。但是在另外一个局域网，这个IP地址仍然能够使用）。拿网吧举例，一个网吧N多台电脑，其实他只要一个外网IP就可以给下面的电脑提供上网</p><h2 id="1-2-服务器容器"><a href="#1-2-服务器容器" class="headerlink" title="1.2 服务器容器"></a>1.2 服务器容器</h2><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = "/images/ComNet/container_server.jpg" width = '40%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = "/images/ComNet/containers.jpg" width = '50%' align:left style='margin-left:10%'><h3 id="1-2-1-Servlet容器"><a href="#1-2-1-Servlet容器" class="headerlink" title="1.2.1 Servlet容器"></a>1.2.1 Servlet容器</h3><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h3 id="1-2-2-Java-WEB容器"><a href="#1-2-2-Java-WEB容器" class="headerlink" title="1.2.2 Java WEB容器"></a>1.2.2 Java WEB容器</h3><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h3 id="1-2-3-Java-EE容器"><a href="#1-2-3-Java-EE容器" class="headerlink" title="1.2.3 Java EE容器"></a>1.2.3 Java EE容器</h3><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h2 id="1-3-举例说明容器与服务器的联系"><a href="#1-3-举例说明容器与服务器的联系" class="headerlink" title="1.3 举例说明容器与服务器的联系"></a>1.3 举例说明容器与服务器的联系</h2><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h3 id="1-3-1-Apache、Nginx、IIS"><a href="#1-3-1-Apache、Nginx、IIS" class="headerlink" title="1.3.1 Apache、Nginx、IIS"></a>1.3.1 Apache、Nginx、IIS</h3><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><p>Nginx：</p><ul><li>代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>nginx除了是个web服务器还能够做反向代理服务器，反向代理服务器的作用，可以用来做负载均衡代理，委托一个人帮我去做事情，上网代理，就是我上网的时候如果上网被墙了，我可以用代理帮我们去上网。</li><li>也可以用nginx来做负载均衡</li></ul><h3 id="1-3-2-Node没有Web容器"><a href="#1-3-2-Node没有Web容器" class="headerlink" title="1.3.2 Node没有Web容器"></a>1.3.2 Node没有Web容器</h3><ul><li>.net平台的 ASP或者ASP.net 需要 <code>IIS</code> 作为服务器容器</li><li>PHP需要搭载 Apache 或者 <code>Nginx</code> 作为服务器容器</li><li>Java 的 JSP 需要 <code>Tomcat</code> 作为服务器容器</li><li>ruby 的 ruby on rails 需要 搭配 <code>Apache</code> 等作为自己的服务器容器。。。</li></ul><p>如果我用 js 写了一个 web 应用程序，那么 node 就是web服务器，Node，不需要服务器容器。</p><h3 id="1-3-3-Tomcat及常见的JavaEE应用服务器"><a href="#1-3-3-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="1.3.3 Tomcat及常见的JavaEE应用服务器"></a>1.3.3 Tomcat及常见的JavaEE应用服务器</h3><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h3 id="1-3-4-Nginx-Tomcat的WEB应用服务器-集群"><a href="#1-3-4-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="1.3.4 Nginx + Tomcat的WEB应用服务器(集群)"></a>1.3.4 Nginx + Tomcat的WEB应用服务器(集群)</h3><img src = "/images/ComNet/nginx_tomcat.jpg" width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="1-4-服务器开发"><a href="#1-4-服务器开发" class="headerlink" title="1.4 服务器开发"></a>1.4 服务器开发</h2><p>开发服务器的语言很多：Java、PHP、.net、node.js、python、go、ruby、erlang等等</p><p>不同语言开发的服务器，对应的配置电脑为服务器的软件也不一样(这里说的都是Windows系统的)</p><ul><li>java — Tomcat</li><li>php — wamp (w-windows、a-apache、m - mysql、p-php)</li><li>node.js — NodeJS</li></ul><h2 id="1-5-Apache服务器的配置"><a href="#1-5-Apache服务器的配置" class="headerlink" title="1.5 Apache服务器的配置"></a>1.5 Apache服务器的配置</h2><p>在iOS与前端的学习中，Apache使用起来最方便。所以这里主要说Web服务器：- http服务器： - Apache服务器</p><p>Apache服务器的配置</p><ul><li>Windows系统：wamp软件安装，然后修改一些配置信息</li><li>Mac系统：自带有Apache服务器，通过终端配置一些信息，然后打开即可</li></ul><p>在配置信息中，我们会<font color=red>指定一个文件夹，作为别人访问我们的电脑服务器时能获取到的文件 — 网站根目录</font></p><p>被访问的时候</p><ul><li>如果网站根目录中，<font color=red>有index命名的文件(不管是HTML文件，还是PHP文件)，会直接运行.</font></li><li>如果没有index命名的，那么就会将该文件夹内的文件，以列表形式展示出来.</li></ul><h2 id="1-6-PHP开发服务器是怎么工作的"><a href="#1-6-PHP开发服务器是怎么工作的" class="headerlink" title="1.6 PHP开发服务器是怎么工作的"></a>1.6 PHP开发服务器是怎么工作的</h2><p>PHP服务器，是怎么接收的？</p><h3 id="1-6-1-创建PHP文件"><a href="#1-6-1-创建PHP文件" class="headerlink" title="1.6.1 创建PHP文件"></a>1.6.1 创建PHP文件</h3><ul><li><p>.php文件，写PHP代码，也可以写HTML+CSS+JS代码，跟写在.html文件中，显示效果一模一样。</p><p>不过，PHP代码，需要写在 <?php ?> 标签中，而且标签内只能写PHP代码。</p></li><li><p>.html文件里，不能写PHP代码</p></li></ul><p><font color=red>要放在我们服务器里的根目录里，PHP代码只有放在服务器中，被访问的时候，才会执行</font></p><h3 id="1-6-2-取值"><a href="#1-6-2-取值" class="headerlink" title="1.6.2 取值"></a>1.6.2 取值</h3><p>别人根据URL，访问该PHP文件的时候，如果携带参数，那就会将参数，传值到该文件</p><p>取值：php中为我们预定义了几个 超全局对象</p><ul><li><p>GET取值：$_GET 是一个关系型数组 $_GET[‘key’]</p></li><li><p>POST取值：$_POST 也是一个关系型数组 $_POST[‘key’]</p></li><li><p>POST上传文件: $_FILES</p><p>获取 上传的文件信息 关系型数组 <code>$fileArr = $_FILES[&#39;upFile&#39;];</code></p><p>获取 上传的文件的原本名字 <code>$fileName = $fileArr[&#39;name&#39;];</code></p><p>获取保存在服务器的那个位置 <code>$filePath = $fileArr[&#39;tmp_name&#39;];</code></p><p>PHP将上传的文件，保存至指定位置</p><ul><li><p>参数1：是从上传的文件信息中，取的Path值</p></li><li><p>参数2：我们指定的存储位置</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(<span class="variable">$filePath</span>,’文件夹/‘.<span class="variable">$fileName</span>); <span class="comment">//注意：<span class="doctag">bug:</span> Mac本上，必须要设置一些指定路径文件夹的权限，设置为everyone可读写，否则，访问的时候，是写不进去东西的</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：key的值就是提交的参数名，需要保持一致</p><h3 id="1-6-3-返回访问结果"><a href="#1-6-3-返回访问结果" class="headerlink" title="1.6.3 返回访问结果"></a>1.6.3 返回访问结果</h3><p><font color=red>如果请求的是HTML文件：原封不动返回，服务器不会动这个HTML文件</font></p><p><font color=red>如果请求的是PHP文件：</font></p><ul><li><p>HTML部分的代码，原封不动的返回</p></li><li><p><code>&lt;?php ?&gt;</code>里的PHP代码，<font color=red>在服务器端执行</font>，只返回输出函数：echo、print_f 打印的结果</p></li></ul><h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><p>试想一下,如果一个网站的注册用户有1千万个那么应该使用什么格式,什么方式来保存这些数据呢?</p><h2 id="3-1-常规保存方式"><a href="#3-1-常规保存方式" class="headerlink" title="3.1 常规保存方式"></a>3.1 常规保存方式</h2><h3 id="3-1-1-txt文件"><a href="#3-1-1-txt文件" class="headerlink" title="3.1.1 .txt文件"></a>3.1.1 .txt文件</h3><p>因为内容是文本,所以直接使用文本文件保存肯定可以,但是当一个文本文件很大很大时,打开是异常缓慢的</p><h3 id="3-1-2-excel文件"><a href="#3-1-2-excel文件" class="headerlink" title="3.1.2 .excel文件"></a>3.1.2 .excel文件</h3><p>可以用来进行数据的统计,分析等操作,但是当很多个人需要访问同一个.excel文件时,性能也很差</p><h2 id="3-2-数据库"><a href="#3-2-数据库" class="headerlink" title="3.2 数据库"></a>3.2 数据库</h2><p>按照数据结构来组织,存储和管理数据的仓库,软件开发行业一般指的是数据库软件,常见的有:Oracle、MySQL、MSSQL等</p><p>特点:</p><ul><li>数据共享:多用户同时访问数据的稳定性</li><li>故障恢复:数据库软件提供了一套的方法,可以用来发现错误并且修复错误</li><li>减少数据冗余:由于大家都可以使用同一套数据,没有必要重复创建了</li></ul><h2 id="3-3-DBA"><a href="#3-3-DBA" class="headerlink" title="3.3 DBA"></a>3.3 DBA</h2><p>数据库管理员（Database Administrator，简称DBA）</p><p>从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支</p><p>工作是:</p><ol><li>主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</li><li>保证数据库的稳定性、安全性、完整性和高性能.</li></ol><p>在国外，也有公司把DBA称作数据库工程师(Database Engineer)，两者的工作内容基本相同，都是保证数据库服务7*24小时的稳定高效运转，但是需要区分一下DBA和数据库开发工程师(Database Developer)：</p><ol><li>数据库开发工程师的主要职责是设计和开发数据库管理系统和数据库应用软件系统，侧重于软件研发；</li><li>DBA的主要职责是运维和管理数据库管理系统，侧重于运维管理。</li></ol><h1 id="三、网络编程-—-BS-CS模式"><a href="#三、网络编程-—-BS-CS模式" class="headerlink" title="三、网络编程 — BS/CS模式"></a>三、网络编程 — BS/CS模式</h1><p>网络编程 是指<strong>编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。</strong></p><p>注意：</p><ul><li>这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。</li><li>无论是C/S，还是B/S都需要联网，所以不需要互联网的单机软件不在讨论范围内。</li></ul><h2 id="3-1-C-S架构-client-server"><a href="#3-1-C-S架构-client-server" class="headerlink" title="3.1 C/S架构(client/server)"></a>3.1 C/S架构(client/server)</h2><blockquote><p>指的是客户端，服务器架构的意思,很多常见的软件都是这种架构</p></blockquote><ul><li><strong>解释：</strong>对于C/S架构，最为常见的例子就是网络游戏，比如LOL、WOW如果不联网无法使用，你在软件内所做的所有操作通过互联网能够传递到其他的的玩家身上。</li><li><strong>优点:</strong><ul><li>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可</li><li>界面酷炫：客户端可以使用更多系统提供的效果(比如传感信息，浏览器就很难做到),做出更为炫目的效果</li></ul></li><li><strong>缺点:</strong><ul><li>更新软件：如果推出了新版本,不更新客户端无法登陆使用(一部分)</li><li>不同设备访问：如果使用其他的电脑,没有安装客户端的话就无法登陆软件(比如收发邮件)</li></ul></li></ul><h2 id="3-2-B-S架构-Browser-Server"><a href="#3-2-B-S架构-Browser-Server" class="headerlink" title="3.2 B/S架构(Browser/Server)"></a>3.2 B/S架构(Browser/Server)</h2><blockquote><p>指的是浏览器—服务器，是WEB兴起之后的一种架构</p></blockquote><ul><li><strong>解释：</strong>现在所有的网站都是B/S架构,较为常见的例子有百度,知乎,网易云音乐Web等等,所有只需要通过浏览器即可使用.</li><li><strong>优点:</strong><ul><li>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容,但是对用户而言只需要刷新浏览器即可</li><li>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用</li></ul></li><li><strong>缺点:</strong><ul><li>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小</li><li>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一,移动设备兼容性较好,ie6已经越来越少人用了</li></ul></li></ul><h1 id="四、网络通讯模型及协议"><a href="#四、网络通讯模型及协议" class="headerlink" title="四、网络通讯模型及协议"></a>四、网络通讯模型及协议</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>在都知道了浏览器、客户端、服务器、数据库是什么之后，接下来就是核心-重点：浏览器/客户端与服务器之间的网络通讯</p><p><strong>学习网络编程：</strong></p><ol><li>可以掌握实时更新数据的手段</li><li>是开发优秀应用的前提和基础</li></ol><p><strong>网络通讯三要素:传输协议、端口号、IP</strong></p><p>通过 IP 找机器，通过 端口 找程序，通过 协议 确定如何传输数据</p><img src="/images/ComNet/网络通讯.png" alt="img" style="zoom:90%;" /><h2 id="4-2-OSI七层模型"><a href="#4-2-OSI七层模型" class="headerlink" title="4.2 OSI七层模型"></a>4.2 OSI七层模型</h2><p>要了解传输协议，首先需要知道传输过程中分为哪几层传输，每一层的传输协议是不一样的。</p><img src="/images/ComNet/OSI七层模型.png" alt="img" style="zoom:90%;" /><table><thead><tr><th>分层</th><th>功能及协议</th></tr></thead><tbody><tr><td>应用层</td><td>网络服务与最终用户的一个接口  HTTP/HTTPS超文本传输协议、FTP文件传输协议、SMTP邮件传输协议</td></tr><tr><td>表示层</td><td>数据的表示、安全、压缩。</td></tr><tr><td>会话层</td><td>建立、管理、终止会话</td></tr><tr><td></td><td>以上三层：http协议(所有的万维网文件都必须遵守)、HLS(渐进流式传输协议，苹果改造HTTP协议创建的流媒体协议)、RTMP/MMS(实时流式传输协议-微软出品)、XMPP/IMPP/PRIM/SIP(四种IM(即时消息通讯)协议，XMPP最灵活常用) 等等好多好多协议</td></tr><tr><td>传输层</td><td><font color=red>遵循TCP/UDP协议，定义传输数据的协议端口号</font> HTTP协议的端口号默认是80，我们可以根据自己实际情况改的</td></tr><tr><td>网络层</td><td>路由器 <font color=red>遵循IP协议，会给电脑分配IP</font>，进行逻辑地址寻址</td></tr><tr><td>数据链路层</td><td>网卡、网桥、交换机 建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）</td></tr><tr><td>物理层</td><td>光纤、电话线 建立、维护、断开物理连接。（由底层网络定义协议）</td></tr></tbody></table><p>注意：</p><ol><li>传输层和上面的三层就是在客户端里的了</li><li>会话层、表示层、应用层在五层模型中合并为应用层</li></ol><h3 id="OSI模型通讯"><a href="#OSI模型通讯" class="headerlink" title="OSI模型通讯"></a>OSI模型通讯</h3><img src="/images/ComNet/OSI模型通讯.png" alt="img" style="zoom:90%;" /><p>解析说明：计算机A -&gt; B，之所以叫封包/解包，是因为当我们应用层需要获取数据时</p><ul><li>会在应用层生成一个请求的数据包(是按照<font color=red>HTTP协议生成</font>的)</li><li>然后到了传输层，会按照TCP/UDP协议进行封装包装，<font color=red>加了个端口号</font></li><li>到了网络层进行IP协议的封装，<font color=red>加了个协议号</font></li><li>然后经过下两层传到服务器</li><li>服务器会进行一一相对应的解封，知道服务器的应用层，会按照请求，返回响应(响应返回去的过程与来时一样)</li></ul><h2 id="4-3-HTTP协议-定义数据格式"><a href="#4-3-HTTP协议-定义数据格式" class="headerlink" title="4.3 HTTP协议 - 定义数据格式"></a>4.3 HTTP协议 - 定义数据格式</h2><h3 id="4-3-1-HTTP协议概述"><a href="#4-3-1-HTTP协议概述" class="headerlink" title="4.3.1 HTTP协议概述"></a>4.3.1 HTTP协议概述</h3><blockquote><p>协议：经过双方或多方共同商量或谈判后取得的一致意见：双方达成协议｜根据协议办事 | 遵守这样的约束。</p></blockquote><ul><li>网络之间传输数据就需要协议。</li><li>所谓的协议就是双方约定好的一些数据格式。否则两台计算机之间如何识别对方发送过来的 0 1 数据。</li></ul><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>HTTP（Hyper Text Transfer Protocol），超文本(图片，视频，zip等)传输协议，是一种<strong>通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。所以<strong>HTTP协议就是 浏览器 和 服务器 之间通信的一个数据格式规范</strong>。</li><li>HTTP 协议是网络编程使用最为广泛的协议，因为很简单</li><li>它是一个应用层协议，承载于TCP之上</li><li>HTTP协议用于客户端和服务器端之间的通信。由请求和响应构成，是一个标准的客户端服务器模型<ul><li>在两台计算机之间使用HTTP协议通信时，必定一端担任客户端角色，另一端担任服务器端角色</li></ul></li><li>通过请求和响应的交换达成通信。是问答式交互，客户端和服务器一问一答进行通信<ul><li>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回</li><li>也就是说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求时，<strong>不会主动向浏览器推送数据</strong>。这样是安全考虑，也是提高服务器性能的考虑。如果要服务器向浏览器推送数据，则需要使用Socket.IO等额外的技术来解决。</li></ul></li></ul><p>请求响应实例：请求访问某台HTTP服务器上的/index.htm页面资源：</p><ul><li>起始行开头的GET：表示请求访问服务器的类型，称为方法</li><li>随后的字符串/index.html：指明了请求访问的资源对象，也叫请求URI</li><li>最后的HTTP/1.1，即HTTP版本号用来提示客户端使用的HTTP协议的功能</li></ul><img src="/images/ComNet/http-reqres-example.png" style="zoom:80%"><h4 id="2-HTTP协议中的内容"><a href="#2-HTTP协议中的内容" class="headerlink" title="2. HTTP协议中的内容"></a>2. HTTP协议中的内容</h4><ul><li>规定URL的格式<ul><li>协议:// 主机地址: 端口号//路径</li><li><a href="http://www.baidu.com/">http://www.baidu.com</a>: 80//…… (http默认的端口号是80，可以省)</li></ul></li><li>规定客户端和服务器之间的数据传输格式，让客户端和服务器能有效地进行数据沟通<ul><li>规定请求怎么发</li><li>规定响应怎么发</li></ul></li></ul><h4 id="3-HTTP协议特点"><a href="#3-HTTP协议特点" class="headerlink" title="3. HTTP协议特点"></a>3. HTTP协议特点</h4><ol><li>简单快速。HTTP协议简单，所以 HTTP 服务器的程序规模小，通信速度快</li><li>灵活。HTTP 允许传输任意类型的数据</li></ol><h4 id="4-HTTP的版本"><a href="#4-HTTP的版本" class="headerlink" title="4. HTTP的版本"></a>4. HTTP的版本</h4><ul><li>HTTP 0.9 和 1.0 使用非持续连接：限制每次连接只处理一个请求，服务器对客户端的请求做出响应后，立刻断开连接，这种方式可以节省传输时间</li><li>HTTP 1.1 使用持续连接（如今最常用）：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，不会创建那么多的请求了</li></ul><h4 id="5-协议的请求、响应结构"><a href="#5-协议的请求、响应结构" class="headerlink" title="5. 协议的请求、响应结构"></a>5. 协议的请求、响应结构</h4><img src="/images/ComNet/http-structure.png" style="zoom:70%"><h3 id="4-3-2-请求报文的格式"><a href="#4-3-2-请求报文的格式" class="headerlink" title="4.3.2 请求报文的格式"></a>4.3.2 请求报文的格式</h3><blockquote><p>客户端向服务器索取数据的一种行为</p></blockquote><h4 id="1-格式"><a href="#1-格式" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的由客户端发给服务器的 HTTP 请求报文 需要包含以下内容：</p><ul><li><p><strong>请求行</strong></p><ul><li>客户端给服务器的一些额外信息，指定 请求方法、请求资源路径 以及 HTTP协议版本</li><li>格式：<code>请求Method /路径(请求URI) 协议版本</code></li></ul></li><li><p><strong>请求头</strong></p><ul><li><font color=red>请求头中至少包含以下信息</font><ul><li>客户端要访问的服务器主机地址 Host: m.baidu.com</li></ul></li><li>请求头中还可以包含以下附加信息（<strong>可选的请求首部字段</strong>）<ul><li>客户端的类型，客户端的软件环境User-Agent: iPhone AppleWebKit</li><li>客户端所能接收的数据类型Accept: text/html, <em>/</em></li><li>客户端的语言环境Accept-Language: zh-cn</li><li>客户端支持的数据压缩格式Accept-Encoding: gzip</li><li>访问结束后，是否断开连接Connection: Close</li></ul></li></ul></li><li><p><strong>请求体(可选)</strong></p><ul><li>客户端发给服务器的具体数据，例如要上传的文件数据（<strong>内容实体</strong>）</li><li>请求格式<ul><li>每一项请求信息末尾使用 \r\n</li><li>最后一个请求项末尾使用 \r\n\r\n 表示请求结束</li></ul></li></ul></li></ul><img src="/images/ComNet/http-req-msg.png" style="zoom:70%"><h4 id="2-请求方法Method"><a href="#2-请求方法Method" class="headerlink" title="2. 请求方法Method"></a>2. 请求方法Method</h4><blockquote><p>HTTP 协议的请求行有一个请求方法, 它有 8 种, 但是我们只要了解五种 (GET,POST,HEAD,DELETE,PUT)。</p></blockquote><p>向请求URI指定的资源发送请求报文时，采用称为方法的命令。</p><p>方法的作用在于：可以指定请求的资源按期望产生某种行为。</p><img src="/images/ComNet/http-req-method.png" style="zoom:70%"><p>HTTP/1.0和HTTP/1.1支持的方法：(LINK和UNLINK已被HTTP/1.1废弃，不再支持)</p><img src="/images/ComNet/http-req-method2.png" style="zoom:70%"><h5 id="1-GET"><a href="#1-GET" class="headerlink" title="1) GET"></a>1) GET</h5><ol><li>GET 的本质是“得”，从服务器拿数据，效率更高。<font color=red>GET请求能够被缓存，保存在 Cache 目录中 \bundleId 下 Cache.db 中</font><ul><li>cfurl_cache_receiver_data，缓存所有的请求数据</li><li>cfurl_cache_response，缓存所有的响应</li></ul></li><li>在 HTTP 协议定义中，没有对 GET 请求的数据大小限制，不过因为浏览器不同，一般限制在 2~8K 之间</li><li>所有的参数包装在URL中，并且服务器的访问日志会记录，不要传递敏感信息</li></ol><p><font color=red>GET实现网址跳转的原理：</font></p><ul><li>拼接网址，然后跳转。在URL添加参数, 首先在URL 添加一个? , 表示要追加参数, 多个参数用&amp; 连接，然后跳转到这个拼接后的网址</li><li>格式:<a href="http://127.0.0.1/login.php">http://127.0.0.1/login.php</a> ? username = aaa &amp; password = bbb(username和password是服务器后台给我们的文档中固定的)</li><li>注意：<ul><li>http 默认的请求的方法就是GET，是网络访问使用频率最好的方法。</li><li>GET请求能够被缓存(存储在沙盒Cache中，电脑浏览器也可以缓存在历史记录，服务器也可以缓存)(一般来讲用get请求过的网页，下次可能会快点)</li><li><font color=red>如果URL中有中文或者空格，创建出来的URL是空的</font> ，程序会崩溃需要进行%号转义，对URL 进行编码<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[urlString stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span>]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-POST"><a href="#2-POST" class="headerlink" title="2) POST"></a>2) POST</h5><ol><li>POST 的本质是<font color=red>“给”</font>，向服务器发送数据，也可以获得服务器处理之后的结果，效率不如 GET</li><li>POST请求不能被缓存</li><li>POST提交数据比较大，大小靠服务器的设定值限制，PHP通常限定 <font color=red>2M</font></li><li>URL中，只有资源路径，但不包含参数，<font color=red>服务器日志不会记录参数</font>，相对更安全</li><li>参数被包装成二进制的数据体，<font color=red>放在请求体中</font>，格式与 GET 基本一致，只是不包含 ?</li></ol><p>所有设计用户隐私的数据（密码，银行卡号）一定记住使用 POST 方式传递</p><p><font color=red>POST代码中，要用NSMutableURLRequest，要设置HTTPMethod和HTTPBody</font></p><h5 id="3-GET-和-POST-的区别"><a href="#3-GET-和-POST-的区别" class="headerlink" title="3) GET 和 POST 的区别"></a>3) GET 和 POST 的区别</h5><p><strong>显示：</strong></p><ul><li>Post传输数据时，不需要在URL中显示出来，是写在请求体中的，格式一样，没有 ？号，而Get方法会在URL中显示参数值、文件名字。</li><li>get提交格式：url后跟着”?”，由于客户端可能向服务器提交多个键值对，键值对之间用”&amp;”进行分割，如果url中有汉字、特殊符号，则需要对url进行编码</li></ul><p><strong>大小：</strong></p><ul><li><font color=red>http 协议中的 get/post 并没有发送数据大小的限制</font>，对发送数据大小产生限制的是浏览器以及操作系统、服务器。<font color=red>http 本身并没有对 url 长度有所限制。</font></li><li>IE 对 URL 长度的限制是 2083字节（&lt;=IE 8）。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统以及服务器的支持。而 chrome 遇到长度很长的 URL 时，会直接 崩溃。URL 长了，对服务器处理本来也是一种负担</li></ul><p><strong>缓存：</strong></p><ul><li>GET会被手机端cache、web浏览器历史记录、服务器各种缓存，POST不会</li></ul><p><strong>规定：</strong></p><ul><li>根据HTTP规范：Post就是为了将数据传送到服务器段，Get就是为了从服务器段取得数据。而Get之所以也能传送数据，只是用来设计告诉服务器，你到底需要什么样的数据。Post的信息作为http请求的内容，而Get是在Http头部传输的。 </li></ul><p><strong>选择：</strong></p><ul><li>一般来讲：开发的时候，这个都是后台告诉我们的</li><li>而如果是自己写,前台后台都是由我们决定的，可以自由选取使用的方式，当某种方式无法实现需求时，再去进行更改，但就提交普通的文本数据而言get跟post是一致的，post所谓的安全性跟get相比也只是多一些而已</li></ul><p>在web中：</p><ul><li>如果要传递大数据量不能用get，必然要type=“file”上传文件，type:”password”传递密码或者<code>&lt;textarea&gt;</code>提交大量文本字段。</li><li>表单域只有设定了name属性的表单元素才会被提交给服务器</li><li>如果给submit按钮设定了name，那么按钮的value也会被提交到服务器</li><li>对于post的表单重新敲地址栏再刷新就不会提示重新提交了，因为重新敲地址就没有偷偷提交的数据了。</li></ul><h5 id="4-POST增强"><a href="#4-POST增强" class="headerlink" title="4) POST增强"></a>4) POST增强</h5><p>包括：</p><ul><li>上传单文件</li><li>上传多文件</li><li>POST JSON</li><li>POST 自定义对象(对象转字典)</li></ul><p>小文件上传</p><ul><li><p>大小一般都是有限制的 <font color=red>2-8k</font> ，php默认限制是 <font color=red>2M</font> ，超过2M的部分上传不上去的，新浪微博上传图片，单张最大允许 <font color=red>5M</font></p></li><li><p>单个小文件</p><p>应用场景：上传用户的头像</p></li><li><p>多个小文件</p><p>应用场景：微信朋友圈，微博</p></li></ul><h4 id="3-常见的其他请求头字段"><a href="#3-常见的其他请求头字段" class="headerlink" title="3. 常见的其他请求头字段"></a>3. 常见的其他请求头字段</h4><img src="/images/ComNet/请求.jpeg" style="zoom:75%;" /><ul><li>User-Agent<ul><li>浏览器的具体类型　　</li><li>如：User-Agent：Mozilla/5.0 (Windows NT 6.1; rv:17.0) Gecko/20100101 Firefox/17.0</li></ul></li><li>Accept<ul><li>浏览器支持哪些数据类型　　</li><li>如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9;</li></ul></li><li>Accept-Charset<ul><li>浏览器采用的是哪种编码　　</li><li>如：Accept-Charset: ISO-8859-1</li></ul></li><li>Accept-Encoding<ul><li>浏览器支持解码的数据压缩格式　　</li><li>如：Accept-Encoding: gzip, deflate</li></ul></li><li>Accept-Language<ul><li>浏览器的语言环境　　</li><li>如：Accept-Language zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3</li></ul></li><li>Host<ul><li>请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。Host:<a href="http://www.baidu.com/">www.baidu.com</a></li></ul></li><li>Connection<ul><li>表示是否需要持久连接。Keep-Alive/close，HTTP1.1默认是持久连接，它可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。如：Connection: Keep-Alive</li></ul></li><li>Content-Length：表示请求消息正文的长度。对于POST请求来说Content-Length必须出现。</li><li>Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。例如：Content-Type: text/html; charset=’gb2312’</li><li>Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</li><li>Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</li><li>Cookie：最常用的请求头，浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。Referer: <a href="http://www.baidu.com/">http://www.baidu.com/</a></li></ul><h3 id="4-3-3-响应报文"><a href="#4-3-3-响应报文" class="headerlink" title="4.3.3 响应报文"></a>4.3.3 响应报文</h3><blockquote><p>服务器对客户端的请求做出的反应，一般指返回数据给客户端</p></blockquote><h4 id="1-格式-1"><a href="#1-格式-1" class="headerlink" title="1. 格式"></a>1. 格式</h4><p><strong>HTTP协议规定：</strong>一个完整的 HTTP 响应报文包含以下内容：</p><ul><li><strong>状态行</strong><ul><li>格式：<code>HTTP协议版本 状态码 用以解释状态码的原因短语</code>。</li></ul></li><li><strong>响应头</strong><ul><li>服务器返回给客户端的一些额外信息，包含了对服务器的描述、对返回数据的描述<ul><li>服务器的类型Server: Apache/2.4.10 (Unix) PHP/5.5.20</li><li>返回数据的类型Content-Type: text/html</li><li>返回数据的长度Content-Length: 660</li><li>响应时间Date: Thu, 04 Jun 2015 19:31:50 GMT</li><li>ETag(HASH值，用于检测本地资源和服务器资源是否一致)ETag: “294-4e1862f57e7c0”</li></ul></li></ul></li><li><strong>实体内容</strong><ul><li>服务器返回给客户端的具体二进制数据。如果请求的是HTML页面，那么返回的就是HTML代码。如果是JS就是JS代码。</li></ul></li></ul><img src="/images/ComNet/http-res-msg.png" style="zoom:65%"><h4 id="2-响应的状态码"><a href="#2-响应的状态码" class="headerlink" title="2. 响应的状态码"></a>2. 响应的状态码</h4><p>作用：当客户端向服务器发送请求时，描述请求的返回结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><table><thead><tr><th></th><th><strong>类别</strong></th><th><strong>原因短语</strong></th></tr></thead><tbody><tr><td>1XX</td><td>信息状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求，客户端的请求有错误</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table><img src="/images/ComNet/res-status-code.jpg" alt="图片" style="zoom:90%;" /><h4 id="3-响应的content-Type"><a href="#3-响应的content-Type" class="headerlink" title="3. 响应的content-Type"></a>3. 响应的content-Type</h4><ul><li>Content-Type：text/html; charset=utf-8表示返回数据的类型</li><li>服务器通过Content-Type告诉客户端<strong>响应的数据的类型</strong>，这样<strong>浏览器就根据返回数据的类型来进行不同的处理</strong>：<ul><li>如果是图片类型就显示：image/jpeg</li><li>如果是文本类型就直接显示内容：text/plain</li><li>如果是文本类型的html格式就用浏览器渲染该格式：text/html</li><li>……</li></ul></li><li>常用Content-Type：text/html、image/gif、image/jpeg、text/plain、text/javascript…</li><li>Content-Length:表示响应报文体的字节长度，报文头只是描述，返回的具体数据在两个回车之后的内容中</li></ul><p>默认客户端接收到的是字符串，客户端会按照自己默认的方式进行处理；</p><p>比如，我们返回的是一段HTML，但是没有指定格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res1.jpg" alt="图片" style="zoom:100%;" /><p>但是，如果我们指定了格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf8&quot;</span>);</span><br><span class="line">res.end(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/images/ComNet/res2.jpg" alt="图片" style="zoom:90%;" /><p>如果我们希望返回一段JSON数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf8&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="4-常见的其他响应头字段"><a href="#4-常见的其他响应头字段" class="headerlink" title="4) 常见的其他响应头字段"></a>4) 常见的其他响应头字段</h4><img src="/images/ComNet/响应.jpeg" alt="响应" style="zoom:90%;" /><ul><li><p>Cache-Control </p><ul><li>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。 </li><li>下面的设置让客户端对响应内容缓存3600秒，也即在3600秒内，如果客户再次访问该资源，直接从客户端的缓存中返回内容给客户，不要再从服务端获取（当然，这个功能是靠客户端实现的，服务端只是通过这个属性提示客户端“应该这么做”，做不做，还是决定于客户端，如果是自己宣称支持HTTP的客户端，则就应该这样实现）。</li><li><code>Cache-Control: max-age=3600</code></li></ul></li><li><p>ETag</p><ul><li>一个代表响应服务端资源（如页面）版本的报文头属性，如果某个服务端资源发生变化了，这个ETag就会相应发生变化。它是Cache-Control的有益补充，可以让客户端“更智能”地处理什么时候要从服务端取资源，什么时候可以直接从缓存中返回响应。</li><li><code>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code></li></ul></li><li><p>Location</p><ul><li>我们在Asp.net中让页面Redirect到一个某个A页面中，其实是让客户端再发一个请求到A页面，这个需要Redirect到的A页面的URL，其实就是通过响应报文头的Location属性告知客户端的，如下的报文头属性，将使客户端redirect到iteye的首页中：</li><li><code>Location: http://www.google.com.hk</code></li></ul></li><li><p>Set-Cookie</p><ul><li>服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。</li><li><code>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</code></li></ul></li></ul><h3 id="4-3-4-HTTP—持久连接"><a href="#4-3-4-HTTP—持久连接" class="headerlink" title="4.3.4 HTTP—持久连接"></a>4.3.4 HTTP—持久连接</h3><p>早期的HTTP连接模型：每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销</p><img src="/images/ComNet/http-short-connect.png" style="zoom:70%"><p><strong>在 HTTP 1.0 中</strong>, 没有官方的 keepalive 的操作。通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加<code>Connection: Keep-Alive</code>，然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中<code>Connection: Keep-Alive</code>。</p><p>这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端认为会话已经结束，其中一方中断连接。</p><p><strong>HTTP持久连接</strong>（<strong>HTTP persistent connection</strong>，也称作<strong>HTTP keep-alive</strong>或<strong>HTTP connection reuse</strong>）是使用同一个TCP连接来发送和接收多个HTTP请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。</p><p>在 HTTP 1.1 中 所有的连接默认都是持续连接，除非特殊声明不支持。HTTP 持久连接不使用独立的 keepalive 信息，而是仅仅允许多个请求使用单个连接。然而， Apache 2.0 httpd 的<strong>默认连接过期时间</strong>是仅仅15秒，对于 Apache 2.2 只有5秒。短的过期时间的优点是能够快速的传输多个web页组件，而不会绑定多个服务器进程或线程太长时间。</p><img src="/images/ComNet/http-long-connect.png" style="zoom:70%"><p>特点：只要任意一端没有明确提出断开连接，则保持连接状态。</p><p>好处：</p><ul><li>减少了连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载</li><li>减少开销的那部分时间，使HTTP请求和响应能够更早的结束，Web页面显示速度也响应提高</li></ul><h3 id="4-3-5-HTTP—无状态"><a href="#4-3-5-HTTP—无状态" class="headerlink" title="4.3.5 HTTP—无状态"></a>4.3.5 HTTP—无状态</h3><ul><li>HTTP协议是无状态的。使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前的一切的请求或响应报文的信息。</li><li>这是为了更快的处理大量事物，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。正因为HTTP协议本身非常简单，所以才被应用到各种场景</li><li><strong>如果让服务器管理全部客户端状态则会成为很大的负担。</strong>由于不必保存状态，自然可以减少服务器的CPU及内存资源的消耗</li><li>所以哪怕在同一个页面中的js、css、jpg也都要重复的提交Accept-Language、Accept-Encoding、Cookie等</li></ul><h3 id="4-3-6-Cookie"><a href="#4-3-6-Cookie" class="headerlink" title="4.3.6 Cookie"></a>4.3.6 Cookie</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><ul><li>http是一个无状态的协议，每次去请求服务器的时候，服务器是不能记住客户端的。</li><li>保留无状态优点的同时又要解决类似的矛盾问题，于是引入了Cookie技术。</li><li>Cookie(曲奇饼)，可以记录服务器与客户端之间的状态</li><li>Cookie是一个由浏览器和服务器共同协作实现的规范。Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。<ul><li>服务器向客户端发送Cookie<ul><li>是在响应头中</li><li>Set-Cookie:name=value; Path=/; Max-Age=; Domain=*.com<ul><li>name=value; 必须包含</li><li>Path=/; 表示Cookie影响的路径，当访问路径不匹配时，浏览器不会发送该Cookie。<code>/</code>表示该请求下所有路径都发送，也可以指定子路径。</li><li>Max-Age：告诉浏览器该Cookie多长时间过期，单位为秒</li><li>HttpOnly：告知浏览器不允许通过脚本document.cookie访问</li></ul></li></ul></li><li>浏览器将Cookie保存</li><li>之后在每一次请求中浏览器都会将Cookie发向服务器。此时服务器就知道是哪个客户端了。<ul><li>Cookie值的格式是 key=value; foo=bar的形式</li><li>客户端发送的Cookie在请求报文的Cookie字段中</li></ul></li></ul></li></ul><img src="/images/ComNet/http-cookie-no.png" style="zoom:60%"><img src="/images/ComNet/http-cookie-yes.png" style="zoom:60%"><p>Cookie-请求响应报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.客户端第一次请求报文</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">* 首部字段内没有Cookie的相关信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.服务器端响应报文（生成Cookie信息）</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed, =&gt;10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.客户端请求报文（自动发送保存着Cookie的信息）</span></span><br><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure><h4 id="2-Cookie的问题"><a href="#2-Cookie的问题" class="headerlink" title="2. Cookie的问题"></a>2. Cookie的问题</h4><ul><li>不能存储太多内容。因为Cookie体积过大会造成请求和响应速度变慢，所以尽量不要再Cookie中存储大量数据</li><li>将静态资源存储在单独的机器上避免Cookie的无效传输</li><li>不安全。Cookie可以在前后端修改，数据容易被篡改和伪造。所以Cookie对于敏感数据的保护基本是无效的</li></ul><h3 id="4-3-7-Session"><a href="#4-3-7-Session" class="headerlink" title="4.3.7 Session"></a>4.3.7 Session</h3><ul><li>为了解决Cookie无法存储大量数据，以及不安全的问题，Session被设计出来了。</li><li>Session的数据是只保留在服务器端的，客户端无法修改。</li><li>Session不是什么新技术，是基于Cookie实现的。需要和cookie搭配来使用</li><li>服务器端保存key（口令）/value（数据）对象，客户端保存，key（口令），一旦口令被篡改，就丢失了映射关系。服务器端用cookie里面的key来查找对应的session值。</li><li>session可以存在内存或硬盘上都可以。<ul><li>将Session集中化，使用Redis、Memcached等高效的缓存服务器技术</li></ul></li></ul><p>Session的口令依旧保存在客户端，还是存在口令被盗用和伪造的情况，解决方案是将口令通过私钥加密进行签名，使得伪造成本更高</p><h3 id="4-3-8-HTTP-2-0"><a href="#4-3-8-HTTP-2-0" class="headerlink" title="4.3.8 HTTP 2.0"></a>4.3.8 HTTP 2.0</h3><p>HTTP2.0了解吗，相比之前的优化</p><ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送： <a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">HTTP/2 服务器推送（Server Push）教程</a> 也得先客户端发起请求，只不过服务器可以额外推送几个附带资源(不用请求)而已，是需要配置的。</li></ul><h2 id="4-4-TCP-UDP协议-端口号"><a href="#4-4-TCP-UDP协议-端口号" class="headerlink" title="4.4 TCP/UDP协议 - 端口号"></a>4.4 TCP/UDP协议 - 端口号</h2><h3 id="4-4-1-TCP-UDP协议"><a href="#4-4-1-TCP-UDP协议" class="headerlink" title="4.4.1 TCP/UDP协议"></a>4.4.1 TCP/UDP协议</h3><p><strong>TCP(传输控制协议) —生成流式Socket</strong></p><ul><li>建立连接，形成传输数据的通道，在连接中进行<font color=red>大数据传输</font>(数据大小不受限制)</li><li>通过三次握手完成连接，是<font color=red>可靠协议</font>，能安全送达，但是由于必须建立连接，所以<font color=red>效率会稍低</font>.</li></ul><p><strong>TCP三次握手</strong></p><ol><li>客户端向服务器发送一个包，然后等服务器确认 （在吗）</li><li>服务器收到包，确认，然后发送给客户端一个包 （在）</li><li>客服端收到确认，再想服务器发送一个包 （那我就发数据了）</li></ol><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据</p><p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><p><strong>UDP(数据报协议) —生成数据报Socket</strong></p><ul><li>将数据源和目的封装成数据包中，<font color=red>不需要建立连接</font>，只管发送，不确认对方是否接收到因为无需连接，因此是不可靠协议。不需要建立连接，速度快</li><li>每个数据报的<font color=red>大小限制在64K之内</font></li><li>应用场景：多媒体教室／网络流媒体/直播平台/游戏</li></ul><p><strong>对比：</strong></p><ul><li>TCP只是网络七大层协议中的一种，需要封装七层的，</li><li>UDP 使用UDP协议，是不用使用七大层封装的，可以直接发出去，这样的坏处就是会丢包，但也有好处：速度更块，实时性更好<ul><li>应用场景：网络直播(即使丢了几帧也没事)</li></ul></li><li><font color=red>TCP和UDP的表现形式，可以比喻为打电话 比 对讲机</font><ul><li>前者可以听的同时也说(也就是发送的时候，也可以接受)</li><li>后者只能发或者接，不能同时接发</li></ul></li><li>像腾讯微信QQ，语音对讲表现形式虽然是UDP，但是因为丢包，所以实质上是使用的TCP(刚开始使用的是UDP，后来改的)，像好多大公司，一般都会自己写底层协议</li></ul><h3 id="4-4-2-端口号"><a href="#4-4-2-端口号" class="headerlink" title="4.4.2 端口号"></a>4.4.2 端口号</h3><p><strong>端口号</strong></p><ul><li>用于标示进程的逻辑地址，不同进程的标示。</li><li>一条进程一定程度上可以表示是一个应用程序，但是有区别：一个“应用程序”一定可以找到一个“进程”，但一个“进程”不一定会有一个“应用程序”与之对应，这些进程有可能是后台程序，用户看不到，感觉不到。</li></ul><p><strong>作用：</strong></p><ul><li>让应用层的各种应用进程都能将其数据通过端口向下交付给运输层。即<font color=red>连接应用层与网络层</font></li><li><font color=red>端口号存在于UDP和TCP报文的首部，而协议号则是存在这个IP数据报的首部.</font></li></ul><p><strong>有效端口：</strong></p><ul><li>0<code>~</code>65535，其中 0~1024由系统使用或者保留端口，开发中我们不要使用 1024 以下的端口，是可以省略的，不写表明使用协议默认的端口号。</li><li>浏览器网页浏览：<ul><li>http默认80</li><li>https默认443</li></ul></li><li>FTP默认20/21/990</li><li>QQ的端口号：由于QQ用的是UDP协议，默认通讯端口是4000，如果4000被占用的话，那么它就会自动改用4001端口，再被占用，以此类推。</li><li>在mac的活动监视器里可以看到一条条的进程对应的端口号</li></ul><h2 id="4-5-IP协议-协议号"><a href="#4-5-IP协议-协议号" class="headerlink" title="4.5 IP协议 - 协议号"></a>4.5 IP协议 - 协议号</h2><blockquote><p>IP协议是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据到了网络层都要经过IP协议的封装，以IP数据报格式传输。它的特点如下:</p></blockquote><p><strong>不可靠（unreliable）</strong></p><ul><li>意思是它不能保证 IP数据报能成功地到达目的地。</li><li>IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， IP有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li></ul><p><strong>无连接（connectionless）</strong></p><ul><li>意思是IP并不维护任何关于后续数据报的状态信息。</li><li>每个数据报的处理是相互独立的。这也说明， IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B） ，每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li></ul><p><strong>协议号</strong></p><ul><li>其他，太深入的模块，在这里不做赘述，网络层，经过IP协议封装之后，会生成一个协议号：</li><li>协议号是存在于IP数据报的首部的20字节的固定部分，占有8bit.该字段是指出此数据报所携带的是数据是使用何种协议，以便目的主机的IP层知道将数据部分上交给哪个处理过程。也就是协议字段告诉IP层应当如何交付数据。</li><li><font color=red>简单来讲，协议号连接网络层与数据链路层</font></li></ul><h2 id="4-6-TCP-IP协议与socket"><a href="#4-6-TCP-IP协议与socket" class="headerlink" title="4.6 TCP/IP协议与socket"></a>4.6 TCP/IP协议与socket</h2><h3 id="4-6-1-TCP-IP协议"><a href="#4-6-1-TCP-IP协议" class="headerlink" title="4.6.1 TCP/IP协议"></a>4.6.1 TCP/IP协议</h3><p>是个名词，并不是TCP和IP放在一起说了，中文名叫做<font color=red>传输控制协议/互联网络协议</font>，是一种网络通信协议，它规范了网络上的所有通信设备，数据<font color=red>往来格式以及传送方式(传输)。</font></p><p><font color=red>TCP/IP协议是网络的基础，是Internet的语言。</font></p><p>关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p><blockquote><p>我们在<font color=red>传输数据时，可以只使用(传输层网络层)TCP/IP协议</font>，但是那样的话，没有应用层，便无法识别数据内容。</p><p>如果想要使传输的数据有意义，则必须使用到应用层HTTP协议。<font color=red>应用层提供了封装或者显示数据的具体形式</font></p></blockquote><h3 id="4-6-2-socket-套接字层、插座"><a href="#4-6-2-socket-套接字层、插座" class="headerlink" title="4.6.2 socket(套接字层、插座)"></a>4.6.2 socket(套接字层、插座)</h3><p>实际上socket就是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(<font color=red>API，内部按照TCP/IP协议对数据封包解包，并记录生成的端口号与IP地址</font>)。Socket的出现只是使我们程序员能够更方便的使用TCP/IP协议栈而已，是对TCP/IP的抽象。</p><p>通过Socket，我们能更好地使用TCP/IP协议。</p><p>通信的两端，也就是客户端和服务器都有 Socket(IP地址和端口号两部分)，所以可以说网络通信其实就是在 Socket 间的通信。数据在两个 Socket 间通过 IO 传输 (input/output，<font color=red>一个请求可以看做一次IO传输</font>)</p><p>Socket 是纯C语言的，是跨平台的<strong>使用socket替代HTTP做网络请求</strong></p><h4 id="1-socket通讯的原理"><a href="#1-socket通讯的原理" class="headerlink" title="1. socket通讯的原理"></a>1. socket通讯的原理</h4><p><img src="/images/ComNet/socket%E5%8E%9F%E7%90%86.jpg" alt="img"></p><h4 id="2-C版本的socket通讯"><a href="#2-C版本的socket通讯" class="headerlink" title="2. C版本的socket通讯"></a>2. C版本的socket通讯</h4><img src="/images/ComNet/socket移动端代码.png" alt="img" style="zoom:90%;" /><p>网络通讯链中，将应用层省去，用Socket做网络请求，HTTP的内容：设置服务器的信息等</p><ol><li><p>创建socket</p><p>使用socket函数。返回值是int ,&gt;0就表示成功</p></li><li><p>创建服务器，并将我们创建的socket连接到服务器</p><p>使用connect函数。返回值是int：0代表连接成功，其他失败)</p></li><li><p>向服务器发送消息</p><p>使用send函数。返回值：如果成功返回发送的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>接收服务器返回的数据</p><p>使用recv函数。返回值：如果成功返回数据的字节数，如果失败返回SOCKET_ERROR</p></li><li><p>关闭连接</p><p>clock(创建的socket)</p></li></ol><p>iOS移动端有一个封装的很好的socket套接字库：GCDAsyncSocket</p><h2 id="4-7-长连接与短连接"><a href="#4-7-长连接与短连接" class="headerlink" title="4.7 长连接与短连接"></a>4.7 长连接与短连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的</p><p><strong>短连接</strong></p><p>数据请求结束后，立即断开连接，能够及时释放服务器资源</p><p>让服务器能够为更多的用户提供服务</p><p><strong>长连接</strong></p><p>一旦连接建立之后，始终保持连接状态，后续只需发送和接收数据即可，数据响应更及时</p><p>长连接对服务器资源占用比较大</p><p>对交互响应要求快的应用，例如即时通讯，需要使用长连接</p><p><strong>心跳包</strong></p><p>是检测长连接的重要技术手段</p><p>可以由服务器发送，定时向客户端发送小数据，根据回执判断客户端是否在线</p><p>也可以由客户端发送，定时向服务器发送小数据，报告客户端当前在线</p><h1 id="五、网络编程相关概念"><a href="#五、网络编程相关概念" class="headerlink" title="五、网络编程相关概念"></a>五、网络编程相关概念</h1><h2 id="5-1-URL"><a href="#5-1-URL" class="headerlink" title="5.1 URL"></a>5.1 URL</h2><ul><li>Uniform Resoure Locator：统一<strong>资源</strong>定位器</li><li>URL地址格式排列为：scheme://host:port/path<ul><li>Internet资源类型（scheme）：指出WWW 客户程序用来操作的工具。</li><li>服务器地址（host）：指出WWW 页所在的服务器域名</li><li>端口（port）：有时（并非总是这样），对某些资源的访问来说，需给出相应的服务器提供端口号</li><li>路径（path）：指明服务器上某资源的位置</li></ul></li></ul><h2 id="5-2-IP地址、域名与DNS服务器"><a href="#5-2-IP地址、域名与DNS服务器" class="headerlink" title="5.2 IP地址、域名与DNS服务器"></a>5.2 IP地址、域名与DNS服务器</h2><h3 id="5-2-1-IP地址"><a href="#5-2-1-IP地址" class="headerlink" title="5.2.1 IP地址"></a>5.2.1 IP地址</h3><p>ip唯一标识 一台设备</p><p>端口号标识一个设备上的应用</p><p>几个特殊的IP地址</p><table><thead><tr><th>IP地址</th><th>含义</th></tr></thead><tbody><tr><td>localhost</td><td>代表本机地址。不走网卡</td></tr><tr><td>127.0.0.1</td><td>代表本地回环地址。走网卡</td></tr><tr><td>192.168.xx.xx</td><td>代表局域网的IP地址。不管是否是本机，会通过网卡发请求给路由或交换机，在请求回来到指定的电脑</td></tr><tr><td>0.0.0.0</td><td>代表任意的IP地址</td></tr><tr><td>255.255.255.255</td><td>广播地址</td></tr></tbody></table><p><strong>协议域：（数字最大就是255）</strong></p><ul><li>IPV4：有四段</li><li>IPV6：有六段</li></ul><h3 id="5-2-2-域名"><a href="#5-2-2-域名" class="headerlink" title="5.2.2 域名"></a>5.2.2 域名</h3><ul><li>是一串用点分隔的名字组成的Internet上，一台计算机或者一个计算机组的名称，用来标识位置</li><li>.com国际域名 全世界都可以访问 </li><li>.cn中国域名</li></ul><p><strong>两者之间的关系？</strong></p><p>如果是前者，那么一个域名对应一个IP，如果是后者，例如百度这种大公司，肯定是个计算机组，那么这个域名下面就有好多个服务器，也就是好多个IP，并且我们通过访问主机域名，百度返回得到的IP是随机的</p><h3 id="5-2-3-DNS服务器"><a href="#5-2-3-DNS服务器" class="headerlink" title="5.2.3 DNS服务器"></a>5.2.3 DNS服务器</h3><p>注意：我们不是通过域名找到服务器的，而是通过IP地址找到的，</p><p>我们访问域名— <font color=red>DNS域名解析服务器帮我们把域名转换成IP地址</font>—DNS返回给我们的电脑— 电脑通过IP地址找到服务器</p><p>(我们一连接上网络，在网络信息中就可以看到我们的DNS服务器)</p><p>举例：如果我们的电脑网络能上QQ等软件，但是浏览器不能上，很有可能就是DNS服务器出问题了，这个时候：要么直接输入我们要访问的网站的IP地址，要么换一个DNS服务器，谷歌提供了一个8.8.8.8，我们可以使用。</p><h2 id="5-3-端口号"><a href="#5-3-端口号" class="headerlink" title="5.3 端口号"></a>5.3 端口号</h2><h3 id="5-3-1-端口的分类"><a href="#5-3-1-端口的分类" class="headerlink" title="5.3.1 端口的分类"></a>5.3.1 端口的分类</h3><ul><li>端口范围：0-65535之间。端口的意义：用来区分不同的进程。</li><li>端口分为以下三类：<ul><li>公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯 明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯,ftp21,smtp25,….。</li><li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于 这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li></ul></li><li>动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端 口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li></ul><h3 id="5-3-2-使用"><a href="#5-3-2-使用" class="headerlink" title="5.3.2 使用"></a>5.3.2 使用</h3><p>IP能够定位机器，端口号可以定位一个应用程序</p><ul><li>node 默认是3000 多了往上加</li><li>Apache服务器，访问资源<ul><li>部署：丢到服务器软件配置的根目录下</li><li>访问：ip+刚开始配的服务器根目录下的要访问的文件的路径</li></ul></li><li>node服务器，访问资源<ul><li>部署：不需要配置根目录，只需要一个js文件。<ul><li>这个js文件中必须配置了端口号，集成了http核心模块的功能。 </li><li>如果做了下面这些操作，node+文件名，命令行中会一直卡在这里，进程一直在开启着，别人可以访问<br>如果只是一个普通的js文件，node+文件名，一下子就执行完了。做不到一直开启的状态。</li></ul></li><li>访问：ip+端口号+此项目中文件名<ul><li>浏览器中访问，肯定是上面要齐全</li><li>如果是html中写url的时候，如果是访问的本项目中的文件(不管是后台文件 还是前端文件)，可以直接写相对路径，比如url: ‘./app.js’</li><li>端口号：默认3000，如果你开了好几个node项目，那就需要注意，端口号要一致。</li><li>文件名：如果不写，默认是会主动运行这个项目中的index.html文件，一般服务器都会做这个设置，到了nodejs中，因为所有请求都是这个js文件接收的，所以一般都会写这么个代码。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pathname == <span class="string">&#x27;/&#x27;</span> &amp;&amp; req.method == <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    fs.readFile(path.join(__dirname, <span class="string">&#x27;index.html&#x27;</span>), <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>注意：</p><ul><li>我们所有对这个端口的访问，都是这个js文件，接收，并处理的。与其他的服务器不一样。<ul><li>比如：Apache，就是我配置了根目录，你想访问什么文件，拿到那个文件的路径就可以，到时候，你的访问是这个文件进行处理。具体代码见笔记中两个js文件</li><li>但nodejs不一样，比如：你要通过这个端口号访问 :3000/public/index.html。这个时候，是js文件接收到这个请求，然后将public/index.html文件的内容readFild读出来，然后返给前端。</li></ul></li><li>一个js文件一个端口号，我们可以同时node + 文件名，同时开启好几个node项目，但是注意端口号要区分开</li></ul><h2 id="5-4-浏览器中跨域的场景"><a href="#5-4-浏览器中跨域的场景" class="headerlink" title="5.4 浏览器中跨域的场景"></a>5.4 浏览器中跨域的场景</h2><ul><li><p>域名不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.com</span><br><span class="line">www.liuxi.com 即为不同的域名</span><br></pre></td></tr></table></figure></li><li><p>二级域名相同，子域名不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.wuyou.wu.com </span><br><span class="line">www.liuxi.wu.com 为子域不同</span><br></pre></td></tr></table></figure></li><li><p>端口不同，协议不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.wuyou.com </span><br><span class="line">https:&#x2F;&#x2F;www.wuyou.com</span><br><span class="line">www.wuyou.con:8888</span><br><span class="line">www.wuyou.con:8080</span><br></pre></td></tr></table></figure></li></ul><p>前端需要用到跨域的地方：</p><ul><li>加载图片，文件资源。很少会跨域，你用别人的网站图片是另一码事……</li><li>ajax请求。</li></ul><ol><li><p><code>使用ctn节点，进行动静资源分离</code>时，也就是说，我们的前端文件，与需要的后端文件，就没在一个项目里</p></li><li><p>我们后段需要请求别的端口号，或者说是别的服务器项目中的后台文件，这个时候，按理说不应该是前端的任务，正儿八经的，应该是前端文件所在项目中的后台文件，帮我们把数据请求回来，因为他们是不存在跨域的，</p></li></ol><p><font color='red'>跨域是浏览器限制的</font></p><p>但是，如果后台的人不给我们做这一步(它是个半瓶水，或者是个棒槌) 或者 说这个接口做了，用几天就不用了(比如双十一这种暂时的活动接口)，那就需要我们进行jsonp跨域请求了,</p><p>由上面可知，用到跨域的情形还是挺少的，而且我们前面讲过如何解决跨域：</p><ul><li>jsonp</li><li>自己写个php后台文件，请求数据做中转。</li><li>如果只是调试阶段有跨域，我们有浏览器插件</li></ul><h2 id="5-5-前后端分离"><a href="#5-5-前后端分离" class="headerlink" title="5.5 前后端分离"></a>5.5 前后端分离</h2><p>顾名思义，前后端分离就是把一个应用的前端代码和后端代码分开来写，为什么要这样做呢？先说说不分开会有什么问题，在传统的 Java Web 开发模式中，前端页面使用 JSP，而 JSP 代码的开发往往不是完全由后端程序猿来完成的。</p><p>JSP 页面的开发步骤是首先需要前端程序猿完成 HTML 代码，然后交给后端程序猿转为 JSP 再进行开发，后端如果遇到页面问题，就需要找前端来解决，但是此时前端看到的代码已经不是他之前写的 HTML 了，是混合了一大堆标签的 JSP 代码，而前端又不懂 JSP，场面就非常尴尬。</p><h2 id="5-6-网站的优化"><a href="#5-6-网站的优化" class="headerlink" title="5.6 网站的优化"></a>5.6 网站的优化</h2><ul><li>网页中如果有图片、css、js等外部文件的话，图片、css、js都在单独的请求中，也就是并不是页面的所有内容都在一个请求中完成，而是每个资源都有一个请求</li></ul><p>思想</p><ul><li>能压缩的压缩能合并的合并：少一个script也好，少一次请求  </li><li>少用js去遍历对象或者写for循环</li><li>能提前运算好的提前运算好，使用枚举法 <code>var a=1024*1024;</code>这么写一点都不好</li><li>流式(响应式)图片 — 图片压缩</li></ul><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域</td></tr><tr><td>请求带宽</td><td>开启GZip，精简JavaScript，移除重复脚本，图像优化</td></tr><tr><td>缓存利用</td><td>使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免CSS表达式，避免重定向</td></tr></tbody></table><p>雅虎14条优化原则</p><ul><li>减少HTTP请求数<ul><li>合并脚本和样式表：分开时分开。就很多网站因为首页的访问量太大，将首页的css和js直接写在页面文件中而不是外部引用。</li><li>CSS Sprites：页面上的背景图片合并为一张，通过css的background-position属性定义不同的值来取背景。<a href="https://links.jianshu.com/go?to=http://www.csssprites.com/">http://www.csssprites.com/</a>可帮助将上传的图片合并并给出对应的background-position坐标。</li></ul></li><li>使用CDN（Content Delivery Network）：从最近的CDN节点请求数据</li><li>添加Expire头，或者Cache-control。通过缓存减少请求数</li><li>Gzip组件。<ul><li>通过压缩减少文件传输的大小。</li><li>所有的文件内容都应该被压缩。</li></ul></li><li>将CSS样式放在页面的上方。一次渲染</li><li>将script放在页面最下面<ul><li>防止脚本阻塞页面的下载，减少页面可视元素的加载时间。（防止页面加载中途去下载脚本）</li><li>防止脚本阻塞并行下载数量</li></ul></li><li>避免在CSS中使用Expressions</li><li>把javascript和css都放到外部文件中<ul><li>把css和js写在页面内容可减少两次请求，但也增大了页面的大小。使用外部文件，如果做了缓存，也不会有两次多余的http请求。</li><li>要视情况而定，参见第一点。</li></ul></li><li>减少DNS查询。减少DNS解析过程、加快页面加载速度。建议一个页面所包含的域名数量尽量控制在2-4个。</li><li>压缩JavaScript和CSS。<ul><li>通过压缩，减少页面字节数，从而提高加载速度，同时还可以起到一定的保护作用。</li><li>但是会丧失可读性，阿里巴巴是在发布的时候在服务器端进行压缩。</li></ul></li><li>避免重定向。增加一次冲重定向就会增加一次web请求。</li><li>移除重复的脚本</li><li>配置实体标签（ETags）</li><li>使AJAX缓存</li></ul><h2 id="5-7-在地址栏输入网址后页面是如何呈现的？"><a href="#5-7-在地址栏输入网址后页面是如何呈现的？" class="headerlink" title="5.7 在地址栏输入网址后页面是如何呈现的？"></a>5.7 在地址栏输入网址后页面是如何呈现的？</h2><ul><li>DNS 把域名转化成ip<ul><li>DNS服务器来做这个事情</li><li>运营商提供的dns服务器</li></ul></li><li>CDN 内容分发网络</li></ul><p>输入 URL：<a href="http://www.baidu.com/">http://www.baidu.com</a></p><ul><li>DNS 域名解析<ul><li>计算机无法识别域名，计算机与计算机之间要想进行通信，必须通过ip地址用来定位该计算机所在的位置</li><li>在浏览器中，输入的ip地址或者域名，默认给你加了一个80端口号（对方的服务器监听的就是80端口）</li><li>158.12.25.652  域名就是为了好记</li><li>为了好记，所以我们的 万维网提供了 一个 域名这样的概念</li><li>当你输入了 ip 地址后，浏览器会自动去 找DNS域名解析服务器</li></ul></li><li>将用户输入的地址封装成 HTTP Request 请求报文 发送到服务器<ul><li>浏览器将用户输入的 URL 地址根据HTTP协议 封装成了  http 请求报文（请求头+请求行+请求体）</li><li>该报文说白了也就是字符串而已，最终也要被转成了二进制数据再发送到服务器</li></ul></li><li>后台服务器接收到用户HTTP Request 请求报文<ul><li>后台服务器接收到 客户端发送给自己的数据（二进制数据）<ul><li>首先把二进制数据按照编码解析成字符（人类可以识别的）</li><li>解析成字符之后，再按照 HTTP 协议规范中定义的格式解析出来</li></ul></li></ul></li><li>后台服务器处理用户请求信息<ul><li>当得到用户请求报文之后，根据请求报文中的 get、post取出URL中的查询字符串 或者 请求体中的数据</li><li>根据用户的特定的请求数据做特定的处理</li></ul></li><li>后台服务器将相应结果封装到 HTTP Response 响应报文中 发送给客户端<ul><li>当我们解析和处理完用户请求报文消息之后</li><li>服务器开始将具体的 要发送给客户端的数据 根据 HTTP 协议规范 封装成 HTTP协议响应报文</li><li>响应头、响应字段、响应体</li><li>该数据说白了也是具有特定格式的字符串而已，最终这个字符串也要转换成二进制数据发送到客户端</li><li>发送到客户端也是通过 Socket（ip地址、端口号） 发送到了该客户单</li></ul></li><li>用户浏览器接收到响应后开始渲染html、css，解析和执行 JavaScript 代码<ul><li>当客户端解析到 服务器发送过来的 二进制数据</li><li>客户端浏览器也会将 二进制数据 根据编码类型解析成 字符串</li><li>然后根据 HTTP 协议，解析服务器发送过来的 响应报文</li><li>然后根据响应报文中的报文内容（报文头、报文体）做具体的解析</li></ul></li><li>当浏览器在解析的过程中遇到 一些静态资源时，会再次重复上面的步骤</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程：是指&lt;strong&gt;编写程序使两台联网的计算机可以完成网络数据交互，完成网络通信。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：这里的计算机泛指可以上网的设备，比如PC、手机、服务器、智能电视等等。&lt;/p&gt;
&lt;p&gt;我们处于互联网时代，我们可以随时随地通过 Interne</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端日志库设计</title>
    <link href="https://tenloy.github.io/2021/09/02/Log.html"/>
    <id>https://tenloy.github.io/2021/09/02/Log.html</id>
    <published>2021-09-02T18:53:12.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、现存问题"><a href="#一、现存问题" class="headerlink" title="一、现存问题"></a>一、现存问题</h2><p>目前，业内移动端日志库大多都存在以下几个问题：</p><ul><li>卡顿，影响性能</li><li>日志丢失</li><li>安全性</li><li>日志分散</li></ul><p>首先，日志模块作为底层的基础库，对上层的性能影响必须尽量小，但是日志的写操作是非常高频的，频繁在Java堆里操作数据容易导致GC的发生，从而引起应用卡顿，而频繁的I/O操作也很容易导致CPU占用过高，甚至出现CPU峰值，从而影响应用性能。</p><p>其次，日志丢失的场景也很常见，例如当用户的App发生了崩溃，崩溃日志还来不及写入文件，程序就退出了，但本次崩溃产生的日志就会丢失。对于开发者来说，这种情况是非常致命的，因为这类日志丢失，意味着无法复现用户的崩溃场景，很多问题依然得不到解决。</p><p>第三点，日志的安全性也是至关重要的，绝对不能随意被破解成明文，也要防止网络被劫持导致的日志泄漏。</p><p>最后一点，对于移动应用来说，日志肯定不止一种，一般会包含端到端日志、代码日志、崩溃日志、埋点日志这几种，甚至会更多。不同种类的日志都具有各自的特点，会导致日志比较分散，查一个问题需要在各个不同的日志平台查不同的日志，例如端到端日志还存在日志采样，这无疑增加了开发者定位问题的成本。</p><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><p>作为一款基础日志库，在设计之初就必须考虑如何解决日志系统现存的一些问题。</p><h3 id="2-1-卡顿，影响性能"><a href="#2-1-卡顿，影响性能" class="headerlink" title="2.1 卡顿，影响性能"></a>2.1 卡顿，影响性能</h3><p>I/O是比较耗性能的操作，写日志需要大量的I/O操作，为了提升性能，首先要减少I/O操作，最有效的措施就是加缓存。先把日志缓存到内存中，达到一定大小的时候再写入文件。为了减少写入本地的日志大小，需要对数据进行压缩，为了增强日志的安全性，需要对日志进行加密。然而这样做的弊端是：</p><ul><li>对Android来说，对日志加密压缩等操作全部在Java堆里面。由于日志写入是一个高频的动作，频繁地堆内存操作，容易引发Java的GC，导致应用卡顿；</li><li>集中压缩会导致CPU短时间飙高，出现峰值；</li><li>由于日志是内存缓存，在杀进程、Crash的时候，容易丢失内存数据，从而导致日志丢失。</li></ul><p>Logan的解决方案是通过Native方式来实现日志底层的核心逻辑，也就是C编写底层库。这样做不光能解决Java GC问题，还做到了一份代码运行在Android和iOS两个平台上。同时在C层实现流式的压缩和加密数据，可以减少CPU峰值，使程序运行更加顺滑。而且先压缩再加密的方式压缩率比较高，整体效率较高，所以这个顺序不能变。</p><h3 id="2-2-日志丢失"><a href="#2-2-日志丢失" class="headerlink" title="2.2 日志丢失"></a>2.2 日志丢失</h3><p>加缓存之后，异常退出丢失日志的问题就必须解决，Logan为此引入了MMAP机制。MMAP是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。MMAP机制的优势是：</p><ul><li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件；</li><li>经过测试发现，操作MMAP的速度和操作内存的速度一样快，可以用MMAP来做数据缓存；</li><li>MMAP将日志回写时机交给操作系统控制。如内存不足，进程退出的时候操作系统会自动回写文件；</li><li>MMAP对文件的读写操作不需要页缓存，只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li></ul><p>引入MMAP机制之后，日志丢失问题得到了有效解决，同时也提升了性能。不过这种方式也不能百分百解决日志丢失的问题，MMAP存在初始化失败的情况，这时候Logan会初始化堆内存来做日志缓存。根据我们统计的数据来看，MMAP初始化失败的情况仅占0.002%，已经是一个小概率事件了。</p><h3 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3 安全性"></a>2.3 安全性</h3><p>日志文件的安全性必须得到保障，不能随意被破解，更不能明文存储。Logan采用了流式加密的方式，使用对称密钥加密日志数据，存储到本地。同时在日志上传时，使用非对称密钥对对称密钥Key做加密上传，防止密钥Key被破解，从而在网络层保证日志安全。</p><h3 id="2-4-日志分散"><a href="#2-4-日志分散" class="headerlink" title="2.4 日志分散"></a>2.4 日志分散</h3><p>针对日志分散的情况，为了保证日志全面，需要做本地聚合存储。Logan采用了自研的日志协议，对于不同种类的日志都会按照Logan日志协议进行格式化处理，存储到本地。当需要上报的时候进行集中上报，通过Logan日志协议进行反解，还原出不同日志的原本面貌。同时Logan后台提供了聚合展示的能力，全面展示日志内容，根据协议综合各种日志进行分析，使用时间轴等方式展示不同种日志的重要信息，使得开发者只需要通过Logan平台就可以查询到某一段时间App到底产生了哪些日志，可以快速复现问题场景，定位问题并处理。</p><p>关于Logan平台是如何展示日志的，下文会再进行说明。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>采集工具设计：</p><ul><li>性能：避免了CPU峰值，同时减少了CPU使用，避免卡顿情况发生。</li><li>丢失率：跨平台C库提供了日志协议数据的格式化处理，针对大日志的分片处理，引入了MMAP机制解决了日志丢失问题</li><li>安全性：使用AES进行日志加密确保日志安全性</li><li>侵入性</li><li>存储空间：<ul><li>采用“先压缩再加密”的顺序，使用流式的加密和压缩。</li><li>为了节约用户手机空间大小，日志文件只保留最近7天的日志，过期会自动删除。在Android设备上Logan将日志保存在沙盒中，保证了日志文件的安全性。</li></ul></li><li>用户流量：由于日志上报网络请求的频次相对较高，为了节省用户流量，日志通常不会太大。尤其是网络日志等这种实时性较高的日志。</li></ul><p>采集时机设计：</p><ul><li>进行预埋，在一些场景下上传，由于日志上报需要网络请求，对于移动App来说频繁网络请求会比较耗电，所以需要注意频率：<ul><li>在特定行为发生时进行上报（例如用户投诉）</li><li>在日志积累到一定程度</li><li>一定时间上报一次</li></ul></li><li>回捞上报：是由后端使用PushSDK向客户端发起回捞指令<ul><li>日志回捞平台需要有着严格的审核机制，确保开发者不会侵犯用户隐私，只关注问题场景。</li><li>日志回捞，依赖于Push。客户端被唤醒接收Push消息，受到一些条件影响：<ul><li>Android想要后台唤醒App，需要确保Push进程在后台存活；</li><li>iOS想要后台唤醒APP，需要确保用户开启后台刷新开关；</li><li>网络环境太差，Android上Push长连建立不成功。</li></ul></li></ul></li><li>主动上报：通过客服引导用户上报</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://tech.meituan.com/2018/02/11/logan.html">美团移动端基础日志库——Logan</a></li><li><a href="https://tech.meituan.com/2018/10/11/logan-open-source.html">Logan：美团开源移动端基础日志库</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、现存问题&quot;&gt;&lt;a href=&quot;#一、现存问题&quot; class=&quot;headerlink&quot; title=&quot;一、现存问题&quot;&gt;&lt;/a&gt;一、现存问题&lt;/h2&gt;&lt;p&gt;目前，业内移动端日志库大多都存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡顿，影响性能&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Log" scheme="https://tenloy.github.io/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃监控与分析</title>
    <link href="https://tenloy.github.io/2021/07/01/Crash-Monitor.html"/>
    <id>https://tenloy.github.io/2021/07/01/Crash-Monitor.html</id>
    <published>2021-07-01T16:24:21.000Z</published>
    <updated>2021-09-17T10:59:07.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>常见的 crash 类型总结下来，分为三种：</p><ul><li>Mach kernel exceptions：是指最底层的内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。 <strong>很多内存错误、访问错误的地址造成的异常会以Mach异常、unix标准的signal机制的形式造成crash的现象。</strong></li><li>Unix Fatal signals：又称BSD 信号，如果开发者没有捕获Mach异常，则会被host层的方法ux_exception()将异常转换为对应的UNIX信号，并通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single。</li><li>应用级异常：<ul><li>Objective-C exceptions（NSException），它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。</li><li>C++ exceptions</li><li>Main thread deadlock (experimental)  主线程死锁</li><li>Custom crashes (e.g. from scripting languages) 自定义崩溃</li></ul></li></ul><h2 id="一、Darwin操作系统简单介绍"><a href="#一、Darwin操作系统简单介绍" class="headerlink" title="一、Darwin操作系统简单介绍"></a>一、Darwin操作系统简单介绍</h2><p>可以通过下面两张图，简单的看一下OS/iOS系统的分层结构</p><img src="/images/RunLoop/RunLoop_3.png" alt="os-structure" style="zoom:60%;" /><p>Darwin是macOS和iOS操作环境的操作系统部分。苹果公司于2000年把Darwin发布给开放源代码社区。</p><ul><li>既然是OS，那肯定要包括系统内核XNU、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</li><li>XNU是一个混合内核，它采用了来自OSF的OSFMK 7.3(Open Software Foundation Mach Kernel)和FreeBSD的各种要素(包括过程模型，网络堆栈和虚拟文件系统)，还有一个称为I/O Kit的面向对象的设备驱动程序API。</li><li>XNU将宏内核与微内核两者的特性兼收并蓄，以期同时拥有两种内核的优点。<strong>微内核的灵活性</strong>：比如在微内核中提高操作系统模块化程度以及让操作系统更多的部分接受内存保护的消息传递机制。<strong>宏内核的性能</strong>：宏内核在高负荷下表现的高性能。</li></ul><p>我们在深入看一下 Darwin 这个核心的架构：</p><img src="/images/RunLoop/RunLoop_4.png" alt="os-structure" style="zoom:70%;" /><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p><ul><li>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</li><li>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。(BSD是宏内核)</li><li>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</li></ul><p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 也是RunLoop的底层实现支持技术。</p><p>iOS中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的：</p><p><img src="/images/crash/os-structure2.png" alt="os-structure2"></p><h2 id="二、Mach异常与Unix信号的异常捕获"><a href="#二、Mach异常与Unix信号的异常捕获" class="headerlink" title="二、Mach异常与Unix信号的异常捕获"></a>二、Mach异常与Unix信号的异常捕获</h2><p>iOS系统自带的 Apple’s Crash Reporter 记录在设备中的Crash日志，Exception Type项通常会包含两个元素： Mach异常 和 Unix信号。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception Type:         EXC_BAD_ACCESS (SIGSEGV)    </span><br><span class="line">Exception Subtype:      KERN_INVALID_ADDRESS at 0x041a6f3</span><br></pre></td></tr></table></figure><p>Mach异常是什么？它又是如何与Unix信号建立联系的？</p><h3 id="2-1-Mach-kernel-exceptions"><a href="#2-1-Mach-kernel-exceptions" class="headerlink" title="2.1 Mach kernel exceptions"></a>2.1 Mach kernel exceptions</h3><h4 id="2-1-1-Mach异常的产生"><a href="#2-1-1-Mach异常的产生" class="headerlink" title="2.1.1 Mach异常的产生"></a>2.1.1 Mach异常的产生</h4><p>Mach异常是指最底层的内核级异常。</p><p>捕获方法：每个thread，task，host都有一个异常端口数组，Mach的部分API暴露给了用户态，用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常，抓取Crash事件。</p><img src="/images/crash/Mach-except-handle.jpg" alt="Mach-except-handle" style="zoom:60%;" /><h4 id="2-1-2-Mach异常的捕获"><a href="#2-1-2-Mach异常的捕获" class="headerlink" title="2.1.2 Mach异常的捕获"></a>2.1.2 Mach异常的捕获</h4><img src="/images/crash/1435544422851512.png" alt="" style="zoom:90%;" /><h3 id="2-2-Unix-BSD-Signals"><a href="#2-2-Unix-BSD-Signals" class="headerlink" title="2.2 Unix/BSD Signals"></a>2.2 Unix/BSD Signals</h3><h4 id="2-2-1-信号的产生"><a href="#2-2-1-信号的产生" class="headerlink" title="2.2.1 信号的产生"></a>2.2.1 信号的产生</h4><p>Unix信号，又称为BSD 信号。</p><ul><li>Mach异常如果没在Mach级别处理，那么都会在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。</li><li>因为硬件产生的信号（通过CPU陷阱）被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号（通过调用kill和pthread_kill）也首先沉下来被转换为Mach异常，再转换为Unix信号。</li><li>转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样不必了解Mach内核也可以通过Unix信号的方式来兼容开发。</li></ul><p>因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach层的EXC_BAD_ACCESS异常，在host层被转换成SIGSEGV信号投递到出错的线程。</p><img src="/images/crash/BSD-signals.jpg" alt="BSD-signals" style="zoom:60%;" /><h4 id="2-2-2-信号的捕获"><a href="#2-2-2-信号的捕获" class="headerlink" title="2.2.2 信号的捕获"></a>2.2.2 信号的捕获</h4><p>既然最终以信号的方式投递到出错的线程，那么就可以通过注册signalHandler来捕获信号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGSEGV,signalHandler);</span><br></pre></td></tr></table></figure><h4 id="2-2-3-系统中都有哪些信号"><a href="#2-2-3-系统中都有哪些信号" class="headerlink" title="2.2.3 系统中都有哪些信号"></a>2.2.3 系统中都有哪些信号</h4><p>默认情况下，大多数信号都是致命的（Fatal signals）。 任何具有“terminate终止”或“dump core核心转储”的默认操作的信号都是致命的，除非它被忽略或明确处理。查看方式：</p><ul><li><p><code>usr/include/sys/signal.h</code> 中，定义了31种</p></li><li><p>也可以使用命令 <code>kill -l</code> 查看，显示了25种</p></li><li><p>针对特定的信号，应用程序可以写对应的信号处理函数。如果不指定，则采取默认的处理方式</p></li><li><p>core dump：是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件(有的系统中将文件命名为 <code>core.进程号</code>，也有的命名为 <code>core-命令名-pid-时间戳</code>)。这种信息往往用于调试。</p></li></ul><h3 id="2-3-常见的Mach异常与Unix信号"><a href="#2-3-常见的Mach异常与Unix信号" class="headerlink" title="2.3 常见的Mach异常与Unix信号"></a>2.3 常见的Mach异常与Unix信号</h3><p>信号可以看做是对硬件异常跟软件异常的封装，常见的几种signals：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SIGSEGV, <span class="comment">// SEGV segmentation violation(段 违反) 非法访问地址，比如试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。比如：给已经release的对象发送消息</span></span><br><span class="line">SIGBUS,  <span class="comment">// 操作非法地址。比如修改只读数据区。</span></span><br><span class="line">SIGILL,  <span class="comment">// 执行非法指令, 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</span></span><br><span class="line">SIGFPE,  <span class="comment">// 算术运算错误</span></span><br><span class="line">SIGSYS,  <span class="comment">// 非法的系统调用</span></span><br><span class="line">SIGPIPE, <span class="comment">// 进程间通信产生，通信管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</span></span><br><span class="line">SIGABRT, <span class="comment">// 调用abort生成的信号，有可能是NSException也有可能是Mach</span></span><br><span class="line">SIGTRAP, <span class="comment">// 由断点指令或其它trap指令产生，一般出现在debug调试时</span></span><br></pre></td></tr></table></figure><ul><li><code>EXC_BAD_ACCESS</code>：is a Mach exception sent by the kernel to your application when you try to access memory that is not mapped for your application(访问没有映射到你APP的内存时). If not handled at the Mach level, it will be translated into a SIGBUS or SIGSEGV BSD signal.(如果没有在mach级别处理，就会被转换成这两种信号)      ——  Matt大神的<a href="https://links.jianshu.com/go?to=https://www.cocoawithlove.com/2010/05/handling-unhandled-exceptions-and.html">回答</a></li><li>SIGABRT is a BSD signal sent by an application to itself when an NSException or obj_exception_throw is not caught.</li></ul><p>Mach exception和Signal转换：</p><img src="/images/crash/mach-bsd.png" alt="mach-bsd" style="zoom:90%;" /><h3 id="2-4-Crash的收集实现"><a href="#2-4-Crash的收集实现" class="headerlink" title="2.4 Crash的收集实现"></a>2.4 Crash的收集实现</h3><p>如上述所说，通过捕获Mach异常或者Unix信号都可以抓到crash事件，于是总结起来实现方案就一共有3种。</p><p>**Q: 两种方式哪个更好呢？ **</p><p>优选Mach异常，因为Mach异常处理会先于Unix信号处理发生，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。</p><h4 id="2-4-1-Mach异常方式"><a href="#2-4-1-Mach异常方式" class="headerlink" title="2.4.1 Mach异常方式"></a>2.4.1 Mach异常方式</h4><h4 id="2-4-2-Unix信号方式"><a href="#2-4-2-Unix信号方式" class="headerlink" title="2.4.2 Unix信号方式"></a>2.4.2 Unix信号方式</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;NWCrashSignalExceptionHandler.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NWCrashTool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(*SignalHandler)(<span class="keyword">int</span> signal, siginfo_t *info, <span class="keyword">void</span> *context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> SignalHandler previousABRTSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousBUSSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousFPESignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousILLSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousPIPESignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousSEGVSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousSYSSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> SignalHandler previousTRAPSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NWCrashSignalExceptionHandler</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)registerHandler &#123;</span><br><span class="line">    <span class="comment">// 将先前别人注册的handler取出并备份</span></span><br><span class="line">    [<span class="keyword">self</span> backupOriginalHandler];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> signalRegister];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)backupOriginalHandler &#123;</span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_abrt;</span><br><span class="line">    sigaction(SIGABRT, <span class="literal">NULL</span>, &amp;old_action_abrt);</span><br><span class="line">    <span class="keyword">if</span> (old_action_abrt.sa_sigaction) &#123;</span><br><span class="line">        previousABRTSignalHandler = old_action_abrt.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_bus;</span><br><span class="line">    sigaction(SIGBUS, <span class="literal">NULL</span>, &amp;old_action_bus);</span><br><span class="line">    <span class="keyword">if</span> (old_action_bus.sa_sigaction) &#123;</span><br><span class="line">        previousBUSSignalHandler = old_action_bus.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_fpe;</span><br><span class="line">    sigaction(SIGFPE, <span class="literal">NULL</span>, &amp;old_action_fpe);</span><br><span class="line">    <span class="keyword">if</span> (old_action_fpe.sa_sigaction) &#123;</span><br><span class="line">        previousFPESignalHandler = old_action_fpe.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_ill;</span><br><span class="line">    sigaction(SIGILL, <span class="literal">NULL</span>, &amp;old_action_ill);</span><br><span class="line">    <span class="keyword">if</span> (old_action_ill.sa_sigaction) &#123;</span><br><span class="line">        previousILLSignalHandler = old_action_ill.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_pipe;</span><br><span class="line">    sigaction(SIGPIPE, <span class="literal">NULL</span>, &amp;old_action_pipe);</span><br><span class="line">    <span class="keyword">if</span> (old_action_pipe.sa_sigaction) &#123;</span><br><span class="line">        previousPIPESignalHandler = old_action_pipe.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_segv;</span><br><span class="line">    sigaction(SIGSEGV, <span class="literal">NULL</span>, &amp;old_action_segv);</span><br><span class="line">    <span class="keyword">if</span> (old_action_segv.sa_sigaction) &#123;</span><br><span class="line">        previousSEGVSignalHandler = old_action_segv.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_sys;</span><br><span class="line">    sigaction(SIGSYS, <span class="literal">NULL</span>, &amp;old_action_sys);</span><br><span class="line">    <span class="keyword">if</span> (old_action_sys.sa_sigaction) &#123;</span><br><span class="line">        previousSYSSignalHandler = old_action_sys.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> sigaction old_action_trap;</span><br><span class="line">    sigaction(SIGTRAP, <span class="literal">NULL</span>, &amp;old_action_trap);</span><br><span class="line">    <span class="keyword">if</span> (old_action_trap.sa_sigaction) &#123;</span><br><span class="line">        previousTRAPSignalHandler = old_action_trap.sa_sigaction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)signalRegister &#123;</span><br><span class="line">    NWSignalRegister(SIGABRT);</span><br><span class="line">    NWSignalRegister(SIGBUS);</span><br><span class="line">    NWSignalRegister(SIGFPE);</span><br><span class="line">    NWSignalRegister(SIGILL);</span><br><span class="line">    NWSignalRegister(SIGPIPE);</span><br><span class="line">    NWSignalRegister(SIGSEGV);</span><br><span class="line">    NWSignalRegister(SIGSYS);</span><br><span class="line">    NWSignalRegister(SIGTRAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Register Signal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWSignalRegister(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sigaction action;</span><br><span class="line">    action.sa_sigaction = NWSignalHandler;</span><br><span class="line">    action.sa_flags = SA_NODEFER | SA_SIGINFO;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask);</span><br><span class="line">    sigaction(signal, &amp;action, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark SignalCrash Handler</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWSignalHandler(<span class="keyword">int</span> signal, siginfo_t* info, <span class="keyword">void</span>* context) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mstr = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">    [mstr appendString:<span class="string">@&quot;Signal Exception:\n&quot;</span>];</span><br><span class="line">    [mstr appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Signal %@ was raised.\n&quot;</span>, signalName(signal)]];</span><br><span class="line">    [mstr appendString:<span class="string">@&quot;Call Stack:\n&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里过滤掉第一行日志</span></span><br><span class="line">    <span class="comment">// 因为注册了信号崩溃回调方法，系统会来调用，将记录在调用堆栈上，因此此行日志需要过滤掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">1</span>; index &lt; <span class="built_in">NSThread</span>.callStackSymbols.count; index++) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSThread</span>.callStackSymbols objectAtIndex:index];</span><br><span class="line">        [mstr appendString:[str stringByAppendingString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [mstr appendString:<span class="string">@&quot;threadInfo:\n&quot;</span>];</span><br><span class="line">    [mstr appendString:[[<span class="built_in">NSThread</span> currentThread] description]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存崩溃日志到沙盒cache目录</span></span><br><span class="line">    [NWCrashTool saveCrashLog:[<span class="built_in">NSString</span> stringWithString:mstr] fileName:<span class="string">@&quot;Crash(Signal)&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    NWClearSignalRegister();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用之前崩溃的回调函数</span></span><br><span class="line">    <span class="comment">// 在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递</span></span><br><span class="line">    previousSignalHandler(signal, info, context);</span><br><span class="line">    </span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Signal To Name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *signalName(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *signalName;</span><br><span class="line">    <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGABRT&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGBUS:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGBUS&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGFPE&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGILL:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGILL&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGPIPE&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGSEGV&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSYS:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGSYS&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTRAP:</span><br><span class="line">            signalName = <span class="string">@&quot;SIGTRAP&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signalName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Previous Signal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> previousSignalHandler(<span class="keyword">int</span> signal, siginfo_t *info, <span class="keyword">void</span> *context) &#123;</span><br><span class="line">    SignalHandler previousSignalHandler = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            previousSignalHandler = previousABRTSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGBUS:</span><br><span class="line">            previousSignalHandler = previousBUSSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            previousSignalHandler = previousFPESignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGILL:</span><br><span class="line">            previousSignalHandler = previousILLSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGPIPE:</span><br><span class="line">            previousSignalHandler = previousPIPESignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            previousSignalHandler = previousSEGVSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGSYS:</span><br><span class="line">            previousSignalHandler = previousSYSSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTRAP:</span><br><span class="line">            previousSignalHandler = previousTRAPSignalHandler;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (previousSignalHandler) &#123;</span><br><span class="line">        previousSignalHandler(signal, info, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark Clear</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> NWClearSignalRegister() &#123;</span><br><span class="line">    signal(SIGSEGV,SIG_DFL);</span><br><span class="line">    signal(SIGFPE,SIG_DFL);</span><br><span class="line">    signal(SIGBUS,SIG_DFL);</span><br><span class="line">    signal(SIGTRAP,SIG_DFL);</span><br><span class="line">    signal(SIGABRT,SIG_DFL);</span><br><span class="line">    signal(SIGILL,SIG_DFL);</span><br><span class="line">    signal(SIGPIPE,SIG_DFL);</span><br><span class="line">    signal(SIGSYS,SIG_DFL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-Mach异常-Unix信号方式"><a href="#2-4-3-Mach异常-Unix信号方式" class="headerlink" title="2.4.3 Mach异常+Unix信号方式"></a>2.4.3 Mach异常+Unix信号方式</h4><p>Github上多数开源项目都采用的这种方式，即使在优选捕获Mach异常的情况下，也放弃捕获EXC_CRASH异常，而选择捕获与之对应的SIGABRT信号。著名开源项目<a href="https://github.com/plausiblelabs/plcrashreporter">plcrashreporter</a>在代码注释中给出了详细的解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We still need to use signal handlers to <span class="keyword">catch</span> SIGABRT in-process. The kernel sends an EXC_CRASH mach exception to denote SIGABRT termination. In that <span class="keyword">case</span>, catching the Mach exception in-process leads to process deadlock in an uninterruptable wait. Thus, we fall back on BSD signal handlers <span class="keyword">for</span> SIGABRT, <span class="keyword">and</span> <span class="keyword">do</span> <span class="keyword">not</span> <span class="keyword">register</span> <span class="keyword">for</span> EXC_CRASH.</span><br><span class="line">  <span class="comment">// 我们仍然需要使用信号处理程序来捕获进程内的SIGABRT。内核发送一个EXC_CRASH mach异常来表示SIGABRT终止。在这种情况下，在进程中捕获Mach异常会导致不可中断等待中的进程死锁。因此，我们对SIGABRT使用BSD信号处理程序，而不注册EXC_CRASH。</span></span><br></pre></td></tr></table></figure><h2 id="三、应用级异常与捕获"><a href="#三、应用级异常与捕获" class="headerlink" title="三、应用级异常与捕获"></a>三、应用级异常与捕获</h2><p>对于应用级异常，还需要单独的特殊处理。</p><h3 id="3-1-NSException"><a href="#3-1-NSException" class="headerlink" title="3.1 NSException"></a>3.1 NSException</h3><p>对于Objective-C异常，一般可通过try catch来捕获</p><p>未被<code>try catch</code> 的 NSException，会发出 <code>kill</code> 或 <code>pthread_kill</code> 信号-&gt; Mach异常-&gt; Unix信号（SIGABRT），但是如果通过捕获<code>SIGABRT</code>信号的方式，来抓取异常，那么在处理收集信息时，获取当前堆栈时获取不到，所以采用<code>NSSetUncaughtExceptionHandler</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSException.h 常见的几种异常名称</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSGenericException; <span class="comment">// 通用异常</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSRangeException;   <span class="comment">// 越界异常</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSInvalidArgumentException;  <span class="comment">// 非法参数，如nil、unrecognized selector send to instance</span></span><br><span class="line">FOUNDATION_EXPORT NSExceptionName <span class="keyword">const</span> NSMallocException;  <span class="comment">// 内存分配异常</span></span><br><span class="line"><span class="comment">// ...等等</span></span><br></pre></td></tr></table></figure><p>参考图：</p><img src="/images/crash/2846924-a0cccb53e95db4d8.png" alt="" style="zoom:100%;" /><h4 id="3-1-1-举例"><a href="#3-1-1-举例" class="headerlink" title="3.1.1 举例"></a>3.1.1 举例</h4><p>以iOS开发常见的 NSException 为例，你是否见过崩溃在main函数的crash日志，但是函数栈里面没有你的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span> Crashed:</span><br><span class="line"><span class="number">0</span>       libsystem_kernel.dylib          <span class="number">0x3a61757c</span>   __semwait_signal_nocancel + <span class="number">0x18</span></span><br><span class="line"><span class="number">1</span>       libsystem_c.dylib               <span class="number">0x3a592a7c</span>   nanosleep$NOCANCEL + <span class="number">0xa0</span></span><br><span class="line"><span class="number">2</span>       libsystem_c.dylib               <span class="number">0x3a5adede</span>   usleep$NOCANCEL + <span class="number">0x2e</span></span><br><span class="line"><span class="number">3</span>       libsystem_c.dylib               <span class="number">0x3a5c7fe0</span>   <span class="built_in">abort</span> + <span class="number">0x50</span></span><br><span class="line"><span class="number">4</span>       libc++abi.dylib                 <span class="number">0x398f6cd2</span>   abort_message + <span class="number">0x46</span></span><br><span class="line"><span class="number">5</span>       libc++abi.dylib                 <span class="number">0x3990f6e0</span>   default_terminate_handler() + <span class="number">0xf8</span></span><br><span class="line"><span class="number">6</span>       libobjc.A.dylib                 <span class="number">0x3a054f62</span>   _objc_terminate() + <span class="number">0xbe</span></span><br><span class="line"><span class="number">7</span>       libc++abi.dylib                 <span class="number">0x3990d1c4</span>   <span class="built_in">std</span>::__terminate(<span class="keyword">void</span> (*)()) + <span class="number">0x4c</span></span><br><span class="line"><span class="number">8</span>       libc++abi.dylib                 <span class="number">0x3990cd28</span>   __cxa_rethrow + <span class="number">0x60</span></span><br><span class="line"><span class="number">9</span>       libobjc.A.dylib                 <span class="number">0x3a054e12</span>   objc_exception_rethrow + <span class="number">0x26</span></span><br><span class="line"><span class="number">10</span>      CoreFoundation                  <span class="number">0x2f7d7f30</span>   CFRunLoopRunSpecific + <span class="number">0x27c</span></span><br><span class="line"><span class="number">11</span>      CoreFoundation                  <span class="number">0x2f7d7c9e</span>   CFRunLoopRunInMode + <span class="number">0x66</span></span><br><span class="line"><span class="number">12</span>      GraphicsServices                <span class="number">0x346dd65e</span>   GSEventRunModal + <span class="number">0x86</span></span><br><span class="line"><span class="number">13</span>      UIKit                           <span class="number">0x32124148</span>   UIApplicationMain + <span class="number">0x46c</span></span><br><span class="line"><span class="number">14</span>      XXXXXX                          <span class="number">0x0003b1f2</span>   main + <span class="number">0x1f2</span></span><br><span class="line"><span class="number">15</span>      libdyld.dylib                   <span class="number">0x3a561ab4</span>   start + <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>可以看出是因为某个NSException导致程序Crash的，只有拿到这个NSException，获取它的reason，name，callStackSymbols信息才能确定出问题的程序位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NSException Class Reference */</span></span><br><span class="line">@property(readonly, copy) NSString *name;  </span><br><span class="line">@property(readonly, copy) NSString *reason;</span><br><span class="line">@property(readonly, copy) NSArray *callStackSymbols;</span><br><span class="line">@property(readonly, copy) NSArray *callStackReturnAddresses;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-NSException的捕获"><a href="#3-1-2-NSException的捕获" class="headerlink" title="3.1.2 NSException的捕获"></a>3.1.2 NSException的捕获</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录之前的崩溃回调函数</span></span><br><span class="line"><span class="keyword">static</span> NSUncaughtExceptionHandler *previousUncaughtExceptionHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_uncaught_exception_handler</span> <span class="params">(NSException *exception)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 异常的堆栈信息</span></span><br><span class="line">    NSArray * stackArray = [exception callStackSymbols];</span><br><span class="line">    <span class="comment">// 出现异常的原因</span></span><br><span class="line">    NSString * reason = [exception reason];</span><br><span class="line">    <span class="comment">// 异常名称</span></span><br><span class="line">    NSString * name = [exception name];</span><br><span class="line">    </span><br><span class="line">    NSString * exceptionInfo = [NSString stringWithFormat:@<span class="string">&quot;========uncaughtException异常错误报告========\nname:%@\nreason:\n%@\ncallStackSymbols:\n%@&quot;</span>, name, reason, [stackArray componentsJoinedByString:@<span class="string">&quot;\n&quot;</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存崩溃日志到沙盒cache目录</span></span><br><span class="line">    [NWCrashTool saveCrashLog:exceptionInfo fileName:@<span class="string">&quot;Crash(Uncaught)&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递</span></span><br><span class="line">    <span class="keyword">if</span> (previousUncaughtExceptionHandler) &#123;</span><br><span class="line">        previousUncaughtExceptionHandler(exception);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 杀掉程序，这样可以防止同时抛出的SIGABRT被SignalException捕获</span></span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)registerHandler &#123;</span><br><span class="line">    <span class="comment">//将先前别人注册的handler取出并备份</span></span><br><span class="line">    previousUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">  </span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;my_uncaught_exception_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拿到的NSException细节写入Crash日志，精准的定位出错程序位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Application Specific Information:</span><br><span class="line">*** Terminating app due to uncaught exception &#x27;NSUnknownKeyException&#x27;, reason: &#x27;[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key key.&#x27;</span><br><span class="line">Last Exception Backtrace:</span><br><span class="line"><span class="number">0</span> CoreFoundation <span class="number">0x2f8a3f7e</span>     __exceptionPreprocess + <span class="number">0x7e</span></span><br><span class="line"><span class="number">1</span> libobjc.A.dylib <span class="number">0x3a054cc</span>     objc_exception_throw + <span class="number">0x22</span></span><br><span class="line"><span class="number">2</span> CoreFoundation <span class="number">0x2f8a3c94</span>     -[NSException raise] + <span class="number">0x4</span></span><br><span class="line"><span class="number">3</span> Foundation <span class="number">0x301e8f1e</span>         -[NSObject(NSKeyValueCoding) setValue:forKey:] + <span class="number">0xc6</span></span><br><span class="line"><span class="number">4</span> DemoCrash <span class="number">0x00085306</span>          -[ViewController crashMethod] + <span class="number">0x6e</span></span><br><span class="line"><span class="number">5</span> DemoCrash <span class="number">0x00084ecc</span>          main + <span class="number">0x1cc</span></span><br><span class="line"><span class="number">6</span> DemoCrash <span class="number">0x00084cf8</span>          start + <span class="number">0x24</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-注意点"><a href="#3-1-3-注意点" class="headerlink" title="3.1.3 注意点"></a>3.1.3 注意点</h4><p><strong>Q: 是不是收到了大量crash在main函数却没有NSException信息的日志，就代表自己集成的Crash日志收集服务没有注册NSUncaughtExceptionHandler呢？</strong></p><p>不一定，还有另外一种可能，就是被同时存在的其他Crash日志收集服务给坑了。</p><p><strong>Q: 未设置NSSetUncaughtExceptionHandler的NSException最后会转成Unix信号吗？</strong></p><p>无论设置NSSetUncaughtExceptionHandler与否，只要未被try catch，最终都会被转成Unix信号，只不过设置了无法在其ExceptionHandler中无法获得最终发送的Unix信号类型</p><h3 id="3-2-ObjC野指针类的Crash"><a href="#3-2-ObjC野指针类的Crash" class="headerlink" title="3.2 ObjC野指针类的Crash"></a>3.2 ObjC野指针类的Crash</h3><p>收集Crash日志这个步骤没有问题的情况下，还是有很多全系统栈的日志的情况，没有自己一行代码，分析起来十分棘手，ObjC野指针类的Crash正是如此，这里推荐几篇好文章：</p><ul><li><a href="http://bugly.qq.com/blog/?p=200">如何定位Obj-C野指针随机Crash(一)：先提高野指针Crash率</a></li><li><a href="http://bugly.qq.com/blog/?p=308">如何定位Obj-C野指针随机Crash(二)：让非必现Crash变成必现</a></li><li><a href="http://bugly.qq.com/blog/?p=335">如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html">分析objc_msgSend()处崩溃的小技巧</a></li></ul><p>除此之外，在Crash日志中补充记录一些额外信息可以辅助定位，如切面标记线程出处、队列出处，记录用户操作轨迹等等……</p><h3 id="3-3-C-exceptions"><a href="#3-3-C-exceptions" class="headerlink" title="3.3 C++ exceptions"></a>3.3 C++ exceptions</h3><p>C++ exceptions使用系统封装好的函数<code>std::set_terminate(CPPExceptionTerminate)</code>来设置回调</p><h2 id="四、Crash的采集"><a href="#四、Crash的采集" class="headerlink" title="四、Crash的采集"></a>四、Crash的采集</h2><h3 id="4-1-采集工具"><a href="#4-1-采集工具" class="headerlink" title="4.1 采集工具"></a>4.1 采集工具</h3><p>崩溃日志收集服务，成熟的开源项目很多，如 <a href="https://github.com/kstenerud/KSCrash">KSCrash</a>，<a href="https://github.com/plausiblelabs/plcrashreporter">PLCrashReporter</a>，<a href="https://github.com/kaler/CrashKit">CrashKit</a> 等。追求方便省心，对于保密性要求不高的程序来说，也可以选择各种一条龙Crash统计产品，如 <a href="http://try.crashlytics.com/">Crashlytics</a>，<a href="http://hockeyapp.net/features/crashreports/">Hockeyapp</a> ，<a href="http://www.umeng.com/umeng30_error_type">友盟</a>，<a href="http://bugly.qq.com/">Bugly</a> 等等。</p><h4 id="4-1-1-官方CrashReporter"><a href="#4-1-1-官方CrashReporter" class="headerlink" title="4.1.1 官方CrashReporter"></a>4.1.1 官方CrashReporter</h4><p>iOS有自己的CrashReporter机制。在真机上产生的crash，在以下两个地方可以找到：</p><ul><li>Xcode－Window－Devices － View Device Logs中可以看到crash文件。</li><li>通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志。需要用户在设置-诊断与用量中允许将崩溃信息发送给开发者。然后在也可以在Xcode的Window - Organizer中可以看到对应的crash信息。（需要在Xcode中登录所属的开发者账号）</li></ul><p>关于各个字段的含义，以下仅供参考：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Incident Identifier</td><td>当前crash的 id，可以区分不同的crash事件</td></tr><tr><td>CrashReporter Key</td><td>当前设备的id，可以判断crash在某一设备上出现的频率</td></tr><tr><td>Hardware Model</td><td>设备型号</td></tr><tr><td>Process</td><td>当前应用的名称，后面中括号中为当前的应用在系统中的进程id</td></tr><tr><td>Path</td><td>当前应用在设备中的路径</td></tr><tr><td>Identifier</td><td>bundle id</td></tr><tr><td>Version</td><td>应用版本号</td></tr><tr><td>Code Type</td><td>还不清楚</td></tr><tr><td>Date/Time</td><td>crash事件 时间(后面跟的应该是时区)</td></tr><tr><td>OS Version</td><td>当前系统版本</td></tr><tr><td>Exception Type</td><td>异常类型</td></tr><tr><td>Exception Codes</td><td>异常出错的代码（常见代码有以下几种) <br />0x8badf00d：Watchdog超时，意为“ate bad food”。  <br />0xdeadfa11：用户强制退出，意为“dead fall”。 <br />0xbaaaaaad：用户按住Home键和音量键，获取当前内存状态，不代表崩溃。 <br />0xbad22222：VoIP应用（因为太频繁？）被iOS干掉。 <br />0xc00010ff：因为太烫了被干掉，意为“cool off”。 <br />0xdead10cc：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock”。</td></tr><tr><td>Triggered by Thread</td><td>在某一个线程出了问题导致crash，Thread 0  为主线程、其它的都为子线程</td></tr><tr><td>Last Exception Backtrace</td><td>最后异常回溯，一般根据这个代码就能找到crash的具体问题</td></tr></tbody></table><h4 id="4-1-2-KSCrash"><a href="#4-1-2-KSCrash" class="headerlink" title="4.1.2 KSCrash"></a>4.1.2 KSCrash</h4><p>KSCrash 是 iOS 上一个知名的 crash 收集框架。包括腾讯刚开源的 APM 框架 Matrix，其中 crash 收集部分也是直接使用的 KSCrash。</p><h4 id="4-1-3-PLCrashReporter"><a href="#4-1-3-PLCrashReporter" class="headerlink" title="4.1.3 PLCrashReporter"></a>4.1.3 PLCrashReporter</h4><p>微软家的，<a href="https://github.com/microsoft/plcrashreporter">Github</a></p><h3 id="4-2-多个Crash日志收集服务共存的坑"><a href="#4-2-多个Crash日志收集服务共存的坑" class="headerlink" title="4.2 多个Crash日志收集服务共存的坑"></a>4.2 多个Crash日志收集服务共存的坑</h3><p>是的，在自己的程序里集成多个Crash日志收集服务实在不是明智之举。通常情况下，第三方功能性SDK都会集成一个Crash收集服务，以及时发现自己SDK的问题。当各家的服务都以保证自己的Crash统计正确完整为目的时，难免出现时序手脚，强行覆盖等等的恶意竞争，总会有人默默被坑。</p><h4 id="4-2-1-拒绝传递-UncaughtExceptionHandler"><a href="#4-2-1-拒绝传递-UncaughtExceptionHandler" class="headerlink" title="4.2.1 拒绝传递 UncaughtExceptionHandler"></a>4.2.1 拒绝传递 UncaughtExceptionHandler</h4><p>如果同时有多方通过NSSetUncaughtExceptionHandler注册异常处理程序，和平的作法是：后注册者通过NSGetUncaughtExceptionHandler将先前别人注册的handler取出并备份，在自己handler处理完后自觉把别人的handler注册回去，规规矩矩的传递。不传递强行覆盖的后果是，在其之前注册过的日志收集服务写出的Crash日志就会因为取不到NSException而丢失Last Exception Backtrace等信息。（P.S. iOS系统自带的Crash Reporter不受影响）</p><p>在开发测试阶段，可以利用 <a href="https://github.com/facebook/fishhook">fishhook</a> 框架去hookNSSetUncaughtExceptionHandler方法，这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。不推荐利用调试器添加符号断点来检查，原因是一些Crash收集框架在调试状态下是不工作的。</p><p>检测代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSUncaughtExceptionHandler *g_vaildUncaughtExceptionHandler;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*ori_NSSetUncaughtExceptionHandler)</span><span class="params">( NSUncaughtExceptionHandler * )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_NSSetUncaughtExceptionHandler</span><span class="params">( NSUncaughtExceptionHandler * handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">    <span class="keyword">if</span> (g_vaildUncaughtExceptionHandler != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;UncaughtExceptionHandler=%p&quot;</span>,g_vaildUncaughtExceptionHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ori_NSSetUncaughtExceptionHandler(handler);</span><br><span class="line">    NSLog(@<span class="string">&quot;%@&quot;</span>,[NSThread callStackSymbols]);</span><br><span class="line">    </span><br><span class="line">    g_vaildUncaughtExceptionHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">    NSLog(@<span class="string">&quot;UncaughtExceptionHandler=%p&quot;</span>,g_vaildUncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于越狱插件注入应用进程内部，恶意覆盖NSSetUncaughtExceptionHandler的情况，应用程序本身处理起来比较弱势，因为越狱环境下操作时序的玩法比较多权利比较大。</p><h4 id="4-2-2-Mach异常端口换出-信号处理Handler覆盖"><a href="#4-2-2-Mach异常端口换出-信号处理Handler覆盖" class="headerlink" title="4.2.2 Mach异常端口换出+信号处理Handler覆盖"></a>4.2.2 Mach异常端口换出+信号处理Handler覆盖</h4><p>和NSSetUncaughtExceptionHandler的情况类似，设置过的Mach异常端口和信号处理程序也有可能被干掉，导致无法捕获Crash事件。</p><h4 id="4-2-3-影响系统崩溃日志准确性"><a href="#4-2-3-影响系统崩溃日志准确性" class="headerlink" title="4.2.3 影响系统崩溃日志准确性"></a>4.2.3 影响系统崩溃日志准确性</h4><p>应用层参与收集Crash日志的服务方越多，越有可能影响iOS系统自带的Crash Reporter。由于进程内线程数组的变动，可能会导致系统日志中线程的Crashed 标签标记错位，可以搜索abort()等关键字来复查系统日志的准确性。</p><p>若程序因NSException而Crash，系统日志中的Last Exception Backtrace信息是完整准确的，不会受应用层的胡来而影响，可作为排查问题的参考线索。</p><h2 id="六、Crash的符号化"><a href="#六、Crash的符号化" class="headerlink" title="六、Crash的符号化"></a>六、Crash的符号化</h2><p>所谓的符号解析就是就是将崩溃日志中的地址映射成为可读的符号和源文件中的行号，方便开发者定位和修复问题。</p><h3 id="6-1-异常信息的查看"><a href="#6-1-异常信息的查看" class="headerlink" title="6.1 异常信息的查看"></a>6.1 异常信息的查看</h3><p>异常信息有三种类型</p><ol><li><p>已标记错误位置的，这种信息很明确了不用解析，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000000109708aeb -[ViewController buttonClick:] + 43</span><br></pre></td></tr></table></figure></li><li><p>有模块地址的情况，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制库名（<span class="built_in">test</span>），调用方法的地址（0x00000001018157dc），模块地址（0x100064000）+偏移地址（24844252）</span></span><br><span class="line">test 0x00000001018157dc 0x100064000 + 24844252</span><br></pre></td></tr></table></figure></li><li><p>无模块地址的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法的地址-偏移地址，得到的就是模块地址  0x00000001018157dc - 24844252 = 0x100064000</span></span><br><span class="line">test 0x00000001018157dc test + 24844252</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-2-系统原生符号解析工具"><a href="#6-2-系统原生符号解析工具" class="headerlink" title="6.2 系统原生符号解析工具"></a>6.2 系统原生符号解析工具</h3><p>一般Xcode项目每次 release 编译后, 都会产生一个新的.dSYM文件和.app文件，这两者有一个共同的UUID.</p><ul><li><p>.dSYM文件是一个符号表文件, 这里面包含了一个16进制的保存函数地址映射信息的中转文件。</p></li><li><p>获取：xcode -&gt; window -&gt; organizer-&gt;右键你的应用 show finder-&gt;右键.xcarchive 显示包内容-&gt;dSYMs-&gt;test.app.dYSM</p></li><li><p>符号表是内存地址与函数名，文件名，行号的映射表。 符号表元素如下所示:</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;起始地址&gt; &lt;结束地址&gt; &lt;函数&gt; [&lt;文件名:行号&gt;]</span><br></pre></td></tr></table></figure><h4 id="6-2-1-symbolicatecrash"><a href="#6-2-1-symbolicatecrash" class="headerlink" title="6.2.1 symbolicatecrash"></a>6.2.1 symbolicatecrash</h4><p>Xcode 提供的 <code>symbolicatecrash</code>。该命令位于：<code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code>，是一个perl 脚本，里面整合了逐步解析的操作（也可以将命令拷贝出来，直接进行调用）。</p><p>用法：<code>symbolicatecrash log.crash -d xxx.app.dSYM</code></p><p>优点：能非常方便的符号化整份 crash 日志。</p><p>缺点：</p><ol><li>耗时比较久。</li><li>粒度比较粗，无法符号化特定的某一行。</li></ol><h4 id="6-2-2-atos"><a href="#6-2-2-atos" class="headerlink" title="6.2.2 atos"></a>6.2.2 atos</h4><p>atos命令来符号化某个特定模块加载地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atos [-arch 架构名] [-o 符号表] [-l 模块地址] [方法地址]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如</span></span><br><span class="line">atos -o xxx.app.dSYM/Contents/Resources/DWARF/xxx -arch arm64/armv7 -l loadAddress runtimeAddress</span><br></pre></td></tr></table></figure><p>优点：速度快，可以符号化特定的某一行，方便上层做缓存。</p><p>上面的这两个工具都有两个最大的缺陷就是：</p><ol><li>都仅仅是单机的工具，无法作为在线服务提供。</li><li>必须依赖 macOS 系统，因 为字节服务端基建全部基于Linux，导致无法复用集团各种平台和框架，这就带来了非常高的机器成本，部署成本和运维成本。</li></ol><ul><li><a href="https://mp.weixin.qq.com/s/MIun-eV4_J1hXGDRjGoLaw">iOS 崩溃日志在线符号化实践</a></li><li><a href="https://mp.weixin.qq.com/s/TVRYXhiOXIsMmXZo9GmEVA">iOS 符号解析重构之路</a></li></ul><h2 id="七、Crash的分析"><a href="#七、Crash的分析" class="headerlink" title="七、Crash的分析"></a>七、Crash的分析</h2><ul><li>当我们拿到crash日志时，应首先从<code>crash Type</code>，<code>crash thread</code>  快速定位到造成crash的代码段。之所以首先要看这两个，是因为type能大致知道crash的类型，如果是OC类型的异常，那基本上处理起来比较简单，如果是mach signals类型的，通过查看造成crash的线程堆栈，也能快速定位到方法，举个实际项目中的例子：</li></ul><blockquote><p>线上有个偶现的crash，crash Type为SIGSEGV，且thread不定，子线程，主线程都会存在，但是代码段相同，由于SIGSEGV是野指针异常类型，且由于在多线程中都会触发，说明问题基本上是多线程的对象读写安全问题</p></blockquote><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="http://www.cocoachina.com/articles/12301">漫谈iOS Crash收集框架 - 念茜</a></p></li><li><p><a href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;常见的 crash 类型总结下来，分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mach kernel exceptions：是指最</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="CrashMonitor" scheme="https://tenloy.github.io/tags/CrashMonitor/"/>
    
  </entry>
  
  <entry>
    <title>iOS卡顿监控</title>
    <link href="https://tenloy.github.io/2021/06/30/Lag-Monitor.html"/>
    <id>https://tenloy.github.io/2021/06/30/Lag-Monitor.html</id>
    <published>2021-06-30T19:28:45.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、卡顿的难点"><a href="#一、卡顿的难点" class="headerlink" title="一、卡顿的难点"></a>一、卡顿的难点</h2><p>时不时会收到这样的卡顿反馈：“用户A 刚才碰到从后台切换前台卡了一下，最近偶尔会遇到几次”、“用户B 反馈点对话框卡了五六秒”、“现网有用户反馈切换 tab 很卡”。</p><p>这些反馈有几个特点，导致跟进困难：</p><ol><li>不易重现。可能是特定用户的手机上才有问题，由于种种原因这个手机不能拿来调试；也有可能是特定的时机才会出问题，过后就不能重现了（例如线程抢锁）。</li><li>操作路径长，日志无法准确打点</li></ol><p>对于这些界面卡顿反馈，通常我们拿用户日志作用不大，增加日志点也用处不大。只能不断重试希望能够重现出来，或者埋头代码逻辑中试图能找的蛛丝马迹。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>在开始之前，我们先思考一下，界面卡顿是由哪些原因导致的？</p><ul><li>死锁：主线程拿到锁 A，需要获得锁 B，而同时某个子线程拿了锁 B，需要锁 A，这样相互等待就死锁了。</li><li>抢锁：主线程需要访问 DB，而此时某个子线程往 DB 插入大量数据。通常抢锁的体验是偶尔卡一阵子，过会就恢复了。</li><li>主线程大量 IO：主线程为了方便直接写入大量数据，会导致界面卡顿。</li><li>主线程大量计算：算法不合理，导致主线程某个函数占用大量 CPU。</li><li>大量的 UI 绘制：复杂的 UI、图文混排等，带来大量的 UI 绘制。</li></ul><p>针对这些原因，我们可以怎么定位问题呢？</p><ul><li>死锁一般会伴随 crash，可以通过 crash report 来分析。</li><li>抢锁不好办，将锁等待时间打出来用处不大，我们还需要知道是<strong>谁占了锁</strong>。</li><li>大量 IO 可以在函数开始结束打点，将占用时间打到日志中。</li><li>大量计算同理可以将耗时打到日志中。</li><li>大量 UI 绘制一般是必现，还好办；如果是偶现的话，想加日志点都没地方，因为是<strong>慢在系统函数里面</strong>。</li></ul><p>如果可以将当时的线程堆栈捕捉下来，那么上述难题都迎刃而解。主线程在什么函数哪一行卡住、在等什么锁而这个锁又是被哪个子线程的哪个函数占用、是在进行I/O操作、或者是进行复杂计算，有了堆栈，我们都可以知道。自然也能知道是慢在UI绘制，还是慢在我们的代码。</p><p>所以，思路就是<strong>起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来</strong>。</p><p>流程图描述如下：</p><img src="/images/PerfOpt/lag-process.png" style="zoom:85%"><h2 id="三、细节"><a href="#三、细节" class="headerlink" title="三、细节"></a>三、细节</h2><p>原理一旦讲出来，好像也不复杂。魔鬼都是隐藏在细节中，效果好不好，完全由实现细节决定。具体到卡顿检测，有几个问题需要仔细处理：</p><ul><li>怎么知道主线程发生了卡顿？</li><li>子线程以什么样的策略和频率来检测主线程？这个是要发布到现网的，如果处理不好，带来明显的性能损耗（尤其是电量），就不能接受了。</li><li>堆栈上报了上来怎么分类？直接用 crash report 的分类不适合。</li><li>卡顿 dump 下来的堆栈会有多频繁？数据量会有多大？</li><li>全量上报还是抽样上报？怎么在问题跟进与节省流量直接平衡？</li></ul><h3 id="3-1-卡顿判断标准"><a href="#3-1-卡顿判断标准" class="headerlink" title="3.1 卡顿判断标准"></a>3.1 卡顿判断标准</h3><p>怎么判断主线程是不是发生了卡顿？一般来说，用户感受得到的卡顿大概有三个特征：</p><ul><li>FPS 降低</li><li>CPU 占用率很高</li><li>主线程 Runloop 执行了很久</li></ul><p>看起来 FPS 能够兼容后面两个特征，但是在实际操作过程中发现 FPS 并不适用，不好衡量：</p><ul><li>人眼结构上看，当一组动作在 1 秒内有 12 次变化（即 12FPS），我们会认为这组动作是连贯的；</li><li>平时看到的大部分电影或视频 FPS 其实不高，一般只有 25FPS ~ 30FPS，而实际上我们也没有觉得卡顿；</li><li>游戏玩家通常追求更流畅的游戏画面体验一般要达到 60FPS 以上</li><li><strong>FPS 低并不意味着卡顿发生，而卡顿发生 FPS 一定不高</strong>。FPS 可以衡量一个界面的流程性，但往往不能很直观的衡量卡顿的发生。</li></ul><p>而对于抢锁或大量 IO 的情况，光有 CPU 是不行的。所以我们实际上用到的是下面两个准则：</p><ul><li>单核 CPU 的占用超过了 80%</li><li>主线程 Runloop 执行了超过2秒</li></ul><h3 id="3-2-卡顿检测实现"><a href="#3-2-卡顿检测实现" class="headerlink" title="3.2 卡顿检测实现"></a>3.2 卡顿检测实现</h3><p>在 iOS/macOS 平台应用中，主线程有一个 Runloop。Runloop 是一个 Event Loop 模型，让线程可以处于接收消息、处理事件、进入等待而不马上退出。在进入事件的前后，Runloop 会向注册的 Observer 通知相应的事件。</p><p>Runloop 的详细介绍可以参考：<a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a>，一个简易的 Runloop 流程如下所示：</p><img src="/images/PerfOpt/simple-runloop-model.png" style="zoom:80%"><p>Matrix 卡顿监控在 Runloop 的起始最开始和结束最末尾位置添加 Observer，从而获得主线程的开始和结束状态。卡顿监控起一个子线程定时检查主线程的状态，当主线程的状态运行超过一定阈值则认为主线程卡顿，从而标记为一个卡顿。</p><img src="/images/PerfOpt/main-thread-lag-check.png" style="zoom:80%"><p>目前微信使用的卡顿监控，主程序 Runloop 超时的阈值是 2 秒，子线程的检查周期是 1 秒。每隔 1 秒，子线程检查主线程的运行状态；如果检查到主线程 Runloop 运行超过 2 秒则认为是卡顿，并获得当前的线程快照。</p><p>同时，我们也认为 CPU 过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到 CPU 占用过高，会捕获当前的线程快照保存到文件中。目前微信应用中认为，单核 CPU 的占用超过了 80%，此时的 CPU 占用就过高了。</p><p>代码示例：<a href="https://github.com/ming1016/DecoupleDemo/blob/master/DecoupleDemo/SMLagMonitor.m">SMLagMonitor.m</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建子线程监控</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//子线程开启一个持续的 loop 用来进行监控</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line">        <span class="keyword">if</span> (semaphoreWait != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!runLoopObserver) &#123;</span><br><span class="line">                timeoutCount = <span class="number">0</span>;</span><br><span class="line">                dispatchSemaphore = <span class="number">0</span>;</span><br><span class="line">                runLoopActivity = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿</span></span><br><span class="line">            <span class="keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                <span class="comment">//将堆栈信息上报服务器的代码放到这里</span></span><br><span class="line">            &#125; <span class="comment">//end activity</span></span><br><span class="line">        &#125;<span class="comment">// end semaphore wait</span></span><br><span class="line">        timeoutCount = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">// end while</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-检测策略—退火算法"><a href="#3-3-检测策略—退火算法" class="headerlink" title="3.3 检测策略—退火算法"></a>3.3 检测策略—退火算法</h3><p>为了降低检测带来的性能损耗，我们仔细设计了检测线程的策略：</p><ul><li>内存 dump：每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）；</li><li>文件 dump：将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对：<ul><li>如果堆栈不同，则获得当前的线程快照并写入文件中；</li><li>如果相同则会跳过，并按照斐波那契数列将<strong>检查时间递增</strong>（1，1，2，3，5，8…）直到没有遇到卡顿或者主线程卡顿堆栈不一样。</li></ul></li></ul><p>这样，可以避免同一个卡顿写入多个文件的情况；避免检测线程遇到主线程卡死的情况下，不断写线程快照文件。</p><h3 id="3-4-卡顿时堆栈获取"><a href="#3-4-卡顿时堆栈获取" class="headerlink" title="3.4 卡顿时堆栈获取"></a>3.4 卡顿时堆栈获取</h3><h4 id="3-4-1-直接调用系统函数"><a href="#3-4-1-直接调用系统函数" class="headerlink" title="3.4.1 直接调用系统函数"></a>3.4.1 直接调用系统函数</h4><p>获取堆栈信息的一种方法是直接调用系统函数。这种方法的优点在于，性能消耗小。但是，它只能够获取简单的信息，也没有办法配合 dSYM 来获取具体是哪行代码出了问题，而且能够获取的信息类型也有限。这种方法，因为性能比较好，所以适用于观察大盘统计卡顿情况，而不是想要找到卡顿原因的场景。</p><p>直接调用系统函数方法的主要思路是：用 signal 进行错误信息的获取。具体代码如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signals[] = &#123;</span><br><span class="line">    SIGABRT,</span><br><span class="line">    SIGBUS,</span><br><span class="line">    SIGFPE,</span><br><span class="line">    SIGILL,</span><br><span class="line">    SIGSEGV,</span><br><span class="line">    SIGTRAP,</span><br><span class="line">    SIGTERM,</span><br><span class="line">    SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signal_num = <span class="keyword">sizeof</span>(s_fatal_signals) / <span class="keyword">sizeof</span>(s_fatal_signals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *exceptionArray = [exception callStackSymbols]; <span class="comment">//得到当前调用栈信息</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionReason = [exception reason];       <span class="comment">//非常重要，就是崩溃的原因</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionName = [exception name];           <span class="comment">//异常类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SignalHandler(<span class="keyword">int</span> code)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;signal handler = %d&quot;</span>,code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InitCrashReport()&#123;</span><br><span class="line">    <span class="comment">//系统错误信号捕获</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">        signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//oc未捕获异常的捕获</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        InitCrashReport();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h4 id="3-4-2-PLCrashReporter三方库"><a href="#3-4-2-PLCrashReporter三方库" class="headerlink" title="3.4.2 PLCrashReporter三方库"></a>3.4.2 PLCrashReporter三方库</h4><p>PLCrashReporter是一个开源的第三方框架，用来做 crash 收集，可以直接用 PLCrashReporter 来获取堆栈信息。这种方法的特点是，能够定位到问题代码的具体位置，而且性能消耗也不大。所以，也是我推荐的获取堆栈信息的方法。</p><p>具体如何使用 PLCrashReporter 来获取堆栈信息，代码如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="built_in">NSData</span> *lagData = [</span><br><span class="line">   [[PLCrashReporter alloc] initWithConfiguration:</span><br><span class="line">                     [[PLCrashReporterConfig alloc]</span><br><span class="line">                      initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]]</span><br><span class="line">                   generateLiveReport];</span><br><span class="line"><span class="comment">// 转换成 PLCrashReport 对象</span></span><br><span class="line">PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="comment">// 进行字符串格式化处理</span></span><br><span class="line"><span class="built_in">NSString</span> *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];</span><br><span class="line"><span class="comment">//将字符串上传服务器</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;lag happen, detail below: \n %@&quot;</span>,lagReportString);</span><br></pre></td></tr></table></figure><h4 id="3-4-3-KSCrash"><a href="#3-4-3-KSCrash" class="headerlink" title="3.4.3 KSCrash"></a>3.4.3 KSCrash</h4><p>KSCrash 是 iOS 上一个知名的 crash 收集框架。包括腾讯开源的 APM 框架 Matrix，其中 crash 收集部分也是直接使用的 KSCrash。</p><p>KSCrash 可以处理以下类型的崩溃：</p><ul><li>Mach kernel exceptions Mac内核异常</li><li>Fatal signals</li><li>C++ exceptions</li><li>Objective-C exceptions</li><li>Main thread deadlock (experimental)  主线程死锁</li><li>Custom crashes (e.g. from scripting languages) 自定义崩溃</li></ul><h4 id="3-4-4-WCCrashBlockMonitorPlugin"><a href="#3-4-4-WCCrashBlockMonitorPlugin" class="headerlink" title="3.4.4 WCCrashBlockMonitorPlugin"></a>3.4.4 WCCrashBlockMonitorPlugin</h4><p>Matrix for iOS/macOS 是微信开源的一个工具，可以使用在 iOS、macOS 平台上。在日常开发中，微信iOS团队通过卡顿监控上报的堆栈，找到微信的代码不合理之处或者是一些性能瓶颈；通过卡顿监控的辅助，尽可能地提升微信的流畅性，给用户带来更加极致美好的体验。</p><p>工具监控范围包括：崩溃、卡顿和爆内存，包含以下两款插件：</p><ul><li>WCCrashBlockMonitorPlugin：基于 <a href="https://github.com/kstenerud/KSCrash">KSCrash</a> 框架开发，具有业界领先的卡顿堆栈捕获能力，同时兼备崩溃捕获能力。</li><li>WCMemoryStatPlugin：一款性能优化到极致的爆内存监控工具，能够全面捕获应用爆内存时的内存分配以及调用堆栈情况。</li></ul><h3 id="3-5-耗时堆栈提取"><a href="#3-5-耗时堆栈提取" class="headerlink" title="3.5 耗时堆栈提取"></a>3.5 耗时堆栈提取</h3><p>子线程检测到主线程 Runloop 时，会获得当前的线程快照当做卡顿文件。但是这个当前的主线程堆栈不一定是最耗时的堆栈，不一定是导致主线程超时的主要原因。</p><p>例如，主线程在绘制一个微信logo，过程如下：</p><img src="/images/PerfOpt/draw-wechat-logo.png" style="zoom:80%"><p>子线程在检测到超出阈值时获得的线程快照，主线程的当前任务是“画小气泡”。但其实“画大气泡”才是耗时操作，导致主线程超时的主要原因。<strong>Matrix 卡顿监控通过主线程耗时堆栈提取来解决这个问题。</strong></p><p>卡顿监控定时获取主线程堆栈，并将堆栈保存到内存的一个循环队列中。如下图，每间隔时间 t 获得一个堆栈，然后将堆栈保存到一个最大个数为 3 的循环队列中。有一个游标不断的指向最近的堆栈。</p><p>微信的策略是每隔 50 毫秒获取一次主线程堆栈，保存最近 20 个主线程堆栈。这个会增加 3% 的 CPU 占用，内存占用可以忽略不计。</p><img src="/images/PerfOpt/time-cost-stack-fetch.png" style="zoom:100%"><p>当主线程检测到卡顿时，通过对保存到循坏队列中的堆栈进行回溯，获取最近最耗时堆栈。</p><p>如下图，检测到卡顿时，内存的循环队列中记录了最近的20个主线程堆栈，需要从中找出最近最耗时的堆栈。Matrix 卡顿监控用如下特征找出最近最耗时堆栈：</p><ul><li>以栈顶函数为特征，认为栈顶函数相同的即整个堆栈是相同的；</li><li>取堆栈的间隔是相同的，堆栈的重复次数近似作为堆栈的调用耗时，重复越多，耗时越多；</li><li>重复次数相同的堆栈可能很有多个，取最近的一个最耗时堆栈。</li></ul><p>获得的最近最耗时堆栈会附带到卡顿文件中。</p><img src="/images/PerfOpt/stack-back.png" style="zoom:80%"><h3 id="3-6-卡死卡顿"><a href="#3-6-卡死卡顿" class="headerlink" title="3.6 卡死卡顿"></a>3.6 卡死卡顿</h3><p>Matrix 中内置了应用被杀原因的检测机制。这个机制从 <a href="https://code.fb.com/ios/reducing-fooms-in-the-facebook-ios-app">Facebook 的博文</a> 中获得灵感，在其基础上增加了系统强杀的判定。Matrix 检测应用被杀原因的具体机制如下图所示：</p><img src="/images/PerfOpt/why-app-killed.png" style="zoom:85%"><p><strong>Matrix 检测到应用卡死被强杀，会把应用上次存活时的最后一份卡顿日志标记为卡死卡顿。</strong></p><h3 id="3-7-性能损耗"><a href="#3-7-性能损耗" class="headerlink" title="3.7 性能损耗"></a>3.7 性能损耗</h3><p>Matrix 卡顿监控不打开耗时堆栈提取，性能损耗可以忽略不计。</p><p>打开耗时堆栈提取后，性能损耗和定时获取主线程堆栈的间隔有关。实测，每隔 50 毫秒不断获取主线程堆栈，会增加 3% 的 CPU 占用。</p><h3 id="3-8-分类方法"><a href="#3-8-分类方法" class="headerlink" title="3.8 分类方法"></a>3.8 分类方法</h3><p>直接用 crash report 的分类方法是不行的，这个很好理解：最终卡在 lock 函数的卡顿，外面可能是很多不同的业务，例如可能是读取消息，可能是读取联系人，等等。卡顿监控需要仔细定义自己的分类规则。可以是从调用堆栈的最外层开始归类，或者是取中间一部分归类，或者是取最里面一部分归类。各有优缺点：</p><ul><li>最外层归类：能够将同一入口的卡顿归类起来。缺点是层数不好定，可能外面十来层都是系统调用，也有可能第一层就是微信的函数了。</li><li>中间层归类：能够根据事先划分好的“特征值”来归类。缺点是“特征值”不好定，如果要做到自动学习生成的话，对后台分析系统要求太高了。</li><li>最内层归类：能够将同一原因的卡顿归类起来。缺点是同一分类可能包含不同的业务。</li></ul><p>综合考虑并一一尝试之后，我们采用了最内层归类的优化版，亦即进行二级归类。</p><ul><li>第一级：按照 <strong>最内倒数2层</strong> 归类，这样能够将 <strong>同一原因</strong> 的卡顿集中起来；<ul><li>第二级分类是从第一级点击进来，然后按照 <strong>最内层倒数4层</strong> 进行归类，这样能够将同一原因，根据 <strong>不同业务(不同入口)</strong> 分散归类起来。</li></ul></li></ul><h3 id="3-9-可运营"><a href="#3-9-可运营" class="headerlink" title="3.9 可运营"></a>3.9 可运营</h3><p>在正式发布之前，我们进行了灰度，以评估卡顿对用户的影响。收集到的结果是用户平均每天会产生30个 dump 文件，压缩上传大约要 300k 流量。预计正式发布的话会对后台有比较大的压力，对用户也有一定流量损耗。所以必须进行抽样上报。</p><ul><li>抽样上报：每天抽取不同的用户进行上报，抽样概率是5%。</li><li>文件上传：被抽中的用户1天仅上传前20个堆栈文件，并且每次上报会进行多文件压缩上传。</li><li>白名单：对于需要跟进问题的用户，可以在后台配置白名单，强制上报。</li></ul><p>另外，为了减少对用户存储空间的影响，卡顿文件仅保存最近7天的记录，过期删除。</p><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=4">微信 iOS 卡顿监控系统</a></li><li><a href="https://github.com/Tencent/matrix/wiki/Matrix-for-iOS-macOS-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86">微信 Matrix 卡顿监控工具</a> </li><li><a href="https://time.geekbang.org/column/article/89494">13 | 如何利用 RunLoop 原理去监控卡顿？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、卡顿的难点&quot;&gt;&lt;a href=&quot;#一、卡顿的难点&quot; class=&quot;headerlink&quot; title=&quot;一、卡顿的难点&quot;&gt;&lt;/a&gt;一、卡顿的难点&lt;/h2&gt;&lt;p&gt;时不时会收到这样的卡顿反馈：“用户A 刚才碰到从后台切换前台卡了一下，最近偶尔会遇到几次”、“用户B</summary>
      
    
    
    
    <category term="性能优化" scheme="https://tenloy.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="LagMonitor" scheme="https://tenloy.github.io/tags/LagMonitor/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI</title>
    <link href="https://tenloy.github.io/2021/06/29/SwiftUI.html"/>
    <id>https://tenloy.github.io/2021/06/29/SwiftUI.html</id>
    <published>2021-06-29T22:30:43.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<p>SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的<strong>声明式框架</strong>。该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发。</p><h3 id="一、UIKit的不足"><a href="#一、UIKit的不足" class="headerlink" title="一、UIKit的不足"></a>一、UIKit的不足</h3><p>从 iOS SDK 2.0 开始，UIKit 已经伴随广大 iOS 开发者经历了接近十年的风风雨雨。UIKit 的思想继承了成熟的 AppKit 和 MVC，在初出时，为 iOS 开发者提供了良好的学习曲线。</p><p>UIKit 提供的是一套符合直觉的，基于控制流的命令式的编程方式。最主要的思想是在确保 View 或者 View Controller 生命周期以及用户交互时，相应的方法 (比如 <code>viewDidLoad</code> 或者某个 target-action 等) 能够被正确调用，从而构建用户界面和逻辑。不过，不管是从使用的便利性还是稳定性来说，UIKit 都面临着巨大的挑战。</p><p>UIKit 的基本思想要求 View Controller 承担绝大部分职责，它需要协调 model，view 以及用户交互。这带来了巨大的 side effect 以及大量的状态，如果没有妥善安置，它们将在 View Controller 中混杂在一起，同时作用于 view 或者逻辑，从而使状态管理愈发复杂，最后甚至不可维护而导致项目失败。不仅是作为开发者我们自己写的代码，UIKit 本身内部其实也经常受困于可变状态，各种奇怪的 bug 也频频出现。</p><h3 id="二、声明式编程的崛起"><a href="#二、声明式编程的崛起" class="headerlink" title="二、声明式编程的崛起"></a>二、声明式编程的崛起</h3><p>近年来，随着编程技术和思想的进步，使用声明式或者函数式的方式来进行界面开发，已经越来越被接受并逐渐成为主流。最早的思想大概是来源于 <a href="https://elm-lang.org/">Elm</a>，之后这套方式被 <a href="https://reactjs.org/">React</a> 和 <a href="https://flutter.dev/">Flutter</a> 采用，这一点上 SwiftUI 也几乎与它们一致。</p><ol><li><p>使用各自的 DSL 来描述「UI 应该是什么样子」，而不是用一句句的代码来指导「要怎样构建 UI」。</p><p>比如传统的 UIKit，我们会使用这样的代码来添加一个 “Hello World” 的标签，它负责“创建 label”，“设置文字”，“将其添加到 view 上”：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">     <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">     label.text <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">     view.addSubview(label)</span><br><span class="line">     <span class="comment">// 省略了布局的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而相对起来，使用 SwiftUI 我们只需要告诉 SDK 我们需要一个文字标签：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来，框架内部读取这些 view 的声明，负责将它们以合适的方式绘制渲染。</p><p>注意，这些 view 的声明只是纯数据结构的描述，而不是实际显示出来的视图，因此这些结构的创建和差分对比并不会带来太多性能损耗。相对来说，将描述性的语言进行渲染绘制的部分是最慢的，这部分工作将交由框架以黑盒的方式为我们完成。</p></li><li><p>如果 <code>View</code> 需要根据某个状态 (state) 进行改变，那我们将这个状态存储在变量中，并在声明 view 时使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">   <span class="type">Text</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态发生改变时，框架重新调用声明部分的代码，计算出新的 view 声明，并和原来的 view 进行差分，之后框架负责对变更的部分进行高效的重新绘制。</p></li></ol><p>SwiftUI 的思想也完全一样，而且实际处理也不外乎这几个步骤。使用描述方式开发，大幅减少了在 app 开发者层面上出现问题的机率。</p><p>由于 Swift ABI 已经稳定，SwiftUI 是一个搭载在用户 iOS 系统上的 Swift 框架。因此它的<strong>最低支持的版本是 iOS 13，可能想要在实际项目中使用，还需要等待一两年时间</strong>。</p><h3 id="三、SwiftUI语法"><a href="#三、SwiftUI语法" class="headerlink" title="三、SwiftUI语法"></a>三、SwiftUI语法</h3><p>常用功能点：</p><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">教程 1 - Creating and Combining Views</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">SwiftUI app 的启动</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-new-project-and-explore-the-canvas">关于 some View</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#customize-the-text-view">预览 SwiftUI</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#combine-views-using-stacks">关于 ViewBuilder</a></li><li><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views#create-a-custom-image-view">链式调用修改 View 的属性</a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation">教程 2 - Building Lists and Navigation</a></p><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#create-the-list-of-landmarks">静态 <code>List</code></a></p></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation#make-the-list-dynamic">动态 <code>List</code> 和 <code>Identifiable</code></a></p></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/handling-user-input">教程 3 - Handling User Input</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/handling-user-input#add-a-control-to-toggle-the-state"><code>@State</code> 和 <code>Binding</code></a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions">教程 5 - Animating Views and Transitions</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions#customize-view-transitions">两种动画的方式</a></li></ul></li><li><p><a href="https://developer.apple.com/tutorials/swiftui/working-with-ui-controls">教程 7 - Working with UI Controls</a></p><ul><li><a href="https://developer.apple.com/tutorials/swiftui/working-with-ui-controls#delay-edit-propagation">关于 <code>View</code> 的生命周期</a></li></ul></li></ul><h3 id="四、学习资料"><a href="#四、学习资料" class="headerlink" title="四、学习资料"></a>四、学习资料</h3><ul><li><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">官网教程</a></p></li><li><p><a href="https://onevcat.com/categories/swiftui/">SwiftUI — OneV</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SwiftUI 于 2019 年度 WWDC 全球开发者大会上发布，它是基于 Swift 建立的&lt;strong&gt;声明式框架&lt;/strong&gt;。该框架可以用于 watchOS、tvOS、macOS、iOS 等平台的应用开发。&lt;/p&gt;
&lt;h3 id=&quot;一、UIKit的不足&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Swift" scheme="https://tenloy.github.io/categories/Swift/"/>
    
    
    <category term="SwiftUI" scheme="https://tenloy.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>Swift版本更新API介绍</title>
    <link href="https://tenloy.github.io/2021/06/29/Swift-Version-History.html"/>
    <id>https://tenloy.github.io/2021/06/29/Swift-Version-History.html</id>
    <published>2021-06-29T21:01:31.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift-ABI-稳定"><a href="#Swift-ABI-稳定" class="headerlink" title="Swift ABI 稳定"></a>Swift ABI 稳定</h3><p>历时5年发展，从Swift1.x发展到了Swift5.x版本，经历了多次重大改变，ABI终于稳定。</p><p>ABI 稳定就是 binary 接口稳定，意味着Swift语法基本不会再有太大的变动。也就是在运行的时候只要是用 Swift 5 (或以上) 的编译器编译出来的 binary，就可以跑在任意的 Swift 5 (或以上) 的 runtime 上。这样，我们就不需要像以往那样在 app 里放一个 Swift runtime 了，Apple 会把它弄到 iOS 和 macOS 系统里。</p><ul><li><p>Xcode 10.2 搭载的 Swift 5.0 版本的编译器</p></li><li><p>iOS 12.2 系统预装了 Swift 5 的 runtime</p></li></ul><h2 id="Swift-5-1"><a href="#Swift-5-1" class="headerlink" title="Swift 5.1"></a>Swift 5.1</h2><p>见《Swift编程从入门到精通》学习笔记</p><h2 id="Swift-5-2"><a href="#Swift-5-2" class="headerlink" title="Swift 5.2"></a>Swift 5.2</h2><p>从表面上看，Swift 5.2 在新语言特性方面绝对是一个次要版本，因为这个新版本的大部分重点是提高 Swift 底层基础设施的速度和稳定性——例如如何报告编译器错误，以及如何解决构建级别的依赖关系。</p><p>然而，虽然 Swift 5.2 的新语言特性<em>总数</em>可能相对较少，但它确实包含了几个新功能，它们可能会对 Swift 作为<em>函数式编程语言</em>的整体能力产生相当大的影响。</p><h4 id="1-callAsFunction"><a href="#1-callAsFunction" class="headerlink" title="1. callAsFunction"></a>1. callAsFunction</h4><p>在 <a href="https://swiftgg.gitbook.io/swift/yu-yan-can-kao/06_declarations#methods-with-special-names">特殊名称方法</a> 章节中新增了有关让类、结构体和枚举的实例作为函数调用语法糖的内容。</p><p>一些含有特殊名称的方法允许使用函数调用语法糖。如果一个类型定义了某个此类型的方法，那这些类型的实例对象都可以使用函数调用语法。这些函数调用会被解析为某个具有特殊名称的实例方法调用。</p><h5 id="dynamicCallable补充"><a href="#dynamicCallable补充" class="headerlink" title="dynamicCallable补充"></a>dynamicCallable补充</h5><p>之前的 <a href="https://swiftgg.gitbook.io/swift/yu-yan-can-kao/07_attributes#dynamicCallable">dynamicCallable</a> 特性中：只要定义了 <code>dynamicallyCall(withArguments:)</code> 方法或者 <code>dynamicallyCall(withKeywordArguments:)</code> 方法，一个类、结构体或者枚举类型都支持函数调用语法。</p><p>该特性用于类、结构体、枚举或协议，以将该类型的实例视为可调用的函数。该类型必须实现上面两个方法之一，或两者同时实现。</p><p>可以调用 <code>dynamicCallable</code> 特性的实例，就像是调用一个任意数量参数的函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamicCallable</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TelephoneExchange</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dynamicallyCall</span>(<span class="params">withArguments</span> <span class="params">phoneNumber</span>: [<span class="type">Int</span>])</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> phoneNumber <span class="operator">==</span> [<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Get Swift help on forums.swift.org&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Unrecognized number&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dial <span class="operator">=</span> <span class="type">TelephoneExchange</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态方法调用</span></span><br><span class="line">dial(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 打印“Get Swift help on forums.swift.org”</span></span><br><span class="line"></span><br><span class="line">dial(<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment">// 打印“Unrecognized number”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用底层方法</span></span><br><span class="line">dial.dynamicallyCall(withArguments: [<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>定义了一个函数调用方法（call-as-function method）也可以达到上述效果。如果一个类型同时定义了一个函数调用方法和使用 <code>dynamicCallable</code> 属性的方法，那么在合适的情况下，编译器会优先使用函数调用方法。</p><p>函数调用方法的名称是 <code>callAsFunction()</code>，或者任意一个以 <code>callAsFunction(</code> 开头并跟随着一些已标签化或未标签化的参数——例如 <code>callAsFunction(_:_:)</code> 和 <code>callAsFunction(something:)</code> 都是合法的函数调用方法名称。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CallableStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callAsFunction</span>(<span class="keyword">_</span> <span class="params">number</span>: <span class="type">Int</span>, <span class="params">scale</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(scale <span class="operator">*</span> (number <span class="operator">+</span> value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> callable <span class="operator">=</span> <span class="type">CallableStruct</span>(value: <span class="number">100</span>)</span><br><span class="line">callable(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line">callable.callAsFunction(<span class="number">4</span>, scale: <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 两次函数调用都会打印 208</span></span><br></pre></td></tr></table></figure><h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h4><ul><li>更新 <a href="">下标选项</a> 章节，现在下标支持形参默认值。</li><li>更新 <a href="">自身类型</a> 章节，现在 <code>Self</code> 可以在更多上下文中使用。</li></ul><h2 id="Swift-5-3"><a href="#Swift-5-3" class="headerlink" title="Swift 5.3"></a>Swift 5.3</h2><h4 id="1-多尾随闭包"><a href="#1-多尾随闭包" class="headerlink" title="1. 多尾随闭包"></a>1. 多尾随闭包</h4><p>Swift 5.3 之前即使有多个尾随闭包也只有最后一个能被写成精简的形式，这种写法一个闭包在圆括号内，另一个在外面。新的写法把这些闭包都放在圆括号外面，显得更加简洁。<strong>注意：尾随闭包中的第一个闭包的标签会被强制省略。</strong></p><h4 id="2-枚举可比较"><a href="#2-枚举可比较" class="headerlink" title="2. 枚举可比较"></a>2. 枚举可比较</h4><h4 id="3-异常catch多值处理"><a href="#3-异常catch多值处理" class="headerlink" title="3. 异常catch多值处理"></a>3. 异常catch多值处理</h4><p>异常catch 后面可以捕获多个异常的值，以逗号隔开</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> <span class="type">FileReadError</span>.<span class="type">FileISNull</span>, <span class="type">FileReadError</span>.<span class="type">FileNotFound</span> &#123; <span class="comment">// 同时处理</span></span><br></pre></td></tr></table></figure><h4 id="4-main"><a href="#4-main" class="headerlink" title="4. @main"></a>4. <code>@main</code></h4><p>作为声明程序的入口点，替换掉以前的<code>@UIApplicationMain</code>。</p><h4 id="5-self改变"><a href="#5-self改变" class="headerlink" title="5. self改变"></a>5. self改变</h4><p>以前闭包中引用当前范围的内容时必须带上<code>self.</code>，Swift 5.3 之后如果不产生循环引用可以省略<code>self.</code>。这个新特性对 SwiftUI 来说非常友好，因为 SwiftUI 中的 View 保存在值类型的结构体中，所以不会发生循环引用。</p><h4 id="6-didSet性能提升"><a href="#6-didSet性能提升" class="headerlink" title="6. didSet性能提升"></a>6. didSet性能提升</h4><p>以前在一个属性中使用 didSet 时，总是调用 getter 来获取该属性的 oldValue（即使没有用到），从而影响性能。Swift 5.3 之后只有在<code>didSet</code>中使用了<code>oldValue</code>参数时，getter 才会被调用。</p><h4 id="7-语法缩进改进"><a href="#7-语法缩进改进" class="headerlink" title="7. 语法缩进改进"></a>7. 语法缩进改进</h4><p>guard 和 if 语句中的条件可以按列对齐。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> x <span class="operator">=</span> optionalX,</span><br><span class="line">      <span class="keyword">let</span> y <span class="operator">=</span> optionalY <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x <span class="operator">=</span> optionalX,</span><br><span class="line">   <span class="keyword">let</span> y <span class="operator">=</span> optionalY &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-新增浮点型Float16"><a href="#8-新增浮点型Float16" class="headerlink" title="8. 新增浮点型Float16"></a>8. 新增浮点型Float16</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number: <span class="type">Float16</span> <span class="operator">=</span> <span class="number">5.0</span></span><br></pre></td></tr></table></figure><h4 id="9-新增日志API"><a href="#9-新增日志API" class="headerlink" title="9. 新增日志API"></a>9. 新增日志API</h4><p>提供了 5 种级别：</p><ul><li>Debug：Debug时使用。</li><li>Info：可以在排查问题时使用。</li><li>Notice (default)：默认，可以在排查问题时使用。</li><li>Error：在程序执行出错时使用。</li><li>Fault：在程序出现bug时使用。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.导入模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建Logger实例</span></span><br><span class="line"><span class="keyword">let</span> logger <span class="operator">=</span> <span class="type">Logger</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用log函数</span></span><br><span class="line">logger.log(level: .debug, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .info, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .default, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .error, <span class="string">&quot;test&quot;</span>)</span><br><span class="line">logger.log(level: .fault, <span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h4><ul><li>Swift Package Manager 功能增强。</li><li>Swift 语言性能继续提升。</li></ul><h2 id="Swift-5-4"><a href="#Swift-5-4" class="headerlink" title="Swift 5.4"></a>Swift 5.4</h2><h4 id="1-改进隐式成员语法"><a href="#1-改进隐式成员语法" class="headerlink" title="1. 改进隐式成员语法"></a>1. 改进隐式成员语法</h4><p>在 UIKit 和 SwiftUI 中设置颜色时，无法直接通过<code>.</code>的方式进行颜色的书写，必须带上前缀<code>UIColor</code>或者<code>Color</code>，因为无法根据上下文进行成员推测，Swift 5.4 中改进了这个语法，可以省去前缀且支持链式调用。</p><ul><li>UIKit</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">view.backgroundColor <span class="operator">=</span> .red.withAlphaComponent(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><ul><li>SwiftUI</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Swift 5.4&quot;</span>)</span><br><span class="line">            .foregroundColor(.red.opacity(<span class="number">0.5</span>))</span><br><span class="line">            .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-支持多个可变参数"><a href="#2-支持多个可变参数" class="headerlink" title="2. 支持多个可变参数"></a>2. 支持多个可变参数</h4><p>Swift 5.4 之前函数只能有一个参数为可变参数， 现在支持多个可变参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">score</span>(<span class="params">courses</span>: <span class="type">String</span>..., <span class="params">scores</span>: <span class="type">Int</span>...)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> courses.count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;《<span class="subst">\(courses[i])</span>》课程的成绩：<span class="subst">\(scores[i])</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">score(courses: <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;iOS开发&quot;</span>, <span class="string">&quot;SwiftUI&quot;</span>, scores: <span class="number">90</span>, <span class="number">95</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h4 id="3-嵌套函数支持重载"><a href="#3-嵌套函数支持重载" class="headerlink" title="3. 嵌套函数支持重载"></a>3. 嵌套函数支持重载</h4><p>Swift 5.4 之前普通函数可以重载，现在嵌套函数也支持重载。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">method</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 内嵌函数一</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数二</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Int</span>, <span class="params">num2</span>: <span class="type">Int</span>, <span class="params">num3</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2 <span class="operator">+</span> num3</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数三</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">num1</span>: <span class="type">Double</span>, <span class="params">num2</span>: <span class="type">Double</span>)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内嵌函数四</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span> <span class="params">num1</span>: <span class="type">Int</span>, <span class="params">b</span> <span class="params">num2</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num1 <span class="operator">+</span> num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add(num1: <span class="number">10</span>, num2: <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line">    add(num1: <span class="number">10</span>, num2: <span class="number">20</span>, num3: <span class="number">30</span>) <span class="comment">// 60</span></span><br><span class="line">    add(num1: <span class="number">10.0</span>, num2: <span class="number">20.0</span>) <span class="comment">// 30</span></span><br><span class="line">    add(a: <span class="number">10</span>, b: <span class="number">20</span>) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method()</span><br></pre></td></tr></table></figure><h4 id="4-Result-builders"><a href="#4-Result-builders" class="headerlink" title="4. Result builders"></a>4. Result builders</h4><ul><li>Swift 5.4 之前叫 <strong>Function builders</strong>，它使用一个<code>buildBlock</code>方法可以将<strong>多个内容</strong>构建为<strong>一个结果</strong>，该特性在 SwiftUI 广泛使用。</li><li>可以使用<code>@resultBuilder</code>自定义 Result builders。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// buildBlock中将多个值构建为一个结果</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">strs</span>: <span class="type">String</span>...)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// 以换行符拼接多个字符串</span></span><br><span class="line">        strs.joined(separator: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if逻辑分支</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;if <span class="subst">\(component)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// else逻辑分支</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;else <span class="subst">\(component)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@StringBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildString</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="string">&quot;静夜思&quot;</span></span><br><span class="line">    <span class="string">&quot;唐•李白&quot;</span></span><br><span class="line">    <span class="string">&quot;床前明月光，疑是地上霜。&quot;</span></span><br><span class="line">    <span class="string">&quot;举头望明月，低头思故乡。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="type">Bool</span>.random() &#123;</span><br><span class="line">        <span class="string">&quot;一首诗&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;一首词&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(buildString())</span><br></pre></td></tr></table></figure><h4 id="5-局部变量支持属性包装"><a href="#5-局部变量支持属性包装" class="headerlink" title="5. 局部变量支持属性包装"></a>5. 局部变量支持属性包装</h4><p>Swift 5.4 将 Swift 5.1 中引入的属性包装支持到局部变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性包装</span></span><br><span class="line"><span class="keyword">@propertyWrapper</span> <span class="class"><span class="keyword">struct</span> <span class="title">Trimmed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; value <span class="operator">=</span> newValue.trimmingCharacters(in: .whitespacesAndNewlines) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">wrappedValue</span> <span class="params">initialValue</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        wrappedValue <span class="operator">=</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">trimed</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="meta">@Trimmed</span> <span class="keyword">var</span> content: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;  Swift 5.4 Property Wrappers  &quot;</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> post <span class="operator">=</span> <span class="type">Post</span>()</span><br><span class="line">        post.trimed()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SwiftUI 中的应用。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义View</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomView</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性包装定义内容</span></span><br><span class="line">    <span class="meta">@ViewBuilder</span> <span class="keyword">var</span> content: () -&gt; <span class="type">Content</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span>(.horizontal) &#123;</span><br><span class="line">            <span class="type">HStack</span>(content: content)</span><br><span class="line">                .padding()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">CustomView</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">10</span>) &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">Image</span>(systemName: <span class="string">&quot;heart&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;SwiftUI&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift-5-5"><a href="#Swift-5-5" class="headerlink" title="Swift 5.5"></a>Swift 5.5</h2><p>在 <a href="https://developer.apple.com/videos/">WWDC21</a> 上，Apple 推出了Swift 5.5第一个快照版本</p><h4 id="1-Async-Await"><a href="#1-Async-Await" class="headerlink" title="1. Async/Await"></a>1. Async/Await</h4><p>在众多新功能中，最令人期待的功能之一是使用和 actor<a href="https://developer.apple.com/documentation/swift/swift_standard_library/concurrency">更好地支持并发</a><code>aysnc/await</code>。</p><h4 id="2-throwing-properties"><a href="#2-throwing-properties" class="headerlink" title="2. throwing properties"></a>2. throwing properties</h4><p><a href="https://www.hackingwithswift.com/articles/233/whats-new-in-swift-5-5">What’s new in Swift 5.5? — hackingwithswift</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://swift.org/blog/">https://swift.org/blog/</a></li><li><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift/04_revision_history">Swift版本历史记录—SwiftGG</a></li><li><a href="https://www.hackingwithswift.com/articles">Hacking With Swift</a>、<a href="https://www.swiftbysundell.com/articles/">Swift By Sundell</a>这是两个个人网站，可以在文章中搜5.4 5.5等查看</li><li><a href="https://juejin.cn/post/6913699890472648712">Swift 5.3 新特性 — YungFan</a></li><li><a href="https://juejin.cn/post/6961964537197101064">Swift 5.4 新特性 — YungFan</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Swift-ABI-稳定&quot;&gt;&lt;a href=&quot;#Swift-ABI-稳定&quot; class=&quot;headerlink&quot; title=&quot;Swift ABI 稳定&quot;&gt;&lt;/a&gt;Swift ABI 稳定&lt;/h3&gt;&lt;p&gt;历时5年发展，从Swift1.x发展到了Swift5.x版本</summary>
      
    
    
    
    <category term="Swift" scheme="https://tenloy.github.io/categories/Swift/"/>
    
    
    <category term="Swift-Syntax" scheme="https://tenloy.github.io/tags/Swift-Syntax/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出GCD常用API</title>
    <link href="https://tenloy.github.io/2021/06/28/GCD.html"/>
    <id>https://tenloy.github.io/2021/06/28/GCD.html</id>
    <published>2021-06-28T19:12:21.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是多线程编程？"><a href="#一、什么是多线程编程？" class="headerlink" title="一、什么是多线程编程？"></a>一、什么是多线程编程？</h2><p>先来复习一下<code>操作系统</code>中线程相关的知识点：</p><h3 id="1-1-代码的运行"><a href="#1-1-代码的运行" class="headerlink" title="1.1 代码的运行"></a>1.1 代码的运行</h3><p><strong>首先，代码是怎么运行的？</strong></p><ul><li>源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。</li><li>CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的地址会远离当前的位置（位置迁移），但是由于一个CUP一次只能执行一个命令，不能执行某处分开的并列的两个命令，因此通过CPU执行的CPU命令列就好比一条无分叉的大道，其执行不会出现分歧。</li></ul><p><strong>一个CPU执行的CPU命令列尾一条无分叉的路径即为“线程”</strong></p><h3 id="1-2-上下文切换"><a href="#1-2-上下文切换" class="headerlink" title="1.2 上下文切换"></a>1.2 上下文切换</h3><blockquote><p>OS X和ios的核心XNU内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路经。执行中路经的状态，例如CPU的寄存器的信息保存到各自路经专用的内存块中，从切换目标路经专用的内存块中，复原CPU寄存器的信息，继续执行切换路经的CPU命令列，这被称为“上下文切换”</p></blockquote><p>上下文切换是并行（单处理器中进程被交替执行，表现出并发外部特征）`的核心关键。</p><p>单核中的多线程是并发，其实是顺序执行的，只不过CPU高速的切换，表面看起来像是并行。<br>多核中的多线程，在线程数小于 &lt; CPU核数时，是真正的并行。</p><p>关于并发和并行的区别，可以看<a href="https://www.jianshu.com/p/446bf121ff8f">上一篇中的介绍</a></p><p><strong>iOS和OS X的核心 — XNU内核决定应当使用的线程数，并只生成所需的线程执行处理，另外，当处理结束，应当执行的处理数减少时，XNU内核会结束不再需要的线程，XNU内核仅使用并行队列便可完美的管理并行执行处理的线程</strong></p><h3 id="1-3-多线程编程的优缺点"><a href="#1-3-多线程编程的优缺点" class="headerlink" title="1.3 多线程编程的优缺点"></a>1.3 多线程编程的优缺点</h3><ul><li><p><strong>优点：</strong>保证应用程序的响应性能</p></li><li><p><strong>缺点</strong>：是易发生各种问题，比如：数据竞争、死锁，而且使用太多线程会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</p></li></ul><h3 id="1-4-主线程"><a href="#1-4-主线程" class="headerlink" title="1.4 主线程"></a>1.4 主线程</h3><p>应用程序启动时。通过最先执行的线程，即‘主线程’来描绘用户界面、处理触摸屏幕的事件，如果在该线程中进行长时间的处理，会造成主线程阻塞，会妨碍主线程中被称为RunLoop的主循环执行，从而导致不能更新用户界面、应用程序画面长时间停滞等问题</p><p><strong>GCD大大简化了偏于复杂的多线程编程的源代码，与Block结合使用，只需要将要执行的任务并追加到适当的Dispatch Queue</strong></p><h2 id="二、GCD基础篇"><a href="#二、GCD基础篇" class="headerlink" title="二、GCD基础篇"></a>二、GCD基础篇</h2><p>Grand Central Dispatch(GCD)</p><ul><li>是Apple推出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要再管理线程的生命周期，只需要关注于要执行的任务即可。</li><li>是异步执行任务的技术之一，用非常简洁的技术方法，实现了极为复杂繁琐的多线程编程</li></ul><p>GCD的源码libdispatch版本很多，源代码风格各版本都有不同，但大体逻辑没有太大变化。libdispatch的源码下载地址<a href="https://opensource.apple.com/tarballs/libdispatch/">在这里</a>。</p><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h3><p>阅读GCD的源码之前，先了解一些相关知识，方便后面的理解。</p><h4 id="2-1-1-DISPATCH-DECL"><a href="#2-1-1-DISPATCH-DECL" class="headerlink" title="2.1.1 DISPATCH_DECL"></a>2.1.1 DISPATCH_DECL</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure><p>GCD中的变量大多使用了这个宏，比如<code>DISPATCH_DECL(dispatch_queue)</code>展开后是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>；</span></span><br></pre></td></tr></table></figure><p>它的意思是定义一个<code>dispatch_queue_t</code>类型的指针，指向了一个<code>dispatch_queue_s</code>类型的结构体。</p><h4 id="2-1-2-fastpath-vs-slowpath"><a href="#2-1-2-fastpath-vs-slowpath" class="headerlink" title="2.1.2 fastpath vs slowpath"></a>2.1.2 fastpath vs slowpath</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span></span><br></pre></td></tr></table></figure><p><code>__builtin_expect</code>是编译器用来优化执行速度的函数，fastpath表示条件更可能成立，slowpath表示条件更不可能成立。我们在阅读源码的时候可以做忽略处理。</p><h4 id="2-1-3-TSD"><a href="#2-1-3-TSD" class="headerlink" title="2.1.3 TSD"></a>2.1.3 TSD</h4><p>Thread Specific Data(TSD)是指线程私有数据。在多线程中，会用全局变量来实现多个函数间的数据共享，局部变量来实现内部的单独访问。TSD则是能够在同一个线程的不同函数中被访问，在不同线程时，相同的键值获取的数据随线程不同而不同。可以通过pthread的相关api来实现TSD:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *, <span class="keyword">void</span> (* _Nullable)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* _Nullable <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> , <span class="keyword">const</span> <span class="keyword">void</span> * _Nullable)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-常用数据结构"><a href="#2-2-常用数据结构" class="headerlink" title="2.2 常用数据结构"></a>2.2 常用数据结构</h3><h4 id="2-2-1-dispatch-object-s结构体"><a href="#2-2-1-dispatch-object-s结构体" class="headerlink" title="2.2.1 dispatch_object_s结构体"></a>2.2.1 dispatch_object_s结构体</h4><p>dispatch_object_s是GCD最基础的结构体，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD的基础结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(object);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//os object头部宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OS_OBJECT_HEADER(isa, ref_cnt, xref_cnt) \</span></span><br><span class="line">        isa; <span class="comment">/* must be pointer-sized */</span> \  <span class="comment">//isa</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \             <span class="comment">//引用计数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt               <span class="comment">//外部引用计数，两者都为0时释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> struct dispatch_#<span class="meta">#x##_vtable_s *do_vtable, \  <span class="comment">//vtable结构体</span></span></span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \   <span class="comment">//下一个do</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \         <span class="comment">//目标队列</span></span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \                               <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *do_finalizer; \                          <span class="comment">//销毁时调用函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> do_suspend_cnt;                   <span class="comment">//suspend计数，用作暂停标志</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-dispatch-continuation-s结构体"><a href="#2-2-2-dispatch-continuation-s结构体" class="headerlink" title="2.2.2 dispatch_continuation_s结构体"></a>2.2.2 dispatch_continuation_s结构体</h4><p>dispatch_continuation_s结构体主要封装block和function，<code>dispatch_async</code>中的block最终都会封装成这个数据类型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_CONTINUATION_HEADER</span>(continuation);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continuation结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable, \                            do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                                 <span class="comment">//_OS_OBJECT_HEADER定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \                  <span class="comment">//执行内容</span></span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \                                <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *dc_data; \                                <span class="comment">//相关数据</span></span><br><span class="line">    <span class="keyword">void</span> *dc_other;                                 <span class="comment">//其他</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-dispatch-object-t联合体"><a href="#2-2-3-dispatch-object-t联合体" class="headerlink" title="2.2.3 dispatch_object_t联合体"></a>2.2.3 dispatch_object_t联合体</h4><p>dispatch_object_t是个union的联合体，可以用dispatch_object_t代表这个联合体里的所有数据结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span>             <span class="comment">//object结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span>       <span class="comment">//任务,dispatch_aync的block会封装成这个数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>              <span class="comment">//队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>        <span class="comment">//队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>              <span class="comment">//群组操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span>             <span class="comment">//source结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_aggregate_s</span> *_<span class="title">dta</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span>       <span class="comment">//source属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>       <span class="comment">//信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> __attribute__((__transparent_union__));</span><br></pre></td></tr></table></figure><h4 id="2-2-4-DISPATCH-VTABLE-HEADER宏"><a href="#2-2-4-DISPATCH-VTABLE-HEADER宏" class="headerlink" title="2.2.4 DISPATCH_VTABLE_HEADER宏"></a>2.2.4 DISPATCH_VTABLE_HEADER宏</h4><p>GCD中常见结构体（比如queue、semaphore等）的vtable字段中定义了很多函数回调，在后续代码分析中会经常看到，定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch vtable的头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_VTABLE_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> do_type; \     <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> do_kind; \       <span class="comment">//种类，比如:group/queue/semaphore</span></span><br><span class="line">    <span class="built_in">size_t</span> (*<span class="keyword">const</span> do_debug)(struct dispatch_#<span class="meta">#x##_s *, char *, size_t); \ <span class="comment">//debug用</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_invoke)(struct dispatch_#<span class="meta">#x##_s *); \    <span class="comment">//invoke回调</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in"><span class="keyword">long</span></span> (*<span class="keyword">const</span> do_probe)(struct dispatch_#<span class="meta">#x##_s *); \   <span class="comment">//probe回调</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_dispose)(struct dispatch_#<span class="meta">#x##_s *);     <span class="comment">//dispose回调，销毁时调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dx_xxx开头的宏定义，后续文章会用到，本质是调用vtable的do_xxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_type(x) (x)-&gt;do_vtable-&gt;do_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_metatype(x) ((x)-&gt;do_vtable-&gt;do_type &amp; _DISPATCH_META_TYPE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_kind(x) (x)-&gt;do_vtable-&gt;do_kind</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_debug(x, y, z) (x)-&gt;do_vtable-&gt;do_debug((x), (y), (z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_dispose(x) (x)-&gt;do_vtable-&gt;do_dispose(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_invoke(x) (x)-&gt;do_vtable-&gt;do_invoke(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-dispatch-queue-s-队列结构"><a href="#2-2-5-dispatch-queue-s-队列结构" class="headerlink" title="2.2.5 dispatch_queue_s(队列结构)"></a>2.2.5 dispatch_queue_s(队列结构)</h4><p>dispatch_queue_s是队列的结构体，也是GCD中开发者接触最多的结构体了，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(queue);    <span class="comment">//基础header</span></span><br><span class="line">    DISPATCH_QUEUE_HEADER;            <span class="comment">//队列头部，见下面的定义</span></span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; <span class="comment">// for static queues only</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列自己的头部定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_HEADER \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_running; \                       <span class="comment">//队列运行的任务数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> \   <span class="comment">//链表头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> \   <span class="comment">//链表尾部节点</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq_specific_q; \                     <span class="comment">//specific队列</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dq_width; \                                  <span class="comment">//队列并发数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dq_is_thread_bound:<span class="number">1</span>; \                  <span class="comment">//是否线程绑定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; \                         <span class="comment">//队列的序列号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dq_label; \                               <span class="comment">//队列名</span></span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_LIST;</span><br></pre></td></tr></table></figure><p>队列的do_table中有很多函数指针，阅读queue的源码时会遇到dx_invoke或者dx_probe等函数，它们其实就是调用vtable中定义的函数。下面看一下相关定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main-queue和普通queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_INSTANCE</span>(queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,    <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,      <span class="comment">//invoke函数</span></span><br><span class="line">    .do_probe = _dispatch_queue_probe,        <span class="comment">//probe函数</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,         <span class="comment">//debug回调</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//global-queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,  <span class="comment">//global-queue销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,              <span class="comment">//_dispatch_wakeup时会调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                    <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="三、GCD的API"><a href="#三、GCD的API" class="headerlink" title="三、GCD的API"></a>三、GCD的API</h2><h3 id="3-1-Dispatch-Queue-调度队列"><a href="#3-1-Dispatch-Queue-调度队列" class="headerlink" title="3.1 Dispatch Queue(调度队列)"></a>3.1 Dispatch Queue(调度队列)</h3><p><code>dispatch_queue</code>可以说是GCD编程中使用频率最高的API，这一节主要讲一下queue的相关用法和原理，关于queue的数据结构和常用定义见上节。</p><ul><li>Dispatch Queue按照追加的顺序（先进先出FIFO）执行处理</li><li>Dispatch Queue分两种：<ul><li>一种是等待现在执行中处理结束的 Serial Dispatch Queue(串行调度队列)</li><li>一种是不等待现在执行中处理结束的 Concurrent Dispatch Queue(并行调度队列)</li></ul></li><li>Dispatch Queue实例：<ul><li>库内置了两个队列：<ul><li>Main Dispatch Queue(串行队列)：追加到Main Dispatch Queue中的处理在主线程的RunLoop中执行</li><li>Global Dispatch Queue(并行队列)</li></ul></li><li>也可以用 dispatch_queue_create 来创建串行、并行队列</li></ul></li></ul><h4 id="3-1-1-使用"><a href="#3-1-1-使用" class="headerlink" title="3.1.1 使用"></a>3.1.1 使用</h4><h5 id="1-Global-Dispatch-Queue-并行队列"><a href="#1-Global-Dispatch-Queue-并行队列" class="headerlink" title="1. Global Dispatch Queue(并行队列)"></a>1. Global Dispatch Queue(并行队列)</h5><p>Global Dispatch Queue有4个执行优先级</p><ul><li>最高优先级（High Priority）</li><li>默认优先级（Default Priority）</li><li>低优先级（Low Priority）</li><li>后台优先级（Background Priority）</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"></span><br><span class="line">dispatch_get_global_queue(优先级变量, unsigned long flags)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Global</span> Dispatch Quene有如下<span class="number">8</span>种:</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(High Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(<span class="keyword">Default</span> Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Low Overcommit Priority)</span><br><span class="line"> <span class="keyword">Global</span> Dispatch Quene(Background Overcommit Priority)</span><br></pre></td></tr></table></figure><ul><li><p>优先级中附有 Overcommit 的 Global Dispatch Quene 使用在 Serial Dispatch Quene中。</p><p>不管系统状态如何，都会强制生成线程的 Dispatch Quene。所以这也是不要大量生成串行队列的原因。对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现大量创建线程的状况。</p></li><li><p>同XNU内核用于 Global Dispatch Queue 的线程并<strong>不能保证实时性</strong>，所以优先级只是个大致判断。</p></li><li><p><strong>XNU内核管理，会将各自使用的队列的执行优先级，作为线程的执行优先级使用，所以添加任务时，需要选择与处理的任务对应优先级的队列。</strong></p></li><li><p>对上面两种队列执行 dispatch_retain 函数和 dispatch_release 函数无效，开发者无需关心这两者的保留、释放</p></li></ul><h5 id="2-dispatch-queue-create-创建队列"><a href="#2-dispatch-queue-create-创建队列" class="headerlink" title="2. dispatch_queue_create(创建队列)"></a>2. dispatch_queue_create(创建队列)</h5><ul><li><p>1个并行队列 + 多个异步任务(dispatch_async) = 会开启多线程</p></li><li><p>多个(1个串行队列+1个(同步/异步)任务(dispatch_sync)) = 多线程</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @参数1 指定Dispatch Queue名称（推荐使用应用程序ID这种逆序全程域名，该名称便于Xcode和Instruments调试，会出现在CrashLog中）</span></span><br><span class="line"><span class="comment"> * @参数2 Serial Dispatch Queue指定为NULL；Concurrent Dispatch Queue指定为DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 为表示Dispatch Queue的&quot;dispatch_queue_t类型&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create (<span class="string">&quot;com.example.MySerialDispatchQueue&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(mySerialDispatchQueue)</span><br></pre></td></tr></table></figure><ul><li><p>dispatch_queue_t 类型变量，必须程序员自己负责释放，像OC的引用计数式内存管理一样，需要通过 <code>dispatch_retain</code> 函数和 <code>dispatch_release</code> 函数的引用计数来管理内存。</p></li><li><p>在 <code>dispatch_async</code>、<code>diapatch_sync</code> 函数中追加 Block 到 Dispatch Queue（该 Block 通过 dispatch_retain 函数持有 Dispatch Queue）</p></li><li><p>一旦 Block 执行结束，就要通过 dispatch_release 函数函数释放该 Block 持有的 Dispatch Queue。</p></li></ul><p><strong>释放时机：</strong></p><ul><li><p>在 dispatch_async 函数中追加 Block 到 Dispatch Queue 后，即是立刻释放 Dispatch Queue，该 Dispatch Queue 由于被 Block 持有也不会废弃，因而 Block 能够执行，Block 执行结束后释放该 Block 持有的 Dispatch Queue，这时谁都不持有 Dispatch Queue，因此它被废弃。</p></li><li><p>在通过函数或方法名获取 Dispatch Queue 以及其他名称中包含 <code>creat</code> 的API生成的对象时，有必要通过 dispatch_retain 函数持有，并在不需要时通过 dispatch_release 函数释放。</p></li></ul><p>系统对于一个串行队列，就只生成并使用一个线程，所以串行队列的生成个数应当仅限所必需的数量，不能大量生成。</p><p>对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现串行队列那种问题。</p><h5 id="3-dispatch-set-target-queue"><a href="#3-dispatch-set-target-queue" class="headerlink" title="3. dispatch_set_target_queue"></a>3. dispatch_set_target_queue</h5><p>dispatch_queue_create函数生成的队列，生成的线程优先级为 Global Dispatch Queue 的默认优先级。</p><p>变更生成的Dispatch Queue的执行优先级要使用dispatch_set_target_queue函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalDispatchQueueBackground = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_PRIORITY_BACKGROUND ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指定要变更执行优先级的Dispatch Queue为dispatch_set_target_queue函数的第一个参数</span></span><br><span class="line"><span class="comment"> * 指定与要使用的执行优先级相同优先级的Dispatch Queue为第二个参数（目标）</span></span><br><span class="line"><span class="comment"> * Main Dispatch Queue和Global Dispatch Queue不可指定为第一个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_set_target_queue</span>(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>变更执行优先级</li><li>目标队列会变成第一个参数队列中任务的执行阶层<ul><li>多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理（可防止 Serial Dispatch Queue 处理并行执行）</li><li>使多个serial队列变并行为串行</li></ul></li></ul><h5 id="4-dispatch-async与dispatch-sync"><a href="#4-dispatch-async与dispatch-sync" class="headerlink" title="4. dispatch_async与dispatch_sync"></a>4. dispatch_async与dispatch_sync</h5><p>当我们处理耗时操作时，比如读取数据库、请求网络数据，为了避免这些耗时操作卡住UI,可将耗时任务放到子线程中，执行完成后再通知主线程更新UI。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Submits a block for asynchronous execution on a dispatch queue and returns immediately.</span></span><br><span class="line"><span class="comment">  在分派队列上提交一个用于异步执行的块，然后立即返回。如果不是主队列就会开启新的线程，但不管开启不开启，都是马上返回的，不会阻塞！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  dispatch_sync：Submits a block object for execution and returns after that block finishes executing.</span></span><br><span class="line"><span class="comment">  即在当前线程同步执行任务，执行完毕才能继续往下执行。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">         <span class="comment">//更新UI</span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-1-2-原理"><a href="#3-1-2-原理" class="headerlink" title="3.1.2 原理"></a>3.1.2 原理</h4><h5 id="1-dispatch-get-global-queue"><a href="#1-dispatch-get-global-queue" class="headerlink" title="1. dispatch_get_global_queue"></a>1. dispatch_get_global_queue</h5><p>dispatch_get_global_queue用于获取一个全局队列，先看一下它的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_get_global_queue</span><span class="params">(<span class="keyword">long</span> priority, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装调用_dispatch_get_root_queue函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(priority,</span><br><span class="line">            flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_t</span> _dispatch_get_root_queue(<span class="keyword">long</span> priority, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (overcommit) <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (priority) &#123;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[</span><br><span class="line">                DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_LOW:</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_NON_INTERACTIVE:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_DEFAULT:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY];</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_QUEUE_PRIORITY_HIGH:</span><br><span class="line">        <span class="keyword">return</span> &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列优先级有八个，分别为低、默认、高、后台以及对应的overcommit。枚举定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_PRIORITY = <span class="number">0</span>,                <span class="comment">//低优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_LOW_OVERCOMMIT_PRIORITY,         <span class="comment">//低优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_PRIORITY,                <span class="comment">//默认优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY,     <span class="comment">//默认优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_PRIORITY,                   <span class="comment">//高优先级</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_HIGH_OVERCOMMIT_PRIORITY,        <span class="comment">//高优先级+overcommit</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_PRIORITY,             <span class="comment">//后台</span></span><br><span class="line">    DISPATCH_ROOT_QUEUE_IDX_BACKGROUND_OVERCOMMIT_PRIORITY,  <span class="comment">//后台+overcomit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_dispatch_get_root_queue</code>从_dispatch_root_queues结构体中获取对应优先级的队列。最后1bit为1的代表overcommit，带有overcommit标记的队列会在任务提交时新创建一个线程处理它。</p><p><code>_dispatch_root_queues</code>取出的<code>dispatch_queue_s</code>队列的do_ctxt字段表示queue的线程池，定义于<code>_dispatch_root_queue_contexts</code>结构体中，每个线程池的最大线程数限制是255。</p><p>下面看一下global queue的do_vtable结构体，它比较重要的是do_probe的调用函数<code>_dispatch_root_queue_probe</code>,这个函数在后续的分析中会用到。结构体定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose, <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,             <span class="comment">//重要，唤醒队列时调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                   <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-get-main-queue"><a href="#2-dispatch-get-main-queue" class="headerlink" title="2. dispatch_get_main_queue"></a>2. dispatch_get_main_queue</h5><p>该API的使用主要是在更新UI时获取<code>dispatch_get_main_queue()</code>并把任务提交到主队列中。它的源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义，返回到是_dispatch_main_q</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_get_main_queue() \</span></span><br><span class="line">        <span class="built_in">DISPATCH_GLOBAL_OBJECT</span>(<span class="keyword">dispatch_queue_t</span>, _dispatch_main_q)</span><br><span class="line"></span><br><span class="line"><span class="comment">//main_queue结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_main_q</span> =</span> &#123;</span><br><span class="line">    .do_vtable = <span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">    .do_targetq = &amp;_dispatch_root_queues[</span><br><span class="line">            DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],  <span class="comment">//目标队列</span></span><br><span class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,   </span><br><span class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,  </span><br><span class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,   <span class="comment">//队列名</span></span><br><span class="line">    .dq_running = <span class="number">1</span>,          </span><br><span class="line">    .dq_width = <span class="number">1</span>,            <span class="comment">//最大并发数是1，串行队列</span></span><br><span class="line">    .dq_is_thread_bound = <span class="number">1</span>,  <span class="comment">//线程绑定</span></span><br><span class="line">    .dq_serialnum = <span class="number">1</span>,        <span class="comment">//序列号为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main queue设置了并发数为1，即串行队列,并且将targetq指向com.apple.root.default-overcommit-priority队列。</p><h5 id="3-dispatch-queue-create"><a href="#3-dispatch-queue-create" class="headerlink" title="3. dispatch_queue_create"></a>3. dispatch_queue_create</h5><p><code>dispatch_queue_create</code>主要用来创建自定义的队列，流程图和源码如下：</p><img src="/images/GCD/dispatch_queue-1.png" alt="img" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用dispatch_queue_create_with_target</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dispatch_queue_create_with_target</span>(label, attr,</span><br><span class="line">            DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_queue_create具体实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create_with_target</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_queue_attr_t</span> attr, <span class="keyword">dispatch_queue_t</span> tq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">   <span class="comment">//申请内存空间</span></span><br><span class="line">    dq = _dispatch_alloc(<span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">            <span class="built_in"><span class="keyword">sizeof</span></span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">  <span class="comment">//初始化，设置自定义队列的基本属性，方法实现见下面</span></span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">       <span class="comment">//设置队列名</span></span><br><span class="line">        dq-&gt;dq_label = <span class="built_in">strdup</span>(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attr == DISPATCH_QUEUE_CONCURRENT) &#123;</span><br><span class="line">       <span class="comment">//并行队列设置dq_width为UINT32_MAX</span></span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY</span></span><br><span class="line">            <span class="comment">// Default target queue is overcommit!</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置自定义队列的目标队列，dq队列的任务会放到目标队列执行</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列初始化方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;dq_running = <span class="number">0</span>;      <span class="comment">//队列当前运行时初始为0</span></span><br><span class="line">    dq-&gt;dq_width = <span class="number">1</span>;        <span class="comment">//队列并发数默认为1，串行队列</span></span><br><span class="line">    dq-&gt;dq_serialnum = <span class="built_in">dispatch_atomic_inc_orig</span>(&amp;_dispatch_queue_serial_numbers,</span><br><span class="line">            relaxed);          <span class="comment">//序列号,在_dispatch_queue_serial_numbers基础上原子性加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码介绍了自定义队列是如何创建的，初始化时会将dq_width默认设置为1，即串行队列。如果外部设置attr为DISPATCH_QUEUE_CONCURRENT，将并发数改为UINT32_MAX；<br>自定义队列的serialnum是在_dispatch_queue_serial_numbers基础上原子性加一，即从12开始累加。1到11被保留的序列号定义如下（后续版本有改动，自定义序列从16开始累加）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip zero        //跳过0</span></span><br><span class="line"><span class="comment">// 1 - main_q       //主队列</span></span><br><span class="line"><span class="comment">// 2 - mgr_q        //管理队列</span></span><br><span class="line"><span class="comment">// 3 - mgr_root_q   //管理队列的目标队列</span></span><br><span class="line"><span class="comment">// 4,5,6,7,8,9,10,11 - global queues   //全局队列</span></span><br><span class="line"><span class="comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">volatile</span> _dispatch_queue_serial_numbers = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>同时还会设置队列的target_queue，向队列提交的任务，都会被放到它的目标队列来执行。串行队列的target_queue是一个支持overcommit的全局队列，而全局队列的底层则是一个线程池。</p><p>借用一张队列的图片：</p><img src="/images/GCD/dispatch_queue-2.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-async"><a href="#4-dispatch-async" class="headerlink" title="4. dispatch_async"></a>4. dispatch_async</h5><p><code>dispatch_async</code>用来异步执行任务，它的代码比较复杂，我们可以分成三个阶段来看，第一阶段是更新队列链表，第二部分是从队列取任务，第三部分则是执行任务。每个阶段都有一张流程图表示，觉得代码多的话可以直接看每个阶段对应的流程图。</p><p>首先看一下<code>dispatch_async</code>的入口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_async封装调用了dispatch_async_f函数，先将block拷贝到堆上，避免block执行前被销毁，同时传入_dispatch_call_block_and_release来保证block执行后会执行Block_release。下面看一下dispatch_async_f的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//如果是串行队列，执行dispatch_barrier_async_f，和当前函数的不同点在于</span></span><br><span class="line">       <span class="comment">//.do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务封装到dispatch_continuation_t结构体中</span></span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;  <span class="comment">//将vtable设置为ASYNC标志位</span></span><br><span class="line">    dc-&gt;dc_func = func; </span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;do_targetq) &#123;</span><br><span class="line">       <span class="comment">//如果有do_targetq，将任务放到目标队列执行</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务压入队列(FIFO)</span></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析一下_dispatch_queue_push，这是一个宏定义，展开后的调用栈如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push</span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br></pre></td></tr></table></figure><p>看一下_dispatch_queue_push的具体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> =</span> _tail._do;</span><br><span class="line">    <span class="comment">//判断链表中是否已经存在节点，有的话返回YES,否则返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(_dispatch_queue_push_list2(dq, tail, tail))) &#123;</span><br><span class="line">       <span class="comment">//将任务放到链表头部</span></span><br><span class="line">        _dispatch_queue_push_slow(dq, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断链表中是否已经存在节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_queue_push_list2(<span class="keyword">dispatch_queue_t</span> dq, struct dispatch_object_s *head,</span><br><span class="line">        struct dispatch_object_s *tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">    tail-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将tail原子性赋值给dq-&gt;dq_items_tail，同时返回之前的值并赋给prev</span></span><br><span class="line">    prev = <span class="built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail, release);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(prev)) &#123;</span><br><span class="line">       <span class="comment">//如果prev不等于NULL，直接在链表尾部添加节点</span></span><br><span class="line">        prev-&gt;do_next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中之前有元素返回YES，否则返回NO</span></span><br><span class="line">    <span class="keyword">return</span> (prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点放到链表开头</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push_slow(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">        struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dx_type</span>(dq) == DISPATCH_QUEUE_ROOT_TYPE &amp;&amp; !dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">       <span class="comment">//原子性的将head存储到链表头部</span></span><br><span class="line">        <span class="built_in">dispatch_atomic_store2o</span>(dq, dq_items_head, obj, relaxed);</span><br><span class="line">        <span class="comment">//唤醒global queue队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将obj放到链表头部并执行_dispatch_wakeup函数里的dx_probe()函数</span></span><br><span class="line">    _dispatch_queue_push_list_slow2(dq, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出<code>_dispatch_queue_push</code>分为两种情况：</p><ul><li>如果队列的链表不为空，将节点添加到链表尾部，即dq-&gt;dq_item_tail=dc。然后队列会按先进先出(FIFO)来处理任务。</li><li>如果队列此时为空，进入到<code>_dispatch_queue_push_slow</code>函数。<ul><li>如果队列是全局队列会进入if分支，原子性的将节点添加到队列开头，并执行<code>_dispatch_queue_wakeup_global</code>唤醒全局队列；</li><li>如果队列是主队列或自定义串行队列if分支判断不成立，执行<code>_dispatch_queue_push_list_slow2</code>函数，它会将节点添加到队列开头并执行<code>_dispatch_wakeup</code>函数唤醒队列。</li></ul></li></ul><p><code>dispatch_async</code>第一阶段的工作主要是封装外部任务并添加到队列的链表中，可以用下图来表示：</p><img src="/images/GCD/dispatch_queue-3.png" alt="img" style="zoom:80%;" /><p>接着来看队列唤醒的逻辑，主要分成主队列和全局队列的唤醒和任务执行逻辑：</p><p>1、如果是主队列，会先调用<code>_dispatch_wakeup</code>唤醒队列，然后执行<code>_dispatch_main_queue_wakeup</code>函数来唤醒主线程的Runloop，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_wakeup(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_dispatch_queue_probe判断dq_items_tail是否为空，if分支不成立</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dx_probe</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果dou._do-&gt;do_suspend_cnt==0，返回YES,否则返回NO；</span></span><br><span class="line">    <span class="comment">//同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="number">0</span>,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_LOCK, release)) &#123;</span><br><span class="line">            <span class="comment">//因为主线程do_suspend_cnt非0，所以主线程if分支判断成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">        <span class="keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">            <span class="comment">//主队列的任务执行和Runloop关联，唤醒主队列</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_main_queue_wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到目标队列中，重新走_dispatch_queue_push方法</span></span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> tq = dou._do-&gt;do_targetq;</span><br><span class="line">    _dispatch_queue_push(tq, dou._do);</span><br><span class="line">    <span class="keyword">return</span> tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒主线程Runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_main_queue_wakeup(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">    <span class="keyword">if</span> (!dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只初始化一次mach_port_t</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, dq,</span><br><span class="line">            _dispatch_runloop_queue_port_init);</span><br><span class="line">    _dispatch_runloop_queue_wakeup_thread(dq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_wakeup_thread(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> mp = (<span class="keyword">mach_port_t</span>)dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">if</span> (!mp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒主线程的runloop</span></span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (kr) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。用Xcode在block处打断点就会看到下图中的调用栈:</p><img src="/images/GCD/dispatch_queue-4.png" alt="img" style="zoom:80%;" /><p>2、如果是全局队列，调用_dispatch_queue_wakeup_global函数，它封装调用了核心函数<code>_dispatch_queue_wakeup_global_slow</code>，调用栈和核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global_slow</span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_wakeup_global_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">unsigned</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="comment">//初始化dispatch_root_queue_context_s</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;pred, <span class="literal">NULL</span>, _dispatch_root_queues_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--i) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测线程池可用大小，如果还有，则将线程池减一</span></span><br><span class="line">    <span class="keyword">uint32_t</span> j, t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!t_count) &#123;</span><br><span class="line">          <span class="comment">//线程池已达到最大使用量</span></span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;pthread pool is full for root queue: &quot;</span></span><br><span class="line">                    <span class="string">&quot;%p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i &gt; t_count ? t_count : i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="built_in">dispatch_atomic_cmpxchgvw2o</span>(qc, dgq_thread_pool_size, t_count,</span><br><span class="line">            t_count - j, &amp;t_count, relaxed));</span><br><span class="line">   <span class="comment">//创建新的线程，入口函数是_dispatch_worker_thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        _dispatch_retain(dq);</span><br><span class="line">        <span class="keyword">while</span> ((r = <span class="built_in">pthread_create</span>(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_temporary_resource_shortage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!attr) &#123;</span><br><span class="line">            r = <span class="built_in">pthread_detach</span>(*pthr);</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_USE_PTHREAD_POOL</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的线程后执行<code>_dispatch_worker_thread</code>函数，代码简化后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _dispatch_worker_thread(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> timeout = (pqc ? <span class="number">5ull</span> : <span class="number">65ull</span>) * NSEC_PER_SEC;</span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//取出一个任务并执行</span></span><br><span class="line">        _dispatch_root_queue_drain(dq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_wait</span>(qc-&gt;dgq_thread_mediator,</span><br><span class="line">            <span class="built_in">dispatch_time</span>(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将线程池加一</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_inc2o</span>(qc, dgq_thread_pool_size, relaxed);</span><br><span class="line">    _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    _dispatch_release(dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从队列取任务的入口是_dispatch_root_queue_drain函数，简化的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">// ensure that high-level memory management techniques do not leak/crash</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_begin_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_begin_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//autoreleasepool的push操作</span></span><br><span class="line">    <span class="keyword">void</span> *pool = _dispatch_autorelease_pool_push();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="comment">//取出队列的头部节点(FIFO)</span></span><br><span class="line">    <span class="keyword">while</span> ((item = <span class="built_in">fastpath</span>(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="comment">//对取出的内容进行处理，核心函数</span></span><br><span class="line">        _dispatch_continuation_pop(item);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_perfmon_end();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">//autoreleasepool的pop操作</span></span><br><span class="line">    _dispatch_autorelease_pool_pop(pool);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_end_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_end_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列唤醒后的工作主要是用线程池(全局队列)或者唤醒Runloop(主队列)的方式从队列的链表中依次取出要执行的任务，流程图如下：</p><img src="/images/GCD/dispatch_queue-5.png" alt="img" style="zoom:80%;" /><p>队列的任务取出之后就是核心的执行逻辑了，也就是<code>_dispatch_continuation_pop</code>函数的逻辑，代码和流程图如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line"></span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断传入的内容是不是队列，如果是的话执行_dispatch_queue_invoke函数，否的话就是block型的</span></span><br><span class="line">    <span class="comment">//任务，直接执行block即可</span></span><br><span class="line">    <span class="comment">//dispatch_barrier_async到自定义并行队列时,dou._do是用户创建的自定义queue，此时会执行</span></span><br><span class="line">    <span class="comment">//_dispatch_queue_invoke，并且用信号量保证barrier的任务不会和其他任务同时执行，后续分析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dx_invoke</span>(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否带有DISPATCH_OBJ_ASYNC_BIT标志位</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">        dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是group</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行dc-&gt;dc_func(dc-&gt;ctxt)</span></span><br><span class="line">    <span class="comment">//本质是调用Block_layout结构体的invoke执行block的实现代码</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//如果是群组执行dispatch_group_leave</span></span><br><span class="line">        <span class="built_in">dispatch_group_leave</span>(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">     _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/GCD/dispatch_queue-6.png" alt="img" style="zoom:80%;" /><p>总结一下：<code>dispatch_async</code>的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。</p><h5 id="5-dispatch-sync"><a href="#5-dispatch-sync" class="headerlink" title="5. dispatch_sync"></a>5. dispatch_sync</h5><p>了解了dispatch_async的逻辑后，再来看下dispatch_sync的实现和流程。<code>dispatch_sync</code>主要封装调用了<code>dispatch_sync_f</code>函数，看一下具体代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">//串行队列执行同步方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">       <span class="comment">//global queue不要求执行顺序，直接执行具体的block</span></span><br><span class="line">        <span class="comment">// the global concurrent queues do not need strict ordering</span></span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并发队列压入同步方法</span></span><br><span class="line">    _dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，后续逻辑主要分为两种情况：</p><p>1、向串行队列提交同步任务，执行dispatch_barrier_sync_f函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>, acquire))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。<code>_dispatch_barrier_sync_f_invoke</code>代码逻辑展开后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="comment">//任务执行核心逻辑，将当前线程的dispatch_queue_key设置为dq，然后执行block，</span></span><br><span class="line">    <span class="comment">//执行完之后再恢复到之前的old_dq</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f2(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_dec2o</span>(dq, dq_running, release) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果队列存在其他任务或者被挂起，调用<code>_dispatch_barrier_sync_f_slow</code>函数，等待该队列的任务执行完之后用信号量通知队列继续执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">        <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dc</span> =</span> &#123;</span><br><span class="line">        .dc_data = dq,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dbss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_BARRIER_BIT |</span><br><span class="line">                DISPATCH_OBJ_SYNC_SLOW_BIT),</span><br><span class="line">        .dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">        .dc_ctxt = &amp;dc,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用信号量等待其他任务执行完成</span></span><br><span class="line">    _dispatch_queue_push(dq, &amp;dbss);</span><br><span class="line">    _dispatch_thread_semaphore_wait(sema); <span class="comment">// acquire</span></span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//收到signal信号，继续执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、向并发队列提交同步任务，执行<code>_dispatch_sync_f2</code>函数。如果队列存在其他任务，或者队列被挂起，或者有正在执行的任务，则调用<code>_dispatch_sync_f_slow</code>函数，使用信号量等待，否则直接调用<code>_dispatch_sync_f_invoke</code>执行任务。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> running = <span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">    <span class="comment">// re-check suspension after barrier check &lt;rdar://problem/15242126&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(running &amp; <span class="number">1</span>) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq))) &#123;</span><br><span class="line">        running = <span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, running == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列存在其他任务|队列被挂起|有正在执行的任务，信号等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">        <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span>*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push_wakeup(dq, &amp;dss, wakeup);</span><br><span class="line">    <span class="comment">//信号等待</span></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//信号唤醒，执行同步任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_sync</code>的逻辑主要是将任务放入队列，并用线程专属信号量做等待，保证每次只会有一个block在执行。流程图如下：</p><img src="/images/GCD/dispatch_queue-7.png" alt="img" style="zoom:80%;" /><h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><p>dispatch_async将任务添加到队列的链表中并唤醒队列，全局队列唤醒时中会从线程池里取出可用线程，如果没有则会新建线程，然后在线程中执行队列取出的任务;主队列会唤醒主线程的Runloop，然后在Runloop循环中通知GCD执行主队列提交的任务。</p><p>dispatch_sync一般都在当前线程执行,如果是主队列的任务还是会切换到主线程执行。它使用线程信号量来实现串行执行的功能。</p><h3 id="3-2-Dispatch-Semaphore"><a href="#3-2-Dispatch-Semaphore" class="headerlink" title="3.2 Dispatch Semaphore"></a>3.2 Dispatch Semaphore</h3><h4 id="3-2-1-API介绍"><a href="#3-2-1-API介绍" class="headerlink" title="3.2.1 API介绍"></a>3.2.1 API介绍</h4><p>Dispatch Semaphore是持有计数的信号，该信号是多线程编程中的计数类型信号。所谓信号，类似过马路时常用的手旗，可以通过时举起手旗，不可以通过时放下手旗。</p><p>在Dispatch Semaphore中，使用计数来实现该功能：<strong>计数为0时等待，计数为1或大于1时，减去1而不等待</strong>。</p><p>信号量的使用比较简单，主要就三个API：<code>create</code>、<code>wait</code>和<code>signal</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使用dispatch_semaphore_create函数生成Dispatch Semaphore</span></span><br><span class="line"><span class="comment"> * 参数value是信号量计数的初始值</span></span><br><span class="line"><span class="comment"> * 函数名称中包含create，必须自己通过dispatch_release函数释放，和dispatch_retain函数持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">intptr_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值大于等于1，或者待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值为0时会等待(直到超时)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout：等待时间 dispatch_time_t类型。DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="comment"> * @return 返回值与dispatch_group_wait函数相同，0表示执行完；超时时返回非0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让信号量值加一，如果有通过dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值增加的线程，会由系统唤醒最先等待的线程执行。</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 </span></span><br><span class="line"><span class="built_in">dispatch_release</span>(semaphore);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-原理"><a href="#3-2-2-原理" class="headerlink" title="3.2.2 原理"></a>3.2.2 原理</h4><h5 id="1-dispatch-semaphore-t"><a href="#1-dispatch-semaphore-t" class="headerlink" title="1.dispatch_semaphore_t"></a>1.dispatch_semaphore_t</h5><p>首先看一下<code>dispatch_semaphore_s</code>的结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> &#123;</span></span><br><span class="line">    DISPATCH_STRUCT_HEADER(semaphore);</span><br><span class="line">    <span class="keyword">semaphore_t</span> dsema_port;    <span class="comment">//等同于mach_port_t信号</span></span><br><span class="line">    <span class="keyword">long</span> dsema_orig;           <span class="comment">//初始化的信号量值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_value; <span class="comment">//当前信号量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_sent_ksignals;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_group_waiters;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_head</span>;</span> <span class="comment">//notify的链表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_tail</span>;</span> <span class="comment">//notify的链表尾部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-semaphore-create"><a href="#2-dispatch-semaphore-create" class="headerlink" title="2. dispatch_semaphore_create"></a>2. dispatch_semaphore_create</h5><p><code>dispatch_semaphore_create</code>用来创建信号量，创建时需要指定value，内部会将value的值存储到dsema_value(当前的value)和dsema_orig(初始value)中，value的值必须大于或等于0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//value值需大于或等于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//申请dispatch_semaphore_t的内存</span></span><br><span class="line">    dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_semaphore_s) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_head) -</span><br><span class="line">            <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_tail));</span><br><span class="line">    <span class="comment">//调用初始化函数</span></span><br><span class="line">    _dispatch_semaphore_init(value, dsema);</span><br><span class="line">    <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化结构体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_semaphore_init(<span class="keyword">long</span> value, <span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line">    dsema-&gt;do_next = (<span class="keyword">dispatch_semaphore_t</span>)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dsema-&gt;do_targetq = dispatch_get_global_queue(</span><br><span class="line">            DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dsema-&gt;dsema_value = value; <span class="comment">//设置信号量的当前value值</span></span><br><span class="line">    dsema-&gt;dsema_orig = value;  <span class="comment">//设置信号量的初始value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着来看Dispatch Semaphore很容易忽略也是最容易造成App崩溃的地方，即信号量的释放。</strong></p><p>创建Semaphore的时候会将do_vtable指向_dispatch_semaphore_vtable，_dispatch_semaphore_vtable的结构定义了信号量销毁的时候会执行<code>_dispatch_semaphore_dispose</code>方法，相关代码实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore的vtable定义</span></span><br><span class="line">DISPATCH_VTABLE_INSTANCE(semaphore,</span><br><span class="line">    .do_type = DISPATCH_SEMAPHORE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;semaphore&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_semaphore_dispose,  <span class="comment">//销毁时执行的回调函数</span></span><br><span class="line">    .do_debug = _dispatch_semaphore_debug,      <span class="comment">//debug函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放信号量的函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_semaphore_dispose(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">       <span class="comment">//Warning:信号量还在使用的时候销毁会造成崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Semaphore/group object deallocated while in use&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_port) &#123;</span><br><span class="line">        kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_port);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果销毁时信号量还在使用，那么dsema_value会小于dsema_orig，则会引起崩溃，这是一个特别需要注意的地方。这里模拟一下信号量崩溃的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semephore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">dispatch_semaphore_wait(semephore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//重新赋值或者将semephore = nil都会造成崩溃,因为此时信号量还在使用中</span></span><br><span class="line">semephore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="3-dispatch-semaphore-wait"><a href="#3-dispatch-semaphore-wait" class="headerlink" title="3. dispatch_semaphore_wait"></a>3. dispatch_semaphore_wait</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>先将信号量的dsema值原子性减一，并将新值赋给value。如果value大于等于0就立即返回，否则调用<code>_dispatch_semaphore_wait_slow</code>函数，等待信号量唤醒或者timeout超时。<code>_dispatch_semaphore_wait_slow</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">        <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    orig = dsema-&gt;dsema_sent_ksignals;</span><br><span class="line">    <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">                orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">                    &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_semaphore_wait_slow</code>函数根据timeout的类型分成了三种情况处理：</p><ol><li>DISPATCH_TIME_NOW：若<code>desma_value</code>小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT，原子性加一是为了抵消<code>dispatch_semaphore_wait</code>函数开始的减一操作。</li><li>DISPATCH_TIME_FOREVER：调用系统的<code>semaphore_wait</code>方法，直到收到<code>signal</code>调用。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = semaphore_wait(dsema-&gt;dsema_port);</span><br></pre></td></tr></table></figure><ol start="3"><li>default：调用内核方法<code>semaphore_timedwait</code>计时等待，直到有信号到来或者超时了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_wait</code>的流程图可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-1.png" alt="img" style="zoom:80%;" /><h5 id="4-dispatch-semaphore-signal"><a href="#4-dispatch-semaphore-signal" class="headerlink" title="4. dispatch_semaphore_signal"></a>4. dispatch_semaphore_signal</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">       <span class="comment">//Warning：value值有误会造成崩溃，详见下篇dispatch_group的分析</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将dsema_value调用原子方法加1，如果大于零就立即返回0，否则进入<code>_dispatch_semaphore_signal_slow</code>方法，该函数会调用内核的<code>semaphore_signal</code>函数唤醒在<code>dispatch_semaphore_wait</code>中等待的线程。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _dispatch_semaphore_signal_slow(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    _dispatch_retain(dsema);</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals, relaxed);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"></span><br><span class="line">    _dispatch_release(dsema);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_semaphore_signal</code>的流程比较简单，可以用下图表示：</p><img src="/images/GCD/dispatch-semaphore-2.png" alt="img" style="zoom:80%;" /><h5 id="5-总结篇"><a href="#5-总结篇" class="headerlink" title="5. 总结篇"></a>5. 总结篇</h5><p>Dispatch Semaphore信号量主要是<code>dispatch_semaphore_wait</code>和<code>dispatch_semaphore_signal</code>函数，<code>wait</code>会将信号量值减一，如果大于等于0就立即返回，否则等待信号量唤醒或者超时；<code>signal</code>会将信号量值加一，如果value大于0立即返回，否则唤醒某个等待中的线程。</p><p>需要注意的是信号量在销毁或重新创建的时候如果还在使用则会引起崩溃，详见上面的分析。</p><h4 id="3-2-3-应用"><a href="#3-2-3-应用" class="headerlink" title="3.2.3 应用"></a>3.2.3 应用</h4><p>1、信号量常用于对资源进行加锁操作，防止多线程访问修改数据出现结果不一致甚至崩溃的问题，代码示例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在init等函数初始化</span></span><br><span class="line">_lock = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="comment">//修改Array或字典等数据的信息</span></span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(_lock);</span><br></pre></td></tr></table></figure><p>2、信号量也可用于链式请求，比如用来限制请求频次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式请求，限制网络请求串行执行，第一个请求成功后再开始第二个请求</span></span><br><span class="line">- (<span class="keyword">void</span>)chainRequestCurrentConfig &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSArray *<span class="built_in">list</span> = @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        [<span class="built_in">list</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            [self fetchConfigurationWithCompletion:^(NSDictionary *dict) &#123;</span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fetchConfigurationWithCompletion:(<span class="keyword">void</span>(^)(NSDictionary *dict))completion &#123;</span><br><span class="line">    <span class="comment">//AFNetworking或其他网络请求库</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//模拟网络请求</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        !completion ? nil : completion(nil);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-Dispatch-Group"><a href="#3-3-Dispatch-Group" class="headerlink" title="3.3 Dispatch Group"></a>3.3 Dispatch Group</h3><p>dispatch_group可以将GCD的任务合并到一个组里来管理。可以指定当追加到Dispatch Queue中的多个处理全部结束时，执行某种操作。</p><p>无论是串行还是并行队列，Dispatch Group都可监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可将结束的处理追加到Dispatch Queue中。</p><h4 id="3-3-1-dispatch-group-create"><a href="#3-3-1-dispatch-group-create" class="headerlink" title="3.3.1 dispatch_group_create"></a>3.3.1 dispatch_group_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建与block相关联的新group。 因为函数名中含有create，所以在使用结束后需要过&quot;dispatch_release&quot;函数释放。</span></span><br><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>Dispatch Group的本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_group_t</span> <span class="title">dispatch_group_create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_alloc(</span><br><span class="line">            DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">    <span class="comment">//使用LONG_MAX初始化信号量结构体</span></span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当value等于LONG_MAX时表示所有任务已完成。</strong></p><h4 id="3-3-2-dispatch-group-enter"><a href="#3-3-2-dispatch-group-enter" class="headerlink" title="3.3.2 dispatch_group_enter"></a>3.3.2 dispatch_group_enter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示一个block已进入group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_enter</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值减一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Too many nested calls to dispatch_group_enter()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-dispatch-group-leave"><a href="#3-3-3-dispatch-group-leave" class="headerlink" title="3.3.3 dispatch_group_leave"></a>3.3.3 dispatch_group_leave</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示group中的某个block已完成</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure><p><code>dispatch_group_leave</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值加一。源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MAX)) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当value等于LONG_MAX时表示所有任务已完成，调用<code>_dispatch_group_wake</code>唤醒group，因此<code>dispatch_group_leave</code>与<code>dispatch_group_enter</code>需成对出现。</p><ul><li><p>当调用了<code>dispatch_group_enter</code>而没有调用<code>dispatch_group_leave</code>时，会造成value值不等于LONG_MAX而不会走到唤醒逻辑，<code>dispatch_group_notify</code>函数的block无法执行或者<code>dispatch_group_wait</code>收不到<code>semaphore_signal</code>信号而卡住线程。</p></li><li><p>当<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多调用了一次时，dispatch_semaphore_t的value会等于LONGMAX+1（2147483647+1），即long的负数最小值 LONG_MIN(–2147483648)。因为此时value小于0，所以会出现”Unbalanced call to dispatch_group_leave()”的崩溃，这是一个特别需要注意的地方。</p></li></ul><h4 id="3-3-4-dispatch-group-async"><a href="#3-3-4-dispatch-group-async" class="headerlink" title="3.3.4 dispatch_group_async"></a>3.3.4 dispatch_group_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将block提交到调度队列，并将block与给定的调度group关联。相比dispatch_async函数不同的是通过第一个参数，指定Block属于指定的Dispatch Group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//封装调用dispatch_group_async_f函数</span></span><br><span class="line">    dispatch_group_async_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    _dispatch_retain(dg);</span><br><span class="line">    <span class="comment">//先调用dispatch_group_enter操作</span></span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">//DISPATCH_OBJ_GROUP_BIT会在_dispatch_continuation_pop方法中用来判断是否为group，如果为group会执行dispatch_group_leave</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width != <span class="number">1</span> &amp;&amp; dq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_async</code> 的原理和 <code>dispatch_async</code> 比较类似，区别点在于group操作会带上DISPATCH_OBJ_GROUP_BIT标志位。添加group任务时会先执行 <code>dispatch_group_enter</code> ，然后在任务执行时会对带有该标记的执行 <code>dispatch_group_leave</code> 操作。</p><p><code>dispatch_group_async_f </code>与 <code>dispatch_async_f</code>代码类似，主要执行了以下操作：</p><ol><li><p>调用dispatch_group_enter</p></li><li><p>将block和queue等信息记录到dispatch_continuation_t中，并将它加入到group的链表中。</p></li><li><p>_dispatch_continuation_pop执行时会判断任务是否为group，是的话执行完任务再调用dispatch_group_leave以达到信号量value的平衡。</p></li></ol><p><code>_dispatch_continuation_pop</code>简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断是否为队列，是的话执行队列的invoke函数</span></span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx_invoke(dou._do);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行具体任务</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//这是group操作，执行leave操作对应最初的enter</span></span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-dispatch-group-wait"><a href="#3-3-5-dispatch-group-wait" class="headerlink" title="3.3.5 dispatch_group_wait"></a>3.3.5 dispatch_group_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 同步地等待，直到与一个group相关联的所有block都完成，或者直到指定的超时已经过去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout 指定等待时间 dispatch_time_t类型的值 (DISPATCH_TIME_FOREVER 一直)</span></span><br><span class="line"><span class="comment"> * @returrn  如果返回值不为0，表示经过等待，任务还在执行中; 如果为0，全部执行结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">intptr_t</span> </span><br><span class="line">dispatch_group_wait(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_time_t</span> timeout);</span><br></pre></td></tr></table></figure><p>源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前value的值为初始值，表示任务都已经完成，直接返回0，如果timeout为0的话返回超时。其余情况会调用_dispatch_group_wait_slow方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_group_waiters, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_group_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_group_waiters, orig,</span><br><span class="line">                    orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到跟dispatch_semaphore的<code>_dispatch_semaphore_wait_slow</code>方法很类似，不同点在于等待完之后调用的again函数会调用<code>_dispatch_group_wake</code>唤醒当前group。</p><h4 id="3-3-6-dispatch-group-notify"><a href="#3-3-6-dispatch-group-notify" class="headerlink" title="3.3.6 dispatch_group_notify"></a>3.3.6 dispatch_group_notify</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @abstract 当与一个group相关联的所有block都完成时，将一个block提交到队列中。不管指定什么样的Dispatch Queue，在追加指定的Block时，之前与Dispatch Group相关联的block都已执行结束。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param queue/block 在追加到该Dispatch Group中的全部处理执行结束时，将第三个参数的Block追加到第二个参数的Dispatch Queue中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_notify(<span class="keyword">dispatch_group_t</span> group,</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span><br><span class="line"><span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装调用dispatch_group_notify_f函数</span></span><br><span class="line">    dispatch_group_notify_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="comment">//封装结构体</span></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> prev, dsn = _dispatch_continuation_alloc();</span><br><span class="line">    dsn-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dc_func = func;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="comment">//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span></span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;do_next = dsn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        dispatch_atomic_store2o(dsema, dsema_notify_head, dsn, seq_cst);</span><br><span class="line">        dispatch_atomic_barrier(seq_cst); <span class="comment">// &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_load2o(dsema, dsema_value, seq_cst) == LONG_MAX) &#123;</span><br><span class="line">            _dispatch_group_wake(dsema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_group_notify的具体实现在dispatch_group_notify_f函数里，逻辑就是将block和queue封装到dispatch_continuation_t里，并将它加到链表的尾部，如果链表为空同时还会设置链表的头部节点。如果dsema_value的值等于初始值，则调用_dispatch_group_wake执行唤醒逻辑。</p><h4 id="3-3-7-dispatch-group-wake-内部API"><a href="#3-3-7-dispatch-group-wake-内部API" class="headerlink" title="3.3.7 dispatch_group_wake(内部API)"></a>3.3.7 dispatch_group_wake(内部API)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>, dc;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line">   <span class="comment">//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span></span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span></span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = (<span class="keyword">long</span>)dispatch_atomic_xchg2o(dsema, dsema_group_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// wake group waiters</span></span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">// async group notify blocks</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = fastpath(head-&gt;do_next);</span><br><span class="line">            <span class="keyword">if</span> (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!(next = fastpath(head-&gt;do_next))) &#123;</span><br><span class="line">                    dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            dc = _dispatch_continuation_free_cacheonly(head);</span><br><span class="line">            <span class="comment">//执行dispatch_group_notify的block，见dispatch_queue的分析</span></span><br><span class="line">            dispatch_async_f(dsn_queue, head-&gt;dc_ctxt, head-&gt;dc_func);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(dc)) &#123;</span><br><span class="line">                _dispatch_continuation_free_to_cache_limit(dc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        _dispatch_release(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_group_wake</code>首先会循环调用<code>semaphore_signal</code>唤醒等待group的信号量，使<code>dispatch_group_wait</code>函数中等待的线程得以唤醒；然后依次获取链表中的元素并调用<code>dispatch_async_f</code>异步执行<code>dispatch_group_notify</code>函数中注册的回调，使得notify中的block得以执行。</p><h4 id="3-3-8-dispatch-release"><a href="#3-3-8-dispatch-release" class="headerlink" title="3.3.8 dispatch_release"></a>3.3.8 dispatch_release</h4><p>与追加 Block 到 Dispatch Queue 时同样，Block 通过 dispatch_retain 函数持有 Dispatch Group，从而使得该 Block 属于 Dispatch Group，这样如果 Block 执行结束，该 Block 就通过 dispatch_release 函数释放持有的Dispatch Group。</p><p>一旦Dispatch Group使用结束，不用考虑属于该Dispatch Group的Block，立即通过dispatch_release函数释放即可。</p><h4 id="3-3-9-原理小结"><a href="#3-3-9-原理小结" class="headerlink" title="3.3.9 原理小结"></a>3.3.9 原理小结</h4><p>dispatch_group本质是个初始值为LONG_MAX的信号量，等待group中的任务完成其实是等待value恢复初始值。<br> <code>dispatch_group_enter </code> 和 <code>dispatch_group_leave</code> 必须成对出现：</p><ul><li>如果前者比后者多一次，则wait函数等待的线程不会被唤醒和注册notify的回调block不会执行；</li><li>如果后者比前者多一次，则会引起崩溃。</li></ul><h3 id="3-4-dispatch-barrier-async"><a href="#3-4-dispatch-barrier-async" class="headerlink" title="3.4 dispatch_barrier_async"></a>3.4 dispatch_barrier_async</h3><h4 id="3-4-1-使用"><a href="#3-4-1-使用" class="headerlink" title="3.4.1 使用"></a>3.4.1 使用</h4><p>变无序为有序。</p><p>当多线程并发读写同一个资源时，为了保证资源读写的正确性，可以用Barrier Block解决该问题。<br>Dispatch Barrier会确保队列中先于Barrier Block提交的任务都完成后再执行它，并且执行时队列不会同步执行其它任务，等Barrier Block执行完成后再开始执行其他任务。代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建自定义并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.gcdTest.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;  <span class="comment">//第一步：执行dispatch_barrier_async之前的任务</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_barrier_async</span>(queue, ^&#123;  <span class="comment">//第二步：执行dispatch_barrier_async函数添加的任务</span></span><br><span class="line">    <span class="comment">//barrier block,可用于写操作</span></span><br><span class="line">    <span class="comment">//确保资源更新过程中不会有其他线程读取</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work2&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 第三步：队列恢复为一般的动作，追加到Concurrent Dispatch Queue的处理又开始并行执行</span></span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里有个需要注意也是官方文档上提到的一点，如果我们调用dispatch_barrier_async时将Barrier blocks提交到一个global queue，barrier blocks执行效果与dispatch_async()一致；</p><p><strong>只有将 Barrier blocks 提交到使用 DISPATCH_QUEUE_CONCURRENT 属性创建的并行queue时它才会表现的如同预期。</strong></p><h4 id="3-4-2-原理"><a href="#3-4-2-原理" class="headerlink" title="3.4.2 原理"></a>3.4.2 原理</h4><p><code>dispatch_barrier_async</code>是开发中解决多线程读写同一个资源比较好的方案，接下来看一下它的实现。<br>该函数封装调用了<code>dispatch_barrier_async_f</code>，它和dispatch_async_f类似，不同点在于vtable多了DISPATCH_OBJ_BARRIER_BIT标志位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置do_vtable的标志位，从队列中取任务时会用到</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_barrier_async</code>如果传入的是global queue，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，故执行效果同<code>dispatch_async</code>一致，验证了使用篇中的备注内容；<br><code>dispatch_barrier_async</code>传的queue为自定义队列时，<code>_dispatch_continuation_pop</code>参数是自定义的queue，然后在<code>_dispatch_continuation_pop</code>中执行自定义队列的dx_invoke函数，即<code>dispatch_queue_invoke</code>。它的调用栈是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_invoke</span><br><span class="line">└──_dispatch_queue_class_invoke</span><br><span class="line">    └──dispatch_queue_invoke2</span><br><span class="line">        └──_dispatch_queue_drain</span><br></pre></td></tr></table></figure><p>重点看一下_dispatch_queue_drain函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_dispatch_thread_semaphore_t</span> _dispatch_queue_drain(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq, orig_tq, old_dq;</span><br><span class="line">    old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = <span class="number">0</span>;</span><br><span class="line">    orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        dc = _dispatch_queue_head(dq);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &#123;</span><br><span class="line">               <span class="comment">//barrier block执行时修改了do_suspend_cnt导致此时为YES</span></span><br><span class="line">               <span class="comment">//保证barrier block执行时其他block不会同时执行</span></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq-&gt;dq_running &gt; dq-&gt;dq_width) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> redirect = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dc) &amp;&amp;</span><br><span class="line">                        (<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dq-&gt;dq_running &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    redirect = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//barrier block之前的block已经执行完，开始执行barrier block</span></span><br><span class="line">            <span class="keyword">if</span> ((sema = _dispatch_barrier_sync_f_pop(dq, dc, <span class="literal">true</span>))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_continuation_pop(dc);</span><br><span class="line">            _dispatch_perfmon_workitem_inc();</span><br><span class="line">        &#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">    <span class="keyword">return</span> sema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在while循环中依次取出任务并调用<code>_dispatch_continuation_redirect</code>函数，使得block并发执行。当遇到DISPATCH_OBJ_BARRIER_BIT标记时，会修改do_suspend_cnt标志以保证后续while循环时直接goto out。barrier block的任务执行完之后<code>_dispatch_queue_class_invoke</code>会将do_suspend_cnt重置回去，所以barrier block之后的任务会继续执行。</p><p><code>dispatch_barrier_async</code>的流程见下图：</p><img src="/images/GCD/dispatch_queue-8.png" alt="img" style="zoom:80%;" /><h3 id="3-5-dispatch-apply"><a href="#3-5-dispatch-apply" class="headerlink" title="3.5 dispatch_apply"></a>3.5 dispatch_apply</h3><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数 <strong>按指定的次数</strong> 将指定的Block追加到指定的队列中，并等待全部处理执行结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：重复次数</span></span><br><span class="line"><span class="comment"> * 参数2：执行队列</span></span><br><span class="line"><span class="comment"> * 参数3：任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_apply</span>(<span class="number">10</span>, queue, ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(@<span class="string">&quot;%zu&quot;</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog（@<span class="string">&quot;done&quot;</span>）;</span><br></pre></td></tr></table></figure><ul><li><p>Global Dispatch Queue中执行，所以各个处理的执行时间不定，但是输出结果的最后必定是done，这是因为dispatch_apply函数会等待全部处理执行结束。</p></li><li><p>dispatch_apply和dispatch_sync函数一样，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Global Dispatch Queue中非同步执行</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Global Dispatch Queue,等待dispatch_apply函数中全部处理执行结束</span></span><br><span class="line">    dispatch_apply([array count], queue, ^(size_t index)&#123;   </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//并列处理包含在NSArray对象的全部对象  index为0-10</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu ：%@&quot;</span>,index,[array objectAtIndex:index]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//dispatch_apply函数中的处理全部执行结束</span></span><br><span class="line">   <span class="comment">//在Main Dispatch Queue中非同步执行</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),^&#123;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//在Main Dispatch Queue中执行处理</span></span><br><span class="line">     <span class="built_in">NSLog</span>（<span class="string">@&quot;done&quot;</span>）;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-6-dispatch-suspend-dispatch-resume"><a href="#3-6-dispatch-suspend-dispatch-resume" class="headerlink" title="3.6 dispatch_suspend/dispatch_resume"></a>3.6 dispatch_suspend/dispatch_resume</h3><p>队列的挂起与恢复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_suspend函数挂起指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_suspend</span>(queue)</span><br><span class="line"><span class="comment">//dispatch_suspend函数恢复指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(queue)</span><br></pre></td></tr></table></figure><p>函数<strong>对已经执行的处理没有影响</strong>。</p><ul><li>挂起后，追加到Dispatch Queue中但尚未执行的处理，在此之后停止执行</li><li>恢复后使得这些处理能继续执行</li></ul><h3 id="3-7-dispatch-once"><a href="#3-7-dispatch-once" class="headerlink" title="3.7 dispatch_once"></a>3.7 dispatch_once</h3><p>dispatch_once函数时保证在应用程序执行中只执行一次指定处理的API，即使同时多线程调用也是线程安全的。常用于创建单例、swizzeld method等功能。</p><h4 id="3-7-1-API介绍"><a href="#3-7-1-API介绍" class="headerlink" title="3.7.1 API介绍"></a>3.7.1 API介绍</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//创建单例、method swizzled或其他任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-原理"><a href="#3-7-2-原理" class="headerlink" title="3.7.2 原理"></a>3.7.2 原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用dispatch_once_f来处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatch_once</code>封装调用了<code>dispatch_once_f</code>函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">        ((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure><p>接着看一下具体的实现函数<code>dispatch_once_f</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> * <span class="title">volatile</span> *<span class="title">vval</span> =</span></span><br><span class="line">            (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> *<span class="title">tail</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchg</span>(vval, <span class="literal">NULL</span>, &amp;dow, acquire)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_atomic_maximally_synchronizing_barrier</span>();</span><br><span class="line">        <span class="comment">// above assumed to contain release barrier</span></span><br><span class="line">        tmp = <span class="built_in">dispatch_atomic_xchg</span>(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                <span class="built_in">dispatch_hardware_pause</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        tmp = *vval;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchgvw</span>(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可知<code>dispatch_once</code>的流程图大致如下：</p><img src="/images/GCD/dispatch_once.png" alt="img" style="zoom:80%;" /><p>首先看一下<code>dispatch_once</code>中用的的原子性操作<code>dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)</code>，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。</p><p>接着结合上面的流程图来看下<code>dispatch_once</code>的代码逻辑：</p><p>首次调用<code>dispatch_once</code>时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用<code>_dispatch_client_callout</code>执行block，然后在block执行完成之后将vval的值更新成<code>DISPATCH_ONCE_DONE</code>表示任务已完成。最后遍历链表的节点并调用<code>_dispatch_thread_semaphore_signal</code>来唤醒等待中的信号量；</p><p>当其他线程同时也调用<code>dispatch_once</code>时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用<code>_dispatch_thread_semaphore_wait</code>阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。</p><h4 id="3-7-3-总结"><a href="#3-7-3-总结" class="headerlink" title="3.7.3 总结"></a>3.7.3 总结</h4><p><code>dispatch_once</code>用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p><p><code>dispatch_once</code>常被用于创建单例、swizzeld method等功能。</p><h3 id="3-8-Dispatch-I-O与Dispatch-Data对象"><a href="#3-8-Dispatch-I-O与Dispatch-Data对象" class="headerlink" title="3.8 Dispatch I/O与Dispatch Data对象"></a>3.8 Dispatch I/O与Dispatch Data对象</h3><p>通过 Dispatch I/O 读写文件，使用 Global Dispatch Queue 将一个文件按大小 read/write。提升读取、写入速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">pipe_q = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;PipeQ&quot;</span>,<span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Dispatch I/O对象</span></span><br><span class="line">pipe_channel = <span class="built_in">dispatch_io_create</span>(DISPATCH_IO_STREAM,fd,pipe_q,^(<span class="keyword">int</span> err)&#123;</span><br><span class="line">   <span class="built_in">close</span>(fd);   <span class="comment">//发生错误时执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*out_fd = fdpair[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最大字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_high_water</span>(pipe_channel, SIZE_MIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最小字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_low_water</span>(pipe_channel,SIZE_MAX);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始异步读取</span></span><br><span class="line"><span class="built_in">dispatch_io_read</span>(pipe_channel,<span class="number">0</span>,SIZE_MAX,pipe_q, ^(<span class="keyword">bool</span> done,<span class="keyword">dispatch_data_t</span> pipe data,<span class="keyword">int</span> err)&#123;</span><br><span class="line"><span class="comment">//每当各个分割的文件快读取结束时，将含有文件块数据的Dispatch Data传递给dispatch_io_read函数指定的读取结束时回调用的Block。回调用的Block分析传递过来的Dispatch Data并进行结合处理</span></span><br><span class="line">   <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">size_t</span> len = <span class="built_in">dispatch_data_get_size</span>(pipe data);</span><br><span class="line">       <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="keyword">char</span> *encoded;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">dispatch_data_t</span> md = <span class="built_in">dispatch_data_create_map</span>(pipe data,(<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes,&amp;len);</span><br><span class="line">          <span class="built_in">asl_set</span>((aslmsg)merged_msg,ASL_KEY_AUX_DATA,encoded);</span><br><span class="line">          <span class="built_in">free</span>(encoded);</span><br><span class="line">          _asl_send_message(<span class="literal">NULL</span>,merged_msg,<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">          <span class="built_in">asl_msg_release</span>(merged_msg);</span><br><span class="line">          <span class="built_in">dispatch_release</span>(md);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(done)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">dispatch_semaphore_signal</span>(sem);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_channel);</span><br><span class="line">         <span class="built_in">dispatch_release</span>(pipe_q);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-9-dispatch-source"><a href="#3-9-dispatch-source" class="headerlink" title="3.9 dispatch_source"></a>3.9 dispatch_source</h3><p>Dispatch Source是BSD系统内核惯有功能kqueue的包装，kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。它的CPU负荷非常小，尽量不占用资源。当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p><h4 id="3-9-1-使用"><a href="#3-9-1-使用" class="headerlink" title="3.9.1 使用"></a>3.9.1 使用</h4><p>dispatch_source最常见的用法就是用来实现定时器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_source_t</span> source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>), <span class="number">3</span> * NSEC_PER_SEC, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">//定时器触发时执行</span></span><br><span class="line">   NSLog(@<span class="string">&quot;timer响应了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动timer</span></span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure><p><code>Dispatch Source</code>定时器的代码看似很简单，但其实是GCD中坑最多的API了，如果处理不好很容易引起Crash。关于<code>Dispatch Source</code>定时器需要注意的知识点请参考文章最后的总结篇。</p><h4 id="3-9-2-原理"><a href="#3-9-2-原理" class="headerlink" title="3.9.2 原理"></a>3.9.2 原理</h4><h5 id="1-dispatch-source-create"><a href="#1-dispatch-source-create" class="headerlink" title="1. dispatch_source_create"></a>1. dispatch_source_create</h5><p><code>dispatch_source_create</code>函数用来创建dispatch_source_t对象，简化后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_source_t</span> <span class="title">dispatch_source_create</span><span class="params">(<span class="keyword">dispatch_source_type_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_queue_t</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    ds = _dispatch_alloc(DISPATCH_VTABLE(source),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_source_s));</span><br><span class="line">    <span class="comment">//初始化ds</span></span><br><span class="line">    _dispatch_queue_init((<span class="keyword">dispatch_queue_t</span>)ds);</span><br><span class="line">    ds-&gt;dq_label = <span class="string">&quot;source&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// the reference the manager queue holds</span></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// since source is created suspended</span></span><br><span class="line">    <span class="comment">//默认处于暂状态，需要手动调用resume</span></span><br><span class="line">    ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;</span><br><span class="line">    ds-&gt;do_targetq = &amp;_dispatch_mgr_q;</span><br><span class="line">    <span class="comment">// First item on the queue sets the user-specified target queue</span></span><br><span class="line">    <span class="comment">//设置事件回调的队列</span></span><br><span class="line">    dispatch_set_target_queue(ds, q);</span><br><span class="line">    _dispatch_object_debug(ds, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-dispatch-source-set-timer"><a href="#2-dispatch-source-set-timer" class="headerlink" title="2. dispatch_source_set_timer"></a>2. dispatch_source_set_timer</h5><p>dispatch_source_set_timer实际上调用了_dispatch_source_set_timer，看一下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_source_set_timer(<span class="keyword">dispatch_source_t</span> ds, <span class="keyword">dispatch_time_t</span> start,</span><br><span class="line">        <span class="keyword">uint64_t</span> interval, <span class="keyword">uint64_t</span> leeway, <span class="keyword">bool</span> source_sync) &#123;</span><br><span class="line">    <span class="comment">//首先屏蔽非timer类型的source</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!ds-&gt;ds_is_timer) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">ds_timer</span>(ds-&gt;ds_refs).flags &amp; DISPATCH_TIMER_INTERVAL)) &#123;</span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Attempt to set timer on a non-timer source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建dispatch_set_timer_params结构体绑定source和timer参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span>;</span></span><br><span class="line">    params = _dispatch_source_timer_params(ds, start, interval, leeway);</span><br><span class="line">    _dispatch_source_timer_telemetry(ds, params-&gt;ident, &amp;params-&gt;values);</span><br><span class="line">    <span class="built_in">dispatch_retain</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (source_sync) &#123;</span><br><span class="line">       <span class="comment">//将source当做队列使用，执行dispatch_barrier_async_f压入队列，</span></span><br><span class="line">       <span class="comment">//核心函数为_dispatch_source_set_timer2</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, params,</span><br><span class="line">                _dispatch_source_set_timer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_source_set_timer2(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer</code>实际上是调用了<code>_dispatch_source_set_timer2</code>函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the source queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="comment">//暂停队列，避免修改过程中定时器被触发了。</span></span><br><span class="line">    <span class="built_in">dispatch_suspend</span>(params-&gt;ds);</span><br><span class="line">    <span class="comment">//在_dispatch_mgr_q队列上执行_dispatch_source_set_timer3(params)</span></span><br><span class="line">    <span class="built_in">dispatch_barrier_async_f</span>(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dispatch_source_set_timer2</code>函数的逻辑是在_dispatch_mgr_q队列执行<code>_dispatch_source_set_timer3(params)</code>，接下来的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer3(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the _dispatch_mgr_q</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = params-&gt;ds;</span><br><span class="line">    ds-&gt;ds_ident_hack = params-&gt;ident;</span><br><span class="line">    <span class="built_in">ds_timer</span>(ds-&gt;ds_refs) = params-&gt;values;</span><br><span class="line">    ds-&gt;ds_pending_data = <span class="number">0</span>;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_or2o</span>(ds, ds_atomic_flags, DSF_ARMED, release);</span><br><span class="line">    <span class="comment">//恢复队列，对应着_dispatch_source_set_timer2函数中的dispatch_suspend</span></span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">    <span class="comment">// Must happen after resume to avoid getting disarmed due to suspension</span></span><br><span class="line">    <span class="comment">//根据下一次触发时间将timer进行排序</span></span><br><span class="line">    _dispatch_timers_update(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (params-&gt;values.flags &amp; DISPATCH_TIMER_WALL_CLOCK) &#123;</span><br><span class="line">        _dispatch_mach_host_calendar_change_register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行提交到_dispatch_mgr_q队列的block时，会调用&amp;_dispatch_mgr_q-&gt;do_invoke函数，即&amp;_dispatch_mgr_q的vtable中定义的<code>_dispatch_mgr_thread</code>。接下来会走到<code>_dispatch_mgr_invoke</code>函数。在这个函数里用I/O多路复用功能的select来实现定时器功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="built_in">select</span>(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, <span class="literal">NULL</span>,</span><br><span class="line">            poll ? (struct timeval*)&amp;timeout_immediately : <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>当内层的 <code>_dispatch_mgr_q</code> 队列被唤醒后，还会进一步唤醒外层的队列(当初用户指定的那个)，并在指定队列上执行 timer 触发时的 block。</p><h5 id="3-dispatch-source-set-event-handler"><a href="#3-dispatch-source-set-event-handler" class="headerlink" title="3. dispatch_source_set_event_handler"></a>3. dispatch_source_set_event_handler</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_event_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_event_handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_event_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_handler_is_block &amp;&amp; dr-&gt;ds_handler_ctxt) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_handler_ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置上下文，保存提交的block等信息</span></span><br><span class="line">    dr-&gt;ds_handler_func = context ? _dispatch_Block_invoke(context) : <span class="literal">NULL</span>;</span><br><span class="line">    dr-&gt;ds_handler_ctxt = context;</span><br><span class="line">    ds-&gt;ds_handler_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-dispatch-source-set-cancel-handler"><a href="#4-dispatch-source-set-cancel-handler" class="headerlink" title="4. dispatch_source_set_cancel_handler"></a>4. dispatch_source_set_cancel_handler</h5><p><code>dispatch_source_set_cancel_handler</code>与<code>dispatch_source_set_event_handler</code>功能类似，保存一下取消事件处理的上下文信息。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_cancel_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_cancel_handler2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_cancel_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_cancel_is_block &amp;&amp; dr-&gt;ds_cancel_handler) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_cancel_handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存事件取消的信息</span></span><br><span class="line">    dr-&gt;ds_cancel_handler = context;</span><br><span class="line">    ds-&gt;ds_cancel_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-dispatch-resume-dispatch-suspend"><a href="#5-dispatch-resume-dispatch-suspend" class="headerlink" title="5. dispatch_resume/dispatch_suspend"></a>5. dispatch_resume/dispatch_suspend</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_resume</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_resume, dou);</span><br><span class="line">    <span class="comment">// Global objects cannot be suspended or resumed.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性减二，并返回之前存储的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_cnt = <span class="built_in">dispatch_atomic_sub_orig2o</span>(dou._do,</span><br><span class="line">             do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt &gt; DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt == DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        _dispatch_wakeup(dou._do);</span><br><span class="line">     <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Over-resume of an object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_suspend</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_suspend, dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性加二</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dou._do, do_suspend_cnt,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断队列是否暂停的依据是do_suspend_cnt是否大于等于2,全局队列和主队列默认都是小于2的，即处于启动状态。<br>而dispatch_source_create方法中，do_suspend_cnt初始为DISPATCH_OBJECT_SUSPEND_INTERVAL，即默认处于暂停状态，需要手动调用resume开启。<br>代码定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_LOCK        1u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPENDED(x) \</span></span><br><span class="line">        ((x)-&gt;do_suspend_cnt &gt;= DISPATCH_OBJECT_SUSPEND_INTERVAL)</span><br></pre></td></tr></table></figure><h4 id="3-9-3-总结"><a href="#3-9-3-总结" class="headerlink" title="3.9.3 总结"></a>3.9.3 总结</h4><p>Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用<code>dispatch_resume</code>启动定时器。<code>dispatch_after</code>只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p><p>Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p><ol><li>循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</li><li><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让<code>dispatch_resume</code>代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</li><li>source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</li></ol><h3 id="3-10-dispatch-after-延迟执行"><a href="#3-10-dispatch-after-延迟执行" class="headerlink" title="3.10 dispatch_after(延迟执行)"></a>3.10 dispatch_after(延迟执行)</h3><h4 id="3-10-1-使用"><a href="#3-10-1-使用" class="headerlink" title="3.10.1 使用"></a>3.10.1 使用</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取精确时间点</span></span><br><span class="line"><span class="comment">typedef uint64_t dispatch_time_t;</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_NOW (0ull)</span></span><br><span class="line"><span class="comment">#define DISPATCH_TIME_FOREVER (~0ull)</span></span><br><span class="line"><span class="comment">* 参数1:  开始时间  DISPATCH_TIME_NOW(现在的时间)</span></span><br><span class="line"><span class="comment">* 参数2：多久后  数值和NSEC_PER_SEC的乘积得到单位为毫微秒的数值，ull是C语言的数值字面量，是显示表明类型时使用的字符串（表示‘unsigned long long’） ，NSEC_PER_MSEC表示毫秒单位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW , <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：指定时间用的dispatch_time_t类型的值，dispatch_time_t类型的值使用dispatch_time函数或者dispatch _walltime函数生成</span></span><br><span class="line"><span class="comment"> * 参数2：指定要追加处理的Dispatch Queue</span></span><br><span class="line"><span class="comment"> * 参数3：指定记述要执行处理的Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_after(time , dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;waited at least three seconds &quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue，上述代码与3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 的相同。</li><li>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔 1/60 秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在 3秒+1/60秒 后执行，并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟是，这个时间会更长。</li></ul><p>dispatch_walltime 函数由 POSLX 中使用的 struct timespec 类型的时间得到 dispatch _time_t 类型的值。</p><p>dispatch _time函数通常用于计算相对时间。</p><p>dispatch_walltime函数用于计算绝对时间，需要指定精确时间参数，可作为粗略的闹钟功能使用。</p><h4 id="3-10-2-原理"><a href="#3-10-2-原理" class="headerlink" title="3.10.2 原理"></a>3.10.2 原理</h4><p><code>dispatch_after</code>是基于Dispatch Source的定时器实现的，函数内部直接调用<code>dispatch_after_f</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_after_f</span><span class="params">(<span class="keyword">dispatch_time_t</span> when, <span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> delta, leeway;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds;</span><br><span class="line">    <span class="comment">//屏蔽DISPATCH_TIME_FOREVER类型</span></span><br><span class="line">    <span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(</span><br><span class="line">                <span class="string">&quot;dispatch_after_f() called with &#x27;when&#x27; == infinity&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_async_f</span>(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    leeway = delta / <span class="number">10</span>; <span class="comment">// &lt;rdar://problem/13447496&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (leeway &lt; NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;</span><br><span class="line">    <span class="keyword">if</span> (leeway &gt; <span class="number">60</span> * NSEC_PER_SEC) leeway = <span class="number">60</span> * NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">    <span class="comment">//创建dispatch_source</span></span><br><span class="line">    ds = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = ds;</span><br><span class="line">    <span class="comment">//将dispatch_continuation_t存储到上下文中</span></span><br><span class="line">    <span class="built_in">dispatch_set_context</span>(ds, dc);</span><br><span class="line">    <span class="comment">//设置timer并启动</span></span><br><span class="line">    <span class="built_in">dispatch_source_set_event_handler_f</span>(ds, _dispatch_after_timer_callback);</span><br><span class="line">    <span class="built_in">dispatch_source_set_timer</span>(ds, when, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timer到时之后，会调用<code>_dispatch_after_timer_callback</code>函数，在这里取出上下文里的block并执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_after_timer_callback(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = ctxt, dc1;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = dc-&gt;dc_data;</span><br><span class="line">    dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">//执行任务的block并执行</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="comment">//清理数据</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、GCD的实现补充"><a href="#四、GCD的实现补充" class="headerlink" title="四、GCD的实现补充"></a>四、GCD的实现补充</h2><h3 id="4-1-Dispatch-Quene"><a href="#4-1-Dispatch-Quene" class="headerlink" title="4.1 Dispatch Quene"></a>4.1 Dispatch Quene</h3><h4 id="4-1-1-Dispatch-Quene实现所需"><a href="#4-1-1-Dispatch-Quene实现所需" class="headerlink" title="4.1.1 Dispatch Quene实现所需"></a>4.1.1 Dispatch Quene实现所需</h4><p>GCD的实现会使用下面这些工具，但不仅仅只有这些：</p><ul><li>用于管理追加的Block的C语言实现的FIFO队列；</li><li>Atomic函数中实现的用于排他控制的轻量级信号；</li><li>用于管理线程的C语言实现的一些容器。</li></ul><p><strong>GCD 是在系统级即iOS和OS X的核心XNU内核级上实现，所以开发者无论如何努力编写线程关系代码，<code>性能</code>都不可能胜过XNU内核级所实现的GCD。</strong></p><p>用于实现Dispatch Queue的几个软件组件框架：</p><ul><li>组件libdispatch提供Dispatch Quene技术；</li><li>组件Libc(pthreads)提供pthread_workquene技术；</li><li>组件XNU内核提供workquene技术。</li></ul><h4 id="4-1-2-执行上下文"><a href="#4-1-2-执行上下文" class="headerlink" title="4.1.2  执行上下文"></a>4.1.2  执行上下文</h4><p>Dispatch Quene通过结构体和链表，被实现为FIFO队列。</p><p>Block并不是直接加入FIFO队列，而是先加入 <code>Dispatch Continuation</code> 这一 <code>dispatch_continuation_t类型</code> 结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记忆 Block 所属的 Dispatch Group 和其他一些信息，相当于一般常说的**<code>执行上下文</code>**。</p><p>上一节在讲 <code>Global Dispatch Queue</code> 的时候，我们介绍过8种类型，这8种 Global Dispatch Quene 各使用一个pthread_workquene。GCD初始化时，使用 <code>pthread_workquene_creat_np</code> 函数生成 pthread_workquene。</p><p>pthread_workquene包含在Libc提供的pthreads API 中。其使用bsdthread_register和workq_open系统调用，<strong>在初始化XNU内核的workquene之后获取workquene信息</strong>。</p><p>XNU内核持有4种workquene：</p><ul><li>WORKQUENE_HIGH_PRIOQUENE</li><li>WORKQUENE_Default_PRIOQUENE</li><li>WORKQUENE_Low_PRIOQUENE</li><li>WORKQUENE_BG_PRIOQUENE</li></ul><p>以上4种执行优先级的workqueue，其执行优先级与Global Dispatch Quene的四种执行优先级相同。</p><p><strong>Global Dispatch Queue → Libc pthread_wordqueue → XNU workqueue</strong></p><img src="/images/GCD/gcd-imp-1.jpg" style="zoom:80%"><h4 id="4-1-3-Dispatch-Queue执行Block的过程"><a href="#4-1-3-Dispatch-Queue执行Block的过程" class="headerlink" title="4.1.3  Dispatch Queue执行Block的过程"></a>4.1.3  Dispatch Queue执行Block的过程</h4><ol><li><p>在Global Dispatch Queue 中执行Block时，libdispatch 从Global Dispatch Queue自身的FIFO队列取出<code>Dispatch Continuation</code></p></li><li><p>调用<code>pthread_workqueue_additem_np</code>函数将该Global Dispatch Queue 本身、符合其优先级的workqueue信息以及执行Dispatch Continuation的回调函数等传递给参数。</p></li><li><p>pthread_workqueue_additem_np函数使用<code>workq_kernreturn系统调用</code>，通知workqueue增加应当执行的项目。</p><p>根据该通知，XNU内核基于系统状态判断是否要生成线程。如果是<code>Overcommit优先级</code>的Global Dispatch Queue ，workqueue则始终生成线程(该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用)。</p><p>因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，他的<code>上下文切换(shift context)</code>与普通的线程有很大的不同。这也是我们使用GCD的原因。</p></li><li><p>workqueue的线程 –&gt; 执行pthread_workqueue函数 –&gt; 该函数调用libdispatch的回调函数。在该回调函数中执行加入到Global Dispatch Queue中的下一个Block。</p></li><li><p>Block执行结束后，进行通知Dispatch Group结束、释放Dispatch Continuation等处理，开始准备执行加入到Global Dispatch Queue中的下一个Block</p></li></ol><h3 id="4-2-Dispatch-Source"><a href="#4-2-Dispatch-Source" class="headerlink" title="4.2 Dispatch Source"></a>4.2 Dispatch Source</h3><p>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。它是BSD系内核惯有功能<code>kqueue的包装</code>。</p><p><strong>kqueue是XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。</strong></p><p>Dispatch Source可处理以下事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD   变量增加</span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR    变量OR</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND  MACH端口发送</span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV  MACH端口接收</span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC   检测到与进程相关的事件</span><br><span class="line">DISPATCH_SOURCE_TYPE_READ   可读取文件映像</span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL 接收信号</span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER  定时器</span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE  文件系统有变更</span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE  可写入文件映像</span><br></pre></td></tr></table></figure><p>事件发生时，在指定的Dispatch Queue中可执行事件的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatc_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  基于READ事件作成Dispatch Source</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">dispatch_source_t</span> source = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_READ, sockfd, <span class="number">0</span> , queuq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定发生READ事件时执行的处理 */</span>    </span><br><span class="line"><span class="built_in">dispatch_source_set_event_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">// 处理结束，取消Dispatch Source</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定取消Dispatch Source时的处理 */</span></span><br><span class="line"><span class="built_in">dispatch_source_set_cancel_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">/* 释放Dispatch Source(自身) */</span></span><br><span class="line">    <span class="built_in">dispatch_release</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动Dispatch Source */</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(source);</span><br></pre></td></tr></table></figure><p>与上面代码非常相似的代码，使用在了Core Foundation框架的用于异步网络的<code>API CFSocket</code>中。因为<strong>Foundation框架的异步网络API是通过CFSocket实现</strong>的，所以可享受到仅使用Foundation框架的Dispatch Source(即GCD)带来的好处。</p><p>一旦将任务追加到Dispatch Queue中，就没有办法将任务取消，也没有办法在执行中取消任务。Dispatch Source是可以取消的，而且取消时的处理可以block的形式作为参数配置。<strong>在必须使用kqueue的情况下，推荐大家使用Dispatch Source，比较简单</strong>。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://xiaozhuanlan.com/iOSDevNotes">iOS开发笔记 — 小专栏</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是多线程编程？&quot;&gt;&lt;a href=&quot;#一、什么是多线程编程？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是多线程编程？&quot;&gt;&lt;/a&gt;一、什么是多线程编程？&lt;/h2&gt;&lt;p&gt;先来复习一下&lt;code&gt;操作系统&lt;/code&gt;中线程相关的知识点：&lt;</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="GCD" scheme="https://tenloy.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/06/28/AutoreleasePool.html"/>
    <id>https://tenloy.github.io/2021/06/28/AutoreleasePool.html</id>
    <published>2021-06-28T16:19:21.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> autorelease]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootAutorelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootAutorelease2()</span><br><span class="line">        └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">            └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                └── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="AutoreleasePool" scheme="https://tenloy.github.io/tags/AutoreleasePool/"/>
    
  </entry>
  
  <entry>
    <title>[转] 深入理解RunLoop—ibireme</title>
    <link href="https://tenloy.github.io/2021/06/26/RunLoop-Reposted-From-ibireme.html"/>
    <id>https://tenloy.github.io/2021/06/26/RunLoop-Reposted-From-ibireme.html</id>
    <published>2021-06-26T16:19:21.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p><blockquote><p>本文是结合着底层CFRunLoop的源码，对RunLoop机制进行了深入分析，如果感觉枯燥，难以消化。可以先看一下孙源的一个线下分享《RunLoop》，对RunLoop的整体有个了解。</p></blockquote><h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模型通常被称作 <a href="http://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p><p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p><p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p><ul><li><p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p></li><li><p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/">http://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码来查看。</p></li></ul><p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E7%A0%81%E5%8F%AF%E8%83%BD%E5%92%8C%E7%8E%B0%E6%9C%89">https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有</a> iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。)</p><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份[文档](<a href="http://www.fenestrated.net/~macman/mirrors/Apple">http://www.fenestrated.net/~macman/mirrors/Apple</a> Technotes (As of 2002)/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p><p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="/images/RunLoop/RunLoop_0.png" alt="RunLoop_0" style="zoom:60%;" /></p><p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p><p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p><ul><li><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p></li><li><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p></li></ul><p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p><p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p><p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p><p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure><p>Mode 暴露的管理 mode item 的接口有下面几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure><p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p><p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p><p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p><h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p><img src="/images/RunLoop/RunLoop_1.png" alt="RunLoop_0" style="zoom:65%;" /><p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p><h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="/images/RunLoop/RunLoop_3.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>苹果官方将整个系统大致划分为上述4个层次：</p><ul><li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li><li>应用框架层即开发人员接触到的 Cocoa 等框架。</li><li>核心框架层包括各种核心框架、OpenGL 等内容。</li><li>Darwin是macOS和iOS操作环境的操作系统部分。苹果公司于2000年把Darwin发布给开放源代码社区。<ul><li>既然是OS，那肯定要包括系统内核XNU、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</li><li>XNU是一个混合内核，它采用了来自OSF的OSFMK 7.3(Open Software Foundation Mach Kernel)和FreeBSD的各种要素(包括过程模型，网络堆栈和虚拟文件系统)，还有一个称为I/O Kit的面向对象的设备驱动程序API。</li><li>XNU将宏内核与微内核两者的特性兼收并蓄，以期同时拥有两种内核的优点。<strong>微内核的灵活性</strong>：比如在微内核中提高操作系统模块化程度以及让操作系统更多的部分接受内存保护的消息传递机制。<strong>宏内核的性能</strong>：宏内核在高负荷下表现的高性能。</li></ul></li></ul><p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="/images/RunLoop/RunLoop_4.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p><ul><li><p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p></li><li><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。(BSD是宏内核)</p></li><li><p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p></li></ul><p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p><p>Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure><p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port。</p><p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mach_msg_return_t</span> <span class="title">mach_msg</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_header_t</span> *msg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_option_t</span> option,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> send_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_size_t</span> rcv_size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> rcv_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_msg_timeout_t</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">mach_port_name_t</span> notify)</span></span>;</span><br></pre></td></tr></table></figure><p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：<br><img src="/images/RunLoop/RunLoop_5.png" alt="RunLoop_0" style="zoom:70%;" /></p><p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing)">Trap_(computing)</a>。</p><p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p><p>关于具体的如何利用 mach port 发送信息，可以看看<a href="http://nshipster.com/inter-process-communication/"> NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p><p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p><h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as &#x27;common mode items&#x27; */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，系统默认注册了5个Mode:</p><ol><li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li><li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li></ol><p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p><p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><p>这个函数内部的调用栈大概是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure><ul><li>CFSocket 是最底层的接口，只负责 socket 通信。</li><li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li><li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li><li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li></ul><p>下面主要介绍下 NSURLConnection 的工作过程。</p><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><img src="/images/RunLoop/RunLoop_network.png" alt="RunLoop_0" style="zoom:65%;" /><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><p>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer的基本介绍</title>
    <link href="https://tenloy.github.io/2021/06/24/Protocol-Buffer.html"/>
    <id>https://tenloy.github.io/2021/06/24/Protocol-Buffer.html</id>
    <published>2021-06-24T17:48:19.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式一样，也可用于通信协议，数据存储等。</p><ul><li>Protocol buffers 在序列化数据方面，它是<strong>灵活的</strong>，<strong>高效的</strong>(快)。<ul><li>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</li><li>一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</li></ul></li><li>相比于 XML、JSON 来说，Protocol buffers 更加<strong>小巧</strong>，更加<strong>简单</strong>。<ul><li>XML和JSON的描述信息太多了，导致消息要大；</li><li>此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</li></ul></li></ul><p><strong>Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式</strong>。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><h3 id="1-1-优势"><a href="#1-1-优势" class="headerlink" title="1.1 优势"></a>1.1 优势</h3><p>JSON 和 XML 可能是目前开发者们用来存储和传输数据的标准方案，而 protocol buffers 与之相比有以下优势：</p><ul><li><strong>快速且小巧</strong>：按照 Google 所描述的，protocol buffers 的体积要小<strong>3-10</strong>倍，速度比XML要快<strong>20-100</strong>倍。可以在这篇<a href="https://damienbod.com/2014/01/09/comparing-protobuf-json-bson-xml-with-net-for-file-streams/">文章</a> ，它的作者是 Damien Bod，文中比较了一些主流文本格式的读写速度。</li><li><strong>类型安全</strong>：Protocol buffers 像 Swift 一样是类型安全的，使用 protocol buffers 时 你需要指定每一个属性的类型。</li><li><strong>自动反序列化</strong>：你不需要再去编写任何的解析代码，只需要更新 <strong>.proto</strong> 文件就行了。 file and regenerate the data access classes.</li><li><strong>分享就是关心</strong>：因为支持多种语言，因此可以在不同的平台中共享数据模型，这意味着跨平台的工作会更轻松。</li></ul><h3 id="1-2-局限性"><a href="#1-2-局限性" class="headerlink" title="1.2 局限性"></a>1.2 局限性</h3><p>Protocol buffers 虽然有着诸多优势，但是它也不是万能的:</p><ul><li><strong>时间成本</strong>：在老项目中去使用 protocol buffers 可能会不太高效，因为需要转换成本。同时，项目成员还需要去学习一种新的语法。</li><li><strong>可读性</strong>：XML 和 JSON 的描述性更好，并且易于阅读。Protocol buffers 的原数据无法阅读(类似txt没有样式，不方便阅读)，并且在没有 <strong>.proto</strong> 文件的情况下没办法解析。</li><li><strong>仅仅是不适合而已</strong>：当你想要使用类似于<a href="http://www.w3schools.com/xml/xml_xslt.asp">XSLT</a>这样的样式表时，XML是最好的选择。所以 protocol buffers 并不总是最佳工具。</li><li><strong>不支持</strong>：编译器可能不支持你正在进行中的项目所使用的语言和平台。</li></ul><h2 id="二、iOS中的单独使用"><a href="#二、iOS中的单独使用" class="headerlink" title="二、iOS中的单独使用"></a>二、iOS中的单独使用</h2><h3 id="2-1-定义-proto文件"><a href="#2-1-定义-proto文件" class="headerlink" title="2.1 定义.proto文件"></a>2.1 定义.proto文件</h3><p>首先要定义一个 Person**.proto** 文件。在这个文件中指定了你的数据结构信息。下面以一个Person模型类为例</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  <span class="comment">// 在第一行声明，我们使用的protobuf语法是proto3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> uid = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">3</span>;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span>;</span><br><span class="line">    PhoneType type = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">repeated</span> PhoneNumber phone = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-转换为源代码文件"><a href="#2-2-转换为源代码文件" class="headerlink" title="2.2 转换为源代码文件"></a>2.2 转换为源代码文件</h3><p>使用 protocol buffers 的编译器，会根据选择的语言创建好一个数据类(Swift 中的 struct)。可以直接在项目中使用这个类/结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protoc *.proto --objc_out=../Class  <span class="comment"># objc_out指定了生成程序的目录，如果是Java，那么是java_out</span></span><br><span class="line"><span class="comment"># 产物是：</span></span><br><span class="line"><span class="comment"># Class/Pro_out/Person.pbobjc.h  Person.pbobjc.m</span></span><br><span class="line"><span class="comment"># Class/Pro_source/Person.proto</span></span><br></pre></td></tr></table></figure><h3 id="2-3-iOS工程中引入Protobuf库"><a href="#2-3-iOS工程中引入Protobuf库" class="headerlink" title="2.3 iOS工程中引入Protobuf库"></a>2.3 iOS工程中引入Protobuf库</h3><ul><li>通过Cocoapods</li><li>通过手动导入</li></ul><h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.pbobjc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">Person *person = [Person new];</span><br><span class="line">person.name = <span class="string">@&quot;weiCL&quot;</span>;</span><br><span class="line">person.uid = <span class="number">20170810</span>;</span><br><span class="line">person.email = <span class="string">@&quot;cl9000@126.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为Data</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [person data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;NSData= %@&quot;</span>, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化为对象</span></span><br><span class="line">Person *person2 = [Person parseFromData:data error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;name:%@ uid:%d email:%@&quot;</span>,person2.name,person2.uid,person2.email);</span><br></pre></td></tr></table></figure><h2 id="三、用在与服务端交互中"><a href="#三、用在与服务端交互中" class="headerlink" title="三、用在与服务端交互中"></a>三、用在与服务端交互中</h2><p>在与服务端交互时，通常使用 JSON 或者 XML 来发送和接收数据，然后根据这些数据生成结构并解析。现在使用 <code>protocol buffers</code> 也类似：</p><ul><li>服务端返回的数据要为pb格式</li><li>移动端使用pb数据的解析配置</li></ul><p>参考链接：<a href="https://juejin.cn/post/6844903622266847246">Protocol Buffers 在 iOS 中的使用</a></p><h2 id="四、编码原理-序列化与反序列化"><a href="#四、编码原理-序列化与反序列化" class="headerlink" title="四、编码原理(序列化与反序列化)"></a>四、编码原理(序列化与反序列化)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可读数据 &#x3D;&#x3D;&#x3D;&#x3D;序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&gt; 二进制</span><br><span class="line">可读数据 &lt;&#x3D;&#x3D;&#x3D;反序列化、字符集编码规则&#x3D;&#x3D;&#x3D;&#x3D; 二进制</span><br></pre></td></tr></table></figure><h3 id="4-1-编码-序列化"><a href="#4-1-编码-序列化" class="headerlink" title="4.1 编码/序列化"></a>4.1 编码/序列化</h3><ul><li><p>Protocol Buffer 序列化采用 Varint、Zigzag 方法，压缩 int 型整数和带符号的整数。对浮点型数字不做压缩（这里可以进一步的压缩，Protocol Buffer 还有提升空间）。</p></li><li><p>对 <code>.proto</code> 文件，会对 option 和 repeated 字段进行检查，若 optional 或 repeated 字段没有被设置字段值，那么该字段在序列化时的数据中是完全不存在的，即不进行序列化（少编码一个字段）。</p></li><li><p>上面这两点做到了压缩数据，使得序列化工作量减少。</p></li><li><p>Protocol Buffer 是 Tag - Value (TLV)的编码方式的实现</p><ul><li><blockquote><p>在通信协议中，TLV（type-length-value或tag-length-value）是一种用于某种协议中可选信息元素的编码方案。TLV 编码的数据流包含记录类型的代码，然后是记录值长度，最后是值本身。</p></blockquote></li><li><p>数据都以 tag - length - value (或者 tag - value)的形式存在二进制数据流中</p></li><li><p>减少了分隔符的使用（比 JSON 和 XML 少了 <code>&#123; &#125; :</code> 这些符号）</p></li><li><p>没有这些分隔符，使得数据存储更加紧凑，也算是再一次减少了数据的体积。</p></li></ul></li><li><p>综上，pb 体积相对较小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。</p></li></ul><h3 id="4-2-反序列化"><a href="#4-2-反序列化" class="headerlink" title="4.2 反序列化"></a>4.2 反序列化</h3><ul><li>反序列化的实现完全是序列化实现/encode的逆过程。反序列化直接读取二进制字节数据流，同样是一些二进制操作。</li><li>反序列化的时候，通常只需要用到 length。tag 值只是用来标识类型的，Properties 的 setEncAndDec() 方法里面已经把每个类型对应的 decode 解码器初始化好了，所以反序列化的时候，tag 值可以直接跳过，从 length 开始处理。</li><li>XML 的解析过程就复杂一些。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</li></ul><h3 id="4-3-性能"><a href="#4-3-性能" class="headerlink" title="4.3 性能"></a>4.3 性能</h3><ul><li><p>如果很少用到整型数字，浮点型数字，全部都是字符串数据，那么 JSON 和 protocol buffers 性能不会差太多。纯前端之间交互的话，选择 JSON 或者 protocol buffers 差别不是很大。</p></li><li><p>与后端交互过程中，用到 protocol buffers 比较多，笔者认为选择 protocol buffers 除了性能强以外，完美兼容 RPC 调用也是一个重要因素。</p></li></ul><h3 id="4-4-其它特性"><a href="#4-4-其它特性" class="headerlink" title="4.4 其它特性"></a>4.4 其它特性</h3><ol><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol><p>参考链接：<a href="https://halfrost.com/protobuf_encode/">高效的数据压缩编码方式 Protobuf — halfrost</a>、<a href="https://halfrost.com/protobuf_decode/">Protobuf的序列化/反序列化</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;Protocol buffers (PB) 是一种语言、平台无关，可扩展的序列化数据的格式。和xml、json等数据交换格式</summary>
      
    
    
    
    <category term="Data" scheme="https://tenloy.github.io/categories/Data/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) 动态规划算法</title>
    <link href="https://tenloy.github.io/2021/06/22/dynamic-programming.html"/>
    <id>https://tenloy.github.io/2021/06/22/dynamic-programming.html</id>
    <published>2021-06-22T14:40:13.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、术语介绍"><a href="#一、术语介绍" class="headerlink" title="一、术语介绍"></a>一、术语介绍</h2><p>先来说几个动态规划问题中的术语。</p><p>动态规划(<code>dynamic programming</code>)是运筹学的一个分支，是求解决策过程(<code>decision process</code>)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(<code>multistep decision process</code>)的优化问题时，提出了著名的最优化原理(<code>principle of optimality</code>)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><p><img src="/images/algorithm/dp-1.jpg" alt="多阶段决策问题的图示"></p><h3 id="1-1-阶段"><a href="#1-1-阶段" class="headerlink" title="1.1 阶段"></a>1.1 阶段</h3><ul><li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同。</li><li>描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用 <code>k</code> 表示。</li><li>此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</li></ul><p><strong>在前面的图中，第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。</strong></p><h3 id="1-2-状态"><a href="#1-2-状态" class="headerlink" title="1.2 状态"></a>1.2 状态</h3><p>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它<strong>既是该阶段某路的起点，同时又是前一阶段某支路的终点。</strong></p><p><strong>前面的例子(图)中，初始状态即A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。</strong></p><p>过程的状态通常可以用一个或一组数来描述，称为<code>状态变量</code>，用<code>x(k)</code>表示。一般，状态是离散的，但有时为了方便也将状态取成连续的。</p><p>而且在每个阶段的状态维数可以不同。状态变量当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为<code>状态集合</code>。</p><h3 id="1-3-无后效性"><a href="#1-3-无后效性" class="headerlink" title="1.3 无后效性"></a>1.3 无后效性</h3><p>我们要求状态具有下面的性质：如果某阶段的状态一旦确定，则在这一阶段以后过程的发展变化仅与此阶段的状态有关，不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。</p><p>换句话说，过程的每一次实现可以用一个状态序列表示。<strong>在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。</strong></p><p>也就是说，<code>未来与过去无关</code>，当前的状态是此前历史（以往决策）的一个完整总结，过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。（简单点说：过去只能通过影响现在，进而影响未来）</p><h3 id="1-4-决策"><a href="#1-4-决策" class="headerlink" title="1.4 决策"></a>1.4 决策</h3><ul><li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为<code>决策</code>。在最优控制中，也称为控制。</li><li><strong>每一个阶段都有若干个决策可供选择。</strong></li><li>在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。</li><li>描述决策的变量称<code>决策变量</code>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。</li></ul><p>决策变量的范围称为<code>允许决策集合</code>。</p><img src="/images/algorithm/dp-3.png" style="zoom:70%"><h3 id="1-5-多阶段决策问题与策略"><a href="#1-5-多阶段决策问题与策略" class="headerlink" title="1.5 多阶段决策问题与策略"></a>1.5 多阶段决策问题与策略</h3><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为<code>多阶段决策问题</code>。</p><ul><li><strong>策略</strong>：由每个阶段的决策组成的一个决策序列称为<strong>策略</strong>。<ul><li>每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取。</li></ul></li><li><strong>允许策略集合</strong>：对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为<strong>允许策略集合</strong>。</li><li><strong>最优策略</strong>：允许策略集合中达到最优效果的策略称为<strong>最优策略</strong>。<ul><li>对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li></ul></li></ul><h3 id="1-6-状态转移方程"><a href="#1-6-状态转移方程" class="headerlink" title="1.6 状态转移方程"></a>1.6 状态转移方程</h3><p>给定k阶段状态变量 <code>x(k)</code> 的值后，如果这一阶段的决策变量一经确定，第 <code>k+1</code> 阶段的状态变量 <code>x(k+1)</code> 也就完全确定，即 <code>x(k+1)</code> 的值随 <code>x(k)</code> 和第 <code>k</code> 阶段的决策 <code>u(k)</code> 的值变化而变化。</p><p>那么可以把这一关系看成 <code>(x(k),u(k))</code> 与 <code>x(k+1)</code> 确定的对应关系，用 <code>x(k+1) = Tk(x(k),u(k))</code> 表示。这是从 <code>k</code> 阶段到 <code>k+1</code> 阶段状态转移方程的状态转移规律，称为状态转移方程。</p><h3 id="1-7-最优化原理-最优子结构性质"><a href="#1-7-最优化原理-最优子结构性质" class="headerlink" title="1.7 最优化原理/最优子结构性质"></a>1.7 最优化原理/最优子结构性质</h3><ul><li>最优性原理：要求问题的<code>最优策略的子策略也是最优</code>。可以通俗地理解为子问题的局部最优将导致整个问题的全局最优，即<code>一个问题的最优解只取决于其子问题的最优解</code>，子问题的非最优解对问题的求解没有影响。</li><li>最优子结构性质：当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。</li></ul><p>一个问题 <code>满足最优化原理</code>也称其 <code>拥有最优子结构性质</code>。</p><p>动态规划引出：</p><p><strong>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决<code>多阶段决策最优化问题</code>的方法为动态规划方法。</strong></p><h2 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h2><blockquote><p>动态规划算法通常用于<code>求解最优性问题</code>：在这类问题中，可能会有许多可行解，每一个解都对应于一个值，我们希望找到具有最优值的解。  </p></blockquote><p><strong>动态规划</strong>(DP：Dynamic Programming)是一种重要的程序设计手段，其基本思想是在对一个<strong>多阶段决策</strong>的问题，按照某一顺序，根据每一步所选决策的不同会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>动态规划</strong>是一种把多阶段过程转化为一系列单阶段问题，逐个求解的方法泛应用于生产调度、工程技术和最优控制等领域。</p><p>动态规划与分治法的异同：</p><ul><li>相同点：都是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>不同点：分治法是将问题划分成相互独立的子问题，因此部分子问题会被重复计算；动态规划方法分解得到的<code>子问题往往不互相独立</code>，而是相互重叠的，从而避免了大量重复计算。</li></ul><p>动态规划的实质是分治思想和解决冗余的结合：</p><ul><li><p>将问题实例分解为更小的、相似的子问题</p></li><li><p>存储子问题的解，在需要时再找出已求得的答案，来避免计算重复的子问题，从而得到多项式时间算法。</p><p>用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的<code>填表格式</code>。</p></li></ul><p>一般来说，只要该问题可以划分成规模更小的子问题，并且原问题的最优解中包含了子问题的最优解(即满足最优化原理)，则可以考虑用动态规划解决。</p><p>动态规划算法的难点在于怎么将问题转化为能够利用动态规划算法来解决。当重复子问题的数目比较小时，动态规划的效果也会很差。</p><h2 id="三、适用情况"><a href="#三、适用情况" class="headerlink" title="三、适用情况"></a>三、适用情况</h2><p>一般具有以下3个特征：</p><ul><li><p>满足最优化原理(或称：问题具有最优子结构的性质。<code>是动态规划的基础</code>)</p><p>怎么分析问题是否满足？反证法</p><p><strong>先假设由问题的最优解导出的子问题的解不是最优的 → 然后证明在这个假设下可构造出比原问题最优解更好的解 → 从而导致矛盾，证明最优化原理</strong></p></li><li><p>无后效性</p></li><li><p>有重叠子问题：递归地分解问题时，产生的子问题并不总是独立的（很多子问题重复），一个子问题在下一阶段中可能被多次使用到。<strong>该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</strong></p><p>动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。<code>其中的关键在于解决冗余</code>，这是动态规划算法的根本目的。动态规划实质上是一种 <code>以空间换时间</code>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p></li></ul><h2 id="四、基本步骤"><a href="#四、基本步骤" class="headerlink" title="四、基本步骤"></a>四、基本步骤</h2><h3 id="4-1-书面版"><a href="#4-1-书面版" class="headerlink" title="4.1 书面版"></a>4.1 书面版</h3><p>1、分析最优解的性质，并刻画其结构特征。(确定满足最优化原理、划分阶段、确定状态)</p><p>2、递归地定义最优解。(确定状态转移方程(递推方程))</p><p>3、以自底向上或自顶向下(备忘录)的方式计算出最优值</p><p>4、根据计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解</p><p>步骤1-3是动态规划算法的基本步骤。在只需求出最优值的情形下，步骤4可以省略，步骤3中记录的信息也较少； 若需要求出问题的一个最优解，则必须执行步骤4，步骤3中记录的信息必须足够多，以便构造最优解。</p><p>【问题描述】：给定两个字符串A[m]、B[n]，求它们的最长公共子序列C。</p><p>1、刻画最优解的结构特征</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果temp=A[m]=B[n]，C=temp+max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...,n<span class="number">-1</span>])；</span><br><span class="line">如果A[m]!=B[n]，则C=maxLen(max_common_len(A[<span class="number">1</span>,...,m],B[<span class="number">1</span>,...,n<span class="number">-1</span>])，max_common_len(A[<span class="number">1</span>,...,m<span class="number">-1</span>],B[<span class="number">1</span>,...n]))。</span><br></pre></td></tr></table></figure><p>2、递归的定义最优解的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设C[i,j]表示两个串A[i]与B[j]的最长公共子序列的长度，则</span><br><span class="line"><span class="keyword">if</span> i=j=<span class="number">0</span>, C[i,j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]==B[j], C[i,j]=<span class="number">1</span>+C[i<span class="number">-1</span>,j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> i,j&gt;<span class="number">0</span> <span class="keyword">and</span> A[i]!=B[j], C[i,j]=max(C[i<span class="number">-1</span>,j],C[i,j<span class="number">-1</span>]).</span><br></pre></td></tr></table></figure><p>3、计算最优解</p><h3 id="4-2-个人理解版本"><a href="#4-2-个人理解版本" class="headerlink" title="4.2 个人理解版本"></a>4.2 个人理解版本</h3><p><strong>第一步：将原问题分解为子问题 — 划分阶段</strong></p><ul><li>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决。</li><li>子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</li><li>按照问题的时间或空间特征，把问题分为若干个子问题。划分时，需要注意<strong>划分后的子问题一定要是有序的或者是可排序的</strong>，否则问题就无法求解。(多阶段决策问题)</li></ul><p><strong>第二步：确定状态 — 确定状态、状态空间</strong></p><ul><li>在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状态”。一个“状态”对应于一个或多个子问题，所谓某个“状态”下的“值”，就是这个“状态”所对应的子问题的解。当然，状态的选择要<code>满足无后效性</code>。</li><li>所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。</li><li><em>比如：求课件中的最大子段和。有n个状态，即状态空间大小为n，每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。因此，用动态规划算法通常只需要多项式时间。</em></li></ul><p><strong>第三步：确定一些初始状态的值</strong></p><ul><li>初始状态，也会被称为边界状态、叶节点状态(对应一个子问题)</li></ul><p><strong>第四步：确定状态转移方程</strong></p><ul><li>定义出什么是状态、在该状态下的值后，就要找出不同的状态之间如何迁移 —— <strong>怎么从本阶段状态(“值”已知)递推到下一阶段的未解状态，直到最终状态</strong>。(递推型)</li><li>状态的迁移可以用递推公式表示，此递推公式也可被称作<strong>状态转移方程</strong>。</li></ul><p><strong>第五步：开始计算</strong></p><ul><li>以 <code>自底向上</code> 或 <code>自顶向下的记忆化方式（备忘录法</code> 计算出最优值，根据计算最优值时得到的信息，构造问题的最优解。</li></ul><img src="/images/algorithm/dp-2.png" style="zoom:70%"><h3 id="4-3-个人总结"><a href="#4-3-个人总结" class="headerlink" title="4.3 个人总结"></a>4.3 个人总结</h3><ul><li>相比动态规划，分治法与贪心法就简单许多。(首先后两者都不用记录前面状态(子问题)的值)</li><li>分治法：先一分为二…然后合二为一… </li><li>贪心法：也算是多阶段决策问题。找出子问题分解思路、确定状态空间、初始状态值。确定状态转移方程这一步有差异，贪心法是自顶向下一层一层分解，遵守贪心选择原则，得出一系列子问题的局部最优解，直到最小子问题，即可组合出原问题的解。</li></ul><h3 id="4-4-备忘录算法"><a href="#4-4-备忘录算法" class="headerlink" title="4.4 备忘录算法"></a>4.4 备忘录算法</h3><p>备忘录方法是动态规划算法的变形，它通过分治思想对原问题进行分解，以<code>存储子问题的解</code>的方式解决冗余计算，并采用自顶向下的递归方式获取问题的最终解。</p><p><strong>备忘录算法与动态规划算法</strong></p><ul><li><p>相同之处：都会对子问题的计算结果进行存储，解决冗余计算</p></li><li><p>不同之处：动态规划算法是<code>自底向上递推</code>求解，而备忘录方法是<code>自顶向下递归</code>求解。</p></li><li><p>当子问题空间中的大量子问题无需求解时，使用备忘录方法较省时。</p></li><li><p>但当无需计算的子问题只有少部分或全部都要计算时，使用动态规划算法，节省递归带来的额外消耗。</p></li></ul><p>比如：求LCS(最长公共子序列)问题中：</p><ul><li>动态规划算法求算，就是自底向上，将所有会出现的子问题都计算并记录下来，而其实有一些子问题在后续的计算中，并不会被用到。</li><li>而备忘录算法求解，就是自顶向下递归，只计算使用到的子问题并记录，</li></ul><p><strong>备忘录算法与直接递归（备忘录方法 = 递归 + 记录表）</strong></p><ul><li>备忘录方法的控制结构与直接递归方法的控制相同(<strong>递归也是分解子问题，自顶向下求解</strong>)，区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免了相同的子问题的重复求解</li><li>备忘录：初始化为每个子问题的记录存入一个特殊的值，表示并未求解。在求解过程中，查看相应记录如果是特殊值，表示未求解，否则只要取出该子问题的解答即可。</li></ul><h2 id="五、程序设计-可只看这部分"><a href="#五、程序设计-可只看这部分" class="headerlink" title="五、程序设计(可只看这部分)"></a>五、程序设计(可只看这部分)</h2><h3 id="5-1-三要素"><a href="#5-1-三要素" class="headerlink" title="5.1 三要素"></a>5.1 三要素</h3><p>动态规划的主要难点在于理论上的设计，也就是上面几个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><ul><li>问题的阶段(子问题划分)</li><li>每个阶段的状态</li><li>从前一个阶段转化到后一个阶段之间的递推关系</li></ul><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为<code>递推可以充分利用前面保存的子问题的解来减少重复计算</code>，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><h3 id="5-2-确定状态转移方程"><a href="#5-2-确定状态转移方程" class="headerlink" title="5.2 确定状态转移方程"></a>5.2 确定状态转移方程</h3><p><img src="/images/algorithm/dp-1.jpg" alt="仍以该图为例"></p><ul><li><strong>阶段</strong>：描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。<ul><li>第一个阶段就是点A到点B，第二个阶段是点B到点C，而第三个阶段是点C到点D。 </li></ul></li><li><strong>状态</strong>：状态通常可以用一个或一组数来描述，称为状态变量，记为x(k)。 <ul><li>初始状态为A，而第一个阶段有两个状态B1和B2，第二个阶段是三个状态C1，C2和C3，而第三个阶段是状态D1和D2。 </li></ul></li><li><strong>决策</strong>：每一个阶段都有若干个决策可供选择，描述决策的变量称决策变量。记为u(k)。</li><li><strong>每个阶段状态的值：</strong>为演变到该状态的前一阶段的状态值F(k) + 决策对应的值。如果发现更优解，覆盖之前的(最优常指耗费最小/路径最短，或是收益最大)。</li></ul><p>以凑零钱问题为例，<strong>如何列出正确的状态转移方程</strong>？(<a href="https://labuladong.gitee.io/algo/1/3/">动态规划详解 — labuladong</a>)</p><ol><li><p><strong>确定</strong> <strong>base case</strong>，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p></li><li><p><strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。</p></li><li><p><strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p></li><li><p><strong>明确 dp 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。</p></li></ol><p>就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。</p><img src="/images/algorithm/dp-4.png" style="zoom:100%"><p>更简单一些的：最长公共子序列问题，dp中没有自变量。</p><img src="/images/algorithm/dp-5.png" style="zoom:100%"><p>更复杂一些的：如投资问题</p><img src="/images/algorithm/dp-6.png" style="zoom:100%"><ul><li>已知：$f_k(x)$为投资项目k x元钱，所得到的收益</li><li>$F_k(x)$：x元钱投给前k个项目最大效益</li><li>$x_k$：投给项目k的钱数</li></ul><h3 id="5-3-最优决策表"><a href="#5-3-最优决策表" class="headerlink" title="5.3 最优决策表"></a>5.3 最优决策表</h3><p>确定了动态规划的这三要素，整个求解过程就可以用一个<code>最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态</code>，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的<code>最优值</code>（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">=</span><span class="variable">max</span><span class="punctuation">&#123;</span><span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="operator">,</span> <span class="variable">f</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">-</span><span class="number">1</span><span class="operator">,</span><span class="variable">m</span><span class="operator">-</span><span class="variable">w</span><span class="punctuation">[</span><span class="variable">n</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="operator">+</span><span class="variable">P</span><span class="punctuation">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">m</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-一般的算法设计模式如下"><a href="#5-4-一般的算法设计模式如下" class="headerlink" title="5.4 一般的算法设计模式如下"></a>5.4 一般的算法设计模式如下</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、经典运用"><a href="#六、经典运用" class="headerlink" title="六、经典运用"></a>六、经典运用</h2><ul><li>矩阵连乘</li><li>走金字塔</li><li>最长公共子序列(LCS)</li><li>最长递增子序列(LIS)</li><li>凸多边形最优三角剖分</li><li>背包问题</li><li>双调欧几里得旅行商问题</li><li>求全路径最短路径的Floyd算法</li><li>…</li></ul><h3 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0-1背包问题"></a>6.1 0-1背包问题</h3><p>【问题描述】<br>给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p>对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1.我们设物品i的装入状态为xi,xi∈ (0,1)，此问题称为0-11背包问题。</p><p>【数据】<br>物品个数n=5，物品重量$w[n] = {0,2,2,6,5,4}$，物品价值$V[n] = {0,6,3,5,4,6}$（第0位，置为0，不参与计算，只是便于与后面的下标进行统一，无特别用处，也可不这么处理）。总重量$c=10$。背包的最大容量为10，那么在设置数组m大小时，可以设行列值为6和11，那么，对于$m(i,j)$就表示可选物品为$i…n$背包容量为j(总重量)时背包中所放物品的最大价值。</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ol><li><p>看了好多，<a href="https://blog.csdn.net/baidu_28312631/article/details/47418773">这一篇博客</a>尤为通俗易懂</p></li><li><p>如果要看备忘录算法、动态规划算法之间的差异，可以看<a href="https://blog.csdn.net/u013309870/article/details/75193592">这篇博客</a>，并做一下<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">求LCS</a>这道题，搜一下它的两种解法</p></li><li><p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin">动态规划 — 百度百科</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、术语介绍&quot;&gt;&lt;a href=&quot;#一、术语介绍&quot; class=&quot;headerlink&quot; title=&quot;一、术语介绍&quot;&gt;&lt;/a&gt;一、术语介绍&lt;/h2&gt;&lt;p&gt;先来说几个动态规划问题中的术语。&lt;/p&gt;
&lt;p&gt;动态规划(&lt;code&gt;dynamic programming</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://tenloy.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://tenloy.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>前端各种模块化方案总结</title>
    <link href="https://tenloy.github.io/2021/06/18/Web-Module.html"/>
    <id>https://tenloy.github.io/2021/06/18/Web-Module.html</id>
    <published>2021-06-18T11:09:27.000Z</published>
    <updated>2021-09-17T10:59:07.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>那么，到底什么是模块化开发呢？</p><blockquote><p>模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。</p></blockquote><ul><li>现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋</li><li>代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统</li></ul><p><strong>模块化：</strong></p><ul><li>模块化开发就是<strong>将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来</strong>；</li><li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li><li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li><li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li></ul><p><strong>模块化的好处：</strong></p><ol><li>防止命名冲突</li><li>代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题）</li><li>高维护性（模块之间有高耦合低内聚的特点）</li></ol><h3 id="1-2-JavaScript设计缺陷"><a href="#1-2-JavaScript设计缺陷" class="headerlink" title="1.2 JavaScript设计缺陷"></a>1.2 JavaScript设计缺陷</h3><p>无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在<em>Brendan Eich</em>用了10天写出JavaScript的时候，它都有很多的缺陷：</p><ul><li>比如var定义的变量作用域问题；</li><li>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；</li><li>比如JavaScript没有模块化的问题；</li></ul><p><em>Brendan Eich</em>本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。</p><ul><li>JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；</li></ul><p>在网页开发的早期，<em>Brendan Eich</em>开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：</p><ul><li>这个时候我们只需要讲JavaScript代码写到<code>&lt;script&gt;</code>标签中即可；</li><li>并没有必要放到多个文件中来编写；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：</p><ul><li>ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；</li><li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；</li><li>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li></ul><p>所以，模块化已经是JavaScript一个非常迫切的需求。</p><h3 id="1-3-没有模块化的JavaScript"><a href="#1-3-没有模块化的JavaScript" class="headerlink" title="1.3 没有模块化的JavaScript"></a>1.3 没有模块化的JavaScript</h3><h4 id="1-3-1-技术方案"><a href="#1-3-1-技术方案" class="headerlink" title="1.3.1 技术方案"></a>1.3.1 技术方案</h4><p>演变过程：</p><ul><li><p>全局函数</p><ul><li>”污染”了全局变量，无法保证不与其它模块发生变量名冲突</li><li>没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块</li></ul></li><li><p>将函数封装到对象命名空间下</p><ul><li>从代码级别可以明显的区分出哪些函数属于同一个模块</li><li>从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突</li><li>会暴露所有的模块成员，内部状态可以被外部改写，不安全</li><li>命名空间越来越长</li></ul></li><li><p>立即函数调用表达式(<strong>IIFE</strong>，Immediately Invoked Function Expression)</p><ul><li><p>将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露</p></li><li><p>会有人强调<strong>职责单一性</strong>，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> add=<span class="function"><span class="keyword">function</span>(<span class="params">v1,v2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">add</span>:add &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculator=(<span class="function"><span class="keyword">function</span>(<span class="params">cal,$</span>)</span>&#123;</span><br><span class="line">  cal.add2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> v1=$(<span class="string">&#x27;#v1&#x27;</span>).val();</span><br><span class="line">      <span class="keyword">var</span> v2= $(<span class="string">&#x27;#v2&#x27;</span>).val();</span><br><span class="line">     <span class="keyword">return</span> (v1-<span class="number">0</span>)+(v2-<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cal;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.calculator||&#123;&#125;,<span class="built_in">window</span>.$)</span><br><span class="line"><span class="comment">//在这告诉我要jquery</span></span><br><span class="line"><span class="comment">//依赖注入</span></span><br><span class="line"><span class="comment">//很牵强的解决文件依赖问题的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IIFE也是有很大缺陷的，见下方代码举例</p></li></ul><h4 id="1-3-2-问题举例"><a href="#1-3-2-问题举例" class="headerlink" title="1.3.2 问题举例"></a>1.3.2 问题举例</h4><p>我们先来简单体会一下没有模块化代码的问题。</p><p>我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：</p><ul><li>我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小丽开发了bbb.js文件，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显出现了一个问题：</p><ul><li>大家都喜欢使用flag来存储一个boolean类型的值；</li><li>但是一个人赋值了true，一个人赋值了false；</li><li>如果之后都不再使用，那么也没有关系；</li></ul><p>但是，小明又开发了ccc.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了：小明发现ccc中的flag值不对</p><ul><li>对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；</li><li>但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？</li></ul><p>备注：引用路径如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ccc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，没有模块化对于一个大型项目来说是灾难性的。</p><h4 id="1-3-3-IIFE的缺陷"><a href="#1-3-3-IIFE的缺陷" class="headerlink" title="1.3.3 IIFE的缺陷"></a>1.3.3 IIFE的缺陷</h4><p>使用IIFE解决上面的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">flag</span>: flag &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> moduleB = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="keyword">const</span> moduleC = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> flag = moduleA.flag;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名冲突的问题，有没有解决呢？解决了。</p><p>但是，我们其实带来了新的问题：</p><ul><li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；</li><li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li><li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；</li></ul><p><strong>所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。</strong></p><ul><li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；</li><li>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；</li></ul><h3 id="1-4-JavaScript中模块化方案"><a href="#1-4-JavaScript中模块化方案" class="headerlink" title="1.4 JavaScript中模块化方案"></a>1.4 JavaScript中模块化方案</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有：</p><p>先有规范，后有实现：</p><ul><li>服务器端规范 <a href="http://www.commonjs.org/">CommonJS</a> =&gt; <a href="https://nodejs.org/">NodeJS</a>、 Browserify</li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">AMD</a> =&gt; <a href="http://requirejs.org/">RequireJS</a></li><li>浏览器端规范 <a href="https://github.com/amdjs/amdjs-api">CMD</a> =&gt; <a href="http://seajs.org/">SeaJS</a></li></ul><h2 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h2><h3 id="2-1-CommonJS和Node"><a href="#2-1-CommonJS和Node" class="headerlink" title="2.1 CommonJS和Node"></a>2.1 CommonJS和Node</h3><p>我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为<strong>ServerJS</strong>，后来为了体现它的广泛性，修改为<strong>CommonJS</strong>，平时我们也会简称为CJS。</p><ul><li>Node是CommonJS在服务器端一个具有代表性的实现；</li><li>Browserify是CommonJS在浏览器中的一种实现；</li><li>webpack打包工具具备对CommonJS的支持和转换（后面会讲到）；</li></ul><p>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p><h3 id="2-2-Node模块化语法"><a href="#2-2-Node模块化语法" class="headerlink" title="2.2 Node模块化语法"></a>2.2 Node模块化语法</h3><h4 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1 模块"></a>2.2.1 模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(name, age);</span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的代码会报错：</span></span><br><span class="line"><span class="comment"> - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；</span></span><br><span class="line"><span class="comment"> - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>在node中每一个文件都是一个独立的模块，有自己的作用域</strong>。在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</p><p>为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</p><p>每个模块(文件)中都包括CommonJS规范的核心变量：exports、module、require；</p><ul><li><p>module：是一个全局对象，代表当前模块。里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.id           <span class="comment">//带有绝对路径的模块文件名</span></span><br><span class="line"><span class="built_in">module</span>.filename      <span class="comment">//模块的文件名，带有绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.loaded       <span class="comment">//表示模块是否已经完成加载</span></span><br><span class="line"><span class="built_in">module</span>.parent     <span class="comment">//返回一个对象，表示调用该模块的模块。</span></span><br><span class="line"><span class="built_in">module</span>.children      <span class="comment">//返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line"><span class="built_in">module</span>.exports     <span class="comment">//模块对外输出的值。需要打破模块封装性曝露的方法和属性，都要挂载到module.exports上。其它文件加载该模块,实际上就是读取module.exports属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module);</span></span><br><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  path: <span class="string">&#x27;/Users/computer/Desktop/ccc&#x27;</span>,</span><br><span class="line">  <span class="built_in">exports</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">&#x27;/Users/computer/Desktop/ccc/main.js&#x27;</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [</span><br><span class="line">    Module &#123;...&#125;</span><br><span class="line">  ],</span><br><span class="line">  paths: [ <span class="comment">//查找路径</span></span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/ccc/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>exports是module.exports的引用。一起负责对模块中的内容进行导出；</p></li><li><p>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p></li></ul><p>在Node.js中，模块分为两类：</p><ul><li><p>第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。</p><ul><li>fs(file system)：与文件系统交互</li><li>http：提供http服务器功能</li><li>os：提供了与操作系统相关的实用方法和属性</li><li>path：处理文件路径</li><li>querystring：解析url查询字符串</li><li>url：解析url</li><li>util：提供一系列实用小工具</li><li>Buffer </li><li>等等很多，见<a href="http://api.nodejs.cn/">官方文档</a></li><li><strong>核心模块的源码都在Node的lib子目录中。为了提高运行速度，它们安装的时候都会被编译成二进制文件</strong></li></ul></li><li><p>第二类，文件模块，也称自定义模块。用路径加载。</p><p>有一种特殊的文件模块 — 包，被管理在<code>node_modules</code>文件夹中的包，也可以直接用名字加载。</p></li></ul><h4 id="2-2-2-exports导出"><a href="#2-2-2-exports导出" class="headerlink" title="2.2.2 exports导出"></a>2.2.2 exports导出</h4><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出内容</span></span><br><span class="line"><span class="built_in">exports</span>.name = name;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 导入内容</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面这行代码意味着什么呢？</p><ul><li>意味着main中的bar变量等于exports对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main中的bar = bar中的<span class="built_in">exports</span></span><br></pre></td></tr></table></figure><p>所以，我可以编写下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = bar.name;</span><br><span class="line"><span class="keyword">const</span> age = bar.age;</span><br><span class="line"><span class="keyword">const</span> sayHello = bar.sayHello;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"></span><br><span class="line">sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br></pre></td></tr></table></figure><p>模块之间的引用关系：</p><img src="/images/webmodule/moduleref.jpg" alt="图片" style="zoom:70%;" /><p>为了进一步论证，bar和exports是同一个对象：</p><ul><li>所以，bar对象是exports对象的浅拷贝；</li><li>浅拷贝的本质就是一种引用的赋值而已；</li></ul><p>定时器修改对象：</p><img src="/images/webmodule/settimeoutmod.jpg" alt="图片" style="zoom:80%;" /><h4 id="2-2-3-module-exports"><a href="#2-2-3-module-exports" class="headerlink" title="2.2.3 module.exports"></a>2.2.3 module.exports</h4><p>但是Node中我们经常导出东西的时候，又是通过module.exports导出的：</p><ul><li>module.exports和exports有什么关系或者区别呢？</li></ul><p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p><ul><li>CommonJS中是没有module.exports的概念的；</li><li>但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</li><li><strong>module才是导出的真正实现者；</strong></li><li>所以在Node中<strong>真正用于导出的其实根本不是exports，而是module.exports</strong>。只是为了实现CommonJS的规范，也为了使用方便，Node为每个模块提供了一个exports对象，让其对module.exports有一个引用而已。</li><li>相当于在每个模块头部，有这样一行命令：<code>var exports = module.exports;</code></li></ul><img src="/images/webmodule/export1.jpg" alt="图片" style="zoom:67%;" /><p><strong>不能直接给exports、module.exports赋值，这样等于切断了exports和module.exports的联系。最终输出的结果只会是module.exports的值</strong>。比如代码这样修改了：</p><img src="/images/webmodule/export2.jpg" alt="图片" style="zoom:67%;" /><img src="/images/webmodule/moduleexports.jpg" alt="moduleexports" style="zoom:68%;" /><h4 id="2-2-4-require"><a href="#2-2-4-require" class="headerlink" title="2.2.4 require"></a>2.2.4 require</h4><h5 id="1-require的加载原理"><a href="#1-require的加载原理" class="headerlink" title="1. require的加载原理"></a>1. require的加载原理</h5><p>前面已经说过，CommonJS 的一个模块，就是一个脚本文件。</p><ul><li><p>CommonJS是同步加载。模块加载的顺序，按照其在代码中出现的顺序</p></li><li><p><code>require</code>命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码，返回该模块的module.exports接口数据。会在内存生成一个该模块对应的module对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hello aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>); <span class="comment">// aaa.js中的代码在引入时会被运行一次</span></span><br></pre></td></tr></table></figure><p>生成的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: <span class="string">&#x27;...&#x27;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">  <span class="built_in">exports</span>: &#123; ... &#125;,  <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  loaded: <span class="literal">true</span>,   <span class="comment">// 是一个布尔值，为false表示还没有加载，为true表示已经加载完毕。这是保证每个模块只加载、运行一次的关键。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。</p></li><li><p>模块被多次引入时（多次执行<code>require</code>命令），CommonJS 模块<strong>只会在第一次加载时运行一次</strong>，以后再加载，会去缓存中取出第一次加载时生成的module对象并返回module.exports。除非手动清除系统缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ccc被加载&#x27;</span>);  <span class="comment">// ccc中的代码只会运行一次。</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-require的查找规则"><a href="#2-require的查找规则" class="headerlink" title="2. require的查找规则"></a>2. require的查找规则</h5><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。</p><p>那么，require的查找规则是怎么样的呢？<a href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">官方文档</a></p><p><strong>这里我总结比较常见的查找规则：</strong>导入格式如下：require(X)</p><ul><li><p>情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找</p><ul><li>加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。</li></ul></li><li><p>情况二：X是以 <code>./</code> 或 <code>../</code> 或 <code>/</code>（根目录）开头的</p><ul><li>在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径</li><li>第一步：将X当做一个文件在对应的目录下查找；<ul><li>如果有后缀名，按照后缀名的格式查找对应的文件</li><li>如果没有后缀名，会按照如下顺序：<ol><li>直接查找文件X</li><li>查找X.js文件：当做JavaScript脚本文件解析</li><li>查找X.json文件：以JSON格式解析。<ul><li>如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。</li><li>json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象</li></ul></li><li>查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块</li></ol></li></ul></li><li>第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件<ol><li>查找X/index.js文件</li><li>查找X/index.json文件</li><li>查找X/index.node文件</li></ol></li><li>如果没有找到，那么报错：<code>not found</code></li></ul></li><li><p>情况三：直接是一个X（没有路径），并且X不是一个核心模块</p><ul><li> 比如在<code>/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js</code>中</li></ul><p>  编写 <code>require(&#39;why&#39;)</code></p><ul><li><p>查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取… 一直找到全局 node_modules 目录。</p><img src="/images/webmodule/require1.jpg" alt="图片" style="zoom:70%;" /></li><li><p>这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就<strong>默认取文件夹下的 index.js</strong>。</p><p>由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。</p></li><li><p>如果上面的路径中都没有找到，那么报错：<code>not found</code></p></li></ul></li></ul><p>流程图：</p><img src="/images/webmodule/image1.jpg" alt="Alt text" style="zoom:80%;" /><ul><li><p>Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错</p></li><li><p>优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports <a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/">参考文献</a></p></li></ul><h5 id="3-require的加载顺序"><a href="#3-require的加载顺序" class="headerlink" title="3. require的加载顺序"></a>3. require的加载顺序</h5><p><strong>如果有多个模块的引入，那么加载顺序是什么？</strong></p><p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p><ul><li>这个其实是一种数据结构：图结构；</li><li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li><li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li></ul><p>多个模块的引入关系：</p><img src="/images/webmodule/multiMoudlesinclude.jpg" alt="multiMoudlesinclude" style="zoom:80%;" /><h3 id="2-3-Node的源码解析"><a href="#2-3-Node的源码解析" class="headerlink" title="2.3 Node的源码解析"></a>2.3 Node的源码解析</h3><p>Module类</p><img src="/images/webmodule/moduleclssource.jpg" alt="图片" style="zoom:80%;" /><p>Module.prototype.require函数</p><img src="/images/webmodule/requiremethodsource.jpg" alt="图片" style="zoom:80%;" /><p>Module._load函数</p><img src="/images/webmodule/loadmethodsource.jpg" alt="图片" style="zoom:80%;" /><h2 id="三、ES6-Module"><a href="#三、ES6-Module" class="headerlink" title="三、ES6 Module"></a>三、ES6 Module</h2><h3 id="4-1-认识ES6-Module"><a href="#4-1-认识ES6-Module" class="headerlink" title="4.1 认识ES6 Module"></a>4.1 认识ES6 Module</h3><h4 id="4-1-1-ES6-Module的优势"><a href="#4-1-1-ES6-Module的优势" class="headerlink" title="4.1.1 ES6 Module的优势"></a>4.1.1 ES6 Module的优势</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。</p><p>由于 ES6 模块是编译时加载：</p><ul><li><p>可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高</p></li><li><p>使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p></li></ul><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><h4 id="4-1-2-自动启动严格模式"><a href="#4-1-2-自动启动严格模式" class="headerlink" title="4.1.2 自动启动严格模式"></a>4.1.2 自动启动严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><ul><li>其中，尤其需要注意<code>this</code>的限制。<font color=red>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></font>。</li><li>参考链接：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式—MDN</a></li><li><a href="https://tenloy.github.io/pnote/web_note/05-JS%E9%AB%98%E7%BA%A7/Sources/3.6_ES5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html">严格模式—阮一峰</a></li></ul></li></ul><h4 id="4-1-3-浏览器中加载ES6-Module"><a href="#4-1-3-浏览器中加载ES6-Module" class="headerlink" title="4.1.3 浏览器中加载ES6 Module"></a>4.1.3 浏览器中加载ES6 Module</h4><h5 id="1-加载普通js文件"><a href="#1-加载普通js文件" class="headerlink" title="1. 加载普通js文件"></a>1. 加载普通js文件</h5><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="javascript"> <span class="comment">// code </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="javascript"> <span class="comment">//code... </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p></li><li><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。</p></li></ul><p>下面就是两种异步加载的语法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p><p><code>defer</code>与<code>async</code>的区别是：</p><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</li><li>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</li></ul><h5 id="2-加载ES6-Module"><a href="#2-加载ES6-Module" class="headerlink" title="2. 加载ES6 Module"></a>2. 加载ES6 Module</h5><p>浏览器内嵌、外链 ES6 模块代码，也使用<code>&lt;script&gt;</code>标签，但是都要加入<code>type=&quot;module&quot;</code>属性。</p><p><code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于下面代码。如果网页有多个 &lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;script&gt;标签的async属性也可以打开：</span></span><br><span class="line"><span class="comment">这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 </span></span><br><span class="line"><span class="comment">同样的：一旦使用了此属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="built_in">window</span>.x); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="built_in">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><h4 id="4-1-4-本地浏览的报错"><a href="#4-1-4-本地浏览的报错" class="headerlink" title="4.1.4 本地浏览的报错"></a>4.1.4 本地浏览的报错</h4><p>代码结构如下（个人习惯）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── modules</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.html中引入两个js文件作为模块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果直接在浏览器中运行代码，会报如下错误：</p><img src="/images/webmodule/modulerunerror.jpg" alt="图片" style="zoom:80%;" /><p>这个在MDN上面有给出解释：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></li><li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。</li><li>你需要通过一个服务器来测试。</li></ul><p>我这里使用的VSCode，VSCode中有一个插件：Live Server</p><ul><li>通过插件运行，可以将我们的代码运行在一个本地服务中；</li></ul><img src="/images/webmodule/liveserver.jpg" alt="图片" style="zoom:80%;" /><h3 id="4-2-ES6-Module的语法"><a href="#4-2-ES6-Module的语法" class="headerlink" title="4.2 ES6 Module的语法"></a>4.2 ES6 Module的语法</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>：</p><ul><li><code>export</code>命令用于规定模块的对外接口</li><li><code>import</code>命令用于输入其他模块提供的功能。</li></ul><h4 id="4-2-1-模块与CommonJS模块的区别"><a href="#4-2-1-模块与CommonJS模块的区别" class="headerlink" title="4.2.1 模块与CommonJS模块的区别"></a>4.2.1 模块与CommonJS模块的区别</h4><h5 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h5><p>与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h5 id="2-导出的不同"><a href="#2-导出的不同" class="headerlink" title="2. 导出的不同"></a>2. 导出的不同</h5><p><strong>CommonJS通过module.exports导出的是一个对象，是<code>module.exports</code>属性浅拷贝后导出：</strong></p><ul><li><p>该对象只有在脚本运行完才会生成。</p></li><li><p>导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">  obj: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(mod.counter, mod.obj.count); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure><p><strong>ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用：</strong></p><p>说法1：</p><ul><li>它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li><li>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错)</li><li>所以，<code>import</code>命令叫做“连接” binding 其实更合适。</li></ul><p>说法2：</p><ul><li><p>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>（module environment record）；</p></li><li><p><strong>模块环境记录</strong>会和变量进行 <code>绑定</code>（binding），并且这个绑定是实时的；</p></li><li><p>而在导入的地方，我们是可以实时的获取到绑定的最新值的；</p></li></ul><p><strong>export和import绑定的过程：</strong></p><img src="/images/webmodule/bindingProcedure.jpg" alt="图片" style="zoom:70%;" /><p>还是举上面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><h5 id="3-导入的不同"><a href="#3-导入的不同" class="headerlink" title="3. 导入的不同"></a>3. 导入的不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码实质会整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码实质只是从<code>fs</code>模块加载 3 个方法，其他方法不加载。</p><h4 id="4-2-2-export"><a href="#4-2-2-export" class="headerlink" title="4.2.2 export"></a>4.2.2 export</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p><h5 id="1-export-lt-decl-gt"><a href="#1-export-lt-decl-gt" class="headerlink" title="1. export &lt;decl&gt;"></a>1. <code>export &lt;decl&gt;</code></h5><p>方式一：分别导出。在<strong>语句声明</strong>的前面直接加上export关键字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> message = <span class="string">&quot;my name is why&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export需要指定对外暴露的接口，所以不能直接输出一个值</span></span><br><span class="line"><span class="comment">// export 40; //error</span></span><br></pre></td></tr></table></figure><h5 id="2-export"><a href="#2-export" class="headerlink" title="2. export {}"></a>2. <code>export &#123;&#125;</code></h5><p>方式二：统一导出。将所有需要导出的标识符，放到export后面的 <code>&#123;&#125;</code>中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。</p><ul><li>注意：这里的 <code>&#123;&#125;</code>里面不是ES6的对象字面量的增强写法，<code>&#123;&#125;</code>也不是表示一个对象的；</li><li>所以：<code>export &#123;name: name&#125;</code>，是错误的写法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-export-lt-gt-as-lt-gt"><a href="#3-export-lt-gt-as-lt-gt" class="headerlink" title="3. export {&lt;&gt; as &lt;&gt;}"></a>3. <code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></h5><p>方式三：通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字在导出时给<code>标识符</code>起一个别名：<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fName,</span><br><span class="line">  age <span class="keyword">as</span> fAge,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello1,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello2, <span class="comment">// 重命名后，sayHello可以用不同的名字输出两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-export导出的是标识符的地址"><a href="#4-export导出的是标识符的地址" class="headerlink" title="4. export导出的是标识符的地址"></a>4. export导出的是标识符的地址</h5><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p><h5 id="5-export导出同一个实例"><a href="#5-export导出同一个实例" class="headerlink" title="5. export导出同一个实例"></a>5. export导出同一个实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br></pre></td></tr></table></figure><p>不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变</p><h5 id="6-export书写位置"><a href="#6-export书写位置" class="headerlink" title="6. export书写位置"></a>6. export书写位置</h5><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;bar&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h5 id="7-export书写次数"><a href="#7-export书写次数" class="headerlink" title="7. export书写次数"></a>7. export书写次数</h5><p>一个模块中：<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</p><h4 id="4-2-3-import"><a href="#4-2-3-import" class="headerlink" title="4.2.3 import"></a>4.2.3 import</h4><p>import关键字负责从另外一个模块中导入内容。</p><p><strong><code>import</code>语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。</strong></p><p><strong>导入内容的方式也有多种：</strong></p><h5 id="1-import-from-39-39"><a href="#1-import-from-39-39" class="headerlink" title="1. import {} from &#39;&#39;"></a>1. <code>import &#123;&#125; from &#39;&#39;</code></h5><p>方式一：选择导入。<code>import &#123;标识符列表&#125; from &#39;模块&#39;</code>；</p><p>注意：</p><ul><li>大括号里面的变量名，必须与被导入模块对外接口的名称相同。</li><li>这里的<code>&#123;&#125;</code>也不是一个对象，里面只是存放导入的标识符列表内容；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>name</code>和<code>age</code>在两个语句中加载，但是它们对应的是同一个<code>foo.js</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p><h5 id="1-import-39-39-的含义"><a href="#1-import-39-39-的含义" class="headerlink" title="1. import &#39;&#39;的含义"></a>1. <code>import &#39;&#39;</code>的含义</h5><p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; </span><br></pre></td></tr></table></figure><p>上面代码仅仅执行<code>lodash</code>模块，但是不导入任何值。</p><p>同样的，如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">// 代码加载了两次`lodash`，但是只会执行一次。</span></span><br></pre></td></tr></table></figure><h5 id="2-import-lt-gt-as-lt-gt-from-39-39"><a href="#2-import-lt-gt-as-lt-gt-from-39-39" class="headerlink" title="2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;"></a>2.  <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></h5><p>方式二：导入时给标识符起别名： <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, sayHello <span class="keyword">as</span> wSayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="3-import-as-lt-gt-from-39-39"><a href="#3-import-as-lt-gt-from-39-39" class="headerlink" title="3.  import * as &lt;&gt; from &#39;&#39;"></a>3.  <code>import * as &lt;&gt; from &#39;&#39;</code></h5><p>方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用<code>*</code>指定： <code>import * as &lt;&gt; from &#39;&#39;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line"><span class="built_in">console</span>.log(foo.age);</span><br><span class="line">foo.sayHello(<span class="string">&quot;Kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.n = &quot;add&quot;; // Type Error: object is not extensible</span></span><br><span class="line"><span class="comment">// foo.f = function () &#123;&#125;; </span></span><br></pre></td></tr></table></figure><p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。</p><h5 id="4-import导入为只读"><a href="#4-import导入为只读" class="headerlink" title="4. import导入为只读"></a>4. import导入为只读</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">name = <span class="string">&quot;mod&quot;</span>; <span class="comment">// Syntax Error : &#x27;name&#x27; is read-only;</span></span><br></pre></td></tr></table></figure><p><code>name</code>是只读的。但是，如果<code>name</code>是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p><h5 id="5-import-from后的路径"><a href="#5-import-from后的路径" class="headerlink" title="5. import from后的路径"></a>5. import from后的路径</h5><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<font color=red>后缀名不能省略</font>。</p><p>如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><h5 id="6-import命令的提升"><a href="#6-import命令的提升" class="headerlink" title="6. import命令的提升"></a>6. import命令的提升</h5><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="7-import中不能使用表达式和变量"><a href="#7-import中不能使用表达式和变量" class="headerlink" title="7. import中不能使用表达式和变量"></a>7. import中不能使用表达式和变量</h5><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><h4 id="4-2-4-export-default"><a href="#4-2-4-export-default" class="headerlink" title="4.2.4 export default"></a>4.2.4 export default</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p><ul><li>在导出export时指定了名字；</li><li>在导入import时需要知道具体的名字；</li></ul><p>还有一种导出叫做默认导出（default export）</p><ul><li>默认导出export时可以不需要指定名字；</li><li>在导入时不需要使用 <code>&#123;&#125;</code>，并且可以自己来指定名字；</li><li>它也方便我们和现有的CommonJS等规范相互操作；</li></ul><h5 id="2-导出与导入格式"><a href="#2-导出与导入格式" class="headerlink" title="2. 导出与导入格式"></a>2. 导出与导入格式</h5><p>也是可以导出变量、函数、类的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出格式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式2：用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式3：用在函数变量前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;sub&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式1：常用及推荐</span></span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.default.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式3</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m.sub(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><h5 id="3-export-default的本质"><a href="#3-export-default的本质" class="headerlink" title="3. export default的本质"></a>3. export default的本质</h5><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;  <span class="comment">// 等同于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>; <span class="comment">// 等同于 import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// export default var a = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// export 42; // export后面得跟声明，或者&#123;标识符&#125;</span></span><br></pre></td></tr></table></figure><h5 id="4-export-default与export"><a href="#4-export-default与export" class="headerlink" title="4. export default与export"></a>4. export default与export</h5><p>注意：在一个模块中，export default是可以与export同时使用的：</p><ul><li>export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。</li><li>export是没有限制的。<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&quot;module1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 在一条`import`语句中，同时输入默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> m, &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">//m.sub、name</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.default.sub、m.name</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m, name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.sub、name</span></span><br></pre></td></tr></table></figure><h4 id="4-2-5-export和import结合"><a href="#4-2-5-export和import结合" class="headerlink" title="4.2.5 export和import结合"></a>4.2.5 export和import结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出一个sum函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js做一个中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js直接从foo中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js 导入，但是只是做一个中转</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> barSum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 甚至在foo.js中导出时，我们可以变化它的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入和导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口的写法如下：</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口：</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;ns&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。</span></span><br></pre></td></tr></table></figure><p>为什么要这样做呢？</p><ul><li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li><li>这样方便指定统一的接口规范，也方便阅读；</li><li>这个时候，我们就可以使用export和import结合使用；</li></ul><h4 id="4-2-6-import"><a href="#4-2-6-import" class="headerlink" title="4.2.6 import()"></a>4.2.6 import()</h4><h5 id="1-import-的背景"><a href="#1-import-的背景" class="headerlink" title="1. import()的背景"></a>1. import()的背景</h5><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，<code>import</code>和<code>export</code>命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在<code>if</code>代码块之中，或在函数之中）的。下面的代码会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;./&#x27;</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path); </span><br><span class="line"><span class="comment">// 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(specifier)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p><h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;<span class="comment">// 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数.</span></span><br><span class="line"><span class="comment">//.then(&#123;export1, export2&#125; =&gt; &#123;     // 可以使用对象解构赋值的语法，获取输出接口。</span></span><br><span class="line"><span class="comment">//.then(&#123;default: theDefault&#125; =&gt; &#123;  // 如果是default，那么需要解构重命名</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">module</span>.loadPageInto(main); <span class="comment">// module.default来使用默认导出</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.textContent = err.message;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是Promise对象，所以也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h5 id="3-适用场合"><a href="#3-适用场合" class="headerlink" title="3. 适用场合"></a>3. 适用场合</h5><ul><li><p>按需加载。</p><p><code>import()</code>可以在需要的时候，再加载某个模块。比如放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p></li><li><p>条件加载</p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p></li><li><p>动态的模块路径</p><p><code>import()</code>允许模块路径动态生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(f()).then(...);  <span class="comment">// 根据函数`f`的返回结果，加载不同的模块。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-7-应用-公共头文件"><a href="#4-2-7-应用-公共头文件" class="headerlink" title="4.2.7 应用: 公共头文件"></a>4.2.7 应用: 公共头文件</h4><p>介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  admin_username: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  admin_password: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-与CommonJS模块化的差异"><a href="#4-2-8-与CommonJS模块化的差异" class="headerlink" title="4.2.8 与CommonJS模块化的差异"></a>4.2.8 与CommonJS模块化的差异</h4><ul><li><p>CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。</p><ul><li><p>运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用</p></li><li><p>编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：</p><ul><li>比如from后面的路径需要动态获取；</li><li>比如不能将import放到if等语句的代码块中；</li><li>所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；</li></ul></li></ul></li><li><p>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</p><ul><li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li><li>异步的意味着：不会阻塞主线程继续执行；<ul><li>JS引擎在遇到<code>import</code>时会去获取这个js文件的过程是异步的</li><li>设置了 <code>type=module</code> 的script标签，相当于加上了 <code>async</code> 属性；</li><li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；</li></ul></li></ul></li></ul><p>CommonJS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;main代码执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// 同步加载foo文件，并且执行一次内部的代码</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;if语句继续执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES Module代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四、CommonJS模块与ES6模块的混编"><a href="#四、CommonJS模块与ES6模块的混编" class="headerlink" title="四、CommonJS模块与ES6模块的混编"></a>四、CommonJS模块与ES6模块的混编</h2><h3 id="4-3-CommonJS模块加载ES6模块"><a href="#4-3-CommonJS模块加载ES6模块" class="headerlink" title="4.3 CommonJS模块加载ES6模块"></a>4.3 CommonJS模块加载ES6模块</h3><p>通常情况下，CommonJS不能加载ES Module</p><ul><li>因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；</li><li>但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；</li></ul><p>可以使用<code>import()</code>这个方法加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><h3 id="4-2-ES6模块加载CommonJS模块"><a href="#4-2-ES6模块加载CommonJS模块" class="headerlink" title="4.2 ES6模块加载CommonJS模块"></a>4.2 ES6模块加载CommonJS模块</h3><p>多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。</p><ul><li>ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；</li><li>这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;foo的address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.address);</span><br></pre></td></tr></table></figure><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><h3 id="4-3-使模块同时支持两种模块化导入"><a href="#4-3-使模块同时支持两种模块化导入" class="headerlink" title="4.3 使模块同时支持两种模块化导入"></a>4.3 使模块同时支持两种模块化导入</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.foo;</span><br></pre></td></tr></table></figure><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>如果是Node.js中，还有一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><h2 id="五、Node-js开发中的模块化"><a href="#五、Node-js开发中的模块化" class="headerlink" title="五、Node.js开发中的模块化"></a>五、Node.js开发中的模块化</h2><h3 id="5-1-Node中支持-ES6-Module"><a href="#5-1-Node中支持-ES6-Module" class="headerlink" title="5.1 Node中支持 ES6 Module"></a>5.1 Node中支持 ES6 Module</h3><p>JavaScript 现在常用的有两种模块。</p><ul><li>ES6 模块，简称 ESM；</li><li>CommonJS 模块，简称 CJS。</li></ul><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作：</p><ul><li>方式一：文件以 <code>.mjs</code> 结尾，表示使用的是ES Module；</li><li>方式二：在package.json中配置字段 <code>type: module</code>，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。<ul><li>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。</li></ul></li><li>如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</li></ul><p>在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告：</p><img src="/images/webmodule/lstwarning.jpg" alt="图片" style="zoom:80%;" /><p>Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p>总结为一句话：</p><ul><li><code>.mjs</code>文件总是以 ES6 模块加载</li><li><code>.cjs</code>文件总是以 CommonJS 模块加载</li><li><code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</li></ul><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><h3 id="5-2-Node-js包模块的入口文件设置"><a href="#5-2-Node-js包模块的入口文件设置" class="headerlink" title="5.2 Node.js包模块的入口文件设置"></a>5.2 Node.js包模块的入口文件设置</h3><h4 id="5-2-1-package-json-的-main-字段"><a href="#5-2-1-package-json-的-main-字段" class="headerlink" title="5.2.1 package.json 的 main 字段"></a>5.2.1 package.json 的 main 字段</h4><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p><h5 id="举例：指定入口文件，格式为ESM"><a href="#举例：指定入口文件，格式为ESM" class="headerlink" title="举例：指定入口文件，格式为ESM"></a>举例：指定入口文件，格式为ESM</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><h4 id="5-2-2-package-json-的-exports-字段"><a href="#5-2-2-package-json-的-exports-字段" class="headerlink" title="5.2.2 package.json 的 exports 字段"></a>5.2.2 package.json 的 exports 字段</h4><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p><h5 id="1-给脚本或子目录起别名"><a href="#1-给脚本或子目录起别名" class="headerlink" title="1. 给脚本或子目录起别名"></a>1. 给脚本或子目录起别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>,  <span class="comment">//给脚本文件 src/submodule.js 起别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span>，<span class="comment">// 给子目录 ./src/features/ 起别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过别名加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="2-main-的别名"><a href="#2-main-的别名" class="headerlink" title="2. main 的别名."></a>2. main 的别名<code>.</code></h5><p><code>exports</code>字段的别名如果是<code>.</code> 就代表了是模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><h5 id="3-条件加载"><a href="#3-条件加载" class="headerlink" title="3. 条件加载"></a>3. 条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口）</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的写法可以简写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Node-js原生模块完全支持ES6-Module"><a href="#5-3-Node-js原生模块完全支持ES6-Module" class="headerlink" title="5.3 Node.js原生模块完全支持ES6 Module"></a>5.3 Node.js原生模块完全支持ES6 Module</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> EventEmitter <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">readFile(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-4-加载路径"><a href="#5-4-加载路径" class="headerlink" title="5.4 加载路径"></a>5.4 加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><h3 id="5-5-内部变量"><a href="#5-5-内部变量" class="headerlink" title="5.5 内部变量"></a>5.5 内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><h2 id="六、循环加载"><a href="#六、循环加载" class="headerlink" title="六、循环加载"></a>六、循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="6-1-CommonJS-模块的循环加载"><a href="#6-1-CommonJS-模块的循环加载" class="headerlink" title="6.1 CommonJS 模块的循环加载"></a>6.1 CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node <a href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;   <span class="comment">// 先输出一个`done`变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done); <span class="comment">// b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span></span><br><span class="line"><span class="comment"> 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。</span></span><br></pre></td></tr></table></figure><p>我们写一个脚本main.js，验证这个过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><p>执行<code>main.js</code>，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>上面的代码证明了两件事：</p><ol><li>在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。</li><li><code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行<code>exports.done = true;</code></li></ol><p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p><p>另外，<strong>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).foo; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.good = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.foo(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.bad = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><h3 id="6-2-ES6-模块的循环加载"><a href="#6-2-ES6-模块的循环加载" class="headerlink" title="6.2 ES6 模块的循环加载"></a>6.2 ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的：</p><ul><li>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。</li><li>接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。</li><li>执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</li></ul><p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;   <span class="comment">// const foo = () =&gt; &#x27;foo&#x27;; 仍然会执行报错。函数表达式，就不具有提升作用</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是因为<strong>函数具有提升作用</strong>，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。</p><p>这也意味着，<strong>如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p><h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><p>我们再来看 ES6 模块加载器<a href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">even</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">odd</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.even(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.even(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.counter</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.counter = counter;</span><br><span class="line"><span class="built_in">exports</span>.even = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || odd(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).even;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; even(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure><h2 id="七、了解：AMD和CMD规范"><a href="#七、了解：AMD和CMD规范" class="headerlink" title="七、了解：AMD和CMD规范"></a>七、了解：AMD和CMD规范</h2><h3 id="7-1-CommonJS规范缺点"><a href="#7-1-CommonJS规范缺点" class="headerlink" title="7.1. CommonJS规范缺点"></a>7.1. CommonJS规范缺点</h3><p>CommonJS加载模块是同步的：</p><ul><li>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；</li><li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；</li></ul><p>如果将它应用于浏览器呢？</p><ul><li>浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；</li><li>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；</li></ul><p>所以在浏览器中，我们通常不使用CommonJS规范：</p><ul><li>当然在webpack中使用CommonJS是另外一回事；</li><li>因为它会将我们的代码转成浏览器可以直接执行的代码；</li></ul><p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：</p><ul><li>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；</li><li>AMD和CMD已经使用非常少了，所以这里我们进行简单的演练；</li></ul><h3 id="7-2-AMD规范"><a href="#7-2-AMD规范" class="headerlink" title="7.2. AMD规范"></a>7.2. AMD规范</h3><h4 id="7-2-1-AMD与Require-js"><a href="#7-2-1-AMD与Require-js" class="headerlink" title="7.2.1 AMD与Require.js"></a>7.2.1 AMD与Require.js</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p><ul><li>AMD是Asynchronous Module Definition（异步模块定义）的缩写；</li><li>它采用的是异步加载模块；</li><li>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；</li></ul><p>我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p><ul><li>AMD实现的比较常用的库是require.js和curl.js；</li></ul><h4 id="7-2-2-Require-js的使用"><a href="#7-2-2-Require-js的使用" class="headerlink" title="7.2.2 Require.js的使用"></a>7.2.2 Require.js的使用</h4><p>第一步：下载require.js</p><ul><li>下载地址：<a href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li><li>找到其中的require.js文件； </li></ul><p>第二步：定义HTML的script标签引入require.js和定义入口文件：</p><ul><li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：编写如下目录和代码(<strong>个人习惯</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── require.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">      foo: <span class="string">&#x27;./modules/foo&#x27;</span>,</span><br><span class="line">      bar: <span class="string">&#x27;./modules/bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 开始加载执行foo模块的代码</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>modules/bar.js</p><ul><li>如果一个模块不依赖其他，那么直接使用define(function)即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age, </span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>modules/foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">&#x27;bar&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-3-CMD规范"><a href="#7-3-CMD规范" class="headerlink" title="7.3 CMD规范"></a>7.3 CMD规范</h3><h4 id="7-3-1-CMD与SeaJS"><a href="#7-3-1-CMD与SeaJS" class="headerlink" title="7.3.1 CMD与SeaJS"></a>7.3.1 CMD与SeaJS</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p><ul><li>CMD 是Common Module Definition（通用模块定义）的缩写；</li><li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li><li>但是目前CMD使用也非常少了；</li></ul><p>CMD也有自己比较优秀的实现方案：</p><ul><li>SeaJS</li></ul><h4 id="7-3-2-SeaJS的使用"><a href="#7-3-2-SeaJS的使用" class="headerlink" title="7.3.2 SeaJS的使用"></a>7.3.2 SeaJS的使用</h4><h5 id="1-下载SeaJS"><a href="#1-下载SeaJS" class="headerlink" title="1. 下载SeaJS"></a>1. 下载SeaJS</h5><ul><li>下载地址：<a href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li><li>找到dist文件夹下的sea.js</li></ul><h5 id="2-引入sea-js和启动模块"><a href="#2-引入sea-js和启动模块" class="headerlink" title="2. 引入sea.js和启动模块"></a>2. 引入sea.js和启动模块</h5><ul><li><code>seajs</code>是指定主入口文件的，也称为启动模块</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!--在调用 seajs 之前，必须先引入 sea.js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  seajs.use(<span class="string">&#x27;./index.js&#x27;</span>);  </span></span><br><span class="line">  /*</span><br><span class="line">   通过 seajs.use() 函数可以启动模块</span><br><span class="line"><span class="javascript">- (<span class="string">&#x27;模块id&#x27;</span> [,callback])加载一个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- ([<span class="string">&#x27;模块1&#x27;</span>, <span class="string">&#x27;模块2&#x27;</span>] [,callback])加载多个模块，并执行回调函数</span></span><br><span class="line"><span class="javascript">- callback 参数是可选的。格式为：<span class="function"><span class="keyword">function</span>(<span class="params"> 模块对象 </span>)</span>&#123; 业务代码 &#125;;</span></span><br><span class="line"></span><br><span class="line"> - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里</span><br><span class="line"><span class="javascript"> - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 <span class="built_in">window</span>.onload 或者 $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span></span><br><span class="line">   */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3-编写如下目录和代码-个人习惯"><a href="#3-编写如下目录和代码-个人习惯" class="headerlink" title="3. 编写如下目录和代码(个人习惯)"></a>3. 编写如下目录和代码(<strong>个人习惯</strong>)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── sea.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure><h5 id="4-定义模块define"><a href="#4-定义模块define" class="headerlink" title="4. 定义模块define"></a>4. 定义模块define</h5><ul><li>在CMD规范中，一个模块就是一个js文件</li></ul><p>module是一个对象，存储了模块的元信息，具体如下：</p><ul><li><p>module.id——模块的ID。</p></li><li><p>module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。</p></li><li><p>module.exports——与exports指向同一个对象。</p></li><li><p>module.uri</p></li></ul><p>define 是一个全局函数，用来定义模块：<code>define( factory )</code></p><ul><li>对象<code>&#123;&#125;</code>：这种方式，外部会直接获取到该对象</li><li>字符串<code>&quot;&quot;</code>： 同上</li><li>函数：<code>define(function(require, exports, module)&#123; 模块代码 &#125;);</code>  为了减少出错，定义函数的时候直接把这三个参数写上</li></ul><h5 id="5-导出接口exports和module-exports"><a href="#5-导出接口exports和module-exports" class="headerlink" title="5. 导出接口exports和module.exports"></a>5. 导出接口exports和module.exports</h5><ul><li><p>功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口</p></li><li><p>exports 等价于 module.exports。exports能做什么，module.exports就能做什么</p></li><li><p>可以通过多次给exports 挂载属性向外暴露</p></li><li><p>不能直接给 exports 赋值</p></li><li><p>如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可</p></li></ul><h5 id="6-依赖模块require"><a href="#6-依赖模块require" class="headerlink" title="6. 依赖模块require"></a>6. 依赖模块require</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 模块标识/模块id</span></span><br><span class="line"><span class="comment">    - 模块标识就是一个`字符串`，用来`标识模块`</span></span><br><span class="line"><span class="comment">    - 模块标识 可以不包含后缀名.js</span></span><br><span class="line"><span class="comment">    - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径</span></span><br><span class="line"><span class="comment">    - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base）</span></span><br><span class="line"><span class="comment">    - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">requeire(<span class="string">&#x27;模块id&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.用于根据一个模块id加载/依赖该模块</span></span><br><span class="line"><span class="comment"> 2.参数必须是一个字符串</span></span><br><span class="line"><span class="comment"> 3.该方法会得到 要加载的模块中的 module.exports 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>只能在模块环境define中使用，define(factory)的构造方法第一个参数<strong>必须命名为 require</strong></li><li>不要重命名require函数或者在任何作用域中给 require 重新赋值</li><li>在一个模块系统中，<code>require</code> 加载过的模块会被缓存</li><li>默认 <code>require</code> 是同步加载模块的</li></ul><p><strong>require.async</strong></p><p>SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.async(<span class="string">&#x27;/path/to/module/file&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code of callback...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。</p><h5 id="SeaJS高级配置"><a href="#SeaJS高级配置" class="headerlink" title="SeaJS高级配置"></a>SeaJS高级配置</h5><ul><li><strong>alias：别名配置</strong></li><li><strong>paths：路径配置</strong></li><li>vars：变量配置</li><li>map：映射配置</li><li>preload：预加载项</li><li>debug：调试模式</li><li><strong>base：基础路径</strong></li><li>charset：文件编码</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./modules/foo&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>bar.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;lilei&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>foo.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bar.name);</span><br><span class="line">  <span class="built_in">console</span>.log(bar.age);</span><br><span class="line">  bar.sayHello(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><p><a href="https://es6.ruanyifeng.com/#docs/module">Module的语法和加载实现 — 阮一峰</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5MDAzNzkwNA==&mid=2247484285&idx=1&sn=bc37c00b5c58ff42355b1b01ad9b9c0d&chksm=cfe3f082f8947994b5475d365c4460ac0d4b36d6eec68b5dd7c15fc3a0ef1b88f33b776f3f05&scene=178&cur_album_id=1567316742547226629#rd">彻底掌握前端模块化 — codewhy</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、模块化&quot;&gt;&lt;a href=&quot;#一、模块化&quot; class=&quot;headerlink&quot; title=&quot;一、模块化&quot;&gt;&lt;/a&gt;一、模块化&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是模块化&quot;&gt;&lt;a href=&quot;#1-1-什么是模块化&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Web" scheme="https://tenloy.github.io/categories/Web/"/>
    
    
  </entry>
  
</feed>
