<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2021-05-27T09:20:16.904Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[转]最通俗的 React Fiber(时间分片)</title>
    <link href="https://tenloy.github.io/2021/05/27/09_Fiber/"/>
    <id>https://tenloy.github.io/2021/05/27/09_Fiber/</id>
    <published>2021-05-27T16:51:02.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903975112671239#heading-13">原文链接</a> Fiber 不是一个新的东西，来看一下单处理进程调度</p><h2 id="一、单处理器进程调度"><a href="#一、单处理器进程调度" class="headerlink" title="一、单处理器进程调度"></a>一、单处理器进程调度</h2><img width = "60%" alt="" align=center src="/images/Fiber/16deecc2160c5d19.jpg"/><p>微软 <a href="https://zh.wikipedia.org/zh-cn/DOS"><code>DOS</code></a> 是一个<code>单任务操作系统</code>， 也称为’单工操作系统‘。这种操作系统同一个时间只允许运行一个程序。 <a href="https://www.zhihu.com/people/s.invalid">invalid s</a>在<a href="https://www.zhihu.com/question/319595914/answer/683541635">《在没有GUI的时代(只有一个文本界面），人们是怎么运行多个程序的？》</a> 的回答中将其称为： ‘<strong>一种压根没有任务调度的“残疾”操作系统</strong>‘.</p><p>在这种系统中，你想执行多个任务，只能等待前一个进程退出，然后再载入一个新的进程。</p><p>直到 Windows 3.x，它才有了真正意义的进程调度器，实现了多进程并发执行。</p><blockquote><p>注意并发和并行不是同一个概念。</p></blockquote><h3 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h3><p>现代操作系统都是<strong>多任务操作系统</strong>。进程的调度策略如果按照CPU核心数来划分，可以分为<strong>单处理器调度</strong>和<strong>多处理器调度</strong>。本文只关注的是单处理器调度，因为它可以类比JavaScript的运行机制。</p><p><strong>说白了，为了实现进程的并发，操作系统会按照一定的调度策略，将CPU的执行权分配给多个进程，多个进程都有被执行的机会，让它们交替执行，形成一种“同时在运行”假象, 因为CPU速度太快，人类根本感觉不到。实际上在单核的物理环境下同时只能有一个程序在运行</strong>。</p><ul><li><p>“龙珠”中的分身术，实质上是一个人，只不过是他运动速度太快，看起来就像分身了。这就是所谓的<strong>并发(Concurrent)</strong>(单处理器)。</p></li><li><p>相比而言, 火影忍者中的分身术，是物理存在的，他们可以真正实现同时处理多个任务，这就是<strong>并行</strong>(严格地讲这是<code>Master-Slave</code>架构，分身虽然物理存在，但应该没有独立的意志)。</p></li></ul><p>所以说<strong>并行可以是并发，而并发不一定是并行，两种不能划等号, 并行一般需要物理层面的支持</strong>。 关于并发和并行，Go 之父 Rob Pike 有一个非常著名的演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not parallelism</a></p><h3 id="1-2-进程调度策略"><a href="#1-2-进程调度策略" class="headerlink" title="1.2 进程调度策略"></a>1.2 进程调度策略</h3><h4 id="1-2-1-先到先得-First-Come-First-Served-FCFS"><a href="#1-2-1-先到先得-First-Come-First-Served-FCFS" class="headerlink" title="1.2.1 先到先得(First-Come-First-Served, FCFS)"></a>1.2.1 先到先得(First-Come-First-Served, FCFS)</h4><p>这是最简单的调度策略, 简单说就是<strong>没有调度</strong>。谁先来谁就先执行，执行完毕后就执行下一个。不过如果中间某些进程因为I/O阻塞了，这些进程会挂起移回就绪队列(说白了就是重新排队)。</p><p><code>FCFS</code> 上面 <code>DOS</code> 的单任务操作系统没有太大的区别。所以非常好理解，因为生活中到处是这样的例子:。</p><ul><li><p><strong>FCFS 对<code>短进程</code>不利</strong>。 短进程即执行时间非常短的进程。</p><p>举例：可以用饭堂排队来比喻: 在饭堂排队打饭的时候，最烦那些一个人打包好好几份的人，这些人就像<code>长进程</code>一样，霸占着CPU资源，后面排队只打一份的人会觉得很吃亏，打一份的人会觉得他们优先级应该更高，毕竟他们花的时间很短，反正你打包那么多份再等一会也是可以的，何必让后面那么多人等这么久…</p></li><li><p><strong>FCFS 对<code>I/O密集</code>不利</strong>。I/O密集型进程(这里特指同步I/O)在进行I/O操作时，会阻塞休眠，这会导致进程重新被放入就绪队列，等待下一次被选择。 </p><p>举例：ZF部门办业务: 假设 CPU 一个窗口、I/O 一个窗口。在CPU窗口好不容易排到你了，这时候发现一个不符合条件或者漏办了, 需要去I/O搞一下，Ok 去 I/O窗口排队，I/O执行完了，到CPU窗口又得重新排队。对于这些丢三落四的人很不公平…</p></li></ul><p>所以 FCFS 这种原始的策略在单处理器进程调度中并不受欢迎。</p><h4 id="1-2-2-轮转"><a href="#1-2-2-轮转" class="headerlink" title="1.2.2 轮转"></a>1.2.2 轮转</h4><p>这是一种基于时钟的<strong>抢占策略</strong>，这也是抢占策略中最简单的一种: <strong>公平地给每一个进程一定的执行时间，当时间消耗完毕或阻塞，操作系统就会调度其他进程，将执行权抢占过来</strong>。</p><blockquote><p><strong>决策模式</strong>: <code>抢占策略</code>相对应的有<code>非抢占策略</code>，非抢占策略指的是让进程运行直到结束、阻塞(如I/O或睡眠)、或者主动让出控制权；抢占策略支持中断正在运行的进程，将主动权掌握在操作系统这里，不过通常开销会比较大。</p></blockquote><p>这种调度策略的要点是<strong>确定合适的时间片长度</strong>: 太长了，长进程霸占太久资源，其他进程会得不到响应(等待执行时间过长)，这时候就跟上述的 <code>FCFS</code> 没什么区别了;  太短了也不好，因为进程抢占和切换都是需要成本的, 而且成本不低，时间片太短，时间可能都浪费在上下文切换上了，导致进程干不了什么实事。</p><p>因此<strong>时间片的长度最好符合大部分进程完成一次典型交互所需的时间</strong>。</p><p>轮转策略非常容易理解，只不过确定时间片长度需要伤点脑筋；另外和<code>FCFS</code>一样，轮转策略对I/O进程还是不公平。</p><h4 id="1-2-3-最短进程优先-Shortest-Process-Next-SPN"><a href="#1-2-3-最短进程优先-Shortest-Process-Next-SPN" class="headerlink" title="1.2.3 最短进程优先(Shortest Process Next, SPN)"></a>1.2.3 最短进程优先(Shortest Process Next, SPN)</h4><p>上面说了<code>先到先得</code>策略对<code>短进程</code>不公平，<code>最短进程优先</code>索性就让’最短’的进程优先执行，也就是说: <strong>按照进程的预估执行时间对进程进行优先级排序，先执行完短进程，后执行长进程。这是一种非抢占策略</strong>。</p><p>这样可以让短进程能得到较快的响应。但是怎么获取或者<strong>评估进程执行时间</strong>呢？一是让程序的提供者提供，这不太靠谱；二是由操作系统来收集进程运行数据，并对它们进程统计分析。例如最简单的是计算它们的平均运行时间。不管怎么说都比上面两种策略要复杂一点。</p><p><code>SPN</code> 的缺陷是: 如果系统有大量的短进程，那么长进程可能会饥饿得不到响应。</p><p>另外因为它不是抢占性策略, 尽管现在短进程可以得到更多的执行机会，但是还是没有解决 <code>FCFS</code> 的问题: 一旦长进程得到CPU资源，得等它执行完，导致后面的进程得不到响应。</p><h4 id="1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT"><a href="#1-2-4-最短剩余时间-Shortest-Remaining-Time-SRT" class="headerlink" title="1.2.4 最短剩余时间(Shortest Remaining Time, SRT)"></a>1.2.4 最短剩余时间(Shortest Remaining Time, SRT)</h4><p><strong>SRT 进一步优化了SPN，增加了抢占机制</strong>。在 SPN 的基础上，当一个进程添加到就绪队列时，操作系统会比较<em>刚添加的新进程</em>和<em>当前正在执行的老进程</em>的‘剩余时间’，如果新进程剩余时间更短，新进程就会抢占老进程。</p><p>相比轮转的抢占，SRT 没有中断处理的开销。但是在 SPN 的基础上，操作系统需要记录进程的历史执行时间，这是新增的开销。<strong>另外长进程饥饿问题还是没有解决</strong>。</p><h4 id="1-2-5-最高响应比优先-HRRN"><a href="#1-2-5-最高响应比优先-HRRN" class="headerlink" title="1.2.5 最高响应比优先(HRRN)"></a>1.2.5 最高响应比优先(HRRN)</h4><p><strong>为了解决长进程饥饿问题，同时提高进程的响应速率</strong>。还有一种<code>最高响应比优先的</code>策略，首先了解什么是响应比:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应比 &#x3D; （等待执行时间 + 进程执行时间） &#x2F; 进程执行时间</span><br></pre></td></tr></table></figure><p><strong>这种策略会选择响应比最高的进程优先执行</strong>：</p><ul><li>对于短进程来说，因为执行时间很短，分母很小，所以响应比比较高，会被优先执行</li><li>对于长进程来说，执行时间长，一开始响应比小，但是随着等待时间增长，它的优先级会越来越高，最终可以被执行</li></ul><h4 id="1-2-6-反馈法"><a href="#1-2-6-反馈法" class="headerlink" title="1.2.6 反馈法"></a>1.2.6 反馈法</h4><p>SPN、SRT、HRRN都需要对进程时间进行评估和统计，实现比较复杂且需要一定开销。而反馈法采取的是<strong>事后反馈</strong>的方式。这种策略下: <strong>每个进程一开始都有相同的优先级，每次被抢占(需要配合其他抢占策略使用，如轮转)，优先级就会降低一级。因此通常它会根据优先级划分多个队列</strong>。</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">队列1</span><br><span class="line">队列2</span><br><span class="line">...</span><br><span class="line">队列N</span><br></pre></td></tr></table></figure><p>新增的任务会推入<code>队列1</code>，<code>队列1</code>会按照<code>轮转策略</code>以一个时间片为单位进行调度。短进程可以很快得到响应，而对于长进程可能一个时间片处理不完，就会被抢占，放入<code>队列2</code>。</p><p><code>队列2</code>会在<code>队列1</code>任务清空后被执行，有时候低优先级队列可能会等待很久才被执行，所以一般会给予一定的补偿，例如增加执行时间，所以<code>队列2</code>的轮转时间片长度是2。</p><p>反馈法仍然可能导致长进程饥饿，所以操作系统可以统计长进程的等待时间，当等待时间超过一定的阈值，可以选择提高它们的优先级。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc24dfd080c.png"/><p>没有一种调度策略是万能的, 它需要考虑很多因素:</p><ul><li>响应速率。进程等待被执行的时间</li><li>公平性。兼顾短进程、长进程、I/O进程</li></ul><p>这两者在某些情况下是对立的，提高了响应，可能会减低公平性，导致饥饿。短进程、长进程、I/O进程之间要取得平衡也非常难。</p><p>上面这些知识对本文来说已经足够了，现实世界操作系统的进程调度算法比教科书上说的要复杂的多，有兴趣读者可以去研究一下 <code>Linux</code> 相关的进程调度算法，这方面的资料也非常多, 例如<a href="https://blog.csdn.net/gatieme/article/details/51456569">《Linux进程调度策略的发展和演变》</a>。</p><h2 id="二、浏览器JavaScript执行环境"><a href="#二、浏览器JavaScript执行环境" class="headerlink" title="二、浏览器JavaScript执行环境"></a>二、浏览器JavaScript执行环境</h2><p>JavaScript 是<a href="https://juejin.im/post/6844903553795014663">单线程运行</a>的(就像单行道)，而且在浏览器环境屁事非常多，它要负责页面的JS解析和执行、绘制、事件处理、静态资源加载和处理, 这些任务可以类比上面’进程‘。</p><blockquote><p>这里特指Javascript 引擎是单线程运行的。 严格来说，Javascript 引擎和页面渲染引擎在同一个<code>渲染线程</code>，GUI 渲染和 Javascript执行 两者是互斥的。 另外异步 I/O 操作底层实际上可能是多线程的在驱动。</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecc35b99001e.jpg"/><p><em>图片来源: <a href="https://developers.google.com/web/fundamentals/performance/rendering">Rendering Performance</a></em></p><p><strong>它只是一个’JavaScript’，同时只能做一件事情，这个和 <code>DOS</code> 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差</strong>。</p><p><strong>对于’前端框架‘来说，解决这种问题有三个方向</strong>:</p><ol><li>优化每个任务，让它有多快就多快。挤压CPU运算量</li><li>快速响应用户，让用户觉得够快，不能阻塞用户的交互</li><li>尝试 Worker 多线程</li></ol><p>Vue 选择的是第1种, 因为对于Vue来说，使用<code>模板</code>让它有了很多优化的空间，配合响应式机制可以让Vue可以精确地进行节点更新, 读者可以去看一下<a href="https://www.yuque.com/vueconf/2019/gwn1z0">今年Vue Conf 尤雨溪的演讲</a>，非常棒!；而 React 选择了2种。对于Worker 多线程渲染方案也有人尝试，要保证状态和视图的一致性相当麻烦。</p><p>React 为什么要引入 Fiber 架构？ 看看下面的火焰图，这是React V15 下面的一个列表渲染资源消耗情况。整个渲染花费了130ms, **在这里面 React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 <code>Reconcilation</code>(中文可以译为<code>协调</code>)**。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc366f124be.png"/><p>在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。</p><p>这样说，你可能没办法体会到，通过下面两个图片来体会一下(<em>图片来源于：<a href="https://twitter.com/dan_abramov">Dan Abramov</a> 的 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 1</a> 演讲, 推荐看一下👍. 另外非常感谢<a href="https://www.zhihu.com/people/BlackGanglion/activities">淡苍</a> 将一个<a href="https://codesandbox.io/s/koyz664q35">类似的DEMO 分享在了 CodeSandbox</a>上🎉，大家自行体验</em>):</p><p>同步模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc3acaf5689.gif" /><p>优化后的 <code>Concurrent</code> 模式下的 React:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc385cc0286.gif" /><p>React 的 Reconcilation 是CPU密集型的操作, 它就相当于我们上面说的’长进程‘。所以初衷和进程调度一样，我们要让高优先级的进程或者短进程优先运行，不能让长进程长期霸占资源。</p><p>所以React 是怎么优化的？ 划重点， <strong>为了给用户制造一种应用很快的’假象’，我们不能让一个程序长期霸占着资源。 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的’进程’，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率</strong>。</p><p><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处</strong>:</p><ul><li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。这个在<a href="https://juejin.im/post/6844903938894872589#heading-1">《「前端进阶」高性能渲染十万条数据(时间分片)》</a> 以及司徒正美的<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 都做了相关实验</li><li>司徒正美在<a href="https://zhuanlan.zhihu.com/p/37095662">《React Fiber架构》</a> 也提到：<strong>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</strong>。</li></ul><p>这就是为什么React 需要 Fiber 。</p><h2 id="三、何为-Fiber"><a href="#三、何为-Fiber" class="headerlink" title="三、何为 Fiber"></a>三、何为 Fiber</h2><p>对于 React 来说，Fiber 可以从两个角度理解:</p><h3 id="1-一种流程控制原语"><a href="#1-一种流程控制原语" class="headerlink" title="1. 一种流程控制原语"></a>1. 一种流程控制原语</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Fiber 也称<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272">协程</a>、或者纤程。 笔者第一次接触这个概念是在学习 Ruby 的时候，Ruby就将协程称为 Fiber。后来发现很多语言都有类似的机制，例如Lua 的<code>Coroutine</code>, 还有前端开发者比较熟悉的 <code>ES6</code> 新增的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator"><code>Generator</code></a>。</p><p><strong>其实协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制</strong>。要理解协程，你得和普通函数一起来看, 以Generator为例:</p><p>普通函数执行的过程中无法<strong>被中断和恢复</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>Generator</code> 可以:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React Fiber 的思想和协程的概念是契合的: <strong>React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染</strong>。</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>浏览器没有抢占的条件, 所以React只能用让出机制?</p><p><strong>答: 没错, 主动让出机制</strong></p><p>一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断/恢复的条件。二是没有抢占的机制，我们无法中断一个正在执行的程序。</p><p>所以我们只能采用类似协程这样控制权让出机制。这个和上文提到的进程调度策略都不同，它有更一个专业的名词：<a href="https://juejin.im/post/6844903874692661255#heading-7"><strong>合作式调度(Cooperative Scheduling)</strong></a>, 相对应的有<strong>抢占式调度(Preemptive Scheduling)</strong></p><p><strong>这是一种’契约‘调度，要求我们的程序和浏览器紧密结合，互相信任</strong>。比如可以由浏览器给我们分配执行时间片(通过<code>requestIdleCallback</code>实现, 下文会介绍)，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><img width = "80%" alt="" align=center src="/images/Fiber/16deecc37fdd60d7.png"/><p>这种调度方式很有趣，你会发现<strong>这是一种身份的对调</strong>，以前我们是老子，想怎么执行就怎么执行，执行多久就执行多久; 现在为了我们共同的用户体验统一了战线, 一切听由浏览器指挥调度，浏览器是老子，我们要跟浏览器申请执行权，而且这个执行权有期限，借了后要按照约定归还给浏览器。</p><p>当然你超时不还浏览器也拿你没办法 … 合作式调度的缺点就在于此，全凭自律，用户要挖大坑，谁都拦不住。</p><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>怎么确定有高优先任务要处理，即什么时候让出？</p><p><strong>答: requestIdleCallback API</strong></p><p>上面代码示例中的 <code>hasHighPriorityEvent()</code> 在目前浏览器中是无法实现的，我们没办法判断当前是否有更高优先级的任务等待被执行。</p><p>只能换一种思路，通过<strong>超时检查的机制来让出控制权</strong>。解决办法是: <em>确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交换给浏览器</em>。</p><p>举个例子，为了让视图流畅地运行，可以按照人类能感知到最低限度每秒60帧的频率划分时间片，这样每个时间片就是 16ms。</p><p>其实浏览器提供了相关的接口 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback"><code>requestIdleCallback</code></a> API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback(</span><br><span class="line">  callback: (dealine: IdleDeadline) &#x3D;&gt; void,</span><br><span class="line">  option?: &#123;timeout: number&#125;</span><br><span class="line">  )</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>IdleDeadline</code>的接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IdleDealine &#123;</span><br><span class="line">  didTimeout: boolean &#x2F;&#x2F; 表示任务执行是否超过约定时间</span><br><span class="line">  timeRemaining(): DOMHighResTimeStamp &#x2F;&#x2F; 任务可供执行的剩余时间</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>单从名字上理解的话, <code>requestIdleCallback</code>的意思是<strong>让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕</strong>。</p><p><strong>那浏览器什么时候有空？</strong></p><p>我们先来看一下浏览器在一帧(Frame，可以认为事件循环的一次循环)内可能会做什么事情:</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecd81f16c6f2.png"/><p><em>你可以打开 Chrome 开发者工具的Performance标签，这里可以详细看到Javascript的每一帧都执行了什么任务(Task), 花费了多少时间。</em></p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc428fb4c0b.png"/><p><em>图片来源: <a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></em></p><p>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p><ul><li>处理用户输入事件</li><li>Javascript执行</li><li>requestAnimation 调用</li><li>布局 Layout</li><li>绘制 Paint</li></ul><p>上面说理想的一帧时间是 <code>16ms</code> (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 <code>requestIdleCallback</code> 的回调。例如</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc43c710e16.png"/><p><strong>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间</strong>。</p><blockquote><p>另外不建议在<code>requestIdleCallback</code>中进行<code>DOM</code>操作，因为这可能导致样式重新计算或重新布局(比如操作DOM后马上调用 <code>getBoundingClientRect</code>)，这些时间很难预估的，很有可能导致回调执行超时，从而掉帧。</p></blockquote><p>目前 <code>requestIdleCallback</code> 目前只有Chrome支持。所以目前 React <a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js">自己实现了一个</a>。它利用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel"><code>MessageChannel</code></a> 模拟将回调延迟到’绘制操作’之后执行:</p><img width = "100%" alt="" align=center src="/images/Fiber/16deecc5839a3974.png"/><p>简单看一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ch = <span class="keyword">new</span> MessageChannel()</span><br><span class="line"><span class="keyword">let</span> pendingCallback</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">ch.port2.onmessage = <span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="comment">// 在绘制之后被执行</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCallback) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = performance.now()</span><br><span class="line">    <span class="comment">// 通过now - startTime可以计算出requestAnimationFrame到绘制结束的执行时间</span></span><br><span class="line">    <span class="comment">// 通过这些数据来计算剩余时间</span></span><br><span class="line">    <span class="comment">// 另外还要处理超时(timeout)，避免任务被饿死</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRemain &amp;&amp; noTimeout) &#123;</span><br><span class="line">      pendingCallback(deadline)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleRequestIdleCallback</span>(<span class="params">callback, timeout</span>) </span>&#123;</span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">animation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在绘制之前被执行</span></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    startTime = performance.now()</span><br><span class="line">    timeout = timeout</span><br><span class="line">    dosomething()</span><br><span class="line">    <span class="comment">// 调度回调到绘制结束后执行</span></span><br><span class="line">    pendingCallback = callback</span><br><span class="line">    ch.port1.postMessage(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务优先级</strong></p><p>上面说了，为了避免任务被饿死，可以设置一个超时时间. <strong>这个超时时间不是死的，低优先级的可以慢慢等待, 高优先级的任务应该率先被执行</strong>. 目前 React 预定义了 5 个优先级, 这个我在[《谈谈React事件机制和未来(react-events)》]中也介绍过:</p><ul><li><code>Immediate</code>(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li><li><code>UserBlocking</code>(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li><code>Normal</code> (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li><li><code>Low</code> (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li><li><code>Idle</code> (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li></ul><h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>React 那为什么不使用 Generator？</p><p><strong>答: 太麻烦</strong></p><p>官方在<a href="https://github.com/facebook/react/issues/7942">《Fiber Principles: Contributing To Fiber》</a> 也作出了解答。主要有两个原因：</p><ol><li>Generator 不能在栈中间让出。比如你想在嵌套的函数调用中间让出, 首先你需要将这些函数都包装成Generator，另外这种栈中间的让出处理起来也比较麻烦，难以理解。除了语法开销，现有的生成器实现开销比较大，所以不如不用。</li><li>Generator 是有状态的, 很难在中间恢复这些状态。</li></ol><blockquote><p>上面理解可能有出入，建议看一下原文</p></blockquote><p>可能都没看懂，简单就是 React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。</p><h3 id="2-一个执行单元"><a href="#2-一个执行单元" class="headerlink" title="2. 一个执行单元"></a>2. 一个执行单元</h3><p>Fiber的另外一种解读是’纤维‘：<strong>这是一种数据结构或者说执行单元</strong>。我们暂且不管这个数据结构长什么样，<strong>将它视作一个执行单元，每次执行完一个’执行单元’,  React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</strong>.</p><p>上文说了，React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于’Fiber‘这个执行单元的，它的过程如下：</p><p>假设用户调用 <code>setState</code> 更新组件, 这个待更新的任务会先放入队列中, 然后通过 <code>requestIdleCallback</code> 请求浏览器调度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure><p>现在浏览器有空闲或者超时了就会调用<code>performWork</code>来执行任务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123;  // 2. 循环取出updateQueue中的任务  while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;    workLoop(deadline);  &#125;  // 3. 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度  if (updateQueue.length &gt; 0) &#123;    requestIdleCallback(performWork);  &#125;&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>workLoop</code> 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘<code>执行单元</code>‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个<code>执行单元</code>，反之则停止执行，保存现场，等下一次有执行权时恢复</strong>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>画个流程图吧！</p><img width = "65%" alt="" align=center src="/images/Fiber/16deed1711f281b3.png"/><h2 id="四、React-的Fiber改造"><a href="#四、React-的Fiber改造" class="headerlink" title="四、React 的Fiber改造"></a>四、React 的Fiber改造</h2><p>Fiber 的核心内容已经介绍完了，现在来进一步看看React 为 Fiber 架构做了哪些改造, 如果你对这部分内容不感兴趣可以跳过。</p><h3 id="1-数据结构的调整"><a href="#1-数据结构的调整" class="headerlink" title="1. 数据结构的调整"></a>1. 数据结构的调整</h3><img width = "65%" alt="" align=center src="/images/Fiber/16deecc72bc9a14c.png"/><p><em>左侧是Virtual DOM，右侧可以看作diff的递归调用栈</em></p><p>上文中提到 React 16 之前，Reconcilation 是同步的、递归执行的。也就是说这是基于函数’调用栈‘的Reconcilation算法，因此通常也称它为<code>Stack Reconcilation</code>. 你可以通过这篇文章<a href="https://juejin.im/post/6844903861434449933">《从Preact中了解React组件和hooks基本原理》</a> 来回顾一下历史。</p><p>栈挺好的，代码量少，递归容易理解, 至少比现在的 React Fiber架构好理解…, 递归非常适合树这种嵌套数据结构的处理。</p><p>只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理。 这种调用栈，不是程序所能控制的， 如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。</p><p>因此<strong>首先我们需要对React现有的数据结构进行调整，<a href="https://zhuanlan.zhihu.com/p/36425839"><code>模拟函数调用栈</code></a>, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代</strong>.</p><p>React 目前的做法是使用<code>链表</code>, 每个 VirtualDOM 节点内部现在使用 <code>Fiber</code>表示, 它的结构大概如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type Fiber = &#123;</span><br><span class="line">  <span class="comment">// Fiber 类型信息</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链表结构</span></span><br><span class="line">  <span class="comment">// 指向父节点，或者render该节点的组件</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向下一个兄弟节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图片来展示这种关系会更直观一些：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecc6db5530be.png"/><p><strong>使用链表结构只是一个结果，而不是目的，React 开发者一开始的目的是冲着模拟调用栈去的</strong>。这个很多关于Fiber 的文章都有提及, 关于调用栈的详细定义参见<a href="https://en.wikipedia.org/wiki/Call_stack">Wiki</a>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecc9a904099b.png"/><blockquote><p>调用栈最经常被用于存放子程序的<strong>返回地址</strong>。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。除了返回地址，还会保存<code>本地变量</code>、<code>函数参数</code>、<code>环境传递</code>(Scope?)</p></blockquote><p>React Fiber 也被称为虚拟栈帧(Virtual Stack Frame), 你可以拿它和函数调用栈类比一下, 两者结构非常像:</p><table><thead><tr><th></th><th>函数调用栈</th><th>Fiber</th></tr></thead><tbody><tr><td>基本单位</td><td>函数</td><td>Virtual DOM 节点</td></tr><tr><td>输入</td><td>函数参数</td><td>Props</td></tr><tr><td>本地状态</td><td>本地变量</td><td>State</td></tr><tr><td>输出</td><td>函数返回值</td><td>React Element</td></tr><tr><td>下级</td><td>嵌套函数调用</td><td>子节点(child)</td></tr><tr><td>上级引用</td><td>返回地址</td><td>父节点(return)</td></tr></tbody></table><p>Fiber 和调用栈帧一样, 保存了节点处理的上下文信息，因为是手动实现的，所以更为可控，我们可以保存在内存中，随时中断和恢复。</p><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 <code>performUnitOfWork</code> 的实现, 它其实就是一个深度优先的遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以配合上文的 <code>workLoop</code> 一起看，<strong>Fiber 就是我们所说的工作单元，<code>performUnitOfWork</code> 负责对 <code>Fiber</code> 进行操作，并按照深度遍历的顺序返回下一个 Fiber</strong>。</p><p><strong>因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的<code>Fiber</code>继续遍历下去</strong>。</p><p>整个迭代顺序和之前递归的一样, 下图假设在 <code>div.app</code> 进行了更新：</p><img width = "85%" alt="" align=center src="/images/Fiber/16deecca7850a24d.png"/><p><em>比如你在<code>text(hello)</code>中断了，那么下一次就会从 <code>p</code> 节点开始处理</em></p><p>这个数据结构调整还有一个好处，就是某些节点异常时，我们可以打印出完整的’节点栈‘，只需要沿着节点的<code>return</code>回溯即可。</p><h3 id="2-两个阶段的拆分"><a href="#2-两个阶段的拆分" class="headerlink" title="2. 两个阶段的拆分"></a>2. 两个阶段的拆分</h3><img width = "85%" alt="" align=center src="/images/Fiber/16deecd830671a70.png"/><p>如果你现在使用最新的 React 版本(v16), 使用 Chrome 的 Performance 工具，可以很清晰地看到每次渲染有两个阶段：<code>Reconciliation</code>(协调阶段) 和 <code>Commit</code>(提交阶段).</p><blockquote><p>我在之前的多篇文章中都有提及: <a href="https://juejin.im/post/6844903946016784392">《自己写个React渲染器: 以 Remax 为例(用React写小程序)》</a></p></blockquote><p>除了Fiber 工作单元的拆分，两阶段的拆分也是一个非常重要的改造，在此之前都是一边Diff一边提交的。先来看看这两者的区别:</p><ul><li><strong>协调阶段</strong>: 可以认为是 Diff 阶段, <strong>这个阶段可以被中断</strong>, 这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等, 这些变更React 称之为’<code>副作用</code>(Effect)’ . 以下生命周期钩子会在协调阶段被调用：<ul><li><code>constructor</code></li><li><code>componentWillMount</code> 废弃</li><li><code>componentWillReceiveProps</code> 废弃</li><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code> 废弃</li><li><code>render</code></li></ul></li><li><strong>提交阶段</strong>: 将上一个阶段计算出来的需要处理的<strong>副作用(Effects)<strong>一次性执行了。</strong>这个阶段必须同步执行，不能被打断</strong>. 这些生命周期钩子在提交阶段被执行:<ul><li><code>getSnapshotBeforeUpdate()</code> 严格来说，这个是在进入 commit 阶段前调用</li><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul></li></ul><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p><p>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，<strong>⚠️React 协调阶段的生命周期钩子可能会被调用多次!</strong>, 例如 <code>componentWillMount</code> 可能会被调用两次。</p><p>因此建议 <strong>协调阶段的生命周期钩子不要包含副作用</strong>. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如<code>componentWillMount</code>、<code>componentWillUpdate</code>. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</p><p>现在你应该知道为什么’提交阶段’必须同步执行，不能中断的吧？ 因为我们要正确地处理各种副作用，包括DOM变更、还有你在<code>componentDidMount</code>中发起的异步请求、useEffect 中定义的副作用… 因为有副作用，所以必须保证按照次序只调用一次，况且会有用户可以察觉到的变更, 不容差池。</p><p>关于为什么要拆分两个阶段，<a href="https://github.com/facebook/react/issues/13186#issuecomment-403959161">这里</a>有更详细的解释。</p><h3 id="3-Reconcilation"><a href="#3-Reconcilation" class="headerlink" title="3. Reconcilation"></a>3. Reconcilation</h3><p>接下来就是就是我们熟知的<code>Reconcilation</code>(为了方便理解，本文不区分Diff和Reconcilation, 两者是同一个东西)阶段了. <strong>思路和 Fiber 重构之前差别不大, 只不过这里不会再递归去比对、而且不会马上提交变更</strong>。</p><p>首先再进一步看一下<code>Fiber</code>的结构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">interface Fiber &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的类型信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span></span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 结构信息</span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 节点的状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 节点实例(状态)：</span></span><br><span class="line">  <span class="comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span></span><br><span class="line">  <span class="comment">//        对于类组件来说，这里保存类组件的实例</span></span><br><span class="line">  <span class="comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line">  <span class="comment">// 新的、待处理的props</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染的props</span></span><br><span class="line">  memoizedProps: any, <span class="comment">// The props used to create the output.</span></span><br><span class="line">  <span class="comment">// 上一次渲染的组件状态</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 副作用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line">  <span class="comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * ⚛️ 替身</span></span><br><span class="line"><span class="comment">   * 指向旧树中的节点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Fiber 包含的属性可以划分为 5 个部分:</p><ul><li><strong>结构信息</strong> - 这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位</li><li><strong>节点类型信息</strong> - 这个也容易理解，tag表示节点的分类、type 保存具体的类型值，如div、MyComp</li><li><strong>节点的状态</strong> - 节点的组件实例、props、state等，它们将影响组件的输出</li><li><strong>副作用</strong> - 这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的<code>effectTag</code> 中(想象为打上一个标记). 那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中React会将所有有‘副作用’的节点都通过<code>nextEffect</code>连接起来</li><li><strong>替身</strong> - React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，<strong>WIP树</strong>)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的<strong>旧树</strong>，React就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</li></ul><p>现在可以放大看看<code>beginWork</code>  是如何对 Fiber 进行比对的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宿主节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffHostComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新增节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.pendingProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类组件节点比对也差不多:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffClassComponent</span>(<span class="params">fiber: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.stateNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.stateNode = createInstance(fiber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.hasMounted) &#123;</span><br><span class="line">    <span class="comment">// 调用更新前生命周期钩子</span></span><br><span class="line">    applybeforeUpdateHooks(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用挂载前生命周期钩子</span></span><br><span class="line">    applybeforeMountHooks(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染新节点</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = fiber.stateNode.render();</span><br><span class="line">  <span class="comment">// 比对子节点</span></span><br><span class="line">  diffChildren(fiber, newChildren);</span><br><span class="line"></span><br><span class="line">  fiber.memoizedState = fiber.stateNode.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点比对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">fiber: Fiber, newChildren: React.ReactNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldFiber = fiber.alternate ? fiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 全新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber == <span class="literal">null</span>) &#123;</span><br><span class="line">    mountChildFibers(fiber, newChildren)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 新子节点</span></span><br><span class="line">  <span class="keyword">const</span> elements = extraElements(newChildren)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比对子元素</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length || oldFiber != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">const</span> sameType = isSameType(element, oldFiber)</span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = cloneFiber(oldFiber, element)</span><br><span class="line">      <span class="comment">// 更新关系</span></span><br><span class="line">      newFiber.alternate = oldFiber</span><br><span class="line">      <span class="comment">// 打上Tag</span></span><br><span class="line">      newFiber.effectTag = UPDATE</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新节点</span></span><br><span class="line">    <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = createFiber(element)</span><br><span class="line">      newFiber.effectTag = PLACEMENT</span><br><span class="line">      newFiber.return = fiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除旧节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      oldFiber.nextEffect = fiber.nextEffect</span><br><span class="line">      fiber.nextEffect = oldFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了.</p><p>这里引用一下<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Youtube: Lin Clark presentation in ReactConf 2017</a> 的Slide，来还原 Reconciliation 的过程. Lin Clark 这个演讲太经典了，几乎所有介绍 React Fiber 的文章都会引用它的Slide. 偷个懒，我也用下:</p><blockquote><p>这篇文章<a href="https://juejin.im/post/6844903582622285831">《React Fiber》</a> 用文字版解释了Link Clark Slide.</p></blockquote><img width = "65%" alt="" align=center src="/images/Fiber/16deecce3162b355.png"/><p>上图是 Reconciliation 完成后的状态，左边是旧树，右边是WIP树。对于需要变更的节点，都打上了’标签’。 在提交阶段，React 就会将这些打上标签的节点应用变更。</p><h3 id="4-双缓冲"><a href="#4-双缓冲" class="headerlink" title="4. 双缓冲"></a>4. 双缓冲</h3><p><code>WIP 树</code>构建这种技术类似于图形化领域的’<strong>双缓存(Double Buffering)</strong>‘技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。</p><p>放到React 中，WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。</p><p>双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。</p><p>Dan 在 <a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16</a> 演讲中用了一个非常恰当的比喻，那就是Git 功能分支，<strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong>:</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf3468b00b.png"/><h3 id="5-副作用的收集和提交"><a href="#5-副作用的收集和提交" class="headerlink" title="5. 副作用的收集和提交"></a>5. 副作用的收集和提交</h3><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在<code>completeWork</code>中做, 例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parent = fiber.return</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到达顶端</span></span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="literal">null</span> || fiber === topWork) &#123;</span><br><span class="line">    pendingCommit = fiber</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.effectTag != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.nextEffect) &#123;</span><br><span class="line">      parent.nextEffect.nextEffect = fiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.nextEffect = fiber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.nextEffect) &#123;</span><br><span class="line">    parent.nextEffect = fiber.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后了，将所有副作用提交了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>) </span>&#123;  <span class="keyword">let</span> next = fiber  <span class="keyword">while</span>(next) &#123;    <span class="keyword">if</span> (fiber.effectTag) &#123;      <span class="comment">// 提交，偷一下懒，这里就不展开了      commitWork(fiber)    &#125;    next = fiber.nextEffect  &#125;  // 清理现场  pendingCommit = nextUnitOfWork = topWork = null&#125;</span></span><br></pre></td></tr></table></figure><h2 id="五、中断和恢复"><a href="#五、中断和恢复" class="headerlink" title="五、中断和恢复"></a>五、中断和恢复</h2><p>上文只是介绍了简单的中断和恢复机制，我们从哪里跌倒就从哪里站起来，在哪个节点中断就从哪个节点继续处理下去。 也就是说，到目前为止：<strong>⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong>。我个人觉得这才是 React Fiber 中最难处理的一部分。</p><p><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务</strong>。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。</p><p><strong>但是如果不按顺序执行任务，可能会导致前后的状态不一致</strong>。 比如低优先级任务将 <code>a</code> 设置为0，而高优先级任务将 <code>a</code> 递增1, 两个任务的执行顺序会影响最终的渲染结果。因此<strong>要让高优先级任务插队, 首先要保证状态更新的时序</strong>。</p><p>解决办法是: <strong>所有更新任务按照顺序插入一个队列, 状态必须按照插入顺序进行计算，但任务可以按优先级顺序执行</strong>, 例如：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deeccf96dac168.png"/><p>红色表示高优先级任务。要计算它的状态必须基于前序任务计算出来的状态, 从而保证<strong>状态的最终一致性</strong>：</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd05f86b375.png"/><p>最终红色的高优先级任务 <code>C</code> 执行时的状态值是<code>a=5,b=3</code>. 在恢复控制权时，会按照优先级先执行 <code>C</code>, 前面的<code>A</code>、 <code>B</code>暂时跳过</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd121a8657a.png"/><p>上面被跳过任务不会被移除，在执行完高优先级任务后它们还是会被执行的。因为不同的更新任务影响的节点树范围可能是不一样的，举个例子 <code>a</code>、<code>b</code> 可能会影响 <code>Foo</code> 组件树，而 <code>c</code> 会影响 <code>Bar</code> 组件树。所以为了保证<strong>视图的最终一致性</strong>, 所有更新任务都要被执行。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd19b1362c0.png"/><p>首先 <code>C</code> 先被执行，它更新了 <code>Foo</code> 组件</p><p>接着执行 <code>A</code> 任务，它更新了<code>Foo</code> 和 <code>Bar</code> 组件，由于 <code>C</code> 已经以最终状态<code>a=5, b=3</code>更新了<code>Foo</code>组件，这里可以做一下性能优化，直接复用C的更新结果， 不必触发重新渲染。因此 <code>A</code> 仅需更新 <code>Bar</code> 组件即可。</p><p>接着执行 <code>B</code>，同理可以复用 Foo 更新结果。</p><p>道理讲起来都很简单，React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证<strong>状态的一致性</strong>和<strong>视图的一致性</strong>，这给了 React 团队很大的考验，以致于现在都没有正式release出来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img width = "35%" alt="" align=center src="/images/Fiber/16deecd21336ca41.jpg"/><p><em>同样来自Link Clark 的 Slider</em></p><p>前面说了一大堆，从操作系统进程调度、到浏览器原理、再到合作式调度、最后谈了React的基本改造工作, 地老天荒… 就是为了上面的小人可以在练就凌波微步, 它脚下的坑是浏览器的调用栈。</p><p>React 开启 <code>Concurrent Mode</code> 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。</p><img width = "65%" alt="" align=center src="/images/Fiber/16deecd2d4124b05.png"/><p><em>来源：<a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode?</a></em></p><p>开启 <code>Concurrent Mode</code> 后，我们可以得到以下好处(详见<a href="https://www.youtube.com/watch?v=ByBPyMBTzM0">Concurrent Rendering in React</a>):</p><ul><li>快速响应用户操作和输入，提升用户交互体验</li><li>让动画更加流畅，通过调度，可以让应用保持高帧率</li><li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。 比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。</li><li>用<code>Suspense</code> 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。</li></ul><p>但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的，开发者可以随心所欲，想挖多大的坑，就挖多大的坑。</p><p>为了共同创造美好的世界，我们要严律于己，该做的优化还需要做: 纯组件、虚表、简化组件、缓存…</p><p>尤雨溪在今年的<a href="https://www.yuque.com/vueconf/2019">Vue Conf</a>一个观点让我印象深刻：<strong>如果我们可以把更新做得足够快的话，理论上就不需要时间分片了</strong>。</p><p><strong>时间分片并没有降低整体的工作量，该做的还是要做</strong>, 因此React 也在考虑利用CPU空闲或者I/O空闲期间做一些预渲染。所以跟尤雨溪说的一样：React Fiber 本质上是为了解决 React 更新低效率的问题，<strong>不要期望 Fiber 能给你现有应用带来质的提升, 如果性能问题是自己造成的，自己的锅还是得自己背</strong>.</p><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><p>本文之所以能成文，离不开社区上优质的开源项目和资料。</p><p><strong>迷你 Fiber 实现：</strong></p><p>React 现在的代码库太复杂了! 而且一直在变动和推翻自己，<a href="https://www.zhihu.com/people/he-shi-jun">Hax</a> 在 <a href="https://www.zhihu.com/question/270428598/answer/354017709">《为什么社区里那些类 React 库至今没有选择实现 Fiber 架构？》 </a> 就开玩笑说: Fiber 性价比略低… 到了这个阶段，竞品太多，facebook 就搞一个 fiber 来作为护城河……</p><p>这种工程量不是一般团队能Hold住的， 如果你只是想了解 Fiber，去读 React 的源码性价比也很低，不妨看看这些 Mini 版实现, 感受其精髓，不求甚解:</p><ul><li><a href="https://github.com/RubyLouvre/anu">anu</a> <a href="https://github.com/RubyLouvre">司徒正美</a> 开发的类React框架</li><li><a href="https://github.com/132yse/fre">Fre</a> <a href="https://www.zhihu.com/people/132yse">伊撒尔</a> 开发的类React框架，代码很精简⁉️</li><li><a href="https://github.com/Foveluy/Luy">Luy</a></li><li><a href="https://github.com/pomber/didact">didact</a></li></ul><p><strong>优秀的文章 &amp; 演讲：</strong></p><p>本文只是对React Fiber进行了简单的科普，实际上React 的实现比本文复杂的多。如果你想深入理解React Fiber的，下面这些文章不容错过:</p><ul><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 👍🎦</a> React Fiber 启蒙，YouTube</li><li><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">Beyond React 16 - Dan Abramov 👍🎦</a></li><li><a href="https://www.youtube.com/watch?v=ByBPyMBTzM0&t=151s">Concurrent Rendering in React - Andrew Clark and Brian Vaughn 👍🎦</a></li><li><a href="https://zhuanlan.zhihu.com/p/37095662">司徒正美: React Fiber架构 👍</a> 看不如写</li><li><a href="https://www.zhihu.com/people/NE_SmallTown/posts">展望 React 17，回顾 React 往事 👍</a> 看完 <a href="https://www.zhihu.com/people/NE_SmallTown">Heaven</a> 的相关文章，会觉得你了解的React 知识真的只是<a href="https://zhuanlan.zhihu.com/jheaven">冰山一角</a>，我们都没资格说我们懂 React。</li><li><a href="https://zhuanlan.zhihu.com/p/36425839">浅入 React16/fiber 系列 👍</a> 同样来自 Heaven</li><li><a href="https://www.zhihu.com/search?type=content&q=requestIdleCallback">淡苍：深入剖析 React Concurrent 👍</a></li><li><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">Didact Fiber: Incremental reconciliation  👍</a> 实现了简单的 React Fiber</li><li><a href="https://zhuanlan.zhihu.com/p/26027085">程墨: React Fiber是什么</a></li><li><a href="https://zhuanlan.zhihu.com/p/57346388">译 深入React fiber架构及源码</a></li><li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/">黯羽轻扬: 完全理解React Fiber</a></li><li><a href="https://github.com/facebook/react/issues/7942">Fiber Principles: Contributing To Fiber</a></li><li><a href="https://philippspiess.com/scheduling-in-react/">Scheduling in React</a></li><li><a href="https://juejin.im/post/6844903874692661255">桃翁: Deep In React 之浅谈 React Fiber 架构（一）</a></li><li><a href="https://juejin.im/post/6844903608488558599#heading-12">为 Luy 实现 React Fiber 架构</a></li><li><a href="https://juejin.im/post/6844903582622285831">妖僧风月: React Fiber</a></li><li><a href="https://www.youtube.com/watch?v=V1Ly-8Z1wQA&t=207s">Flarnie Marchan - Ready for Concurrent Mode? 🎦</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering">Web Fundamentals &gt; Performance</a></li><li><a href="https://juejin.im/post/6844903592831238157">你应该知道的requestIdleCallback</a></li><li><a href="https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/">深入探究 eventloop 与浏览器渲染的时序问题</a></li><li><a href="https://nolanlawson.com/2018/09/25/accurately-measuring-layout-on-the-web/">Accurately measuring layout on the web</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903975112671239#heading-13&quot;&gt;原文链接&lt;/a&gt; Fiber 不是一个新的东西，来看一下单处理进程调度&lt;/p&gt;
&lt;h2 id=&quot;一、单处理器进程调度&quot;&gt;&lt;a href=&quot;#一、单</summary>
      
    
    
    
    <category term="React" scheme="https://tenloy.github.io/categories/React/"/>
    
    
    <category term="Fiber" scheme="https://tenloy.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>[转]什么是协程</title>
    <link href="https://tenloy.github.io/2021/05/27/08_Coroutine/"/>
    <id>https://tenloy.github.io/2021/05/27/08_Coroutine/</id>
    <published>2021-05-27T10:42:19.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p><strong>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</strong></p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;z&#x27;</span></span><br></pre></td></tr></table></figure><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但<strong>协程的特点在于是一个线程执行</strong>，那和多线程比，协程有何优势？</p><ul><li><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p></li><li><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p></li></ul><p><strong>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</strong></p><p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.<span class="built_in">next</span>()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure><p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p><ol><li>首先调用c.next()启动生成器；</li><li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li><li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li><li>produce拿到consumer处理的结果，继续生产下一条消息；</li><li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li></ol><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><p>“子程序就是协程的一种特例。”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/p&gt;
&lt;p&gt;协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。&lt;/p&gt;
&lt;p&gt;子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="协程" scheme="https://tenloy.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>常见的编程范式知识点汇总</title>
    <link href="https://tenloy.github.io/2021/04/30/07_Common-Programming-Paradigm/"/>
    <id>https://tenloy.github.io/2021/04/30/07_Common-Programming-Paradigm/</id>
    <published>2021-04-30T18:10:23.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、结构化编程"><a href="#一、结构化编程" class="headerlink" title="一、结构化编程"></a>一、结构化编程</h3><blockquote><p>一种编程典范(编程范式)。它采用子程序、块结构、for循环以及while循环等结构，来取代传统的 goto。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><ul><li>“面向结构”的程序设计方法即结构化程序设计方法，是“面向过程”方法的改进，结构上将软件系统划分为若干功能模块，各模块按要求单独编程，再由各模块连接，组合构成相应的软件系统。</li><li>结构化程序设计采用自顶向下、逐步求精的设计方法，各个模块通过“顺序、选择、循环”的控制结构进行连接，并且只有一个入口、一个出口。</li></ul><p>数据结构化：所谓结构化，是指将逐渐积累起来的知识加以归纳和整理，使之条理化、纲领化，做到纲举目张</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、结构化编程&quot;&gt;&lt;a href=&quot;#一、结构化编程&quot; class=&quot;headerlink&quot; title=&quot;一、结构化编程&quot;&gt;&lt;/a&gt;一、结构化编程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一种编程典范(编程范式)。它采用子程序、块结构、for循环以及while循</summary>
      
    
    
    
    <category term="编程范式" scheme="https://tenloy.github.io/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的工程化</title>
    <link href="https://tenloy.github.io/2021/04/29/06_Corss-Platform/"/>
    <id>https://tenloy.github.io/2021/04/29/06_Corss-Platform/</id>
    <published>2021-04-29T19:43:56.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、工程化"><a href="#一、工程化" class="headerlink" title="一、工程化"></a>一、工程化</h2><h3 id="2-1-几个概念"><a href="#2-1-几个概念" class="headerlink" title="2.1 几个概念"></a>2.1 几个概念</h3><p>工程</p><blockquote><p>泛指某项需要投入巨大人力和物力的工作。</p></blockquote><blockquote><p>工程是科学和数学的某种应用，通过这一应用，使自然界的物质和能源的特性能够通过各种结构、机器、产品、系统和过程，是以最短的时间和最少的人力、物力做出高效、可靠且对人类有用的东西。</p></blockquote><p>软件工程</p><blockquote><p>应用计算机科学、数学及管理科学等原理，以工程化方法制作软件的工程。它借鉴传统工程的原则、方法，创建软件以达到提高质量，降低成本的目的。</p></blockquote><p>软件工程是一门指导计算机软件开发和维护的工程学科。是一门交叉性学科(需要用到多种学科的方法支持和指导)，如：</p><ul><li>计算机科学、数学用于构造模型与算法</li><li>工程科学用于制定规范、设计范型、评估成本及确定权衡</li><li>管理科学用于计划、资源、质量、成本等管理</li></ul><h3 id="2-2-平时所提到的工程化"><a href="#2-2-平时所提到的工程化" class="headerlink" title="2.2 平时所提到的工程化"></a>2.2 平时所提到的工程化</h3><h2 id="三、容器化与动态化"><a href="#三、容器化与动态化" class="headerlink" title="三、容器化与动态化"></a>三、容器化与动态化</h2><p>移动动态化：移动指的是移动端，包括安卓、iOS。动态化则是动态部署和逻辑下发到客户端的能力。移动动态最好的状态就是让移动应用和 Web 一样，想发就发！</p><p>动态化的收益</p><p>动态化是整个外卖业务的发展方向。提单页的动态化建立在容器化的基础之上，在完成容器化之后，就具备了动态化的基础。当前提单页的动态化，所指的主要是模块层级的动态化，提单页的各模块展示顺序、展示与否，都可以完全由根据服务端下发的数据决定，各模块可以自由地进行组合、拼装，实现提单页的动态配置。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件：通俗点就是组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件。<br>      组件的出现是为了解决全局工程中有很多重复代码的问题，是为了复用，而且划分力度是相对较小的模块。<br>      组件化的另一个目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</p><p>插件：可以理解为是封装了一层对外调用的接口的组件。<br>      插件的概念比较形象，一般存在一个“插拔”过程，所以要求可插拔的插件有一个相同的接口(这里所说的接口只是概念上的接口，即调用方法及参数等)。而组件是不存在这个相同接口的。</p><p>插件和组件的实质区别就在于通过统一接口隔绝业务代码对于组件的直接依赖，</p><p>模块：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。<br>      将一个大的系统模块化之后，每个模块都可以被高度复用。<br>      但是值得注意的是模块不等于功能，二者的关系大概为：功能 &gt; 模块一个功能可能包含多个模块。</p><p>组件和模块的实质区别在于：组件化开发是纵向分层，模块化开发是横向分块。模块化并没有要求一定组件化，就是说进行模块化拆分时你可以完全不考虑代码重用，只是把同一业务的代码做内聚整合成不同的模块。只不过这样得到的成果相对简单，我们一般不会这样而已。</p><p>总结<br>组件：代码重用，功能相对单一或者独立，无统一接口。组件化开发的成果是基础库和公共组件。<br>插件：近乎组件，有统一接口，可以说是封装了一层对外调用的接口的组件。<br>模块：高内聚，松耦合，功能相对复杂，有多个统一接口。模块化开发的基础是框架。<br>首先，可以肯定的是，组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</p><p>而且如果大的组件也可以称为模块，小的模块也可以称为组件，所以，在我看来组件和模块的划分并没有那么的泾渭分明。随意两者的粒度的大小改变，两者是可以转换的。</p><p>最后说一下，这三个概念是经常同时出现在一个项目中的，我们往往对复杂大项目进行模块化划分的时候，也会进行组件化，而且插件化的本质是面向接口编程，对于组件化和模块化都是适用的，可实现随意插拔的灵活和高扩展性，属于项目架构的高端设计。</p><p><a href="https://cloud.tencent.com/developer/article/1336167">https://cloud.tencent.com/developer/article/1336167</a><br><a href="http://tutuge.me/2016/03/29/modular-and-component-summary/">http://tutuge.me/2016/03/29/modular-and-component-summary/</a></p><h2 id="一、容器化"><a href="#一、容器化" class="headerlink" title="一、容器化"></a>一、容器化</h2><p>容器化、跨平台到底是不是一回事？</p><p>不是，跨平台是实现效果，容器化是一种软件开发方法，其可以实现跨平台，但不仅仅是跨平台</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、工程化&quot;&gt;&lt;a href=&quot;#一、工程化&quot; class=&quot;headerlink&quot; title=&quot;一、工程化&quot;&gt;&lt;/a&gt;一、工程化&lt;/h2&gt;&lt;h3 id=&quot;2-1-几个概念&quot;&gt;&lt;a href=&quot;#2-1-几个概念&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="工程化" scheme="https://tenloy.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>[转]Docker入门教程</title>
    <link href="https://tenloy.github.io/2021/04/29/05_Dock-Reprinted-from-RuanYIFeng/"/>
    <id>https://tenloy.github.io/2021/04/29/05_Dock-Reprinted-from-RuanYIFeng/</id>
    <published>2021-04-29T14:42:44.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">原文链接 — 《Docker 入门教程》</a></p><p>2013年发布至今， <a href="https://www.docker.com/">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p><p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p><img src='/images/Docker/docker_logo.png' width = '60%'><h2 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h2><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h2 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h2><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h2 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h2><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h2><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h2><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h2 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h2><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><blockquote><ul><li><a href="https://docs.docker.com/docker-for-mac/install/">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/">Windows</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/debian/">Debian</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/fedora/">Fedora</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/binaries/">其他 Linux 发行版</a></li></ul></blockquote><p>安装完成后，运行下面的命令，验证是否安装成功。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure></blockquote><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></blockquote><p>Docker 是服务器—-客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/">官方文档</a>）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、image-文件"><a href="#六、image-文件" class="headerlink" title="六、image 文件"></a>六、image 文件</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure></blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h2 id="七、实例：hello-world"><a href="#七、实例：hello-world" class="headerlink" title="七、实例：hello world"></a>七、实例：hello world</h2><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/">hello world”</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href="https://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure></blockquote><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><p>现在，运行这个 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure></blockquote><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure></blockquote><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/"><code>docker container kill</code></a> 命令手动终止。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、容器文件"><a href="#八、容器文件" class="headerlink" title="八、容器文件"></a>八、容器文件</h2><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/"><code>docker container rm</code></a>命令删除。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id="九、Dockerfile-文件"><a href="#九、Dockerfile-文件" class="headerlink" title="九、Dockerfile 文件"></a>九、Dockerfile 文件</h2><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h2 id="十、实例：制作自己的-Docker-容器"><a href="#十、实例：制作自己的-Docker-容器" class="headerlink" title="十、实例：制作自己的 Docker 容器"></a>十、实例：制作自己的 Docker 容器</h2><p>下面我以 <a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip">下载源码</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-1-编写-Dockerfile-文件"><a href="#10-1-编写-Dockerfile-文件" class="headerlink" title="10.1 编写 Dockerfile 文件"></a>10.1 编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></blockquote><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="10-2-创建-image-文件"><a href="#10-2-创建-image-文件" class="headerlink" title="10.2 创建 image 文件"></a>10.2 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-3-生成容器"><a href="#10-3-生成容器" class="headerlink" title="10.3 生成容器"></a>10.3 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p>上面命令的各个参数含义如下：</p><blockquote><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></blockquote><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure></blockquote><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-4-CMD-命令"><a href="#10-4-CMD-命令" class="headerlink" title="10.4 CMD 命令"></a>10.4 CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure></blockquote><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure></blockquote><h3 id="10-5-发布-image-文件"><a href="#10-5-发布-image-文件" class="headerlink" title="10.5 发布 image 文件"></a>10.5 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/">hub.docker.com</a> 或 <a href="https://cloud.docker.com/">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></blockquote><p>接着，为本地的 image 标注用户名和版本。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure></blockquote><p>也可以不标注用户名，重新构建一下 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure></blockquote><p>最后，发布 image 文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure></blockquote><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="十一、其他有用的命令"><a href="#十一、其他有用的命令" class="headerlink" title="十一、其他有用的命令"></a>十一、其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure></blockquote><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure></blockquote><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure></blockquote><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot;&gt;原文链接 — 《Docker 入门教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2013年发布至今， &lt;a href=&quot;https://www.do</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
    <category term="Docker" scheme="https://tenloy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>常见的容器概念：Linux容器、Docker容器、服务器容器</title>
    <link href="https://tenloy.github.io/2021/04/28/04_Containers/"/>
    <id>https://tenloy.github.io/2021/04/28/04_Containers/</id>
    <published>2021-04-28T15:10:28.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>汉语释义：</p><blockquote><p>容器(Container)是一种基础工具。泛指任何可以用于容纳其它物品的工具。</p></blockquote><p>容器的特性：</p><ul><li><p>可以部分或完全封闭。— 隔离性</p></li><li><p>被用于容纳、储存、运输物品。 — 便携性、换到程序的概念就是可移植性</p></li><li><p>物体可以被放置在容器中，而容器则可以保护内容物。— 安全</p></li></ul><h2 id="二、Linux容器与Docker容器"><a href="#二、Linux容器与Docker容器" class="headerlink" title="二、Linux容器与Docker容器"></a>二、Linux容器与Docker容器</h2><h3 id="2-1-诞生背景—环境配置的难题"><a href="#2-1-诞生背景—环境配置的难题" class="headerlink" title="2.1 诞生背景—环境配置的难题"></a>2.1 诞生背景—环境配置的难题</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><h3 id="2-2-虚拟机"><a href="#2-2-虚拟机" class="headerlink" title="2.2 虚拟机"></a>2.2 虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p><p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p><p><strong>（1）资源占用多</strong></p><p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p><p><strong>（2）冗余步骤多</strong></p><p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p><p><strong>（3）启动慢</strong></p><p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="2-3-Linux容器"><a href="#2-3-Linux容器" class="headerlink" title="2.3 Linux容器"></a>2.3 Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><h4 id="2-3-1-定义"><a href="#2-3-1-定义" class="headerlink" title="2.3.1 定义"></a>2.3.1 定义</h4><ul><li><p>Linux 容器技术能够让您对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。 —  <a href="https://www.redhat.com/zh/topics/containers">Red Hat官网</a></p></li><li><p>容器是包含在任何环境中运行所需的所有元素的软件包。是轻量级应用代码包，还包含了依赖项，例如编程语言运行时的特定版本和运行软件服务所需的库。 —  <a href="https://cloud.google.com/learn/what-are-containers?hl=zh-cn#section-1"> Google Cloud官网</a></p></li><li><p>Linux 容器，又称Linux软件容器，是一种操作系统层虚拟化技术，为Linux内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库。</p><p>Linux 容器透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。— <a href="https://zh.wikipedia.org/wiki/LXC">维基百科</a></p></li></ul><p>总之：容器就是代码/应用程序+运行时环境</p><p>LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境。</p><p>容器虚拟化操作系统，可以在任何地方运行，不管目标环境是私有数据中心、公有云，还是开发者的个人笔记本电脑。</p><p>容器也是保障 IT 安全的一个重要组成部分。将安全性内置于容器管道，可以为基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</p><h4 id="2-3-2-优势"><a href="#2-3-2-优势" class="headerlink" title="2.3.2 优势"></a>2.3.2 优势</h4><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>由于容器是进程级别的，相比虚拟机有很多优势。</p><p><strong>（1）启动快</strong></p><p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p><p><strong>（2）资源占用少</strong></p><p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p><p><strong>（3）体积小</strong></p><p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p><p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><p>LXC的使用：</p><ul><li><p>Proxmox VE: 它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术。</p></li><li><p>Docker：它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境。</p><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></li></ul><h3 id="2-4-Docker容器"><a href="#2-4-Docker容器" class="headerlink" title="2.4 Docker容器"></a>2.4 Docker容器</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></p><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><ul><li>最初实现是基于 LXC</li><li>从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer</li><li>从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。</li></ul><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby">GitHub 项目</a> 已经超过 6 万 多个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，dotCloud 公司决定改名为 Docker。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><h4 id="2-4-2-用途"><a href="#2-4-2-用途" class="headerlink" title="2.4.2 用途"></a>2.4.2 用途</h4><p>Docker 的主要用途，目前有三大类。</p><p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h4 id="2-4-3-镜像Image"><a href="#2-4-3-镜像Image" class="headerlink" title="2.4.3 镜像Image"></a>2.4.3 镜像Image</h4><p>镜像Image于Docker容器（本质上还是程序与进程的区别？）</p><h5 id="1-引自Docker网站"><a href="#1-引自Docker网站" class="headerlink" title="1) 引自Docker网站"></a>1) 引自Docker网站</h5><p>镜像/映像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器映像</strong>：包含创建容器所需的所有依赖项和信息的包。 映像包括所有依赖项（例如框架），以及容器运行时使用的部署和执行配置。 通常情况下，映像派生自多个基础映像，这些基础映像是堆叠在一起形成容器文件系统的层。 创建后，映像不可变。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><h5 id="2-引自阮一峰"><a href="#2-引自阮一峰" class="headerlink" title="2) 引自阮一峰"></a>2) 引自阮一峰</h5><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h3 id="2-5-容器与虚拟机的区别"><a href="#2-5-容器与虚拟机的区别" class="headerlink" title="2.5 容器与虚拟机的区别"></a>2.5 容器与虚拟机的区别</h3><p>虚拟机：一种运行在主机操作系统之上，可以访问底层硬件的客机操作系统，例如Linux 或 Windows。</p><p>容器常常被拿来和虚拟机 (VM) 比较。与虚拟机相似，容器也可以让您将应用与库和其他依赖项打包，提供独立环境来运行您的软件服务。</p><p>但是两者的相似性仅此而已，因为容器为开发者和 IT 运营团队提供了更加轻型、具有众多优势的运营单元。</p><ul><li>容器比虚拟机更加轻量化</li><li>容器在操作系统级别进行虚拟化，而虚拟机在硬件级别进行虚拟化</li><li>容器共享操作系统内核，其占用的内存与虚拟机相比微乎其微</li></ul><h3 id="2-6-容器化的优势"><a href="#2-6-容器化的优势" class="headerlink" title="2.6 容器化的优势"></a>2.6 容器化的优势</h3><p>容器化是软件开发的一种方法，通过该方法可将应用程序或服务、其依赖项及其配置（抽象化为部署清单文件）一起打包为容器映像。容器化应用程序可以作为一个单元进行测试，并可以作为容器映像实例部署到主机操作系统 (OS)。 <a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/">参考链接</a></p><p>容器在整个应用程序生命周期工作流中提供以下优点：</p><ul><li><p><strong>责任分离</strong>：容器化使开发者和 IT 运营团队的责任泾渭分明，开发者专注于应用逻辑和依赖项，而 IT 运营团队可以专注于部署和管理，不必为应用细节分心，例如具体的软件版本和配置。</p></li><li><p><strong>工作负载可移植性</strong>：</p><ul><li>软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。 按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境。</li><li>容器几乎能在任何地方运行，极大减轻了开发和部署工作量：在 Linux、Windows 和 Mac 操作系统中；在虚拟机或物理服务器上；在开发者的机器或本地数据中心的机器上；当然还有在公有云上。</li><li>就像船只、火车或卡车运输集装箱而不管其内部是什么货物一样。</li></ul></li><li><p><strong>应用隔离/隔离性</strong>：容器会在操作系统级别虚拟化 CPU、内存、存储和网络资源，为开发者提供在逻辑上与其他应用相隔离的操作系统接口，即在共享 OS 上将应用程序彼此隔离开。</p></li><li><p><strong>灵活性</strong>：轻量级。容器化应用程序在容器主机上运行，而容器主机在 OS（Linux 或 Windows）上运行。 因此，容器的占用比虚拟机 (VM) 映像小得多。</p><p>每个容器可以运行整个 Web 应用或服务，如下图所示，在一个容器主机上运行多个容器。 在此示例中，Docker 主机是容器主机，而 App1、App2、Svc 1 和 Svc 2 是容器化应用程序或服务。</p></li></ul><img src = '/images/Docker/multiple-containers-single-host.png' width = '50%'><ul><li><p><strong>可伸缩性</strong>：通过为短期任务创建新容器，可以快速扩大。 从应用程序的角度来看，实例化映像（创建容器）类似于实例化 服务或 Web 应用等进程。 </p><p>但出于可靠性考虑，在多个主机服务器上运行同一映像的多个实例时，通常要使每个容器（映像实例）在不同容错域中的不同主机服务器或 VM 中运行。</p></li></ul><h2 id="三、服务器与容器"><a href="#三、服务器与容器" class="headerlink" title="三、服务器与容器"></a>三、服务器与容器</h2><h3 id="3-1-服务器-server"><a href="#3-1-服务器-server" class="headerlink" title="3.1 服务器(server)"></a>3.1 服务器(server)</h3><p>服务器(server)指：<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></p><ul><li><p>一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</p></li><li><p>运行以上软件的计算机，或称为网络主机（host）。通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。</p></li></ul><p>有时，这两种定义会引起混淆。如网页服务器：</p><ul><li>它可能是指用于网站的计算机。</li><li>也可能是指像Apache这样的软件，运行在这样的计算机上以管理网页组件和回应网页浏览器的请求。</li></ul><p>根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，Web服务器等。</p><h4 id="3-1-1-作为硬件"><a href="#3-1-1-作为硬件" class="headerlink" title="3.1.1 作为硬件"></a>3.1.1 作为硬件</h4><p>服务器与PC机的不同点很多：</p><ul><li>服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。</li><li>服务器通常以网络作为介质，既可以通过内部网对内提供服务，也可以通过互联网对外提供服务。所以PC机在一个时刻通常只为一个用户服务。而服务器能够通过网络同时提供给多个用户使用</li><li>和普通的个人电脑相比， 服务器需要连续的工作在7×24小时环境。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</li></ul><h4 id="3-1-2-作为软件"><a href="#3-1-2-作为软件" class="headerlink" title="3.1.2 作为软件"></a>3.1.2 作为软件</h4><p>服务器软件工作在客户端-服务器或浏览器-服务器的方式，有很多形式的服务器，常用的包括：</p><ul><li><p>文件服务器(file server)或网络存储设备(network attached storage)</p></li><li><p>数据库服务器(database server) —— 如Oracle数据库服务器，MySQL，MariaDB，PostgreSQL，Microsoft SQL Server，MongoDB，Redis等；</p></li><li><p>应用程序服务器(application server/AP server)</p><ul><li><strong>运行应用程序，提供应用程序所实现服务</strong>。通常来说，<strong>服务器端的应用程序实现各种业务逻辑，应用服务器通过各种协议把这些业务逻辑曝露给客户端的程序</strong>。它提供了访问业务逻辑的途径，以供客户端应用程序使用。应用服务器使用此业务逻辑就像调用对象的一个方法一样。</li><li>如Bea公司的WebLogic、JBoss、Sun的GlassFish，及Tomcat、Jetty、Websphere、JBoss等都是Java EE WEB应用服务器/<strong>Java EE服务器</strong><ul><li>Java EE服务器是实现Java EE技术规范，并提供标准Java EE服务的应用程序服务器。</li><li>Java EE服务器有时称为应用服务器，因为它们允许您向客户端提供应用数据，就像Web服务器向Web浏览器提供Web页面一样。</li></ul></li></ul></li><li><p>网页服务器(Web server) </p><ul><li>WEB：现广泛译作网络、互联网等技术领域。表现为三种形式，即<strong>超文本（hypertext）、超媒体（hypermedia）、超文本传输协议（HTTP）</strong>等。</li><li>Web server可以向浏览器等WEB客户端提供文档浏览、数据文件下载等WEB服务。</li><li>如Apache、lighttpd、nginx、微软的IIS等；</li></ul></li><li><p>FTP服务器（FTP server）—— Pureftpd、Proftpd、WU-ftpd、Serv-U、vs-ftpd等；</p></li><li><p>邮件服务器(mail server)</p></li><li><p>域名服务器（DNS server）—— 如BIND等</p></li><li><p>代理服务器（proxy server）—— 如Squid cache</p></li><li><p>其他，如Active Directory服务器、Minecraft游戏服务器等</p></li><li><p>补充：WEB应用服务器</p><ul><li><p>上面我们把应用服务器和WEB服务器严格区分：应用服务器通过应用程序接口(通常是网络请求API）把业务逻辑暴露给客户端应用程序。而WEB服务器通过HTTP提供静态内容给浏览器等客户端。</p><p>如果不严格区分，应用服务器包含WEB服务器，因为WEB服务器是WEB服务应用程序实现的。</p></li><li><p>WEB应用服务器：结合应用服务器和WEB服务器，可以说，它是带应用服务器的Web服务器，接收HTTP请求后，既能返回页面等静态内容，又能处理业务逻辑返回数据。</p></li></ul></li></ul><img src = '/images/Docker/servers.jpg' width = '70%' align:left style='margin-left:10%'><h3 id="3-2-容器"><a href="#3-2-容器" class="headerlink" title="3.2 容器"></a>3.2 容器</h3><p>如果说Linux、Docker容器是装满物体的容器：应用/服务程序 + 运行时环境</p><p>那么服务器中说的容器就是纯指未装物体的容器：运行时环境 — <strong>可以部署应用程序，使其在上面运行的环境</strong>。</p><img src = '/images/Docker/container_server.jpg' width = '50%' align:left style='margin-left:10%'><p>容器是服务器中位于应用程序/组件和平台之间的<code>接口集合</code>。它处理屏蔽了服务器平台的复杂性(如线程安全、事务、网络、资源等细节)，使得应用程序在它的基础上可以方便快捷的部署。<a href="https://zh.wikipedia.org/zh-hans/Web%E5%AE%B9%E5%99%A8">Web容器</a></p><ul><li><p>容器管理组件的生命周期，向应用程序组件分派请求，并提供与上下文数据（如关于当前请求的信息）的接口。</p></li><li><p>容器一般位于服务器之内，由服务器负责加载和维护。一个容器只能存在于一个服务器之内，一个服务器可以创建和维护多个容器。</p></li><li><p>容器一般遵守可配置的原则，即容器的用户可以通过对容器参数的配置，来达到自己的使用需求，而不需要修改容器的代码。</p></li></ul><p>根据接口实现的规范、用途不同，常见的分类有：</p><img src = '/images/Docker/containers.jpg' width = '70%' align:left style='margin-left:10%'><h4 id="3-2-1-Servlet容器"><a href="#3-2-1-Servlet容器" class="headerlink" title="3.2.1 Servlet容器"></a>3.2.1 Servlet容器</h4><p>Servlet：属于Java EE重要技术规范，构建了”接收请求–调用servlet程序处理–返回响应”基本模型。</p><p>Servlet程序：Java提供了开发Servlet程序的API，该API可以说Servlet容器的一部分，它对接应用程序与Servlet容器；</p><p>Servlet容器：就是<strong>实现了Servlet</strong>技术规范的部署环境，它可以部署运行Servlet程序。</p><h4 id="3-2-2-Java-WEB容器"><a href="#3-2-2-Java-WEB容器" class="headerlink" title="3.2.2 Java WEB容器"></a>3.2.2 Java WEB容器</h4><p>WEB容器：可以部署多个WEB应用程序的环境。</p><p>Java WEB容器：<strong>实现了Java EE</strong>规定的WEB应用技术规范的的部署环境。</p><p>Java EE WEB应用技术规范：Servlet、JSP（JavaServer Pages）、Java WebSocket等。</p><p>所以，完整的<strong>Java WEB</strong>容器包含Servlet容器。</p><h4 id="3-2-3-Java-EE容器"><a href="#3-2-3-Java-EE容器" class="headerlink" title="3.2.3 Java EE容器"></a>3.2.3 Java EE容器</h4><p>Java EE容器：实现了Java EE技术规范的部署环境。</p><p>Java EE技术规范：除了上面说的Servlet、JSP等Java EE WEB应用技术规范，还包括EJB（Enterprise JavaBeans）等许多技术规范。</p><p>所以，<strong>完整的Java EE</strong>容器包含Java WEB容器（Servlet容器）、EJB容器等。</p><h3 id="3-3-举例说明容器与服务器的联系"><a href="#3-3-举例说明容器与服务器的联系" class="headerlink" title="3.3 举例说明容器与服务器的联系"></a>3.3 举例说明容器与服务器的联系</h3><blockquote><p>服务器是指管理资源并为用户提供服务的计算机软件，或运行该软件的硬件设备。</p></blockquote><blockquote><p>容器是对服务器平台上接口的一层上层封装，屏蔽一些复杂性，提供简化版的接口。使得程序可以在其上快捷的开发和部署运行。</p></blockquote><h4 id="3-3-1-Apache、Nginx、IIS"><a href="#3-3-1-Apache、Nginx、IIS" class="headerlink" title="3.3.1 Apache、Nginx、IIS"></a>3.3.1 Apache、Nginx、IIS</h4><p>Apache、Nginx、IIS是目前主流的三个Web服务器。</p><p>但是可以用它们来构建WEB应用服务器，通常它们发现一个请求是动态请求，就通过CGI、ISAPI、特殊管道等协议接口调用后面的应用服务器来协同处理请求。如Nginx通过fastCGI模块来调用ZendEngine执行PHP应用来处理PHP请求。</p><h4 id="3-3-2-Tomcat及常见的JavaEE应用服务器"><a href="#3-3-2-Tomcat及常见的JavaEE应用服务器" class="headerlink" title="3.3.2 Tomcat及常见的JavaEE应用服务器"></a>3.3.2 Tomcat及常见的JavaEE应用服务器</h4><p>Tomcat、Jetty、WebLogic、Websphere、JBoss都是Java（EE） WEB应用服务器。</p><p>Tomcat</p><ul><li>按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）、Java Expression Language 和 Java WebSocket（Java EE）技术的支持。并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。</li><li>因为实现了Servlet规范，所以可以称为是一个Servlet容器，可以运行Servlet程序</li><li>由于Tomcat本身也内含了HTTP服务器，可以通过HTTP提供HTML页面等静态内容的请求访问，因此也可以视作是一个Web服务器。</li><li>因为可以通过Servlet容器，调用Servlet处理动态请求，所以也是一个应用服务器；</li></ul><p>所以，可以说Tomcat是Java（EE） WEB应用服务器。</p><p>注意，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><p>Tomcat提供了一个Jasper编译器用以将JSP编译成对应的Servlet。</p><p>Tomcat的Servlet引擎通常与Apache或者其他Web服务器一起工作。除了用于开发过程中的调试以及那些对速度和事务处理只有很小要求的用户，很少会将Tomcat单独作为Web服务器。但随着版本的更新，正有越来越多的用户将其单独作为Web服务器用以那些对速度和可靠性有较高要求的环境中。</p><h4 id="3-3-3-Nginx-Tomcat的WEB应用服务器-集群"><a href="#3-3-3-Nginx-Tomcat的WEB应用服务器-集群" class="headerlink" title="3.3.3 Nginx + Tomcat的WEB应用服务器(集群)"></a>3.3.3 Nginx + Tomcat的WEB应用服务器(集群)</h4><img src = '/images/Docker/nginx_tomcat.jpg' width = '50%' align:left style='margin-left:10%'><p>一般在实际应用中：</p><ul><li>先是通过Nginx反向代理服务器(reverse proxy server)接收请求，匹配分离动态/静态请求（动静分离）</li><li>如果是静态请求，则转发到另外的Nginx WEB服务器上，返回静态内容；</li><li>如果是动态请求，则转发到后面的Tomcat应用服务器，处理动态请求的业务逻辑。</li></ul><p><a href="https://blog.csdn.net/tjiyu/article/details/53148174">参考链接 — 各种容器与服务器的区别与联系</a></p><h2 id="五、iOS的容器化"><a href="#五、iOS的容器化" class="headerlink" title="五、iOS的容器化"></a>五、iOS的容器化</h2><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>容器在不同场景下的含义</p><ol><li>字面意思，容器就是指容纳小物品的事物，比如：<ol><li>UIStackview</li><li>自定义的Container视图组件</li><li>前端组件化开发中的页面充当的角色(将一个页面分成很多个组件，此处页面就相当于是个纯粹的容器)</li></ol></li><li>数据的解析/渲染环境。比如：<ol><li>美团，后端返回协商好的结构化的数据，移动端对数据进行解析，还原成界面的layout。进行视图创建、渲染</li></ol></li><li>应用程序的运行环境。比如：<ol><li>上面的Docker容器</li><li>服务器容器</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、容器&quot;&gt;&lt;a href=&quot;#一、容器&quot; class=&quot;headerlink&quot; title=&quot;一、容器&quot;&gt;&lt;/a&gt;一、容器&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义&quot;&gt;&lt;a href=&quot;#1-1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.1 定</summary>
      
    
    
    
    <category term="容器化" scheme="https://tenloy.github.io/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>同步和异步解读及编程中的使用场景</title>
    <link href="https://tenloy.github.io/2021/04/20/03_Sync-Async/"/>
    <id>https://tenloy.github.io/2021/04/20/03_Sync-Async/</id>
    <published>2021-04-20T20:05:13.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、同步"><a href="#一、同步" class="headerlink" title="一、同步"></a>一、同步</h2><blockquote><p>协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/约束关系(这个关系分很多种：可以是两者 <code>同时</code>做指定的事、也可以是两者 <code>先后</code>做指定的事等)。</p></blockquote><p>比如：</p><ul><li>音画同步、动作同步等。指某人/事 <code>同时</code>产生，同时进行。</li><li>云同步等。在时间上保持一致性与统一化的现象。</li><li>同步。两部分任务之间按照 <code>先后</code>顺序进行。<ul><li>线程同步：一者暂停(在时域中是一个横线)，等另一者执行完成，再继续</li></ul></li></ul><p>注意：</p><blockquote><p>简单来说：同步就是一段时间内，规定<code>同一时间标准的每一刻</code>（注解1），每个模块(设备/部件/线程)分别应该完成什么(变化)，且各模块的<code>变化之间有一定的相对/约束关系</code>(注解2)</p></blockquote><ol><li><code>当两个设备需要有同步关系的时候，需要在两个设备之间规定一个共同的时间参考(时钟)。</code>即由同宽同距(同频同相)的时钟信号控制每个设备(部件/线程)，分别完成相应的操作</li><li>这两(多)个量的变化之间 <code>可能</code>没有联系，突出的是这两(多)个量<code>一段时间段内随时间的变化过程之间的对应关系</code>。比如上述第一个例子中两者的变化没有联系，而第二个例子中是一者的变化引起另一者的变化</li></ol><h2 id="二、异步"><a href="#二、异步" class="headerlink" title="二、异步"></a>二、异步</h2><blockquote><p>与同步概念相反，两(多)者在随时间变化过程中没有相对/约束关系</p></blockquote><p>比如：</p><ul><li>异步：多线程异步、进程异步</li><li>异步传输：一种通讯方式，对设备需求简单，异步双方不需要共同的时钟。</li></ul><h2 id="三、编程中的使用"><a href="#三、编程中的使用" class="headerlink" title="三、编程中的使用"></a>三、编程中的使用</h2><p>在操作系统中：同步执行的代码的执行过程有顺序性。而并发带来的异步性，每个进(线)程的代码都以其相对独立的不可预知的速度向前推进。</p><p>在计算机中，同步异步常见的两处使用场景：</p><ul><li>线程同步、异步</li><li>同步通信、异步通信(指的是计算机内部件之间的通信)</li><li>同步传输、异步传输(指的是计算机网络中的数据传输，原理基本上与上相同，增加了一些内容，详见下文)1<h3 id="3-1-线程同步、异步"><a href="#3-1-线程同步、异步" class="headerlink" title="3.1 线程同步、异步"></a>3.1 线程同步、异步</h3></li></ul><h4 id="3-1-1-同步"><a href="#3-1-1-同步" class="headerlink" title="3.1.1 同步"></a>3.1.1 同步</h4><p>线程之间存在一定的约束关系，在执行过程中，存在一定的<code>前后顺序</code>。可能是出于临界资源的占用，也可能是等待另一条线程执行结果的返回等原因，需要执行完前一个，才能再执行下一个，<code>需要等待、协调运行</code></p><h4 id="3-1-1-异步"><a href="#3-1-1-异步" class="headerlink" title="3.1.1 异步"></a>3.1.1 异步</h4><p>紧贴上面的概念，异步可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><p><code>异步和多线程并不是一个同等关系，异步是最终目的，多线程只是我们实现异步的一种手段</code>。异步是当一个调用请求发送给被调用者，而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</p><h3 id="3-2-同步通信、异步通信"><a href="#3-2-同步通信、异步通信" class="headerlink" title="3.2 同步通信、异步通信"></a>3.2 同步通信、异步通信</h3><p>总线通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合，通常用4种方式：同步通信、异步通信、半同步通信、分离式通信。</p><ul><li><p>同步通信中通信双方由统一时标控制数据传送。即双方按统一的传输周期进行信息传输，双方按约定好的时序进行联络，在规定的时钟周期内分别完成相应的操作。</p></li><li><p>异步通信中没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式(又称握手方式)，即当主模块发出请求信号时，一直等待从模块反馈回来响应信号后，才开始通信。</p></li><li><p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型。不互锁方式通信双方没有相互制约关系；半互锁方式通信双方有简单的制约关系；全互锁方式通信双方有完全的制约关系。其中全互锁通信可靠性最高；</p></li></ul><p>详见总线通信控制 ——《计组》</p><h3 id="3-3-同步、异步传输"><a href="#3-3-同步、异步传输" class="headerlink" title="3.3 同步、异步传输"></a>3.3 同步、异步传输</h3><p>在网络通信过程中，通信双方要交换数据，需要高度的协同工作。为了正确的解释信号，接收方必须确切地知道信号应当何时接收和处理，因此定时是至关重要的。</p><p>在计算机网络中，定时的因素称为位同步。同步是要接收方按照发送方发送的每个位的起止时刻和速率来接收数据，否则会产生误差。</p><p>通常可以采用同步或异步的传输方式对位进行同步处理。</p><p>首先是两者的不同</p><table><thead><tr><th></th><th>同步传输</th><th>异步传输</th></tr></thead><tbody><tr><td><code>同步</code></td><td><code>外同步</code></td><td><code>自同步</code>（见底部总结）</td></tr><tr><td>传输格式</td><td>面向 <code>比特</code>的传输，每个信息帧中包含若干个字符( <code>单位是帧</code>)</td><td>面向 <code>字符</code>的传输，每个字符帧只包含一个字符( <code>单位是字符</code>)</td></tr><tr><td>时钟</td><td>要求接收时钟和发送时钟同频同相，通过特定的时钟线路协调时序</td><td>不要求接收时钟和发送时钟完全同步，对时序的要求较低</td></tr><tr><td>数据流</td><td>发送端发送<code>连续</code>的比特流</td><td>发送端发送完一个字节后，可经过任意长的时间间隔再发送</td></tr></tbody></table><p>是否拥有同一个时钟序列进行工作，或者是以数据块为单位进行数据传输，是同步传输和异步传输之间的差别；</p><p>同步效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高，硬件更复杂。</p><h4 id="3-3-1-位同步"><a href="#3-3-1-位同步" class="headerlink" title="3.3.1 位同步"></a>3.3.1 位同步</h4><p>要求接收端根据发送端发送数据的起止时间和时钟频率，来校正自己的时间基准和时钟频率，这个过程叫位同步。可见，位同步的目的是使接收端接收的每一位信息都与发送端保持同步。</p><img src = '/images/OS/bit_sync.png' width = '80%'><h4 id="3-3-2-同步通信"><a href="#3-3-2-同步通信" class="headerlink" title="3.3.2 同步通信"></a>3.3.2 同步通信</h4><p>同步通信是一种比特同步通信技术，要求发收双方具有同频同相的同步时钟信号，只需在传送报文的最前面附加特定的同步字符，当接收端确认接收到同步字符后，发收双方建立同步，此后便在 <code>同步时钟的控制下</code>逐位发送/接收。</p><p>同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息，<code>由同步字符、数据字符和校验字符（CRC）组成。(见上图)</code></p><ul><li>同步字符：位于帧的开头，用于确认数据字符的开始；</li><li>数据字符：在同步字符之后，个数没有限制，由所需传输的数据块长度来决定；</li><li>校验字符：有1到2个，用于接收端对接收到的字符序列进行正确性的校验</li></ul><p>同步这种方式中因为分组相比异步大得多，很长一段数据才会有额外的辅助位负载，所以效率更高，更加适合对速度要求高的传输，当然这种通信对时序的要求也更高。</p><p>随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。</p><p>另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p><blockquote><p>“同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地发送和接收连续的同步比特流。但这时还有两种不同的同步方式。一种是使用全网同步，用一个非常精确的主时钟对全网所有结点上的时钟进行同步。另一种是使用准同步，各结点的时钟之间允许有微小的误差，然后采用其他措施实现同步传输。</p></blockquote><h4 id="3-3-3-异步通信"><a href="#3-3-3-异步通信" class="headerlink" title="3.3.3 异步通信"></a>3.3.3 异步通信</h4><blockquote><p>异步通信指两个互不同步的设备通过计时机制或其他技术进行数据传输。异步通信中两个字符之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。基本上，发送方可以随时传输数据，而接收方必须在信息到达时准备好接收。</p></blockquote><p>这种传输通常是很小的分组，比如一个字符为一组，为这个组配备起始位和结束位。所以这种传输方式的效率是比较低的，毕竟额外加入了很多的辅助位作为负载，常用在低速的传输中。</p><p>异步通信，是以字符或者字节为单位组成字符帧进行传输。<code>字符帧格式中包括空闲位、起始位、资料位、奇偶校验位、停止位。(见上图)</code></p><p>以RS232协议规定为例，异步通信一个字符一个字符地传输，每个字符一位一位地传输，并且传输一个字符时：</p><ul><li>总是以“起始位”开始（低电平，逻辑值0），以“停止位”结束，字符之间没有固定的时间间隔要求。</li><li>字符数据本身由5~8位数据位组成，接着字符后面是一位校验位（也可以没有校验位）</li><li>最后是一位或一位半或二位停止位</li><li>停止位后面是不定长的空闲位(处于逻辑“1”状态，表示当前线路上没有资料传送)。</li><li>停止位和空闲位都规定为高电平（逻辑值１），这样就保证起始位开始处一定有一个下跳沿。</li></ul><p>异步通信是按字符传输的，接收设备在收到起始信号之后只要在一个字符的传输时间内能和发送设备保持同步就能正确接收。下一个字符起始位的到来又使同步重新校准(<code>依靠检测起始位来实现发送与接收方的时钟 自同步的</code>)。这样，只要发送端和接收端协商好字符帧格式和波特率，就可以由各自的时钟来控制数据的发送和接收。</p><p>举个例子，我们的键盘按下一个按键，发出一个字符信号，异步传输机制就会为它加上前后的辅助同步信息，帮助接收方识别到我们按下了哪一个按键。因为我们敲击键盘的节奏不固定，所以异步是一种很适合的方式</p><p>用于异步通信的连接在OSI(开放系统互连)参考模型的物理层中被定义。</p><blockquote><p>“异步通信”是一种很常用的通信方式。</p><p>异步通信在发送字符时，所发送的字符之间的时间间隔可以是任意的。当然，接收端必须时刻做好接收的准备（如果接收端主机的电源都没有加上，那么发送端发送字符就没有意义，因为接收端根本无法接收）。发送端可以在任意时刻开始发送字符，因此必须在每一个字符的开始和结束的地方加上标志，即加上开始位和停止位，以便使接收端能够正确地将每一个字符接收下来。</p></blockquote><p>异步通信的好处是通信设备简单、便宜，但传输效率较低（因为开始位和停止位的开销所占比例较大）。</p><p>异步通信也可以是以帧作为发送的单位。接收端必须随时做好接收帧的准备。这时，帧的首部必须设有一些特殊的比特组合，使得接收端能够找出一帧的开始。这也称为 <code>帧定界</code>。</p><p>帧定界还包含确定帧的结束位置，这有两种方法：</p><ul><li>一种是在帧的尾部设有某种特殊的比特组合来标志帧的结束</li><li>在帧首部中设有帧长度的字段</li></ul><p>需要注意的是，在异步发送帧时，并不是说发送端对帧中的每一个字符都必须加上开始位和停止位后再发送出去，而是说，发送端可以在任意时间发送一个帧，而帧与帧之间的时间间隔也可以是任意的。在一帧中的所有比特是连续发送的。发送端不需要在发送一帧之前和接收端进行协调（不需要先进行比特同步）。</p><h4 id="3-3-4-总结"><a href="#3-3-4-总结" class="headerlink" title="3.3.4 总结"></a>3.3.4 总结</h4><h5 id="1-异步通信方式的特点"><a href="#1-异步通信方式的特点" class="headerlink" title="1.异步通信方式的特点"></a>1.异步通信方式的特点</h5><p>异步通信是按字符传输的。每传输一个字符就用起始位来进行收、发双方的同步。不会因收发双方的时钟频率的小的偏差导致错误。</p><p>这种传输方式利用每一帧的起、止信号来建立发送与接收之间的同步。特点是：<code>每帧内部各位均采用固定的时间间隔，而帧与帧之间的间隔时随即的</code>。接收机完全靠每一帧的起始位和停止位来识别字符时正在进行传输还是传输结束。</p><p>（使用串口USART中的串行异步通信是一个代表）</p><h5 id="2-同步通信方式的特点"><a href="#2-同步通信方式的特点" class="headerlink" title="2.同步通信方式的特点"></a>2.同步通信方式的特点</h5><p>进行数据传输时，发送和接收双方要保持完全的同步，因此，要求接收和发送设备必须使用同一时钟。</p><p>优点是可以实现高速度、大容量的数据传送；缺点是要求发生时钟和接收时钟保持严格同步，同时硬件复杂。</p><p>（SPI总线是一个典型代表）</p><h5 id="3-对比："><a href="#3-对比：" class="headerlink" title="3.对比："></a>3.对比：</h5><p>可以这样说，不管是异步通信还是同步通信都需要进行同步，只是异步通信通过传送字符内的起始位来进行同步，而同步通信采用共用外部时钟来进行同步。所以，可以说前者是 <code>自同步</code>，后者是 <code>外同步</code>。同时，同步要求收发两端对时间的精确度要求很高，异步没有同步要求那么高。</p><p>自同步、外同步：</p><ul><li>同步传输：是发送端的发送、接收端的接收是同步的，在统一的时钟信号下进行，发一位，接一位。同步传输的数据格式是一种外同步方式所采用的数据格式。对这种方式，在发送的一帧数据中不包含同步字符。同步信号SYNC通过专门的控制线加到串行的接口上。当SYNC一到达，表明数据部分开始，接口就连续接收数据和CRC校验码。    </li><li>异步传输：发送端的发送、接收端的接收不用时钟同步。发送端发一个字符，接收端等接收到之后按字符的始、止位来实现自同步，处理一个字符。</li></ul><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h5><p>在大量使用异步与同步传输的大型机/终端环境中</p><ul><li>异步传输用于传输来自用户周期性按键的终端的字符。接收系统知道等待下一次按键，即使这会花费较多的时间。</li><li>相反，同步传输用作定期传输大量信息的大型系统之间的数据链路。协议为在公用电话系统上利用慢速链路而进行了优化，因此无关位将从传输中删除，并且时钟用于隔开字符。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、同步&quot;&gt;&lt;a href=&quot;#一、同步&quot; class=&quot;headerlink&quot; title=&quot;一、同步&quot;&gt;&lt;/a&gt;一、同步&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;协调，实现步调一致。两个或几个随时间变化的量，在变化过程中(在时域序列上相对位置)保持一定的相对/</summary>
      
    
    
    
    <category term="OS" scheme="https://tenloy.github.io/categories/OS/"/>
    
    
    <category term="多线程" scheme="https://tenloy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CI-CD</title>
    <link href="https://tenloy.github.io/2021/04/12/02_CI-CD/"/>
    <id>https://tenloy.github.io/2021/04/12/02_CI-CD/</id>
    <published>2021-04-12T14:59:20.000Z</published>
    <updated>2021-05-27T09:20:16.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、常见的Travis-CI与Jenkins"><a href="#一、常见的Travis-CI与Jenkins" class="headerlink" title="一、常见的Travis CI与Jenkins"></a>一、常见的Travis CI与Jenkins</h2><p><a href="https://zhuanlan.zhihu.com/p/67805669">参考链接：谁才是世界上最好的 CI/CD 工具？</a></p><p><strong>On-Premise vs Hosted</strong></p><ul><li>On-Premise 需要用户搭建自己的服务器来运行 CI/CD 工具。</li><li>Hosted CI/CD 工具是一个 SaaS 服务，不需要用户搭建自己的服务器。</li></ul><p>常见的 CI/CD 工具</p><ul><li><p>TeamCity 和 Jenkins 属于 “On-Premise” 阵营</p></li><li><p>Travis CI 属于 “Hosted” 阵营</p></li><li><p>AppVeyor 和 Azure Pipelines 则是既能 “On-Premise” 又能 “Hosted” </p></li></ul><p>如果在 CI/CD 过程中，需要连接到不同的内网服务。那么 On-Premise 的 CI/CD 工具适合这样的使用场景，你可以把 Build Agent 部署在内网的机器上，这样可以轻松地连接内网资源。</p><p>如果你不需要连接内网资源，那么 Hosted CI/CD Service 就是你的最佳选择了，有以下几个优势：</p><ul><li>维护成本：Hosted CI/CD Service 可以说是零维护成本了，整个运行环境都由服务商托管。相比于 On-Premise 的CI/CD 工具，使用者需要自己花大量时间搭建与维护服务器，对于 Hosted CI/CD Service 来说，使用者完全不需要担心背后服务器的维护。</li><li>Clean的运行环境：假设你在为你的 Python 项目寻求一个 CI/CD 工具，而你的 Python 项目需要同时对 Python 2.7, 3.6, 3.7 进行持续集成，那么 Hosted CI/CD Service 完全可以满足你的需要。On-Premise 的机器上，你需要对不同的 Python 版本而烦恼，而 Hosted CI/CD Service 每次都会创建一个新的运行环境，想用哪个 Python 版本就用哪个。</li><li>预装的软件和运行时：每一个项目在做持续集成时，往往会需要依赖不同的运行时和工具链，Hosted CI/CD Service 会帮你预装好许多常用的软件和运行时，大大减少了搭建环境的时间。</li><li>价格：价格成本也是我们在技术选型要重点考虑的一点。<ul><li>On-Premise 的 TeamCity 和 Jenkins：虽然他们都是免费使用的，但是使用者都需要搭建自己的服务器，不论是用自己的物理机还是使用 Azure 或是 AWS 上的虚拟机，这都是一个花费。特别是对于大规模的持续集成的需求下，这会是个很大的价格成本。</li><li>对于开源项目，Hosted CI/CD Service 有着很大的优势，Travis CI、AppVeyor 和 Azure Pipelines 对于开源项目都是完全免费的。</li><li>对于私有项目，Travis CI 和 AppVeyor 是收费的，而 Azure Pipelines 有一个月 1800 分钟的免费额度。可见，对于私有项目，Azure Pipelines 有很大的优势。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、常见的Travis-CI与Jenkins&quot;&gt;&lt;a href=&quot;#一、常见的Travis-CI与Jenkins&quot; class=&quot;headerlink&quot; title=&quot;一、常见的Travis CI与Jenkins&quot;&gt;&lt;/a&gt;一、常见的Travis CI与Jenki</summary>
      
    
    
    
    <category term="软件工程(化)" scheme="https://tenloy.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%8C%96/"/>
    
    
    <category term="CI/CD" scheme="https://tenloy.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo+Github Pages搭建个人博客</title>
    <link href="https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/"/>
    <id>https://tenloy.github.io/2021/04/10/01_GithubPages-Hexo/</id>
    <published>2021-04-10T10:25:24.000Z</published>
    <updated>2021-05-27T09:20:16.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Hexo配置和基本使用"><a href="#一、Hexo配置和基本使用" class="headerlink" title="一、Hexo配置和基本使用"></a>一、Hexo配置和基本使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown(或其他渲染引擎) 解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p><a href="https://hexo.io/zh-cn/docs/github-pages">hexo文档</a></p><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><h4 id="1-2-1-init"><a href="#1-2-1-init" class="headerlink" title="1.2.1 init"></a>1.2.1 init</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder] <span class="comment"># 新建一个网站。如果没有设置folder，Hexo默认在目前的文件夹建立网站。</span></span><br></pre></td></tr></table></figure><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h4 id="1-2-2-new"><a href="#1-2-2-new" class="headerlink" title="1.2.2 new"></a>1.2.2 new</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; <span class="comment"># 新建一篇文章</span></span><br></pre></td></tr></table></figure><ul><li>如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。</li><li>如果标题包含空格的话，请使用引号括起来。</li></ul><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br><span class="line"><span class="comment"># 以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `&quot;About me&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意！title 是必须指定的！如果你这么做并不能达到你的目的：</span></span><br><span class="line">hexo new page --path about/me</span><br><span class="line"><span class="comment"># 此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `&quot;page&quot;`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-generate"><a href="#1-2-3-generate" class="headerlink" title="1.2.3 generate"></a>1.2.3 generate</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  <span class="comment"># 生成静态文件。可以简写为hexo g</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站。<code>hexo g -d</code> 与 <code>hexo d -g</code> 两个命令的作用是相同的。</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动。Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h4 id="1-2-4-deploy"><a href="#1-2-4-deploy" class="headerlink" title="1.2.4 deploy"></a>1.2.4 deploy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy <span class="comment"># 部署网站。可以简写为：hexo d</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><h4 id="1-2-5-server"><a href="#1-2-5-server" class="headerlink" title="1.2.5 server"></a>1.2.5 server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  <span class="comment"># 启动服务器。可以简写为：hexo s</span></span><br></pre></td></tr></table></figure><p>默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h4 id="1-2-6-clean"><a href="#1-2-6-clean" class="headerlink" title="1.2.6 clean"></a>1.2.6 clean</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。</span></span><br></pre></td></tr></table></figure><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h4 id="1-2-7-其他"><a href="#1-2-7-其他" class="headerlink" title="1.2.7 其他"></a>1.2.7 其他</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt; <span class="comment"># 发表草稿</span></span><br><span class="line">hexo render &lt;file1&gt; [file2] ... <span class="comment"># 渲染文件。可通过参数-o,--output来设置输出路径</span></span><br><span class="line">hexo migrate &lt;<span class="built_in">type</span>&gt; <span class="comment"># 从其他博客系统 迁移内容 https://hexo.io/zh-cn/docs/migration</span></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;  <span class="comment">#列出网站资料</span></span><br><span class="line">hexo version  <span class="comment"># 显示 Hexo 版本</span></span><br></pre></td></tr></table></figure><h2 id="二、主题配置"><a href="#二、主题配置" class="headerlink" title="二、主题配置"></a>二、主题配置</h2><p><a href="https://github.com/Tenloy/hexo-theme-archer">fork的theme</a></p><p>根据喜好随便改：配置简书、RSS</p><p><strong>GIT</strong>子模块：</p><ul><li>现在我们的Blog项目受GitHub管理，是个仓库，其中包含了一个主题仓库。其中对主题仓库的修改，要在外层仓库、theme仓库分别提交一次</li><li>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git-子模块</a></li></ul><h2 id="三、Travis-CI配置"><a href="#三、Travis-CI配置" class="headerlink" title="三、Travis CI配置"></a>三、Travis CI配置</h2><p>持续集成（Continuous integration，简称CI）</p><p>可以在其中加入一些自动化命令的执行，如每次commit，自动hexo algolia、hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p><p><a href="https://mfrank2016.github.io/breeze-blog/2020/05/02/hexo/hexo-start/#toc-heading-12">参考链接</a></p><p>但并没有以下问题：</p><blockquote><p>注意：有两种类型的 <code>github pages</code>，一种是使用 <code>用户名.github.io</code> 作为项目名，一种是使用其它名称。虽然看起来只是名字不一样，但两种方式其实是有差异的，前一种方式里，网页静态文件只能存放在 master 分支，所以如果想要把博客源文件也存到同一个仓库，必须使用其它分支来存放，相应的 travis ci 监听和推送的分支也需要修改，当然也可以使用另一个新的仓库来存放。后一种方式则没这个限制，通常使用名为 <code>gh-pages</code> 作为分支名，<code>Hexo</code> 内默认设置的分支也是叫这个名字。这里我们使用的是后一种方案，即源文件和生成的网页静态文件存放在同一个仓库，源文件在 <code>master</code> 分支，静态文件在 <code>gh-pages</code> 分支。</p></blockquote><h2 id="四、algolia站内搜索配置"><a href="#四、algolia站内搜索配置" class="headerlink" title="四、algolia站内搜索配置"></a>四、algolia站内搜索配置</h2><p>algolia网站本质上就是提供了数据库，提供了接口给使用者，供其将要被检索的内容上传。</p><p>hexo-algolia工具就是完成了文档中内容的摘取，然后上传，上传的各项内容，其key就相当于数据库的表字段。</p><ul><li>hexo-algolia 要1.2.2版本之前，之后去掉了content字段，即表中不存储文章内容，所以不能搜索文章内容</li></ul><p>algolia网站配置步骤<a href="https://blog.csdn.net/qq_35479468/article/details/107335663">参考链接</a></p><h2 id="五、评论系统配置"><a href="#五、评论系统配置" class="headerlink" title="五、评论系统配置"></a>五、评论系统配置</h2><p><a href="https://www.heson10.com/posts/3217.html">https://www.heson10.com/posts/3217.html</a></p><p><a href="https://blog.shuiba.co/comment-systems-recommendation">https://blog.shuiba.co/comment-systems-recommendation</a></p><p>gitalk</p><h2 id="附：GitBook的使用注意点"><a href="#附：GitBook的使用注意点" class="headerlink" title="附：GitBook的使用注意点"></a>附：GitBook的使用注意点</h2><h3 id="6-1-不支持本地导出HTML"><a href="#6-1-不支持本地导出HTML" class="headerlink" title="6.1 不支持本地导出HTML"></a>6.1 不支持本地导出HTML</h3><p>新版本不支持本地导出的HTML跳转，解决方案：</p><ul><li><p>在_book文件夹中找到gitbook-&gt;theme.js文件。</p></li><li><p>在代码中搜索 <code>if(m)for(n.handler&amp;&amp;</code></p></li><li><p>将<code>if(m)</code>改成<code>if(false)</code>，再重新打开index.html即可 </p></li></ul><p>缺点：每次都会重置侧边栏。如果是部署后访问，侧边栏点击跳转后，不会重置状态</p><h3 id="6-2-默认主题运行报错"><a href="#6-2-默认主题运行报错" class="headerlink" title="6.2 默认主题运行报错"></a>6.2 默认主题运行报错</h3><p>在使用该主题的过程中，发现经常会在控制台报下面的错误，没有找到是哪里的原因，官方也一直没有修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme.js:4UncaughtTypeError:Cannot read property&#39;split&#39; of undefined</span><br></pre></td></tr></table></figure><p>后来在 <a href="https://github.com/maxkoryukov/theme-default/commit/811fcca17fcc84ad9ff3f940a4194dbffa62a31d">这里</a> 看到一个解决方法，需要修改本地的 GitBook Theme 模板。下面是具体步骤：</p><ul><li><p>进入 GitBook 默认主题所在的文件夹 <code>用户主目录</code> -&gt; <code>.gitbook</code> -&gt; <code>versions</code> -&gt; <code>3.2.2</code> -&gt; <code>node_modules</code> -&gt; <code>gitbook-plugin-theme-default</code> -&gt; <code>src</code> -&gt; <code>js</code> -&gt; <code>theme</code>，打开 <code>navigation.js</code>，找到 <code>getChapterHash</code> 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash = $link.attr(<span class="string">&#x27;href&#x27;</span>).split(<span class="string">&#x27;#&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将该函数修改为下面的形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapterHash</span>(<span class="params">$chapter</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $link = $chapter.children(<span class="string">&#x27;a&#x27;</span>),      </span><br><span class="line">      hash,      </span><br><span class="line">      href,      </span><br><span class="line">      parts;</span><br><span class="line">  <span class="keyword">if</span>($link.length)&#123;      </span><br><span class="line">    href = $link.attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(href)&#123;          </span><br><span class="line">      parts = href.split(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(parts.length&gt;<span class="number">1</span>)&#123;              </span><br><span class="line">        hash = parts[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(hash) hash =<span class="string">&#x27;#&#x27;</span>+hash;</span><br><span class="line">  <span class="keyword">return</span>(!!hash)? hash :<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到 <code>gitbook-plugin-theme-default</code> 文件夹，运行 <code>npm install</code> 重新编译文件。</p></li></ul><h3 id="6-3-anchor-navigation-ex插件回到顶部"><a href="#6-3-anchor-navigation-ex插件回到顶部" class="headerlink" title="6.3 anchor-navigation-ex插件回到顶部"></a>6.3 <code>anchor-navigation-ex</code>插件回到顶部</h3><ul><li>如果文章有1级标题就必定好使</li><li>如果没有就：第一次好使，之后不好使。锚点设置的有问题</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;a href=&quot;#一、Hexo配置和基本使用&quot; class=&quot;headerlink&quot; title=&quot;一、Hexo配置和基本使用&quot;&gt;&lt;/a&gt;一、Hexo配置和基本使用&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://tenloy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>AutoreleasePool</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/RunLoop/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/RunLoop/</id>
    <published>2021-04-06T19:16:47.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Autorelease简介"><a href="#一、Autorelease简介" class="headerlink" title="一、Autorelease简介"></a>一、Autorelease简介</h2><p>iOS开发中的Autorelease机制是为了延时释放对象。自动释放的概念看上去很像ARC，但实际上这更类似于C语言中自动变量的特性。</p><p>自动变量：在超出变量作用域后将被废弃；<br> 自动释放池：在超出释放池生命周期后，向其管理的对象实例的发送<code>release</code>消息。</p><h3 id="1-1-MRC下使用自动释放池"><a href="#1-1-MRC下使用自动释放池" class="headerlink" title="1.1 MRC下使用自动释放池"></a>1.1 MRC下使用自动释放池</h3><p>在MRC环境中使用自动释放池需要用到<code>NSAutoreleasePool</code>对象，其生命周期就相当于C语言变量的作用域。对于所有调用过<code>autorelease</code>方法的对象，在废弃<code>NSAutoreleasePool</code>对象时，都将调用<code>release</code>实例方法。用源代码表示如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="comment">//第一步：生成并持有释放池NSAutoreleasePool对象;</span></span><br><span class="line"><span class="type">NSAutoreleasePool</span> <span class="operator">*</span>pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：调用对象的autorelease实例方法;</span></span><br><span class="line">id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[obj autorelease];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：废弃NSAutoreleasePool对象;</span></span><br><span class="line">[pool drain];   <span class="comment">//向pool管理的所有对象发送消息，相当于[obj release]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//obi已经释放，再次调用会崩溃(Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT))</span></span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br></pre></td></tr></table></figure><p>理解<code>NSAutoreleasePool</code>对象的生命周期，如下图所示：</p><img src="/images/RunLoop/AutoreleasePool5.png" width = "50%" alt="" align=center /><h3 id="1-2-ARC下使用自动释放池"><a href="#1-2-ARC下使用自动释放池" class="headerlink" title="1.2 ARC下使用自动释放池"></a>1.2 ARC下使用自动释放池</h3><p>ARC环境不能使用<code>NSAutoreleasePool</code>类也不能调用<code>autorelease</code>方法，代替它们实现对象自动释放的是<code>@autoreleasepool</code>块和<code>__autoreleasing</code>修饰符。比较两种环境下的代码差异如下图：</p><img src="/images/RunLoop/AutoreleasePool4.png" width = "60%" alt="" align=center /><p>如图所示，<code>@autoreleasepool</code>块替换了<code>NSAutoreleasePoool</code>类对象的生成、持有及废弃这一过程。而附有<code>__autoreleasing</code>修饰符的变量替代了<code>autorelease</code>方法，将对象注册到了<code>Autoreleasepool</code>；由于ARC的优化，<code>__autorelease</code>是可以被省略的，所以简化后的ARC代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显式使用<code>__autoreleasing</code>修饰符的情况非常少见，这是因为ARC的很多情况下，即使是不显式的使用<code>__autoreleasing</code>，也能实现对象被注册到释放池中。主要包括以下几种情况：</p><ol><li>编译器会进行优化，检查方法名是否以<code>alloc/new/copy/mutableCopy</code>开始，如果不是则自动将返回对象注册到<code>Autoreleasepool</code>;</li><li>访问附有<code>__weak</code>修饰符的变量时，实际上必定要访问注册到<code>Autoreleasepool</code>的对象，即会自动加入<code>Autoreleasepool</code>;</li><li>id的指针或对象的指针(id*，NSError **)，在没有显式地指定修饰符时候，会被默认附加上<code>__autoreleasing</code>修饰符，加入<code>Autoreleasepool</code></li></ol><p><strong>注意：</strong>如果编译器版本为LLVM.3.0以上，即使ARC无效<code>@autoreleasepool</code>块也能够使用；如下源码所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MRC环境下的测试：</span></span><br><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [obj autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、AutoRelease原理"><a href="#二、AutoRelease原理" class="headerlink" title="二、AutoRelease原理"></a>二、AutoRelease原理</h2><h3 id="2-1-使用-autoreleasepool"><a href="#2-1-使用-autoreleasepool" class="headerlink" title="2.1 使用@autoreleasepool{}"></a>2.1 使用@autoreleasepool{}</h3><p>我们在<code>main</code>函数中写入自动释放池相关的测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了探究释放池的底层实现，我们在终端使用<code>clang -rewrite-objc + 文件名</code>命令将上述OC代码转化为C++源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span></span><br><span class="line">    &#123;</span><br><span class="line">        __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_3f_crl5bnj956d806cp7d3ctqhm0000gn_T_main_d37e0d_mi_0);</span><br><span class="line">     &#125;<span class="comment">//大括号对应释放池的作用域</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过编译器<code>clang</code>命令转化后，我们看到的所谓的<code>@autoreleasePool</code>块，其实对应着<code>__AtAutoreleasePool</code>的结构体。</p><h3 id="2-2-分析结构体-AtAutoreleasePool的具体实现"><a href="#2-2-分析结构体-AtAutoreleasePool的具体实现" class="headerlink" title="2.2 分析结构体__AtAutoreleasePool的具体实现"></a>2.2 分析结构体__AtAutoreleasePool的具体实现</h3><p>在源码中找到<code>__AtAutoreleasePool</code>结构体的实现代码，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">__AtAutoreleasePool`结构体包含了：构造函数、析构函数和一个边界对象；</span><br><span class="line"> 构造函数内部调用：`objc_autoreleasePoolPush()`方法，返回边界对象`atautoreleasepoolobj`</span><br><span class="line"> 析构函数内部调用：`objc_autoreleasePoolPop()`方法，传入边界对象`atautoreleasepoolobj</span><br></pre></td></tr></table></figure><p>分析<code>main</code>函数中<code>__autoreleasepool</code>结构体实例的生命周期是这样的：<br> <code>__autoreleasepool</code>是一个自动变量，其构造函数是在程序执行到声明这个对象的位置时调用的，而其析构函数则是在程序执行到离开这个对象的作用域时调用。所以，我们可以将上面<code>main</code>函数的代码简化如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char <span class="operator">*</span> argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">        void <span class="operator">*</span>atautoreleasepoolobj <span class="operator">=</span> objc_autoreleasePoolPush();</span><br><span class="line">        <span class="type">NSLog</span>((<span class="type">NSString</span> <span class="operator">*</span>)<span class="operator">&amp;</span>__NSConstantStringImpl__var_folders_kb_06b822gn59df4d1zt99361xw0000gn_T_main_d39a79_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop"><a href="#2-3-objc-autoreleasePoolPush与objc-autoreleasePoolPop" class="headerlink" title="2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop"></a>2.3 objc_autoreleasePoolPush与objc_autoreleasePoolPop</h3><p>进一步观察自动释放池构造函数与析构函数的实现，其实它们都只是对<code>AutoreleasePoolPage</code>对应静态方法<code>push</code>和<code>pop</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-理解AutoreleasePoolPage"><a href="#2-4-理解AutoreleasePoolPage" class="headerlink" title="2.4 理解AutoreleasePoolPage"></a>2.4 理解AutoreleasePoolPage</h3><p><code>AutoreleasePoolPage</code>是一个C++中的类，打开<code>Runtime</code>的源码工程，在<code>NSObject.mm</code>文件中可以找到它的定义，摘取其中的关键代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大致在641行代码开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)  <span class="comment">//空池占位</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil                <span class="comment">//边界对象(即哨兵对象）</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;                  <span class="comment">//校验AutoreleasePagePoolPage结构是否完整</span></span><br><span class="line">    id *next;                             <span class="comment">//指向新加入的autorelease对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;               <span class="comment">//当前所在线程，AutoreleasePool是和线程一一对应的</span></span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;   <span class="comment">//指向父节点page，第一个结点的parent值为nil</span></span><br><span class="line">    AutoreleasePoolPage *child;           <span class="comment">//指向子节点page，最后一个结点的child值为nil</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;                 <span class="comment">//链表深度，节点个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;                       <span class="comment">//数据容纳的一个上限</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，<strong>每个自动释放池都是是由若干个<code>AutoreleasePoolPage</code>组成的双向链表结构</strong>，如下图所示:</p><img src="/images/RunLoop/AutoreleasePool3.png" width = "90%" alt="" align=center /><p><code>AutoreleasePoolPage</code>中拥有<code>parent</code>和<code>child</code>指针，分别指向上一个和下一个<code>page</code>；当前一个<code>page</code>的空间被占满(每个<code>AutorelePoolPage</code>的大小为4096字节)时，就会新建一个<code>AutorelePoolPage</code>对象并连接到链表中，后来的  Autorelease对象也会添加到新的<code>page</code>中；</p><p>另外，当<code>next== begin()</code>时，表示<code>AutoreleasePoolPage</code>为空；当<code>next == end()</code>，表示<code>AutoreleasePoolPage</code>已满。</p><h3 id="2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用"><a href="#2-5-理解哨兵对象-边界对象-POOL-BOUNDARY-的作用" class="headerlink" title="2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用"></a>2.5 理解哨兵对象/边界对象(POOL_BOUNDARY)的作用</h3><p>在<code>AutoreleasePoolPage</code>的源码中，我们很容易找到边界对象(哨兵对象)的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define POOL_BOUNDARY nil</span><br></pre></td></tr></table></figure><p>边界对象其实就是<code>nil</code>的别名，而它的作用事实上也就是为了起到一个标识的作用。</p><p>每当自动释放池初始化调用<code>objc_autoreleasePoolPush</code>方法时，总会通过<code>AutoreleasePoolPage</code>的<code>push</code>方法，将<code>POOL_BOUNDARY</code>放到当前<code>page</code>的栈顶，并且返回这个边界对象；</p><p>而在自动释放池释放调用<code>objc_autoreleasePoolPop</code>方法时，又会将边界对象以参数传入，这样自动释放池就会向释放池中对象发送<code>release</code>消息，直至找到第一个边界对象为止。</p><h3 id="2-6-理解objc-autoreleasePoolPush方法"><a href="#2-6-理解objc-autoreleasePoolPush方法" class="headerlink" title="2.6 理解objc_autoreleasePoolPush方法"></a>2.6 理解objc_autoreleasePoolPush方法</h3><p>经过前面的分析，<code>objc_autoreleasePoolPush</code>最终调用的是    <code>AutoreleasePoolPage</code>的<code>push</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">1.</span>        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈操作：将对象加入AutoreleaseNoPage并移动栈顶的指针</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotPage已满时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前hotpage不存在时调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，每次调用<code>push</code>其实就是创建一个新的AutoreleasePool，在对应的<code>AutoreleasePoolPage</code>中插入一个<code>POOL_BOUNDARY</code> ，并且返回插入的<code>POOL_BOUNDARY</code> 的内存地址。<code>push</code>方法内部调用的是<code>autoreleaseFast</code>方法，并传入边界对象(<code>POOL_BOUNDARY</code>)。<code>hotPage</code>可以理解为当前正在使用的<code>AutoreleasePoolPage</code>。</p><p>自动释放池最终都会通过<code>page-&gt;add(obj)</code>方法将边界对象添加到释放池中，而这一过程在<code>autoreleaseFast</code>方法中被分为三种情况：</p><ol><li>当前<code>page</code>存在且不满，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中，即<code>next</code>指向的位置</li><li>当前<code>page</code>存在但是已满，调用<code>autoreleaseFullPage</code>初始化一个新的<code>page</code>，调用<code>page-&gt;add(obj)</code>方法将对象添加至<code>page</code>的栈中</li><li>当前<code>page</code>不存在时，调用<code>autoreleaseNoPage</code>创建一个<code>hotPage</code>，再调用<code>page-&gt;add(obj)</code> 方法将对象添加至<code>page</code>的栈中</li></ol><h3 id="2-7-objc-autoreleasePoolPop方法"><a href="#2-7-objc-autoreleasePoolPop方法" class="headerlink" title="2.7 objc_autoreleasePoolPop方法"></a>2.7 objc_autoreleasePoolPop方法</h3><p>AutoreleasePool的释放调用的是<code>objc_autoreleasePoolPop</code>方法，此时需要传入边界对象作为参数。这个边界对象正是每次执行<code>objc_autoreleasePoolPush</code>方法返回的对象<code>atautoreleasepoolobj</code>；</p><p>同理，我们找到<code>objc_autoreleasePoolPop</code>最终调用的方法，即<code>AutoreleasePoolPage</code>的<code>pop</code>方法，该方法的具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span>   <span class="comment">//POOL_BOUNDARY的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);   <span class="comment">//通过POOL_BOUNDARY找到对应的page</span></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  *stop != POOL_SENTINEL) &#123;</span><br><span class="line">        <span class="comment">// This check is not valid with DebugPoolAllocation off</span></span><br><span class="line">        <span class="comment">// after an autorelease with a pool page but no pool in place.</span></span><br><span class="line">        _objc_fatal(<span class="string">&quot;invalid or prematurely-freed autorelease pool %p; &quot;</span>, </span><br><span class="line">                    token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();   <span class="comment">// 记录最高水位标记</span></span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);   <span class="comment">//向栈中的对象发送release消息，直到遇到第一个哨兵对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="comment">// 删除空掉的节点</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先根据传入的边界对象地址找到边界对象所处的<code>page</code>；然后选择当前<code>page</code>中最新加入的对象一直向前清理，可以向前跨越若干个<code>page</code>，直到边界所在的位置；清理的方式是向这些对象发送一次<code>release</code>消息，使其引用计数减一；</p><p>另外，清空<code>page</code>对象还会遵循一些原则：</p><ol><li>如果当前的<code>page</code>中存放的对象少于一半，则子<code>page</code>全部删除；</li><li>如果当前当前的<code>page</code>存放的多余一半（意味着马上将要满），则保留一个子<code>page</code>，节省创建新<code>page</code>的开销;</li></ol><h3 id="2-8-autorelease方法"><a href="#2-8-autorelease方法" class="headerlink" title="2.8 autorelease方法"></a>2.8 autorelease方法</h3><p>上述是对自动释放池整个生命周期的分析，现在我们来理解延时释放对象<code>autorelease</code>方法的实现，首先查看该方法的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject autorelease]</span><br><span class="line">└── id objc_object::rootAutorelease()</span><br><span class="line">    └── id objc_object::rootAutorelease2()</span><br><span class="line">        └── static id AutoreleasePoolPage::autorelease(id obj)</span><br><span class="line">            └── static id AutoreleasePoolPage::autoreleaseFast(id obj)</span><br><span class="line">                ├── id *add(id obj)</span><br><span class="line">                ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── id *add(id obj)</span><br><span class="line">                └── static id *autoreleaseNoPage(id obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── id *add(id obj)</span><br></pre></td></tr></table></figure><p>如上所示，<code>autorelease</code>方法最终也会调用上面提到的 <code>autoreleaseFast</code>方法，将当前对象加到<code>AutoreleasePoolPage</code>中。关于<code>autoreleaseFast</code>的分析这里不再累述，我们主要来考虑一下两次调用的区别：</p><p><code>autorelease</code>函数和<code>push</code>函数一样，关键代码都是调用<code>autoreleaseFast</code>函数向自动释放池的链表栈中添加一个对象，不过<code>push</code>函数入栈的是一个边界对象，而<code>autorelease</code>函数入栈的是一个具体的Autorelease的对象。</p><h2 id="三、AutoreleasePool与NSThread、NSRunLoop的关系"><a href="#三、AutoreleasePool与NSThread、NSRunLoop的关系" class="headerlink" title="三、AutoreleasePool与NSThread、NSRunLoop的关系"></a>三、AutoreleasePool与NSThread、NSRunLoop的关系</h2><p>由于<code>AppKit</code>和<code>UIKit</code>框架的优化，我们很少需要显式的创建一个自动释放池块。这其中就涉及到<code>AutoreleasePool</code>与<code>NSThread</code>、<code>NSRunLoop</code>的关系。</p><h3 id="3-1-RunLoop和NSThread的关系"><a href="#3-1-RunLoop和NSThread的关系" class="headerlink" title="3.1 RunLoop和NSThread的关系"></a>3.1 RunLoop和NSThread的关系</h3><p><code>RunLoop</code>是用于控制线程生命周期并接收事件进行处理的机制，其实质是一个<code>do-While</code>循环。在苹果文档找到关于<a href="https://links.jianshu.com/go?to=https://developer.apple.com/documentation/foundation/nsrunloop%23//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a>的介绍如下：</p><blockquote><p>Your application neither creates or explicitly manages NSRunLoop objects. Each NSThread object—including the application’s main thread—has an NSRunLoop object automatically created for it as needed. If you need to access the current thread’s run loop, you do so with the class method currentRunLoop.</p></blockquote><p>总结<code>RunLoop</code>与<code>NSThread</code>(线程)之间的关系如下：</p><ol><li><code>RunLoop</code>与线程是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ol><h3 id="3-2-RunLoop和AutoreleasePool的关系"><a href="#3-2-RunLoop和AutoreleasePool的关系" class="headerlink" title="3.2 RunLoop和AutoreleasePool的关系"></a>3.2 RunLoop和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote><p>如上所述，主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</p><h3 id="3-3-Thread和AutoreleasePool的关系"><a href="#3-3-Thread和AutoreleasePool的关系" class="headerlink" title="3.3 Thread和AutoreleasePool的关系"></a>3.3 Thread和AutoreleasePool的关系</h3><p>在<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html%23//apple_ref/doc/uid/TP40003623">苹果文档</a>中找到两者关系的介绍如下：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</p></blockquote><p>如上所述， 包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</p><h2 id="四、AutoreleasePool在主线程上的释放时机"><a href="#四、AutoreleasePool在主线程上的释放时机" class="headerlink" title="四、AutoreleasePool在主线程上的释放时机"></a>四、AutoreleasePool在主线程上的释放时机</h2><h3 id="4-1-理解主线程上的自动释放过程"><a href="#4-1-理解主线程上的自动释放过程" class="headerlink" title="4.1 理解主线程上的自动释放过程"></a>4.1 理解主线程上的自动释放过程</h3><p>分析主线程<code>RunLoop</code>管理自动释放池并释放对象的详细过程，我们在如下Demo中的主线程中设置断点，并执行lldb命令：<code>po [NSRunLoop currentRunLoop]</code>，具体效果如下：</p><img src="/images/RunLoop/AutoreleasePool2.png" width = "70%" alt="" align=center /><p>我们看到主线程<code>RunLoop</code>中有两个与自动释放池相关的<code>Observer</code>，它们的 <code>activities</code>分别为<code>0x1</code>和<code>0xa0</code>这两个十六进制的数，转为二进制分别为<code>1</code>和<code>10100000</code>，对应<code>CFRunLoopActivity</code>的类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),          <span class="comment">//0x1，启动Runloop循环</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),            </span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>),        </span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>),  <span class="comment">//0xa0，即将进入休眠     </span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),   </span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),           <span class="comment">//0xa0，退出RunLoop循环  </span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>结合RunLoop监听的事件类型，分析主线程上自动释放池的使用过程如下：</p><ol><li>App启动后，苹果在主线程<code>RunLoop</code>里注册了两个<code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>;</li><li>第一个<code>Observer</code>监视的事件是<code>Entry</code>(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code>创建自动释放池。<code>order = -2147483647</code>(即32位整数最小值)表示其优先级最高，可以保证创建释放池发生在其他所有回调之前;</li><li>第二个<code>Observer</code>监视了两个事件<code>BeforeWaiting</code>(准备进入休眠)时调用<code>_objc_autoreleasePoolPop()</code>和<code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code>来释放自动释放池。<code>order = 2147483647</code>(即32位整数的最大值)表示其优先级最低，保证其释放池子发生在其他所有回调之后;</li><li>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 <code>RunLoop</code>创建好的<code>AutoreleasePool</code>环绕着，所以不会出现内存泄漏，开发者也不必显示创建<code>AutoreleasePool</code>了;</li></ol><p>最后，也可以结合图示理解主线程上自动释放对象的具体流程：</p><img src="/images/RunLoop/AutoreleasePool.png" width = "70%" alt="" align=center /><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h3 id="4-2-测试主线程上的对象自动释放过程"><a href="#4-2-测试主线程上的对象自动释放过程" class="headerlink" title="4.2 测试主线程上的对象自动释放过程"></a>4.2 测试主线程上的对象自动释放过程</h3><p>下面的代码创建了一个Autorelease对象<code>string</code>，并且通过<code>weakString</code>进行弱引用(不增加引用计数，所以不会影响对象的生命周期)，具体如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">TestMemoryVC</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic,<span class="keyword">weak</span>)<span class="type">NSString</span> <span class="operator">*</span>weakString;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">TestMemoryVC</span></span><br><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>string <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;%@&quot;</span>,@<span class="string">&quot;WUYUBEICHEN&quot;</span>];</span><br><span class="line">    <span class="keyword">self</span>.weakString <span class="operator">=</span> string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewWillAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)viewDidAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;viewDidAppear:%@&quot;</span>, <span class="keyword">self</span>.weakString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line"><span class="comment">//viewWillAppear:WUYUBEICHEN</span></span><br><span class="line"><span class="comment">//viewDidAppear:(null)</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong>自动变量的<code>string</code>在离开<code>viewDidLoad</code>的作用域后，会依靠当前主线程上的<code>RunLoop</code>迭代自动释放。最终<code>string</code>对象在<code>viewDidAppear</code>方法执行前被释放(<code>RunLoop</code>完成此次迭代)。</p><h2 id="五、AutoreleasePool子线程上的释放时机"><a href="#五、AutoreleasePool子线程上的释放时机" class="headerlink" title="五、AutoreleasePool子线程上的释放时机"></a>五、AutoreleasePool子线程上的释放时机</h2><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><p>前面讲到过，ARC会根据一些情况进行优化，添加<code>__autoreleasing</code>修饰符，其实这就相当于对需要延时释放的对象调用了<code>autorelease</code>方法。从源码分析的角度来看，如果子线程中没有创建<code>AutoreleasePool</code> ，而一旦产生了<code>Autorelease</code>对象，就会调用<code>autoreleaseNoPage</code>方法自动创建<code>hotpage</code>，并将对象加入到其栈中。所以，一般情况下，子线程中即使我们不手动添加自动释放池，也不会产生内存泄漏。</p><h2 id="六、AutoreleasePool需要手动添加的情况"><a href="#六、AutoreleasePool需要手动添加的情况" class="headerlink" title="六、AutoreleasePool需要手动添加的情况"></a>六、AutoreleasePool需要手动添加的情况</h2><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><p>而在ARC环境下的实际开发中，我们最常遇到的也是第二种情况，以下面的代码为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj</code>因为离开作用域所以会被加入最近一次创建的自动释放池中，而这个释放池就是主线程上的<code>RunLoop</code>管理的；因为<code>for</code>循环在当前线程没有执行完毕，<code>Runloop</code>也就没有完成当前这一次的迭代，所以导致大量对象被延时释放。释放池中的对象将会在<code>viewDidAppear</code>方法执行前就被销毁。在此情况下，我们就有必要通过手动干预的方式及时释放不需要的对象，减少内存消耗；优化的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">1000000</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">             <span class="type">NSObject</span> <span class="operator">*</span>obj <span class="operator">=</span> [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">             <span class="type">NSLog</span>(@<span class="string">&quot;打印obj：%@&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Autorelease简介&quot;&gt;&lt;a href=&quot;#一、Autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;一、Autorelease简介&quot;&gt;&lt;/a&gt;一、Autorelease简介&lt;/h2&gt;&lt;p&gt;iOS开发中的Autorelease</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="RunLoop" scheme="https://tenloy.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>iOS-interview</title>
    <link href="https://tenloy.github.io/2021/04/06/iOS/Interview/"/>
    <id>https://tenloy.github.io/2021/04/06/iOS/Interview/</id>
    <published>2021-04-06T13:16:47.000Z</published>
    <updated>2021-05-27T09:20:16.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、算法与数据结构"><a href="#一、算法与数据结构" class="headerlink" title="一、算法与数据结构"></a>一、算法与数据结构</h2><blockquote><p> TLE    Time Limit Exceed(超时)</p></blockquote><ul><li>链表中是否有环</li><li>一个整型数组，将所有元素拼接成一个最大数输出</li><li>大型数组里面装了几万个数，找到前5个，不能用for循环。TopK问题，建小/大顶堆</li><li>贪心</li><li>LRU</li><li>N万个点勾勒一个国家的范围，然后染色</li><li>剑指offer 42：连续子数组的最大和</li><li>hash表</li><li>用底层设计一个缓存，上限是40mb</li><li>二叉树按层次遍历</li><li>数组链表的使用场景</li><li>数组底层内存如何优化</li><li>10进制转16进制 算法</li><li>寻找两个正序数组的中位数</li><li>接雨水</li></ul><h2 id="二、OC相关知识"><a href="#二、OC相关知识" class="headerlink" title="二、OC相关知识"></a>二、OC相关知识</h2><h3 id="2-1-TaggedPointer"><a href="#2-1-TaggedPointer" class="headerlink" title="2.1 TaggedPointer"></a>2.1 TaggedPointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *strongString;</span><br><span class="line">@property (nonatomic, weak)   NSString *weakString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D;  [NSString stringWithFormat:@&quot;%@&quot;,@&quot;string1&quot;];</span><br><span class="line">_weakString &#x3D;  _strongString;</span><br><span class="line"></span><br><span class="line">_strongString &#x3D; nil;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, _weakString);</span><br></pre></td></tr></table></figure><p><img src="/images/Interview/TaggedPoint.png" alt="TaggedPoint"></p><h3 id="2-2-KVO"><a href="#2-2-KVO" class="headerlink" title="2.2 KVO"></a>2.2 KVO</h3><ul><li>为什么KVO不释放 会闪退</li><li>推荐了一个facebook的安全使用kvo</li></ul><h3 id="2-3-KVC"><a href="#2-3-KVC" class="headerlink" title="2.3 KVC"></a>2.3 KVC</h3><h3 id="2-4-Block"><a href="#2-4-Block" class="headerlink" title="2.4 Block"></a>2.4 Block</h3><h4 id="2-4-1-Block1：讲讲Block的底层实现"><a href="#2-4-1-Block1：讲讲Block的底层实现" class="headerlink" title="2.4.1 Block1：讲讲Block的底层实现"></a>2.4.1 Block1：讲讲Block的底层实现</h4><ul><li>Block底层也是struct封装的，本质是个对象，拥有ISA指针</li><li>Block中的代码以函数的形式存在于代码段，Block对应的struct有一个指针类型成员，记录了函数地址</li><li>Block会对代码中使用到的局部变量进行捕获<ul><li>auto变量：值捕获</li><li>static变量：地址捕获</li><li>全局变量：不捕获，直接访问</li></ul></li></ul><h4 id="2-4-2-block的底层原理"><a href="#2-4-2-block的底层原理" class="headerlink" title="2.4.2 __block的底层原理"></a>2.4.2 __block的底层原理</h4><ul><li>编译器会将 __block变量包装成一个对象</li><li>再次使用的时候是实现的底层形成的 __Block_byref_xx_y类型的结构体中的成员变量</li></ul><h4 id="2-4-3-block会造成循环引用吗"><a href="#2-4-3-block会造成循环引用吗" class="headerlink" title="2.4.3 __block会造成循环引用吗"></a>2.4.3 __block会造成循环引用吗</h4><h4 id="2-4-4-例题"><a href="#2-4-4-例题" class="headerlink" title="2.4.4 例题"></a>2.4.4 例题</h4><ol><li><p>如果调用一个赋值为空的 block，会发生什么情况？闪退的那个地址值（address）是多少？为什么？</p><p>0x10. 参考Block的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;  &#x2F;&#x2F;地址值0x10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^test)(int);</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) test block;</span><br><span class="line">@property (nonatomic, assign) int b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    _b &#x3D; 1;</span><br><span class="line">    int a &#x3D; 100;</span><br><span class="line">    _block &#x3D; ^(int value)&#123;</span><br><span class="line">        return a+value+_b;  &#x2F;&#x2F; 问题2：block会捕获哪些变量？捕获了a、self</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_block class]);</span><br><span class="line">    </span><br><span class="line">    if (a&gt;10) &#123;</span><br><span class="line">        a &#x3D; 10;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        a &#x3D; 20;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;,_block(1)); &#x2F;&#x2F; 问题1：102。对a是值捕获，改变无效。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 问题3：如果该页面是二级页面，退出时，会调用dealloc吗？会，block是assign修饰的，block是在栈上，不对self产生强引用。如果修饰符换成copy呢？不会调用dealloc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-Runtime"><a href="#2-5-Runtime" class="headerlink" title="2.5 Runtime"></a>2.5 Runtime</h3><h4 id="2-5-1-Category中能添加成员变量吗？为什么？"><a href="#2-5-1-Category中能添加成员变量吗？为什么？" class="headerlink" title="2.5.1 Category中能添加成员变量吗？为什么？"></a>2.5.1 Category中能添加成员变量吗？为什么？</h4><p>分类的底层结构体中就没有ivars这个成员，存放不了成员变量。</p><h4 id="2-5-2-Category的数据在编译运行过程中具体是怎么处理的？"><a href="#2-5-2-Category的数据在编译运行过程中具体是怎么处理的？" class="headerlink" title="2.5.2 Category的数据在编译运行过程中具体是怎么处理的？"></a>2.5.2 Category的数据在编译运行过程中具体是怎么处理的？</h4><ol><li><p>通过Runtime加载某个类的所有Category数据</p></li><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中</p><ul><li>后面参与编译的Category数据，会在数组的前面</li></ul></li><li><p>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p></li></ol><h4 id="2-5-3-说说-load与-initialize"><a href="#2-5-3-说说-load与-initialize" class="headerlink" title="2.5.3 说说+load与+initialize"></a>2.5.3 说说+load与+initialize</h4><ol><li>调用时机：+load方法会在runtime加载类、分类时调用；+initialize方法会在类第一次接收到消息时调用</li><li>调用方式：+load方法是根据方法地址直接调用，并不是经过objc_msgSend函数调用；+initialize是通过objc_msgSend进行调用的</li></ol><h4 id="2-5-4-消息发送-传递机制"><a href="#2-5-4-消息发送-传递机制" class="headerlink" title="2.5.4 消息发送/传递机制"></a>2.5.4 消息发送/传递机制</h4><p>objc_msgSend()函数会依据接受者（调用方法的对象）的类型和选择子（方法名）来调用适当的方法。</p><ol><li>接收者会根据isa指针找到接收者自己所属的类，然后在所属类的”方法列表“（method list）中从上向下遍历。如果能找到与选择子名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果找不到与选择子名称相符的方法，接收者会根据所属类的superClass指针，沿着类的继承体系继续向上查找（向父类查找），如果 能找到与名称相符的方法，就根据IMP指针跳转到方法的实现代码，调用这个方法的实现。</li><li>如果在继承体系中还是找不到与选择子相符的方法，此时就会执行”<code>消息转发（message forwarding）</code>“操作。</li></ol><h4 id="2-5-5-消息转发"><a href="#2-5-5-消息转发" class="headerlink" title="2.5.5 消息转发"></a>2.5.5 消息转发</h4><p><img src="/images/Interview/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" alt="消息转发"></p><p>消息转发分为两大阶段。第一阶段叫做“动态方法解析（dynamic method resolution）”，或者叫“动态方法决议”。第二阶段涉及到“完整的消息转发机制（full forwarding mechanism）”，或者叫“完整的消息转发原理”。</p><h5 id="第一阶段：动态方法解析"><a href="#第一阶段：动态方法解析" class="headerlink" title="第一阶段：动态方法解析"></a>第一阶段：动态方法解析</h5><p>动态方法解析的意思就是，征询消息接受者所属的类，看其是否能动态添加方法，以处理当前“这个未知的选择子（unknown selector）“。实例对象在接受到无法解读的消息后，首先会调用其<code>所属类</code>的下列<code>类方法</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>类对象在接受到无法解读的消息后，那么运行期系统就会调用另外的一个方法，如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)selector</span><br></pre></td></tr></table></figure><p>如果运行期系统已经执行完了动态方法解析，那么消息接受者自己就无法再以动态新增方法的形式来响应包含该未知选择子的消息了，此时就进入了第二阶段——<code>完整的消息转发</code>。运行期系统会请求消息接受者以其他手段来处理与消息相关的方法调用。</p><h5 id="第二阶段：又细分为两小步"><a href="#第二阶段：又细分为两小步" class="headerlink" title="第二阶段：又细分为两小步"></a>第二阶段：又细分为两小步</h5><h5 id="2-1-备援接受者-replacement-receiver"><a href="#2-1-备援接受者-replacement-receiver" class="headerlink" title="2.1 备援接受者(replacement receiver)"></a>2.1 备援接受者(replacement receiver)</h5><p>当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)selector &#x2F;&#x2F;方法参数代表未知的选择子</span><br></pre></td></tr></table></figure><ul><li>若当前接收者能找到备援对象，则将其返回，此时运行期系统(Runtime)会把消息转给那个对象，消息转发过程结束</li><li>若找不到，就返回nil，此时启动完整的消息转发机制。</li></ul><p>通过此方案，我们可以用”组合”(composition)来模拟出“多重继承”(multiple inheritance) 的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p><p>请注意，我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</p><h5 id="2-2-完整的消息转发"><a href="#2-2-完整的消息转发" class="headerlink" title="2.2 完整的消息转发"></a>2.2 完整的消息转发</h5><p>首先创建NSInvocation对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标(target)及参数。<br>在触发NSInvocation对象时，“消息派发系统”(message-dispatch system)将亲自出马，把消息指派给目标对象。</p><p>此步骤需要先实现一个方法，来返回方法的签名：返回值类型、参数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure><p>然后会调用下列方法来转发消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation*)invocation</span><br></pre></td></tr></table></figure><p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p><h4 id="2-5-6-常见面试题"><a href="#2-5-6-常见面试题" class="headerlink" title="2.5.6 常见面试题"></a>2.5.6 常见面试题</h4><ul><li><p>Methodswizzing使用中遇到过什么问题吗，怎么避免</p></li><li><p>类和一些分类都hook( methodswizzing)了一个方法，会发生什么</p></li><li><p>a和b互换方法，c方法在不知情的状况下和a互换了方法，会有什么问题，a执行的是哪个方法，如何避免这个问题</p></li><li><p>本类一个方法，分类中有一个同名的方法，怎么调用本类的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)callClassMethod &#123;</span><br><span class="line">    u_int count;</span><br><span class="line">    Method *methods &#x3D; class_copyMethodList([Student class], &amp;count);</span><br><span class="line">    NSInteger index &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        SEL name &#x3D; method_getName(methods[i]);</span><br><span class="line">        NSString *strName &#x3D; [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">        if ([strName isEqualToString:@&quot;run&quot;]) &#123;</span><br><span class="line">            index &#x3D; i;  &#x2F;&#x2F; 先获取原类方法在方法列表中的索引。分类的在前，后面的本类中的会覆盖前面的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 调用方法</span><br><span class="line">    Student *stu &#x3D; [[Student alloc] init];</span><br><span class="line">    SEL sel &#x3D; method_getName(methods[index]);</span><br><span class="line">    IMP imp &#x3D; method_getImplementation(methods[index]);</span><br><span class="line">    ((void (*)(id, SEL))imp)(stu,sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分类文件 +声明 -实现，调用会崩溃吗，为什么</p></li><li><p>分类为什么不能扩展属性？用runtime 关联对象 为什么就能实现增加属性？内部数据结构怎么处理的的</p></li></ul><h3 id="2-6-RunLoop"><a href="#2-6-RunLoop" class="headerlink" title="2.6 RunLoop"></a>2.6 RunLoop</h3><h4 id="2-6-1-RunLoop的大概流程及常见运用"><a href="#2-6-1-RunLoop的大概流程及常见运用" class="headerlink" title="2.6.1 RunLoop的大概流程及常见运用"></a>2.6.1 RunLoop的大概流程及常见运用</h4><p>Timers Sources Blocks Source0 Source1</p><p>运用：线程保活、NSTimer滑动停止工作、监控引用卡顿(比如使用CADisplayLink，添加到runloop中)等</p><h4 id="2-6-2-自动释放池"><a href="#2-6-2-自动释放池" class="headerlink" title="2.6.2 自动释放池"></a>2.6.2 自动释放池</h4><p><a href="https://www.jianshu.com/p/7bd2f85f03dc">iOS内存管理-深入解析自动释放池</a></p><h5 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1) 实现原理"></a>1) 实现原理</h5><h5 id="2-NSThread、NSRunLoop、Autorelease的关系"><a href="#2-NSThread、NSRunLoop、Autorelease的关系" class="headerlink" title="2) NSThread、NSRunLoop、Autorelease的关系"></a>2) NSThread、NSRunLoop、Autorelease的关系</h5><p>总结<code>NSThread</code>(线程)与<code>RunLoop</code>之间的关系如下：</p><ul><li>线程与<code>RunLoop</code>是一一对应关系，每个线程(包括主线程)都有一个对应的<code>RunLoop</code>对象；其对应关系保存在一个全局的Dictionary里；</li><li>主线程的<code>RunLoop</code>默认由系统自动创建并启动；而其他线程在创建时并没有<code>RunLoop</code>，若该线程一直不主动获取，就一直不会有<code>RunLoop</code>；</li><li>苹果不提供直接创建<code>RunLoop</code>的方法；所谓其他线程<code>Runloop</code>的创建其实是发生在第一次获取的时候，系统判断当前线程没有<code>RunLoop</code>就会自动创建；</li><li>当前线程结束时，其对应的<code>Runloop</code>也被销毁；</li></ul><p><code>RunLoop</code>与<code>AutoreleasePool</code>的关系：</p><ul><li>主线程的<code>NSRunLoop</code>在监测到事件响应开启每一次<code>event loop</code>之前，会自动创建一个<code>autorelease pool</code>，并且会在<code>event loop</code>结束的时候执行<code>drain</code>操作，释放其中的对象。</li></ul><p><code>Thread</code>和<code>AutoreleasePool</code>的关系：</p><ul><li>包括主线程在内的所有线程都维护有它自己的自动释放池的堆栈结构。新的自动释放池被创建的时候，它们会被添加到栈的顶部，而当池子销毁的时候，会从栈移除。对于当前线程来说，Autoreleased对象会被放到栈顶的自动释放池中。当一个线程线程停止，它会自动释放掉与其关联的所有自动释放池。</li></ul><h5 id="3-AutoreleasePool在主线程上的释放时机"><a href="#3-AutoreleasePool在主线程上的释放时机" class="headerlink" title="3) AutoreleasePool在主线程上的释放时机"></a>3) AutoreleasePool在主线程上的释放时机</h5><ol><li>程序启动到加载完成后，主线程对应的<code>RunLoop</code>会停下来等待用户交互</li><li>用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。</li><li><code>RunLoop</code>检测到事件后，就会创建自动释放池;</li><li>所有的延迟释放对象都会被添加到这个池子中;</li><li>在一次完整的运行循环结束之前，会向池中所有对象发送<code>release</code>消息，然后自动释放池被销毁;</li></ol><h5 id="4-AutoreleasePool在子线程上的释放时机"><a href="#4-AutoreleasePool在子线程上的释放时机" class="headerlink" title="4) AutoreleasePool在子线程上的释放时机"></a>4) AutoreleasePool在子线程上的释放时机</h5><p>子线程默认不开启<code>RunLoo</code>p，那么其中的延时对象该如何释放呢？其实这依然要从<code>Thread</code>和<code>AutoreleasePool</code>的关系来考虑：</p><blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote><p>也就是说，每一个线程都会维护自己的 <code>Autoreleasepool</code>栈，所以子线程虽然默认没有开启<code>RunLoop</code>，但是依然存在<code>AutoreleasePool</code>，在子线程退出的时候会去释放<code>autorelease</code>对象。</p><h5 id="5-AutoreleasePool需要手动添加的情况"><a href="#5-AutoreleasePool需要手动添加的情况" class="headerlink" title="5) AutoreleasePool需要手动添加的情况"></a>5) AutoreleasePool需要手动添加的情况</h5><p>尽管ARC已经做了诸多优化，但是有些情况我们必须手动创建<code>AutoreleasePool</code>，而其中的延时对象将在当前释放池的作用域结束时释放。<a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html%23//apple_ref/doc/uid/20000047">苹果文档</a>中说明了三种情况，我们可能会需要手动添加自动释放池：</p><ol><li>编写的不是基于UI框架的程序，例如命令行工具；</li><li>通过循环方式创建大量临时对象；</li><li>使用非Cocoa程序创建的子线程；</li></ol><h4 id="2-6-3-其他"><a href="#2-6-3-其他" class="headerlink" title="2.6.3 其他"></a>2.6.3 其他</h4><ul><li>runloop运行逻辑</li><li>runloop跟线程什么关系，runloop怎么唤起线程</li><li>子线程的runloop怎么获取，具体应用场景有哪些</li><li>线程保活具体怎么做</li><li>你讲到runloop有多种mode,那为什么要设计多种mode呢，一个组合mode行不行</li></ul><h3 id="2-7-内存管理"><a href="#2-7-内存管理" class="headerlink" title="2.7 内存管理"></a>2.7 内存管理</h3><h4 id="2-7-1-iOS的内存管理机制"><a href="#2-7-1-iOS的内存管理机制" class="headerlink" title="2.7.1 iOS的内存管理机制"></a>2.7.1 iOS的内存管理机制</h4><h5 id="1-64位后出现的TaggedPoint"><a href="#1-64位后出现的TaggedPoint" class="headerlink" title="1) 64位后出现的TaggedPoint"></a>1) 64位后出现的TaggedPoint</h5><p>Tagged Pointer专门用来存储例如NSNumber、NSDate、NSString等小对象数据，这种数据绝大多数4字节都够满足需求了，在64位系统下就会造成极大的浪费，所以它会将值存在Tagged Pointer，而不是将它作为一个地址，值另外存储，它的内存并不存储在堆中，不需要malloc和free，可以极大得提高创建和读写效率，并且节省内存空间。</p><ul><li>当指针(8字节)不够存储数据时，才会使用动态分配内存的方式来存储数据<ul><li>NSString达到10位就放不下了</li><li>注意：当使用字符串字面量，给NSString实例赋值时，实例的类型是__NSCFConstantString，而不会是NSTaggedPointerString。其他数据类型使用字面量创建实例时，就没有这个限制</li></ul></li><li>objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销(消息发送流程)</li><li>release()方法中，释放之前，会先判断是否是TaggedPointer</li><li>如何判断一个指针是否为Tagged Pointer？iOS平台，指针的最高有效位是1(第64bit);   Mac平台，指针的最低有效位是1</li></ul><h5 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2) 引用计数"></a>2) 引用计数</h5><p>如果不是TaggedPoint，那么内存管理仍是靠引用计数的</p><h5 id="3-64位系统中，ISA的改变"><a href="#3-64位系统中，ISA的改变" class="headerlink" title="3) 64位系统中，ISA的改变"></a>3) 64位系统中，ISA的改变</h5><p>由普通的地址 → nonpointer (day10-Runtime ISA详解)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- OBJC 1.0</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    &#x2F;&#x2F; 在arm64架构之前，isa就是一个普通的指针，存储着Class、Meta-Class对象的内存地址</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">#pragma mark -- OBJC 2.0</span><br><span class="line">&#x2F;&#x2F;从arm64架构开始，对isa进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</span><br><span class="line">&#x2F;**</span><br><span class="line"> 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</span><br><span class="line"> *&#x2F;</span><br><span class="line">union isa_t</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">    #define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">    #define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">    #define ISA_MAGIC_VALUE 0x000001a000000001ULL  &#x2F;&#x2F; magic的值，如果对应的1a，表示对象已经初始化成功</span><br><span class="line">    #define RC_ONE          (1ULL&lt;&lt;45)</span><br><span class="line">    #define RC_HALF         (1ULL&lt;&lt;18)</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         注意，越前面的成员放在越低位</span><br><span class="line">         p&#x2F;x obj.isa &#x3D; 0000000000000000000 0 0 0 011010 000100000000000011110100111010101 0 0 1</span><br><span class="line">                         extra_rc                 magic             shiftcls                  nonpointer</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t nonpointer        : 1;  &#x2F;&#x2F; 0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span><br><span class="line">        &#x2F;**</span><br><span class="line">         objc_setAssociatedObject简单可以验证。</span><br><span class="line">         注意：是&#96;设置过&#96;，清除了也算。</span><br><span class="line">         如果没有，释放时会更快的意思是：见下源码</span><br><span class="line">         void *objc_destructInstance(id obj)&#123; &#x2F;&#x2F; objc-runtime-new.mm，对象在释放时调用</span><br><span class="line">             if (obj) &#123;</span><br><span class="line">                 if (obj-&gt;hasCxxDtor()) object_cxxDestruct(obj);  &#x2F;&#x2F; 有析构函数，调用析构函数</span><br><span class="line">                 if (obj-&gt;hasAssociatedObjects()) _object_remove_assocations(obj); &#x2F;&#x2F; 有关联对象，移除关联对象</span><br><span class="line">                 obj-&gt;clearDeallocating();</span><br><span class="line">             &#125;</span><br><span class="line">             return obj;</span><br><span class="line">         &#125;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_assoc         : 1;  &#x2F;&#x2F; 是否有设置过关联对象(associatedObject)，如果没有，释放时会更快</span><br><span class="line">        &#x2F;**</span><br><span class="line">         析构函数(destructor)与构造函数相反，是当对象的生命周期结束时，自动地被调用运行。它最主要的目的在于，清空并释放对象先前创建或是占用的存储器资源。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;  &#x2F;&#x2F; 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;&#x2F; shift cls 存储着Class、Meta-Class对象的内存地址信息</span><br><span class="line">        uintptr_t magic             : 6;  &#x2F;&#x2F; 用于在调试时分辨对象是否未完成初始化</span><br><span class="line">        &#x2F;**</span><br><span class="line">         加个__weak简单可以验证。</span><br><span class="line">         注意：是&#96;指向过&#96;，弱引用销毁了也算</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uintptr_t weakly_referenced : 1;  &#x2F;&#x2F; 是否有被弱引用指向过，如果没有，释放时会更快</span><br><span class="line">        uintptr_t deallocating      : 1;  &#x2F;&#x2F; 对象是否正在释放</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;  &#x2F;&#x2F; 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span><br><span class="line">        uintptr_t extra_rc          : 19; &#x2F;&#x2F; 里面存储的值是引用计数器减1 （举例的对象引用计数器是1，所以这里是0）</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-SideTables-—-引用计数、Weak引用的管理"><a href="#4-SideTables-—-引用计数、Weak引用的管理" class="headerlink" title="4) SideTables — 引用计数、Weak引用的管理"></a>4) SideTables — 引用计数、Weak引用的管理</h5><ul><li>weak哈希表怎么保存键值对的，说说哈希表的实现，以什么作为key保存到哈希表的</li></ul><p><img src="../../images/Interview/SideTables.png" alt="SideTables"></p><ul><li>弱引用表在APP中存在什么位置？(微博) MachO哪个段？数据段吧</li></ul><h5 id="5-C指针需要自己管理释放"><a href="#5-C指针需要自己管理释放" class="headerlink" title="5) C指针需要自己管理释放"></a>5) C指针需要自己管理释放</h5><h4 id="2-7-2-手写一个MRC-setter方法"><a href="#2-7-2-手写一个MRC-setter方法" class="headerlink" title="2.7.2 手写一个MRC setter方法"></a>2.7.2 手写一个MRC setter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setCar:(MJCar *)car</span><br><span class="line">&#123;</span><br><span class="line">    if (_car !&#x3D; car) &#123;   &#x2F;&#x2F; 需要先判断赋值与正在持有的值是否是同一个，避免错误release</span><br><span class="line">        [_car release];  &#x2F;&#x2F; 赋值之前，需要将之前的数据release</span><br><span class="line">        _car &#x3D; [car retain]; </span><br><span class="line">      &#x2F;*</span><br><span class="line">      MRC下：赋值给属性，引用计数是+1的，赋值给成员变量，引用计数不变。区别主要是在于Setter方法内部做的一次retain操作</span><br><span class="line">      ARC下：给成员变量赋值，也会对被赋值对象造成强引用(ARC下通过KVC来访问私有API)。</span><br><span class="line">      *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-3-weak的实现原理"><a href="#2-7-3-weak的实现原理" class="headerlink" title="2.7.3 weak的实现原理"></a>2.7.3 weak的实现原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">▼ dealloc</span><br><span class="line">  ▼ _objc_rootDealloc</span><br><span class="line">    ▼ rootDealloc</span><br><span class="line">      ▶ free</span><br><span class="line">      ▼ object_dispose</span><br><span class="line">        ▼ objc_destructInstance</span><br><span class="line">          ▶ object_cxxDestruct          &#x2F;&#x2F;调用C++析构函数(如果有的话)，会清除自己的成员变量</span><br><span class="line">          ▶ _object_remove_assocations  &#x2F;&#x2F;移除关联对象</span><br><span class="line">          ▶ clearDeallocating           &#x2F;&#x2F;将指向当前对象的弱指针置为nil</span><br><span class="line">        ▶ free</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">__weak <span class="keyword">typeof</span>(self) weakSelf = self;</span><br><span class="line">[weakSelf method];  <span class="comment">// 是否有问题？会崩溃，weak源码里会判断是否是deallocing，是这个状态的话就直接抛出异常了</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)method&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-4-野指针、僵尸对象"><a href="#2-7-4-野指针、僵尸对象" class="headerlink" title="2.7.4 野指针、僵尸对象"></a>2.7.4 野指针、僵尸对象</h4><ul><li><p>野指针：地址值是个不合法的地址。</p><ul><li>可能是不能访问的区域</li><li>可能是数据已经被释放</li></ul></li><li><p>僵尸对象：1个已经被释放的对象 就叫做僵尸对象。</p></li><li><p>使用**<code>野指针访问僵尸对象</code><strong>有的时候会出问题报错（</strong><code>EXC_BAD_ACCESS</code>**），有的时候不会出问题。</p><p>当OC对象<code>引用计数为0被释放</code>就变成了僵尸对象，此时僵尸对象的内存已经被系统回收，虽然该对象的数据可能还存在于内存中(申请空间时，才初始化)，但僵尸对象已经不是稳定对象，不可以再访问或者使用，它的内存是随时可能被别的对象申请而占用的。</p></li><li><p>僵尸对象的检测：在Xcode中设置Edit Scheme -&gt; Diagnostics -&gt; Zombie Objects</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zombie Objects hook 住了对象的dealloc方法，在回收对象时，不将其真的回收，而是把它转化为僵尸对象。这种对象所在的内存无法重用，因此不可遭到重写，所以将随机变成必然。</span><br><span class="line">系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择器，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序，这非常有利于调试。</span><br></pre></td></tr></table></figure></li><li><p>修改：检测到之后，把野指针置为nil即可</p></li></ul><h3 id="2-8-属性关键字、对象所有权修饰符"><a href="#2-8-属性关键字、对象所有权修饰符" class="headerlink" title="2.8 属性关键字、对象所有权修饰符"></a>2.8 属性关键字、对象所有权修饰符</h3><p>参考链接：<a href="https://juejin.cn/post/6844904067425124366">OC - 属性关键字和所有权修饰符</a></p><h4 id="2-8-1-assign-和-weak-关键字的区别有哪些？"><a href="#2-8-1-assign-和-weak-关键字的区别有哪些？" class="headerlink" title="2.8.1 assign 和 weak 关键字的区别有哪些？"></a>2.8.1 assign 和 weak 关键字的区别有哪些？</h4><ul><li><code>weak</code>只能修饰对象，而<code>assign</code>既可以修饰对象也可以修饰基本数据类型；</li><li><code>assign</code>修饰的对象在被释放后，指针仍然指向原对象地址；而<code>weak</code>修饰的对象在被释放之后会自动置指针为 nil；</li><li>相同点：在修饰对象的时候，<code>assign</code>和<code>weak</code>都不改变对象的引用计数。</li></ul><h4 id="2-8-2-copy-strong的底层实现-百度"><a href="#2-8-2-copy-strong的底层实现-百度" class="headerlink" title="2.8.2 copy strong的底层实现(百度)"></a>2.8.2 copy strong的底层实现(百度)</h4><p><a href="https://www.jianshu.com/p/bc16a644784d">https://www.jianshu.com/p/bc16a644784d</a></p><p><strong>结论</strong></p><ul><li><code>copy</code>和<code>strong</code>修饰的属性在底层编译的不一致，主要还是llvm中对其进行了不同的处理的结果。<code>copy</code>的赋值是通过<code>objc_setProperty</code>，而strong的赋值时通过<code>self + 内存平移</code>（即将指针通过平移移至name所在的位置，然后赋值），然后还原成 <code>strong</code>类型</li><li><code>strong &amp; copy</code> 在底层调用<code>objc_storeStrong</code>，本质是<code>新值retain，旧值release</code></li><li><code>weak</code> 在底层调用<code>objc_initWeak</code></li></ul><h2 id="三、运行库与三方库API"><a href="#三、运行库与三方库API" class="headerlink" title="三、运行库与三方库API"></a>三、运行库与三方库API</h2><h3 id="3-1-UI-—-UIKit-与-QuartzCore"><a href="#3-1-UI-—-UIKit-与-QuartzCore" class="headerlink" title="3.1 UI — UIKit 与 QuartzCore"></a>3.1 UI — UIKit 与 QuartzCore</h3><h4 id="3-1-1-触摸事件的分发机制"><a href="#3-1-1-触摸事件的分发机制" class="headerlink" title="3.1.1 触摸事件的分发机制"></a>3.1.1 触摸事件的分发机制</h4><p><a href="https://www.jianshu.com/p/74a2f44840fa">参考链接</a></p><ul><li>hitTest:withEvent:</li><li>pointInside:withEvent:</li></ul><h4 id="3-1-2-异步渲染"><a href="#3-1-2-异步渲染" class="headerlink" title="3.1.2 异步渲染"></a>3.1.2 异步渲染</h4><p>异步渲染就是在子线程进行绘制，然后拿到主线程显示。</p><p>UIView的显示是通过CALayer实现的，CALayer的显示则是通过contents进行的。异步渲染的实现原理是当我们改变UIView的frame时，会调用layer的setNeedsDisplay，然后调用layer的display方法。我们不能在非主线程将内容绘制到layer的context上，但我们单独开一个子线程通过<code>CGBitmapContextCreateImage()</code>绘制内容，绘制完成之后切回主线程，将内容赋值到contents上。</p><h4 id="3-1-3-离屏渲染"><a href="#3-1-3-离屏渲染" class="headerlink" title="3.1.3 离屏渲染"></a>3.1.3 离屏渲染</h4><p>什么是离屏渲染？</p><ul><li>如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。</li></ul><p>什么情况会导致离屏渲染？</p><ul><li><p>以阴影为例，为什么它会导致离屏渲染。因为<a href="https://cloud.tencent.com/product/gpu?from=10680">GPU</a>的渲染是遵循“画家算法”，一层一层绘制的，但阴影很特殊，它需要全部内容绘制完成，再根据外轮廓进行绘制。这就导致了，阴影这一层要一直占据一块内存区域，这就导致了离屏渲染。</p></li><li><p>类似导致离屏渲染的情况还有：</p><ul><li>cornerRadius+clipsToBounds</li><li>group opacity 组透明度</li><li>mask 遮罩</li><li>UIBlurEffect 毛玻璃效果</li></ul></li></ul><p>有一篇文章详细的讨论了这些情况：<a href="https://zhuanlan.zhihu.com/p/72653360">关于iOS离屏渲染的深入研究</a></p><h4 id="3-1-4-UIView与CALayer的关系"><a href="#3-1-4-UIView与CALayer的关系" class="headerlink" title="3.1.4 UIView与CALayer的关系"></a>3.1.4 UIView与CALayer的关系</h4><ul><li><p>创建UIView对象时，UIView内部会自动创建一个层(CALayer对象)，通过UIView的layer属性可以访问这个层。当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图渲染，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了UIView的显示</p></li><li><p>UIView相比CALayer最大区别是UIView继承自UIResponder，可以响应用户事件，而CALayer不可以；UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。</p></li><li><p>UIView本身，更像是一个CALayer的管理器，访问它的和绘图、坐标相关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性</p></li><li><p>UIView和CALayer是相互依赖的关系。UIView依赖CALayer提供的内容，CALayer依赖UIView提供的容器来显示绘制的内容。归根到底CALayer是这一切的基础，如果没有CALayer，UIView自身也不会存在，UIView是一个特殊的CALayer实现，添加了响应事件的能力。</p></li><li><p>高级：UIView的layer树形在系统内部被系统维护着三份copy</p><ul><li>逻辑树：就是代码里可以操纵的，例如更改layer的属性（阴影，圆角等）就在这一份</li><li>动画树：这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作</li><li>显示树：这棵树的内容是当前正被显示在屏幕上的内容</li><li>这三棵树的逻辑结构都是一样的，区别只有各自的属性</li></ul></li></ul><h4 id="3-1-5-Core-Animation"><a href="#3-1-5-Core-Animation" class="headerlink" title="3.1.5 Core Animation"></a>3.1.5 Core Animation</h4><ul><li><p>与UIView动画的关系：UIView动画其实就是对Core Animation的一种封装，向客户程序员呈现更简洁的接口</p></li><li><p>动画执行过程中是否响应事件？UIView的block animation在执行过程中不能响应其自身的触摸事件。</p></li><li><p>动画的属性（字节）</p><ul><li>CAAnimation  anchorpoint fillmode fillModeforward</li></ul></li></ul><h4 id="3-1-6-UITableView重用机制"><a href="#3-1-6-UITableView重用机制" class="headerlink" title="3.1.6 UITableView重用机制"></a>3.1.6 UITableView重用机制</h4><h4 id="3-1-7-CADisplayLink"><a href="#3-1-7-CADisplayLink" class="headerlink" title="3.1.7 CADisplayLink"></a>3.1.7 CADisplayLink</h4><p><strong>CADisplayLink是一个定时器对象，它可以让你与屏幕刷新频率相同的速率来刷新你的视图</strong><br> 目前iOS中的屏幕刷新速率是60Hz。也就是每秒刷新60次。那么我们可以利用CADisplayLink对象使我们想要执行的代码块每秒执行60次。当然我们也可以设置CADisplayLink的属性<code>preferredFramesPerSecond</code>来改变刷新次数为30次或15次。</p><p>CADisplayLink为什么比NSTimer精确？</p><ul><li><p>CADisplayLink 和 NSTimer 都需要注册到 runloop 的 model</p></li><li><p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。</p><p>那如果掉帧，CADisplayLink肯定也受影响吧</p></li><li><p> 既然都依赖 runloop，为什么NSTimer就会被runloop影响的不精确，CADisaplyLink就没事呢？</p></li><li><p><a href="https://www.cnblogs.com/xyq-208910/p/6590829.html">https://www.cnblogs.com/xyq-208910/p/6590829.html</a></p></li></ul><h3 id="3-2-Foundation"><a href="#3-2-Foundation" class="headerlink" title="3.2 Foundation"></a>3.2 Foundation</h3><ul><li>NSString、NSArray相关的类簇概念了解一下<ul><li>当hook方法时，要用真正的类名，不能用这个类簇名</li></ul></li></ul><h3 id="3-3-WebKit-—-WKWebview"><a href="#3-3-WebKit-—-WKWebview" class="headerlink" title="3.3 WebKit — WKWebview"></a>3.3 WebKit — WKWebview</h3><ul><li>cookie同步</li><li>post body</li><li>webp图片处理</li><li>NSURLProtocol的机制，有什么问题，拦截的成功率</li><li>除了NSURLProtocol还有什么方式能拦截请求：说hook ajax xmlhttprequest的open set方法</li><li>白屏检测：为什么会白屏，怎么监测，webViewWebContentProcessDidTerminate触发了就是白屏？因为其他问题，WK进程崩溃了，这个方法就不会调用吗</li><li>白屏优化</li><li>BRBridge的通信机制<ul><li>数据是怎么传递的，复杂数据是怎么编码、序列化、反序列化的</li><li>为什么要用iframe，原生的API message那一套行不行。不够灵活，且有兼容性，UIWebView、WKWebView之间不能无缝衔接</li></ul></li><li>webview的优化点：<ul><li>缓存</li><li>WKWebview进程是单独的，启动时涉及内核，所以耗时？要进行相关的优化吗？进程开始就创建一个，really？还是扯呢</li><li>HTTP2.0 相比HTTP1.1，报文压缩，加快传输速度</li><li>Webp图片压缩</li></ul></li></ul><h3 id="3-4-常见三方库"><a href="#3-4-常见三方库" class="headerlink" title="3.4 常见三方库"></a>3.4 常见三方库</h3><ul><li>看过什么源码</li><li>是带着问题看的，还是系统得看</li><li>带着什么问题，找到答案了吗。比如atomic的实现</li><li>二面确实就是问优化的东西：SD 和YYCache的缓存机制的区别，以及淘汰规则，最后设计一个LRU的方案</li><li>lottie的原理：lottie json 描述了 关键帧和参数，iOS通过解析iOS，转为代码 就可以实现动画</li></ul><h3 id="3-5-图像处理相关"><a href="#3-5-图像处理相关" class="headerlink" title="3.5 图像处理相关"></a>3.5 图像处理相关</h3><ul><li>png图片压缩机制</li><li>jpg png sd底层能够是如何解析的</li><li>webp 和 Lottie 在对动图的优化，webp压缩算法 丢弃了什么(通过丢掉 高频部分，达到一定程度的压缩??)<ul><li>webp 虽然解码时间边长了，但是100k的图片能压缩到4k不到？</li></ul></li></ul><h3 id="3-6-音视频相关"><a href="#3-6-音视频相关" class="headerlink" title="3.6 音视频相关"></a>3.6 音视频相关</h3><ul><li><a href="https://mp.weixin.qq.com/s/IGA3caeXMB-upTFiV8MuYg">极致首帧播放方案 - 零首帧解决方案 — 字节</a></li><li>学习资料，见《多读书》</li></ul><h3 id="3-6-Others"><a href="#3-6-Others" class="headerlink" title="3.6 Others"></a>3.6 Others</h3><ul><li>App 换肤(字节)</li><li>骨架屏：<a href="https://github.com/tigerAndBull/TABAnimated">https://github.com/tigerAndBull/TABAnimated</a></li><li>一个UIView如何实现UIScrollView，思路？加手势 调整 bounds？</li></ul><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><h3 id="4-1-多线程"><a href="#4-1-多线程" class="headerlink" title="4.1 多线程"></a>4.1 多线程</h3><h4 id="4-1-1-概念"><a href="#4-1-1-概念" class="headerlink" title="4.1.1 概念"></a>4.1.1 概念</h4><p><img src="../../images/Interview/Thread.png" alt="Thread"></p><h4 id="4-1-2-多线程的几种方案"><a href="#4-1-2-多线程的几种方案" class="headerlink" title="4.1.2 多线程的几种方案"></a>4.1.2 多线程的几种方案</h4><p>NSThread、GCD、NSOperationQueue的区别？各自的一些优点，以及应用场景</p><ul><li>NSThread：实现常驻线程，创建并开启RunLoop</li><li>GCD：dispatch_group、dispatch_barry、</li><li>NSOperationQueue：面向对象的封装，可以监控任务的状态、取消任务</li></ul><h4 id="4-1-3-串行-并行、同步-异步"><a href="#4-1-3-串行-并行、同步-异步" class="headerlink" title="4.1.3 串行/并行、同步/异步"></a>4.1.3 串行/并行、同步/异步</h4><ul><li>串行与并行是队列的属性：一个队列中，可以放很多task任务。<code>影响的是任务的执行方式</code><ul><li>串行队列：队列中的任务依次执行，一个执行完成之后，下一个才能开始(一次放出一个)</li><li>并行队列：队列中的任务并发执行，一个执行的同时，另一个可以同时执行(每当CPU访问该队列就放出一个)</li></ul></li><li>同步与异步是，同步异步函数赐予任务task的属性。<code>影响的是能不能开启新的线程</code></li><li>异步和一个并行队列结合：发布一次任务，就创建一个子线程，所以发布了多少个任务，会同时存在多少个线程(假设任务执行时间够长、系统不限制最大线程数)</li><li>异步和一个串行队列结合：发布一次任务，就创建一个子线程，但是无论发布多少次任务，都是同时只存在一个子线程(因为上一个任务完成，线程就回收了)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;微博一面：下面程序的耗时、打印顺序。A方法耗时2s</span><br><span class="line">dispatch_queue_t aSerialQueue &#x3D; dispatch_queue_create(“xxx_name”,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_async(aSerialQueue, ^(void) &#123;</span><br><span class="line">&#x2F;&#x2F; 1.执行方法A </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(aSerialQueue, ^(void) &#123;</span><br><span class="line">&#x2F;&#x2F; 2.执行方法A </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.执行方法A</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;答：1-2-3, 6s</span><br></pre></td></tr></table></figure><h4 id="4-1-4-常见的线程同步的手段"><a href="#4-1-4-常见的线程同步的手段" class="headerlink" title="4.1.4 常见的线程同步的手段"></a>4.1.4 常见的线程同步的手段</h4><ul><li><p>原子操作</p><p>我们在声明一个变量的时候一般会使用<code>nonatomic</code>，这个就是非原子操作；原子操作是<code>atomic</code>。</p><p>简单的加减使用原子操作具有更高的性能优势。注意是加减，不是增删！！</p><p>也就是说仅仅对于getter,setter是线程安全的，两个线程都去对变量赋值是安全的。对于比如NSMutableArray类型的增删操作不是线程安全的</p></li><li><p>线程锁</p><p>锁可以保护临界区，代码在临界区同一时间只会被一个线程执行。有互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等。</p></li><li><p>条件、信号量</p><p>有个BOOL类型的变量，当线程A进入临界区时把BOOL值置为NO，如果线程B准备进入临界区时发现BOOL值为NO就挂起等待，当线程A出临界区时把BOOL置为YES，线程B会被唤醒并继续执行。</p><p>条件就是使用信号量在线程之间相互发生信号。</p><p>条件通常被使用来说明资源可用性，或用来确保任务以特定的顺序执行。</p></li><li><p>使用Selector</p><p>selector方法允许你的线程以异步的方式来传递消息，以确保它们在同一个线程上面执行是同步的。</p><p>比如<code>NSObject</code>中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelectorInBackground:withObject:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-1-4-都有哪些锁"><a href="#4-1-4-都有哪些锁" class="headerlink" title="4.1.4 都有哪些锁"></a>4.1.4 都有哪些锁</h4><p>互斥锁、递归锁、读写锁、分布锁、自旋锁、双重检查锁等等</p><ul><li>说说读写锁</li></ul><p>分类自旋锁、互斥锁。性能从高到低排序(仅供参考，不同环境下有差异)</p><ul><li>os_unfair_lock(iOS10)</li><li>OSSpinLock</li><li>dispatch_semaphore(常用)</li><li>pthread_mutex（常用）</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive) （为了保证能递归加锁，内部肯定是有一些逻辑的，所以性能上稍差点）</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="4-1-5-死锁"><a href="#4-1-5-死锁" class="headerlink" title="4.1.5 死锁"></a>4.1.5 死锁</h4><p>死锁的原因：只有4个条件都满足时，才会出现死锁。</p><ul><li>互斥(Mutual exclusion)：任一时刻只允许一个进程使用资源;</li><li>请求和保持(Request and hold)：进程在请求其余资源时，不主动释放已经占用的资源; </li><li>非剥夺(Nonpreemptive)：进程已经占用的资源，不会被强制剥夺;</li><li>环路等待(Circular Wait)：环路中的每一条边是进程在请求另一进程已经占有的资源。</li></ul><p>如何解决？</p><h4 id="4-1-6-其他常见问题"><a href="#4-1-6-其他常见问题" class="headerlink" title="4.1.6 其他常见问题"></a>4.1.6 其他常见问题</h4><ul><li><p>如果要在GCD里面取消任务 怎么操作</p></li><li><p>创建队列的时候， 这个 label 你有没有用到过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li><li><p>多线程并发，多少比较合适，有没有了解过相关的标准。AFN、SD中都是多少</p></li><li><p>如果有多个任务来回做，它们有优先级的处理，要怎么做？（线程的优先级、任务的优先级可以理解为一个东西，都是任务的优先级，它与线程是绑定的）</p></li><li><p>已经执行的任务可能干扰不了，那排队未执行的任务根据优先级要怎么调整</p></li><li><p>多个异步任务依赖的处理方案</p></li><li><p>多读单写的实现：pthread_rwlock、dispatch_barrier_async</p></li><li><p>atomic是线程安全吗</p><p>atomic只能保证setter、getter方法之间是线程安全的。并不能保证使用属性、方法的过程是线程安全的，比如对NSMutableArray实例的使用，setter、getter过程是安全的，但接下来对NSMutableArray实例的使用（addObject）是有线程安全隐患的。还需要自己加锁</p><p>或者说，若属性是指针类型，只能保证对属性这个指针变量本身的读写是线程安全的，并不保证对指针指向的内存空间的读写是否线程安全</p></li><li><p>题目：启动N个线程，这N个线程要不间断按顺序打印数字1-N</p></li><li><p>多线程的线程安全问题(微博)</p></li></ul><h3 id="4-2-文件系统"><a href="#4-2-文件系统" class="headerlink" title="4.2 文件系统"></a>4.2 文件系统</h3><p>请尽可能详细地描述从磁盘上读取一份数据到CPU进行处理的过程中发生了什么？（网易，以下非标准答案）</p><ol><li>代码申请fopen，通过syscall中断进入内核态</li><li>内核开始在自己的结构体中寻找文件指向的vnode，检查文件权限和状态之后，创建file descriptor返回给程序</li><li>程序继续运行，申请读取文件，再次陷入内核态</li><li>内核发起IO中断，由文件系统驱动handle文件系统驱动进一步联系磁盘驱动，磁盘驱动转专交IO中断处理权给硬件</li><li>硬件读取文件内容进入mapped IO virtual memory就绪以后再次启动IO中断返回内核</li><li>内核从mapped vm内读取内容，在SMAP机制的设备上会继续调用copy_out将数据从内核态转移到进程的user space vm内</li><li>程序开始读取内核转交的内存</li></ol><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><p>请尽可能详细的描述在浏览器上输入一个网页地址到整个网页完全展示的过程中发生了什么？(网易，以下非标准答案)</p><ol><li>解析URL浏览器识别scheme头，识别类型http:// https:// mailto:// schemeHeaders://等，并应用用户的设置</li><li>解析URL识别到网页URI，发起dns请求定向主机，成功以后，开始准备协议: http协议、https协议。发起tcp连接，Chrome浏览器可能在一次tcp中传输多个http内容</li><li>https证书校验。强制https设置检查，检查是否有https网站请求了http资源，检查完成以后开始下载资源</li><li>网页html开始加载。通过chromium， webkit等引擎渲染网页，每一个资源下载完成都会触发一次差异渲染，但也有浏览器策略会要求全部css和js下载完成才开始渲染内容</li><li>调用网页申请的初始化js</li><li>渲染完成以后进入runloop监听事件，处理用户输入，调用js</li></ol><ol><li>首先是DNS解析。</li><li>数据链路层-源mac本机，如果是局域网，目的mac就是服务器的mac。如果是广域网目的mac就是路由器的mac。</li><li>ip层-源ip本机，如果是局域网，目的ip就是服务器的ip。如果是广域网目的ip就是路由器的ip。</li><li>tcp层-源端口系统随机分配，目的端口HTTP的话默认是80端口 HTTPS443</li><li>tcp三次握手，如果是https还有tls四次握手。</li><li>开始传输http数据。</li></ol><h3 id="5-1-HTTP1-1-2-0"><a href="#5-1-HTTP1-1-2-0" class="headerlink" title="5.1 HTTP1.1 2.0"></a>5.1 HTTP1.1 2.0</h3><ul><li><p>霜神的HTTP网络全套的blog</p></li><li><p>HTTPS与HTTP的关系，就是加了个SSL？SSL与TLS的关系</p></li><li><p>HTTP2.0了解吗，相比之前的优化</p><ul><li>报文压缩</li><li>请求头压缩，是怎么压缩的？</li><li>多路复用、分用</li><li>服务器推送？</li></ul></li></ul><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p><a href="https://juejin.cn/post/6844903901037084686">https://juejin.cn/post/6844903901037084686</a></p><h4 id="5-2-1-连接过程"><a href="#5-2-1-连接过程" class="headerlink" title="5.2.1 连接过程"></a>5.2.1 连接过程</h4><ul><li><p>HTTPS的连接过程：TLS SSL 预置密钥</p></li><li><p>握手阶段细分为五步: </p><ol><li>客户端发送出协议版本号，一个客户端生成的随机数，以及客户端支持的加密方法。 </li><li>服务端确认双方使用的加密方法，并给出数字证书以及一个服务器生成的随机数。</li><li>客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，发送给服务端。</li><li>服务端使用自己的私钥，解密出随机数。 </li><li>客户端和服务端根据约定的加密方法，使用前面的三个随机数生成对话密钥，用来加密接下来的对话。</li></ol></li><li><p>预备主密钥？？</p></li><li><p>如果第4步失败了，两端会怎么办？不知道是不是下面这个答案 <a href="https://halfrost.com/https_tls1-2_handshake/#toc-6">https://halfrost.com/https_tls1-2_handshake/#toc-6</a></p><ul><li>Server 拿到 EncryptedPreMasterSecret 以后，用自己的 RSA 私钥解密。解密以后还需要再次校验 PreMasterSecret 中的 ProtocolVersion 和 ClientHello 中传递的 ProtocolVersion 是否一致。如果不相等，校验失败，Server 会根据下面说的规则重新生成 PreMasterSecret，并继续进行握手。</li><li>在任何情况下，如果处理一个 RSA 加密的预备主密钥消息失败的时候，或版本号不是期望的时候，一个 TLS Server 一定不能产生一个警报。作为替代，它必须以一个随机生成的预备主密钥继续握手流程。出于定位问题的意图将失败的真正原因记录在日志中可能是有帮助的。但必须注意避免泄露信息给攻击者（例如，计时，日志文件或其它渠道）</li></ul></li></ul><h4 id="5-2-2-CA证书"><a href="#5-2-2-CA证书" class="headerlink" title="5.2.2 CA证书"></a>5.2.2 CA证书</h4><p>其中有什么内容：颁发机构、过期时间、密钥</p><h3 id="5-3-TCP"><a href="#5-3-TCP" class="headerlink" title="5.3 TCP"></a>5.3 TCP</h3><ul><li><p>TCP协议的流量控制机制、分片原理</p></li><li><p>三次握手与四次挥手</p><ul><li><p>讲一下三次握手与四次挥手的过程。握手为什么要三次、挥手为什么要四次？</p></li><li><p>三次握手与四次挥手：<a href="https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw">https://mp.weixin.qq.com/s/CzhBX1H_H37xFWEiYkumZw</a></p></li><li><p>三次握手：<a href="https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg">https://mp.weixin.qq.com/s/EEAADJBQwvgPiVwagUxUcg</a></p></li><li><p>四次挥手：<a href="https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA">https://mp.weixin.qq.com/s/oRBCqEcvfX7HEOWWx9i1RA</a></p></li></ul></li></ul><h3 id="5-4-Socket"><a href="#5-4-Socket" class="headerlink" title="5.4 Socket"></a>5.4 Socket</h3><ul><li>socket保证连接，心跳包</li></ul><h3 id="5-5-断点下载实现原理"><a href="#5-5-断点下载实现原理" class="headerlink" title="5.5 断点下载实现原理"></a>5.5 断点下载实现原理</h3><h3 id="5-6-POST数据格式"><a href="#5-6-POST数据格式" class="headerlink" title="5.6 POST数据格式"></a>5.6 POST数据格式</h3><p>默认POST提交方式是application/x-www-form-urlencoded，这个是application/json</p><h2 id="六、编译、链接、装载"><a href="#六、编译、链接、装载" class="headerlink" title="六、编译、链接、装载"></a>六、编译、链接、装载</h2><ul><li>编译过程<ul><li>中间的binding过程，可以做什么优化：减少动态库、动态库改静态库？</li></ul></li><li>app启动流程，从启动经历了哪些步骤</li><li>堆栈符号化定位</li><li>写一个APP，原则上一个文件就能搞定所有的事情，我们为什么还搞那么多文件，那么多类</li><li>内存和虚拟内存 如何映射</li><li>混合架构的framework 静态库 需要分离么</li><li>静态库中包含分类文件，如何调用。</li><li>为什么需要加Objc，静态库的加载流程，Objc的语义？</li><li>组件化编译慢怎么解决？</li></ul><h2 id="七、数据库"><a href="#七、数据库" class="headerlink" title="七、数据库"></a>七、数据库</h2><ul><li>以txt文本文件为例，实现类似数据库的增删改查，比如存储信息为通讯录：姓名 电话 手机号 超长的介绍</li><li>存储 文件和数据库 选择</li><li>比fmdb更好的优化方案</li></ul><h3 id="7-1-Protocol-Buffers-PB"><a href="#7-1-Protocol-Buffers-PB" class="headerlink" title="7.1 Protocol Buffers(PB)"></a>7.1 Protocol Buffers(PB)</h3><p>Protocol Buffers(简称Protobuf, PB) ，是Google出品的序列化框架，与开发语言无关，和平台无关，具有良好的可扩展性。Protobuf和所有的序列化框架一样，都可以用于数据存储、通讯协议。</p><p>Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#，<a href="https://link.jianshu.com/?t=https://developers.google.com/protocol-buffers/">官网地址</a>。</p><p>Portobuf的序列化的结果体积要比XML、JSON小很多，XML和JSON的描述信息太多了，导致消息要大；此外Portobuf还使用了Varint 编码，减少数据对空间的占用。</p><p>Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。</p><p><a href="https://juejin.cn/post/6844903622266847246">https://juejin.cn/post/6844903622266847246</a></p><ul><li>protobuf 是怎么进行解析的， 有啥可以优化点</li></ul><h2 id="八、软件工程"><a href="#八、软件工程" class="headerlink" title="八、软件工程"></a>八、软件工程</h2><h3 id="8-1-工程化"><a href="#8-1-工程化" class="headerlink" title="8.1 工程化"></a>8.1 工程化</h3><h3 id="8-2-UML"><a href="#8-2-UML" class="headerlink" title="8.2 UML"></a>8.2 UML</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80">UML</a> 是统一建模语言的简称，它是一种由一整套图表组成的标准化建模语言。UML用于帮助系统开发人员阐明，展示，构建和记录软件系统的产出。UML代表了一系列在大型而复杂系统建模中被证明是成功的做法，是开发面向对象软件和软件开发过程中非常重要的一部分。UML主要使用图形符号来表示软件项目的设计，使用UML可以帮助项目团队沟通、探索潜在的设计和验证软件的架构设计。</p><p>UML 图表可大致分为结构性图表和行为性图表两种。</p><ul><li><p>结构性图表显示了系统在不同抽象层次和实现层次上的静态结构以及它们之间的相互关系。</p></li><li><p>结构性图表中的元素表示系统中具意义的概念，可能包括抽象的、现实的和實作的概念。</p></li><li><p>结构性图表有七种类型：类图、组件图…</p></li></ul><p>类图可以没用过，但最起码能看懂会画</p><h2 id="九、设计模式与框架"><a href="#九、设计模式与框架" class="headerlink" title="九、设计模式与框架"></a>九、设计模式与框架</h2><h3 id="9-1-Apple-MVC与传统MVC"><a href="#9-1-Apple-MVC与传统MVC" class="headerlink" title="9.1 Apple MVC与传统MVC"></a>9.1 Apple MVC与传统MVC</h3><h3 id="9-2-MVVM"><a href="#9-2-MVVM" class="headerlink" title="9.2 MVVM"></a>9.2 MVVM</h3><ul><li>RAC 冷信号</li><li>RAC 数据流</li><li>RAC 如果出现 A-&gt;B-&gt;C-&gt;A, 那么怎么断环</li></ul><h3 id="9-3-MVP"><a href="#9-3-MVP" class="headerlink" title="9.3 MVP"></a>9.3 MVP</h3><p>优点：说了相比MVC的改进</p><p>缺点：说了相比MVVM的不足</p><h3 id="9-4-组件化"><a href="#9-4-组件化" class="headerlink" title="9.4 组件化"></a>9.4 组件化</h3><ul><li>模块解耦：中心化 去中心化</li><li>组件化、模块化的理解：划分粒度</li><li>组件化：多仓库、路由</li><li>组件化二进制化<ul><li>有赞：<a href="https://tech.youzan.com/you-zan-ji-yu-er-jin-zhi-de-bian-yi-ti-xiao-ce-lue/">https://tech.youzan.com/you-zan-ji-yu-er-jin-zhi-de-bian-yi-ti-xiao-ce-lue/</a></li><li>知乎：<a href="https://www.infoq.cn/article/hxh8ceu6st5xwolyynt8">https://www.infoq.cn/article/hxh8ceu6st5xwolyynt8</a></li></ul></li></ul><h3 id="9-5-设计模式"><a href="#9-5-设计模式" class="headerlink" title="9.5 设计模式"></a>9.5 设计模式</h3><ul><li><p>常用的设计模式，熟练哪一个，用纸笔画一下类图，什么结构、联系</p></li><li><p>平时会画类图吗，如果不画，那平时设计架构，怎么跟别人沟通讲解呢，每个类在干什么、具体什么联系、别人怎么修改你的</p></li><li><p>一些设计模式的优缺点</p></li><li><p>看过AF源码 ，AF用了哪些设计模式（58同城）</p></li></ul><h2 id="十、性能问题监测及优化-必问"><a href="#十、性能问题监测及优化-必问" class="headerlink" title="十、性能问题监测及优化(必问)"></a>十、性能问题监测及优化(必问)</h2><h3 id="10-1-流畅性-FPS"><a href="#10-1-流畅性-FPS" class="headerlink" title="10.1 流畅性(FPS)"></a>10.1 流畅性(FPS)</h3><ul><li><a href="https://blog.csdn.net/Hello_Hwc/article/details/84311933?utm_source=app&app_version=4.5.7">iOS 性能优化 - TimeProfiler分析代码耗时</a></li><li>卡顿检测：<ul><li>例如runloop能检测卡顿 是在runloop哪个阶段 多线程runloop收集到卡顿 如何告诉主线程</li><li>子线程一直去ping主线程 算不算？</li><li>不然就是FPS监控 CADisplayLink 其他不知道了</li></ul></li></ul><h3 id="10-2-内存"><a href="#10-2-内存" class="headerlink" title="10.2 内存"></a>10.2 内存</h3><blockquote><p>OOM，是 Out of Memory 的缩写，指的是 App 占用的内存达到了 iOS 系统对单个 App 占用内存上限后，而被系统强杀掉的现象</p></blockquote><ul><li>内存过高被杀死，如何定位大概位置</li><li>内存泄露监控，说一下思路（如果你自己写一个检测内存泄露的工具，你会怎么写）</li></ul><h3 id="10-3-崩溃"><a href="#10-3-崩溃" class="headerlink" title="10.3 崩溃"></a>10.3 崩溃</h3><blockquote><p> 检测、采集、防崩溃</p></blockquote><ul><li><p>Crash产生的原因，都有哪些种类：exception、signal等，</p></li><li><p>对于难处理的exception、signal是怎么处理的</p></li><li><p>NSSetUncaughtExceptionHandler一定能采集到吗？什么是采集不到的</p></li><li><p>后台崩溃是采集不到的，那怎么采集后台崩溃呢？</p></li><li><p>对于Mach层次的异常，是怎么捕获的</p><p>Mach为XNU的微内核，Mach异常为最底层的内核级异常，在iOS系统中，底层Crash先触发Mach异常，然后再转换为对应的signal信号。</p></li><li><p><a href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p></li><li><p><a href="https://time.geekbang.org/column/article/88600">12 | iOS 崩溃千奇百怪，如何全面监控？</a></p></li><li><p><a href="https://www.jianshu.com/p/930d7f77df6c">iOS中Crash采集及PLCrashReporter使用</a></p></li><li><p>自己编写防崩溃组件，功能：</p><ul><li>常见崩溃的预防拦截<ul><li>比如给NSArray、NSDictionary添加分类，hook方法，处理insert nil的crash</li><li>运用消息转发机制，处理unrecognized selector的方法</li><li>这些拦截，是一直开着，还是只debug开着，线上开着这个，会造成其它未知的错误吗  </li></ul></li><li>其它崩溃的采集、崩溃信息的可视化、统计<ul><li>都上传了什么数据：backtrace C函数获取调用堆栈。是什么时机调用的呢？</li><li>怎么可视化</li></ul></li></ul></li><li><p>bugly无法获取的崩溃有哪些</p></li><li><p>数组越界的处理，除了hook外，有什么更好的处理方式</p></li><li><p>Crash收集防护怎么做，常见的Crash场景，怎么收集上报的，OOM性能怎么监控，如果让你打造一款Bugly,你会考虑怎么设计</p></li><li><p>swift的crash怎么捕捉，好像oc的不适用？不知道swift的 但是Mach异常捕获 Unix信号捕获 应该都可以用</p></li><li><p><a href="https://faisalmemon.github.io/ios-crash-dump-analysis-book/zh/">https://faisalmemon.github.io/ios-crash-dump-analysis-book/zh/</a></p></li></ul><h3 id="10-4-网络层优化"><a href="#10-4-网络层优化" class="headerlink" title="10.4 网络层优化"></a>10.4 网络层优化</h3><ul><li>安全性<ul><li>防中间人攻击？单向校验，双向校验还是双向认证</li><li>AFN中关于安全校验的一些API</li><li>了解榕树贷款的证书机制</li></ul></li><li>了解别人能抓包的原因，配置的什么证书就可以了？为什么可以？处于证书信任链中？<ul><li>https抓包是怎么实现的？就是charls原理 中间人劫持 模拟发送请求</li><li><a href="https://www.jianshu.com/p/405f9d76f8c4">https://www.jianshu.com/p/405f9d76f8c4</a></li></ul></li><li>HTTPDNS</li><li>弱网优化<ul><li>一般是可以通过重试和改用udp来改善用户体验<ul><li>疑问：目的是提高弱网下的请求成功率。重试的话，请求太多也会造成问题吧？这里应该有更细的策略。</li><li>然后UDP，我可以理解为减少了握手所以更快资源更少，但UDP怎么解决可靠性问题？<ul><li>QUIC 全称 Quick UDP Internet Connection, 是谷歌公司研发的一种基于 UDP 协议的低时延互联网传输协议。在2018年IETF会议中，HTTP-over-QUIC协议被重命名为HTTP/3，并成为 HTTP 协议的第三个正式版本。参考链接：<a href="https://cloud.tencent.com/developer/article/1407615">QUIC网络协议简介</a></li></ul></li></ul></li><li>apns携带一部分数据过去，用户即使网络不好，通过通知打开应用也能展示<ul><li>APNS Payload 不能超过4096，之前貌似是256 提高到4096的</li></ul></li></ul></li></ul><h3 id="10-5-启动速度优化"><a href="#10-5-启动速度优化" class="headerlink" title="10.5 启动速度优化"></a>10.5 启动速度优化</h3><p>先知道启动流程 — 从点击图标到展示完成</p><p>每个节点的底层原理，premain之前的优化，didfinish的优化。</p><blockquote><p>优化方案及数据</p></blockquote><p>冷启动速度</p><ul><li>运行，有个环境变量，配置之后可以打印premain耗时情况</li><li>冷启动时间的统计：kill进程并不代表一定就是真正的冷启动流程，必须等刚刚运行时占用的内存被真正回收掉。可以卸载APP或者重启手机。1.2s左右</li><li>main阶段的时间统计：APPdelegate时间戳 - main函数时间戳。2.7 2.8s左右</li><li>插桩、重排是优化哪个阶段的，效果是多少。premain</li></ul><p>二进制重排</p><ul><li><p>为什么：缺页中断影响执行速度 </p></li><li><p>原理：Clang插桩</p></li><li><p>配置路径：build setting - order file</p></li></ul><h3 id="10-6-包体积优化"><a href="#10-6-包体积优化" class="headerlink" title="10.6 包体积优化"></a>10.6 包体积优化</h3><ul><li>优化手段：资源瘦身、代码瘦身等</li><li>怎么检测项目中无用代码<ul><li>背后的检测原理知道吗</li><li>检测出来的无用代码都是没有用的吗（可能是有用的，runtime会换方法）</li></ul></li></ul><p>注意：搞点高技术含量的，别说一些烂大街的</p><h3 id="10-7-LLVM中间代码优化"><a href="#10-7-LLVM中间代码优化" class="headerlink" title="10.7 LLVM中间代码优化"></a>10.7 LLVM中间代码优化</h3><blockquote><p>LLVM pass是否了解过，有编写过吗</p></blockquote><h3 id="10-8-应用安全"><a href="#10-8-应用安全" class="headerlink" title="10.8 应用安全"></a>10.8 应用安全</h3><h4 id="10-8-1-网络安全"><a href="#10-8-1-网络安全" class="headerlink" title="10.8.1 网络安全"></a>10.8.1 网络安全</h4><h4 id="10-8-2-防逆向"><a href="#10-8-2-防逆向" class="headerlink" title="10.8.2 防逆向"></a>10.8.2 防逆向</h4><h3 id="10-9-电量优化"><a href="#10-9-电量优化" class="headerlink" title="10.9 电量优化"></a>10.9 电量优化</h3><p>如果应用要一直更新定位，怎样操作才省电？</p><ul><li>pushkit</li></ul><h3 id="10-10-Xcode提供的优化手段"><a href="#10-10-Xcode提供的优化手段" class="headerlink" title="10.10 Xcode提供的优化手段"></a>10.10 Xcode提供的优化手段</h3><h4 id="10-10-1-Analyze静态分析"><a href="#10-10-1-Analyze静态分析" class="headerlink" title="10.10.1 Analyze静态分析"></a>10.10.1 Analyze静态分析</h4><p>僵尸对象诊断可以帮助快速定位多数情况下的野指针问题，但也有时候不能奏效，这个时候只能利用Xcode的Analyze静态分析帮助检查可能出问题的地方，仔细检查问题所在，比较费时。</p><p>使用方法很简单，选中Xcode顶部导航栏Product-Analyze或使用快捷键Command+Shift+B，分析需要花一些时间，然后左侧会列出编辑器发现的存在潜在问题的地方，选中蓝色图标对应的问题项会跳到问题项所在的代码行。但这只能给出一些潜在提示，帮助搜索问题所在，不一定和我们的bug相关。</p><h3 id="10-11-常见面试题"><a href="#10-11-常见面试题" class="headerlink" title="10.11 常见面试题"></a>10.11 常见面试题</h3><ul><li>做过哪些性能优化</li><li>线上有做性能检测措施吗？比如卡顿(FPS检查)上报(上报堆栈)</li><li>崩溃率有统计过吗？万2左右(Keep)算不错了</li><li>应用安全方面？<ul><li>ptrace 防lldb 远程debug</li></ul></li><li>APM （Application Performance Management，即应用性能管理，在分布式领域也称为分布式跟踪管理）对企业的应用系统进行实时监控，它是用于实现对应用程序性能管理和故障管理的系统化的解决方案。<ul><li>matrix(矩阵、模型)  —— 微信开源的工具 <a href="https://github.com/Tencent/matrix">https://github.com/Tencent/matrix</a></li></ul></li><li><a href="https://satanwoo.github.io/2017/07/30/xlog/">微信高性能线上日志系统xlog剖析 — SatanWoo</a></li><li>知道苹果原生出的性能检测框架吗？（百度）<ul><li>说是新特性</li><li><a href="https://mp.weixin.qq.com/s/66UvtkfPP3vDObLNk6W3Yg">使用 XCTest 消除动画卡顿？</a></li></ul></li></ul><h2 id="十一、Swift"><a href="#十一、Swift" class="headerlink" title="十一、Swift"></a>十一、Swift</h2><ul><li><p>oc怎么转换成SwiftUI</p></li><li><p>swift 为什么推荐使用 结构体，swift数组为什么选择使用 结构体。类和结构体的区别</p></li><li><p>静态库中swift与OC如何实现混编？</p></li><li><p>swift 与 OC混编 module的原理是什么？</p></li><li><p>swift 与 OC 混编 module的配置流程？</p></li><li><p>oc的 KVO 你已经知道了，那么 swift 的KVO 原理懂么</p></li><li><p>Swift的修饰词</p></li><li><p>转JSON：kakaJson、HandlyJson <a href="https://www.jianshu.com/p/e9d933ce7c74">https://www.jianshu.com/p/e9d933ce7c74</a></p><p><img src="../../images/Interview/JSONParsePerformance.jpeg" alt="Thread"></p></li></ul><h2 id="十二、JavaScript与RN"><a href="#十二、JavaScript与RN" class="headerlink" title="十二、JavaScript与RN"></a>十二、JavaScript与RN</h2><ul><li>跨平台的方案分析，选型以及优化点</li></ul><ol><li><p>原型继承</p></li><li><p>写过JS吗？获取一个元素试试？</p></li></ol><p>document.getElementById:()</p><ol start="3"><li>写过CSS样式吗？选择器的权重</li></ol><p>默认/继承样式 &lt; 标签选择器 &lt; 类选择器 &lt; “ID”选择器 &lt; 行内样式 &lt; “!important”修饰符</p><p>通配符选择器仅大于继承样式，但是不推荐使用</p><ol start="4"><li>组件的生命周期 </li></ol><p><a href="https://www.jianshu.com/p/7b4fe125aa92">https://www.jianshu.com/p/7b4fe125aa92</a></p><ol start="5"><li>props state 区别</li></ol><p><code>props（“properties” 的缩写）</code>和 <code>state</code> 都是普通的 <code>JavaScript</code> 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的几个重要的不同点就是：</p><ul><li><code>props</code> 是传递给组件的（类似于函数的形参），而 <code>state</code> 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</li><li><code>props</code> 是不可修改的，所有 <code>React</code> 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改。 由于 <code>props</code> 是传入的，并且它们不能更改，因此我们可以将任何仅使用 <code>props</code> 的 <code>React</code> 组件视为 <code>pureComponent</code>，也就是说，在相同的输入下，它将始终呈现相同的输出。</li><li><code>state</code> 是在组件中创建的，一般在 <code>constructor</code>中初始化 <code>state</code></li><li><code>state</code> 是多变的、可以修改，每次<code>setState</code>都异步更新的。</li></ul><h2 id="十三、开放题"><a href="#十三、开放题" class="headerlink" title="十三、开放题"></a>十三、开放题</h2><h3 id="13-1-项目"><a href="#13-1-项目" class="headerlink" title="13.1 项目"></a>13.1 项目</h3><ul><li>感觉有亮点的项目讲一下</li><li>遇到了哪些问题以及怎么解决的</li><li>开发中遇到问题是怎么排查的，讲一下解决问题的思路及手段</li></ul><h3 id="13-2-其他"><a href="#13-2-其他" class="headerlink" title="13.2 其他"></a>13.2 其他</h3><ul><li>哪个项目是你觉得最有经验、心得的？</li><li>最有成就感的一项技术产出是什么</li></ul><ul><li><p>如果多个组件，还有 弹窗，前后台切换，页面push等等 都可能 控制 播放器的播放和停止，那么你怎么设计一个无依赖的方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 通知。但通知有一个大问题，就是不好管理，然后没有传递链(抖音应该不会用这么low的方案...)</span><br><span class="line">2. 中间状态 statefulwidget（题目的意思可能在考察组件化的概念）</span><br><span class="line">3. 但感觉面试官不满意答案2...</span><br></pre></td></tr></table></figure></li></ul><h2 id="待归类"><a href="#待归类" class="headerlink" title="待归类"></a>待归类</h2><p>CI构建，编译打包流程；(Jenkins、fastlane。就是持续集成，讲讲你的理解，怎么配置，怎么构建之类)</p><ul><li>自动打包是其中的一个功能</li></ul><p>Runtime/Runloop这种机制，为啥要设计这种机制呢，编译时运行时；</p><p>几种多线程方案的利弊；</p><p>APP安装包都有什么，怎么瘦身，背后怎么做的，哪些场景可能会引起包体积增大；</p><p>怎么看待异常；</p><p>进程和线程；</p><p>对iOS新技术有关注吗（我说了Flutter，那Flutter具体怎么做的，事件响应怎么设计之类的。。。）</p><p>ˇ好未来</p><p>1：组件化 理解 解耦 方式<br>2：项目结构 模块<br>3：网络模块 怎么处理  AFNetWorking  源码  NSURLConnection  NSURLSession的区别<br>4:  HTTP HTTPS  加密过程<br>5：TCP网络三次握手<br>6：网络相关常见错误码<br>7：自动释放池  自动师范池与runloop的区别<br>8：堆和栈的区别<br>9：block  为什么要用copy修饰  注意点<br>10： 启动优化  load  initialize 的区别<br>11：App 打包成 api 做了那些事<br>12：自动化搭建<br>13：线上的问题的定位 修复 监护 卡顿<br>14：崩溃类型  解决方案<br>15：空指针<br>16：单例<br>17：设计模式<br>18：原生和H5的交互  释放时间 监控白屏 其他坑<br>19：内存占用  内存泄漏<br>20：卡顿：tableView    切圆角  离屏渲染<br>21：最近学习东西<br>22：isa </p><p>了解过 __ attribute__((constructor))相关函数么？作用是什么 ？</p><ul><li><p><a href="https://www.jianshu.com/p/dd425b9dc9db">https://www.jianshu.com/p/dd425b9dc9db</a></p></li><li><p><a href="https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html">https://tech.meituan.com/2018/12/06/waimai-ios-optimizing-startup.html</a></p></li></ul><p>多个非系统动态库的合并？需要合并么，如果需要，怎么合并</p><p>iOS6以下系统，默认navBar和tabBar都不占空间。</p><p>iOS7及以上系统默认：</p><ul><li>self.navigationController.navigationBar.translucent(半透明)为YES</li><li>self.edgesForExtendedLayout = UIRectEdgeAll</li><li>此时，self.view.frame.origin.y从0开始（屏幕最上部、navigationBar的顶部）。</li></ul><p>设置translucent=NO、与edgesForExtendedLayout=UIRectEdgeNone 都会使self.view.frame.origin.y下移(navBar高度)个像素，即self.view中的子控件布局从navBar下方开始</p><ul><li>如果只设置后者，由于navBar是透明的，会出现64像素的黑色区域。设置背景色、背景图片都有点问题，所以最好设置前者</li></ul><p>iOS7之后也增加了一个self.tabBarController.tabBar.translucent的属性，默认为YES。效果同上</p><p>注意：在viewDidLoad中打印self.view.frame是屏幕宽高，在viewWillAppear及之后的生命周期方法中，才会因为上面的设置而改变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、算法与数据结构&quot;&gt;&lt;a href=&quot;#一、算法与数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、算法与数据结构&quot;&gt;&lt;/a&gt;一、算法与数据结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; TLE    Time Limit Exceed(超时)</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
    <category term="interview" scheme="https://tenloy.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
