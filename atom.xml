<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenloy&#39;s Blog</title>
  
  <subtitle>学习 记录</subtitle>
  <link href="https://tenloy.github.io/atom.xml" rel="self"/>
  
  <link href="https://tenloy.github.io/"/>
  <updated>2022-09-07T02:38:36.225Z</updated>
  <id>https://tenloy.github.io/</id>
  
  <author>
    <name>Tenloy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS SQLite的使用与优化</title>
    <link href="https://tenloy.github.io/2022/05/05/sqlite.html"/>
    <id>https://tenloy.github.io/2022/05/05/sqlite.html</id>
    <published>2022-05-05T11:12:33.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-数据库方案"><a href="#iOS-数据库方案" class="headerlink" title="iOS 数据库方案"></a>iOS 数据库方案</h1><p>目前移动端数据库方案按其实现可分为两类，</p><ul><li><p><strong>关系型数据库</strong>，代表有CoreData、FMDB等。</p><ul><li><strong>CoreData</strong>：它是苹果内建框架，和Xcode深度结合，可以很方便进行ORM；但其上手学习成本较高，不容易掌握。稳定性也堪忧，很容易crash；多线程的支持也比较鸡肋。</li><li><strong>FMDB</strong>：它基于SQLite封装，对于有SQLite和ObjC基础的开发者来说，简单易懂，可以直接上手；而缺点也正是在此，FMDB只是将SQLite的C接口封装成了ObjC接口，没有做太多别的优化，即所谓的胶水代码(Glue Code)。使用过程需要用大量的代码拼接SQL、拼装Object，并不方便。</li></ul></li><li><p><strong>key-value数据库</strong>，代表有Realm、LevelDB、RocksDB等。</p><ul><li><strong>Realm</strong>：因其在各平台封装、优化的优势，比较受移动开发者的欢迎。对于iOS开发者，key-value的实现直接易懂，可以像使用NSDictionary一样使用Realm。并且ORM彻底，省去了拼装Object的过程。但其对代码侵入性很强，Realm要求类继承RLMObject的基类。这对于单继承的ObjC，意味着不能再继承其他自定义的子类。同时，key-value数据库对较为复杂的查询场景也比较无力。</li></ul></li></ul><p>可见，各个方案都有其独特的优势及劣势，没有最好的，只有最适合的。</p><h1 id="一、SQLite概述及其优点、不足"><a href="#一、SQLite概述及其优点、不足" class="headerlink" title="一、SQLite概述及其优点、不足"></a>一、SQLite概述及其优点、不足</h1><blockquote><p><a href="https://www.sqlite.org/">SQLite官方文档</a></p></blockquote><p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</p><p>就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。</p><h2 id="1-1-为什么要用-SQLite？"><a href="#1-1-为什么要用-SQLite？" class="headerlink" title="1.1 为什么要用 SQLite？"></a>1.1 为什么要用 SQLite？</h2><ul><li>不需要一个单独的服务器进程或操作的系统（无服务器的）。</li><li>SQLite 不需要配置，这意味着不需要安装或管理。</li><li>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</li><li>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</li><li>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</li><li>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</li><li>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</li><li>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</li><li>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</li></ul><h2 id="1-2-SQLite-局限性"><a href="#1-2-SQLite-局限性" class="headerlink" title="1.2 SQLite 局限性"></a>1.2 SQLite 局限性</h2><p>在 SQLite 中，SQL92 不支持的特性如下所示：</p><table><thead><tr><th align="left">特性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">查询 — 外连接</td><td align="left">只实现了 LEFT OUTER JOIN。不支持RIGHT OUTER JOIN、FULL OUTER JOIN</td></tr><tr><td align="left">修改 — ALTER TABLE</td><td align="left">支持修改表名称、添加字段命令，但不支持删除字段、修改字段的属性(名称、类型、宽度等) 。</td></tr><tr><td align="left">Trigger 支持</td><td align="left">支持 FOR EACH ROW 触发器，但不支持 FOR EACH STATEMENT 触发器。</td></tr><tr><td align="left">VIEWs</td><td align="left">在 SQLite 中，视图是只读的。您不可以在视图上执行 DELETE、INSERT 或 UPDATE 语句。</td></tr><tr><td align="left">GRANT 和 REVOKE</td><td align="left">可以应用的唯一的访问权限是底层操作系统的正常文件访问权限。</td></tr></tbody></table><h1 id="二、SQLite中的”连接“与”句柄“"><a href="#二、SQLite中的”连接“与”句柄“" class="headerlink" title="二、SQLite中的”连接“与”句柄“"></a>二、SQLite中的”连接“与”句柄“</h1><h2 id="2-1-MySQL的”连接“"><a href="#2-1-MySQL的”连接“" class="headerlink" title="2.1 MySQL的”连接“"></a>2.1 MySQL的”连接“</h2><p>数据库连接(database connection)是数据库服务器与客户端之间的通信联系（数据库也是个服务器，也需要远程连接操作）。客户通过数据库连接发送命令、接收服务器返回的结果。</p><ul><li><p>通过可执行文件，连接服务器</p><p>以下是从命令行中，使用MySQL二进制方式，连接MySQL数据库，进入到mysql命令提示符下来操作数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本实例中，使用root用户登录到mysql服务器，当然你也可以使用其他mysql用户登录。</span></span><br><span class="line"><span class="comment"># 如果用户权限足够，任何用户都可以在mysql的命令提示窗口中进行SQL操作。</span></span><br><span class="line">[root@host]<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password:******</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令执行后，登录成功输出结果如下:</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2854760 to server version: 5.0.9</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the buffer.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在登录成功后会出现 mysql&gt; 命令提示窗口，你可以在上面执行任何 SQL 语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 mysql&gt; 命令提示窗口可以使用 exit 命令，如下所示：</span></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">Bye</span><br></pre></td></tr></table></figure></li><li><p>通过代码连接，比如Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="comment">//static final String JDBC_DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;;  </span></span><br><span class="line">    <span class="comment">//static final String DB_URL = &quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">        Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开链接：连接数据库....</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行查询：实例化Statement对象...</span></span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>;</span><br><span class="line">        ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 展开结果集数据库</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="comment">// 通过字段检索</span></span><br><span class="line">            <span class="keyword">int</span> id  = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String url = rs.getString(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成后关闭</span></span><br><span class="line">        rs.close();</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>IBM DB2, Microsoft SQL Server, Oracle, MySQL, PostgreSQL, 与Neo4j使用连接池技术来改善性能。</p><p>建造连接时，通常要提供一个驱动程序或provider与一个连接字符串。例如，<code>Server=sql_box;Database=Common;User ID=uid;Pwd=password;</code></p><p>一旦连接建立，它可以被打开、关闭、设置性质。</p><h2 id="2-2-操作系统中句柄与文件"><a href="#2-2-操作系统中句柄与文件" class="headerlink" title="2.2 操作系统中句柄与文件"></a>2.2 操作系统中句柄与文件</h2><h3 id="2-2-1-操作系统中的”句柄“"><a href="#2-2-1-操作系统中的”句柄“" class="headerlink" title="2.2.1 操作系统中的”句柄“"></a>2.2.1 操作系统中的”句柄“</h3><blockquote><p>在程序设计中，句柄（handle）是Windows操作系统用来标识被应用程序所创建或使用的对象的整数。其本质相当于带有引用计数的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，可以使用句柄。</p><p>句柄与普通指针的区别在于：</p><ul><li>指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。</li><li>通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制。</li></ul><p>句柄与安全性：客户获得句柄时，句柄不仅是资源的标识符，也被授予了对资源的特定访问权限。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C 打开文件，返回文件指针(FILE是个结构体，记录了打开文件的一些信息)</span></span><br><span class="line"><span class="comment">// 操作系统把我们指定要打开文件的信息保存起来，并且返回给我们一个指向文件 信息的指针，称为文件指针。文件指针也可以理解为代指打开的文件。</span></span><br><span class="line"><span class="comment">// 指针的类型为 FILE 类型，FILE 是系统使用 typedef 定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。</span></span><br><span class="line"><span class="function">FILE * <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> level;        <span class="comment">// 缓冲区&quot;满&quot;或者&quot;空&quot;的程度</span></span><br><span class="line">    <span class="keyword">unsigned</span> flags;     <span class="comment">// 文件状态标志</span></span><br><span class="line">    <span class="keyword">char</span> fd;            <span class="comment">// Linux中叫做文件描述符，Windows中叫句柄</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> hold; <span class="comment">// 如无缓冲区不读取字符</span></span><br><span class="line">    <span class="keyword">short</span> bsize;        <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;<span class="comment">// 数据缓冲区的位置</span></span><br><span class="line">    <span class="keyword">unsigned</span> ar;        <span class="comment">// 指针，当前的指向</span></span><br><span class="line">    <span class="keyword">unsigned</span> istemp;    <span class="comment">// 临时文件，指示器</span></span><br><span class="line">    <span class="keyword">short</span> token;        <span class="comment">// 用于有效性的检查</span></span><br><span class="line">&#125; FILE;</span><br><span class="line"></span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">fp = fopen(<span class="string">&quot;../test&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>关于句柄，下面举一个实际的例子，在Linux中，值为0、1、2的fd分别代表标准输入、标准输出和标准错误输出。在程序中打开文件得到的fd从3开始增长。fd具体是什么呢？</p><p>在内核中，每一个进程都有一个私有的“打开文件表”，这个表是一个指针数组，每一个元素都指向一个内核的打开文件对象。而fd，就是这个表的下标。当用户打开一个文件时，内核会在内部生成一个打开文件对象，并在这个表里找到一个空项，让这一项指向生成的打开文件对象，并返回这一项的下标作为fd。由于这个表处于内核，并且用户无法访问到，因此用户即使拥有fd，也无法得到打开文件对象的地址，只能够通过系统提供的函数来操作。</p><p>在C语言里，操纵文件的渠道则是FILE结构，不难想象，C语言中的 FILE结构必定和fd有一对一的关系，每个FILE结构都会记录自己唯一对 应的fd。</p><h3 id="2-2-2-文件打开多次-多句柄"><a href="#2-2-2-文件打开多次-多句柄" class="headerlink" title="2.2.2 文件打开多次(多句柄)"></a>2.2.2 文件打开多次(多句柄)</h3><p>一个文件可以被打开多次(同一进程/不同进程)，返回的文件指针、fd(文件描述符/句柄)、文件的读写指针(光标)都不同，都是独立的。</p><ul><li>如果是不同进程中，因为打开文件表是每个进程私有的，得到的fd也是可能一样的。</li></ul><p>被打开多次时：</p><ul><li>记得要关闭多次 </li><li>此时，文件是可以同时读写的，需要注意避免读写冲突：<ul><li>如果打开模式是r/r+/w/w+，那写入的数据因为文件读写指针是独立的，所以会发生数据覆盖写入的问题。</li><li>如果打开模式是a/a+，那写入前会自动调整文件读写指针到文件末尾，<em>此时就是多线程/多进程并发操作文件的效果</em>。</li></ul></li></ul><p>所以，如果是多进程写日志的场景中，一个日志文件打开了多次，那写数据时，最好通过进程号标记每一条日志是由哪个进程写入的，因为各进程写入文件是随机的。</p><h2 id="2-3-SQLite中的”连接“与”句柄“"><a href="#2-3-SQLite中的”连接“与”句柄“" class="headerlink" title="2.3 SQLite中的”连接“与”句柄“"></a>2.3 SQLite中的”连接“与”句柄“</h2><p>SQLite作为应用或产品的嵌入式数据库，此时不是作为一个服务(server)在工作，对SQLite的操作，更类似于文件系统中，对本地文件的操作(打开/关闭)。API也很相似：（<em>但为了跟MySQL等数据库系统看齐，有时候也称这个文件打开操作是个创建连接</em>(<em>Connection</em>)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqlite3</span> &#123;</span></span><br><span class="line">  sqlite3_vfs *pVfs;            <span class="comment">/* OS Interface */</span></span><br><span class="line">  <span class="keyword">int</span> nDb;                      <span class="comment">/* Number of backends currently in use */</span></span><br><span class="line">  Db *aDb;                      <span class="comment">/* All backends */</span></span><br><span class="line">  <span class="keyword">int</span> flags;                    <span class="comment">/* Miscellaneous flags. See below */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> openFlags;       <span class="comment">/* Flags passed to sqlite3_vfs.xOpen() */</span></span><br><span class="line">  <span class="keyword">int</span> errCode;                  <span class="comment">/* Most recent error code (SQLITE_*) */</span></span><br><span class="line">  <span class="keyword">int</span> errMask;                  <span class="comment">/* &amp; result codes with this before returning */</span></span><br><span class="line">  <span class="comment">//....省略了超级多</span></span><br><span class="line">  sqlite3 *pBlockingConnection; <span class="comment">/* Connection that caused SQLITE_LOCKED */</span></span><br><span class="line">  sqlite3 *pUnlockConnection;           <span class="comment">/* Connection to watch for unlock */</span></span><br><span class="line">  <span class="keyword">void</span> *pUnlockArg;                     <span class="comment">/* Argument to xUnlockNotify */</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*xUnlockNotify)(<span class="keyword">void</span> **, <span class="keyword">int</span>);  <span class="comment">/* Unlock notify callback */</span></span><br><span class="line">  sqlite3 *pNextBlocked;        <span class="comment">/* Next in list of all blocked connections */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open a new database Connection. (官方文档中叫连接，源码中直接称Open a new database handle.)</span></span><br><span class="line"><span class="comment"> * @param ppDb 传入一个sqlite3 *指针的地址。这个地址会在函数执行完被赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqlite3_open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *filename,   <span class="comment">/* Database filename (UTF-8) */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    sqlite3 **ppDb          <span class="comment">/* OUT: SQLite db handle.*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Closing A Database Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqlite3_close</span><span class="params">(sqlite3*)</span></span>;</span><br></pre></td></tr></table></figure><p>这个传出参数 <code>ppDb</code> 定义与C语言中的<strong>文件指针</strong>很相似，一点都不符合操作系统中对句柄的定义。<strong>不知道为什么SQLite中将其叫做句柄。不过注意点就好了，知道sqlite3中的句柄本质上是个文件指针，区别于Windows句柄就行。</strong></p><h1 id="三、SQLite-简单使用示例"><a href="#三、SQLite-简单使用示例" class="headerlink" title="三、SQLite 简单使用示例"></a>三、SQLite 简单使用示例</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SQLite初体验原生实现(了解)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span>&#123;</span><br><span class="line">    sqlite3 *_db;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建数据库和打开数据库,只需要一个函数 sqlite3_open</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        参数1:创建出来的数据库,保存到沙盒的哪个路径中,路径的后缀以.db或是.sqlite结尾</span></span><br><span class="line"><span class="comment">        参数2:数据库实例,后面增,删,改,查都必须用到它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *dbPath = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@&quot;my.db&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有数据库,就创建并且打开</span></span><br><span class="line">    <span class="comment">//如果有数据,直接打开</span></span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_open([dbPath UTF8String], &amp;_db);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;创建和打开数据库的连接成功!!!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建表,新增,修改,删除,都用到一个函数 sqlite3_exec</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            参数1 数据库的实例</span></span><br><span class="line"><span class="comment">            参数2 要执行的创表的Sql</span></span><br><span class="line"><span class="comment">            参数3 成功之后的要执行的函数,如果不传,写NULL</span></span><br><span class="line"><span class="comment">            参数4 执行参数3函数的参数</span></span><br><span class="line"><span class="comment">            参数5 错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">NSString</span> *createSQLString = <span class="string">@&quot;create table if not exists T_student(studentId integer primary key,studentName text not null,studentAge integer default 20);&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</span><br><span class="line">        sqlite3_exec(_db, createSQLString.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (errmsg==<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;创建表成功了!!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,errmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)query&#123;</span><br><span class="line">    <span class="comment">//查询数据 sqlite3_prepare_v2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        参数1:数据库实例</span></span><br><span class="line"><span class="comment">        参数2:查询sql语句</span></span><br><span class="line"><span class="comment">        参数3:一般传入-1,让系统自动去算</span></span><br><span class="line"><span class="comment">        参数4:查询出来的结果集</span></span><br><span class="line"><span class="comment">        参数5:NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *queryAllSQLString = <span class="string">@&quot;select * from T_student;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果集合</span></span><br><span class="line">    sqlite3_stmt *stmt = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要查询成功了,stmt这个里面就会有数据</span></span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_prepare_v2(_db, queryAllSQLString.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;<span class="comment">//查询成功</span></span><br><span class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;<span class="comment">//遍历到一行数据，会自动判断有没有，没有就跳过这个循环</span></span><br><span class="line">            <span class="comment">//取出该行里面,需要的字段的值</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name = sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">NSString</span> *ocName = [[<span class="built_in">NSString</span> alloc] initWithCString:name encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="keyword">int</span> age  = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%@---%d&quot;</span>,ocName,age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h1 id="四、SQLite的两种日志模式"><a href="#四、SQLite的两种日志模式" class="headerlink" title="四、SQLite的两种日志模式"></a>四、SQLite的两种日志模式</h1><p>SQLite主要有两种日志模式(journal mode)：DELETE模式和WAL(Write-Ahead Log)模式，默认是DELETE模式。</p><p>DELETE模式下，日志文件记录的是数据页变更前的内容。当事务开启时，将db-page的内容写入日志，写操作直接修改db-page，读操作也是直接读取db-page，db-page存储了事务最新的所有更新，当事务提交时直接删除日志文件即可，事务回滚时将日志文件覆盖db-page文件，恢复原始数据。</p><blockquote><p>WAL：预写日志。是指在数据写入到数据库之前，先写入到日志。再将日志记录变更到存储器中。</p></blockquote><p>WAL模式下，日志文件记录的是数据变更后的内容。当事务开启时，写操作不直接修改db-page，而是以append的方式追加到日志文件末尾，当事务提交时不会影响db-page，直接将日志文件覆盖到db-page即可，事务回滚时直接将日志文件去掉即可。读操作也是读取日志文件，开始读数据时会先扫描日志文件，看需要读的数据是否在日志文件中，如果在直接读取，否则从对应的db-page读取，并引入.shm文件，建立日志索引，采用哈希索引来加快日志扫描。</p><p>两种模式对读写并发的影响：</p><ul><li>DELETE模式下因为读写操作都是直接在db-page上面进行，因此读写操作必须串行执行。</li><li>WAL模式下，读写操作都是在日志文件上进行，写操作会先append到日志文件末尾，而不是直接覆盖旧数据。而读操作开始时，会记下当前的日志文件状态，并且只访问在此之前的数据。这就确保了多线程<strong>读与读</strong>、<strong>读与写</strong>之间可以并发地进行。</li><li>更多关于WAL模式的内容可以阅读<a href="https://www.sqlite.org/">SQLite官方文档</a>。</li></ul><p>iOS中，如果使用了WAL模式，那么打开app沙盒里面的会有三种类型的文件：sqlite、sqlite-shm、sqlite-wal。</p><ul><li>sqlite-shm是共享内存(Shared Memory)文件，该文件里面会包含一份sqlite-wal文件的索引，系统会自动生成shm文件，所以删除它，下次运行还会生成。</li><li>sqlite-wal是预写式日志(Write-Ahead Log)文件，这个文件里面会包含尚未提交的数据库事务，所以看见有这个文件了，就代表数据库里面还有还没有处理完的事务需要提交，所以说如果有sqlite-wal文件，再去打开sqlite文件，很可能最近一次数据库操作还没有执行。</li></ul><p>在调试的时候，如果需要即时的观察数据库的变化，我们就可以先将日志模式设置为DELETE。</p><h1 id="五、数据库的升级"><a href="#五、数据库的升级" class="headerlink" title="五、数据库的升级"></a>五、数据库的升级</h1><h2 id="5-1-数据库升级是指什么？"><a href="#5-1-数据库升级是指什么？" class="headerlink" title="5.1 数据库升级是指什么？"></a>5.1 数据库升级是指什么？</h2><blockquote><p>先弄清楚数据库、数据库系统的区别。</p></blockquote><ul><li>表(Table)：以按行按列形式组织及展现的数据。一张表由表名、表中的字段和表的记录三个部分组成的。</li><li>数据库(Database)：相互之间有关联关系的Table的集合。<ul><li>数据库是电子化信息的集合。将信息规范化并使之电子化，形成电子信息 ‘库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul></li><li>数据库管理系统(Database Management System，DBMS)：能实现数据库的定义、操纵(增删改查)、控制(权限等)、维护(转储/恢复/重组/性能监测/分析)。<ul><li>其实可以就是个SDK，一般提供命令行工具、编程API两种使用方式。</li><li>常见的有：MySQL、SQL Server、DB2、Oracle Database等。</li></ul></li></ul><p><strong>一般移动端开发中的所说的数据库升级，无非就是对库、表的增删，对表结构(<em>设计数据表结构就是定义数据表文件名，确定数据表包含哪些字段，各字段的字段名、字段类型、及宽度</em>)的修改</strong>。</p><p>移动端中的数据库升级，需要考虑不同存量APP版本，升级时的不同处理：比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1: 表A 表B</span></span><br><span class="line"><span class="comment">// V2: 表A 表B 表C</span></span><br><span class="line"><span class="comment">// V3: 表A 表B 表C(Modify, 对表C进行修改)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么</span></span><br><span class="line"><span class="comment">//   1. 在开发V3时，就要考虑对V1、V2的不同处理：V1直接创建最新的表C、V2需要进行表的修改。</span></span><br><span class="line"><span class="comment">//   2. 需要保证已存储的数据不丢失。</span></span><br></pre></td></tr></table></figure><p>服务端开发中，因为数据库升级，不需要考虑上面的存量用户使用问题，所以很简单，不值一提。所以<strong>一般服务端开发人员所说的数据库升级是指数据库管理系统升级，比如MySQL版本升级。</strong></p><h2 id="5-2-表结构修改的几种处理方式"><a href="#5-2-表结构修改的几种处理方式" class="headerlink" title="5.2 表结构修改的几种处理方式"></a>5.2 表结构修改的几种处理方式</h2><p>数据库升级中库、表的增删不提，关于表结构修改的几种处理方式：</p><ul><li><p>直接删除旧表，丢弃已存储数据，再新建新表（<strong>除非评估后，数据可留可删。否则不推荐</strong>）</p></li><li><p><strong>如果SQLite支持要进行的操作</strong>：在已有表的基础上对表结构进行修改。（SQLite的ALTER TABLE命令非常局限，只支持重命名表以及添加新的字段。）</p><ul><li>优点：能够保留数据</li><li>缺点：规则比较繁琐，要建立一个数据库的字段配置文件，然后读取配置文件，执行SQL修改表结构、约束和主键等等，涉及到跨多个版本的数据库升级就变得繁琐并且麻烦了</li></ul></li><li><p><strong>如果SQLite不支持要进行的操作，比如：列的删除操作、字段名、长度、类型等属性的修改</strong>，那此时老表就不能用了，需要进行数据迁移操作。</p><ul><li>数据迁移：将旧表改名为临时表，然后创建新表 — 导入数据 — 删除临时表。(<em>或者先创建临时表，把数据导入到临时表，然后删除旧表，把临时表更名为旧表的名称，也行</em>)</li><li>优点：能够保留数据，支持表结构的修改，约束、主键的变更，实现起来比较简单</li><li>缺点：实现的步骤比较多</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建临时表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [new_table](id <span class="type">integer</span> <span class="keyword">primary</span> key, name text)</span><br><span class="line"># 导入数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [new_table] <span class="keyword">as</span> <span class="keyword">select</span> id, name <span class="keyword">from</span> [old_table]</span><br><span class="line"># 删除旧表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> [old_table]</span><br><span class="line"># 重命名临时表</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [new_table] rename <span class="keyword">to</span> [old_table]</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-3-数据库升级常见的几种方式"><a href="#5-3-数据库升级常见的几种方式" class="headerlink" title="5.3 数据库升级常见的几种方式"></a>5.3 数据库升级常见的几种方式</h2><p>假如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V1: 表A 表B</span></span><br><span class="line"><span class="comment">// V2: 表A 表B 表C</span></span><br><span class="line"><span class="comment">// V3: 表A 表B 表C2(Modify, 对表C进行了修改，称C修改后为C2)</span></span><br><span class="line"><span class="comment">// V4: 表A 表B2(M) 表C2</span></span><br><span class="line"><span class="comment">// V5: 表A2(M) 表B2 表C2 (即将发布的新版本)</span></span><br></pre></td></tr></table></figure><h3 id="5-3-1-最原始的SQLite"><a href="#5-3-1-最原始的SQLite" class="headerlink" title="5.3.1 最原始的SQLite"></a>5.3.1 最原始的SQLite</h3><p>在Android中，SQLiteOpenHelper 类中有一个方法<code>onUpgrade</code>，当我们创建对象的时候如果传入的版本号大于之前的版本号，该方法就会被调用，通过判断oldVersion 和 newVersion 就可以决定如何升级数据库。（iOS同理，只不过需要自己维护版本号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2、创建C2    &#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2、修改C-&gt;C2 &#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2、修改B-&gt;B2&#125; </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> == oldVersion) &#123; <span class="comment">//修改A-&gt;A2&#125; </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>要记录每个数据库版本的库、表结构</li><li>每次数据库有了新版本，都需要重写所有存量版本的 if 分支的升级处理。</li></ol><h3 id="5-3-2-只需记录每次迭代改动"><a href="#5-3-2-只需记录每次迭代改动" class="headerlink" title="5.3.2 只需记录每次迭代改动"></a>5.3.2 只需记录每次迭代改动</h3><p>谷歌在 2018 I/O 大会上发布了一系列辅助android开发者的实用工具，这套工具就是Jetpack，它是一套库、工具和指南的合集，可以帮助开发者更轻松地编写和构建出色的 Android 应用程序。</p><p>其中，ROOM就是 JetPack组件中的数据库框架。使用ROOM时，数据库升级时，只需要写出相比上次的更新就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_4_5 = <span class="keyword">new</span> Migration(<span class="number">4</span>,<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;migrate:&quot;</span>+database.getVersion());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `hermes_static_resource` (`url` TEXT NOT NULL, `file_name` TEXT NOT NULL, `file_path` TEXT NOT NULL, `download_status` INTEGER NOT NULL, `update_time` INTEGER NOT NULL, `create_time` INTEGER NOT NULL, PRIMARY KEY(`url`))&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `hermes_cert` (`domain_name` TEXT NOT NULL, `data` TEXT NOT NULL, `version` INTEGER NOT NULL, PRIMARY KEY(`domain_name`))&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS web_resource_data&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS CertificateBean&quot;</span>);</span><br><span class="line">            database.execSQL(<span class="string">&quot;DROP TABLE IF EXISTS PushMessage&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_5_6 = <span class="keyword">new</span> Migration(<span class="number">5</span>,<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(<span class="meta">@NonNull</span> SupportSQLiteDatabase database)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;chen&quot;</span>,<span class="string">&quot;migrate:&quot;</span>+database.getVersion());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            database.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS `orion_host` (`old_host` TEXT NOT NULL, `new_host` TEXT NOT NULL, `data` TEXT, `version` INTEGER NOT NULL, PRIMARY KEY(`old_host`))&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iOS方面也有相同的库：FMDB README_MD中推荐了FMDBMigrationManager开源库，来做数据库升级。</p><p>根据官方文档的解释，有两种方法实现升级：</p><p>第一种：每次升级对应一个文件。所谓升级文件，就是一些sql文件，在里面写入一些对数据库操作的语句。</p><ul><li>文件名的格式是固定的 <code>(数字)_(描述性语言).sql</code>。前面的数字就是所谓的版本号，官方建议使用时间戳，也可以使用1，2，3，4，5……升级，保持单调递增即可。</li><li>文件内写入要对数据库做的操作sql语句，比如<code>create table user(name TEXT, ....)</code>。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DBPath是要升级的数据库的地址 </span></span><br><span class="line"><span class="comment">// [NSBundle mainBundle]是保存数据库升级sql文件的位置 根据自己放文件的位置定。</span></span><br><span class="line">   <span class="comment">// FMDBMigrationManager 将会根据创建时给入的NSBundle自行寻找sql文件，对比版本号进行操作。</span></span><br><span class="line">FMDBMigrationManager * manager=[FMDBMigrationManager managerWithDatabaseAtPath:DBPath migrationsBundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> resultState=<span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSError</span> * error=<span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (!manager.hasMigrationsTable) &#123;</span><br><span class="line">    <span class="comment">// 执行完该语句，会发现我们的数据库中多了一个表 schema_migrations。为版本号表，记录数据库的版本号。</span></span><br><span class="line">    resultState=[manager createMigrationsTable:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据库升级到指定版本。UINT64_MAX 表示升级到最高版本</span></span><br><span class="line">resultState=[manager migrateDatabaseToVersion:<span class="built_in">UINT64_MAX</span> progress:<span class="literal">nil</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p>第二种：使用自定义类的形式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FMDBMigrationManager.h&quot;</span></span></span><br><span class="line"><span class="comment">// 首先定义一个新的类：Migration</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Migration</span> : <span class="title">NSObject</span>&lt;<span class="title">FMDBMigrating</span>&gt; // 遵循<span class="title">FMDBMigrating</span>协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于name和version都是只读的，因此我们要自定义一个init方法，传入描述 版本号和升级语句，升级语句最好用数组的方式传入，因为可能有多个升级语句。</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andVersion:(uint64_t)version andExecuteUpdateArray:(<span class="built_in">NSArray</span> *)updateArray;<span class="comment">//自定义方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与第一种拖入文件的方式相同，name是升级描述，version是版本号，最后一个方法里面，进行操作。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) uint64_t version;</span><br><span class="line">- (<span class="built_in">BOOL</span>)migrateDatabase:(FMDatabase *)database error:(<span class="keyword">out</span> <span class="built_in">NSError</span> *__autoreleasing *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  Migration.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Migration.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Migration</span>()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> * myName;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>)uint64_t myVersion;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSArray</span> * updateArray;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Migration</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name andVersion:(uint64_t)version andExecuteUpdateArray:(<span class="built_in">NSArray</span> *)updateArray&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _myName=name;</span><br><span class="line">        _myVersion=version;</span><br><span class="line">        _updateArray=updateArray;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name  &#123; <span class="keyword">return</span> _myName; &#125;</span><br><span class="line">- (uint64_t)version &#123; <span class="keyword">return</span> _myVersion; &#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)migrateDatabase:(FMDatabase *)database error:(<span class="keyword">out</span> <span class="built_in">NSError</span> *__autoreleasing *)error&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSString</span> * updateStr <span class="keyword">in</span> _updateArray)&#123;</span><br><span class="line">        [database executeUpdate:updateStr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用方法也很简单，将自定义类对象添加进manager即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FMDBMigrationManager * manager=[FMDBMigrationManager managerWithDatabaseAtPath:DBPath migrationsBundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line"></span><br><span class="line">Migration * migration_1=[[Migration alloc]initWithName:<span class="string">@&quot;新增USer表&quot;</span> andVersion:<span class="number">1</span> andExecuteUpdateArray:@[<span class="string">@&quot;create table User(name text,age integer)&quot;</span>]];</span><br><span class="line">Migration * migration_2=[[Migration alloc]initWithName:<span class="string">@&quot;USer表新增字段email&quot;</span> andVersion:<span class="number">2</span> andExecuteUpdateArray:@[<span class="string">@&quot;alter table User add email text&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 以后还想升级，在加入一个新的自定义对象，注意！！！版本号要保持递增</span></span><br><span class="line"></span><br><span class="line">[manager addMigration:migration_1];</span><br><span class="line">[manager addMigration:migration_2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> resultState=<span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSError</span> * error=<span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (!manager.hasMigrationsTable) &#123;</span><br><span class="line">    resultState=[manager createMigrationsTable:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultState=[manager migrateDatabaseToVersion:<span class="built_in">UINT64_MAX</span> progress:<span class="literal">nil</span> error:&amp;error];</span><br></pre></td></tr></table></figure><p><strong>看了一下实现代码，很简单，是根据版本号，循环将之前的数据库升级sql执行了一遍</strong>(<strong>简单粗暴</strong>)。而不是直接根据现有版本号与最新版本号，得出两者之间的差异，只做差异更新。</p><ul><li><em>不知道google出版的roomdb是怎么做的。</em></li><li>不过，因为我们每次都是指定的升级sql，而不是当次升级至的数据库状态。通过每次的sql语句，比较指定两次的差异，也不是很好做吧？下面这种提供了ORM形式的数据库升级，应该可以做到直接比较(<em>想到了git工作原理中，就是每次有</em>)。</li></ul><h3 id="5-3-3-与ORM相结合的升级"><a href="#5-3-3-与ORM相结合的升级" class="headerlink" title="5.3.3 与ORM相结合的升级"></a>5.3.3 与ORM相结合的升级</h3><p>比如CoreData、WCDB等，以后者为例。</p><p>WCDB 将数据库升级和 ORM 结合起来，对于需要增删改的字段，只需直接在 ORM 层面修改，并再次调用 createTableAndIndexesOfName:withClass: 接口即可自动升级。以下是一个数据库升级的例子。</p><ul><li><strong>删除字段</strong>：如例子中的 createTime 字段，删除字段只需直接将 ORM 中的定义删除即可。</li><li><strong>增加字段</strong>：如例子中的 aNewProperty 字段，增加字段只需直接添加 ORM 的定义即可。</li><li><strong>修改字段类型</strong>：如例子中的 content 字段，字段类型可以直接修改，但需要确保新类型与旧类型兼容。</li><li><strong>修改字段名称</strong>：如例子中的 aNewModifiedTime ，字段名称可以通过 WCDB_SYNTHESIZE_COLUMN(className, propertyName, columnName) 重新映射。</li><li><strong>增加约束</strong>：如例子中的 WCDB_UNIQUE(Message, aNewModifiedTime) ，新的约束只需直接在 ORM 中添加即可。</li><li><strong>增加索引</strong>：如例子中的 WCDB_INDEX(Message, “_newIndex”, aNewProperty) ，新的索引只需直接在 ORM 添加。</li></ul><img src="/images/sqlite/21.jpg" alt="wcdb-up" style="zoom:90%;" /><p>其他：有个ObjectBox，也支持ORM，跨平台 Android/iOS/Mac/Windows/Go。(Android同事用过)，号称世界最快嵌入式数据库；体积小(最小压缩到增加体积1MB) ；函数设计简单优雅；支持DSL；支持监听数据库；浏览器查看数据库，仅查看；根据配置生成的JSON文件自动迁移；不支持嵌套对象。</p><h1 id="六、SQLite的优化点"><a href="#六、SQLite的优化点" class="headerlink" title="六、SQLite的优化点"></a>六、SQLite的优化点</h1><blockquote><p>原文 — <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a></p></blockquote><p>随着微信iOS客户端业务的增长，在数据库上遇到的性能瓶颈也逐渐凸显。在<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=21#wechat_redirect">微信的卡顿监控系统</a>上，数据库相关的卡顿不断上升。而在用户侧也逐渐能感知到这种卡顿，尤其是有大量群聊、联系人和消息收发的重度用户。</p><p>我们在对SQLite进行优化的过程中发现，靠单纯地修改SQLite的参数配置，已经不能彻底解决问题。因此从6.3.16版本开始，我们合入了SQLite的源码，并开始进行源码层的优化。</p><p>本文将分享在SQLite源码上进行的多线程并发、I/O性能优化等，并介绍优化相关的SQLite原理。</p><h2 id="6-1-多线程并发优化"><a href="#6-1-多线程并发优化" class="headerlink" title="6.1 多线程并发优化"></a>6.1 多线程并发优化</h2><h3 id="6-1-1-背景"><a href="#6-1-1-背景" class="headerlink" title="6.1.1 背景"></a>6.1.1 背景</h3><p>由于历史原因，旧版本的微信一直使用单句柄的方案，即所有线程共有一个SQLite Handle，并用线程锁避免多线程问题。当多线程并发时，各线程的数据库操作同步顺序进行，这就导致后来的线程会被阻塞较长的时间。</p><h3 id="6-1-2-SQLite的多句柄方案及Busy-Retry方案"><a href="#6-1-2-SQLite的多句柄方案及Busy-Retry方案" class="headerlink" title="6.1.2 SQLite的多句柄方案及Busy Retry方案"></a>6.1.2 SQLite的多句柄方案及Busy Retry方案</h3><p>SQLite 支持三种线程模式：(<em><a href="https://www.sqlite.org/threadsafe.html">官方文档 — Using SQLite In Multi-Threaded Applications</a></em>)</p><ul><li>单线程（Single-thread） ，在此模式下，所有互斥锁都被禁用，并且SQLite连接不能在多个线程中使用。</li><li>多线程（Multi-thread），在此模式下，SQLite可以安全地由多个线程使用，前提是在两个或多个线程中不同时使用单个数据库连接。</li><li>串行（Serialized），在此模式下，SQLite可以被多个线程安全地使用而没有任何限制。（<strong>默认</strong>）</li></ul><p>线程模式可以在以下三种时间设置：</p><ul><li>编译时（从源代码编译 SQLite 库时）</li><li>启动时（当打算使用 SQLite 的应用程序正在初始化时）</li><li>运行时（当在应用程序中，创建新的 SQLite 数据库连接时）。</li><li>一般来说，运行时会覆盖启动时，启动时会覆盖编译时。注意：单线程模式一旦选择就不能被覆盖。</li></ul><p>所以，SQLite实际是支持多线程（几乎）无锁地并发操作。只需</p><ol><li>开启配置 <code>PRAGMA SQLITE_THREADSAFE=2</code></li><li>确保同一个句柄同一时间只有一个线程在操作</li></ol><blockquote><p>Multi-thread. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</p></blockquote><p>倘若再开启SQLite的WAL模式（Write-Ahead-Log），多线程的并发性将得到进一步的提升。</p><p>此时写操作会先append到wal文件末尾，而不是直接覆盖旧数据。而读操作开始时，会记下当前的WAL文件状态，并且只访问在此之前的数据。这就确保了多线程<strong>读与读</strong>、<strong>读与写</strong>之间可以并发地进行。</p><p>然而，阻塞的情况并非不会发生。</p><ul><li>当多线程写操作并发时，后来者还是必须在源码层等待之前的写操作完成后才能继续。</li></ul><p>SQLite提供了Busy Retry的方案，即发生阻塞时，会触发Busy Handler，此时可以让线程休眠一段时间后，重新尝试操作。重试一定次数依然失败后，则返回<code>SQLITE_BUSY</code>错误码。</p><p><img src="/images/sqlite/01.jpg" alt="01"></p><h3 id="6-1-3-SQLite-Busy-Retry方案的不足"><a href="#6-1-3-SQLite-Busy-Retry方案的不足" class="headerlink" title="6.1.3 SQLite Busy Retry方案的不足"></a>6.1.3 SQLite Busy Retry方案的不足</h3><p>Busy Retry的方案虽然基本能解决问题，但对性能的压榨做的不够极致。在Retry过程中，休眠时间的长短和重试次数，是决定性能和操作成功率的关键。</p><p>然而，它们的最优值，因不同操作不同场景而不同。</p><ul><li>若休眠时间太短，使得重试次数太多，会空耗CPU的资源；（<em>CPU重试加锁的时间里，是空转的，不响应任何别的工作程序。如下图中第二段红色Try Lock。</em>）</li><li>若休眠时间过长，会造成等待的时间太长；（<em>如下图第三段红色Sleep，CPU可用的情况下，因为sleep时间还没截止，会继续等待。</em>）</li><li>若重试次数太少，则会降低操作的成功率。</li></ul><p><img src="/images/sqlite/02.jpg" alt="01"></p><p>我们通过A/B Test对不同的休眠时间进行了测试，得到了如下的结果：</p><p><img src="/images/sqlite/03.jpg" alt="01"></p><p>可以看到，倘若休眠时间与重试成功率的关系，按照绿色的曲线进行分布，那么p点的值也不失为该方案的一个次优解。然而事总不遂人愿，我们需要一个更好的方案。</p><h3 id="6-1-4-SQLite中的线程锁及进程锁"><a href="#6-1-4-SQLite中的线程锁及进程锁" class="headerlink" title="6.1.4 SQLite中的线程锁及进程锁"></a>6.1.4 SQLite中的线程锁及进程锁</h3><p>作为有着十几年发展历史、且被广泛认可的数据库，SQLite的任何方案选择都是有其原因的。在完全理解由来之前，切忌盲目自信、直接上手修改。因此，首先要了解SQLite是如何控制并发的。</p><p><img src="/images/sqlite/04.png" alt="01"></p><p>SQLite是一个适配不同平台的数据库，不仅支持多线程并发，还支持多进程并发。它的核心逻辑可以分为两部分：</p><ul><li>Core层。包括了接口层、编译器和虚拟机。通过接口传入SQL语句，由编译器编译SQL生成虚拟机的操作码opcode。而虚拟机是基于生成的操作码，控制Backend的行为。</li><li>Backend层。由B-Tree、Pager、OS三部分组成，实现了数据库的存取数据的主要逻辑。</li></ul><p>在架构最底端的OS层是对不同操作系统的系统调用的抽象层。它实现了一个VFS（Virtual File System），将OS层的接口在编译时映射到对应操作系统的系统调用。锁的实现也是在这里进行的。</p><p>SQLite通过两个锁来控制并发：</p><ul><li>第一个锁对应DB文件，通过5种状态进行管理；</li><li>第二个锁对应WAL文件，通过修改一个16-bit的unsigned short int的每一个bit进行管理。</li></ul><p>尽管锁的逻辑有一些复杂，但此处并不需关心。这两种锁最终都落在OS层的<code>sqlite3OsLock</code>、<code>sqlite3OsUnlock</code>和<code>sqlite3OsShmLock</code>上具体实现。</p><p>它们在锁的实现比较类似。以lock操作在iOS上的实现为例：</p><ol><li><p>通过<code>pthread_mutex_lock</code>进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则返回<code>SQLITE_BUSY</code></p></li><li><p>通过<code>fcntl</code>进行文件锁，防止其他进程介入。若锁失败，则返回<code>SQLITE_BUSY</code></p><blockquote><p>多线程可以用多线程互斥量pthread_mutex_t实现线程之间上锁，那么多进程之间如何共享锁呢？</p><ul><li><p>使用文件锁<code>flock</code>实现多进程锁</p><p>由于文件锁是存放到位于内存的系统文件表中， 所有进程/线程可通过系统访问。如果不同进程使用同一文件锁（写锁/排他锁），当取得文件锁时，进程可继续执行；如果没有取得锁，则阻塞等待。而唯一标识该文件的是文件路径，因此，可以通过一个共同的文件路径，来实现多进程锁机制。</p></li><li><p>使用多线程锁实现多进程锁</p><p>多线程之间天然共享内存/变量，而多进程各有自己的进程空间，它们之间是不共享数据的。2个关键步骤</p><p>1）互斥锁变量存放到共享内存；</p><p>2）设置互斥锁变量的进程共享属性（PTHREAD_PROCESS_SHARED)；</p></li></ul></blockquote></li></ol><p>而SQLite选择Busy Retry的方案的原因也正是在此－－－<strong>文件锁没有线程锁类似pthread_cond_signal的通知机制。当一个进程的数据库操作结束时，无法通过锁来第一时间通知到其他进程进行重试。因此只能退而求其次，通过多次休眠来进行尝试。</strong></p><h3 id="6-1-5-优化开始"><a href="#6-1-5-优化开始" class="headerlink" title="6.1.5 优化开始"></a>6.1.5 优化开始</h3><p>通过上面的各种分析、准备，终于可以动手开始修改了。</p><p>我们知道，iOS app是单进程的，并<strong>没有多进程并发的需求</strong>，这和SQLite的设计初衷是不相同的。这就给我们的优化提供了理论上的基础。在iOS这一特定场景下，我们可以舍弃兼容性，提高并发性。</p><p>新的方案修改为，当OS层进行lock操作时：</p><ol><li>通过 <code>pthread_mutex_lock</code> 进行线程锁，防止其他线程介入。然后比较状态量，若当前状态不可跳转，则将当前期望跳转的状态，插入到一个FIFO的Queue尾部。最后，线程通过 <code>pthread_cond_wait</code> 进入休眠状态，等待其他线程的唤醒。</li><li>忽略文件锁</li></ol><p>当OS层的unlock操作结束后：</p><ol><li>取出Queue头部的状态量，并比较状态是否能够跳转。若能够跳转，则通过<code>pthread_cond_signal_thread_np</code>唤醒对应的线程重试。</li></ol><blockquote><p><code>pthread_cond_signal_thread_np</code> 是Apple在pthread库中新增的接口，与 <code>pthread_cond_signal</code> 类似，它能唤醒一个等待条件锁的线程。不同的是，<code>pthread_cond_signal_thread_np</code> 可以指定一个特定的线程进行唤醒。</p></blockquote><p><img src="/images/sqlite/05.jpg" alt="01"></p><p>新的方案可以在DB空闲时的第一时间，通知到其他正在等待的线程，最大程度地降低了空等待的时间，且准确无误。此外，由于Queue的存在，当主线程被其他线程阻塞时，可以将主线程的操作“插队”到Queue的头部。当其他线程发起唤醒通知时，主线程可以有更高的优先级，从而降低用户可感知的卡顿。</p><p>该方案上线后，卡顿检测系统检测到</p><ul><li>等待线程锁的造成的卡顿下降超过90%</li><li>SQLITE_BUSY的发生次数下降超过95%</li></ul><img src="/images/sqlite/06.jpg" alt="01" style="zoom:80%;" /><p><img src="/images/sqlite/07.png" alt="01"></p><h2 id="6-2-I-O-性能优化"><a href="#6-2-I-O-性能优化" class="headerlink" title="6.2 I/O 性能优化"></a>6.2 I/O 性能优化</h2><h3 id="6-2-1-保留WAL文件大小"><a href="#6-2-1-保留WAL文件大小" class="headerlink" title="6.2.1 保留WAL文件大小"></a>6.2.1 保留WAL文件大小</h3><p>如上文多线程优化时提到，开启WAL模式后，写入的数据会先append到WAL文件的末尾。待文件增长到一定长度后，SQLite会进行checkpoint。这个长度默认为1000个页大小，在iOS上约为3.9MB。</p><p>同样的，在数据库关闭时，SQLite也会进行checkpoint。不同的是，checkpoint成功之后，会将WAL文件长度删除或truncate到0。下次打开数据库，并写入数据时，WAL文件需要重新增长。而对于文件系统来说，这就意味着需要<strong>消耗时间重新寻找合适的文件块</strong>。</p><p>显然SQLite的设计是针对容量较小的设备，尤其是在十几年前的那个年代，这样的设备并不在少数。而随着硬盘价格日益降低，对于像iPhone这样的设备，几MB的空间已经不再是需要斤斤计较的了。</p><p>因此我们可以修改为：</p><ul><li>数据库关闭并checkpoint成功时，不再truncate或删除WAL文件只修改WAL的文件头的Magic Number。下次数据库打开时，SQLite会识别到WAL文件不可用，重新从头开始写入。</li></ul><blockquote><p>保留WAL文件大小后，每个数据库都会有这约3.9MB的额外空间占用。如果数据库较多，这些空间还是不可忽略的。因此，微信中目前只对读写频繁且检测到卡顿的数据库开启，如聊天记录数据库。</p></blockquote><h3 id="6-2-2-mmap优化"><a href="#6-2-2-mmap优化" class="headerlink" title="6.2.2 mmap优化"></a>6.2.2 mmap优化</h3><p>mmap对I/O性能的提升无需赘言，尤其是对于读操作。SQLite也在OS层封装了mmap的接口，可以无缝地切换mmap和普通的I/O接口。只需配置 <code>PRAGMA mmap_size=XXX</code> 即可开启mmap。</p><blockquote><p>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</p><p>Many operations, especially I/O intensive operations, can be much faster since content does need to be copied between kernel space and user space. In some cases, performance can nearly double.</p><p>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</p><p>使用内存映射 I/O 有利有弊。优点包括：</p><ul><li>许多操作，尤其是 I/O 密集型操作，可以更快。因为内容不再需要在内核空间和用户空间之间复制。在某些情况下，性能几乎可以翻倍。</li><li>SQLite 库可能需要更少的 RAM，因为它与操作系统页面缓存(page cache)共享pages，而且并不总是需要自己的工作页面(working pages)副本。</li></ul></blockquote><p>然而，你在iOS上这样配置恐怕不会有任何效果。因为早期的iOS版本的存在一些bug，SQLite在编译层就关闭了在iOS上对mmap的支持，并且后知后觉地在16年1月才重新打开。所以如果使用的SQLite版本较低，还需注释掉相关代码后，重新编译生成后，才可以享受上mmap的性能。</p><p><img src="/images/sqlite/08.jpg" alt="01"></p><p>开启mmap后，SQLite性能将有所提升，但这还不够。因为它只会对DB文件进行了mmap，而WAL文件享受不到这个优化。</p><p>WAL文件长度是可能变短的，而在多句柄下，对WAL文件的操作是并行的。一旦某个句柄将WAL文件缩短了，而没有一个通知机制让其他句柄更新mmap的内容。此时其他句柄若使用mmap操作已被缩短的内容，就会造成crash。而普通的I/O接口，则只会返回错误，不会造成crash。因此，SQLite没有实现对WAL文件的mmap。</p><p>还记得我们上一个优化吗？没错，我们保留了WAL文件的大小。因此它在这个场景下是不会缩短的，那么不能mmap的条件就被打破了。实现上，只需在WAL文件打开时，用<code>unixMapfile</code>将其映射到内存中，SQLite的OS层即会自动识别，将普通的I/O接口切换到mmap上。</p><h2 id="6-3-其他优化"><a href="#6-3-其他优化" class="headerlink" title="6.3 其他优化"></a>6.3 其他优化</h2><h3 id="6-3-1-禁用文件锁"><a href="#6-3-1-禁用文件锁" class="headerlink" title="6.3.1 禁用文件锁"></a>6.3.1 禁用文件锁</h3><p>如我们在多线程优化时所说，对于iOS app并没有多进程的需求。因此我们可以直接注释掉<code>os_unix.c</code>中所有文件锁相关的操作。</p><p>也许你会很奇怪，虽然没有文件锁的需求，但这个操作耗时也很短，是否有必要特意优化呢？其实并不全然。耗时多少是比出来。</p><p>SQLite中有cache机制。被加载进内存的page，使用完毕后不会立刻释放。而是在一定范围内通过LRU的算法更新page cache。这就意味着，如果cache设置得当，大部分读操作都不会读取新的page。然而因为文件锁的存在，本来这个只需在内存层面进行的读操作，不得不进行至少一次I/O操作。而我们知道，I/O操作是远远慢于内存操作的。</p><h3 id="6-3-2-禁用内存统计锁"><a href="#6-3-2-禁用内存统计锁" class="headerlink" title="6.3.2 禁用内存统计锁"></a>6.3.2 禁用内存统计锁</h3><p>SQLite会对申请的内存进行统计，而这些统计的数据都是放到同一个全局变量里进行计算的。这就意味着统计前后，都是需要加线程锁，防止出现多线程问题的。</p><p><img src="/images/sqlite/09.jpg" alt="01"></p><p>内存申请虽然不是非常耗时的操作，但却很频繁。多线程并发时，各线程很容易互相阻塞。</p><p>阻塞虽然也很短暂，但频繁地切换线程，却是个很影响性能的操作，尤其是单核设备。</p><p>因此，如果不需要内存统计的特性，可以通过<code>sqlite3_config(SQLITE_CONFIG_MEMSTATUS, 0)</code>进行关闭。这个修改虽然不需要改动源码，但如果不查看源码，恐怕是比较难发现的。</p><p>优化上线后，卡顿监控系统监测到</p><ul><li>DB写操作造成的卡顿下降超过80%</li><li>DB读操作造成的卡顿下降超过85%</li></ul><img src="/images/sqlite/10.jpg" alt="01" style="zoom:80%;" /><h2 id="6-4-数据库修复"><a href="#6-4-数据库修复" class="headerlink" title="6.4 数据库修复"></a>6.4 数据库修复</h2><blockquote><p>数据库修复指的是通过技术手段将损坏的数据库文件修复至可正常使用的数据库文件的过程。 </p></blockquote><h3 id="6-4-1-前言"><a href="#6-4-1-前言" class="headerlink" title="6.4.1 前言"></a>6.4.1 前言</h3><p>众所周知，微信在后台服务器不保存聊天记录，微信在移动客户端所有的聊天记录都存储在一个 SQLite 数据库中，一旦这个数据库损坏，将会丢失用户多年的聊天记录。而我们监控到现网的损坏率是0.02%，也就是每 1w 个用户就有 2 个会遇到数据库损坏。考虑到微信这么庞大的用户基数，这个损坏率就很严重了。更严重的是我们用的官方修复算法，修复成功率只有 30%。损坏率高，修复率低，这两个问题都需要我们着手解决。</p><h3 id="6-4-2-SQLite-损坏原因及其优化-降低损坏率"><a href="#6-4-2-SQLite-损坏原因及其优化-降低损坏率" class="headerlink" title="6.4.2 SQLite 损坏原因及其优化(降低损坏率)"></a>6.4.2 SQLite 损坏原因及其优化(降低损坏率)</h3><p>我们首先来看 SQLite 损坏的原因，SQLite官网(<a href="http://www.sqlite.org/howtocorrupt.html)%E4%B8%8A%E5%88%97%E5%87%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A">http://www.sqlite.org/howtocorrupt.html)上列出以下几点：</a></p><ul><li>文件错写</li><li>文件锁 bug</li><li>文件 sync 失败</li><li>设备损坏</li><li>内存覆盖</li><li>操作系统 bug</li><li>SQLite bug</li></ul><p>但是我们通过收集到的大量案例和日志，分析出实际上移动端数据库损坏的真正原因其实就3个：</p><ul><li>空间不足</li><li>设备断电</li><li>文件 sync 失败</li></ul><p>我们需要针对这些原因一一进行优化。</p><h4 id="1-优化空间占用"><a href="#1-优化空间占用" class="headerlink" title="1. 优化空间占用"></a>1. 优化空间占用</h4><p>首先我们来优化微信的空间占用问题。在这之前微信的部分业务也做了空间清理，例如朋友圈会自动删除7天前缓存的图片。但是总的来说对文件空间的使用缺乏一个全局把控，全靠各个业务自觉。我们需要做得更积极主动，要让开发人员意识到用户的存储空间是宝贵的。我们采取以下措施：</p><ul><li>业务文件先申请后使用，如果某个文件没有申请就使用了，会被自动扫描出来并删除；</li><li>每个业务文件都要申明有效期，是一天、一个星期、一个月还是永久存储；</li><li>过期文件会被自动清理。</li></ul><p><img src="/images/sqlite/11.jpg" alt="11"></p><p>对于微信之外的空间占用，例如相册、视频、其他App的空间占用，微信本身是做不了什么事情的，我们可以提示用户进行空间清理： </p><img src="/images/sqlite/12.jpg" style="zoom:65%;" /><h4 id="2-优化文件-sync"><a href="#2-优化文件-sync" class="headerlink" title="2. 优化文件 sync"></a>2. 优化文件 sync</h4><h5 id="1-synchronous-FULL"><a href="#1-synchronous-FULL" class="headerlink" title="1) synchronous = FULL"></a>1) synchronous = FULL</h5><p>设置SQLite的文件同步机制为全同步，亦即要求每个事务的写操作是真的flush到文件里去。</p><h5 id="2-fullfsync-1"><a href="#2-fullfsync-1" class="headerlink" title="2) fullfsync = 1"></a>2) fullfsync = 1</h5><p>通过与苹果工程师的交流，我们发现在 iOS 平台下还有 fullfsync (<a href="https://www.sqlite.org/pragma.html#pragma_fullfsync">https://www.sqlite.org/pragma.html#pragma_fullfsync</a>) 这个选项，可以严格保证写入顺序跟提交顺序一致。设备开发商为了测评数据好看，往往会对提交的数据进行重排，再统一写入，亦即写入顺序跟App提交的顺序不一致。在某些情况下，例如断电，就可能导致写入文件不一致的情况，导致文件损坏。</p><h4 id="3-优化效果"><a href="#3-优化效果" class="headerlink" title="3. 优化效果"></a>3. 优化效果</h4><p>多管齐下之后，我们成功将损坏率降低了一半多；DB损坏还是无法完全避免，我们还是得提高修复成功率。 </p><img src="/images/sqlite/13.jpg" style="zoom:65%;" /><h3 id="6-4-3-SQLite-修复逻辑优化-提高修复率"><a href="#6-4-3-SQLite-修复逻辑优化-提高修复率" class="headerlink" title="6.4.3 SQLite 修复逻辑优化(提高修复率)"></a>6.4.3 SQLite 修复逻辑优化(提高修复率)</h3><p>长久以来SQLite DB都有损坏问题，从Android、iOS等移动系统，到Windows、Linux 等桌面系统都会出现。由于微信所有消息都保存在DB，服务端不保留备份，一旦损坏将导致用户消息数据丢失，显然不能接受。</p><p>下面介绍一下微信数据库修复的具体方案和发展历程。</p><h4 id="1-我们的需求"><a href="#1-我们的需求" class="headerlink" title="1. 我们的需求"></a>1. 我们的需求</h4><p>具体来说，微信需要一套满足以下条件的DB恢复方案：</p><ul><li><strong>恢复成功率高。</strong> 由于牵涉到用户核心数据，“姑且一试”的方案是不够的，虽说 100% 成功率不太现实，但 90% 甚至 99% 以上的成功率才是我们想要的。</li><li><strong>支持加密DB。</strong> Android 端微信客户端使用的是加密 SQLCipher DB，加密会改变信息 的排布，往往对密文一个字节的改动就能使解密后一大片数据变得面目全非。这对于数据恢复 不是什么好消息，我们的方案必须应对这种情况。</li><li><strong>能处理超大的数据量。</strong> 经过统计分析，个别重度用户DB大小已经超过2GB，恢复方案 必须在如此大的数据量下面保证不掉链子。</li><li><strong>不影响体验。</strong> 统计发现只有万分之一不到的用户会发生DB损坏，如果恢复方案 需要事先准备（比如备份），它必须对用户不可见，不能为了极个别牺牲全体用户的体验。</li></ul><p>经过多年的不断改进，微信先后采用出三套不同的DB恢复方案，离上面的目标已经越来越近了。</p><h4 id="2-sql-master表介绍"><a href="#2-sql-master表介绍" class="headerlink" title="2. sql_master表介绍"></a>2. sql_master表介绍</h4><p>首先我们来看 SQLite 的架构。SQLite 使用 B+树 存储一个表，整个 SQLite 数据库就是这些 B+树 组成的森林。</p><ul><li>每个表的元数据，都记录在一个叫 sql_master 的表中。</li><li>这个 sql_master 表(下面有些场景简称 master 表) 本身也是一个 B+树 存储的普通表。DB 第0页就是他的根节点。</li></ul><img src="/images/sqlite/14.jpg" style="zoom:85%;" /><p><code>sqlite_master</code>是一个每个SQLite DB都有的特殊的表， 无论是查看官方文档<a href="https://www.sqlite.org/schematab.html">Database File Format</a>，还是执行SQL语句 <code>SELECT * FROM sqlite_master;</code>，都可得知这个SQLite的系统表中保存着数据库中所有的其他表、索引(indexes)、触发器(triggers)、视图(views)的元数据：表名、类型（table/index）、创建此表/索引的SQL语句，以及表的RootPage。(只包括table本身的信息即元数据，不包括里面的数据哦)</p><p><code>sqlite_master</code> 每一行记录一个项目。在创建一个SQLIte数据库的时候，该表会自动创建。<code>sqlite_master</code>的表名、表结构都是固定的：</p><ul><li>type：是以下文本字符串之一：“table”、“index”、“view”或“trigger”，具体取决于定义的对象类型。 ‘table’ 字符串用于普通表和虚拟表。</li><li>name：保存对象的名称。</li><li>tbl_name：包含与对象关联的表或视图的名称。<ul><li>对于表或视图，tbl_name 列是 name 列的副本。</li><li>对于索引，tbl_name 是被索引的表的名称。</li><li>对于触发器，tbl_name 列存储导致触发器触发的表或视图的名称。</li></ul></li><li>rootpage：存储表和索引的 b-tree 根节点的 page 号。对于描述视图、触发器和虚拟表(virtual tables)的行，rootpage 列是 0 或 NULL。</li><li>sql：存储描述对象的 SQL 文本。此 SQL 文本是 CREATE TABLE、CREATE VIRTUAL TABLE、CREATE INDEX、CREATE VIEW 或 CREATE TRIGGER 语句。</li><li><em>更详细的说明，可以见上面的官方文档链接</em></li></ul><img src="/images/sqlite/15.jpg" style="zoom:100%;" /><p><strong>正常情况下，SQLite 引擎打开DB后首次使用，需要先遍历</strong> <code>sqlite_master</code>，并将里面保存的SQL语句再解析一遍， 保存在内存中供后续编译SQL语句时使用。</p><p>由于sqlite_master表存储所有的数据库项目，所以可以通过该表判断特定的表、视图或者索引是否存在。例如，以下语句可以判断user表是否存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> sqlite_master <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;user&#x27;</span> <span class="keyword">and</span> type<span class="operator">=</span><span class="string">&#x27;table&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-方案一：官方的Dump恢复方案"><a href="#3-方案一：官方的Dump恢复方案" class="headerlink" title="3. 方案一：官方的Dump恢复方案"></a>3. 方案一：官方的Dump恢复方案</h4><p>Google 一下SQLite DB恢复，不难搜到使用<code>.dump</code>命令恢复DB的方法。<code>.dump</code>命令的作用是将 整个数据库的内容输出为很多 SQL 语句，只要对空 DB 执行这些语句就能得到一个一样的 DB。</p><p><code>.dump</code>命令原理很简单：</p><ol><li>每个SQLite DB都有一个<code>sqlite_master</code>表。遍历它得到所有表的名称和 <code>CREATE TABLE ...</code>的SQL语句，输出<code>CREATE TABLE</code>语句。</li><li>根据根节点地址和创表语句接着使用<code>SELECT * FROM ...</code> 通过表名遍历整个表，每读出一行就输出一个<code>INSERT</code>语句，遍历完后就把整个DB dump出来了（<em>能 select 多少是多少</em>）。</li></ol><p>这样的操作，和普通查表是一样的，遇到损坏一样会返回<code>SQLITE_CORRUPT</code>，我们忽略掉损坏错误，继续遍历下个表，最终可以把所有没损坏的表以及<strong>损坏了的表的前半部分</strong>读取出来。将dump 出来的SQL语句逐行执行，最终可以得到一个等效的新DB。由于直接跑在SQLite上层，所以天然 就支持加密SQLCipher，不需要额外处理。</p><p>下图是dump输出样例：</p><img src="/images/sqlite/16.jpg" style="zoom:100%;" /><p>优点：</p><ul><li>这个方案不需要任何准备，只有坏DB的用户要花好几分钟跑恢复，大部分用户是不感知的。 </li></ul><p>缺点：</p><ul><li>数据量大小，主要影响恢复需要的临时空间：先要保存 dump 出来的SQL的空间，这个大概一倍DB大小，还要另外一倍 DB大小来新建 DB恢复。</li><li>至于我们最关心的成功率呢？上线后，<strong>成功率约为30</strong>%。这个成功率的定义是至少恢复了一条记录，也就是说一大半用户 一条都恢复不成功！研究一下就发现，恢复失败的用户，原因都是<code>sqlite_master</code>表读不出来。</li></ul><p><strong>官方修复算法率低下原因 — 太依赖 master 表</strong>：</p><p>前面说过，master 表他本身也是一个 B+树 形式的普通表，DB 第0页就是他的根节点。那么只要 master 表某个节点损坏，这个节点下面记录的表就都恢复不了。更坏的情况是 DB 第0页损坏，那么整个 master 表都读不出来，就导致整个DB都恢复失败。这就是官方修复算法成功率这么低的原因，太依赖 master 表了。</p><p>恢复率这么低的尴尬状况维持了好久， 其他方案才渐渐露出水面。</p><h4 id="4-方案二：备份恢复方案"><a href="#4-方案二：备份恢复方案" class="headerlink" title="4. 方案二：备份恢复方案"></a>4. 方案二：备份恢复方案</h4><p>损坏的数据无法修复，最直观的解决方案就是<strong>备份</strong>，于是备份恢复方案被提上日程了。备份恢复这个方案思路简单，SQLite 也有不少备份机制可以使用，具体是：</p><ul><li><strong>拷贝：</strong> 不能再直白的方式。由于SQLite DB本身是文件（主DB + journal 或 WAL）， 直接把文件复制就能达到备份的目的。</li><li><strong>Dump：</strong> 上一个恢复方案用到的命令的本来目的。在DB完好的时候执行<code>.dump</code>， 把 DB所有内容输出为 SQL语句，达到备份目的，恢复的时候执行SQL即可。</li><li><strong>Backup API：</strong> SQLite自身提供的一套备份机制，按 Page 为单位复制到新 DB， 支持热备份。</li></ul><p>这么多的方案孰优孰劣？作为一个移动APP，我们关心的无非就是 <strong>备份大小、备份性能、 恢复性能</strong> 几个指标。微信作为一个重度DB使用者，备份大小和备份性能是主要关注点： 原本用户就可能有2GB 大的 DB，如果备份数据本身也有2GB 大小，用户想必不会接受； 性能则主要影响体验和备份成功率，作为用户不感知的功能，占用太多系统资源造成卡顿是不行的，备份耗时越久，被系统杀死等意外事件发生的概率也越高。</p><p>对以上方案做简单测试后，备份方案也就基本定下了。下图是备选方案性能对比（测试用的DB大小约 <strong>50MB</strong>， 数据条目数大约为 <strong>10万条</strong>）：</p><img src="/images/sqlite/17.jpg" style="zoom:100%;" /><p>可以看出，比较折中的选择是 <strong>Dump + 压缩</strong>，备份大小具有明显优势，备份性能尚可， 恢复性能较差但由于需要恢复的场景较少，算是可以接受的短板。</p><p>微信在Dump + gzip方案上再加以优化：</p><ul><li><p>由于格式化SQL语句输出耗时较长，因此使用了自定义的二进制格式承载Dump输出。</p><ul><li>由于数据保密需要，二进制Dump数据也做了加密处理。</li><li> 采用自定义二进制格式还有一个好处是，恢复的时候不需要重复的编译SQL语句，编译一次就可以插入整个表的数据了，恢复性能也有一定提升。</li></ul></li><li><p>第二耗时的压缩操作则放到别的线程同时进行，在双核以上的环境基本可以做到无额外时间消耗。</p></li></ul><p>相比原始的Dump + 压缩，优化后的方案<strong>每秒备份行数提升了 150%，每秒恢复行数也提升了 40%</strong> （性能优化效果如下图）。</p><img src="/images/sqlite/18.jpg" style="zoom:80%;" /><p>即使优化后的方案，对于特大DB备份也是<strong>耗时耗电</strong>。对于移动APP来说，可能未必有这样的机会做这样重度的操作，或者频繁备份会导致卡顿，这也是需要开发者衡量的。比如Android微信会选择在 <strong>充电并灭屏</strong> 时进行DB备份，若备份过程中退出以上状态，备份会中止，等待下次机会。</p><p>备份方案上线后，恢复成功率<strong>达到72</strong>%，但有部分重度用户DB损坏时，由于备份耗时太久， 始终没有成功，而对DB数据丢失更为敏感的也恰恰是这些用户，于是新方案应运而生。</p><h4 id="5-方案三：解析B-tree恢复方案-RepairKit"><a href="#5-方案三：解析B-tree恢复方案-RepairKit" class="headerlink" title="5. 方案三：解析B-tree恢复方案(RepairKit)"></a>5. 方案三：解析B-tree恢复方案(RepairKit)</h4><p>备份方案的高消耗迫使我们从另外的方案考虑，于是我们再次把注意力放在之前的Dump方案。 Dump 方案本质上是尝试从坏DB里读出信息，这个尝试一般来说会出现两种结果：</p><ul><li>DB的基本格式仍然健在，但个别数据损坏，读到损坏的地方SQLite返回 <code>SQLITE_CORRUPT</code> 错误， 但已读到的数据得以恢复。</li><li>基本格式丢失（文件头或<code>sqlite_master</code>损坏），获取有哪些表的时候就返回 <code>SQLITE_CORRUPT</code> ，根本没法恢复。</li></ul><p>第一种可以算是预期行为，毕竟没有损坏的数据能 <strong>部分恢复</strong>。从之前的数据看， 不少用户遇到的是第二种情况，这种有没挽救的余地呢？ —— <strong>sqlite_master 损坏时的修复方案</strong>。</p><h5 id="1-方案：自实现数据读取系统"><a href="#1-方案：自实现数据读取系统" class="headerlink" title="1) 方案：自实现数据读取系统"></a>1) 方案：自实现数据读取系统</h5><p>假如<code>sqlite_master</code>损坏了无法解析，“Dump恢复”这种走正常SQLite 流程的方法，自然会卡在第一步了。</p><p>为了让<code>sqlite_master</code>受损的DB也能打开，需要想办法绕过SQLite引擎的逻辑。 <strong>由于SQLite引擎初始化逻辑比较复杂，为了避免副作用，没有采用hack的方式复用其逻辑，而是决定仿造一个只可以读取数据的最小化系统</strong>。</p><p>虽然仿造最小化系统可以跳过很多正确性校验，但也需要一些必须的数据：</p><h5 id="2-关键点1-—-sqlite-master备份"><a href="#2-关键点1-—-sqlite-master备份" class="headerlink" title="2) 关键点1 — sqlite_master备份"></a>2) 关键点1 — sqlite_master备份</h5><p><code>sqlite_master</code>里保存的信息对恢复来说也是十分重要的， 特别是RootPage，因为它是表对应的B-tree结构的根节点所在地，没有了它我们甚至不知道从哪里开始解析对应的表。</p><p><code>sqlite_master</code>信息量比较小，因此对它进行备份成本是非常低的，一般手机典型只需要几毫秒到数十毫秒即可完成，一致性也容易保证， 只需要执行了上述语句的时候重新备份一次即可。</p><p><strong>备份时机：</strong></p><p>我们只需要每隔一段时间轮询 master 表，看看最近有没有增删 table，有的话就全量备份。</p><p>这里有个担忧，就是普通数据表的插入会不会导致表的根节点发生变化，也就是说 master 表会不会频繁变化，如果变化很频繁的话，我们就不能简单地进行轮询方案了。通过分析源码，我们发现 SQLite 里面 B+树 算法的实现是 <strong>向下分裂</strong> 的，也就是说当一个叶子页满了需要分裂时，原来的叶子页会成为内部节点，然后新申请两个页作为他的叶子页。这就保证了根节点一旦定下来，是再也不会变动的。实际的代码调试也证实了我们这个推论。所以说 master 表只会在新创建表、删除表、修改表结构时（例如执行了<code>CREATE TABLE</code>、<code>ALTER TABLE</code> 等语句）才会发生变化，我们完全可以采用定时轮询方案。</p><p><strong>备份文件有效性</strong></p><p>接下来的难题是既然 DB 可以损坏，那么这个备份文件也会损坏，怎么办呢？我们采用了 <strong>双备份</strong> 的机制。具体来说就是：</p><ul><li>会有新旧两个备份文件，每个文件头都加上 CRC 校验；</li><li>每次备份时，从两个备份文件中选出一个进行覆盖。具体怎么选呢？<ul><li>优先选损坏那个备份文件，如果两个都有效，那么就选相对较旧的。这就保证了即使本次写入导致文件损坏，还有另外一份备份可以用。</li><li>这个做法跟 Realm 标榜的 MVCC（多版本并发控制）的做法有异曲同工之妙，相当于确认新写入的文件有效之后，才使用新写入的文件，否则还是继续用旧的有效的文件。</li></ul></li></ul><p>前面提到 DB 损坏的一个常见场景是空间不足，这种情况下还要分配文件空间给备份文件也是会失败的。为了解决这个问题，我们采取 <strong>预先分配空间</strong> 的做法，初始值是 32K，大约可存 750 个表的元信息，后续则按照32K的倍数进行增长。</p><p>有了备份，我们的逻辑可以在读取DB自带的<code>sqlite_master</code>失败的时候使用备份的信息来代替。</p><h5 id="3-关键点2-—-加解密"><a href="#3-关键点2-—-加解密" class="headerlink" title="3) 关键点2 — 加解密"></a>3) 关键点2 — 加解密</h5><p>DB初始化的问题除了文件头和<code>sqlite_master</code>完整性外，还有加密。</p><p>SQLCipher加密数据库，对应的恢复逻辑还需要加上解密逻辑。按照SQLCipher的实现，加密DB 是按page 进行包括头部的完整加密，所用的密钥是根据用户输入的原始密码和创建DB 时随机生成的 salt 运算后得出的。可以猜想得到，如果保存salt错了，将没有办法得出之前加密用的密钥，导致所有page都无法读出了。由于salt 是创建DB时随机生成，后续不再修改，将它纳入到备份的范围内即可。</p><h5 id="4-实现"><a href="#4-实现" class="headerlink" title="4) 实现"></a>4) 实现</h5><p>到此，初始化必须的数据就保证了，可以仿造读取逻辑了。</p><ul><li>我们常规使用的读取DB的方法（包括dump方式恢复），都是通过执行SQL语句实现的，这牵涉到SQLite系统最复杂的子系统——SQL执行引擎。我们的恢复任务只需要遍历B-tree所有节点， 读出数据即可完成，不需要复杂的查询逻辑，因此最复杂的SQL引擎可以省略。</li><li>同时，因为我们的系统是只读的， 写入恢复数据到新 DB 只要直接调用 SQLite 接口即可，因而可以省略同样比较复杂的B-tree平衡、Journal和同步等逻辑。 </li><li>最后恢复用的最小系统只需要：<ul><li>VFS读取部分的接口（Open/Read/Close），或者直接用stdio的fopen/fread、Posix的open/read也可以</li><li>SQLCipher的解密逻辑：加密 SQLCipher 情况较为复杂，幸好SQLCipher 加密部分可以单独抽出，直接套用其解密逻辑。</li><li>B-tree解析逻辑：Database File Format 详细描述了SQLite文件格式， 参照之实现B-tree解析可读取 SQLite DB。</li></ul></li></ul><p>即可实现。最小化系统如图所示：</p><img src="/images/sqlite/19.jpg" style="zoom:80%;" /><h5 id="5-注意点-—-列的补全"><a href="#5-注意点-—-列的补全" class="headerlink" title="5) 注意点 — 列的补全"></a>5) 注意点 — 列的补全</h5><p>实现了上面的逻辑，就能读出DB的数据进行恢复了，但还有一个小插曲。</p><ul><li>我们知道，使用SQLite查询一个表， 每一行的列数都是一致的，这是Schema层面保证的。但是在Schema的下面一层——B-tree层，没有这个保证。 B-tree的每一行（或者说每个entry、每个record）可以有不同的列数，一般来说，SQLite插入一行时， B-tree里面的列数和实际表的列数是一致的。</li><li>但是<strong>当对一个表进行了 <code>ALTER TABLE ADD COLUMN</code> 操作， 整个表都增加了一列，但已经存在的B-tree行实际上没有做改动，还是维持原来的列数。 当SQLite查询到 <code>ALTER TABLE</code> 前的行，缺少的列会自动用默认值补全</strong>。</li><li>恢复的时候，也需要做同样的判断和支持， 否则会出现缺列而无法插入到新的DB。</li></ul><h5 id="6-优化效果"><a href="#6-优化效果" class="headerlink" title="6) 优化效果"></a>6) 优化效果</h5><p>解析B-tree方案上线后，<strong>成功率约为78</strong>%。这个成功率计算方法为恢复成功的 Page 数除以总 Page 数。 由于是我们自己的系统，可以得知总 Page 数，使用恢复 Page 数比例的计算方法比人数更能反映真实情况。 </p><p>B-tree解析好处是准备成本较低，不需要经常更新备份，对大部分表比较少的应用备份开销也小到几乎可以忽略， 成功恢复后能还原损坏时最新的数据，不受备份时限影响。 坏处是，和Dump一样，如果损坏到表的中间部分，比如非叶子节点，将导致后续数据无法读出。</p><h4 id="6-不同方案的组合"><a href="#6-不同方案的组合" class="headerlink" title="6. 不同方案的组合"></a>6. 不同方案的组合</h4><p>由于解析B-tree恢复原理和备份恢复不同，失败场景也有差别，可以两种手段混合使用覆盖更多损坏场景。 微信的数据库中，有部分数据是临时或者可从服务端拉取的，这部分数据可以选择不修复，有些数据是不可恢复或者 恢复成本高的，就需要修复了。</p><ul><li>如果修复过程一路都是成功的，那无疑使用B-tree解析修复效果要好于备份恢复。备份恢复由于存在时效性，总有部分最新的记录会丢掉，解析修复由于直接基于损坏DB来操作，不存在时效性问题。 假如损坏部分位于不需要修复的部分，解析修复有可能不发生任何错误而完成。</li><li>如果修复过程遇到错误，则很可能是需要修复的B-tree损坏了，这会导致需要修复的表发生部分或全部缺失。 这个时候再使用备份修复，能挽救一些缺失的部分。</li><li>最早的Dump修复，场景已经基本被B-tree解析修复覆盖了，若B-tree修复不成功，Dump恢复也很有可能不会成功。 即便如此，假如上面的所有尝试都失败，最后还是会尝试Dump恢复。</li></ul><p>恢复方案组合如图所示：</p><img src="/images/sqlite/20.jpg" style="zoom:85%;" /><p>上面说的三种修复方法，原理上只涉及到SQLite文件格式以及基本的文件系统，是跨平台的。 实际操作上，各个平台可以利用各自的特性做策略上的调整，比如 Android 系统使用 <code>JobScheduler</code> 在充电灭屏状态下备份。</p><h3 id="6-4-4-小结"><a href="#6-4-4-小结" class="headerlink" title="6.4.4 小结"></a>6.4.4 小结</h3><p>通过这些优化，我们提高了微信聊天记录存储的可靠性。这些优化实践，会同上面在并发、IO性能方面的优化实践（<a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a>），将会合并到微信即将开源的 WCDB（WeChat Database）组件中。</p><h2 id="6-5-小结"><a href="#6-5-小结" class="headerlink" title="6.5 小结"></a>6.5 小结</h2><p>移动客户端数据库虽然不如后台数据库那么复杂，但也存在着不少可挖掘的技术点。本次尝试了仅对SQLite原有的方案进行优化，而市面上还有许多优秀的数据库，如LevelDB、RocksDB、Realm等，它们采用了和SQLite不同的实现原理。后续我们将借鉴它们的优化经验，尝试更深入的优化。</p><h1 id="七、SQLite多线程解决方案"><a href="#七、SQLite多线程解决方案" class="headerlink" title="七、SQLite多线程解决方案"></a>七、SQLite多线程解决方案</h1><h2 id="7-1-FMDB中的多线程-—-转串行"><a href="#7-1-FMDB中的多线程-—-转串行" class="headerlink" title="7.1 FMDB中的多线程 — 转串行"></a>7.1 FMDB中的多线程 — 转串行</h2><p><a href="https://github.com/ccgus/fmdb">FMDB</a> 是基于 SQLite 的数据库框架，使用 Objective-C 语言对 SQLite 的 C 语言接口做了一层面向对象的封装，并通过一个 Serial 队列保证在多线程环境下的数据安全。</p><p>FMDB 提供了 <code>FMDatabase</code> 类，该类与数据库文件一一对应，在新建一个 FMDatabase 对象时，可以关联一个已有的数据库文件；该对象以面向对象思想封装了增、删、改、查、事务等常用的数据库操作。但是<code>FMDatabase</code>  <strong>不是线程安全</strong> 的，在多个线程之间使用同一个<code>FMDatabase</code>可能会出现数据错误。</p><p>对于线程安全 FMDB 提供了<code>FMDatabaseQueue</code> 和 <code>FMDatabasePool</code> 。</p><ul><li><code>FMDatabaseQueue</code>持有 SQLite 句柄，多个线程使用同一个句柄，同时在初始化时创建了一个<strong>串行队列</strong>，当在多线程之间执行数据库操作时，<code>FMDatabaseQueue</code>将数据库操作以 <strong>block</strong> 的形式添加到该串行队列，然后按接收<strong>顺序同步执行</strong>，以此来保证数据库在多线程下的数据安全。</li><li><code>FMDatabasePool</code> 实现原理和<code>FMDatabaseQueue</code>一样，它的使用更加灵活，但是容易造成死锁，不推荐使用。</li></ul><p>FMDatabaseQueue原理：让各个线程的数据库操作按顺序同步执行。</p><img src="/images/sqlite/22.png" alt="img" style="zoom:77%;" /><p>示例：</p><p>创建FMDatabaseQueue：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *documentPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSString</span> *path = [documentPath stringByAppendingPathComponent:<span class="string">@&quot;demoDataBase.sqlite&quot;</span>];</span><br><span class="line">_database = [FMDatabase databaseWithPath:path];</span><br></pre></td></tr></table></figure><p>多线程操作数据库：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;张三&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;李四&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span>.databaseQueue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@&quot;INSERT INTO Person (name, sex) VALUES (&#x27;王五&#x27;, &#x27;男&#x27;)&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;插入成功 - %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]); &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/images/sqlite/23.png" alt="img" style="zoom:85%;" /><p>数据库结果：</p><p><img src="/images/sqlite/24.png" alt="img"></p><h2 id="7-2-WCDB"><a href="#7-2-WCDB" class="headerlink" title="7.2 WCDB"></a>7.2 WCDB</h2><p>WCDB 是微信团队推出的一个高效、完整、易用的移动数据库框架，基于 SQLCipher（SQLite的加密扩展），支持 iOS，mac OS 和 Android。</p><p>WCDB 通过 <strong>SQLite 多句柄</strong> 和 <strong>WAL 日志模式</strong> 来支持线程间读与读、读与写操作<strong>并发</strong>执行，并通过<strong>优化 Busy Retry 方案</strong> 来提升线程间写与写操作<strong>串行</strong>执行的效率。(<em>实现细节见6.1节</em>)</p><p>WCDB 内置一个句柄池<code>HandlePool</code>，由它管理和分发 SQLite 句柄。WCDB 提供的<code>WCTDatabase</code>、<code>WCTTable</code>和<code>WCTTransaction</code>的所有 SQL 操作接口都是线程安全，它们不直接持有数据库句柄，而是由<code>HandlePool</code>根据数据库访问所在的线程、是否处于事务、并发状态等，自动分发合适的 SQLite 连接进行操作，以此来保证同一个句柄在同一时间只有一个线程在操作，从而达到读与读、读与写并发的效果。</p><h2 id="7-3-性能对比"><a href="#7-3-性能对比" class="headerlink" title="7.3 性能对比"></a>7.3 性能对比</h2><blockquote><p>以下测试数据来自 <a href="https://github.com/Tencent/wcdb/wiki/%e6%80%a7%e8%83%bd%e6%95%b0%e6%8d%ae%e4%b8%8eBenchmark">WCDB性能数据与Benchmark</a></p></blockquote><p>这里主要对比 FMDB 和 WCDB。</p><p>如无特殊说明，SQLite配置均为WAL模式、缓存大小2000字节、页大小4 kb：</p><ul><li><code>PRAGMA cache_size=-2000</code></li><li><code>PRAGMA page_size=4096</code></li><li><code>PRAGMA journal_mode=WAL</code></li></ul><p>测试数据均为含有一个整型和一个二进制数据的表：<code>CREATE TABLE benchmark(key INTEGER, value BLOB)</code>，二进制数据长度为100字节。</p><h3 id="7-3-1-Baseline"><a href="#7-3-1-Baseline" class="headerlink" title="7.3.1 Baseline"></a>7.3.1 Baseline</h3><ul><li><strong>读操作性能测试</strong>：该测试为从数据库中取出所有数据，并拼装为object。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_read.png" style="zoom:57%;" /><ul><li><strong>写操作性能测试</strong>：该测试为将object的数据不断插入到数据库中（不使用事务）。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_write.png" style="zoom:57%;" /><ul><li><strong>批量写操作性能测试</strong>：该测试为将object的数据批量插入数据库（使用事务）。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/baseline_batch_write.png" style="zoom:57%;" /><p>WCDB写操作和批量写操作的性能分别优于FMDB <strong>28%</strong> 和 <strong>180%</strong> ，而读操作则劣于FMDB <strong>5%</strong> 。</p><p>对于读操作，SQLite速度很快，因此封装层的消耗会占比较多。FMDB只做了最简单的封装， 而WCDB还包括ORM、WINQ等操作，因此执行的指令会比FMDB多，从而导致性能稍差于FMDB。但WCDB也通过一些优化手段减少这种差距。例如，通过IMP指针调用函数、部分操作No-ARC等等。</p><p>而写操作，WCDB也做了许多针对性的优化。例如，WAL模式下写入操作触发checkpoint时，不立即执行checkpoint，而是由一个checkpoint线程来完成，从而减少单次操作的耗时等等。</p><h3 id="7-3-2-Multithread"><a href="#7-3-2-Multithread" class="headerlink" title="7.3.2 Multithread"></a>7.3.2 Multithread</h3><ul><li><strong>多线程读操作性能测试</strong>：该测试同时启动两个线程，分别从数据库中取出所有数据，并拼装为object。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_read_read.png" style="zoom:57%;" /><ul><li><strong>多线程读写操作性能测试</strong>：该测试同时启动两个线程，一个线程从数据库中取出所有数据，并拼装为object；另一个将object的数据批量插入到数据库中。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_read_write.png" style="zoom:57%;" /><ul><li><strong>多线程写操作性能测试</strong>：该测试同时启动两个线程，分别将object的数据批量插入数据库。</li></ul><img src="https://github.com/Tencent/wcdb/wiki/assets/benchmark/multithread_write_write.png" style="zoom:57%;" /><p>WCDB 的多线程读写操作性能优于 FMDB <strong>62%</strong> ，而多线程读操作基本与 FMDB 持平（FMDB 只对 SQLite 做了最简单的封装， 而 WCDB 还包括ORM、WINQ等操作，执行的指令会比 FMDB 多，因此在多线程读测试中没有表现出明显的优势）。</p><p>FMDB在多线程写测试中，直接触发了 Busy Retry ，返回错误<code>SQLITE_BUSY</code>，因此无法比较。而WCDB通过优化Busy Retry，多线程写操作实质也是串行执行，但不会出错导致操作中断。</p><h2 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h2><p>FMDB 采用串行队列来保证线程安全，并且采用单句柄方案，即所有线程共用一个SQLite Handle。在多线程并发时，虽然能够使各个线程的数据库操作按顺序同步进行，保证了数据安全，但正是因为各线程同步进行，导致后来的线程会被阻塞较长时间，无论是读操作还是写操作，都必须等待前面的线程执行完毕，使得性能无法得到更好的保障。</p><p>WCDB 内置了一个句柄池，根据各个线程的情况派发数据库句柄，通过多句柄方案来实现线程间读与读、读与写并发执行，并开启SQLite的WAL日志模式进一步提高多线程的并发性。同时 WCDB 修改了SQLite的内部实现，优化了 Busy Retry 方案，禁用了文件锁并添加队列来支持主动唤醒等待的线程，以此来提高线程间写与写串行执行的效率。</p><p>WCDB 在多线程方面明显优于 FMDB。</p><h1 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h1><ul><li>并发及IO优化<ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286361&idx=1&sn=78bbcda7f41a14291ad71289e4821f71&scene=21#wechat_redirect">微信iOS SQLite源码优化实践</a></li></ul></li><li>数据库修复<ul><li><a href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw">微信 SQLite 数据库修复实践</a></li><li><a href="https://cloud.tencent.com/developer/article/1005513">微信移动端数据库组件 WCDB 系列：数据库修复三板斧（二）</a></li></ul></li><li>WCDB的使用<ul><li><a href="https://mp.weixin.qq.com/s/1XxcrsR2HKam9ytNk8vmGw">微信移动端数据库组件WCDB系列（一）-iOS基础篇</a></li><li><a href="https://cloud.tencent.com/developer/article/1005718">为什么要从 FMDB 迁移到 WCDB？</a></li><li><a href="https://github.com/Tencent/wcdb/wiki/%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E4%B8%8EBenchmark">性能数据与Benchmark</a></li><li><a href="https://github.com/Tencent/wcdb">WCDB 源码</a></li></ul></li><li><a href="https://cloud.tencent.com/developer/article/1005549">微信 WCDB 进化之路：开源与开始</a></li><li><a href="https://github.com/ccgus/fmdb">FMDB 源码</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS-数据库方案&quot;&gt;&lt;a href=&quot;#iOS-数据库方案&quot; class=&quot;headerlink&quot; title=&quot;iOS 数据库方案&quot;&gt;&lt;/a&gt;iOS 数据库方案&lt;/h1&gt;&lt;p&gt;目前移动端数据库方案按其实现可分为两类，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="数据的存储与传输" scheme="https://tenloy.github.io/categories/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BC%A0%E8%BE%93/"/>
    
    
  </entry>
  
  <entry>
    <title>内存映射mmap函数的原理与应用</title>
    <link href="https://tenloy.github.io/2022/04/28/mmap.html"/>
    <id>https://tenloy.github.io/2022/04/28/mmap.html</id>
    <published>2022-04-28T10:15:19.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p><img src="/images/OS/mmap/mmap-03.png" alt="mmap-03" style="zoom:100%;" /><h2 id="二、相关API"><a href="#二、相关API" class="headerlink" title="二、相关API"></a>二、相关API</h2><h3 id="2-1-mmap"><a href="#2-1-mmap" class="headerlink" title="2.1 mmap()"></a>2.1 mmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mmap(), munmap() - map or unmap files or devices into memory(将文件或设备映射或取消映射到内存中)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * addr/length分别用于指定需要申请的空间的起始地址和长度。</span></span><br><span class="line"><span class="comment"> *    如果addr设置为0/NULL，那么Linux系统会自动挑选合适的起始地址(这是最方便的方式)。</span></span><br><span class="line"><span class="comment"> *    如果addr不为NULL，则内核将其作为关于在何处放置映射的提示；</span></span><br><span class="line"><span class="comment"> *        在Linux上，内核将选择一个附近的页面边界（但总是高于或等于 /proc/sys/vm/mmap_min_addr 指定的值）并尝试在那里创建映射。</span></span><br><span class="line"><span class="comment"> *        如果那里已经存在另一个映射，内核会选择一个新地址，该地址可能依赖于提示，也可能不依赖于提示。</span></span><br><span class="line"><span class="comment"> * prot: 用于设置申请的空间的权限（可读、可写、可执行，并且不能与文件的打开模式冲突）。是以下的某个值，可以通过or运算合理地组合在一起</span></span><br><span class="line"><span class="comment">                  PROT_EXEC  ：页内容可以被执行</span></span><br><span class="line"><span class="comment">                  PROT_READ  ：页内容可以被读取</span></span><br><span class="line"><span class="comment">                  PROT_WRITE ：页可以被写入</span></span><br><span class="line"><span class="comment">                  PROT_NONE  ：页不可访问</span></span><br><span class="line"><span class="comment"> * @param flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</span></span><br><span class="line"><span class="comment">                  MAP_FIXED     // 使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</span></span><br><span class="line"><span class="comment">                  MAP_SHARED    // 与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。</span></span><br><span class="line"><span class="comment">                  MAP_PRIVATE   // 建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</span></span><br><span class="line"><span class="comment">                  MAP_DENYWRITE // 这个标志被忽略。</span></span><br><span class="line"><span class="comment">                  MAP_EXECUTABLE// 同上</span></span><br><span class="line"><span class="comment">                  MAP_NORESERVE // 不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。</span></span><br><span class="line"><span class="comment">                  MAP_LOCKED    // 锁定映射区的页面，从而防止页面被交换出内存。</span></span><br><span class="line"><span class="comment">                  MAP_GROWSDOWN // 用于堆栈，告诉内核VM系统，映射区可以向下扩展。</span></span><br><span class="line"><span class="comment">                  MAP_ANONYMOUS // 匿名映射，映射区不与任何文件关联。</span></span><br><span class="line"><span class="comment">                  MAP_ANON      // MAP_ANONYMOUS的别称，不再被使用。</span></span><br><span class="line"><span class="comment">                  MAP_FILE      // 兼容标志，被忽略。</span></span><br><span class="line"><span class="comment">                  MAP_32BIT     // 将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。</span></span><br><span class="line"><span class="comment">                  MAP_POPULATE  // 为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。</span></span><br><span class="line"><span class="comment">                  MAP_NONBLOCK  // 仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。</span></span><br><span class="line"><span class="comment"> * flags:用于设置映射类型（文件映射、匿名空间等）。确定映射的更新是否对映射同一区域的其他进程可见，以及是否将更新传递到底层文件。</span></span><br><span class="line"><span class="comment"> * fd:   用于文件映射时，指定文件描述符。在mmap()调用返回后，文件描述符fd可以立即关闭，而不会使映射无效。</span></span><br><span class="line"><span class="comment"> * offset: 用于文件映射时，指定文件偏移。offset 必须是 sysconf(_SC_PAGE_SIZE) 返回的页面大小的倍数。</span></span><br><span class="line"><span class="comment"> * return: </span></span><br><span class="line"><span class="comment"> *  成功时，mmap() 返回一个指向映射区域的指针。</span></span><br><span class="line"><span class="comment"> *  出错时，返回值 MAP_FAILED（即 (void *) -1），并设置 errno 以指示错误。</span></span><br><span class="line"><span class="comment">                  EACCES：访问出错</span></span><br><span class="line"><span class="comment">                  EAGAIN：文件已被锁定，或者太多的内存已被锁定</span></span><br><span class="line"><span class="comment">                  EBADF ：fd不是有效的文件描述词</span></span><br><span class="line"><span class="comment">                  EINVAL：一个或者多个参数无效</span></span><br><span class="line"><span class="comment">                  ENFILE：已达到系统对打开文件的限制</span></span><br><span class="line"><span class="comment">                  ENODEV：指定文件所在的文件系统不支持内存映射</span></span><br><span class="line"><span class="comment">                  ENOMEM：内存不足，或者进程已超出最大内存映射数量</span></span><br><span class="line"><span class="comment">                  EPERM ：权能不足，操作不允许</span></span><br><span class="line"><span class="comment">                  ETXTBSY：已写的方式打开文件，同时指定MAP_DENYWRITE标志</span></span><br><span class="line"><span class="comment">                  SIGSEGV：试着向只读区写入</span></span><br><span class="line"><span class="comment">                  SIGBUS：试着访问不属于进程的内存区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>mmap() 的作用就是向操作系统申请一段虚拟地址空间，这段空间：</p><ul><li>当然这块虚拟地址空间可以映射到某个文件（这也是这个系统调用的最初的作用）<ul><li>此时，会使用从文件描述符 <code>fd</code> 引用的文件（或其他对象）中， 偏移量 <code>offset</code> 开始，长度 <code>length</code> 字节的数据，对映射区域进行初始化。</li></ul></li><li>当它不将地址空间映射到某个文件时，我们又称这块空间为匿名（Anonymous）空间，匿名空间就可以拿来作为堆空间(就是单纯的申请内存)，又称匿名映射。<ul><li>此时，映射没有任何文件支持；它的内容被初始化为零。</li><li>关于这个使用，详见<em>4.2.1节-malloc的原理</em>。</li></ul></li><li>使用场景：进程间通信(共享内存映射)、文件的装载。</li></ul><h3 id="2-2-munmap"><a href="#2-2-munmap" class="headerlink" title="2.2 munmap()"></a>2.2 munmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> * addr, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>成功执行时，munmap()返回0。失败时，munmap返回-1，error返回标志和mmap一致；</p><p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；</p><p>当映射关系解除后，对原来映射地址的访问将导致段错误发生。 </p><h3 id="2-3-msync"><a href="#2-3-msync" class="headerlink" title="2.3 msync()"></a>2.3 msync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap()后才执行该操作。</p><p>可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。</p><h2 id="三、mmap和常规文件操作的区别"><a href="#三、mmap和常规文件操作的区别" class="headerlink" title="三、mmap和常规文件操作的区别"></a>三、mmap和常规文件操作的区别</h2><h3 id="3-1-页缓存-page-cache"><a href="#3-1-页缓存-page-cache" class="headerlink" title="3.1 页缓存(page cache)"></a>3.1 页缓存(page cache)</h3><blockquote><p>维基百科：<a href="https://en.wikipedia.org/wiki/Page_cache">Page cache</a></p></blockquote><p>在计算中，页面缓存(page cache)，有时也称为磁盘缓存(disk cache)，[1] 是一种透明缓存，用于存储源自二级存储设备（如硬盘驱动器 (HDD) 或固态驱动器 (SSD)）的页面。操作系统在主内存 (RAM) 的其他未使用部分中保留页面缓存，从而更快地访问缓存页面的内容并提高整体性能。页面缓存在内核中通过分页内存管理实现，并且对应用程序几乎是透明的。</p><p>通常，所有不直接分配给应用程序的物理内存都被操作系统用于页面缓存。出于充分利用内存不使其处于空闲状态，以及此类内存在应用程序请求时很容易回收，因此通常没有相关的性能损失。操作系统甚至可能将此类内存报告为“空闲(free)”或“可用(available)”。</p><p>与主存相比，硬盘驱动器的读/写速度很慢，随机访问需要昂贵的磁盘寻道；因此，随着更多数据可以缓存在内存中，大容量的主内存能带来明显的性能提升。 </p><ul><li>独立的磁盘缓存(Separate disk caching)由专用 RAM 或 NVRAM 芯片（位于磁盘控制器(<a href="https://en.wikipedia.org/wiki/Disk_controller">disk controller</a>)或磁盘阵列控制器(<a href="https://en.wikipedia.org/wiki/Disk_array_controller">disk array controller</a>)中。如果是前者，此时缓存被集成到硬盘驱动器中，通常称为磁盘缓冲区(disk buffer)）在硬件方面提供。此类内存不应与页面缓存(page cache)混淆了</li></ul><p>页缓存中被引入后修改的页称为脏页(dirty pages)。</p><h4 id="3-1-1-补充-—-文件系统、文件、磁盘"><a href="#3-1-1-补充-—-文件系统、文件、磁盘" class="headerlink" title="3.1.1 补充 — 文件系统、文件、磁盘"></a>3.1.1 补充 — 文件系统、文件、磁盘</h4><blockquote><p>文件系统：是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的哪个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。</p></blockquote><p>现代OS几乎都是通过文件系统来组织和管理在计算机中所存储的大量程序和数据的。<strong>文件系统的管理功能是通过把它所管理的程序和数据组织成一系列文件的方法来实现</strong>的。而<strong>文件则是指具有文件名的若干相关元素的集合</strong>。<strong>元素通常是记录，而记录是一组有意义的数据项的集合</strong>。可以把数据组成分为数据项、记录、文件。</p><ul><li><strong>数据项</strong>，数据项是最低级数据组织形式。分为基本数据项（用于描述一个对象某种属性的字符集，是数据组织中可以明明的最小逻辑数据单位，即原子数据，又称为数据元素或字段）和组合数据项（由若干个基本数据项组成）</li><li><strong>记录</strong>，是一组相关数据项的集合，用于描述一个对象在某方面的属性，为了能够唯一标识一个记录，需要在记录中确定一个或集合数据项，把他们的集合称为关键字，关键字是能够唯一标识一个记录的数据项。</li><li><strong>文件</strong>，文件是具有文件名的一组相关元素的集合。<ul><li>文件分为有结构文件和无结构文件。有结构文件由若干个相关记录组成，无结构文件则被看成一个字符流。</li><li>文件是文件系统的最大数据单位。</li><li>文件应该具有自己的属性，包括：<ul><li>文件类型：如源文件、目标文件、可执行文件等。</li><li>文件长度：文件的当前长度，也可能是最大允许长度。</li><li>文件的物理位置：指示文件在哪一个设备上及在该设备的哪个位置的指针。</li><li>文件的建立时间：文件最后一次修改时间。</li></ul></li></ul></li></ul><p>一个文件可对应若干个记录，一个记录可对应若干个数据项。</p><p>文件系统管理的对象有：</p><ul><li><strong>文件</strong>：作为文件管理的直接对象</li><li><strong>目录</strong>：为了方便用户对文件的存取和检索，在文件系统中配置目录，每个目录项中，必须含有文件名及该文件所在的物理地址，对目录的组织和管理是方便和提高对文件存取速度的关键。</li><li><strong>磁盘存储空间</strong>：文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul><h4 id="3-1-2-补充-—-字符设备文件和块设备文件"><a href="#3-1-2-补充-—-字符设备文件和块设备文件" class="headerlink" title="3.1.2 补充 — 字符设备文件和块设备文件"></a>3.1.2 补充 — 字符设备文件和块设备文件</h4><p>在Unix的/dev 目录下，有许多文件，其中有两个大类：字符设备文件和块设备文件。</p><ul><li>字符设备特殊文件进行I/O操作不经过操作系统的缓冲区，与外设进行I/O操作时每次只传输一个字符。</li><li>块设备特殊文件使用了cache机制，在外设和内存之间一次可以传送一整块数据(定长的包传输)。</li><li>裸设备是一种特殊类型的块设备文件，允许以直接访问硬盘的方式访问一个存储设备，而不经过操作系统的高速缓存和缓冲器（尽管可能仍旧使用硬件高速缓存）。应用程序如数据库管理系统可能直接使用裸设备，使它们能自行管理数据的缓存方式，而不将这些任务交给操作系统。</li></ul><p>裸设备少了操作系统这一层，I/O效率更高。不少数据库都能通过使用裸设备作为存储介质来提高I/O效率。</p><p>2021年6月10日，IT之家消息，RAW 设备正式退出了历史舞台。</p><h4 id="3-1-3-Buffer-Cache与Page-Cache（Linux）"><a href="#3-1-3-Buffer-Cache与Page-Cache（Linux）" class="headerlink" title="3.1.3 Buffer Cache与Page Cache（Linux）"></a>3.1.3 Buffer Cache与Page Cache（Linux）</h4><p>在我们进行数据持久化，对文件内容进行落盘处理时，我们时常会使用fsync操作（file sync，即文件同步），该操作会将文件关联的脏页(dirty page)数据(<strong>实际文件内容及元数据信息</strong>)一同写回磁盘。这里提到的脏页(dirty page)即为页缓存(page cache，也叫页高速缓存)。</p><p>块缓存(buffer cache)，则是内核为了加速对底层存储介质的访问速度，而构建的一层缓存。它<strong>缓存部分磁盘数据</strong>，当有磁盘读取请求时，会首先查看块缓存中是否有对应的数据，如果有的话，则直接将对应数据返回，从而减少对磁盘的访问。</p><p>两层缓存各有自己的缓存目标，我好奇的是，这两者到底是什么关系？</p><p>两类缓存各自的作用：</p><ul><li><p>Page Cache</p><p>Page Cache以Page为单位，缓存文件内容。缓存在Page Cache中的文件数据，能够更快的被用户读取。同时对于带buffer的写入操作，数据在写入到Page Cache中即可立即返回，而不需等待数据被实际持久化到磁盘，进而提高了上层应用读写文件的整体性能。</p></li><li><p>Buffer Cache</p><p>磁盘的最小数据单位为sector，每次读写磁盘都是以sector为单位对磁盘进行操作。sector大小跟具体的磁盘类型有关，有的为512Byte， 有的为4K Bytes。无论用户是希望读取1个byte，还是10个byte，最终访问磁盘时，都必须以sector为单位读取，如果裸读磁盘，那意味着数据读取的效率会非常低。同样，如果用户希望向磁盘某个位置写入(更新)1个byte的数据，他也必须整个刷新一个sector，言下之意，则是在写入这1个byte之前，我们需要先将该1byte所在的磁盘sector数据全部读出来，在内存中，修改对应的这1个byte数据，然后再将整个修改后的sector数据，一口气写入磁盘。</p><p>为了降低这类低效访问，尽可能的提升磁盘访问性能，内核会在磁盘sector上构建一层缓存，它以sector的整数倍粒度为单位(block)，缓存部分sector数据在内存中，当有数据读取请求时，它能够直接从内存中将对应数据读出。当有数据写入时，它可以直接在内存中直接更新指定部分的数据，然后再通过异步方式，把更新后的数据写回到对应磁盘的sector中。</p><p>这层缓存则是块缓存Buffer Cache。</p></li></ul><p>虽然，目前Linux Kernel（linux-2.6.18）代码中，Page Cache和Buffer Cache实际上是统一的，无论是文件的Page Cache还是Block的Buffer Cache最终都统一到Page上。但是，在阅读较老代码时，我们能够看出，这两块缓存的实现，原本是完全分开的。是什么原因使得最终这两类缓存“走到了一起”？</p><h5 id="1-第一阶段：仅有Buffer-Cache"><a href="#1-第一阶段：仅有Buffer-Cache" class="headerlink" title="1.  第一阶段：仅有Buffer Cache"></a>1.  第一阶段：仅有Buffer Cache</h5><p>在Linux-0.11版本的代码中，我们会看到，buffer cache是完全独立的实现，甚至都还没有基于page作为内存单元，而是以原始指针的系形式出现。每一个block sector，在kernel内部对应一个独立的buffer cache单元，这个buffer cache单元通过buffer head来描述。</p><h5 id="2-第二阶段：Page-Cache、Buffer-Cache并存"><a href="#2-第二阶段：Page-Cache、Buffer-Cache并存" class="headerlink" title="2. 第二阶段：Page Cache、Buffer Cache并存"></a>2. 第二阶段：Page Cache、Buffer Cache并存</h5><p>到Linux-2.2版本时，磁盘文件访问的高速缓冲仍然是缓冲区高速缓冲(Buffer Cache)。其访问模式与上面Linux-0.11版本的访问逻辑基本类似。但此时，Buffer Cache已基于page来分配内存：</p><ul><li>buffer_head内部，已经有了关于所在page的一些信息：成员变量<code>struct buffer_head *b_this_page;</code></li><li>同时，从buffer cache的初始化，以及buffer cache不足时新建buffer cache单元的动作，我们也可以看出，此时buffer cache已经完全是基于page来分配内存。</li></ul><p>此时的buffer cache基于page来分配内存，但是与Page Cache完全独立，一点关系都没有。</p><p>在Linux-2.2版本中，Page Cache此时用来干什么的？</p><ul><li>用于文件的mmap</li><li>用于network-based filesytems</li></ul><p>此时，Page Cache和Buffer Cache的关系如下图所示：</p><img src="/images/OS/mmap/mmap-07.png" alt="mmap-07" style="zoom:80%;" /><p>Page Cache仅负责其中mmap部分的处理，而Buffer Cache实际上负责所有对磁盘的IO访问。从上面图中，我们也可看出其中一个问题：write绕过了Page Cache，这里导致了一个同步问题。当write发生时，有效数据是在Buffer Cache中，而不是在Page Cache中。这就导致mmap访问的文件数据可能存在不一致问题。</p><p>为了解决这个问题，所有基于磁盘文件系统的write，都需要调用 update_vm_cache() 函数，该操作会修改write相关Buffer Cache对应的Page Cache。从代码中我们可以看到，上述sysv_file_write中，在调用完copy_from_user之后，会调用update_vm_cache。</p><p>同样，正是这样Page Cache、Buffer Cache分离的设计，导致基于磁盘的文件，同一份数据，可能在Page Cache中有一份，而同时，却还在Buffer Cache中有一份。</p><h5 id="3-第三阶段：Page-Cache、Buffer-Cache融合"><a href="#3-第三阶段：Page-Cache、Buffer-Cache融合" class="headerlink" title="3. 第三阶段：Page Cache、Buffer Cache融合"></a>3. 第三阶段：Page Cache、Buffer Cache融合</h5><p>介于上述Page Cache、Buffer Cache分离设计的弊端，Linux-2.4版本中对Page Cache、Buffer Cache的实现进行了融合，融合后的Buffer Cache不再以独立的形式存在：</p><ul><li><p>Buffer Cache的内容，直接存在于Page Cache中，同时，保留了对Buffer Cache的描述符单元：buffer_head。</p><img src="/images/OS/mmap/mmap-08.png" alt="mmap-08" style="zoom:85%;" /></li><li><p>page结构中，通过buffers字段是否为空，来判定这个Page是否与一组Buffer Cache关联（在后续的演进过程中，这个判断，转变为由 private 字段来判定）。</p></li><li><p>而对应的，buffer_head则增加了字段 b_page ，直接指向对应的page。</p></li></ul><p>至此，两者的关系已经相互融合如下图所示：</p><img src="/images/OS/mmap/mmap-09.png" alt="mmap-09" style="zoom:85%;" /><p>将Page Cache与Buffer Cache(buffer_head)相互绑定。<strong>对上，在文件读写时，以page为单位进行处理。而对下，在数据向device进行刷新时，则可以以buffer_head(block)为单位进行处理。</strong></p><p>在后续的linux-2.5版本中，引入了bio结构来替换基于buffer_head的块设备IO操作。</p><p>注意：</p><ul><li><p>这里的Page Cache与Buffer Cache的融合，是针对文件这一层面的Page Cache与Buffer Cache的融合。</p></li><li><p>对于跨层的：File层面的Page Cache和裸设备Buffer Cache，虽然都统一到了基于Page的实现，但File的Page Cache和该文件对应的Block在裸设备层访问的Buffer Cache，这两个是完全独立的Page。</p><p>即：这种情况下，一个物理磁盘Block上的数据，仍然会对应Linux内核中的两份Page：一个是下图右侧，通过文件层访问的File的Page Cache(Page Cache)；一个是下图左侧，通过裸设备层访问的Page Cache(Buffer Cache)。</p><img src="/images/OS/mmap/mmap-10.png" alt="mmap-10" style="zoom:70%;" /></li></ul><h4 id="3-1-4-总结"><a href="#3-1-4-总结" class="headerlink" title="3.1.4 总结"></a>3.1.4 总结</h4><p>早期的Linux内核版本中，同时存在PageCache和BufferCache，由于这两种缓存处于半独立的状态，缺乏集成导致整体性能下降和缺乏灵活性。在内核版本2.4之后，对Page Cache、Buffer Cache的实现进行了融合。融合后的Buffer Cache不再以独立的形式存在，Buffer Cache的内容，直接存在于Page Cache中，同时，保留了对Buffer Cache的描述符单元：buffer_head。</p><p>简单说来，磁盘的操作有逻辑级（文件系统）和物理级（磁盘块），这两种Cache就是分别缓存逻辑和物理级数据的。<strong>page cache用来缓存文件数据，buffer cache用来缓存磁盘数据。</strong></p><ul><li>在有文件系统的情况下，对文件操作，那么数据会缓存到page cache，如果直接采用dd等工具对磁盘进行读写，那么数据会缓存到buffer cache。</li><li>Cache(Page Cache)以页面形式缓存了文件系统的文件，给需要使用的程序读取，它是为了给读操作提供缓冲，避免频繁读硬盘，提高读取效率。</li><li>Buffer(Buffer Cache)以块形式缓冲了块设备的操作，定时或手动的同步到硬盘，它是为了缓冲写操作然后一次性将很多改动写入硬盘，避免频繁写硬盘，提高写入效率。</li></ul><h3 id="3-2-常规文件操作"><a href="#3-2-常规文件操作" class="headerlink" title="3.2 常规文件操作"></a>3.2 常规文件操作</h3><p>我们首先简单的回顾一下常规linux文件系统操作（调用read/fread等类函数）中，函数的调用过程：</p><ol><li>进程发起读文件请求。</li><li>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。</li><li>inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。</li><li>如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。</li></ol><p>总结来说，<strong>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。</strong>这样造成读文件时需要先<strong>将文件页从磁盘拷贝到页缓存中</strong>，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要<strong>将数据页从页缓存中再次拷贝到内存对应的用户空间中</strong>。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p><img src="/images/OS/mmap/mmap-01.jpg" alt="mmap-01" style="zoom:85%;" /><h3 id="3-3-mmap映射操作文件"><a href="#3-3-mmap映射操作文件" class="headerlink" title="3.3 mmap映射操作文件"></a>3.3 mmap映射操作文件</h3><p>而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p><p><strong>mmap内存映射的实现过程，总的来说可以分为三个阶段：</strong></p><ol><li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</li><li>调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</li><li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</li></ol><img src="/images/OS/mmap/mmap-02.jpg" style="zoom:85%;" /><p><font color='red'><strong>总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。</strong></font>说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p><h2 id="四、mmap优点总结"><a href="#四、mmap优点总结" class="headerlink" title="四、mmap优点总结"></a>四、mmap优点总结</h2><p>由上文讨论可知，mmap优点共有一下几点：</p><ul><li><p>对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。</p></li><li><p>实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。</p></li><li><p>提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。</p><p>同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</p></li><li><p>可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。<strong>换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。</strong></p></li></ul><h2 id="五、mmap使用细节"><a href="#五、mmap使用细节" class="headerlink" title="五、mmap使用细节"></a>五、mmap使用细节</h2><h3 id="5-1-注意点"><a href="#5-1-注意点" class="headerlink" title="5.1 注意点"></a>5.1 注意点</h3><p>1、使用mmap需要注意的一个关键点是，<strong>mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）</strong>。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。</p><p>2、<strong>内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。</strong>也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。具体情形参见“情形三”。</p><p>3、<strong>映射建立之后，即使文件关闭，映射依然存在。</strong>因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。</p><h3 id="5-2-示例：文件大小、映射大小"><a href="#5-2-示例：文件大小、映射大小" class="headerlink" title="5.2 示例：文件大小、映射大小"></a>5.2 示例：文件大小、映射大小</h3><p>在上面的知识前提下，我们下面看看如果大小不是页的整倍数的具体情况：</p><p><strong>情形一：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射5000字节到虚拟内存中。</strong></p><p>分析：因为单位物理页面的大小是4096字节，虽然被映射的文件只有5000字节，但是对应到进程虚拟地址区域的大小需要满足整页大小，因此mmap函数执行后，实际映射到虚拟内存区域8192个 字节，5000~8191的字节部分用零填充。映射后的对应关系如下图所示：</p><img src="/images/OS/mmap/mmap-04.png" alt="mmap-04" style="zoom:70%;" /><p>此时：</p><p>（1）读/写前5000个字节（0~4999），会返回操作文件内容。</p><p>（2）读字节5000~8191时，结果全为0。写5000~8191时，进程不会报错，但是所写的内容不会写入原文件中 。</p><p>（3）读/写8192以外的磁盘部分，会返回一个SIGSECV错误。</p><p><strong>情形二：一个文件的大小是5000字节，mmap函数从一个文件的起始位置开始，映射15000字节到虚拟内存中，即映射大小超过了原始文件的大小。</strong></p><p>分析：由于文件的大小是5000字节，和情形一一样，其对应的两个物理页。那么这两个物理页都是合法可以读写的，只是超出5000的部分不会体现在原文件中。由于程序要求映射15000字节，而文件只占两个物理页，因此8192字节~15000字节都不能读写，操作时会返回异常。如下图所示：</p><img src="/images/OS/mmap/mmap-05.png" alt="mmap-05" style="zoom:80%;" /><p>此时：</p><p>（1）进程可以正常读/写被映射的前5000字节(0~4999)，写操作的改动会在一定时间后反映在原文件中。</p><p>（2）对于5000~8191字节，进程可以进行读写过程，不会报错。但是内容在写入前均为0，另外，写入后不会反映在文件中。</p><p>（3）对于8192~14999字节，进程不能对其进行读写，会报SIGBUS错误。</p><p>（4）对于15000以外的字节，进程不能对其读写，会引发SIGSEGV错误。</p><p><strong>情形三：一个文件初始大小为0，使用mmap操作映射了1000*4K的大小，即1000个物理页大约4M字节空间，mmap返回指针ptr。</strong></p><p>分析：如果在映射建立之初，就对文件进行读写操作，由于文件大小为0，并没有合法的物理页对应，如同情形二一样，会返回SIGBUS错误。</p><p>但是如果，每次操作ptr读写前，先增加文件的大小，那么ptr在文件大小内部的操作就是合法的。例如，文件扩充4096字节，ptr就能操作ptr ~ [ (char)ptr + 4095]的空间。只要文件扩充的范围在1000个物理页（映射范围）内，ptr都可以对应操作相同的大小。</p><p>这样，方便随时扩充文件空间，随时写入文件，不造成空间浪费。</p><p>增加文件的大小，可以使用<code>ftruncate</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将path指定的文件、由fd引用的常规文件截断为精确长度字节的大小。</span></span><br><span class="line"><span class="comment"> *    如果文件以前大于此大小，则多余的数据将丢失。</span></span><br><span class="line"><span class="comment"> *    如果文件先前较短，则将其扩展，扩展部分读取为空字节 (&#x27;\0&#x27;)。</span></span><br><span class="line"><span class="comment"> * 文件偏移量没有改变。</span></span><br><span class="line"><span class="comment"> * 如果大小发生变化，则更新文件的 st_ctime 和 st_mtime 字段（分别为上次状态更改的时间和上次修改的时间），以及set-user-ID 和 set-group-ID权限位可以被清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>; <span class="comment">// 文件必须是可写的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;  <span class="comment">// 文件必须打开才能写入</span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">increaseFileLength</span>(<span class="params">length</span>: size_t)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel map first</span></span><br><span class="line"><span class="keyword">self</span>.munmap()</span><br><span class="line"></span><br><span class="line"><span class="comment">// change file length</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> ftruncate(fileDescriptor, fileLength <span class="operator">+</span> off_t(length))</span><br><span class="line"><span class="keyword">if</span> result <span class="operator">&lt;</span> <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;can&#x27;t truncate data file&quot;</span>)</span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remap</span></span><br><span class="line">fileLength <span class="operator">=</span> lseek(fileDescriptor, <span class="number">0</span>, <span class="type">SEEK_END</span>)</span><br><span class="line"><span class="keyword">self</span>.mmap()</span><br><span class="line"></span><br><span class="line">lock.unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、使用场景"><a href="#六、使用场景" class="headerlink" title="六、使用场景"></a>六、使用场景</h2><blockquote><p>这一部分来自苹果官方开发文档<a href="https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html">Mapping Files Into Memory</a></p></blockquote><p>尽管映射文件可以提供巨大的性能优势，但并不适用于所有情况。</p><p>文件映射的目标是减少磁盘和内存之间的传输。在某些情况下，文件映射可以帮助您，但不是全部。<strong>映射到内存中的文件越多，文件映射的用处就越少</strong>。</p><p>在将任何文件映射到内存之前，请确保您了解典型的文件使用模式。使用工具来帮助您确定应用程序访问文件的位置以及这些操作需要多长时间。</p><h3 id="6-1-适合的场景"><a href="#6-1-适合的场景" class="headerlink" title="6.1 适合的场景"></a>6.1 适合的场景</h3><ul><li>您有一个很大的文件，希望随机访问其内容一次或多次。</li><li>您有一个小文件，您想一次将其内容全部读入内存并经常访问。这种技术最适用于大小不超过几个虚拟内存页的文件。（页是地址空间的最小单位，虚拟页和物理页的大小是一样的，通常为4KB。）</li><li>您想在内存中缓存文件的特定部分。文件映射完全消除了缓存数据的需要，从而在系统磁盘缓存中为其他数据留出了更多空间。</li></ul><p>当随机访问一个非常大的文件时，最好是一次只映射文件的一小部分。映射大文件的问题是文件消耗活动内存。如果文件足够大，系统可能会被迫调出内存的其他部分来加载文件。将多个文件映射到内存中会加剧这个问题。</p><h3 id="6-2-不适合的场景"><a href="#6-2-不适合的场景" class="headerlink" title="6.2 不适合的场景"></a>6.2 不适合的场景</h3><p>在以下情况下不要使用文件映射：</p><ul><li>您只想从头到尾按顺序读取文件一次。</li><li>该文件的大小为数百兆字节或更大。将大文件映射到内存中会很快填满内存，并可能导致分页，这首先抵消了映射文件的好处。<strong>对于大型顺序读取操作，你应该禁用磁盘缓存(disk cache/page cache)并将文件读入一个小的内存缓冲区。</strong></li><li>该文件大于可用的连续虚拟内存地址空间。这对于 64 位应用程序来说不是问题，但对于 32 位应用程序来说可能是一个问题。</li><li>该文件位于可移动驱动器上。</li><li>该文件位于网络驱动器上。</li></ul><p>如果您在可移动驱动器或网络驱动器上映射文件，并且该驱动器被卸载或由于其他原因消失，则访问映射内存可能会导致总线错误并使您的程序崩溃。</p><h2 id="七、iOS-中的-mmap"><a href="#七、iOS-中的-mmap" class="headerlink" title="七、iOS 中的 mmap"></a>七、iOS 中的 mmap</h2><h3 id="7-1-性能测试用例"><a href="#7-1-性能测试用例" class="headerlink" title="7.1 性能测试用例"></a>7.1 性能测试用例</h3><p>下面这个程序，通过read和mmap两种方法分别对硬盘上一个名为“mmap_test”的文件进行操作，文件中存有10000个整数，程序两次使用不同的方法将它们读出，加1，再写回硬盘。通过对比可以看出，read消耗的时间将近是mmap的两到三倍。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv1</span>, <span class="title">tv2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*read*/</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;mmap_test&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX != read(fd, (<span class="keyword">void</span> *)<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Reading data failed.../n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line">        ++<span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX != write(fd, (<span class="keyword">void</span> *)<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Writing data failed.../n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    gettimeofday(&amp;tv2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time of read/write: %dms/n&quot;</span>, tv2.tv_usec - tv1.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*mmap*/</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv1, <span class="literal">NULL</span>);</span><br><span class="line">    fd = open(<span class="string">&quot;mmap_test&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">array</span> = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; ++i)</span><br><span class="line">        ++<span class="built_in">array</span>[i];</span><br><span class="line">        </span><br><span class="line">    munmap(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX);</span><br><span class="line">    msync(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * MAX, MS_SYNC);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    gettimeofday(&amp;tv2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time of mmap: %dms/n&quot;</span>, tv2.tv_usec - tv1.tv_usec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time of read&#x2F;write: 154ms</span><br><span class="line">Time of mmap: 68ms</span><br></pre></td></tr></table></figure><h3 id="7-2-自实现Demo"><a href="#7-2-自实现Demo" class="headerlink" title="7.2 自实现Demo"></a>7.2 自实现Demo</h3><p>用<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/FileSystem/Articles/MappingFiles.html">官方文档 — Mapping Files Into Memory</a>的代码做参考，实现一个读写的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName, <span class="keyword">void</span> ** outDataPtr, <span class="keyword">size_t</span> * outDataLength, <span class="keyword">size_t</span> appendSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> outError;</span><br><span class="line">    <span class="keyword">int</span> fileDescriptor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statInfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return safe values on error.</span></span><br><span class="line">    outError = <span class="number">0</span>;</span><br><span class="line">    *outDataPtr = <span class="literal">NULL</span>;</span><br><span class="line">    *outDataLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the file.</span></span><br><span class="line">    fileDescriptor = open( inPathName, O_RDWR, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>(fileDescriptor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        outError = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We now know the file exists. Retrieve the file size.</span></span><br><span class="line">        <span class="keyword">if</span>( fstat( fileDescriptor, &amp;statInfo ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            outError = errno;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ftruncate(fileDescriptor, statInfo.st_size + appendSize);</span><br><span class="line">            fsync(fileDescriptor);</span><br><span class="line">            *outDataPtr = mmap(<span class="literal">NULL</span>,</span><br><span class="line">                               statInfo.st_size + appendSize,</span><br><span class="line">                               PROT_READ|PROT_WRITE,</span><br><span class="line">                               MAP_FILE|MAP_SHARED,</span><br><span class="line">                               fileDescriptor,</span><br><span class="line">                               <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>( *outDataPtr == MAP_FAILED ) &#123;</span><br><span class="line">                outError = errno;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// On success, return the size of the mapped file.</span></span><br><span class="line">                *outDataLength = statInfo.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now close the file. The kernel doesn’t use our file descriptor.</span></span><br><span class="line">        close( fileDescriptor );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> dataLength;</span><br><span class="line">    <span class="keyword">void</span> * dataPtr;</span><br><span class="line">    <span class="keyword">char</span> *appendStr = <span class="string">&quot; append_key&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> appendSize = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(appendStr);</span><br><span class="line">    <span class="keyword">if</span>( MapFile(inPathName, &amp;dataPtr, &amp;dataLength, appendSize) == <span class="number">0</span>) &#123;</span><br><span class="line">        dataPtr = dataPtr + dataLength;</span><br><span class="line">        <span class="built_in">memcpy</span>(dataPtr, appendStr, appendSize);</span><br><span class="line">        <span class="comment">// Unmap files</span></span><br><span class="line">        munmap(dataPtr, appendSize + dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="function">interface <span class="title">ViewController</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    NSString * path = [NSHomeDirectory() stringByAppendingPathComponent:@<span class="string">&quot;test.data&quot;</span>];</span><br><span class="line">    NSLog(@<span class="string">&quot;path: %@&quot;</span>, path);</span><br><span class="line">    NSString *str = @<span class="string">&quot;test str&quot;</span>;</span><br><span class="line">    [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line"></span><br><span class="line">    ProcessFile(path.UTF8String);</span><br><span class="line">    NSString *result = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">    NSLog(@<span class="string">&quot;result:%@&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-MMKV-和-mmap"><a href="#7-3-MMKV-和-mmap" class="headerlink" title="7.3 MMKV 和 mmap"></a>7.3 MMKV 和 mmap</h3><h4 id="7-3-1-MMKV-简介"><a href="#7-3-1-MMKV-简介" class="headerlink" title="7.3.1 MMKV 简介"></a>7.3.1 MMKV 简介</h4><ul><li>NSUserDefault 是常见的缓存工具，但是数据有时会同步不及时，比如说在 crash 前保存的值很容易出现保存失败的情况，在 App 重新启动之后读取不到保存的值。</li><li>MMKV 很好的解决了 NSUserDefault 的局限，但是同样由于其独特设计，在数据量较大、操作频繁的场景下，会产生性能问题。这里的使用给出两个建议：<ul><li>不要全部用 defaultMMKV，根据业务大的类型做聚合，避免某一个 MMKV 数据过大，特别是对于某些只会出现一次的新手引导、红点之类的逻辑，尽可能按业务聚合，使用多个 MMKV 的对象；</li><li>对于需要频繁读写的数据，可以在内存持有一份数据缓存，必要时再更新到 MMKV。</li></ul></li></ul><h4 id="7-3-2-MMKV-原理"><a href="#7-3-2-MMKV-原理" class="headerlink" title="7.3.2 MMKV 原理"></a>7.3.2 MMKV 原理</h4><h5 id="1-内存准备"><a href="#1-内存准备" class="headerlink" title="1. 内存准备"></a>1. 内存准备</h5><p>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由 iOS 负责将内存回写到文件，不必担心 crash 导致数据丢失。</p><h5 id="2-数据组织"><a href="#2-数据组织" class="headerlink" title="2. 数据组织"></a>2. 数据组织</h5><p>数据序列化方面选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</p><p>考虑到要提供的是通用 KV 组件，key 可以限定是 string 字符串类型，value 则多种多样（int/bool/double 等）。要做到通用的话，考虑<strong>将 value 通过 protobuf 协议序列化成统一的内存块（buffer），然后就可以将这些 KV 对象序列化到内存中。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message KV &#123;</span><br><span class="line">  string key = <span class="number">1</span> ;</span><br><span class="line">  buffer value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setInt32:(int32 t)value forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">  auto data = PBEncode(value); </span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> setData:data forKey:key];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setData: (<span class="built_in">NSData</span>*)data forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">  auto kv = KV[key,data];</span><br><span class="line">  auto buf = PBEncode(kv);</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> write: buf];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-写入优化"><a href="#3-写入优化" class="headerlink" title="3. 写入优化"></a>3. 写入优化</h5><p>标准 protobuf 不提供增量更新的能力，每次写入都必须全量写入。考虑到主要使用场景是频繁地进行写入更新，我们需要有<strong>增量更新的能力：将增量 kv 对象序列化后，直接 append 到内存末尾。</strong>这样同一个 key 会有新旧若干份数据，最新的数据在最后。那么只需在程序启动第一次打开 mmkv 时，不断用后读入的 value 替换之前的值，就可以保证数据是最新有效的。</p><h5 id="4-空间增长"><a href="#4-空间增长" class="headerlink" title="4. 空间增长"></a>4. 空间增长</h5><p>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。</p><p>例如同一个 key 不断更新的话，是可能耗尽几百 M 甚至上 G 空间，而事实上整个 KV 文件就这一个 key，不到 1k 空间就存得下，这明显是不可取的。</p><p>我们需要在性能和空间上做个折中：</p><p><strong>以内存 pagesize 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整、key 排重，尝试序列化保存排重结果；排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)append: (<span class="built_in">NSData</span>*)data &#123;</span><br><span class="line">  <span class="keyword">if</span> (space &gt;= data.length) &#123;</span><br><span class="line">    append(fd, data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newData = unique(m_allKV);</span><br><span class="line">    <span class="keyword">if</span> (total_space &gt;= newData.length) &#123;</span><br><span class="line">      write(fd, newData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (total_space &lt; newData.length) &#123;</span><br><span class="line">        total_ space *= <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ftruncate(fd, total . space);</span><br><span class="line">      write(fd, newData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-数据有效性"><a href="#5-数据有效性" class="headerlink" title="5. 数据有效性"></a>5. 数据有效性</h5><p>考虑到文件系统、操作系统都有一定的不稳定性，另外增加了 crc 校验，对无效数据进行甄别。</p><h5 id="6-MMKV-性能"><a href="#6-MMKV-性能" class="headerlink" title="6. MMKV 性能"></a>6. MMKV 性能</h5><p>写个简单的测试，将 MMKV、NSUserDefaults 的性能进行对比（循环写入1w 次数据，测试环境：iPhone X 256G, iOS 11.2.6，单位：ms）：</p><img src="/images/OS/mmap/mmap-06.jpg" alt="mmap-06" style="zoom:75%;" /><p>可见 MMKV 性能远远优于 iOS 自带的 NSUserDefaults。另外，在测试中发现，NSUserDefaults 在每 2-3 次测试，就会有 1 次比较耗时的操作，怀疑是触发了数据 synchronize 重整写入。对比之下，MMKV 即使触发数据重整，也保持了性能的稳定高效。</p><h3 id="7-4-NSData-与-mmap"><a href="#7-4-NSData-与-mmap" class="headerlink" title="7.4 NSData 与 mmap"></a>7.4 NSData 与 mmap</h3><p>NSData 有一个静态方法和 mmap 有关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (id)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSDataReadingOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint to map the file in if possible and safe. 在保证安全的前提下使用 mmap</span></span><br><span class="line">    NSDataReadingMappedIfSafe =   <span class="number">1UL</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// Hint to get the file not to be cached in the kernel. 不要缓存。如果该文件只会读取一次，这个设置可以提高性能</span></span><br><span class="line">    NSDataReadingUncached = <span class="number">1UL</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// Hint to map the file in if possible. This takes precedence over NSDataReadingMappedIfSafe if both are given.  总使用 mmap</span></span><br><span class="line">    NSDataReadingMappedAlways API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">1UL</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>Mapped 的意思是使用 mmap，那么 ifSafe 是什么意思呢？NSDataReadingMappedIfSafe 和 NSDataReadingMappedAlways 有什么区别？</li><li>如果使用 mmap，则在 NSData 的生命周期内，都不能删除对应的文件。</li><li>如果文件是在固定磁盘，非可移动磁盘、网络磁盘，则满足 NSDataReadingMappedIfSafe。对 iOS 而言，这个 NSDataReadingMappedIfSafe = NSDataReadingMappedAlways。</li><li>那什么情况下应该用对应的参数？<ul><li>如果文件很大，直接使用 dataWithContentsOfFile 方法，会导致 load 整个文件，出现内存占用过多的情况；此时用 NSDataReadingMappedIfSafe，则会使用 mmap 建立文件映射，减少内存的占用。</li><li>使用场景：视频加载。视频文件通常比较大，但是使用的过程中不会同时读取整个视频文件的内容，可以使用 mmap 优化。</li></ul></li></ul><h3 id="7-5-FastImageCache"><a href="#7-5-FastImageCache" class="headerlink" title="7.5 FastImageCache"></a>7.5 FastImageCache</h3><p><a href="https://github.com/path/FastImageCache">FastImageCache</a>是Path团队开发的一个开源库，提供了一种在 iOS 应用程序中存储和检索图像的高效、持久且最重要的快速方法。</p><p>iOS从磁盘加载一张图片，使用UIImageVIew显示在屏幕上，需要经过以下步骤：</p><ol><li><p>从磁盘拷贝数据到内核缓冲区</p></li><li><p>从内核缓冲区复制数据到用户空间</p></li><li><p>生成UIImageView，把图像数据赋值给UIImageView</p></li><li><p>如果图像数据为未解码的PNG/JPG，解码为位图数据</p></li><li><p>CATransaction捕获到UIImageView layer树的变化</p></li><li><p>主线程Runloop提交CATransaction，开始进行图像渲染</p><p>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。</p><p>6.2 GPU处理位图数据，进行渲染。</p></li></ol><p>FastImageCache分别优化了2、4、6.1三个步骤：</p><ol><li>使用mmap内存映射，省去了上述第2步数据从内核空间拷贝到用户空间的操作。</li><li>缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作。</li></ol><h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul><li><a href="https://blog.csdn.net/jinking01/article/details/107480248">Linux内核Page Cache和Buffer Cache关系及演化历史</a></li><li><a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html">从内核文件系统看文件读写过程</a></li><li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">认真分析mmap：是什么 为什么 怎么用 </a></li><li><a href="https://blog.csdn.net/joejames/article/details/37958017">linux内存映射mmap原理分析</a></li><li><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemAdvancedPT/MappingFilesIntoMemory/MappingFilesIntoMemory.html">Apple Developer — Mapping Files Into Memory</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟</summary>
      
    
    
    
    <category term="操作系统" scheme="https://tenloy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>AVFoundation Programming Guide(译)</title>
    <link href="https://tenloy.github.io/2022/03/18/avfoundation.html"/>
    <id>https://tenloy.github.io/2022/03/18/avfoundation.html</id>
    <published>2022-03-18T16:54:19.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVFoundation概述"><a href="#AVFoundation概述" class="headerlink" title="AVFoundation概述"></a>AVFoundation概述</h1><blockquote><p>译文，原文链接：<a href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/AVFoundationPG/RevisionHistory.html#//apple_ref/doc/uid/TP40010188-CH99-SW1">AVFoundation Programming Guide</a>.（不完全一致。内容结构有调整，增加了一些类的定义源码）</p></blockquote><p>AVFoundation 是一个媒体框架，它提供的接口：</p><ul><li>可以精确地处理基于时间的音视频媒体数据，比如媒体文件的查找、创建、编辑、二次编码。</li><li>可以从设备获取输入流并在实时捕获和播放期间操作视频。</li></ul><p>iOS 上的架构：</p><img src="/images/avf/frameworksBlockDiagram_2x.png" alt="img" style="zoom:70%;" /><p> OS X 上相应的媒体架构：</p><img src="/images/avf/frameworksBlockDiagramOSX_2x.png" alt="img" style="zoom:70%;" /><p>AVFoundation 框架包含视频API 和音频API 两方面。较早的与音频相关的类提供了处理音频的简单方法：</p><ul><li>播放声音文件，可以使用 AVAudioPlayer。</li><li>录制音频，可以使用 AVAudioRecorder。</li><li>使用 AVAudioSession 配置应用程序的音频行为。</li></ul><p>在完成具体的开发任务时，你应该尽可能的选择更高层次的抽象框架。</p><ul><li>如果只需要播放视频，可以使用 AVKit 框架</li><li>如果需要在 iOS 设备上录制视频，而且并不关心更具体的录制参数，可以使用 UIKit 中 UIImagePickerController 类。</li></ul><p>需要注意的是，在 AVFoundation 框架中使用的一些原始数据结构 (包括时间相关的数据结构和存储描述媒体数据的底层对象)，都在 Core Media 框架中声明。</p><h1 id="一、使用Assets"><a href="#一、使用Assets" class="headerlink" title="一、使用Assets"></a>一、使用Assets</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Asset 资产;财产;有价值的人(或事物);有用的人(或事物);</p><ul><li><p>现实中，更多的指资产、财产</p></li><li><p>编程中，可以理解为资源，图像、音频、视频等，与resource相近(Android中两者所表示的文件在编译处理上大有不同，不展开讲了)。以下出现的资产、资源都是指asset的中文翻译</p></li></ul></blockquote><p>AVFoundation 框架中表示媒体的主要类 — AVAsset。 <code>AVAsset</code> 表示基于时间的视听数据，比如电影文件或视频流。<code>AVAsset</code> 的结构决定了 AV Foundation 框架大部分的工作方式。</p><ul><li>AVAsset 实例是一个或多个媒体数据（音频和视频轨道）的集合的聚合表示。它提供有关整个集合的信息，例如其标题、持续时间、自然呈现大小等。<ul><li>AVAsset也可能有元数据</li></ul></li><li>AVAsset 是一个抽象类，可以使用它的子类来：<ul><li>从 URL 创建一个 asset 对象</li><li>根据已有的媒体资源合成出一个新的媒体资源。</li></ul></li><li>AVAsset 不依赖于特定的数据格式。</li><li>AVAsset 中的每条独立的媒体数据都有一个统一类的型，称为轨道(track)。<ul><li>在一个典型的简单情况下，一个轨道代表音频分量，另一个轨道代表视频分量；</li><li>然而，在复杂的合成中，可能有多个重叠的音频和视频轨道。</li></ul></li></ul><p>拥有一个电影资产后，可以从中提取静止图像、将其转码为另一种格式或修剪内容。</p><h2 id="1-1-资产与轨道-AVAsset与AVAssetTrack"><a href="#1-1-资产与轨道-AVAsset与AVAssetTrack" class="headerlink" title="1.1 资产与轨道(AVAsset与AVAssetTrack)"></a>1.1 资产与轨道(AVAsset与AVAssetTrack)</h2><h3 id="1-1-1-AVAsset类结构"><a href="#1-1-1-AVAsset类结构" class="headerlink" title="1.1.1 AVAsset类结构"></a>1.1.1 AVAsset类结构</h3><p>AVAsset 是 AV Foundation 框架的核心关键类，它提供了对视听数据(如电影、视频流)的<strong>格式无关的抽象</strong>。</p><p>类之间的关系如下图所示。大部分情况下，使用的都是这些类的子类：</p><ul><li>使用 AVComposition 子类创建新的 asset</li><li>使用 AVURLAsset 子类根据一个指定的 URL（包括来自MPMedia、AssetLibrary框架的asset(iPod库/相册)）创建 asset</li></ul><img src="/images/avf/avassetHierarchy_2x.png" alt="img" style="zoom:70%;" /><p>一个 asset 包含：</p><ul><li>一组 track，每个 track 都有特定媒体类型，包括但不限于 audio，video，text，closed captions 以及 subtitles。</li><li>整个资源的信息，比如时长和标题。</li><li>Asset 对象也可能包含元数据 (metadata)，metadata 由 <a href="https://developer.apple.com/reference/avfoundation/avmetadataitem">AVMetadataItem</a> 类表示。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">AVAsynchronousKeyValueLoading</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredRate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredVolume;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGAffineTransform</span> preferredTransform;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> naturalSize API_DEPRECATED(<span class="string">&quot;Use the naturalSize and preferredTransform, as appropriate, of the receiver&#x27;s video tracks. See -tracksWithMediaType:&quot;</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVDisplayCriteria</span> *preferredDisplayCriteria;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> minimumTimeOffsetFromLive;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 异步加载 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetAsynchronousLoading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> providesPreciseDurationAndTiming;</span><br><span class="line">- (<span class="keyword">void</span>)cancelLoading;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用限制 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetReferenceRestrictions</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetReferenceRestrictions</span> referenceRestrictions;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetTrackInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *tracks;</span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrackGroup</span> *&gt; *trackGroups;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMetadataReading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMetadataItem</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lyrics;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *commonMetadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataFormat</span>&gt; *availableMetadataFormats;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *)metadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format;</span><br><span class="line">- (<span class="keyword">void</span>)loadMetadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 章节检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetChapterInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSLocale</span> *&gt; *availableChapterLocales;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 媒体 选择 选项 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMediaSelection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaCharacteristic</span>&gt; *availableMediaCharacteristicsWithMediaSelectionOptions;</span><br><span class="line">- (<span class="built_in">AVMediaSelectionGroup</span> *)mediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadMediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMediaSelectionGroup</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaSelection</span> *preferredMediaSelection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">AVMediaSelection</span> *&gt; *allMediaSelections;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetProtectedContent</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasProtectedContent;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetFragments</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canContainFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> containsFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> overallDurationHint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetUsability</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exportable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> composable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithSavedPhotosAlbum;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithAirPlayVideo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="1-1-2-轨道-Track"><a href="#1-1-2-轨道-Track" class="headerlink" title="1.1.2 轨道(Track)"></a>1.1.2 轨道(Track)</h3><p>如下图所示，一个 track 由 AVAssetTrack 类表示。简单场景下，一个 track 代表 audio component，另一个 track 代表 video component；复杂场景下，可能有多个 audio 和 video 重叠的 track。</p><img src="/images/avf/avassetAndTracks_2x.png" alt="img" style="zoom:70%;" /><p>一个 track 包含多个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 包含此轨道的asset对象  */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">weak</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基本性质和特点 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackBasicPropertiesAndCharacteristics</span>)</span></span><br><span class="line"><span class="comment">// 类型 (video or audio)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// track 包含一个描述格式的数组。这个数组中的元素为 CMFormatDescription 对象，用来描述 track 包含的媒体的格式信息。</span></span><br><span class="line">  <span class="comment">// track通常呈现统一的媒体（例如，使用相同编码设置编码的媒体），此时是包含单一格式的描述。</span></span><br><span class="line">  <span class="comment">// 但是，在某些情况下，track可能包含多种格式描述。例如，一个 H.264 编码的视频轨道可能有一些片段使用 Main profile 编码，而其他片段使用 High profile 编码。</span></span><br><span class="line">  <span class="comment">// 此外，作为 AVAssetTrack 的子类的单个 AVCompositionTrack 可能包含使用不同编解码器的音频或视频片段。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *formatDescriptions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> decodable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> selfContained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">long</span> <span class="keyword">long</span> totalSampleDataLength;</span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTemporalProperties</span>)</span></span><br><span class="line"><span class="comment">//该轨道在assett整体时间线内的时间范围</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 语言属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackLanguageProperties</span>) </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 视觉特征的属性.如画面大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForVisualCharacteristic</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 听觉特性的属性.如音量大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForAudibleCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于帧特性的属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForFrameBasedCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 片段。一个 track 可能被分为几段，每一段由一个 AVAssetTrackSegment 对象表示，该对象就是一个由资源数据到 track 时间轴的映射。 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSegments</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackMetadataReading</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track的关联 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTrackAssociations</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样本光标 AVSampleCursor实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSampleCursorProvision</span>)</span></span><br></pre></td></tr></table></figure><h2 id="1-2-创建AVURLAsset"><a href="#1-2-创建AVURLAsset" class="headerlink" title="1.2 创建AVURLAsset"></a>1.2 创建AVURLAsset</h2><h3 id="1-2-1-类源码"><a href="#1-2-1-类源码" class="headerlink" title="1.2.1 类源码"></a>1.2.1 类源码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> : <span class="title">AVAsset</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)audiovisualTypes;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)audiovisualMIMETypes;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isPlayableExtendedMIMEType: (<span class="built_in">NSString</span> *)extendedMIMEType;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)URLAssetWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetURLHandling</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetResourceLoader</span> *resourceLoader;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetCache</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetCache</span> *assetCache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetCompositionUtility</span> )</span></span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)compatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack;</span><br><span class="line">- (<span class="keyword">void</span>)findCompatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler API_AVAILABLE(macos(<span class="number">12.0</span>), ios(<span class="number">15.0</span>), tvos(<span class="number">15.0</span>), watchos(<span class="number">8.0</span>));</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetVariantInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetVariant</span> *&gt; *variants;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-创建一个AVURLAsset对象"><a href="#1-2-2-创建一个AVURLAsset对象" class="headerlink" title="1.2.2 创建一个AVURLAsset对象"></a>1.2.2 创建一个AVURLAsset对象</h3><p>AVURLAsset代表任何一个能用URL识别的资源的asset。最简单的是从一个file创建asset。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#<span class="string">&quot;标识视听资产（如电影文件）的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>初始化的第二个参数options是一个字典。</p><p>字典中唯一使用的key是AVURLAssetPreferPreciseDurationAndTimingKey。对应的值是一个布尔值（包含在 NSValue对象中），这个布尔值指出了这个asset是否应该提供准确的duration，以及支持随机读取指定时间的内容。</p><p>获得一个asset 精确的的持续时间duration可能需要大量的处理开销。使用一个近似的持续时间通常是更划算的选择，并且对于播放已经足够。因此：</p><ul><li>如果只是播放asset，options传递nil，或者字典里对应的值是NO(包含在NSValue对象中)</li><li>如果要将asset添加到composition，需要精确的随机存取，传递一个字典，对应值是YES(包含在NSValue对象中)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span> : @YES&#125;; </span><br><span class="line"><span class="built_in">AVURLAsset</span> *asset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:fileUrl options:dict];</span><br></pre></td></tr></table></figure><h3 id="1-2-3-访问用户的asset-iPod库-相册"><a href="#1-2-3-访问用户的asset-iPod库-相册" class="headerlink" title="1.2.3 访问用户的asset(iPod库+相册)"></a>1.2.3 访问用户的asset(iPod库+相册)</h3><p>要访问由 iPod 库、相册中的资产，需要获取对应资产的 URL。</p><ul><li>访问 iPod 库，需要创建一个 MPMediaQuery 实例来查找想要的项目，然后使用 <strong>MPMediaItemPropertyAssetURL</strong> 获取其 URL。</li><li>访问照片应用程序管理的资产，使用 <strong>ALAssetsLibrary</strong> —— iOS9.0之后这个库失效，使用PHPhotoLibrary库</li></ul><p>下面的是获取用户相册中第一个视频的示例代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span></span><br><span class="line">[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Within the group enumeration block, filter to enumerate just videos.</span></span><br><span class="line">[group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// For this example, we&#x27;re only interested in the first item.</span></span><br><span class="line">[group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>]</span><br><span class="line">                        options:<span class="number">0</span></span><br><span class="line">                     usingBlock:^(ALAsset *alAsset, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *innerStop) &#123;</span><br><span class="line"> </span><br><span class="line">                         <span class="comment">// The end of the enumeration is signaled by asset == nil.</span></span><br><span class="line">                         <span class="keyword">if</span> (alAsset) &#123;</span><br><span class="line">                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];</span><br><span class="line">                             <span class="built_in">NSURL</span> *url = [representation url];</span><br><span class="line">                             <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line">                             <span class="comment">// Do something interesting with the AV asset.</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;];</span><br><span class="line">                 &#125;</span><br><span class="line">                 failureBlock: ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                     <span class="comment">// Typically you should handle an error more gracefully than this.</span></span><br><span class="line">                     <span class="built_in">NSLog</span>(<span class="string">@&quot;No groups&quot;</span>);</span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure><h2 id="1-3-使用Asset"><a href="#1-3-使用Asset" class="headerlink" title="1.3 使用Asset"></a>1.3 使用Asset</h2><p>注意：<strong>初始化asset或track并不一定意味着它已准备好使用。</strong>可能需要一些时间去计算项目的持续时间(duration)（例如，MP3 文件可能不包含摘要信息）。计算时不要阻塞当前线程，可以使用 AVAsynchronousKeyValueLoading 协议来请求值，完成处理后通过定义的block回调结果（AVAsset 和 AVAssetTrack 符合 AVAsynchronousKeyValueLoading 协议）。</p><p>可以使用 <code>statusOfValueForKey:error:</code> 判断是否为属性加载了值。asset首次加载时，其大部分或全部属性的值为 AVKeyValueStatusUnknown。</p><p>可以使用 <code>loadValuesAsynchronouslyForKeys:completionHandler:</code> 为一个或多个属性加载值。在完成处理程序中，可以根据属性的状态采取任何适当的操作。注意：加载是可能会失败的，比如基于网络的 URL 不可访问，或者加载被取消。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *keys = @[<span class="string">@&quot;duration&quot;</span>]; <span class="comment">// 如果准备一个asset去播放，应该加载它的 tracks 属性</span></span><br><span class="line"> </span><br><span class="line">[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> tracksStatus = [asset statusOfValueForKey:<span class="string">@&quot;duration&quot;</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">switch</span> (tracksStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</span><br><span class="line">            [<span class="keyword">self</span> updateUserInterfaceForDuration];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</span><br><span class="line">            [<span class="keyword">self</span> reportError:error forAsset:asset];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</span><br><span class="line">            <span class="comment">// Do whatever is appropriate for cancelation.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="1-4-视频中获取静态图像-AssetImageGenerator"><a href="#1-4-视频中获取静态图像-AssetImageGenerator" class="headerlink" title="1.4 视频中获取静态图像(AssetImageGenerator)"></a>1.4 视频中获取静态图像(AssetImageGenerator)</h2><p>从视频中获取静态图片 (比如某个时间点的视频预览缩略图)，可以使用 AVAssetImageGenerator。</p><p>使用asset初始化一个图像生成器对象。注意即使asset在初始化时没有视觉轨道，初始化也可能成功，所以如果有必要，应该使用 trackWithMediaCharacteristic: 提前判断一下asset是否用于可视化的track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> anAsset = &lt;#Get an asset#&gt;; <span class="comment">// 使用要生成缩略图的asset来初始化</span></span><br><span class="line"><span class="keyword">if</span> ([[anAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:anAsset];</span><br><span class="line">    <span class="comment">// Image Generator使用默认启用的视频轨道来生成图像</span></span><br><span class="line">    <span class="comment">// Implementation continues...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以配置图像生成器的几个方面，比如：</p><ul><li>使用 maximumSize 属性设置图片的最大尺寸</li><li>使用 apertureMode 属性设置图片的光栅模式</li><li>根据给定的时间点生成单张或者一系列的图片</li></ul><p>注意：生成过程中必须确保 imagegenerator 的强引用。</p><h3 id="1-4-1-生成单个图像"><a href="#1-4-1-生成单个图像" class="headerlink" title="1.4.1 生成单个图像"></a>1.4.1 生成单个图像</h3><p>使用 copyCGImageAtTime:actualTime:error: 在指定时间生成单个图像。AVFoundation可能无法精确的根据你指定的时间生成图像，所以可以将一个指向 CMTime 的指针作为第二个参数传递，该指针在返回时包含实际生成图像的时间。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [[<span class="built_in">AVAssetImageGenerator</span> alloc] initWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> midpoint = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">2.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">CMTime</span> actualTime;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (halfWayImage != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime);</span><br><span class="line">    <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, midpoint);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got halfWayImage: Asked for %@, got %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(halfWayImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-生成一系列图像"><a href="#1-4-2-生成一系列图像" class="headerlink" title="1.4.2 生成一系列图像"></a>1.4.2 生成一系列图像</h3><p>使用 <code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code> 生成一系列图像。</p><ul><li>第一个参数是一个 NSValue 对象数组，每个对象都包含一个 CMTime 结构体对象，指定你希望的生成图像的时间。</li><li>第二个参数是一个block，用作为生成的每个图像调用的回调。block的参数中提供了一个结果常量，表示图像创建是成功、失败、被取消等结果，在 block 中，应当检查图片生成的结果。另外，根据不同情况，可能包含以下的参数：<ul><li>生成的图片</li><li>请求生成图片的时间和实际生成图片的时间</li><li>生成失败的原因</li></ul></li></ul><p>在完成创建图像之前，保持一个对图像生成器的强引用。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="comment">// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;</span></span><br><span class="line"><span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> end = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[<span class="built_in">NSValue</span> valueWithCMTime:kCMTimeZero],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:end]];</span><br><span class="line"></span><br><span class="line">[imageGenerator generateCGImagesAsynchronouslyForTimes:times</span><br><span class="line">                completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span> image, <span class="built_in">CMTime</span> actualTime,</span><br><span class="line">                                    <span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, requestedTime));</span><br><span class="line">                <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime));</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Requested: %@; actual %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;</span><br><span class="line">                    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorFailed</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed with error: %@&quot;</span>, [error localizedDescription]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorCancelled</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Canceled&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>调用图像生成器的 cancelAllCGImageGeneration ，来取消图像序列的生成。</p><h2 id="1-5-视频的剪辑和转码-AVAssetExportSession"><a href="#1-5-视频的剪辑和转码-AVAssetExportSession" class="headerlink" title="1.5 视频的剪辑和转码(AVAssetExportSession)"></a>1.5 视频的剪辑和转码(AVAssetExportSession)</h2><p>AVAssetExportSession 对象可以剪辑视频或者对视频进行格式转换。流程图如下：</p><img src="/images/avf/export_2x.png" alt="img" style="zoom:80%;" /><p>导出会话(export session)是管理asset异步导出的控制器对象。</p><ul><li><p>使用要导出的asset、指示导出选项的导出预设(export preset)的名称来初始化会话。</p><ul><li>使用 exportPresetsCompatibleWithAsset: 检查是否可以使用给定预设导出asset</li></ul></li><li><p>然后配置 export session 指定导出的 URL 、文件格式、其他信息 (比如是否因为网络使用而对元数据进行优化)。</p><ul><li>指定输出URL：该URL必须是文件URL</li><li>文件类型：AVAssetExportSession 可以从 URL 的路径扩展名推断输出文件类型；但是，通常您直接使用 outputFileType 设置它。</li><li>其它可选的设置，例如元数据、时间范围、输出文件长度的限制、导出的文件是否应针对网络使用输出优化、视频合成等。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *anAsset = &lt;#Get an asset#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *compatiblePresets = [<span class="built_in">AVAssetExportSession</span> exportPresetsCompatibleWithAsset:anAsset];</span><br><span class="line"><span class="keyword">if</span> ([compatiblePresets containsObject:<span class="built_in">AVAssetExportPresetLowQuality</span>]) &#123;</span><br><span class="line">    <span class="built_in">AVAssetExportSession</span> *exportSession = [[<span class="built_in">AVAssetExportSession</span> alloc]</span><br><span class="line">        initWithAsset:anAsset presetName:<span class="built_in">AVAssetExportPresetLowQuality</span>];</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">    <span class="comment">// 使用 timeRange 属性修剪影片</span></span><br><span class="line">    exportSession.outputURL = &lt;#A file URL#&gt;;</span><br><span class="line">    exportSession.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CMTime</span> start = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">1.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTime</span> duration = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTimeRange</span> range = <span class="built_in">CMTimeRangeMake</span>(start, duration);</span><br><span class="line">    exportSession.timeRange = range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 exportAsynchronouslyWithCompletionHandler: 方法导出文件。导出操作完成时会调用complete handler。在该代码块中，需要根据 status 属性判断导出是否成功。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[exportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ([exportSession status]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusFailed</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export failed: %@&quot;</span>, [[exportSession error] localizedDescription]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusCancelled</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export canceled&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>可以通过向会话发送 cancelExport 消息来取消导出。</p></li></ul><p>导出到一个已存在的文件或者导出到应用程序沙盒目录外将会导致导出失败。其他可能导致失败的情况包括：</p><ul><li>导出过程中接收到电话呼叫</li><li>程序进入后台, 有其他程序开始使用播放功能</li></ul><p>在这些情况下，要告知用户导出失败，并允许用户重新开始导出。</p><h1 id="二、播放Assets"><a href="#二、播放Assets" class="headerlink" title="二、播放Assets"></a>二、播放Assets</h1><p>AVFoundation 允许以更精确的方式管理asset的播放。为了支持这一点，它将asset的呈现状态(presentation state)与asset本身分开。这就能让开发者在同一时刻以不同分辨率呈现同一资源的两个不同片段。</p><ul><li>使用 AVPlayer 对象来控制asset的播放。</li><li>使用播放器项目(player item)对象管理asset的呈现状态（AVPlayerItem 实例）</li><li>使用播放器项目轨道(player item track)对象管理asset中每个轨道的呈现状态 （AVPlayerItemTrack实例）</li></ul><p>比如，使用 player item 和 player item tracks 可以：</p><ul><li>设置资源的可视部分在播放时的尺寸</li><li>播放时，设置audio 的混音参数、视频合成设置，或者禁用asset中的某些部分</li></ul><p>使用 <em>player</em> 对象可以播放 player items 对象，或者直接指定将其输出 (output) 到 Core Animation layer 之上。还可以使用播放队列(<em>player queue</em>) 来顺序播放多个 player items 对象。</p><p>使用 AVPlayerLayer 对象来显示视频。</p><h2 id="2-1-核心类概述"><a href="#2-1-核心类概述" class="headerlink" title="2.1 核心类概述"></a>2.1 核心类概述</h2><h3 id="2-1-1-播放器AVPlayer"><a href="#2-1-1-播放器AVPlayer" class="headerlink" title="2.1.1 播放器AVPlayer"></a>2.1.1 播放器AVPlayer</h3><p>播放器(player)是一个控制器对象，用于管理资源的播放，例如开始和停止播放，以及寻找特定时间。</p><ul><li>使用 AVPlayer 实例来播放单个资源。</li><li>使用 AVQueuePlayer 对象按顺序播放多个项目（AVQueuePlayer 是 AVPlayer 的子类）。在 OS X 上，您可以选择使用 AVKit 框架的 AVPlayerView 类在视图中播放内容。</li></ul><p>播放器可提供有关播放状态的信息，因此，如果需要，可以将用户界面与播放器的状态同步。</p><p>通常，将播放器的输出定向到专门的核心动画层（AVPlayerLayer 或 AVSynchronizedLayer 的实例）。要了解有关图层的更多信息，请参阅核心动画编程指南。</p><blockquote><p>多个播放器层：您可以从单个 AVPlayer 实例创建多个 AVPlayerLayer 对象，但只有最近创建的layer才会在屏幕上显示视频内容。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器AVPlayer</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayer</span> : <span class="title">NSObject</span> </span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPlayerItem:(<span class="keyword">nullable</span> <span class="built_in">AVPlayerItem</span> *)item;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVPlayerStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayerItem</span> *currentItem;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> volume;  <span class="comment">// 音量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isMuted) <span class="built_in">BOOL</span> muted; <span class="comment">// 静音</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-AVPlayerItem"><a href="#2-1-2-AVPlayerItem" class="headerlink" title="2.1.2 AVPlayerItem"></a>2.1.2 AVPlayerItem</h3><ul><li>播放资源时，需要向 AVPlayer 对象提供一个 AVPlayerItem 实例，而不是直接提供asset。</li><li>player item会管理与其关联的asset的呈现状态。</li><li>player item包含了播放器项目轨道（AVPlayerItemTrack 的实例），它们对应于asset中的轨道。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器项目AVPlayerItem</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItem</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVPlayerItemStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVPlayerItemTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CGSize</span> presentationSize;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>不仅可以使用现有asset初始化player item，也可以直接从 URL 初始化，以便你可以在特定位置播放资源（AVPlayerItem会为资源创建和配置一个asset）。</p><p>然而，与 AVAsset 一样，简单地初始化一个player item并不一定意味着它已经可以立即播放。你可以<strong>使用KVO观察player item的status属性</strong>来确定它是否以及何时准备好播放。</p><h3 id="2-1-3-AVPlayerLayer"><a href="#2-1-3-AVPlayerLayer" class="headerlink" title="2.1.3 AVPlayerLayer"></a>2.1.3 AVPlayerLayer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerLayer</span> : <span class="title">CALayer</span></span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line"><span class="built_in">AVPlayerLayerInternal</span>*_playerLayer;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">AVPlayerLayer</span> *)playerLayerWithPlayer:(<span class="keyword">nullable</span> <span class="built_in">AVPlayer</span> *)player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="comment">//指示player的当前player item的第一个视频帧是否准备好显示</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isReadyForDisplay) <span class="built_in">BOOL</span> readyForDisplay;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> videoRect;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *pixelBufferAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="2-1-4-类关系梳理"><a href="#2-1-4-类关系梳理" class="headerlink" title="2.1.4 类关系梳理"></a>2.1.4 类关系梳理</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItemTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 被播放器项目轨道表示了其呈现状态的资产轨道。 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetTrack</span> *assetTrack;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>按照类关联关系：AVPlayer → AVPlayerItem → AVPlayerItemTrack → AVAssetTrack</p></blockquote><img src="/images/avf/avplayerLayer_2x.png" alt="avplayerLayer_2x" style="zoom:70%;" /><p>这种抽象意味着可以同时使用不同的播放器播放一个给定的资源，每个播放器以不同的方式呈现。比如下图 ，不同的播放器使用不同的设置播放同一个相同的资产。可以使用项目轨道，在播放期间禁用特定轨道（例如屏蔽声音）。</p><img src="/images/avf/playerObjects_2x.png" alt="playerObjects_2x" style="zoom:70%;" /><h2 id="2-2-处理不同类型的资源"><a href="#2-2-处理不同类型的资源" class="headerlink" title="2.2 处理不同类型的资源"></a>2.2 处理不同类型的资源</h2><h3 id="2-2-1-两种类型资源"><a href="#2-2-1-两种类型资源" class="headerlink" title="2.2.1 两种类型资源"></a>2.2.1 两种类型资源</h3><p>asset播放的方式取决于其类型。从广义上讲，有两种主要类型：</p><ul><li>基于文件的资源 file-based assets ，你可以随机访问（例如从本地文件、媒体库、相册）</li><li>基于流的资源 stream-based assets（HTTP 实时流格式）</li></ul><h3 id="2-2-2-播放基于文件的资源"><a href="#2-2-2-播放基于文件的资源" class="headerlink" title="2.2.2 播放基于文件的资源"></a>2.2.2 播放基于文件的资源</h3><p>步骤：</p><ol><li>使用 AVURLAsset 创建 AVAsset</li><li>使用asset创建 AVPlayerItem 的实例</li><li>将 AVPlayerItem实例 与 AVPlayer 实例相关联</li><li>等待，直到player item的status属性表明已经可以播放（通过KVO观察属性变化）。</li></ol><p>示例代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@&quot;VideoFileName&quot;</span> </span><br><span class="line">                                             withExtension:<span class="string">@&quot;extension&quot;</span>];</span><br><span class="line">    <span class="comment">//创建一个资源实例</span></span><br><span class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:fileURL];</span><br><span class="line">    <span class="comment">//关联播放资源</span></span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">    <span class="comment">//添加监听PlayerItem的status属性值</span></span><br><span class="line">    [playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;ItemStatusContext];</span><br><span class="line">    <span class="comment">//创建player</span></span><br><span class="line">    _player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:playerItem]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// ... 处理逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-播放-HTTP-实时流"><a href="#2-2-3-播放-HTTP-实时流" class="headerlink" title="2.2.3 播放 HTTP 实时流"></a>2.2.3 播放 HTTP 实时流</h3><p>使用 URL 初始化 AVPlayerItem 的实例。（不能直接创建 AVAsset 实例来表示 HTTP 实时流中的媒体）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;&lt;#Live stream URL#&gt;];</span></span><br><span class="line"><span class="string">// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.</span></span><br><span class="line"><span class="string">self.playerItem = [AVPlayerItem playerItemWithURL:url];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 观察player item的status属性</span></span><br><span class="line"><span class="string">[playerItem addObserver:self forKeyPath:@&quot;</span>status<span class="string">&quot; options:0 context:&amp;ItemStatusContext];</span></span><br><span class="line"><span class="string">self.player = [AVPlayer playerWithPlayerItem:playerItem];</span></span><br></pre></td></tr></table></figure><p>将 AVPlayerItem实例 与 AVPlayer 实例相关联，准备播放。当准备好播放时，player item会创建 AVAsset 和 AVAssetTrack 实例，可以使用它们来检查实时流的内容。</p><p>要获取流媒体项目的持续时间，可以观察player item的duration属性。当项目准备好播放时，此属性将更新为流的正确值。</p><p>如果只是想播放直播，可以如以下代码，直接使用 URL 创建创建播放器player：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithURL:&lt;#Live stream URL#&gt;];</span><br><span class="line"><span class="comment">//观察player的status的属性</span></span><br><span class="line">[player addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;PlayerStatusContext];</span><br></pre></td></tr></table></figure><p>补充：与AVAsset和AVPlayerItem一样，初始化了播放器并不意味着它已准备好播放。你应该监听播放器的status属性，当它准备好播放时，其值会更改为 AVPlayerStatusReadyToPlay。您还可以观察 currentItem 属性以访问为流创建的播放器项目。</p><h3 id="2-2-4-URL类型的判断"><a href="#2-2-4-URL类型的判断" class="headerlink" title="2.2.4 URL类型的判断"></a>2.2.4 URL类型的判断</h3><p>如果不知道自己的 URL 类型，可以按照以下步骤操作：</p><ol><li>尝试使用 URL 初始化 AVURLAsset，然后加载它的tracks属性。如果tracks加载成功，就可以为资源创建一个AVPlayerItem实例。</li><li>如果第一步失败，则直接从 URL 创建一个 AVPlayerItem，监听其status属性来确定它是否可以播放。</li></ol><p>上面任一分支成功，最后都会得到一个player item，然后将其与播放器player关联。</p><h2 id="2-3-播放一个项目-AVPlayer"><a href="#2-3-播放一个项目-AVPlayer" class="headerlink" title="2.3 播放一个项目 AVPlayer"></a>2.3 播放一个项目 AVPlayer</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>调用播放器的play方法，即可开始播放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了简单的播放之外，还可以管理播放的各个方面，例如：</p><ul><li>设置播放头的速率和位置 （<em>播放头playhead为显示当前播放位置的那一条与时间轴垂直的线</em>）</li><li>监控播放器的播放状态（比如设置用户界面与资源的呈现状态同步）。</li></ul><h3 id="2-3-2-更改播放速度"><a href="#2-3-2-更改播放速度" class="headerlink" title="2.3.2 更改播放速度"></a>2.3.2 更改播放速度</h3><p>设置播放器的 rate 属性来更改播放速度。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aPlayer.rate = <span class="number">0.5</span>;</span><br><span class="line">aPlayer.rate = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure><ul><li>值 1.0 表示“以当前项目的自然速度播放”。</li><li>值 0.0 与暂停播放相同——也可以直接调用 <code>pause</code> 方法暂停。</li><li>当项目支持反向播放时，可以使用赋值 rate 负数来设置反向播放速度。</li></ul><p>playerItem 的几个属性，用来确定支持的反向播放类型：</p><ul><li>canPlayReverse（是否支持 -1.0 的速度值）</li><li>canPlaySlowReverse（是否支持介于 0.0 到 -1.0 之间的速度）</li><li> canPlayFastReverse（是否支持小于 -1.0 的速度值）</li></ul><h3 id="2-3-3-寻找—重新定位播放头"><a href="#2-3-3-寻找—重新定位播放头" class="headerlink" title="2.3.3 寻找—重新定位播放头"></a>2.3.3 寻找—重新定位播放头</h3><p>要将播放头移动到特定时间，可以使用以下两种方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seekToTime:方法是针对性能而不是精度进行调整的</span></span><br><span class="line"><span class="built_in">CMTime</span> fiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要精确移动播放头，使用下面的方法。[tolerance 容许偏差]</span></span><br><span class="line"><span class="built_in">CMTime</span> FiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</span><br></pre></td></tr></table></figure><p>注意：使用零容差可能需要框架解码大量数据。仅当你正在编写需要精确控制的复杂媒体编辑APP时才应使用。</p><p>播放后，播放器的头部被设置到项目的末尾，进一步调用 play 无效。要将播放头放回项目的开头，您可以注册以接收来自项目的 AVPlayerItemDidPlayToEndTimeNotification 通知。在通知的回调方法中，您使用参数 kCMTimeZero 调用 seekToTime:。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    addObserver:<span class="keyword">self</span></span><br><span class="line">    selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">    name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">    object:&lt;#The player item#&gt;];</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-播放多个项目-AVQueuePlayer"><a href="#2-4-播放多个项目-AVQueuePlayer" class="headerlink" title="2.4 播放多个项目 AVQueuePlayer"></a>2.4 播放多个项目 AVQueuePlayer</h2><p>使用 AVQueuePlayer 对象按顺序播放多个项目。 AVQueuePlayer 类是 AVPlayer 的子类。使用一个盛放player Item的数组初始化队列播放器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = &lt;#An array of player items#&gt;;</span><br><span class="line"><span class="built_in">AVQueuePlayer</span> *queuePlayer = [[<span class="built_in">AVQueuePlayer</span> alloc] initWithItems:items];</span><br><span class="line"><span class="comment">// 使用 play 播放队列，就像使用 AVPlayer 对象一样</span></span><br><span class="line">[queuePlayer paly];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列播放器依次播放每个项目。可以调用advanceToNextItem跳到下一个项目</span></span><br><span class="line">[queuePlayer advanceToNextItem];</span><br></pre></td></tr></table></figure><p>可以使用 insertItem:afterItem:、removeItem: 和 removeAllItems 修改队列。添加新项目时，应使用 canInsertItem:afterItem: 检查是否可以将其插入队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVPlayerItem</span> *anItem = &lt;#Get a player item#&gt;;</span><br><span class="line"><span class="comment">// 判断是否可以将新项目附加到队列中，第二个参数可以传 nil</span></span><br><span class="line"><span class="keyword">if</span> ([queuePlayer canInsertItem:anItem afterItem:<span class="literal">nil</span>]) &#123;</span><br><span class="line">    [queuePlayer insertItem:anItem afterItem:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-播放监听"><a href="#2-5-播放监听" class="headerlink" title="2.5 播放监听"></a>2.5 播放监听</h2><h3 id="2-5-1-使用场景"><a href="#2-5-1-使用场景" class="headerlink" title="2.5.1 使用场景"></a>2.5.1 使用场景</h3><p>可以监听播放器player的呈现状态和正在播放的播放器项目player item的许多方面。当一些不受开发者直接控制的状态更改时，这将特别有用。例如：</p><ul><li>如果用户使用多任务切换到不同的应用程序，AVPlayer的 rate 属性值将下降到 0.0。</li><li>如果正在播放远程媒体，AVPlayerItem 的 loadedTimeRanges 和 seekableTimeRanges 属性将随着更多数据可用而改变。<br>这些属性告诉您播放器项目时间线的哪些部分可用。</li><li>当为 HTTP 直播流创建 AVPlayerItem 时，AVPlayer的 currentItem 属性会发生变化。</li><li>播放 HTTP 直播流时，AVPlayerItem 的 tracks 属性可能会发生变化。（比如如果流为内容提供了不同的编码，当播放器切换到不同的编码，tracks会发生变化。）</li><li>如果由于某种原因播放失败，AVPlayer 或 AVPlayerItem 的 status 属性可能会更改。</li></ul><p>可以使用KVO来监听这些属性值的变化。<strong>注意：需要在主线程上注册、注销KVO通知。</strong></p><h3 id="2-5-2-监听status的变化"><a href="#2-5-2-监听status的变化" class="headerlink" title="2.5.2 监听status的变化"></a>2.5.2 监听status的变化</h3><p>当播放器或播放器项目的 status 发生变化时，会发出一个KVO改变通知。如果对象由于某种原因无法播放（例如，如果媒体服务被重置），则 status 将根据需要更改为 AVPlayerStatusFailed 或 AVPlayerItemStatusFailed。在这种情况下，对象的 error 属性将被赋值为一个NSError对象，描述了错误原因。</p><p>AV Foundation 没有指定发送通知的线程。如果要通知更新用户界面，则必须确保是在主线程上进行操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &lt;#Player status context#&gt;) &#123;</span><br><span class="line">        <span class="built_in">AVPlayer</span> *thePlayer = (<span class="built_in">AVPlayer</span> *)object;</span><br><span class="line">        <span class="keyword">if</span> ([thePlayer status] == <span class="built_in">AVPlayerStatusFailed</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [&lt;#The <span class="built_in">AVPlayer</span> object#&gt; error];</span><br><span class="line">            <span class="comment">// Respond to error: for example, display an alert sheet.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deal with other status change if appropriate.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Deal with other change notifications if appropriate.</span></span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-监听可视化内容的就绪状态"><a href="#2-5-3-监听可视化内容的就绪状态" class="headerlink" title="2.5.3 监听可视化内容的就绪状态"></a>2.5.3 监听可视化内容的就绪状态</h3><p>监听 AVPlayerLayer 对象的 readyForDisplay 属性，以便在图层具有用户可见内容时收到通知。特别是，当你只需要在有可视化内容时，才要将播放器图层 player layer 插入到图层树layer tree中的情况。</p><h3 id="2-5-4-监听播放时间"><a href="#2-5-4-监听播放时间" class="headerlink" title="2.5.4 监听播放时间"></a>2.5.4 监听播放时间</h3><p>使用场景：根据已播放时间或剩余时间来更新用户界面，或执行一些其他用户界面同步。</p><p>跟踪 AVPlayer 对象中播放头位置的变化，可以使用下面的两个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block会在指定的时间间隔中被调用。如果时间有跳跃，会在播放开始或者结束的时候调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval </span><br><span class="line">                                   queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                              usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个包装CMTime的NSValue数组。每当这些时间被通过时，block都会被调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addBoundaryTimeObserverForTimes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)times </span><br><span class="line">                                queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                           usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>这两种方法都返回一个作为 observer 的不透明对象。必须对其保持强引用。</li><li>必须平衡上面这两个方法与 removeTimeObserver: 的调用。</li><li>使用上面两个方法，AV Foundation 不保证在每个间隔、边界通过时都会调用block。如果先前调用的block执行尚未完成，就不会调用block。因此，您必须确保您在block中执行的工作不会对系统造成过多的负担。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume a property: @property (strong) id playerObserver;</span></span><br><span class="line"> </span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([&lt;#An asset#&gt; duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[[<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird]];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">self</span>.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:<span class="literal">NULL</span> usingBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *timeDescription = (<span class="built_in">NSString</span> *)</span><br><span class="line">        <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, [<span class="keyword">self</span>.player currentTime]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Passed a boundary at %@&quot;</span>, timeDescription);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="2-5-5-监听播放结束"><a href="#2-5-5-监听播放结束" class="headerlink" title="2.5.5 监听播放结束"></a>2.5.5 监听播放结束</h3><p>可以注册<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知来监听 player item 的播放结束.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:&lt;#The observer, typically <span class="keyword">self</span>#&gt;</span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(&lt;#The selector name#&gt;)</span><br><span class="line">                                           name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                           object:&lt;#A player item#&gt;];</span><br></pre></td></tr></table></figure><h2 id="2-6-示例：使用-AVPlayerLayer-播放视频文件"><a href="#2-6-示例：使用-AVPlayerLayer-播放视频文件" class="headerlink" title="2.6 示例：使用 AVPlayerLayer 播放视频文件"></a>2.6 示例：使用 AVPlayerLayer 播放视频文件</h2><p>这个简短的代码示例说明了如何使用 AVPlayer 对象来播放视频文件。它展示了如何：</p><ul><li>使用 AVPlayerLayer 图层去配置一个view</li><li>创建一个 AVPlayer 对象</li><li>为 file-based asset 创建一个 AVPlayerItem 对象，并使用KVO观察其status值</li><li>监听资源是否准备好播放，同步改变播放按钮的可用状态。</li><li>播放item，然后将播放头恢复到开头位置。</li></ul><blockquote><p>提示: 为了展示核心代码, 这份示例省略了某些内容, 比如内存管理和通知的移除等. 使用 AV Foundation 之前, 你最好已经拥有 Cocoa 框架的使用经验.</p></blockquote><h3 id="step1-定义-Player-View"><a href="#step1-定义-Player-View" class="headerlink" title="step1: 定义 Player View"></a>step1: 定义 Player View</h3><p>要播放一个 asset 的可视部分, 你需要一个包含<code>AVPlayerLayer</code>对象的 view, 用来接收<code>AVPlayer</code>对象的输出. 可以简单的定义一个 UIView 的子类来实现这一功能：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerView</span></span></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">AVPlayer</span>*)player &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] player];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setPlayer:(<span class="built_in">AVPlayer</span> *)player &#123;</span><br><span class="line">    [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] setPlayer:player];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="step2-配置-View-Controller"><a href="#step2-配置-View-Controller" class="headerlink" title="step2: 配置 View Controller"></a>step2: 配置 View Controller</h3><p>假设你有一个简单的视图控制器，声明如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">PlayerView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayerItem</span> *playerItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> PlayerView *playerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *playButton;</span><br><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)play:sender;</span><br><span class="line">- (<span class="keyword">void</span>)syncUI;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>syncUI 方法将按钮的状态与播放器的状态同步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)syncUI &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.player.currentItem != <span class="literal">nil</span>) &amp;&amp;</span><br><span class="line">        ([<span class="keyword">self</span>.player.currentItem status] == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 viewDidLoad 方法中就调用 syncUI 以确保在首次显示视图时用户界面一致。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> syncUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3-创建-Asset、PlayerItem、Player"><a href="#step3-创建-Asset、PlayerItem、Player" class="headerlink" title="step3: 创建 Asset、PlayerItem、Player"></a>step3: 创建 Asset、PlayerItem、Player</h3><p>使用<code>AVURLAsset</code>根据 URL 创建 asset.(下面的代码假设项目中包含了一个视频资源)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle]</span><br><span class="line">        URLForResource:&lt;#<span class="string">@&quot;VideoFileName&quot;</span>#&gt; withExtension:&lt;#<span class="string">@&quot;extension&quot;</span>#&gt;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:fileURL options:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *tracksKey = <span class="string">@&quot;tracks&quot;</span>;</span><br><span class="line"></span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:</span><br><span class="line">     ^&#123;</span><br><span class="line">         <span class="comment">// The completion block goes here.</span></span><br><span class="line">     &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 completion block 中创建 <code>AVPlayerItem</code>，并将其设置为 player view 的 player。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Completion handler block.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">  ^&#123;</span><br><span class="line">      <span class="built_in">NSError</span> *error;</span><br><span class="line">      <span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracksKey error:&amp;error];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;</span><br><span class="line">          <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">          <span class="comment">// 与创建asset一样，简单地创建PlayerItem并不意味着它可以使用。要确定它何时可以播放，需要观察其status属性。</span></span><br><span class="line">          <span class="comment">// 在 playerItem 与 player 完成关联之前，配置此监听</span></span><br><span class="line">          [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> </span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionInitial</span></span><br><span class="line">                               context:&amp;ItemStatusContext];</span><br><span class="line">          [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                   selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">                                       name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                     object:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          <span class="comment">// 将 playerItem 与 player 完成关联时，会触发 playerItem 的播放准备。</span></span><br><span class="line">          <span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          [<span class="keyword">self</span>.playerView setPlayer:<span class="keyword">self</span>.player];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// You should deal with the error appropriately.</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;The asset&#x27;s tracks were not loaded:\n%@&quot;</span>, [error localizedDescription]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="step4-响应-PlayerItem-的-status-改变"><a href="#step4-响应-PlayerItem-的-status-改变" class="headerlink" title="step4: 响应 PlayerItem 的 status 改变"></a>step4: 响应 PlayerItem 的 status 改变</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// 保证在主线程上调用了UI操作代码</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">                       ^&#123;</span><br><span class="line">                           [<span class="keyword">self</span> syncUI];</span><br><span class="line">                       &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step5-播放-Item"><a href="#step5-播放-Item" class="headerlink" title="step5: 播放 Item"></a>step5: 播放 Item</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>item 只被播放一次，播放结束后，播放点会被设置为 item 的结束点，这样下一次调用 play 方法将会失效。要将播放点设置到 item 的起始处，参考如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">        addObserver:<span class="keyword">self</span></span><br><span class="line">        selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">        name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">        object:[<span class="keyword">self</span>.player currentItem]];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span>.player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、编辑-Assets"><a href="#三、编辑-Assets" class="headerlink" title="三、编辑 Assets"></a>三、编辑 Assets</h1><p>AVFoundation 框架为音视频编辑提供了功能丰富的类集。</p><p>这些 API 的核心称为合成/组合 (compositions)。composition 是一个或多个媒体资源的 track 的集合。</p><ul><li>从现有媒体片段<ul><li>使用 compositions(组合) 从现有的媒体片段（通常是一个或多个视频和音频轨道）创建新的asset。</li><li>使用可变的 composition 来添加和删除轨道，并调整它们的时间顺序。</li><li>可以设置音轨的相对音量和渐变效果；并设置视频轨道的透明度和透明度渐变。</li><li>composition 是保存在内存中的一系列媒体片段的集合。可以通过 <em>export session</em> 将 composition 导出到文件中。</li></ul></li><li>从样本缓冲区或静止图像<ul><li>使用资产写入器(asset writer)从样本缓冲区或静止图像等媒体创建asset。</li></ul></li></ul><h2 id="3-1-Asset合成-AVMutableComposition"><a href="#3-1-Asset合成-AVMutableComposition" class="headerlink" title="3.1 Asset合成(AVMutableComposition)"></a>3.1 Asset合成(AVMutableComposition)</h2><h3 id="核心类概述"><a href="#核心类概述" class="headerlink" title="核心类概述"></a>核心类概述</h3><p>AVMutableComposition 类提供了插入和删除 track，以及管理其时间顺序的的接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> : <span class="title">AVComposition</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> naturalSize;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)composition;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)compositionWithURLAssetInitializationOptions:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)URLAssetInitializationOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//composition层面的编辑，管理时间顺序</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionCompositionLevelEditing</span>)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)insertTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange ofAsset:(<span class="built_in">AVAsset</span> *)asset atTime:(<span class="built_in">CMTime</span>)startTime error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">void</span>)insertEmptyTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)removeTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)scaleTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange toDuration:(<span class="built_in">CMTime</span>)duration;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track层面的编辑</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackLevelEditing</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向composition中添加一个新track时，必须同时提供媒体类型 (media type) 和 track ID。</span></span><br><span class="line"><span class="comment"> * @param mediaType 除了最常用的音频和视频类型，还有其他的媒体类型可以选择。比如 AVMediaTypeSubtitle(字幕)，AVMediaTypeText。</span></span><br><span class="line"><span class="comment"> * @param preferredTrackID 每个 track 都会有一个唯一的标识符 track ID(32位整数值)</span></span><br><span class="line"><span class="comment">                           如果指定 kCMPersistentTrackID_Invalid 作为 track ID，则会自动为关联的 track 自动生成一个唯一的 ID。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)addMutableTrackWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType preferredTrackID:(<span class="built_in">CMPersistentTrackID</span>)preferredTrackID;</span><br><span class="line">- (<span class="keyword">void</span>)removeTrack:(<span class="built_in">AVCompositionTrack</span> *)track;</span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)mutableTrackCompatibleWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track检查</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackInspection</span>)</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMutableCompositionTrack</span> *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>下图展示了如何通过已存在的 assets 组合成为一个 composition。</p><img src="/images/avf/avmutablecomposition_2x.png" alt="avmutablecomposition_2x" style="zoom:70%;" /><h3 id="3-1-1-创建AVMutableComposition"><a href="#3-1-1-创建AVMutableComposition" class="headerlink" title="3.1.1 创建AVMutableComposition"></a>3.1.1 创建AVMutableComposition</h3><p>先使用 AVMutableComposition 类创建一个自定义的 Composition。</p><h3 id="3-1-2-添加AVMutableCompositionTrack"><a href="#3-1-2-添加AVMutableCompositionTrack" class="headerlink" title="3.1.2 添加AVMutableCompositionTrack"></a>3.1.2 添加AVMutableCompositionTrack</h3><p>然后如果要向组合中添加媒体数据，那么需要先使用 AVMutableCompositionTrack 类在自定义的 Composition 中添加一个或多个 composition tracks。</p><p>下面是一个通过 video track 和 audio track 创建 composition 的例子:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the video composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the audio composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure><h3 id="3-1-3-向composition-track中添加AVAssetTrack"><a href="#3-1-3-向composition-track中添加AVAssetTrack" class="headerlink" title="3.1.3 向composition track中添加AVAssetTrack"></a>3.1.3 向composition track中添加AVAssetTrack</h3><h4 id="1-添加媒体数据"><a href="#1-添加媒体数据" class="headerlink" title="1. 添加媒体数据"></a>1. 添加媒体数据</h4><p>当配置好一个包含一个或多个track的composition时，就可以开始将媒体数据添加到合适的track中。</p><p>首先，需要访问媒体数据所在的<code>AVAsset</code>对象。将具有相同媒体类型的多个 track 添加到同一个 mutable composition track 中。</p><p>下面的例子说明了如何将两个不同的 video asset tracks 顺序添加到一个 composition track 中:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以从许多地方检索 AVAsset，例如相机胶卷</span></span><br><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="built_in">AVAsset</span> with at least one video track#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *anotherVideoAsset = &lt;<span class="meta">#another AVAsset with at least one video track#&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从每个 asset 中获取第一个视频轨道</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add them both to the composition.</span></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="2-检索兼容的-Composition-Tracks"><a href="#2-检索兼容的-Composition-Tracks" class="headerlink" title="2. 检索兼容的 Composition Tracks"></a>2. 检索兼容的 Composition Tracks</h4><p>如果可能的情况下，每种媒体类型都应当只有一个对之对应的 composition track，这样会降低资源的使用。当串行呈现媒体数据时，应当将相同类型的媒体数据放到同一个 composition track 中。</p><p>可以通过查询一个 mutable composition，找出是否有与 asset track 对应的 composition track.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:&lt;<span class="meta">#the AVAssetTrack you want to insert#&gt;];</span></span><br><span class="line"><span class="keyword">if</span> (compatibleCompositionTrack) &#123;</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 在同一个 composition track 添加多个视频段，可能会导致视频段之间进行切换时掉帧，嵌入式设备尤其明显。如何为 composition track 选择合适数量的视频段取决于 App 的设计以及其目标设备。</p></blockquote><h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h3><p>如果你需要顺序合并多个 asset 到一个文件中，上面的内容就已经够用了。但是如果要对合成中的 track 执行任何自定义的音视频处理操作，那么你需要分别进行音频混合、视频组合。</p><h2 id="3-2-音频混合-AVMutableAudioMix"><a href="#3-2-音频混合-AVMutableAudioMix" class="headerlink" title="3.2 音频混合(AVMutableAudioMix)"></a>3.2 音频混合(AVMutableAudioMix)</h2><h3 id="3-2-1-核心类概述"><a href="#3-2-1-核心类概述" class="headerlink" title="3.2.1 核心类概述"></a>3.2.1 核心类概述</h3><p>如下图(performs audio mixing)中所示，使用 AVMutableAudioMix 类可以对 composition 中的 audio track 进行自定义操作。你还可以指定 audio track 的最大音量或者为其设置渐变效果。</p><img src="/images/avf/avmutableaudiomix_2x.png" alt="avmutableaudiomix_2x" style="zoom:70%;" /><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMix</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMix</span> : <span class="title">AVAudioMix</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMixInputParameters</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getVolumeRampForTime:(<span class="built_in">CMTime</span>)time startVolume:(<span class="keyword">float</span> *)startVolume endVolume:(<span class="keyword">float</span> *)endVolume timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMixInputParameters</span> : <span class="title">AVAudioMixInputParameters</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParametersWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParameters;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="keyword">void</span>)setVolumeRampFromStartVolume:(<span class="keyword">float</span>)startVolume toEndVolume:(<span class="keyword">float</span>)endVolume timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setVolume:(<span class="keyword">float</span>)volume atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-示例-自定义音频处理-—-音量渐变"><a href="#3-2-2-示例-自定义音频处理-—-音量渐变" class="headerlink" title="3.2.2 示例: 自定义音频处理 — 音量渐变"></a>3.2.2 示例: 自定义音频处理 — 音量渐变</h3><p>使用一个<code>AVMutableAudioMix</code>对象就可以为 composition 中的每一个 audio tracks 单独执行自定义的音频处理操作。</p><p>下面的例子展示了如何给一个 audio track 设置音量渐变让声音有一个缓慢淡出结束的效果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类方法 audioMix 创建一个 audio mix</span></span><br><span class="line"><span class="built_in">AVMutableAudioMix</span> *mutableAudioMix = [<span class="built_in">AVMutableAudioMix</span> audioMix];</span><br><span class="line"><span class="comment">// 使用AVMutableAudioMixInputParameters设置 将音轨添加到混音时使用的参数。</span></span><br><span class="line"><span class="built_in">AVMutableAudioMixInputParameters</span> *mixParameters = [<span class="built_in">AVMutableAudioMixInputParameters</span> audioMixInputParametersWithTrack:mutableCompositionAudioTrack];</span><br><span class="line"><span class="comment">// 修改音量 Set the volume ramp, 使声音有一个缓慢淡出效果</span></span><br><span class="line">[mixParameters setVolumeRampFromStartVolume:<span class="number">1.</span>f toEndVolume:<span class="number">0.</span>f timeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration)];</span><br><span class="line"><span class="comment">// Attach the input parameters to the audio mix. </span></span><br><span class="line">mutableAudioMix.inputParameters = @[mixParameters];</span><br></pre></td></tr></table></figure><p>AVMutableAudioMixInputParameters 类的接口将 audio mix 与 composition 中特定的 track 关联起来</p><h2 id="3-3-视频合成-AVMutableVideoComposition"><a href="#3-3-视频合成-AVMutableVideoComposition" class="headerlink" title="3.3 视频合成(AVMutableVideoComposition)"></a>3.3 视频合成(AVMutableVideoComposition)</h2><h3 id="3-3-1-核心类概述"><a href="#3-3-1-核心类概述" class="headerlink" title="3.3.1 核心类概述"></a>3.3.1 核心类概述</h3><h4 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h4><p>如下图所示，使用 AVMutableVideoComposition 类可以直接处理合成中的视频 track。</p><ul><li>从一个 video composition 输出视频时，可以指定输出的尺寸、缩放比例、帧率。</li><li>AVMutableVideoCompositionInstruction (视频合成指令)，可以修改视频背景色、设置 layer 的 instructions。<ul><li>AVMutableVideoCompositionLayerInstruction (视频合成图层指令) 可以对合成中的 video track 实现transform、渐变transform、透明度、透明度渐变等效果。</li></ul></li><li>Video composition类还允许通过 <code>animationTool</code> 属性在视频中应用 Core Animation 框架的一些效果。</li></ul><img src="/images/avf/avmutablevideocomposition_2x.png" alt="avmutablevideocomposition_2x" style="zoom:70%;" /><h4 id="2-视频合成类"><a href="#2-视频合成类" class="headerlink" title="2. 视频合成类"></a>2. 视频合成类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt; </span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class&lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositorClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> frameDuration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> sourceTrackIDForFrameTiming;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> renderSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> renderScale;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositionInstruction</span>&gt;&gt; *instructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">AVVideoCompositionCoreAnimationTool</span> *animationTool;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *sourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出帧的颜色空间</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将core Image filters(滤镜)应用于指定asset的每个视频帧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line">               applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> : <span class="title">AVVideoComposition</span></span></span><br><span class="line">  <span class="comment">//.... 继承AVVideoComposition的所有属性</span></span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoComposition;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset prototypeInstruction:(<span class="built_in">AVVideoCompositionInstruction</span> *)prototypeInstruction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line"> applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-视频合成指令类"><a href="#3-视频合成指令类" class="headerlink" title="3. 视频合成指令类"></a>3. 视频合成指令类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionInstruction</span> : <span class="title">AVVideoCompositionInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>)<span class="built_in">CGColorRef</span> backgroundColor;</span><br><span class="line"><span class="comment">// 指定如何从源tracks分层、合成视频帧的指令。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCompositionLayerInstruction</span> *&gt; *layerInstructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> enablePostProcessing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *requiredSourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionLayerInstruction</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getTransformRampForTime:(<span class="built_in">CMTime</span>)time startTransform:(<span class="built_in">CGAffineTransform</span> *)startTransform endTransform:(<span class="built_in">CGAffineTransform</span> *)endTransform timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getOpacityRampForTime:(<span class="built_in">CMTime</span>)time startOpacity:(<span class="keyword">float</span> *)startOpacity endOpacity:(<span class="keyword">float</span> *)endOpacity timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getCropRectangleRampForTime:(<span class="built_in">CMTime</span>)time startCropRectangle:(<span class="built_in">CGRect</span> *)startCropRectangle endCropRectangle:(<span class="built_in">CGRect</span> *)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置transform、opacity等属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionLayerInstruction</span> : <span class="title">AVVideoCompositionLayerInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstructionWithAssetTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="keyword">void</span>)setTransformRampFromStartTransform:(<span class="built_in">CGAffineTransform</span>)startTransform toEndTransform:(<span class="built_in">CGAffineTransform</span>)endTransform timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setTransform:(<span class="built_in">CGAffineTransform</span>)transform atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacityRampFromStartOpacity:(<span class="keyword">float</span>)startOpacity toEndOpacity:(<span class="keyword">float</span>)endOpacity timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacity:(<span class="keyword">float</span>)opacity atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangleRampFromStartCropRectangle:(<span class="built_in">CGRect</span>)startCropRectangle toEndCropRectangle:(<span class="built_in">CGRect</span>)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangle:(<span class="built_in">CGRect</span>)cropRectangle atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="4-核心动画工具"><a href="#4-核心动画工具" class="headerlink" title="4. 核心动画工具"></a>4. 核心动画工具</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionCoreAnimationTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithAdditionalLayer:(<span class="built_in">CALayer</span> *)layer asTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:(<span class="built_in">CALayer</span> *)videoLayer inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">CALayer</span> *&gt; *)videoLayers inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-示例-自定义视频处理"><a href="#3-3-2-示例-自定义视频处理" class="headerlink" title="3.3.2 示例: 自定义视频处理"></a>3.3.2 示例: 自定义视频处理</h3><p>与音频混合一样，可以使用 <code>AVMutableVideoComposition</code> 对象可以对 composition 中的 video tracks 执行所有自定义处理操作。比如指定尺寸、缩放比例、以及帧率。</p><h4 id="1-设置-Composition-的背景色"><a href="#1-设置-Composition-的背景色" class="headerlink" title="1. 设置 Composition 的背景色"></a>1. 设置 Composition 的背景色</h4><p>Video compositions 必须包含一个 AVVideoCompositionInstruction 对象的数组，其中至少包含一个 video composition instruction。</p><p>使用 AVMutableVideoCompositionInstruction 可以创建自定义的视频合成指令(video composition instructions)。使用视频合成指令，来修改composition的背景颜色、指定是否需要后期处理、设置图层的指令等。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *mutableVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line">mutableVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration);</span><br><span class="line">mutableVideoCompositionInstruction.backgroundColor = [[<span class="built_in">UIColor</span> redColor] <span class="built_in">CGColor</span>];</span><br></pre></td></tr></table></figure><h4 id="2-设置-track-切换时的透明度渐变"><a href="#2-设置-track-切换时的透明度渐变" class="headerlink" title="2. 设置 track 切换时的透明度渐变"></a>2. 设置 track 切换时的透明度渐变</h4><p>AVMutableVideoCompositionLayerInstruction 可以用来设置 video track 的 transforms、transforms 渐变、opacity、opacity 渐变。</p><p>AVMutableVideoCompositionInstruction 的属性 layerInstructions 中指令的顺序，决定了在该合成指令的持续时间内，应如何对来自源 track 的视频帧进行分层和合成。</p><p>下面的代码片段展示了如何在第二个视频出现之前为第一个视频增加一个透明度淡出效果:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *firstVideoAssetTrack  = &lt;#<span class="built_in">AVAssetTrack</span> representing the first video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *secondVideoAssetTrack = &lt;#<span class="built_in">AVAssetTrack</span> representing the second video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="comment">// 创建第一个视频合成指令</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将timeRange设置为跨越第一个视频track的持续时间</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一个图层指令，然后与视频track，相关联</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不透明度渐变以在整个持续时间内淡出第一个视频轨道。</span></span><br><span class="line">[firstVideoLayerInstruction setOpacityRampFromStartOpacity:<span class="number">1.</span>f toEndOpacity:<span class="number">0.</span>f timeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个视频合成指令，使第二个视频轨道不透明</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将其时间范围设置为跨越第二个视频轨道的持续时间。</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"><span class="comment">// 创建第二个图层指令并将其与视频track相关联。</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach the first layer instruction to the first video composition instruction.</span></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line"><span class="comment">// Attach the second layer instruction to the second video composition instruction.</span></span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach both of the video composition instructions to the video composition.</span></span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure><h4 id="3-结合-Core-Animation"><a href="#3-结合-Core-Animation" class="headerlink" title="3. 结合 Core Animation"></a>3. 结合 Core Animation</h4><p>Video composition 的 animationTool 属性可以在 composition 中展示 Core Animation 框架的强大能力，例如视频水印、视频标题、动画遮罩等。</p><p>在 Video compositions 中 Core Animatio 有两种不同的使用方式：</p><ul><li>添加一个 Core Animation layer 作为独立的 composition track；</li><li>使用 Core Animation layer 将核心动画的效果直接渲染到视频帧中。</li></ul><p>下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *watermarkLayer = &lt;#<span class="built_in">CALayer</span> representing your desired watermark image#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CALayer</span> *parentLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"><span class="built_in">CALayer</span> *videoLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">parentLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">videoLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">[parentLayer addSublayer:videoLayer];</span><br><span class="line"></span><br><span class="line">watermarkLayer.position = <span class="built_in">CGPointMake</span>(mutableVideoComposition.renderSize.width/<span class="number">2</span>, mutableVideoComposition.renderSize.height/<span class="number">4</span>);</span><br><span class="line">[parentLayer addSublayer:watermarkLayer];</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.animationTool = [<span class="built_in">AVVideoCompositionCoreAnimationTool</span> videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];</span><br></pre></td></tr></table></figure><h2 id="3-4-音视频组合-AVAssetExportSession"><a href="#3-4-音视频组合-AVAssetExportSession" class="headerlink" title="3.4 音视频组合(AVAssetExportSession)"></a>3.4 音视频组合(AVAssetExportSession)</h2><p>如下图所示，要对音视频进行组合，可以使用 AVAssetExportSession。使用 composition 初始化一个 export session，然后分别其设置 <code>audioMix</code> 和 <code>videoComposition</code> 属性。</p><img src="/images/avf/puttingitalltogether_2x.png" style="zoom:70%;" /><h2 id="3-5-示例-多个asset的合成与导出"><a href="#3-5-示例-多个asset的合成与导出" class="headerlink" title="3.5 示例: 多个asset的合成与导出"></a>3.5 示例: 多个asset的合成与导出</h2><p>下面的代码简要的展示了如何合并两个 video asset tracks 和一个 audio asset track 为一个视频文件。 包括:</p><ul><li>创建 AVMutableComposition 对象, 并添加多个 AVMutableCompositionTrack 对象</li><li>在 composition tracks 中添加 AVAssetTrack 对象的时间范围</li><li>检查 video asset track 的 preferredTransform 属性，判断视频方向</li><li>使用 AVMutableVideoCompositionLayerInstruction 对象进行 transform 变换</li><li>设置 video composition 的 renderSize 和 frameDuration 属性</li><li>导出视频文件</li><li>保存视频文件到相册</li></ul><blockquote><p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p></blockquote><h3 id="1-创建-Composition"><a href="#1-创建-Composition" class="headerlink" title="1. 创建 Composition"></a>1. 创建 Composition</h3><p>使用<code>AVMutableComposition</code>对象组合多个 assets 中的 tracks。下面的代码创建了一个 composition，并向其添加了一个 audio track 和一个 video track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure><h3 id="2-添加-Assets"><a href="#2-添加-Assets" class="headerlink" title="2. 添加 Assets"></a>2. 添加 Assets</h3><p>向 composition 添加两个 video asset tracks 和一个 audio asset track。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAssetTrack</span> *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)</span><br><span class="line">                               ofTrack: firstVideoAssetTrack </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) </span><br><span class="line">                               ofTrack: secondVideoAssetTrack </span><br><span class="line">                                atTime: firstVideoAssetTrack.timeRange.duration </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[audioCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) </span><br><span class="line">                               ofTrack: [[audioAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>] </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h3 id="3-判断视频方向"><a href="#3-判断视频方向" class="headerlink" title="3. 判断视频方向"></a>3. 判断视频方向</h3><p>一旦在 composition 中添加了 audio tracks 和 videotracks，必须确保其中所有的 video tracks 的视频方向都是正确的。</p><p>默认情况下，video tracks 默认为横屏模式，如果 video track 是在竖屏模式下采集的，那么导出视频时会出现方向错误。同理，也不能将一个横向的视频和一个纵向的视频进行合并后导出。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isFirstVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> firstTransform = firstVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="comment">// 对比video track的preferredTransform，判断是否以纵向模式录制。</span></span><br><span class="line"><span class="keyword">if</span> (firstTransform.a == <span class="number">0</span> &amp;&amp; firstTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (firstTransform.b == <span class="number">1.0</span> || firstTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (firstTransform.c == <span class="number">1.0</span> || firstTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isFirstVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> isSecondVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> secondTransform = secondVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="keyword">if</span> (secondTransform.a == <span class="number">0</span> &amp;&amp; secondTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (secondTransform.b == <span class="number">1.0</span> || secondTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (secondTransform.c == <span class="number">1.0</span> || secondTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isSecondVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) || </span><br><span class="line">    (!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *incompatibleVideoOrientationAlert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;Error!&quot;</span> message:<span class="string">@&quot;Cannot combine a video shot in portrait mode with a video shot in landscape mode.&quot;</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@&quot;Dismiss&quot;</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [incompatibleVideoOrientationAlert show];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 <code>AVAssetTrack</code> 对象都有一个 <code>preferredTransform</code> 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面一节的代码中，会将 layer instruction 的 transform 设置为 asset track 的 transform，这样便于修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。</p><h3 id="4-设置视频合成图层指令"><a href="#4-设置视频合成图层指令" class="headerlink" title="4. 设置视频合成图层指令"></a>4. 设置视频合成图层指令</h3><p>一旦确认了视频方向，就可以对每个视频设置必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中去.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将第一个图层指令的时间范围设置为跨越第一个视频轨道的持续时间。</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> * secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 将第一个video track的首选transform 赋值给 第一个图层指令的transform</span></span><br><span class="line">Set the transform of the first layer instruction to the preferred transform of the first video track.</span><br><span class="line">[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];</span><br><span class="line"></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure><h3 id="5-设置渲染尺寸和帧率"><a href="#5-设置渲染尺寸和帧率" class="headerlink" title="5. 设置渲染尺寸和帧率"></a>5. 设置渲染尺寸和帧率</h3><p>要修正视频方向，还必须对 renderSize 属性进行调整。同时也需要设置一个合理的帧持续时间 frameDuration，比如 1/30 秒(30FPS)。默认情况下，renderScale 值为 1.0。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> naturalSizeFirst, naturalSizeSecond;</span><br><span class="line"><span class="comment">// 如果第一个视频资源是在纵向模式下拍摄的，那么如果我们在这里制作第二个视频资源也是如此。</span></span><br><span class="line"><span class="keyword">if</span> (isFirstVideoAssetPortrait) &#123;</span><br><span class="line">    <span class="comment">// 反转video track的宽度和高度以确保它们正确显示。</span></span><br><span class="line">    naturalSizeFirst = <span class="built_in">CGSizeMake</span>(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);</span><br><span class="line">    naturalSizeSecond = <span class="built_in">CGSizeMake</span>(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果视频不是以纵向模式拍摄的，我们可以使用它们的自然尺寸。</span></span><br><span class="line">    naturalSizeFirst = firstVideoAssetTrack.naturalSize;</span><br><span class="line">    naturalSizeSecond = secondVideoAssetTrack.naturalSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> renderWidth, renderHeight;</span><br><span class="line"><span class="comment">// 将 renderWidth 和 renderHeight 设置为两个视频宽度和高度的最大值。</span></span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.width &gt; naturalSizeSecond.width) &#123;</span><br><span class="line">    renderWidth = naturalSizeFirst.width;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderWidth = naturalSizeSecond.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.height &gt; naturalSizeSecond.height) &#123;</span><br><span class="line">    renderHeight = naturalSizeFirst.height;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderHeight = naturalSizeSecond.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.renderSize = <span class="built_in">CGSizeMake</span>(renderWidth, renderHeight);</span><br><span class="line"><span class="comment">// 将帧持续时间设置为适当的值（每秒30帧）</span></span><br><span class="line">mutableVideoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="6-导出-Composition"><a href="#6-导出-Composition" class="headerlink" title="6. 导出 Composition"></a>6. 导出 Composition</h3><p>最后一步是导出 composition 到一个视频文件中，并将视频文件保存到用户相册中。使用 AVAssetExportSession 创建一个新的视频文件，并指定要输出的文件目录的 URL。使用 ALAssetsLibrary 可以将生成的视频文件保存到用户相册中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个staic dataFormatter</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *kDateFormatter;</span><br><span class="line"><span class="keyword">if</span> (!kDateFormatter) &#123;</span><br><span class="line">    kDateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    kDateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;</span><br><span class="line">    kDateFormatter.timeStyle = <span class="built_in">NSDateFormatterShortStyle</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 composition 创建导出会话，并将预设preset设置为最高质量。</span></span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc] initWithAsset:mutableComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];</span><br><span class="line"><span class="comment">// 设置输出URL</span></span><br><span class="line">exporter.outputURL = [[[[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:@YES error:<span class="literal">nil</span>] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]]] URLByAppendingPathExtension:<span class="built_in">CFBridgingRelease</span>(UTTypeCopyPreferredTagWithClass((<span class="built_in">CFStringRef</span>)<span class="built_in">AVFileTypeQuickTimeMovie</span>, kUTTagClassFilenameExtension))];</span><br><span class="line"><span class="comment">// 设置输出文件类型为 QuickTime movie.</span></span><br><span class="line">exporter.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line">exporter.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;</span><br><span class="line">exporter.videoComposition = mutableVideoComposition;</span><br><span class="line"><span class="comment">// 异步导出composition到一个视频文件，导出完成后，保存到相机胶卷</span></span><br><span class="line">[exporter exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];</span><br><span class="line">            <span class="keyword">if</span> ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) &#123;</span><br><span class="line">                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:<span class="literal">NULL</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="四、静态图片和视频捕捉"><a href="#四、静态图片和视频捕捉" class="headerlink" title="四、静态图片和视频捕捉"></a>四、静态图片和视频捕捉</h1><h2 id="核心类概述-1"><a href="#核心类概述-1" class="headerlink" title="核心类概述"></a>核心类概述</h2><p>通过输入 (inputs) 和输出 (outputs) 对象对设备 (比如摄像头或麦克风) 采集到的数据进行管理。使用 AVCaptureSession 对象协调 inputs 和 outputs 之间的数据流。</p><ul><li>AVCaptureDevice 代表输入设备，比如摄像头和麦克风。</li><li>AVCaptureInput 的子类用来对输入设备进行配置。</li><li>AVCaptureOutput 的子类用来管理输出的数据（输出结果为图片或者视频）。</li><li>AVCaptureSession 用来协调 inputs 和 outputs 之间的数据流<ul><li>可以为单个session配置多个输入和输出，即使这个会话正在运行时也可以。</li><li>可以向会话发送消息以启动和停止数据流。</li></ul></li><li>AVCaptureVideoPreviewLayer预览图层(CALayer 的子类)，可以展示摄像头正在采集的画面预览。</li></ul><p>对于一个 session，可以配置多个 inputs 和 outputs，如图所示：</p><img src="/images/avf/captureOverview_2x.png" alt="captureOverview_2x" style="zoom:70%;" /><p>对于大部分的应用而言，这已经足够了。但是有些情况下，会涉及到如何表示一个 inputs 的多个端口 (ports)，以及这些 ports 如何连接到 outputs。</p><p>Capture session 中：</p><ul><li>一个 Inputs(AVCaptureInput实例) 包含一个或多个 input ports(AVCaptureInputPort)。比如输入设备可能同时提供音频和视频数据。</li><li>一个 Outputs(AVCaptureOutput实例) 可以从一个或多个源接收数据，比如 AVCaptureMovieFileOutput 可以同时接收视频和音频数据。</li><li>使用 AVCaptureConnection 对象来定义一组 AVCaptureInputPort 对象和单个 AVCaptureOutput 之间的映射。</li></ul><p>如下图所示，当在 session 中添加一个 input 或 output 时，session 会为所有可匹配的 inputs 和 outputs 之前生成 connections(AVCaptureConnection)。</p><img src="/images/avf/captureDetail_2x.png" alt="captureDetail_2x" style="zoom:70%;" /><p>可以使用一个 connection 来开启或关闭一个 input 或 output 数据流。也可以使用 connection 监控一个 audio 频道的功率平均值和峰值。</p><blockquote><p>注意：媒体捕获不支持同时使用呢 iOS 设备上的前置和后置摄像头捕获。</p></blockquote><h2 id="4-1-使用AVCaptureSession协调数据流"><a href="#4-1-使用AVCaptureSession协调数据流" class="headerlink" title="4.1 使用AVCaptureSession协调数据流"></a>4.1 使用AVCaptureSession协调数据流</h2><p>AVCaptureSession 对象是管理数据捕获的中央协调对象，协调从输入设备到输出的数据流。</p><h3 id="4-1-1-AVCaptureSession-类"><a href="#4-1-1-AVCaptureSession-类" class="headerlink" title="4.1.1 AVCaptureSession 类"></a>4.1.1 AVCaptureSession 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureSession</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canSetSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVCaptureSessionPreset</span> sessionPreset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureInput</span> *&gt; *inputs; <span class="comment">//__kindof表示可以是当前类或子类</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)removeInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ouputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)removeOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addInputWithNoConnections:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addOutputWithNoConnections:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connections 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *connections;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)addConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)removeConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置Capture Session</span></span><br><span class="line">- (<span class="keyword">void</span>)beginConfiguration;</span><br><span class="line">- (<span class="keyword">void</span>)commitConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isRunning) <span class="built_in">BOOL</span> running;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isInterrupted) <span class="built_in">BOOL</span> interrupted;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usesApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresCaptureDeviceForWideColor;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startRunning;</span><br><span class="line">- (<span class="keyword">void</span>)stopRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> masterClock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 session 中添加采集设备并对 output 进行配置之后，可以向 session 发送 startRunning 消息开始采集, 发送 stopRunning 消息停止采集。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line"><span class="comment">// Add inputs and outputs.</span></span><br><span class="line">[session startRunning];</span><br></pre></td></tr></table></figure><h3 id="4-1-2-配置-Capture-Session"><a href="#4-1-2-配置-Capture-Session" class="headerlink" title="4.1.2 配置 Capture Session"></a>4.1.2 配置 Capture Session</h3><p>使用 session 的 <code>sessionPreset</code> 属性指定图片质量和分辨率，perset是一个常数，系统定义了多种配置，需注意，有些配置只有在特定设备上才生效。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSessionPresetHigh</span>      <span class="comment">// 最高级别, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetMedium</span>    <span class="comment">// 中等, 适合 Wi-Fi 分享. 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetLow</span>       <span class="comment">// 低, 适合 3G 分享, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset640x480</span>   <span class="comment">// 640x480, VGA</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset1280x720</span>  <span class="comment">// 1280x720, 720p HD</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetPhoto</span>     <span class="comment">// 全屏照片, 不能用来作为输出视频</span></span><br></pre></td></tr></table></figure><p>在设置一个 preset 之前，需要判断设备是否支持该 preset 值:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要设置一个更高分辨率的 preset，或者在 session 运行时修改一些配置，需要在 beginConfiguration 和 commitConfiguration 之间完成修改。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an existing capture device.移除一个采集设备</span></span><br><span class="line"><span class="comment">// Add a new capture device.         添加一个采集设备</span></span><br><span class="line"><span class="comment">// Reset the preset.                 修改sessionPreset属性</span></span><br><span class="line"><span class="comment">// 单独配置 input 和 output 的属性</span></span><br><span class="line"></span><br><span class="line">[session commitConfiguration]; <span class="comment">// 在调用commitConfiguration 方法之后，改变会一起生效。</span></span><br></pre></td></tr></table></figure><p>beginConfiguration 和 commitConfiguration 方法确保所有的修改作为一个group被整体应用，减少对预览状态的影响。</p><h3 id="4-1-3-监听-Capture-Session-的状态"><a href="#4-1-3-监听-Capture-Session-的状态" class="headerlink" title="4.1.3 监听 Capture Session 的状态"></a>4.1.3 监听 Capture Session 的状态</h3><p>可以监听 session 的状态，例如何时开始运行、停止运行、被中断等。</p><ul><li>当发生运行时错误，会发送 AVCaptureSessionRuntimeErrorNotification 通知。</li><li>可以使用Session的<code>running</code>属性判断当前的运行状态，<code>interrupted</code>属性则可以判断当前是否中断。这两者都可以通过 KVO 进行监听，并且通知都在主线程中发送。</li></ul><h3 id="4-1-4-补充-AVCaptureConnection-类"><a href="#4-1-4-补充-AVCaptureConnection-类" class="headerlink" title="4.1.4 补充: AVCaptureConnection 类"></a>4.1.4 补充: AVCaptureConnection 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureConnection</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *inputPorts;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureOutput</span> *output;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoPreviewLayer</span> *videoPreviewLayer;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> active;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureAudioChannel</span> *&gt; *audioChannels;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mirroring镜像</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoMirroring;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> videoMirrored;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyAdjustsVideoMirroring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持更改方向</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoOrientation;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoOrientation</span> videoOrientation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示应如何处理流经过connect的隔行扫描的视频</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoFieldMode;   </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVVideoFieldMode</span> videoFieldMode; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频最大的尺寸和裁剪因子</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> videoMaxScaleAndCropFactor;</span><br><span class="line"><span class="comment">// 此属性仅适用于涉及视频的连接。可以将此属性设置为介于 1.0 到 videoMaxScaleAndCropFactor 值之间的值。以1.0为因子，图像是其原始大小。系数大于 1.0 时，图像按系数缩放并中心裁剪为其原始尺寸。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> videoScaleAndCropFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定模式。此属性仅适用于涉及视频的 AVCaptureConnection 实例。启用视频稳定会在视频捕获管道中引入额外的延迟，并且可能会消耗更多的系统内存，具体取决于稳定模式和格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoStabilization;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> preferredVideoStabilizationMode;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> activeVideoStabilizationMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置捕获管道以传递相机内在信息(如成像参数等)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliverySupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliveryEnabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="4-2-使用AVCaptureDevice表示输入设备"><a href="#4-2-使用AVCaptureDevice表示输入设备" class="headerlink" title="4.2 使用AVCaptureDevice表示输入设备"></a>4.2 使用AVCaptureDevice表示输入设备</h2><p><a href="https://developer.apple.com/reference/avfoundation/avcapturedevice">AVCaptureDevice</a> 是对实际的物理捕捉设备的抽象，物体捕捉设备向 <code>AVCaptureSession</code> 提供数据。每个 <code>AVCaptureDevice</code> 对象代表一个实际的输入设备，例如前摄像头或后摄像头、或麦克风。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 获取当前可用的捕捉设备，而且可以获取捕捉设备的设备特性</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devices API_DEPRECATED(<span class="string">&quot;Use AVCaptureDeviceDiscoverySession instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 找出对应类型的可用设备</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devicesWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">AVCaptureDevice</span> *)defaultDeviceWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">                                                       </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceDiscoverySession</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *devices;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>当前的可用设备的状态可能会发生改变：</p><ul><li>当前使用的输入设备可能会变为不可用状态 (如果设备被另外一个应用使用)；</li><li>也可能会有新的设备变为可用状态 (被其他应用释放)。</li></ul><p>注册接收 <code>AVCaptureDeviceWasConnectedNotification</code> 和 <code>AVCaptureDeviceWasDisconnectedNotification</code> 通知可以得知可用设备列表的变化。</p><p>使用捕捉输入(AVCaptureInput)将输入设备添加到 capture session 中。</p><h3 id="4-2-1-设备特性"><a href="#4-2-1-设备特性" class="headerlink" title="4.2.1 设备特性"></a>4.2.1 设备特性</h3><p>可以获取一个设备的设备特性，比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个可用的捕获设备都有一个唯一的 ID</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *uniqueID;</span><br><span class="line"><span class="comment">// 型号ID，同一型号的所有设备具有相同的、唯一的标识符。例如，两个相同的iPhone机型内置的摄像头的型号ID将是相同的。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *modelID;</span><br><span class="line"><span class="comment">// 本地化、人类可读的名称。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *localizedName;</span><br><span class="line"><span class="comment">// 制造商名称</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *manufacturer;</span><br><span class="line"><span class="comment">// 传输类型(e.g. USB, PCI, etc).</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int32_t transportType;</span><br><span class="line"><span class="comment">// 设备是否能捕捉 给定类型的媒体。如是否能采集音频、视频等</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="comment">// 设备是否可以在使用给定预设配置的capture Session中使用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)supportsAVCaptureSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br></pre></td></tr></table></figure><p>当要提供一个可用的捕捉设备列表给用户进行选择时，获取展示出设备的位置以及名称 (比如前摄像头或后摄像头) 拥有更好的用户体验。</p><p>下图展示了前摄像头 (<code>AVCaptureDevicePositionFront</code>) 和后摄像头 (<code>AVCaptureDevicePositionBack</code>):</p><blockquote><p>注意：媒体捕获不支持同时捕获 iOS 设备上的前置和后置摄像头。</p></blockquote><img src="/images/avf/cameras_2x.png" alt="img" style="zoom:70%;" /><p>下面的代码遍历了所有的可用设备并打印其名称，如果是视频设备，则打印其位置:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devices];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Device name: %@&quot;</span>, [device localizedName]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([device hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ([device position] == <span class="built_in">AVCaptureDevicePositionBack</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : front&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还可以获取设备的 model ID 以及 unique ID。</p><h3 id="4-2-2-设备捕捉时的参数设置"><a href="#4-2-2-设备捕捉时的参数设置" class="headerlink" title="4.2.2 设备捕捉时的参数设置"></a>4.2.2 设备捕捉时的参数设置</h3><p>不同的设备之间具备不同的能力，比如一些设备支持不同的对焦或闪光灯模式，某些设备还支持兴趣点对焦。</p><p>下面的代码示例了如何找出一个具有手电筒模式和并支持给定capture session preset 的视频输入设备：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *torchDevices = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line">    [<span class="keyword">if</span> ([device hasTorch] &amp;&amp;</span><br><span class="line">         [device supportsAVCaptureSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) &#123;</span><br><span class="line">        [torchDevices addObject:device];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到了多个符合要求的设备，你可能需要让用户选择其中的某一个设备，这时可以使用 localizedName 属性获取设备的描述信息.</p><p>可以用类似的方式实现各种不同的捕捉设置。框架预定义了一些常量用来代表特定的捕捉模式，你可以使用这些常量以便于判断设备是否支持特定的模式。</p><p>在大部分情况下，可以通过属性值的监听，获悉设备特性的变化。</p><p>任何情况下，在改变设备的捕捉参数配置之前，都应该先锁定设备，详见下节设备的配置。</p><blockquote><p>兴趣点对焦模式和兴趣点曝光模式是互斥的，正如对焦模式和曝光模式也是互斥的一样</p></blockquote><h4 id="1-对焦模式-Focus分类"><a href="#1-对焦模式-Focus分类" class="headerlink" title="1. 对焦模式(Focus分类)"></a>1. 对焦模式(Focus分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFocus</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> lockingFocusWithCustomLensPositionSupported;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的对焦模式，然后设置属性 focusMode 改变对焦模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFocusModeSupported:(<span class="built_in">AVCaptureFocusMode</span>)focusMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 三种对焦模式：</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeLocked: 固定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeAutoFocus: 自动对焦然后锁定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeContinuousAutoFocus: 根据需要连续自动对焦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFocusMode</span> focusMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点对焦模式. 通过下面方法判断是否支持该模式, 然后使用属性 focusPointOfInterest 设置焦点. </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> focusPointOfInterestSupported;</span><br><span class="line"><span class="comment">// 赋值CGPoint。无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> focusPointOfInterest;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在对焦中。可以使用 KVO 监听该属性获取对焦开始与结束的通知。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingFocus;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> autoFocusRangeRestrictionSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureAutoFocusRangeRestriction</span> autoFocusRangeRestriction;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> smoothAutoFocusSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> smoothAutoFocusEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensPosition;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureLensPositionCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setFocusModeLockedWithLensPosition:(<span class="keyword">float</span>)lensPosition completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> minimumFocusDistance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置对焦模式的示例代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isFocusModeSupported:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> autofocusPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setFocusPointOfInterest:autofocusPoint];</span><br><span class="line">    [currentDevice setFocusMode:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-曝光模式-Exposure分类"><a href="#2-曝光模式-Exposure分类" class="headerlink" title="2. 曝光模式(Exposure分类)"></a>2. 曝光模式(Exposure分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceExposure</span>)</span></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的曝光模式，然后设置属性 exposureMode 改变曝光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExposureModeSupported:(<span class="built_in">AVCaptureExposureMode</span>)exposureMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 两种曝光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeContinuousAutoExposure: 自动调整曝光等级</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeLocked: 固定曝光等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureExposureMode</span> exposureMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点曝光模式. 通过下面的方法判断是否支持该模式, 然后使用属性 exposurePointOfInterest 设置曝光点.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exposurePointOfInterestSupported;</span><br><span class="line"><span class="comment">// 无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> exposurePointOfInterest;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> activeMaxExposureDuration;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在改变曝光设置中. 可以使用 KVO 监听该属性获取开始设置曝光模式与结束设置曝光模式的通知.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingExposure;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensAperture;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> exposureDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> ISO;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CMTime</span> <span class="built_in">AVCaptureExposureDurationCurrent</span>;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureISOCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureModeCustomWithDuration:(<span class="built_in">CMTime</span>)duration ISO:(<span class="keyword">float</span>)ISO completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetOffset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> minExposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> maxExposureTargetBias;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureExposureTargetBiasCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureTargetBias:(<span class="keyword">float</span>)bias completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置曝光模式的示例代码如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isExposureModeSupported:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> exposurePoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setExposurePointOfInterest:exposurePoint];</span><br><span class="line">    [currentDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-闪光模式-Flash分类"><a href="#3-闪光模式-Flash分类" class="headerlink" title="3. 闪光模式(Flash分类)"></a>3. 闪光模式(Flash分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFlash</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasFlash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashAvailable) <span class="built_in">BOOL</span> flashAvailable API_AVAILABLE(macos(<span class="number">10.15</span>), ios(<span class="number">5.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashActive) <span class="built_in">BOOL</span> flashActive API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -isFlashScene instead.&quot;</span>, ios(<span class="number">5.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(macos) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="comment">// 判断是否支持某个闪光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFlashModeSupported:(<span class="built_in">AVCaptureFlashMode</span>)flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -supportedFlashModes instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置闪光灯模式</span></span><br><span class="line"><span class="comment"> 三种闪光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeAuto: 根据环境亮度自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFlashMode</span> flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoSettings.flashMode instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="4-手电筒模式-Torch分类"><a href="#4-手电筒模式-Torch分类" class="headerlink" title="4. 手电筒模式(Torch分类)"></a>4. 手电筒模式(Torch分类)</h4><p>手电筒模式下，闪光灯会一直处于开启状态，用于视频捕捉。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceTorch</span>)</span></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasTorch;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> torchLevel;</span><br><span class="line"><span class="comment">// 判断是否支持某个手电筒模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTorchModeSupported:(<span class="built_in">AVCaptureTorchMode</span>)torchMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置手电筒模式，三种手电筒模式:</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeAuto: 根据需要自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureTorchMode</span> torchMode;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setTorchModeOnWithLevel:(<span class="keyword">float</span>)torchLevel error:(<span class="built_in">NSError</span> ** _Nullable)outError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于一个有手电筒的设备，手电筒只有在设备与一个运行中的 capture session 进行了关联后才可以设置为开启。</p><h4 id="5-白平衡-WhiteBalance分类"><a href="#5-白平衡-WhiteBalance分类" class="headerlink" title="5. 白平衡(WhiteBalance分类)"></a>5. 白平衡(WhiteBalance分类)</h4><p>有两种白平衡模式:</p><ul><li><code>AVCaptureWhiteBalanceModeLocked</code>: 固定参数的白平衡</li><li><code>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance</code>: 由相机自动调整白平衡参数</li></ul><p>使用方法 isWhiteBalanceModeSupported: 判断设备是否支持给定的白平衡模式，然后通过属性 whiteBalanceMode 设置白平衡模式。</p><p>使用属性 adjustingWhiteBalance 判断当前是否正在修改白平衡模式。可以使用 KVO 监听该属性获取开始设置白平衡模式与结束设置白平衡模式的通知。</p><h4 id="6-视频稳定性-AVCaptureConnection"><a href="#6-视频稳定性-AVCaptureConnection" class="headerlink" title="6. 视频稳定性(AVCaptureConnection)"></a>6. 视频稳定性(AVCaptureConnection)</h4><p>依赖于某些特殊的硬件设备，视频会有更好的稳定性。但并不支持所有的视频格式和分辨率。</p><p>开启电影视频稳定性特性在捕捉视频时可能会增加延迟。</p><p>使用属性 videoStabilizationEnabled 可以判断当前是否使用了视频稳定性特性。</p><p>属性 enablesVideoStabilizationWhenAvailable 可以在设备支持的情况下自动开启视频稳定性特性，该属性默认为关闭状态。</p><h4 id="7-设置设备方向-AVCaptureConnection"><a href="#7-设置设备方向-AVCaptureConnection" class="headerlink" title="7. 设置设备方向(AVCaptureConnection)"></a>7. 设置设备方向(AVCaptureConnection)</h4><p>可以在<code>AVCaptureConnection</code>上指定期望的设备方向，用来设置输出时<code>AVCaptureOutput</code>(<code>AVCaptureMovieFileOutput</code>、<code>AVCaptureStillImageOutput</code>和<code>AVCaptureVideoDataOutput</code>) 的设备方向。</p><p>使用属性<code>AVCaptureConnectionsupportsVideoOrientation</code>判断设备是否支持修改视频方向，使用属性<code>videoOrientation</code>指定一个方向。下面的代码将<code>AVCaptureConnection</code>的方向设置为<code>AVCaptureVideoOrientationLandscapeLeft</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *captureConnection = &lt;#A capture connection#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureConnection isVideoOrientationSupported]) &#123;</span><br><span class="line">    <span class="built_in">AVCaptureVideoOrientation</span> orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>;</span><br><span class="line">    [captureConnection setVideoOrientation:orientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-设备配置"><a href="#4-2-3-设备配置" class="headerlink" title="4.2.3 设备配置"></a>4.2.3 设备配置</h3><p>要修改设备的捕捉参数相关的属性，首先需要使用方法 <a href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1387810-lockforconfiguration">lockForConfiguration:</a> 锁定设备，这样可以避免与其他应用的设置产生冲突。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeLocked</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">        device.focusMode = <span class="built_in">AVCaptureFocusModeLocked</span>;</span><br><span class="line">        [device unlockForConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Respond to the failure as appropriate.</span></span><br></pre></td></tr></table></figure><p>只有当你需要设备属性保持不变时，您应该保持设备锁定。不必要地保持设备锁定可能会降低共享设备的其他应用程序的捕获质量。</p><h3 id="4-2-4-切换设备"><a href="#4-2-4-切换设备" class="headerlink" title="4.2.4 切换设备"></a>4.2.4 切换设备</h3><p>某些场景下可能需要允许用户切换输入设备，比如前后摄像头。为了避免卡顿，可以重新配置正在运行的 session，使用 <a href="https://developer.apple.com/reference/avfoundation/avcapturesession/1389174-beginconfiguration">beginConfiguration</a> 和 <a href="https://developer.apple.com/reference/avfoundation/avcapturesession/1388173-commitconfiguration">commitConfiguration</a> 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = &lt;#A capture session#&gt;;</span><br><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line">[session removeInput:frontFacingCameraDeviceInput];</span><br><span class="line">[session addInput:backFacingCameraDeviceInput];</span><br><span class="line"></span><br><span class="line">[session commitConfiguration];</span><br></pre></td></tr></table></figure><p>当最后的<code>commitConfiguration</code>方法被调用时，所有的设置变化会一起执行，确保了切换的流畅性.</p><h2 id="4-3-使用AVCaptureInput添加输入设备"><a href="#4-3-使用AVCaptureInput添加输入设备" class="headerlink" title="4.3 使用AVCaptureInput添加输入设备"></a>4.3 使用AVCaptureInput添加输入设备</h2><p>要把一个 capture device 添加到 capture session 中，需要使用 AVCaptureDeviceInput(抽象类<code>AVCaptureInput</code>的子类)。</p><p>Capture device input 管理设备的端口。</p><h3 id="4-3-1-AVCaptureInput-与-Port"><a href="#4-3-1-AVCaptureInput-与-Port" class="headerlink" title="4.3.1 AVCaptureInput 与 Port"></a>4.3.1 AVCaptureInput 与 Port</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInputPort</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureInput</span> *input;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> formatDescription;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> clock;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDeviceType</span> sourceDeviceType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDevicePosition</span> sourceDevicePosition;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *ports;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceInput</span> : <span class="title">AVCaptureInput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)deviceInputWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>)<span class="built_in">AVCaptureDevice</span> *device;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> unifiedAutoExposureDefaultsEnabled;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)portsWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType </span><br><span class="line">                     sourceDeviceType:(<span class="built_in">AVCaptureDeviceType</span>)sourceDeviceType </span><br><span class="line">                 sourceDevicePosition:(<span class="built_in">AVCaptureDevicePosition</span>)sourceDevicePosition;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> videoMinFrameDurationOverride;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-3-2-添加输入设备-AVCaptureSession"><a href="#4-3-2-添加输入设备-AVCaptureSession" class="headerlink" title="4.3.2 添加输入设备(AVCaptureSession)"></a>4.3.2 添加输入设备(AVCaptureSession)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!input) &#123;</span><br><span class="line">    <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 addInput: 添加输入，使用 canAddInput: 判断该设备是否可以被添加到 session 中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *captureDeviceInput = &lt;#Get a capture device input#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddInput:captureDeviceInput]) &#123;</span><br><span class="line">    [captureSession addInput:captureDeviceInput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>AVCaptureInput</code>对象包含一个或多个数据流。例如，输入设备可能同时提供音频和视频数据。</p><p>每个 AVCaptureInputPort 对象代表一个媒体数据流。</p><p>Capture session 使用一个<code>AVCaptureConnection</code> 对象定义一组 <code>AVCaptureInputPort</code> 和一个 <code>AVCaptureOutput</code> 之间的映射关系。</p><h2 id="4-4-使用AVCaptureOutput输出数据"><a href="#4-4-使用AVCaptureOutput输出数据" class="headerlink" title="4.4 使用AVCaptureOutput输出数据"></a>4.4 使用AVCaptureOutput输出数据</h2><p>要从 capture session 中输出数据，可以向其添加一个或多个 outputs(AVCaptureOutput 的子类)，比如:</p><ul><li>AVCaptureFileOutput: 输出为文件</li><li>AVCaptureMovieFileOutput 电影文件<ul><li>AVCaptureAudioFileOutput 音频文件</li></ul></li><li>AVCaptureVideoDataOutput: 可以逐帧处理捕捉到的视频</li><li>AVCaptureAudioDataOutput: 可以处理捕捉到的音频数据</li><li>AVCaptureStillImageOutput: 输出为静态图片</li><li>…等</li></ul><p>使用方法 addOutput: 在 capture session 中添加 outputs。使用方法 canAddOutput: 判断是否可以添加一个给定的 output。可以根据需要在 session 运行过程中添加或移除一个 output。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *movieOutput = &lt;#Create and configure a movie output#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddOutput:movieOutput]) &#123;</span><br><span class="line">    [captureSession addOutput:movieOutput];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-1-输出为视频文件-AVCaptureFileOutput"><a href="#4-4-1-输出为视频文件-AVCaptureFileOutput" class="headerlink" title="4.4.1 输出为视频文件(AVCaptureFileOutput)"></a>4.4.1 输出为视频文件(AVCaptureFileOutput)</h3><p>使用 AVCaptureMovieFileOutput 将视频数据保存为一个本地文件（AVCaptureMovieFileOutput 是 AVCaptureFileOutput 的一个具体子类，它定义了许多基本行为）。</p><h4 id="1-三个输出文件类"><a href="#1-三个输出文件类" class="headerlink" title="1. 三个输出文件类"></a>1. 三个输出文件类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureFileOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputDelegate</span>&gt; delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputFileURL;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line">- (<span class="keyword">void</span>)stopRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recordingPaused __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)pauseRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)resumeRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> recordedDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int64_t recordedFileSize;</span><br><span class="line"><span class="comment">// 最大录制时长</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> maxRecordedDuration;  </span><br><span class="line"><span class="comment">// 最大的录制文件大小</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t maxRecordedFileSize;</span><br><span class="line"><span class="comment">// 磁盘应保持的最低容量。当达到限制时停止录制，并且调用 captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error: 委托方法，传出错误。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t minFreeDiskSpaceLimit;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为视频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureMovieFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> movieFragmentInterval;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedOutputSettingsKeysForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettingsForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">BOOL</span>)recordsVideoOrientationAndMirroringChangesAsMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setRecordsVideoOrientationAndMirroringChanges:(<span class="built_in">BOOL</span>)doRecordChanges asMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isPrimaryConstituentDeviceSwitchingBehaviorForRecordingEnabled) <span class="built_in">BOOL</span> primaryConstituentDeviceSwitchingBehaviorForRecordingEnabled;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimaryConstituentDeviceSwitchingBehaviorForRecording:(<span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span>)switchingBehavior restrictedSwitchingBehaviorConditions:(<span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span>)restrictedSwitchingBehaviorConditions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span> primaryConstituentDeviceSwitchingBehaviorForRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span> primaryConstituentDeviceRestrictedSwitchingBehaviorConditionsForRecording;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为音频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)availableOutputFileTypes;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL outputFileType:(<span class="built_in">AVFileType</span>)fileType recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以对 movie file output 的参数进行配置，比如最大的录制时长、最大的录制文件大小。如果设备磁盘空间不足的话，还可以阻止用户进行视频录制。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc] init];</span><br><span class="line"><span class="built_in">CMTime</span> maxDuration = &lt;#Create a <span class="built_in">CMTime</span> to represent the maximum duration#&gt;;</span><br><span class="line">aMovieFileOutput.maxRecordedDuration = maxDuration;</span><br><span class="line">aMovieFileOutput.minFreeDiskSpaceLimit = &lt;#An appropriate minimum given the quality of the movie format and the duration#&gt;;</span><br></pre></td></tr></table></figure><p>输出的分辨率和码率依赖于 capture session 的<code>sessionPreset</code> 属性，常用的视频编码格式是 H.264，音频编码格式是 AAC。实际的编码格式可能由于设备不同有所差异。</p><h4 id="2-两个协议"><a href="#2-两个协议" class="headerlink" title="2. 两个协议"></a>2. 两个协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件录制协议。在单个文件记录过程中的各个阶段，通知外部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputRecordingDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didStartRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didPauseRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didResumeRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output willFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出协议。用于监听和控制媒体文件输出的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)captureOutputShouldProvideSampleAccurateRecordingStart:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 开始录制</span></span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = &lt;#A file URL that identifies the output location#&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 使用方法下面的方法开始录制一段 QuickTime 视频，方法需要传入一个本地文件的 URL 和一个录制的 delegate。</span></span><br><span class="line"><span class="comment"> - 传入的本地 URL 不能是已经存在的文件，因为 movie file output 不会对已存在的文件进行重写，而且对传入的文件路径，程序必须有写入权限。</span></span><br><span class="line"><span class="comment"> - 传入的 delegate 必须遵循 AVCaptureFileOutputRecordingDelegate 协议，且必须实现其require方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;#The delegate#&gt;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 确保文件写入成功，在下面协议方法中不仅需要检测 error, 还需要对 error 中的 user info 字典中的 AVErrorRecordingSuccessfullyFinishedKey进行判断。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput</span><br><span class="line">        didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL</span><br><span class="line">        fromConnections:(<span class="built_in">NSArray</span> *)connections</span><br><span class="line">        error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> recordedSuccessfully = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([error code] != noErr) &#123;</span><br><span class="line">        <span class="comment">// A problem occurred: Find out if the recording was successful.</span></span><br><span class="line">        <span class="keyword">id</span> value = [[error userInfo] objectForKey:<span class="built_in">AVErrorRecordingSuccessfullyFinishedKey</span>];</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            recordedSuccessfully = [value boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Continue as appropriate...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以需要对<code>AVErrorRecordingSuccessfullyFinishedKey</code>进行判断，是因为即使写入过程中抛出了一个 error，文件也可能被成功写入了。抛出的 error 可能是因为：</p><ul><li>达到了一些设置的限制约束条件，比如：<ul><li>AVErrorMaximumDurationReached</li><li>AVErrorMaximumFileSizeReached</li></ul></li><li>其他可能导致录制中断的情况如下:<ul><li>磁盘已满 - AVErrorDiskFull</li><li>与录制的设备的连接断开 - AVErrorDeviceWasDisconnected</li><li>session 中断 (比如有电话接入) - AVErrorSessionWasInterrupted</li></ul></li></ul><h4 id="4-在文件中添加元数据-AVMetadataItem"><a href="#4-在文件中添加元数据-AVMetadataItem" class="headerlink" title="4. 在文件中添加元数据(AVMetadataItem)"></a>4. 在文件中添加元数据(AVMetadataItem)</h4><p>可在任何时刻对文件的元数据 (metadata) 进行设置，哪怕是在录制过程中。一个 file output 的 metadata 由一个 AVMetadataItem 对象的数组来表示。可以使用其可变子类 AVMutableMetadataItem 创建自定义的 metadata。</p><img src="/images/avf/avmetadataItem.jpg" alt="avmetadataItem" style="zoom:75%;" /><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *existingMetadataArray = aMovieFileOutput.metadata;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *newMetadataArray = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (existingMetadataArray) &#123;</span><br><span class="line">    newMetadataArray = [existingMetadataArray mutableCopy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    newMetadataArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];</span><br><span class="line">item.keySpace = <span class="built_in">AVMetadataKeySpaceCommon</span>;</span><br><span class="line">item.key = <span class="built_in">AVMetadataCommonKeyLocation</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CLLocation</span> *location - &lt;#The location to set#&gt;;</span><br><span class="line">item.value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%+08.4lf%+09.4lf/&quot;</span></span><br><span class="line">    location.coordinate.latitude, location.coordinate.longitude];</span><br><span class="line"></span><br><span class="line">[newMetadataArray addObject:item];</span><br><span class="line"></span><br><span class="line">aMovieFileOutput.metadata = newMetadataArray;</span><br></pre></td></tr></table></figure><h3 id="4-4-2-处理视频帧-AVCaptureVideoDataOutput"><a href="#4-4-2-处理视频帧-AVCaptureVideoDataOutput" class="headerlink" title="4.4.2 处理视频帧(AVCaptureVideoDataOutput)"></a>4.4.2 处理视频帧(AVCaptureVideoDataOutput)</h3><h4 id="1-AVCaptureVideoDataOutput类"><a href="#1-AVCaptureVideoDataOutput类" class="headerlink" title="1. AVCaptureVideoDataOutput类"></a>1. AVCaptureVideoDataOutput类</h4><p>AVCaptureVideoDataOutput 使用代理模式来对视频帧进行处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoDataOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理，此外还需要传入代理方法被调用的队列。</span></span><br><span class="line"><span class="comment">// 必须使用串行队列确保视频帧按照录制顺序被传递到代理方法中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setSampleBufferDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt;)sampleBufferDelegate queue:(<span class="built_in">dispatch_queue_t</span>)sampleBufferCallbackQueue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt; sampleBufferDelegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> sampleBufferCallbackQueue;</span><br><span class="line"><span class="comment">// 自定义输出格式. videoSettings属性是一个字典类型, 目前只支持kCVPixelBufferPixelFormatTypeKey.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">null_resettable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *)availableVideoCodecTypesForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForVideoCodecType:(<span class="built_in">AVVideoCodecType</span>)videoCodecType assetWriterOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line"><span class="comment">// 获取支持的视频像素格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableVideoCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// 获取支持的视频编解码格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line"><span class="comment">// 最小帧率。降低帧率来确保有足够的时间对视频帧进行处理</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> minFrameDuration API_DEPRECATED(<span class="string">&quot;Use AVCaptureConnection&#x27;s videoMinFrameDuration property instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 如果data output queue is阻塞，是否丢弃帧(当我们处理静止图像时)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysDiscardsLateVideoFrames;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresOutputBufferDimensions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> deliversPreviewSizedOutputBuffers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从video data输出样本缓冲区，并监控其状态的方法。</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureVideoDataOutputSampleBufferDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 通知已写入新的视频帧。视频帧由 CMSampleBufferRef 类型表示。默认情况下，buffers 被设置为当前设备相机效率最高的格式。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didDropSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection API_AVAILABLE(ios(<span class="number">6.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>设置队列时，可以使用队列修改视频帧传递处理的优先级，参见示例 <a href="https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190">SquareCam</a>。</p><p>Core Graphics 和 OpenGL 都很好的兼容了<code>BGRA</code>格式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =</span><br><span class="line">                @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput.videoSettings = newSettings;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果data output queue is阻塞，则丢弃(当我们处理静止图像时)</span></span><br><span class="line">[videoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="literal">YES</span>];)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建串行队列</span></span><br><span class="line">videoDataOutputQueue = dispatch_queue_create(<span class="string">&quot;VideoDataOutputQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">[videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:videoDataOutputQueue];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#The Capture Session#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( [captureSession canAddOutput:videoDataOutput] )</span><br><span class="line">     [captureSession addOutput:videoDataOutput];</span><br></pre></td></tr></table></figure><h4 id="2-视频处理时的性能考虑"><a href="#2-视频处理时的性能考虑" class="headerlink" title="2. 视频处理时的性能考虑"></a>2. 视频处理时的性能考虑</h4><p>导出视频应当尽可能的使用低分辨率，高分辨率会消耗额外的 CPU 和电量。</p><p>确保在代理方法 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中处理 sample buffer 时不要使用耗时操作，如果处理占用时间过长，AV Foundation 会停止向代理方法中传递视频帧，而且会停止其他的输出，比如 preview layer 上的预览。</p><p>可以设置 capture video data 的属性 minFrameDuration 通过降低帧率来确保有足够的时间对视频帧进行处理。</p><p>将属性 alwaysDiscardsLateVideoFrames 设置为<code>YES</code>(默认值) 的话，后面的视频帧将会被丢弃，而不是排队等待处理。如果你并不介意延迟，而且需要处理所有的视频帧，也可以将<code>alwaysDiscardsLateVideoFrames</code>设置为<code>NO</code>(即使如此, 也可能会出现掉帧的情况)。</p><h3 id="4-4-3-捕捉静态图像-AVCaptureStillImageOutput"><a href="#4-4-3-捕捉静态图像-AVCaptureStillImageOutput" class="headerlink" title="4.4.3 捕捉静态图像(AVCaptureStillImageOutput)"></a>4.4.3 捕捉静态图像(AVCaptureStillImageOutput)</h3><p>使用 AVCaptureStillImageOutput 捕捉带元数据的静态图像。图片的分辨率依赖于 session 的 preset 设置和具体的硬件设备。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureStillImageOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="comment">// 可以指定需要的图片格式等</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="comment">// ouput支持的图像像素格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableImageDataCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// ouput支持的图像编解码格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableImageDataCodecTypes;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyEnablesStillImageStabilizationWhenAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> highResolutionStillImageOutputEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> capturingStillImage;</span><br><span class="line">- (<span class="keyword">void</span>)captureStillImageAsynchronouslyFromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">CMSampleBufferRef</span> _Nullable imageDataSampleBuffer, <span class="built_in">NSError</span> * _Nullable error))handler <span class="built_in">NS_SWIFT_DISABLE_ASYNC</span>;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)jpegStillImageNSDataRepresentation:(<span class="built_in">CMSampleBufferRef</span>)jpegSampleBuffer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="1-像素和编码格式"><a href="#1-像素和编码格式" class="headerlink" title="1. 像素和编码格式"></a>1. 像素和编码格式</h4><p>不同的设备支持不同的图片格式。</p><p>可以使用 availableImageDataCVPixelFormatTypes、availableImageDataCodecTypes 查询。使用outputSettings 设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureStillImageOutput *stillImageOutput &#x3D; [[AVCaptureStillImageOutput alloc] init];</span><br><span class="line">NSDictionary *outputSettings &#x3D; @&#123; AVVideoCodecKey : AVVideoCodecJPEG&#125;;</span><br><span class="line">[stillImageOutput setOutputSettings:outputSettings];</span><br></pre></td></tr></table></figure><p>如果需要的是 JPEG 图片，则不要指定压缩格式。相反，应该让 still image output 进行压缩 (因为它是硬件加速的)。可以使用 jpegStillImageNSDataRepresentation: 获取 NSData对象，且无需重新压缩数据，即使你修改了图像的元数据。</p><h4 id="2-捕捉图片"><a href="#2-捕捉图片" class="headerlink" title="2. 捕捉图片"></a>2. 捕捉图片</h4><p>使用方法 captureStillImageAsynchronouslyFromConnection:completionHandler: 捕捉图片。</p><ul><li>第一个参数是需要捕捉的 connection，需要判断当前的 connection 中哪个 input 正在采集视频。</li><li>第二个参数是一个有两个参数的<code>block</code>：<ul><li>一个包含图像数据的<code>CMSampleBuffer</code>类型</li><li>一个是 NSError 对象。Sample buffer 自身包含了元数据，比如 EXIF 信息字典，可以对这些元数据进行修改。</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *videoConnection = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureConnection</span> *connection <span class="keyword">in</span> stillImageOutput.connections) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureInputPort</span> *port <span class="keyword">in</span> [connection inputPorts]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[port mediaType] isEqual:<span class="built_in">AVMediaTypeVideo</span>] ) &#123;</span><br><span class="line">            videoConnection = connection;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (videoConnection) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:</span><br><span class="line">    ^(<span class="built_in">CMSampleBufferRef</span> imageSampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> exifAttachments =</span><br><span class="line">            <span class="built_in">CMGetAttachment</span>(imageSampleBuffer, kCGImagePropertyExifDictionary, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (exifAttachments) &#123;</span><br><span class="line">            <span class="comment">// Do something with the attachments.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue as appropriate.</span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><h2 id="4-5-录制预览"><a href="#4-5-录制预览" class="headerlink" title="4.5 录制预览"></a>4.5 录制预览</h2><p>可以提供给用户一个 preview，用来展示正在通过摄像头录制的内容 (使用 preview layer)，或者正在通过麦克风记录的音频内容 (通过监听 audio channel)。</p><h3 id="4-5-1-视频预览-AVCaptureVideoPreviewLayer"><a href="#4-5-1-视频预览-AVCaptureVideoPreviewLayer" class="headerlink" title="4.5.1 视频预览(AVCaptureVideoPreviewLayer)"></a>4.5.1 视频预览(AVCaptureVideoPreviewLayer)</h3><h4 id="1-AVCaptureVideoPreviewLayer类"><a href="#1-AVCaptureVideoPreviewLayer类" class="headerlink" title="1. AVCaptureVideoPreviewLayer类"></a>1. AVCaptureVideoPreviewLayer类</h4><p>使用 AVCaptureVideoPreviewLayer 可以进行视频预览。 <code>AVCaptureVideoPreviewLayer</code>是<code>CALayer</code>的子类. 进行视频预览不需要设置任何的 output 对象。</p><p>大体上，video preview layer 的性质与<code>CALayer</code>类似。你可以对图像进行缩放，向操作其他任何 layer 一样进行 transformations，rotations 等操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoPreviewLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">AVCaptureSession</span> *session;</span><br><span class="line">- (<span class="keyword">void</span>)setSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureConnection</span> *connection;</span><br><span class="line"><span class="comment">/* 指示图层如何在其范围内显示视频内容。(为啥叫重力模式？)</span></span><br><span class="line"><span class="comment">   Preview layer 支持三种重力模式</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspect: 保持视频款高比, 当视频内容不能铺满屏幕时, 不足的部分使用黑色背景进行填充.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspectFill: 保持视频款高比, 但是会铺满整个屏幕, 必要时会对视频内容进行裁剪.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResize: 拉伸视频内容铺满屏幕, 可能导致图像变形.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> previewing;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)captureDevicePointOfInterestForPoint:(<span class="built_in">CGPoint</span>)pointInLayer;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)pointForCaptureDevicePointOfInterest:(<span class="built_in">CGPoint</span>)captureDevicePointOfInterest;</span><br><span class="line">- (<span class="built_in">CGRect</span>)metadataOutputRectOfInterestForRect:(<span class="built_in">CGRect</span>)rectInLayerCoordinates;</span><br><span class="line">- (<span class="built_in">CGRect</span>)rectForMetadataOutputRectOfInterest:(<span class="built_in">CGRect</span>)rectInMetadataOutputCoordinates;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">AVMetadataObject</span> *)transformedMetadataObjectForMetadataObject:(<span class="built_in">AVMetadataObject</span> *)metadataObject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用 AVCaptureVideoDataOutput 类可以在视频展示给用户预览之前对视频进行处理。</p><p>与 capture output 不同，一个 video preview layer 会强引用与其相关联的 session。这是为了确保在进行视频预览时 session 不会被销毁。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">CALayer</span> *viewLayer = &lt;#Get a layer from the view <span class="keyword">in</span> which you want to present the preview#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession];</span><br><span class="line">[viewLayer addSublayer:captureVideoPreviewLayer];</span><br></pre></td></tr></table></figure><h4 id="2-预览时使用点击聚焦功能"><a href="#2-预览时使用点击聚焦功能" class="headerlink" title="2. 预览时使用点击聚焦功能"></a>2. 预览时使用点击聚焦功能</h4><p>在 preview layer 上实现点击聚焦功能时，需要注意视频方向、视频重力模式以及可能预览设置了视频镜像。参见代码示例 <a href="https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112">AVCam-iOS: Using AVFoundation to Capture Images and Movies</a>.</p><h3 id="4-5-2-展示声音等级-AVCaptureAudioChannel"><a href="#4-5-2-展示声音等级-AVCaptureAudioChannel" class="headerlink" title="4.5.2 展示声音等级(AVCaptureAudioChannel)"></a>4.5.2 展示声音等级(AVCaptureAudioChannel)</h3><p>要在 capture connection 中检测声音的均值和峰值，可以使用 AVCaptureAudioChannel 对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioChannel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> averagePowerLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> peakHoldLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> volume;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>声音等级不能使用 KVO 的方式获取，所以需要根据界面更新的需求定时进行轮询 (比如每秒 10 次)。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureAudioDataOutput</span> *audioDataOutput = &lt;#Get the audio data output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *connections = audioDataOutput.connections;</span><br><span class="line"><span class="keyword">if</span> ([connections count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There should be only one connection to an AVCaptureAudioDataOutput.</span></span><br><span class="line">    <span class="built_in">AVCaptureConnection</span> *connection = [connections objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *audioChannels = connection.audioChannels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureAudioChannel</span> *channel <span class="keyword">in</span> audioChannels) &#123;</span><br><span class="line">        <span class="keyword">float</span> avg = channel.averagePowerLevel;</span><br><span class="line">        <span class="keyword">float</span> peak = channel.peakHoldLevel;</span><br><span class="line">        <span class="comment">// Update the level meter user interface.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-示例-捕捉视频帧为UIImage对象"><a href="#4-6-示例-捕捉视频帧为UIImage对象" class="headerlink" title="4.6 示例: 捕捉视频帧为UIImage对象"></a>4.6 示例: 捕捉视频帧为UIImage对象</h2><p>接下来的代码简单示例了如何捕捉视频，并将捕捉到的视频帧转换为 UIImage 对象:</p><ul><li>创建<code>AVCaptureSession</code>对象</li><li>找到合适类型的<code>AVCaptureDevice</code>对象进行输入</li><li>为设备创建<code>AVCaptureDeviceInput</code>对象</li><li>创建<code>AVCaptureVideoDataOutput</code>对象获取视频帧</li><li>实现<code>AVCaptureVideoDataOutput</code>的代理</li><li>实现一个方法将接收到的<code>CMSampleBuffer</code>转换为<code>UIImage</code></li></ul><blockquote><p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)config &#123;</span><br><span class="line">    <span class="comment">// 1. 创建和配置 Capture Session，用来协调 input 和 output 之间的数据流。</span></span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPresetMedium</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建和配置 Device 和 Device Input。AVCaptureDevic表示采集设备，AVCaptureInput用来配置 采集设备的端口(一台设备有一个或多个端口)。通常使用默认配置的capture input</span></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =  <span class="comment">//如果找不到合适的设备，error不为空</span></span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    [session addInput:input];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建和配置 Video Data Output。使用 AVCaptureVideoDataOutput处理未压缩的视频帧。</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    [session addOutput:output];</span><br><span class="line">    output.videoSettings =</span><br><span class="line">                    @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;; <span class="comment">//配置像素格式</span></span><br><span class="line">    output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>); <span class="comment">//最小帧率。将帧率限制为15fps（1/15 sec）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;MyQueue&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 提供串行队列. 在此队列上回调</span></span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 实现 Sample Buffer 代理方法。注意该方法是在指定的队列上调用的。如果要更新UI，必须在主线程上。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将转换为 UIImage 的操作代码参见 [Converting CMSampleBuffer to a UIImage Object](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/06_MediaRepresentations.html#//apple_ref/doc/uid/TP40010188-CH2-SW4).</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">    <span class="comment">// Add your code here that uses the image.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 配置 capture session 之后，需要确保应用有访问相机的权限.</span></span><br><span class="line">- (<span class="keyword">void</span>)checkAccess &#123;</span><br><span class="line">  <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line">  [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (granted)&#123;</span><br><span class="line">          <span class="comment">//Granted access to mediaType</span></span><br><span class="line">          [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;AVCam!&quot;</span></span><br><span class="line">                                      message:<span class="string">@&quot;AVCam doesn&#x27;t have permission to use Camera, please change privacy settings&quot;</span></span><br><span class="line">                                     delegate:<span class="keyword">self</span></span><br><span class="line">                            cancelButtonTitle:<span class="string">@&quot;OK&quot;</span></span><br><span class="line">                            otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                  [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 开始和停止</span></span><br><span class="line"><span class="comment">// 当获取到相应的访问权限之后，可以使用 startRunning 方法开始录制。startRunning 会阻塞线程，所以需要异步调用，以免阻塞主线程。</span></span><br><span class="line">[session startRunning];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 stopRunning 可以停止录制.</span></span><br><span class="line">[session stopRunning];</span><br></pre></td></tr></table></figure><h2 id="4-7-高帧率视频捕捉"><a href="#4-7-高帧率视频捕捉" class="headerlink" title="4.7 高帧率视频捕捉"></a>4.7 高帧率视频捕捉</h2><p>iOS 7.0 在选定的硬件上引入了高帧率视频捕获支持（也称为“SloMo”视频）。完整的 AVFoundation 框架支持高帧率内容。</p><p>可以使用 AVCaptureDeviceFormat 类确定设备的捕获能力。此类具有返回支持的媒体类型、帧速率、视野、最大缩放系数、是否支持视频稳定等的方法。</p><ul><li>捕捉：支持每秒 60 帧 (fps) 、720p（1280 x 720 像素）分辨率，包括视频稳定和可丢弃的 P 帧（H264 编码电影的一项功能，即使在较慢和较旧的硬件上也可以流畅地播放电影。 )</li><li>播放：增强了对慢速和快速播放的音频支持，允许音频的时间音高可以在更慢或更快的速度下保存。</li><li>编辑：完全支持可变 compositions 中的缩放编辑。</li><li>导出：支持 60 fps 影片时，导出提供两个选项。可以保留可变帧速率、慢动作或快动作，或者将电影转换为任意较慢的帧速率，例如每秒 30 帧。</li></ul><p>SloPoke 示例代码演示了 AVFoundation 对快速视频捕获的支持、确定硬件是否支持高帧率视频捕获、使用各种速率和时间间距算法进行播放以及编辑（包括为部分合成设置时间比例）。</p><h3 id="4-7-1-播放"><a href="#4-7-1-播放" class="headerlink" title="4.7.1 播放"></a>4.7.1 播放</h3><p>AVPlayer 的实例通过设置 setRate: 方法值自动管理大部分播放速度。该值用作播放速度的乘数。值 1.0 会导致正常播放，0.5 会以半速播放，5.0 会比正常播放快五倍，依此类推。</p><p>AVPlayerItem 对象支持 audioTimePitchAlgorithm 属性（指示缩放音频编辑时，音频音高的处理算法）。此属性允许您使用 Time Pitch Algorithm Settings 常量指定在以各种帧速率播放电影时如何播放音频。</p><p>下表显示了支持的时间音高算法、质量、算法是否导致音频匹配特定的帧速率，以及每种算法支持的帧速率范围。</p><table><thead><tr><th align="left">Time pitch algorithm</th><th align="left">Quality</th><th align="left">Snaps to specific frame rate</th><th align="left">Rate range</th></tr></thead><tbody><tr><td align="left">AVAudioTimePitchAlgorithmLowQualityZeroLatency(低质量零延迟)</td><td align="left">低质量，适用于快进、快退或低质量语音。</td><td align="left"><code>YES</code></td><td align="left">0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0 rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmTimeDomain(时域)</td><td align="left">质量适中，计算成本较低，适用于语音。</td><td align="left"><code>NO</code></td><td align="left">0.5–2x rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmSpectral(光谱)</td><td align="left">最高质量，最昂贵的计算，保留原始项目的音高。</td><td align="left"><code>NO</code></td><td align="left">1/32–32 rates.</td></tr><tr><td align="left">AVAudioTimePitchAlgorithmVarispeed(变速)</td><td align="left">无需音高校正的高质量播放。</td><td align="left"><code>NO</code></td><td align="left">1/32–32 rates.</td></tr></tbody></table><h3 id="4-7-2-编辑"><a href="#4-7-2-编辑" class="headerlink" title="4.7.2 编辑"></a>4.7.2 编辑</h3><p>编辑时，您使用 AVMutableComposition 类来构建临时编辑。</p><ul><li>使用类方法 composition 创建一个新的 AVMutableComposition 实例。</li><li>使用 insertTimeRange:ofAsset:atTime:error: 方法插入视频资产。</li><li>使用 scaleTimeRange:toDuration: 设置部分 composition 的时间比例。</li></ul><h3 id="4-7-3-导出"><a href="#4-7-3-导出" class="headerlink" title="4.7.3 导出"></a>4.7.3 导出</h3><p>导出 60 fps 视频使用 AVAssetExportSession 类来导出资产。可以使用两种技术导出内容：</p><ul><li>使用 AVAssetExportPresetPassthrough 预设来避免重新编码电影。它使用标记为 60 fps 部分、减速部分或加速部分的媒体部分重新定时媒体。</li><li>使用恒定帧速率导出以获得最大的播放兼容性。将视频合成的 frameDuration 属性设置为 30 fps。还可以通过设置导出会话的 audioTimePitchAlgorithm 属性来指定时间音高。</li></ul><h3 id="4-7-4-录制"><a href="#4-7-4-录制" class="headerlink" title="4.7.4 录制"></a>4.7.4 录制</h3><p>使用 AVCaptureMovieFileOutput 类捕获高帧率视频，该类自动支持高帧率录制。它将自动选择正确的 H264 音高电平和比特率。</p><p>要进行自定义录制，您必须使用 AVAssetWriter 类，这需要一些额外的设置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assetWriterInput.expectsMediaDataInRealTime=<span class="literal">YES</span>；<span class="comment">// input是否应针对实时源调整其对媒体数据的处理</span></span><br></pre></td></tr></table></figure><p>此设置确保捕获可以跟上传入的数据。</p><h1 id="五、Asset的读、写、重编码"><a href="#五、Asset的读、写、重编码" class="headerlink" title="五、Asset的读、写、重编码"></a>五、Asset的读、写、重编码</h1><blockquote><p>Asset  → AssetReader → AssetReaderOutput → 内存 → AssetWriteInput → AssetWrite → 文件URL</p></blockquote><p>可以使用AVAssetExportSession 、 <em>AVAssetReader</em> 、<em>AVAssetWriter</em> 对象，完成一些的音视频资源操作需求，比如：</p><ul><li>可以通过一个导出会话 (<em>export session</em>)，将一个已存在的 asset 进行重新编码为，一些已经预设置好的常用格式 (commonly-used presets)。</li><li>协同使用 <em>AVAssetReader</em> 和 <em>AVAssetWriter</em> 对象，可以实现更多的自定义设置，如可以选择将哪些 track 输出到文件中，对资源进行修改。<ul><li>在需要对 asset 内容进行操作时使用<code>AVAssetReader</code>。例如，需要读取 audio track 绘制音频波形图.。</li><li>在需要将媒体 (比如 sample buffers 或者静态图像) 转换为一个 asset 时，使用<code>AVAssetWriter</code>。</li></ul></li></ul><p>注意：</p><ul><li>这两个类不适用于实时处理。</li><li><code>AVAssetReader</code>不能用来读取 HTTP 直播流这样的实时资源。</li><li>如果在实时数据处理 (比如 AVCaptureOutput) 中使用了<code>AVAssetWriter</code>，需要将<code>AVAssetWriter</code>的属性 expectsMediaDataInRealTime 设置为<code>YES</code>，这样可以保证以正确的顺序写入文件。</li></ul><h2 id="5-1-读取Asset-AVAssetReader"><a href="#5-1-读取Asset-AVAssetReader" class="headerlink" title="5.1 读取Asset(AVAssetReader)"></a>5.1 读取Asset(AVAssetReader)</h2><h3 id="AVAssetReader-和-Output-类"><a href="#AVAssetReader-和-Output-类" class="headerlink" title="AVAssetReader 和 Output 类"></a>AVAssetReader 和 Output 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReader</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetReaderStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetReaderOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line"><span class="comment">//开始读取</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)startReading;</span><br><span class="line">- (<span class="keyword">void</span>)cancelReading;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>每个<code>AVAssetReader</code>对象只能被关联到一个 asset，但是这个 asset 可能包含多个 track。因此，在开始读取之前，需要为 asset reader配置一个 AVAssetReaderOutput 的子类来设置媒体数据的读取方式。</p><p><code>AVAssetReaderOutput</code>有三个子类可以用来读取 asset：AVAssetReaderTrackOutput、AVAssetReaderAudioMixOutput、AVAssetReaderVideoCompositionOutput。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 AVAssetReader 读取通用媒体类型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// 是否输出样本数据的副本。默认值为YES。</span></span><br><span class="line"><span class="comment">// 可以通过将值设置为 NO 来禁用默认行为，注意此时只能引用，而不能修改它们，因为修改共享缓冲区的行为是未定义的。</span></span><br><span class="line"><span class="comment">// 如果不需要修改样本数据，禁用复制可能会提高性能。如果你打算修改它返回的有样本数据，置为YES是合适的。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysCopiesSampleData;</span><br><span class="line"><span class="comment">// 复制下一个样本缓冲区</span></span><br><span class="line">- (<span class="built_in">CMSampleBufferRef</span>)copyNextSampleBuffer <span class="built_in">CF_RETURNS_RETAINED</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> (<span class="title">AVAssetReaderOutputRandomAccess</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsRandomAccess;</span><br><span class="line">- (<span class="keyword">void</span>)resetForReadingTimeRanges:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)timeRanges;</span><br><span class="line">- (<span class="keyword">void</span>)markConfigurationAsFinal;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 AVAssetReader 的 AVAsset 的单个 AVAssetTrack 读取媒体数据。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderTrackOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderTrackOutputWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetTrack</span> *track;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取由 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTrack 中的音频混合产生的音频样本。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderAudioMixOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderAudioMixOutputWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *audioTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioMix</span> *audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取已从 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTracks 中的帧合成在一起的视频帧。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderVideoCompositionOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderVideoCompositionOutputWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *videoTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVVideoComposition</span> *videoComposition;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositor;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-1-1-创建-AVAssetReader"><a href="#5-1-1-创建-AVAssetReader" class="headerlink" title="5.1.1 创建 AVAssetReader"></a>5.1.1 创建 AVAssetReader</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 AVAssetReader 对象需要一个 asset 对象</span></span><br><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">AVAsset</span> *someAsset = &lt;#<span class="built_in">AVAsset</span> that you want to read#&gt;;</span><br><span class="line"><span class="built_in">AVAssetReader</span> *assetReader = [<span class="built_in">AVAssetReader</span> assetReaderWithAsset:someAsset error:&amp;outError];</span><br><span class="line"><span class="comment">// 需要检查 assetReader 是否创建成功, 如果失败, error 会包含相关的错误信息.</span></span><br><span class="line"><span class="built_in">BOOL</span> success = (assetReader != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><h3 id="5-1-2-设置-AVAssetReaderOutput"><a href="#5-1-2-设置-AVAssetReaderOutput" class="headerlink" title="5.1.2 设置 AVAssetReaderOutput"></a>5.1.2 设置 AVAssetReaderOutput</h3><p>成功创建 assetReader 后，至少需要设置一个 output 来接收读取的媒体数据。确保 output 的属性 alwaysCopiesSampleData 被设置为<code>NO</code>，这样能提升性能。本章所有的实例代码中，该属性都设置为<code>NO</code>。</p><h4 id="1-AVAssetReaderTrackOutput"><a href="#1-AVAssetReaderTrackOutput" class="headerlink" title="1. AVAssetReaderTrackOutput"></a>1. AVAssetReaderTrackOutput</h4><p>如果只是需要从一个或多个 track 中读取数据并修改其格式，那么可以使用<code>AVAssetReaderTrackOutput</code>。</p><p>要解压一个 audio track 为 Linear PCM，需要进行如下设置:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *localAsset = assetReader.asset;</span><br><span class="line"><span class="comment">// Get the audio track to read.</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTrack = [[localAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Decompression settings for Linear PCM</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// Create the output with the audio track and decompression settings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *trackOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:trackOutput])</span><br><span class="line">    [assetReader addOutput:trackOutput];</span><br></pre></td></tr></table></figure><blockquote><p>要以存储时的格式读取数据，将参数<code>outputSettings</code>设置为<code>nil</code>.</p></blockquote><h4 id="2-AVAssetReaderAudioMixOutput"><a href="#2-AVAssetReaderAudioMixOutput" class="headerlink" title="2. AVAssetReaderAudioMixOutput"></a>2. AVAssetReaderAudioMixOutput</h4><p>对于使用 AVAudioMix 和 AVVideoComposition 处理过的 asset，需要使用<code>AVAssetReaderAudioMixOutput</code> 和 <code>AVAssetReaderVideoCompositionOutput</code>进行读取。</p><p>通常，当从 AVComposition 对象中读取数据时，会使用到这些 output 对象。</p><p>使用一个<code>AVAssetReaderAudioMixOutput</code>对象，可以读取 asset 中的多个 audio track。下面的代码展示了如何使用 asset 中所有的 audio track 创建一个<code>AVAssetReaderAudioMixOutput</code>对象，解压缩 audio track 为 Linear PCM，并为 output 设置音频混合方式 (audio mix)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAudioMix</span> *audioMix = &lt;#<span class="string">&quot;一个 AVAudioMix，指定如何混合来自 AVAsset 的音轨&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 对象初始化的。</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的音轨</span></span><br><span class="line"><span class="built_in">NSArray</span> *audioTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line"><span class="comment">// 获取线性 PCM 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// 使用音轨和解压缩设置创建音频混合输出。</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *audioMixOutput = [<span class="built_in">AVAssetReaderAudioMixOutput</span> assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">audioMixOutput.audioMix = audioMix;</span><br><span class="line"><span class="comment">// 将output添加到reader</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:audioMixOutput])</span><br><span class="line">    [assetReader addOutput:audioMixOutput];</span><br></pre></td></tr></table></figure><blockquote><p>设置参数<code>audioSettings</code> 为 <code>nil</code>，将返回未被压缩的样本数据。对<code>AVAssetReaderVideoCompositionOutput</code>也一样。</p></blockquote><h4 id="3-AVAssetReaderVideoCompositionOutput"><a href="#3-AVAssetReaderVideoCompositionOutput" class="headerlink" title="3. AVAssetReaderVideoCompositionOutput"></a>3. AVAssetReaderVideoCompositionOutput</h4><p><code>AVAssetReaderVideoCompositionOutput</code> 的使用方法大致与<code>AVAssetReaderAudioMixOutput</code> 相同，可以从 asset 中读取多个 video track。下面的代码示例了如何从多个 video track 中读取数据，并解压为 ARGB:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVVideoComposition</span> *videoComposition = &lt;#<span class="string">&quot;一个 AVVideoComposition，指定如何合成来自 AVAsset 的视频轨道&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 初始化的</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的视频轨道。</span></span><br><span class="line"><span class="built_in">NSArray</span> *videoTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="comment">// ARGB 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123; (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary] &#125;;</span><br><span class="line"><span class="comment">// 使用视频轨道和解压缩设置创建视频合成输出</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *videoCompositionOutput = [<span class="built_in">AVAssetReaderVideoCompositionOutput</span> assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">videoCompositionOutput.videoComposition = videoComposition;</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:videoCompositionOutput])</span><br><span class="line">    [assetReader addOutput:videoCompositionOutput];</span><br></pre></td></tr></table></figure><h3 id="5-1-3-读取-Asset-中的媒体数据"><a href="#5-1-3-读取-Asset-中的媒体数据" class="headerlink" title="5.1.3 读取 Asset 中的媒体数据"></a>5.1.3 读取 Asset 中的媒体数据</h3><p>按需设置 outputs 之后，调用 asset reader 的方法 startReading 开始读取数据。然后使用方法 copyNextSampleBuffer 从 output 中开始检索、获取媒体数据。示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the asset reader up.</span></span><br><span class="line">[<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line"><span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">while</span> (!done)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Copy the next sample buffer from the reader output.</span></span><br><span class="line">  <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">  <span class="keyword">if</span> (sampleBuffer)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Do something with sampleBuffer here.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">    sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Find out why the asset reader output couldn&#x27;t copy another sample buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">      <span class="comment">// Handle the error here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The asset reader output has read all of its samples.</span></span><br><span class="line">      done = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-写入Asset-AVAssetWriter"><a href="#5-2-写入Asset-AVAssetWriter" class="headerlink" title="5.2 写入Asset(AVAssetWriter)"></a>5.2 写入Asset(AVAssetWriter)</h2><h3 id="AVAssetWriter-和-Input-类"><a href="#AVAssetWriter-和-Input-类" class="headerlink" title="AVAssetWriter 和 Input 类"></a>AVAssetWriter 和 Input 类</h3><p><a href="https://developer.apple.com/reference/avfoundation/avassetwriter">AVAssetWriter</a> 将多个来源的数据以指定格式写入到单个文件中。Asset writer 并不与一个特定的 asset 相关联，但必须与要创建的输出文件相关联。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriter</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithContentType:(UTType *)outputContentType <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">AVFileType</span> outputFileType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaType</span>&gt; *availableMediaTypes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetWriterStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldOptimizeForNetworkUse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *directoryForTemporaryFiles;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetWriterInput</span> *&gt; *inputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canApplyOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="built_in">BOOL</span>)startWriting;</span><br><span class="line">- (<span class="keyword">void</span>)startSessionAtSourceTime:(<span class="built_in">CMTime</span>)startTime;</span><br><span class="line">- (<span class="keyword">void</span>)endSessionAtSourceTime:(<span class="built_in">CMTime</span>)endTime;</span><br><span class="line">- (<span class="keyword">void</span>)cancelWriting;</span><br><span class="line">- (<span class="built_in">BOOL</span>)finishWriting API_DEPRECATED_WITH_REPLACEMENT(<span class="string">&quot;finishWritingWithCompletionHandler:&quot;</span>;</span><br><span class="line">- (<span class="keyword">void</span>)finishWritingWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))handler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.....还有一些分类，此处不再列出.....</span></span><br><span class="line">                                                      </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVAssetWriterDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType segmentReport:(<span class="built_in">AVAssetSegmentReport</span> *)segmentReport;</span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由于一个 asset writer 可以从多个来源获取数据，所以需要为每个要写入的 track 创建对应的 AVAssetWriterInput 对象。</p><ul><li>接收 CMSampleBufferRef 类型的数据，使用<code>AVAssetWriterInput</code>对象</li><li>如果想要添加 CVPixelBufferRef 类型的数据，可以使用 AVAssetWriterInputPixelBufferAdaptor。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriterInput</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readyForMoreMediaData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> expectsMediaDataInRealTime;</span><br><span class="line">- (<span class="keyword">void</span>)requestMediaDataWhenReadyOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)appendSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer;</span><br><span class="line">- (<span class="keyword">void</span>)markAsFinished;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-2-1-创建-AVAssetWriter"><a href="#5-2-1-创建-AVAssetWriter" class="headerlink" title="5.2.1 创建 AVAssetWriter"></a>5.2.1 创建 AVAssetWriter</h3><p>创建 AVAssetWriter 对象需要指定一个文件 URL 和文件格式。下面的代码示例了如何初始化一个 AVAssetWriter 用来创建 QuickTime 电影.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">NSURL</span> *outputURL = &lt;#<span class="string">&quot;NSURL对象，表示您要保存视频的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:outputURL</span><br><span class="line">                                                      fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span></span><br><span class="line">                                                         error:&amp;outError];</span><br><span class="line"><span class="built_in">BOOL</span> success = (assetWriter != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-2-设置-AVAssetWriterInput"><a href="#5-2-2-设置-AVAssetWriterInput" class="headerlink" title="5.2.2 设置 AVAssetWriterInput"></a>5.2.2 设置 AVAssetWriterInput</h3><p>要让 AVAssetWriter 能写入媒体数据，必须至少设置一个 asset writer input。</p><h4 id="1-AVAssetWriterInput"><a href="#1-AVAssetWriterInput" class="headerlink" title="1. AVAssetWriterInput"></a>1. AVAssetWriterInput</h4><p>例如要写入<code>CMSampleBufferRef</code>类型的数据，需要使用<code>AVAssetWriterInput</code>。下面的代码示例了将压缩的音频数据写入为 128 kbps 的 AAC 格式:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 将通道布局(channel layout)配置为立体声</span></span><br><span class="line">AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 channel layout 对象转换为 NSData 对象</span></span><br><span class="line"><span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 128 kbps AAC 的压缩设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用压缩设置创建asset writer input，并将媒体类型指定为音频。</span></span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *assetWriterInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:compressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the input to the writer if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetWriter canAddInput:assetWriterInput])</span><br><span class="line">    [assetWriter addInput:assetWriterInput];</span><br></pre></td></tr></table></figure><blockquote><p>只有 asset writer 初始化时<code>fileType</code>为 AVFileTypeQuickTimeMovie，参数<code>outputSettings</code>才能为 nil，意味着写入的文件格式为 QuickTime movie。</p></blockquote><p>使用属性 metadata 和 transform 可以为指定的 track 设置 metadata 和 transform。<em>（注意，需要在开始写入之前设置这两个属性才会生效）</em></p><p>当输入源为 video track 时，可以通过如下方式持有 video track 的原始 transform:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="string">&quot;具有至少一个视频轨道的 AVAsset&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">assetWriterInput.transform = videoAssetTrack.preferredTransform</span><br></pre></td></tr></table></figure><h4 id="2-AVAssetWriterInputPixelBufferAdaptor"><a href="#2-AVAssetWriterInputPixelBufferAdaptor" class="headerlink" title="2. AVAssetWriterInputPixelBufferAdaptor"></a>2. AVAssetWriterInputPixelBufferAdaptor</h4><p>在写入文件时，有时候可能会需要分配一个 pixel buffer，这时可以使用<code>AVAssetWriterInputPixelBufferAdaptor</code>类。为了提高效率，可以直接使用 pixel buffer adaptor 提供的 pixel buffer pool。下面的代码示例了创建了一个 pixel buffer 对象处理 RGB 色域:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixelBufferAttributes = @&#123;</span><br><span class="line">     kCVPixelBufferCGImageCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferCGBitmapContextCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithInt:kCVPixelFormatType_32ARGB]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> *inputPixelBufferAdaptor = [<span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> assetWriterInputPixelBufferAdaptorWithAssetWriterInput:<span class="keyword">self</span>.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];</span><br></pre></td></tr></table></figure><blockquote><p>注意，所有的<code>AVAssetWriterInputPixelBufferAdaptor</code>对象都必须与一个 asset writer input 相关联 。这个 asset writer input 对象必须接收<code>AVMediaTypeVideo</code>类型的数据。</p></blockquote><h3 id="5-2-3-写入媒体数据"><a href="#5-2-3-写入媒体数据" class="headerlink" title="5.2.3 写入媒体数据"></a>5.2.3 写入媒体数据</h3><p>当配置完 asset writer 之后，就可以开始写入数据了。</p><p>下面的代码示例了从一个输入源读取数据并写入所有读取到的数据:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the asset writer for writing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动写入过程</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line"><span class="comment">// 开启一个写入会话 (sample-writing session)。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Asset writer 的所有写入过程都通过这个 session 完成，并且 sesion 的时间范围决定了源媒体数据中哪个时间范围内的数据会被写入到文件中</span></span><br><span class="line"><span class="comment">  例如，只写入源数据的后一半的示例代码如下:</span></span><br><span class="line"><span class="comment">  CMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);</span></span><br><span class="line"><span class="comment">  [self.assetWriter startSessionAtSourceTime:halfAssetDuration];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^&#123;</span><br><span class="line">     <span class="comment">// 表示input是否准备好接受媒体数据。</span></span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取下一个样本缓冲区。</span></span><br><span class="line">          <span class="comment">// copyNextSampleBufferToWrite方法只是一个stub(桩代码/存根)。此存根的位置是您需要插入一些逻辑以返回表示你要写入的媒体数据的 CMSampleBufferRef 对象的位置。Sample buffers 可能来源于一个 asset reader output.</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> nextSampleBuffer = [<span class="keyword">self</span> copyNextSampleBufferToWrite];</span><br><span class="line">          <span class="keyword">if</span> (nextSampleBuffer)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 如果存在，则将下一个样本缓冲区附加到输出文件。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:nextSampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(nextSampleBuffer);</span><br><span class="line">               nextSampleBuffer = <span class="literal">nil</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 假设没有下一个样本缓冲区，意味着样本缓冲区源没有样本并将输入标记为已完成。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>一般情况下，方法 endSessionAtSourceTime: 用来结束写入会话。但是如果文件已经写入完毕，则可以方法 finishWriting 结束写入会话。</p><h2 id="5-3-重编码Assets"><a href="#5-3-重编码Assets" class="headerlink" title="5.3 重编码Assets"></a>5.3 重编码Assets</h2><p>可以搭配使用 asset reader 和 asset writer 进行 asset 之间的转换。相比于使用<code>AVAssetExportSession</code>，使用这些对象可以更好的控制转换细节。例如：</p><ul><li>可以选择导出哪个 track</li><li>可以指定导出的文件格式</li><li>可以在转换过程中修改asset，如指定导出的时间范围。</li></ul><p>下面的代码片段示例了如何从一个 asset reader output 读取数据，并使用 asset writer input 写入这些数据.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个用于读写的串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^&#123;</span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取asset reader output的下一个样本缓冲区</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">          <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If it exists, append this sample buffer to the output file.</span></span><br><span class="line">               <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">               sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Check for errors that may have occurred when appending the new sample buffer.</span></span><br><span class="line">               <span class="keyword">if</span> (!success &amp;&amp; <span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetWriter.error;</span><br><span class="line">                    <span class="comment">//Handle the error.</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">//如果下一个样本缓冲区不存在， 定位asset reader output 无法提供另一个样本缓冲区的原因。</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">                    <span class="comment">//Handle the error here.</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// The asset reader output已经听过所有数据，标记为已完成 </span></span><br><span class="line">                    [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="5-4-示例-Asset-Reader和Writer-重编码-Asset"><a href="#5-4-示例-Asset-Reader和Writer-重编码-Asset" class="headerlink" title="5.4 示例: Asset Reader和Writer 重编码 Asset"></a>5.4 示例: Asset Reader和Writer 重编码 Asset</h2><p>下面的代码简要示例了使用 asset reader 和 writer 对一个 asset 中的第一个 video 和 audio track 进行重新编码并将结果数据写入到一个新文件中.</p><blockquote><p>提示: 为了将注意力集中在核心代码上，这份示例省略了某些内容.</p></blockquote><h3 id="5-4-1-初始化设置"><a href="#5-4-1-初始化设置" class="headerlink" title="5.4.1 初始化设置"></a>5.4.1 初始化设置</h3><p>在创建和配置 asset reader 和 writer 之前，需要进行一些初始化设置。首先需要为读写过程创建三个串行队列.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the main serialization queue. 用于 asset reader 和 writer 的启动、停止和取消。</span></span><br><span class="line"><span class="keyword">self</span>.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwAudioSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw audio serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写音频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwVideoSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw video serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写视频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-2-加载-asset-中的-track，并开始重编码"><a href="#5-4-2-加载-asset-中的-track，并开始重编码" class="headerlink" title="5.4.2 加载 asset 中的 track，并开始重编码."></a>5.4.2 加载 asset 中的 track，并开始重编码.</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.asset = &lt;#<span class="built_in">AVAsset</span> that you want to reencode#&gt;;</span><br><span class="line"><span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.outputURL = &lt;#<span class="built_in">NSURL</span> representing desired output URL <span class="keyword">for</span> file generated by asset writer#&gt;;</span><br><span class="line"><span class="comment">// Asynchronously load the tracks of the asset you want to read.</span></span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:@[<span class="string">@&quot;tracks&quot;</span>] completionHandler:^&#123;</span><br><span class="line">     <span class="comment">// Once the tracks have finished loading, dispatch the work to the main serialization queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// Due to asynchronous nature, check to see if user has already cancelled.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">          <span class="built_in">NSError</span> *localError = <span class="literal">nil</span>;</span><br><span class="line">          <span class="comment">// Check for success of loading the assets tracks.</span></span><br><span class="line">          success = ([<span class="keyword">self</span>.asset statusOfValueForKey:<span class="string">@&quot;tracks&quot;</span> error:&amp;localError] == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.</span></span><br><span class="line">               <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">               <span class="built_in">NSString</span> *localOutputPath = [<span class="keyword">self</span>.outputURL path];</span><br><span class="line">               <span class="keyword">if</span> ([fm fileExistsAtPath:localOutputPath])</span><br><span class="line">                    success = [fm removeItemAtPath:localOutputPath error:&amp;localError];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> setupAssetReaderAndAssetWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> startAssetReaderAndWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:success withError:localError];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>剩下的工作就是实现取消的处理，并实现三个自定义方法.</p><h3 id="5-4-3-初始化-Asset-Reader-和-Writer"><a href="#5-4-3-初始化-Asset-Reader-和-Writer" class="headerlink" title="5.4.3 初始化 Asset Reader 和 Writer"></a>5.4.3 初始化 Asset Reader 和 Writer</h3><p>自定义方法 <code>setupAssetReaderAndAssetWriter</code> 实现了 asset Reader 和 writer 的初始化和配置。在这个示例中：</p><ul><li>audio 先被 asset reader 解压为 Linear PCM，然后被 asset write 压缩为 128 kbps AAC。</li><li>video 被 asset reader 解压为 YUV，然后被 asset writer 压缩为 H.264:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupAssetReaderAndAssetWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Create and initialize the asset reader.</span></span><br><span class="line">     <span class="keyword">self</span>.assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:<span class="keyword">self</span>.asset error:outError];</span><br><span class="line">     <span class="built_in">BOOL</span> success = (<span class="keyword">self</span>.assetReader != <span class="literal">nil</span>);</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader was successfully initialized, do the same for the asset writer.</span></span><br><span class="line">          <span class="keyword">self</span>.assetWriter = [[<span class="built_in">AVAssetWriter</span> alloc] initWithURL:<span class="keyword">self</span>.outputURL fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span> error:outError];</span><br><span class="line">          success = (<span class="keyword">self</span>.assetWriter != <span class="literal">nil</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.</span></span><br><span class="line">          <span class="built_in">AVAssetTrack</span> *assetAudioTrack = <span class="literal">nil</span>, *assetVideoTrack = <span class="literal">nil</span>;</span><br><span class="line">          <span class="built_in">NSArray</span> *audioTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line">          <span class="keyword">if</span> ([audioTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetAudioTrack = [audioTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">          <span class="built_in">NSArray</span> *videoTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">          <span class="keyword">if</span> ([videoTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetVideoTrack = [videoTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetAudioTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderAudioOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderAudioOutput];</span><br><span class="line">               <span class="comment">// Then, set the compression settings to 128kbps AAC and create the asset writer input.</span></span><br><span class="line">               AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">                    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">                    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">                    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">                    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">                    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">                    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">                    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetWriterAudioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterAudioInput];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetVideoTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is a video track to read, set the decompression settings for YUV and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123;</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey     : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderVideoOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderVideoOutput];</span><br><span class="line">               <span class="built_in">CMFormatDescriptionRef</span> formatDescription = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Grab the video format descriptions from the video track and grab the first one if it exists.</span></span><br><span class="line">               <span class="built_in">NSArray</span> *videoFormatDescriptions = [assetVideoTrack formatDescriptions];</span><br><span class="line">               <span class="keyword">if</span> ([videoFormatDescriptions count] &gt; <span class="number">0</span>)</span><br><span class="line">                    formatDescription = (__bridge <span class="built_in">CMFormatDescriptionRef</span>)[formatDescriptions objectAtIndex:<span class="number">0</span>];</span><br><span class="line">               <span class="built_in">CGSize</span> trackDimensions = &#123;</span><br><span class="line">                    .width = <span class="number">0.0</span>,</span><br><span class="line">                    .height = <span class="number">0.0</span>,</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">                    trackDimensions = <span class="built_in">CMVideoFormatDescriptionGetPresentationDimensions</span>(formatDescription, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    trackDimensions = [assetVideoTrack naturalSize];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionSettings = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *cleanAperture = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *pixelAspectRatio = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> cleanApertureFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_CleanAperture);</span><br><span class="line">                    <span class="keyword">if</span> (cleanApertureFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         cleanAperture = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureWidthKey</span>            : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHeightKey</span>           : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHorizontalOffsetKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureVerticalOffsetKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> pixelAspectRatioFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);</span><br><span class="line">                    <span class="keyword">if</span> (pixelAspectRatioFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         pixelAspectRatio = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioHorizontalSpacingKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioVerticalSpacingKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Add whichever settings we could grab from the format description to the compression settings dictionary.</span></span><br><span class="line">                    <span class="keyword">if</span> (cleanAperture || pixelAspectRatio)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="built_in">NSMutableDictionary</span> *mutableCompressionSettings = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">                         <span class="keyword">if</span> (cleanAperture)</span><br><span class="line">                              [mutableCompressionSettings setObject:cleanAperture forKey:<span class="built_in">AVVideoCleanApertureKey</span>];</span><br><span class="line">                         <span class="keyword">if</span> (pixelAspectRatio)</span><br><span class="line">                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:<span class="built_in">AVVideoPixelAspectRatioKey</span>];</span><br><span class="line">                         compressionSettings = mutableCompressionSettings;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Create the video settings dictionary for H.264.</span></span><br><span class="line">               <span class="built_in">NSMutableDictionary</span> *videoSettings = (<span class="built_in">NSMutableDictionary</span> *) @&#123;</span><br><span class="line">                    <span class="built_in">AVVideoCodecKey</span>  : <span class="built_in">AVVideoCodecH264</span>,</span><br><span class="line">                    <span class="built_in">AVVideoWidthKey</span>  : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.width],</span><br><span class="line">                    <span class="built_in">AVVideoHeightKey</span> : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.height]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// Put the compression settings into the video settings dictionary if we were able to grab them.</span></span><br><span class="line">               <span class="keyword">if</span> (compressionSettings)</span><br><span class="line">                    [videoSettings setObject:compressionSettings forKey:<span class="built_in">AVVideoCompressionPropertiesKey</span>];</span><br><span class="line">               <span class="comment">// Create the asset writer input and add it to the asset writer.</span></span><br><span class="line">               <span class="keyword">self</span>.assetWriterVideoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterVideoInput];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-重编码-Asset"><a href="#5-4-4-重编码-Asset" class="headerlink" title="5.4.4 重编码 Asset"></a>5.4.4 重编码 Asset</h3><p>方法<code>startAssetReaderAndWriter</code>负责读取和写入 asset：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)startAssetReaderAndWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">     <span class="comment">// Attempt to start the asset reader.</span></span><br><span class="line">     success = [<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">          *outError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader started successfully, attempt to start the asset writer.</span></span><br><span class="line">          success = [<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               *outError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.</span></span><br><span class="line">          <span class="keyword">self</span>.dispatchGroup = dispatch_group_create();</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is audio to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwAudioSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.audioFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterAudioInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next audio sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderAudioOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterAudioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the audio work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                         <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If we had video to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwVideoSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.videoFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterVideoInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next video sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderVideoOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterVideoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the video work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                         <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set up the notification that the dispatch group will send when the audio and video work have both finished.</span></span><br><span class="line">          dispatch_group_notify(<span class="keyword">self</span>.dispatchGroup, <span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">               <span class="built_in">BOOL</span> finalSuccess = <span class="literal">YES</span>;</span><br><span class="line">               <span class="built_in">NSError</span> *finalError = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// Check to see if the work has finished due to cancellation.</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If so, cancel the reader and writer.</span></span><br><span class="line">                    [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">                    [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If cancellation didn&#x27;t occur, first make sure that the asset reader didn&#x27;t fail.</span></span><br><span class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span>.assetReader status] == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = <span class="literal">NO</span>;</span><br><span class="line">                         finalError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If the asset reader didn&#x27;t fail, attempt to stop the asset writer and check for any errors.</span></span><br><span class="line">                    <span class="keyword">if</span> (finalSuccess)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = [<span class="keyword">self</span>.assetWriter finishWriting];</span><br><span class="line">                         <span class="keyword">if</span> (!finalSuccess)</span><br><span class="line">                              finalError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.</span></span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];</span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Return success here to indicate whether the asset reader and writer were started successfully.</span></span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重编码过程中，为了提升性能，音频处理和视频处理在两个不同队列中进行。但这两个队列在一个 dispatchGroup 中，当每个队列的任务都完成后，会发送通知。判断重新编码结果是否成功。</p><p>最后调用<code>readingAndWritingDidFinishSuccessfully:</code>。</p><h3 id="5-4-5-处理编码结果"><a href="#5-4-5-处理编码结果" class="headerlink" title="5.4.5 处理编码结果"></a>5.4.5 处理编码结果</h3><p>对重编码的结果进行处理并同步到 UI:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)readingAndWritingDidFinishSuccessfully:(<span class="built_in">BOOL</span>)success withError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 如果重新编码过程未成功完成，则asset reader、asset writer都将被取消</span></span><br><span class="line">          [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to failure.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Reencoding was successful, reset booleans.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to success.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-6-取消重编码"><a href="#5-4-6-取消重编码" class="headerlink" title="5.4.6 取消重编码"></a>5.4.6 取消重编码</h3><p>使用多个串行队列，可以很轻松的取消对 asset 的重编码。</p><ul><li>在主序列化队列上，消息被异步发送到每个 asset 重新编码序列化队列，以取消它们的读取和写入。</li><li>当这两个序列化队列完成取消时，调度组向主序列化队列发送通知，其中取消属性设置为 YES。</li></ul><p>可以将下面的代码与 UI 上的 “取消” 按钮关联起来:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Handle cancellation asynchronously, but serialize it with the main queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// If we had audio data to reencode, we need to cancel the audio work.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the audio queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwAudioSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                    <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group since the audio work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the video queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwVideoSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                    <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group, since the video work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set the cancelled Boolean property to YES to cancel any work on the main queue as well.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-AVOutputSettingsAssistant介绍"><a href="#5-5-AVOutputSettingsAssistant介绍" class="headerlink" title="5.5 AVOutputSettingsAssistant介绍"></a>5.5 AVOutputSettingsAssistant介绍</h2><p><a href="https://developer.apple.com/reference/avfoundation/avoutputsettingsassistant">AVOutputSettingsAssistant</a> 类的功能是为 asset reader 或 writer 创建设置信息。这使得设置更简单，特别是在对于具有许多特定预设的高帧率的 H264 视频进行参数设置时。</p><p>下面的代码是<code>AVOutputSettingsAssistant</code>的使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVOutputSettingsAssistant</span> *outputSettingsAssistant = [<span class="built_in">AVOutputSettingsAssistant</span> outputSettingsAssistantWithPreset:&lt;some preset&gt;];</span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> audioFormat = [<span class="keyword">self</span> getAudioFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (audioFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceAudioFormat:(<span class="built_in">CMAudioFormatDescriptionRef</span>)audioFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> videoFormat = [<span class="keyword">self</span> getVideoFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (videoFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceVideoFormat:(<span class="built_in">CMVideoFormatDescriptionRef</span>)videoFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMTime</span> assetMinVideoFrameDuration = [<span class="keyword">self</span> getMinFrameDuration];</span><br><span class="line"><span class="built_in">CMTime</span> averageFrameDuration = [<span class="keyword">self</span> getAvgFrameDuration]</span><br><span class="line"></span><br><span class="line">[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];</span><br><span class="line">[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:&lt;some URL&gt; fileType:[outputSettingsAssistant outputFileType] error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *audioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *videoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeVideo</span> outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];</span><br></pre></td></tr></table></figure><h1 id="六、时间和媒体的表示"><a href="#六、时间和媒体的表示" class="headerlink" title="六、时间和媒体的表示"></a>六、时间和媒体的表示</h1><p>AV Foundation 框架中使用的一些用来代表时间和媒体的底层数据结构来源于 Core Media 框架。</p><h2 id="6-1-时间的表示"><a href="#6-1-时间的表示" class="headerlink" title="6.1 时间的表示"></a>6.1 时间的表示</h2><p>AV Foundation 框架中的时间由一个 Core Media 框架中的数据结构表示.</p><h3 id="6-1-1-用-CMTime-表示一段时间"><a href="#6-1-1-用-CMTime-表示一段时间" class="headerlink" title="6.1.1 用 CMTime 表示一段时间"></a>6.1.1 用 CMTime 表示一段时间</h3><p><a href="https://developer.apple.com/reference/coremedia/cmtime">CMTime</a> 是一个以有理数表示时间的 C 语言结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个 int64_t 类型作为分子，一个 int32_t 类型作为分母。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeValue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> CMTimeScale;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeEpoch</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">CMTimeValuevalue;<span class="comment">/*!&lt; The value of the CMTime. value/timescale = seconds */</span></span><br><span class="line">CMTimeScaletimescale;<span class="comment">/*!&lt; The timescale of the CMTime. value/timescale = seconds. */</span></span><br><span class="line"><span class="comment">// 除了用来表示时间，CMTime还可以用来表示非数值的值：正无穷大(+infinity)，负无穷大(-infinity)，不确定(indefinite)，还可以指示时间是否在某个时间点四舍五入(HasBeenRounded)。</span></span><br><span class="line">  CMTimeFlagsflags;<span class="comment">/*!&lt; The flags, eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity, etc. */</span></span><br><span class="line">  <span class="comment">// 维护了一个纪元数（记数的起算时间）。epoch通常为0，但您可以使用不同的值，例如，在循环中。</span></span><br><span class="line">CMTimeEpochepoch;</span><br><span class="line">&#125; CMTime;</span><br></pre></td></tr></table></figure><p>从概念上来看，timescale (时间段/时间刻度) 描述了一秒中包含多少个时间单元。</p><ul><li>如果 timescale 等于 4，则每个时间单元代表四分之一秒；</li><li>如果果 timescale 等于 10，则每个时间单元代表十分之一秒，以此类推；</li><li>经常使用 600 的 timescale ，因为这是几个常用帧速率的倍数：电影 24 fps、NTSC 30 fps（用于北美和日本的电视）和 PAL 25 fps（用于电视欧洲）。使用 600 的timescale，可以准确地表示这些系统中的任意数量的帧。</li></ul><h4 id="1-CMTime的创建与使用"><a href="#1-CMTime的创建与使用" class="headerlink" title="1. CMTime的创建与使用"></a>1. CMTime的创建与使用</h4><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1400785-cmtimemake">CMTimeMake</a> 或者 <a href="https://developer.apple.com/reference/coremedia/1400797-cmtimemakewithseconds">CMTimeMakeWithSeconds</a> 创建一个时间。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用value和时间刻度的有效 CMTime。 Epoch 隐含为 0。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMake</span>(int64_t value, int32_t timescale);</span><br><span class="line"><span class="comment">// 使用秒数和首选时间刻度生成 CMTime。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMakeWithSeconds</span>(Float64 seconds, int32_t preferredTimescale)</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> time1 = <span class="built_in">CMTimeMake</span>(<span class="number">200</span>, <span class="number">2</span>); <span class="comment">// 200 1/2秒</span></span><br><span class="line"><span class="built_in">CMTime</span> time2 = <span class="built_in">CMTimeMake</span>(<span class="number">400</span>, <span class="number">4</span>); <span class="comment">// 400 1/4秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// time1 和 time2 都代表 100 秒，但使用不同的时间刻度。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTimeCompare</span>(time1, time2) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time1 and time2 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Float64 float64Seconds = <span class="number">200.0</span> / <span class="number">3</span>;</span><br><span class="line"><span class="built_in">CMTime</span> time3 = <span class="built_in">CMTimeMakeWithSeconds</span>(float64Seconds , <span class="number">3</span>); <span class="comment">// 66.66... third-seconds</span></span><br><span class="line">time3 = <span class="built_in">CMTimeMultiply</span>(time3, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//  time3 现在代表 200 秒；接下来减去 time1（100 秒）</span></span><br><span class="line">time3 = <span class="built_in">CMTimeSubtract</span>(time3, time1);</span><br><span class="line"><span class="built_in">CMTimeShow</span>(time3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_COMPARE_INLINE</span>(time2, ==, time3)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time2 and time3 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细信息参见 <a href="https://developer.apple.com/reference/coremedia/1669288-cmtime"><em>CMTime Reference</em></a>.</p><h4 id="2-CMTime-的特殊值与判断宏"><a href="#2-CMTime-的特殊值与判断宏" class="headerlink" title="2. CMTime 的特殊值与判断宏"></a>2. CMTime 的特殊值与判断宏</h4><p>Core Media 框架提供了一些常量:</p><ul><li><code>kCMTimeZero</code></li><li><code>kCMTimeInvalid</code></li><li><code>kCMTimePositiveInfinity</code> </li><li><code>kCMTimeNegativeInfinity</code>。</li></ul><p><code>CMTime</code>结构体能够进行很多操作，比如要判断一个时间是否有效(是否为非数字值)，可以使用一些定义好的宏：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_VALID(time) ((Boolean)(((time).flags &amp; kCMTimeFlags_Valid) != 0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INVALID(time) (! CMTIME_IS_VALID(time))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_POSITIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_PositiveInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NEGATIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_NegativeInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INDEFINITE(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_Indefinite) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NUMERIC(time) ((Boolean)(((time).flags &amp; (kCMTimeFlags_Valid | kCMTimeFlags_ImpliedValueFlagsMask)) == kCMTimeFlags_Valid))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_HAS_BEEN_ROUNDED(time) ((Boolean)(CMTIME_IS_NUMERIC(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_HasBeenRounded) != 0)))</span></span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> myTime = &lt;#Get a <span class="built_in">CMTime</span>#&gt;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_IS_INVALID</span>(myTime)) &#123;</span><br><span class="line">    <span class="comment">// Perhaps treat this as an error; display a suitable alert to the user.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能将 CMTime 结构体与<code>kCMTimeZero</code>直接进行比较。</p><h4 id="3-将-CMTime-转换为对象"><a href="#3-将-CMTime-转换为对象" class="headerlink" title="3. 将 CMTime 转换为对象"></a>3. 将 CMTime 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTime，使用方法 <a href="https://developer.apple.com/reference/coremedia/1400845-cmtimecopyasdictionary">CMTimeCopyAsDictionary</a> 和 <a href="https://developer.apple.com/reference/coremedia/1400819-cmtimemakefromdictionary">CMTimeMakeFromDictionary</a> 可以在 CMTime 结构体和<code>CFDictionary</code>类型 (参见 <a href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1400791-cmtimecopydescription">CMTimeCopyDescription</a> 可以获取 CMTime 结构体的字符串描述。</p><h4 id="4-纪元-Epochs"><a href="#4-纪元-Epochs" class="headerlink" title="4. 纪元 (Epochs)"></a>4. 纪元 (Epochs)</h4><p><code>CMTime</code>结构体中的 epoch 通常被设置为 0。但有些场景下，可以用到，比如在循环中，可以使用这个值来区分不同循环次数中的同一个时间点。</p><h3 id="6-1-2-用-CMTimeRange-表示一个时间范围"><a href="#6-1-2-用-CMTimeRange-表示一个时间范围" class="headerlink" title="6.1.2 用 CMTimeRange 表示一个时间范围"></a>6.1.2 用 CMTimeRange 表示一个时间范围</h3><p>CMTimeRange 是一个 C 语言结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CMTime  start;<span class="comment">// 起始时间</span></span><br><span class="line">    CMTime  duration;<span class="comment">// 持续时间</span></span><br><span class="line">&#125; CMTimeRange;</span><br><span class="line"></span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeMake</span><span class="params">(CMTime start, CMTime duration)</span></span>;</span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeFromTimeToTime</span><span class="params">(CMTime start, CMTime end)</span></span>;</span><br></pre></td></tr></table></figure><p>一个时间范围并不包含<code>start</code>加上<code>duration</code>得到的时间。（是个数学上的开区间，不包含后边界）</p><p>使用上面两个方法可以创建一个时间范围，但是存在一些限制:</p><ul><li><code>CMTimeRange</code>不能跨过不同的<code>epoch</code>。</li><li><code>start</code>的<code>epoch</code>值可能不为0，我们只能对<code>start</code>的<code>epoch</code>值相同的 CMTimeRange 进行范围操作(例如 CMTimeRangeGetUnion)。</li><li><code>duration</code>的<code>epoch</code>值应该一直为 0，<code>value</code> 值为非负。</li></ul><h4 id="1-处理-CMTimeRange"><a href="#1-处理-CMTimeRange" class="headerlink" title="1. 处理 CMTimeRange"></a>1. 处理 CMTimeRange</h4><p>Core Media 框架提供了一些一个时间范围操作方法：</p><ul><li>判断一个时间范围是否包含某个时间点或者其他时间范围的方法</li><li>判断两个时间范围是否相同</li><li>对两个时间范围进行交集和并集运算的方法。</li></ul><p>例如，<a href="https://developer.apple.com/reference/coremedia/1462775-cmtimerangecontainstime">CMTimeRangeContainsTime</a>，<a href="https://developer.apple.com/reference/coremedia/1462841-cmtimerangeequal">CMTimeRangeEqual</a>，<a href="https://developer.apple.com/reference/coremedia/1462830-cmtimerangecontainstimerange">CMTimeRangeContainsTimeRange</a> 和 <a href="https://changjianfeishui.gitbooks.io/avfoundation-programming-guide/CMTimeRangeGetUnion">CMTimeRangeGetUnion</a>.</p><p>注意下面的表达式永远返回 false(<em>包前不包后，前闭后开</em>)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTimeRangeContainsTime</span>(range, <span class="built_in">CMTimeRangeGetEnd</span>(range));</span><br></pre></td></tr></table></figure><p>更多相关的详细信息，参见 <a href="https://developer.apple.com/reference/coremedia/1665980-cmtimerange"><em>CMTimeRange Reference</em></a>.</p><h4 id="2-CMTimeRange-的特殊值"><a href="#2-CMTimeRange-的特殊值" class="headerlink" title="2. CMTimeRange 的特殊值"></a>2. CMTimeRange 的特殊值</h4><p>Core Media 提供了两个常量：</p><ul><li>kCMTimeRangeZero：表示空范围</li><li>kCMTimeRangeInvalid：表示无效范围</li></ul><p>可以使用以下这些宏对 CMTimeRange 的特殊值进行判断: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_VALID(range) ((Boolean)(CMTIME_IS_VALID(range.start) &amp;&amp; CMTIME_IS_VALID(range.duration) &amp;&amp; (range.duration.epoch == 0) &amp;&amp; (range.duration.value &gt;= 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INVALID(range) (! CMTIMERANGE_IS_VALID(range))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INDEFINITE(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_IS_INDEFINITE(range.start) || CMTIME_IS_INDEFINITE(range.duration))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_EMPTY(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_COMPARE_INLINE(range.duration, ==, kCMTimeZero))))</span></span><br></pre></td></tr></table></figure><p>不能将 CMTimeRange 结构体与<code>kCMTimeRangeInvalid</code>直接进行比较。</p><h4 id="3-将-CMTimeRange-转换为对象"><a href="#3-将-CMTimeRange-转换为对象" class="headerlink" title="3. 将 CMTimeRange 转换为对象"></a>3. 将 CMTimeRange 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTimeRange，使用方法 <a href="https://developer.apple.com/reference/coremedia/1462781-cmtimerangecopyasdictionary">CMTimeRangeCopyAsDictionary</a> 和 <a href="https://developer.apple.com/reference/coremedia/1462777-cmtimerangemakefromdictionary">CMTimeRangeMakeFromDictionary</a> 可以在 CMTimeRange 结构体和<code>CFDictionary</code>类型 (参见 <a href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p><p>使用方法 <a href="https://developer.apple.com/reference/coremedia/1462823-cmtimerangecopydescription">CMTimeRangeCopyDescription</a> 可以获取 CMTimeRange 结构体的字符串描述.</p><h2 id="6-2-媒体的表示-CMSampleBuffer"><a href="#6-2-媒体的表示-CMSampleBuffer" class="headerlink" title="6.2 媒体的表示(CMSampleBuffer)"></a>6.2 媒体的表示(CMSampleBuffer)</h2><p>视频数据和与其相关联的元数据都使用 Core Media 框架中的对象类型来表示。</p><p>Core Media 使用<code>CMSampleBuffer</code>(参见 <a href="https://developer.apple.com/reference/coremedia/cmsamplebuffer">CMSampleBufferRef</a>) 类型表示视频数据。</p><blockquote><p>CMSampleBuffers 是包含零个或多个特定媒体类型（音频、视频、多路混合等）的压缩（或未压缩）样本的 CF 对象，用于在媒体系统中移动媒体样本数据。</p><p>CMSampleBuffer 可以包含一个或多个媒体样本的 CMBlockBuffer 或 CVImageBuffer、CMSampleBuffer 流的格式描述、每个包含的媒体样本的大小和时间信息，以及缓冲区级别(buffer-level)和样本级别(sample-level)的附件。</p></blockquote><p>一个<code>CMSampleBuffer</code>对象是一个包含了视频数据帧的 sample buffer(样本缓冲区)，用来作为 Core Video pixel buffer(核心视频像素缓冲区，参见 <a href="https://developer.apple.com/reference/corevideo/cvpixelbufferref">CVPixelBufferRef</a>)。</p><p>可以使用 <a href="https://developer.apple.com/reference/coremedia/1489236-cmsamplebuffergetimagebuffer">CMSampleBufferGetImageBuffer</a> 方法访问 sample buffer 中的 pixel buffer.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(&lt;#A <span class="built_in">CMSampleBuffer</span>#&gt;);</span><br></pre></td></tr></table></figure><p>可以在 pixel buffer 访问到实际的视频数据，参见下节示例代码。</p><p>除了视频数据而言，还可以获取视频帧其他方面的信息:</p><ul><li><p><strong>时间信息</strong>: 使用 <a href="https://developer.apple.com/reference/coremedia/1489252-cmsamplebuffergetpresentationtim">CMSampleBufferGetPresentationTimeStamp</a> 和 <a href="https://developer.apple.com/reference/coremedia/1489404-cmsamplebuffergetdecodetimestamp">CMSampleBufferGetDecodeTimeStamp</a> 可以分别获取视频帧的初始时间和解码时间。</p></li><li><p><strong>格式信息</strong>: 包含在一个<code>CMFormatDescription</code>对象中 (参见 <a href="https://developer.apple.com/reference/coremedia/cmformatdescriptionref">CMFormatDescriptionRef</a>)。从格式描述 对象中，可以：</p><ul><li>使用<code>CMVideoFormatDescriptionGetCodecType</code>获取视频的编码信息</li><li>使用<code>CMVideoFormatDescriptionGetDimensions</code>获取视频尺寸。</li></ul></li><li><p><strong>元数据</strong>: 以附件形式存储在一个字典中，通过 <a href="https://developer.apple.com/reference/coremedia/1470707-cmgetattachment">CMGetAttachment</a> 获取:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMSampleBufferRef</span> sampleBuffer = &lt;#Get a sample buffer#&gt;;</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> metadataDictionary =</span><br><span class="line">    <span class="built_in">CMGetAttachment</span>(sampleBuffer, <span class="built_in">CFSTR</span>(<span class="string">&quot;MetadataDictionary&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (metadataDictionary) &#123;</span><br><span class="line">    <span class="comment">// Do something with the metadata.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-3-将CMSampleBuffer转换为UIImage"><a href="#6-3-将CMSampleBuffer转换为UIImage" class="headerlink" title="6.3 将CMSampleBuffer转换为UIImage"></a>6.3 将CMSampleBuffer转换为UIImage</h2><p>下面的代码示例了如何将<code>CMSampleBuffer</code>转换为<code>UIImage</code>。这个转换相当消耗性能，使用时必须进行谨慎考虑。</p><p>例如，它适用于从大约每秒钟拍摄的一帧视频数据创建静态图像。您不应该将此作为实时操作来自捕获设备的每一帧视频的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a UIImage from sample buffer data</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *) imageFromSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>) sampleBuffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get a CMSampleBuffer&#x27;s Core Video image buffer for the media data</span></span><br><span class="line">    CVImageBufferRef imageBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line">    <span class="comment">// Lock the base address of the pixel buffer</span></span><br><span class="line">    CVPixelBufferLockBaseAddress(imageBuffer, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    <span class="keyword">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class="line">    <span class="comment">// Get the pixel buffer width and height</span></span><br><span class="line">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class="line">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a device-dependent RGB color space</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a bitmap graphics context with the sample buffer data</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(baseAddress, width, height, <span class="number">8</span>,</span><br><span class="line">      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    <span class="comment">// Create a Quartz image from the pixel data in the bitmap graphics context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> quartzImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="comment">// Unlock the pixel buffer</span></span><br><span class="line">    CVPixelBufferUnlockBaseAddress(imageBuffer,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Free up the context and color space</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create an image object from the Quartz image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:quartzImage];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Release the Quartz image</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(quartzImage);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、并发编程"><a href="#七、并发编程" class="headerlink" title="七、并发编程"></a>七、并发编程</h1><p>来自 AVFoundation 的回调 —— block、KVO、notification，都不能保证会在任何特定线程或队列上进行。相反，AVFoundation 会在任务的线程或队列上执行这些回调。</p><p>两个有关通知和线程的准则：</p><ul><li>UI 相关的通知必须在主线程中发送</li><li>需要创建或指定一个队列的类或方法，将在该队列上返回通知</li></ul><p>除了这两个准则之外，您不应该假设将在任何特定线程上返回通知。</p><p>如果你正在编写一个多线程的应用程序，你可以使用 NSThread 类的下面方法来判断当前是否是你所需要的线程： </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread;</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSThread</span> currentThread] isEqual:&lt;#A stored thread reference#&gt;] </span><br></pre></td></tr></table></figure><p>可以使用 NSObject 下面的方法来指定线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector </span><br><span class="line">                         withObject:(nullable id)arg </span><br><span class="line">                      waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">               onThread:(NSThread *)thr </span><br><span class="line">             withObject:(nullable id)arg </span><br><span class="line">          waitUntilDone:(BOOL)wait </span><br><span class="line">                  modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>dispatch_async</code>将回调 block 放到合适的线程中执行。</p><ul><li>更多并发编程的资料参考：<a href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091"><em>Concurrency Programming Guide.</em></a> </li><li>更多 block 相关资料参见 <a href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502"><em>Blocks Programming Topics</em></a>. </li><li>示例代码 <a href="https://developer.apple.com/library/prerelease/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112"><em>AVCam-iOS: Using AVFoundation to Capture Images and Movies</em></a> 是 AVFoundation 的一个基础示例， 并展示了一些 AVFoundation 中线程和队列的用法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AVFoundation概述&quot;&gt;&lt;a href=&quot;#AVFoundation概述&quot; class=&quot;headerlink&quot; title=&quot;AVFoundation概述&quot;&gt;&lt;/a&gt;AVFoundation概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;译文，原文链接：&lt;</summary>
      
    
    
    
    <category term="音视频处理" scheme="https://tenloy.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS音视频库概述</title>
    <link href="https://tenloy.github.io/2022/03/17/avframework.html"/>
    <id>https://tenloy.github.io/2022/03/17/avframework.html</id>
    <published>2022-03-17T08:29:54.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 和 OS X 平台都有一系列操作音视频的 API，其中涵盖了从低到高的全部层级。随着时间的推移、平台的增长以及改变，不同 API 的数量可以说有着非常巨大的变化。本文对当前可以使用的 API 以及它们使用的不同目的进行简要的概括。</p><h1 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h1><ul><li><p>iOS 框架：MediaPlayer、AVKit、AVFoundation、AudioToolbox、AudioUnit、OpenAL。</p><ul><li>其中AVKit、MediaPlayer 、 AVFoundation 是基于 Objective-C/Swift 的； AudioToolBox 、 AudioUnit 和 OpenAL 是基于 C 的。</li></ul></li><li><p>第三方库：FFmpeg 、 FAAC 、 FAAD2。</p></li></ul><h2 id="Media-Player"><a href="#Media-Player" class="headerlink" title="Media Player"></a>Media Player</h2><p>Media Player 框架是 iOS 平台上一个用于音频和视频播放的高层级接口，它包含了一个你可以在应用中直接使用的默认的用户界面。你可以使用它来播放用户在 iPod 库中的项目，或者播放本地文件以及网络流。</p><p>另外，这个框架也包括了查找用户媒体库中内容的 API，同时还可以配置像是在锁屏界面或者控制中心里的音频控件。</p><ul><li>使用 MPMusicPlayerController 播放音频文件。 </li></ul><h2 id="AVKit"><a href="#AVKit" class="headerlink" title="AVKit"></a>AVKit</h2><p>为媒体播放创建用户界面，包括传输控件、章节导航、画中画支持以及字幕和隐藏式字幕的显示。</p><ul><li>使用 AVPlayerController 播放音频文件或流。 </li></ul><h2 id="AVFoundation"><a href="#AVFoundation" class="headerlink" title="AVFoundation"></a>AVFoundation</h2><blockquote><p>定义视听资产，控制设备摄像头，处理音频和配置系统音频交互。</p><p>结合了六大技术领域，共同涵盖了在 Apple 平台上捕获、处理、合成、控制、导入和导出视听媒体的广泛任务。</p></blockquote><p>AVFoundation 是苹果的现代媒体框架，它包含了一些不同的用途的 API 和不同层级的抽象。其中有一些是现代 Objective-C 对于底层 C 语言接口的封装。除了少数的例外情况，<code>AVFoundation</code> 可以同时在 iOS 和 OS X 中使用。</p><ul><li>AVAudioSession 操作音频会话</li><li>AVAudioFile(iOS8) 读写音频文件</li><li>AVAudioRecorder 录制音频文件</li><li>AVAudioPlayer 和 AVPlayer 播放音频文件</li><li>AVCaptureSession 录制音频和视频数据。 </li><li>在 iOS 8 之前使用 AVAssetWritter 将 PCM 音频写入 AAC LC 编码格式的音频文件，而且使用的是硬编码。 </li><li>在 iOS 8 及以后可以使用 AVAudioEngine 进行均衡器、混响和混音等操作，其基于底层的 AudioUnit ，但比后者更易用。 </li></ul><h3 id="AVAudioSession"><a href="#AVAudioSession" class="headerlink" title="AVAudioSession"></a>AVAudioSession</h3><p>AVAudioSession 是用于 iOS 系统中协调应用程序之间的音频播放的 API 的。例如，当有电话打进来时，音频的播放就会被暂停；在用户启动电影时，音乐的播放就会停止。我们需要使用这些 API 来确保一个应用程序能够正确响应并处理这类事件。</p><h3 id="AVAudioPlayer"><a href="#AVAudioPlayer" class="headerlink" title="AVAudioPlayer"></a>AVAudioPlayer</h3><p>这个高层级的 API 为你提供一个简单的接口，用来播放本地或者内存中的音频。这是一个无界面的音频播放器 (也就是说没有提供 UI 元素)，使用起来也很直接简单。它不适用于网络音频流或者低延迟的实时音频播放。如果这些问题都不需要担心，那么 <code>AVAudioPlayer</code> 可能就是正确的选择。音频播放器的 API 也为我们带来了一些额外的功能，比如循环播放、获取音频的音量强度等等。</p><h3 id="AVAudioRecorder"><a href="#AVAudioRecorder" class="headerlink" title="AVAudioRecorder"></a>AVAudioRecorder</h3><p>作为与 <code>AVAudioPlayer</code> 相对应的 API，<code>AVAudioRecorder</code> 是将音频录制为文件的最简单的方法。除了用一个音量计接受音量的峰值和平均值以外，这个 API 简单粗暴，但要是你的使用场景很简单的话，这可能恰恰就是你想要的方法。</p><h3 id="AVPlayer"><a href="#AVPlayer" class="headerlink" title="AVPlayer"></a>AVPlayer</h3><p>AVPlayer 与上面提到的 API 相比，提供了更多的灵活性和可控性。它基于 <code>AVPlayerItem</code> 和 <code>AVAsset</code>，为你提供了颗粒度更细的权限来获取资源，比如选择指定的音轨。它还通过 <code>AVQueuePlayer</code> 子类支持播放列表，而且你可以控制这些资源是否能够通过 AirPlay 发送。</p><p>与 <code>AVAudioPlayer</code> 最主要的区别是，<code>AVPlayer</code> 对来自网络的流媒体资源的 “开箱即用” 支持。这增加了处理播放状态的复杂性，但是你可以使用 KVO 来观测所有的状态参数来解决这个问题。</p><h3 id="AVAudioEngine"><a href="#AVAudioEngine" class="headerlink" title="AVAudioEngine"></a>AVAudioEngine</h3><p>AVAudioEngine 是播放和录制的 Objective-C 接口。它提供了以前需要深入到 Audio Toolbox 框架的 C API 才能做的控制 (例如一些实时音频任务)。该音频引擎 API 对底层的 API 建立了优秀的接口。如果你不得不处理底层的问题，你仍然可以使用 Audio Toolbox 框架。</p><p>这个 API 的基本概念是建立一个音频的节点图，从源节点 (播放器和麦克风) 以及过处理 (overprocessing) 节点 (混音器和效果器) 到目标节点 (硬件输出)。每一个节点都具有一定数量的输入和输出总线，同时这些总线也有良好定义的数据格式。这种结构使得它非常的灵活和强大。而且它集成了音频单元 (audio unit)。</p><h2 id="AudioToolbox"><a href="#AudioToolbox" class="headerlink" title="AudioToolbox"></a>AudioToolbox</h2><p>Audio Toolbox 框架是强大的，但是它的层级却非常的低。在过去，它基于 C++ 所编写，但是<strong>其大多数的功能现在都可以通过 <code>AVFoundation</code> 实现。</strong></p><p>简单介绍：</p><ul><li>System Sound Services 播放音频文件、</li><li>Audio Queue Services 录制和播放音频数据</li><li>Audio Converter Services 进行音频转码(格式、 bit-depth 和采样率)</li><li>Audio File Services 和 AudioFileStream 读写音频文件。 </li></ul><h2 id="Audio-Unit"><a href="#Audio-Unit" class="headerlink" title="Audio Unit"></a>Audio Unit</h2><p>Audio Unit 框架是一个底层的 API；所有 iOS 中的音频技术都构建在 Audio Unit 这个框架之上。音频单元是用来加工音频数据的插件。一个音频单元链叫做音频处理图。</p><p>如果你需要<strong>非常低的延迟 (如 VoIP 或合成乐器)、回声消除、混音或者音调均衡</strong>的话，你可能需要直接使用音频单元，或者自己写一个音频单元。但是其中的大部分工作可以使用 <code>AVAudioEngine</code> 的 API 来完成。如果你不得不写自己的音频单元的话，你可以将它们与 <code>AVAudioUnit</code> 节点一起集成在 <code>AVAudioEngine</code> 处理图中。</p><h3 id="跨应用程序音频"><a href="#跨应用程序音频" class="headerlink" title="跨应用程序音频"></a>跨应用程序音频</h3><p>Audio Unit 的 API 可以在 iOS 中进行跨应用音频。音频流 (和 MIDI 命令) 可以在应用程序之间发送。比如说：一个应用程序可以提供音频的效果器或者滤波器。另一个应用程序可以将它的音频发送到第一个应用程序中，并使用其中的音频效果器处理音频。被过滤的音频又会被实时地发送回原来的应用程序中。 CoreAudioKit 提供了一个简单的跨应用程序的音频界面。</p><h2 id="OpenAL"><a href="#OpenAL" class="headerlink" title="OpenAL"></a>OpenAL</h2><p><a href="https://en.wikipedia.org/wiki/OpenAL">OpenAL</a> 是一个跨平台的 API。它提供了位置 (3D) 和低延迟的音频服务。它主要用于跨平台游戏的开发。它有意地模仿了 OpenGL 中 API 的风格。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>MIDI</strong>：在 iOS 上，Core MIDI 和 CoreAudioKit 可以被用来使应用程序表现为 MIDI 设备。在 OS X 上，Music Sequencing 服务提供了基于 MIDI 的控制和对音乐数据访问的权限。Core MIDI 服务为服务器和驱动程序提供了支持。</li><li>在 OS X 中，最基本的音频接口就是 <code>NSBeep()</code>，它能够简单地播放系统中的声音。</li><li><strong>NSSound 类</strong>：为 OS X 提供了用于播放声音的简单接口，与 iOS 中的 <code>AVAudioPlayer</code> 在概念上基本类似。</li><li>所有的通知 API，包括 iOS 中的本地通知或者推送通知、OS X 中的 <code>NSUserNotification</code> 以及 CloudKit 通知，都可以播放声音。</li><li>QTKit 和 QuickTime 框架现在已经过时了，它们不应该被用在以后的开发中。我们应该使用 <code>AVFoundation</code> (和 AVKit) 来代替它们。</li></ul><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><ul><li>FAAC：将 PCM 软编码为 AAC LC。 </li><li>FFmpeg、FAAD2：将 AAC LC 软解码为 PCM 、 PCM 重采样(Resample)。</li></ul><h1 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h1><ul><li><p>iOS 框架：MediaPlayer、AVKit、UIKit、AVFoundation、VideoToolBox、GLKit(OpenGL ES) 。</p><ul><li>其中 MediaPlayer、AVKit、UIKit、AVFoundation基于 Objective-C ； VideoToolBox 和 GLKit 基于 C 的。当然， GLKit 远远不只是可以渲染视频。</li></ul></li><li><p>第三方库 FFmpeg 、 x264。</p></li></ul><img src="https://tenloy.github.io/images/avf/frameworksBlockDiagram_2x.png" alt="img" style="zoom:70%;" /><h2 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h2><ul><li>使用 MPMoviePlayerViewController(MPMoviePlayerController/MPMoviePlayer) 播放视频文件或流。 </li></ul><h2 id="AVKit-1"><a href="#AVKit-1" class="headerlink" title="AVKit"></a>AVKit</h2><ul><li>使用 AVPlayerController 播放视频文件或流。 </li></ul><h2 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h2><ul><li>使用 UIImagePickerController 录制包含音频的视频文件</li><li>使用 UIVideoEditorController 可对视频进行简单编辑。 </li></ul><h2 id="AVFoundation-1"><a href="#AVFoundation-1" class="headerlink" title="AVFoundation"></a>AVFoundation</h2><ul><li>使用 AVPlayer 播放视频文件或流</li><li>使用AVCaptureSession 录制视频帧。 </li><li>在 iOS 8 之前使用 AVFoundation 框架的 AVAssetWritter 将 YUV 数据写入 H.264 编码格式的视频文件，而且使用的是硬编码。 </li></ul><h2 id="VideoToolBox"><a href="#VideoToolBox" class="headerlink" title="VideoToolBox"></a>VideoToolBox</h2><p>在 iOS 8 及以后使用 VideoToolBox 框架将 YUV 视频数据硬编码为 H.264 ，以及将 H.264 硬解码为 YUV 视频数据。 </p><h2 id="GLKit"><a href="#GLKit" class="headerlink" title="GLKit"></a>GLKit</h2><p>使用 GLKit 将 sRGB 或 YUV 视频数据渲染输出到屏幕。 </p><h2 id="第三方库-1"><a href="#第三方库-1" class="headerlink" title="第三方库"></a>第三方库</h2><ul><li>FFmpeg：将 H.264 软解码为 YUV 。 </li><li>x264：将 YUV 视频软编码为 H.264 。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;iOS 和 OS X 平台都有一系列操作音视频的 API，其中涵盖了从低到高的全部层级。随着时间的推移、平台的增长以及改变，不同 API 的数量可以说有着非常巨大的变化。本文对当前可以使用的 API 以及它们使用的不同目的进行简要的概括。&lt;/p&gt;
&lt;h1 id=&quot;Audio</summary>
      
    
    
    
    <category term="音视频处理" scheme="https://tenloy.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] OAuth 2.0简述</title>
    <link href="https://tenloy.github.io/2022/02/09/OAuth.html"/>
    <id>https://tenloy.github.io/2022/02/09/OAuth.html</id>
    <published>2022-02-09T17:03:25.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 —— <a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释 —— 阮一峰</a></p></blockquote><p>OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p><blockquote><p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p></blockquote><p>这段话的意思就是，<strong>OAuth 是一种授权机制，核心就是向第三方应用颁发令牌(token)。</strong>以获取用户数据</p><p>然后，RFC 6749 接着写道：</p><blockquote><p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p></blockquote><p>下面就是重点讲解这两点：OAuth的运行流程、四种授权方式</p><h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p><p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p><p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p><p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p><ol><li>“云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</li><li>Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</li><li>“云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</li><li>用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</li><li>只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</li></ol><p>OAuth就是为了解决上面这些问题而诞生的。</p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h1 id="二、令牌与密码"><a href="#二、令牌与密码" class="headerlink" title="二、令牌与密码"></a>二、令牌与密码</h1><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><h1 id="三、OAuth的思路与运行流程"><a href="#三、OAuth的思路与运行流程" class="headerlink" title="三、OAuth的思路与运行流程"></a>三、OAuth的思路与运行流程</h1><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。<ul><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul></li><li><strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li></ul><p>OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。</p><ul><li>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。</li><li>“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</li><li>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</li></ul><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051203.png"></p><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><h1 id="四、四种授权方式"><a href="#四、四种授权方式" class="headerlink" title="四、四种授权方式"></a>四、四种授权方式</h1><p><strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><h2 id="4-1-授权码"><a href="#4-1-授权码" class="headerlink" title="4.1 授权码"></a>4.1 授权码</h2><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040902.jpg" alt="img"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040907.jpg" alt="img"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040904.jpg" alt="img"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040905.jpg" alt="img"></p><h2 id="4-2-隐藏式"><a href="#4-2-隐藏式" class="headerlink" title="4.2 隐藏式"></a>4.2 隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019040906.jpg" alt="img"></p><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p><h2 id="4-3-密码式"><a href="#4-3-密码式" class="headerlink" title="4.3 密码式"></a>4.3 密码式</h2><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p><h2 id="4-4-凭证式"><a href="#4-4-凭证式" class="headerlink" title="4.4 凭证式"></a>4.4 凭证式</h2><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h1 id="五、令牌的使用"><a href="#五、令牌的使用" class="headerlink" title="五、令牌的使用"></a>五、令牌的使用</h1><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure><p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p><h1 id="六、令牌的更新"><a href="#六、令牌的更新" class="headerlink" title="六、令牌的更新"></a>六、令牌的更新</h1><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p><h1 id="七、示例-GitHub-OAuth第三方登录"><a href="#七、示例-GitHub-OAuth第三方登录" class="headerlink" title="七、示例: GitHub OAuth第三方登录"></a>七、示例: GitHub OAuth第三方登录</h1><p>今天演示一个实例，如何通过 OAuth 获取 API 数据。</p><p>很多网站登录时，允许使用第三方网站的身份，这称为”第三方登录”。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042101.jpg" alt="img"></p><p>下面就以 GitHub 为例，写一个最简单的应用，演示第三方登录。</p><h2 id="7-1-第三方登录的原理"><a href="#7-1-第三方登录的原理" class="headerlink" title="7.1 第三方登录的原理"></a>7.1 第三方登录的原理</h2><p>所谓第三方登录，实质就是 OAuth 授权。用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>举例来说，A 网站允许 GitHub 登录，背后就是下面的流程。</p><ol><li>A 网站让用户跳转到 GitHub。</li><li>GitHub 要求用户登录，然后询问”A 网站要求获得 xx 权限，你是否同意？”</li><li>用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。</li><li>A 网站使用授权码，向 GitHub 请求令牌。</li><li>GitHub 返回令牌.</li><li>A 网站使用令牌，向 GitHub 请求用户数据。</li></ol><p>下面就是这个流程的代码实现。</p><h2 id="7-2-应用登记"><a href="#7-2-应用登记" class="headerlink" title="7.2 应用登记"></a>7.2 应用登记</h2><p>一个应用要求 OAuth 授权，必须先到对方网站登记，让对方知道是谁在请求。</p><p>所以，你要先去 GitHub 登记一下。当然，我已经登记过了，你使用我的登记信息也可以，但为了完整走一遍流程，还是建议大家自己登记。这是免费的。</p><p>访问这个<a href="https://github.com/settings/applications/new">网址</a>，填写登记表。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042102.jpg" alt="img"></p><p>应用的名称随便填，主页 URL 填写<code>http://localhost:8080</code>，跳转网址填写 <code>http://localhost:8080/oauth/redirect</code>。</p><p>提交表单以后，GitHub 应该会返回客户端 ID（client ID）和客户端密钥（client secret），这就是应用的身份识别码。</p><h2 id="7-3-示例仓库"><a href="#7-3-示例仓库" class="headerlink" title="7.3 示例仓库"></a>7.3 示例仓库</h2><p>我写了一个<a href="https://github.com/ruanyf/node-oauth-demo">代码仓库</a>，请将它克隆到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:ruanyf/node-oauth-demo.git</span><br><span class="line">$ <span class="built_in">cd</span> node-oauth-demo</span><br></pre></td></tr></table></figure><p>两个配置项要改一下，写入上一步的身份识别码。</p><ul><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L3"><code>index.js</code></a>：改掉变量<code>clientID</code> and <code>clientSecret</code></li><li><a href="https://github.com/ruanyf/node-oauth-demo/blob/master/public/index.html#L16"><code>public/index.html</code></a>：改掉变量<code>client_id</code></li></ul><p>然后，安装依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure><p>浏览器访问<code>http://localhost:8080</code>，就可以看到这个示例了。</p><h2 id="7-4-浏览器跳转-GitHub"><a href="#7-4-浏览器跳转-GitHub" class="headerlink" title="7.4 浏览器跳转 GitHub"></a>7.4 浏览器跳转 GitHub</h2><p>示例的首页很简单，就是一个链接，让用户跳转到 GitHub。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042103.jpg" alt="img"></p><p>跳转的 URL 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?</span><br><span class="line">  client_id&#x3D;7e015d8ce32370079895&amp;</span><br><span class="line">  redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect</span><br></pre></td></tr></table></figure><p>这个 URL 指向 GitHub 的 OAuth 授权网址，带有两个参数：<code>client_id</code>告诉 GitHub 谁在请求，<code>redirect_uri</code>是稍后跳转回来的网址。</p><p>用户点击到了 GitHub，GitHub 会要求用户登录，确保是本人在操作。</p><h2 id="7-5-授权码"><a href="#7-5-授权码" class="headerlink" title="7.5 授权码"></a>7.5 授权码</h2><p>登录后，GitHub 询问用户，该应用正在请求数据，你是否同意授权。</p><p><img src="https://www.wangbase.com/blogimg/asset/201904/bg2019042104.png" alt="img"></p><p>用户同意授权， GitHub 就会跳转到<code>redirect_uri</code>指定的跳转网址，并且带上授权码，跳转回来的 URL 就是下面的样子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;redirect?</span><br><span class="line">  code&#x3D;859310e7cecc9196f4af</span><br></pre></td></tr></table></figure><p>后端收到这个请求以后，就拿到了授权码（<code>code</code>参数）。</p><h2 id="7-6-后端实现"><a href="#7-6-后端实现" class="headerlink" title="7.6 后端实现"></a>7.6 后端实现</h2><p>示例的<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js">后端</a>采用 Koa 框架编写，具体语法请看<a href="https://www.ruanyifeng.com/blog/2017/08/koa.html">教程</a>。</p><p>这里的关键是针对<code>/oauth/redirect</code>的请求，编写一个<a href="https://github.com/ruanyf/node-oauth-demo/blob/master/index.js#L16">路由</a>，完成 OAuth 认证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oauth = <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(route.get(<span class="string">&#x27;/oauth/redirect&#x27;</span>, oauth));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>oauth</code>函数就是路由的处理函数。下面的代码都写在这个函数里面。</p><p>路由函数的第一件事，是从 URL 取出授权码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestToken = ctx.request.query.code;</span><br></pre></td></tr></table></figure><h2 id="7-7-令牌"><a href="#7-7-令牌" class="headerlink" title="7.7 令牌"></a>7.7 令牌</h2><p>后端使用这个授权码，向 GitHub 请求令牌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tokenResponse = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;https://github.com/login/oauth/access_token?&#x27;</span> +</span><br><span class="line">    <span class="string">`client_id=<span class="subst">$&#123;clientID&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`client_secret=<span class="subst">$&#123;clientSecret&#125;</span>&amp;`</span> +</span><br><span class="line">    <span class="string">`code=<span class="subst">$&#123;requestToken&#125;</span>`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub 的令牌接口<code>https://github.com/login/oauth/access_token</code>需要提供三个参数。</p><ul><li><code>client_id</code>：客户端的 ID</li><li><code>client_secret</code>：客户端的密钥</li><li><code>code</code>：授权码</li></ul><p>作为回应，GitHub 会返回一段 JSON 数据，里面包含了令牌<code>accessToken</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> accessToken = tokenResponse.data.access_token;</span><br></pre></td></tr></table></figure><h2 id="7-8-API-数据"><a href="#7-8-API-数据" class="headerlink" title="7.8 API 数据"></a>7.8 API 数据</h2><p>有了令牌以后，就可以向 API 请求数据了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  url: <span class="string">`https://api.github.com/user`</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    accept: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    Authorization: <span class="string">`token <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，GitHub API 的地址是<code>https://api.github.com/user</code>，请求的时候必须在 HTTP 头信息里面带上令牌<code>Authorization: token 361507da</code>。</p><p>然后，就可以拿到用户数据，得到用户的身份。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = result.data.name;</span><br><span class="line">ctx.response.redirect(<span class="string">`/welcome.html?name=<span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 —— &lt;a href=&quot;https://www.ruanyifeng.com/blog/2019/04/oauth_design.html&quot;&gt;OAuth 2.0 的一个简单解释 —— 阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="互联网标准RFC" scheme="https://tenloy.github.io/categories/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86RFC/"/>
    
    
  </entry>
  
  <entry>
    <title>WKWebView使用过程中遇到的坑</title>
    <link href="https://tenloy.github.io/2022/01/18/wkwebview-buges.html"/>
    <id>https://tenloy.github.io/2022/01/18/wkwebview-buges.html</id>
    <published>2022-01-18T17:39:45.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WKWebView-API"><a href="#WKWebView-API" class="headerlink" title="WKWebView API"></a>WKWebView API</h1><h2 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h2><p>关于 <code>extendedLayoutIncludesOpaqueBars</code> 和 <code>automaticallyAdjustsScrollViewInsets</code></p><ul><li>这两个属性属于UIViewController</li><li>默认情况下extendedLayoutIncludesOpaqueBars = false 扩展布局不包含导航栏</li><li>默认情况下automaticallyAdjustsScrollViewInsets = true 自动计算滚动视图的内容边距</li><li>但是，当 导航栏 是 不透明时，而tabBar为透明的时候，为了正确显示tableView的全部内容，需要重新设置这两个属性的值，然后设置contentInset(参考代码).</li></ul><p>在iOS11 中， UIViewController的 <code>automaticallyAdjustsScrollViewInsets</code> 属性已经不再使用，我们需要使用UIScrollView的 <code>contentInsetAdjustmentBehavior </code> 属性来替代它.</p><p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型，值有以下几种:</p><ul><li>automatic 和scrollableAxes一样，scrollView会自动计算和适应顶部和底部的内边距并且在scrollView 不可滚动时，也会设置内边距.</li><li>scrollableAxes 自动计算内边距.</li><li>never不计算内边距</li><li>always 根据safeAreaInsets 计算内边距一般我们肯定需要设置为 never，我们自己来控制间距，但是在iOS 12的webView中，就会出现开始所说的问题，需要设置为automatic才能解决</li></ul><p><strong>调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值.</strong></p><h2 id="2-调整滚动速率"><a href="#2-调整滚动速率" class="headerlink" title="2. 调整滚动速率"></a>2. 调整滚动速率</h2><p>WKWebView 需要通过 scrollView delegate 调整滚动速率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">  scrollView.decelerationRate = <span class="built_in">UIScrollViewDecelerationRateNormal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-视频自动播放"><a href="#3-视频自动播放" class="headerlink" title="3. 视频自动播放"></a>3. 视频自动播放</h2><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p><h2 id="4-goBack-API问题"><a href="#4-goBack-API问题" class="headerlink" title="4. goBack API问题"></a>4. goBack API问题</h2><p>WKWebView 上调用 -[WKWebView goBack]， 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p><h1 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h1><p>在以前，一直以为Hybrid App开发是一种略显简单的事，不会使用太多能发挥移动端原生本身优势的复杂API，后来在新公司的工作(半混合式开发)过程中，发现混合式开发也是很多坑… 或者说WKWebView好多坑…</p><blockquote><p> 以下所说的内容，<a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA">参考链接</a>上基本上都有，本文的叙述方式主要是结合自己的经历(自己踩过的总结总是那么的深刻…[\捂脸])</p><p> 应该在开始混合开发之前就看下这篇文章的，结果真的是等自己踩坑踩了一遍，总结之后，发现这篇文章上都有….[\大哭]</p><p> 参考链接2： <a href="https://www.jianshu.com/p/86d99192df68">https://www.jianshu.com/p/86d99192df68</a></p></blockquote><h2 id="1-加载URL的-encode问题"><a href="#1-加载URL的-encode问题" class="headerlink" title="1. 加载URL的 encode问题"></a>1. 加载URL的 encode问题</h2><p>在数据网络请求或其他情况下，需要把URL中的一些特殊字符转换成UTF-8编码，比如：中文。解决<code>无法加载</code>的问题</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByAddingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ios9后对其方法进行了修改</span></span><br><span class="line">stringByAddingPercentEncodingWithAllowedCharacters: [<span class="built_in">NSCharacterSet</span> URLQueryAllowedCharacterSet]</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 9以前</span></span><br><span class="line">stringByReplacingPercentEscapesUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// iOS 9以后</span></span><br><span class="line">stringByRemovingPercentEncoding</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>混合开发中，最好将所有的URL的编解码问题都<strong>交给前端或者后端来做</strong>，毕竟移动端发版不够灵活。</li><li>API编写时，要<strong>保证iOS与Android两端的处理一致</strong>，否则前端同学做处理就太麻烦了。</li></ul><h2 id="2-loadRequest造成的body数据丢失"><a href="#2-loadRequest造成的body数据丢失" class="headerlink" title="2. loadRequest造成的body数据丢失"></a>2. loadRequest造成的body数据丢失</h2><p>在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是由于进程间通信性能问题，HTTPBody字段被丢弃[request setHTTPMethod:@&quot;POST&quot;];</span></span><br><span class="line">[request setHTTPBody:[<span class="string">@&quot;bodyData&quot;</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line">[wkwebview loadRequest: request];</span><br></pre></td></tr></table></figure><p>目前也已经有成熟的解决方案了，见<a href="https://github.com/karosLi/KKJSBridge#ajax-hook-%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94">KKJSBridge库</a>。原理上都是hook ajax，不过细节上分两种：</p><p>这里只对比方案间相互比较的优缺点，共同的优点，就不赘述了。如果对私有 API 不敏感的，我是比较推荐使用方案一的。</p><h3 id="方案一：Ajax-Hook-部分-API-NSURLProtocol"><a href="#方案一：Ajax-Hook-部分-API-NSURLProtocol" class="headerlink" title="方案一：Ajax Hook 部分 API + NSURLProtocol"></a>方案一：Ajax Hook 部分 API + NSURLProtocol</h3><p>这个方案对应的是这里的 <code>KKJSBridge/AjaxProtocolHook</code>。</p><p>原理介绍：此种方案，是只需要 hook ajax 中的 open/send 方法。</p><ol><li>在 hook 的 send 方法里，先把要发送的 body 通过 JSBridge 发送到 Native 侧去缓存起来。<ul><li><em>为每一个post请求设置一个id，对应其缓存起来的body数据？</em></li><li><em>如果不想缓存，那先把post转get、或者body参数存header中，缺点都是body有限制。这种适合参数较少时。注意有个坑就是修改header可能会导致发出options请求。—— 来自群友交流</em></li></ul></li><li>缓存成功后，再去执行真实的 send 方法，NSURLProtocol 此时会拦截到该请求，然后取出之前缓存的 body 数据，重新拼接请求，就可以发送出去了。</li><li>然后通过 NSURLProtocol 把请求结果返回给 WebView 内核。</li></ol><p>优点：</p><ul><li>兼容性会更好，网络请求都是走 webview 原生的方式。</li><li>hook 的逻辑会更少，会更加稳定。</li><li>可以更好的支持 ajax 获取二进制的数据。例如 H5 小游戏场景（白鹭引擎是通过异步获取图片资源）。</li></ul><p>缺点：</p><ul><li>需要使用到私有 API browsingContextController 去注册 http/https。（其实现在大部分的离线包方案也是使用了这个私有 API 了）</li></ul><h3 id="方案二：Ajax-Hook-全部-API"><a href="#方案二：Ajax-Hook-全部-API" class="headerlink" title="方案二：Ajax Hook 全部 API"></a>方案二：Ajax Hook 全部 API</h3><p>这个方案对应的是这里的 <code>KKJSBridge/AjaxHook</code>。</p><p>原理介绍：此种方案，是使用 hook 的 XMLHttpRequest 对象来代理真实的 XMLHttpRequest 去发送请求，相当于是需要 hook ajax 中的所有方法。</p><ul><li>在 hook 的 open 方法里，调用 JSBridge 让 Native 去创建一个 NSMutableRequest 对象。</li><li>在 hook 的 send 方法里，把要发送的 body 通过 JSBridge 发送到 Native 侧，并把 body 设置给刚才创建的 NSMutableRequest 对象。</li><li>在 Native 侧完成请求后，通过 JS 执行函数，把请求结果通知给 JS 侧，JS 侧找到 hook 的 XMLHttpRequest 对象，最后调用 onreadystatechange 函数，让 H5 知道有请求结果了。</li></ul><p>优点：</p><ul><li>没有使用私有 API。</li></ul><p>缺点：</p><ul><li>需要 hook XMLHttpRequest 的所有方法。</li><li>请求结果是通过 JSBrdige 来进行传输的，性能上肯定没有原生的性能好。</li><li>不能支持 ajax 获取二进制的数据。要想支持的话，还需要额外的序列化工作。</li></ul><h2 id="3-WKUserContentController造成内存泄漏"><a href="#3-WKUserContentController造成内存泄漏" class="headerlink" title="3. WKUserContentController造成内存泄漏"></a>3. WKUserContentController造成内存泄漏</h2><blockquote><p>self -&gt; webView -&gt; WKWebViewConfiguration -&gt; WKUserContentController -&gt; self (addScriptMessageHandler)</p></blockquote><p>以下的方法，并不能解决问题</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) copy_self = <span class="keyword">self</span>;</span><br><span class="line">addScriptMessageHandler: copy_self</span><br></pre></td></tr></table></figure><p>解决方案： 单独创建一个类实现<code>WKScriptMessageHandler</code>协议，然后在该类中再创建一个协议，由self来实现协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> -&gt; webView -&gt; <span class="built_in">WKWebViewConfiguration</span> -&gt; <span class="built_in">WKUserContentController</span> -&gt; <span class="keyword">weak</span> delegate obj --delegate--&gt; <span class="keyword">self</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个新类WeakScriptMessageDelegate</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakScriptMessageDelegate</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt; scriptDelegate;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakScriptMessageDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptDelegate &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">      _scriptDelegate = scriptDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    [<span class="keyword">self</span>.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在我们使用WKWebView的控制器中引入我们创建的那个类，将注入js对象的代码改为:</span></span><br><span class="line">[config.userContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:<span class="keyword">self</span>] name:scriptMessage];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在delloc方法中通过下面的方式移除注入的js对象</span></span><br><span class="line">[<span class="keyword">self</span>.config.userContentController removeScriptMessageHandlerForName:scriptMessage];</span><br></pre></td></tr></table></figure><p>上面三步就可以解决控制器不能被释放的问题了。</p><h2 id="4-WKWebView的白屏问题-拍照引起"><a href="#4-WKWebView的白屏问题-拍照引起" class="headerlink" title="4.  WKWebView的白屏问题(拍照引起)"></a>4.  WKWebView的白屏问题(拍照引起)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。</p><p>换WKWebView加载网页后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。<strong>在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。</strong></p><ul><li><p>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；</p></li><li><p>在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>总结下来，白屏的现象有几种：</p><ul><li>WKWebView的URL为空，出现白屏，这种现象可以通过loadRequest解决。</li><li>WKWebView的URL不空，出现白屏、部分白屏、白屏部分能点击，这种现象无论是reload还是loadRequest都不能刷出网页。（可以尝试3、4）</li></ul><h4 id="方案1-ContentProcessDidTerminate"><a href="#方案1-ContentProcessDidTerminate" class="headerlink" title="方案1. ContentProcessDidTerminate"></a>方案1. ContentProcessDidTerminate</h4><p>借助 iOS 9以后 <code>WKNavigtionDelegate</code> 新增了一个回调函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(<span class="built_in">WKWebView</span> *)webView API_AVAILABLE(macosx(<span class="number">10.11</span>), ios(<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><p>当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行<code>[webView reload]</code>(这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p><h4 id="方案2-检测-webView-title-是否为空"><a href="#方案2-检测-webView-title-是否为空" class="headerlink" title="方案2. 检测 webView.title 是否为空"></a>方案2. 检测 webView.title 是否为空</h4><p>并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的<code>意见反馈</code>H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，<strong>WebContent Process 被系统挂起</strong>），但上面的回调函数并没有被调用。</p><p>在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空， 因此，可以在 viewWillAppear 的时候检测 <code>webView.title</code> 是否为空来 reload 页面。</p><p>注意：可能<strong>有的前端页面确实没写title标签</strong>，在前端移动端开发中是可能会有这种场景的，会造成页面反复刷新</p><p>综合以上两种方法可以解决绝大多数的白屏问题。</p><h4 id="方案3-检索WKCompositingView控件"><a href="#方案3-检索WKCompositingView控件" class="headerlink" title="方案3. 检索WKCompositingView控件"></a>方案3. 检索WKCompositingView控件</h4><blockquote><p>（<em>未验证，有人说不好使</em>）</p></blockquote><p>WKWebView的URL不空，出现白屏不能点击、白屏部分能点击、部分白屏能点击等，这种现象无论是reload、loadRequest、清缓存、setNeedsLayout都不能刷出网页，只能回收旧webview（webview = nil 后记得清除代理，移除监听，要不然会crash）创建新的 webview， 然后重新request。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否白屏</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isBlankView:(<span class="built_in">UIView</span> *)view &#123; <span class="comment">// YES：blank</span></span><br><span class="line">    Class wkCompositingView = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;WKCompositingView&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ([view isKindOfClass:[wkCompositingView <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">UIView</span> * subView <span class="keyword">in</span> view.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> isBlankView:subView]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案4-html中加入资源加载的监听"><a href="#方案4-html中加入资源加载的监听" class="headerlink" title="方案4. html中加入资源加载的监听"></a>方案4. html中加入资源加载的监听</h4><p>在本地html中加入资源加载的监听，只要发生错误，就调用location.reload();重载当前文档。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监控资源加载错误(img,script,css,以及jsonp)</span></span><br><span class="line">window.addEventListener(<span class="string">&#x27;error&#x27;</span>, function (e) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;===&quot;</span> + e.message + <span class="string">&quot;===&quot;</span>);</span><br><span class="line">    location.reload();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) &#123;</span><br><span class="line">    console.log(<span class="string">&quot;错误信息：&quot;</span>, errorMessage);</span><br><span class="line">    console.log(<span class="string">&quot;出错文件：&quot;</span>, scriptURI);</span><br><span class="line">    console.log(<span class="string">&quot;出错行号：&quot;</span>, lineNumber);</span><br><span class="line">    console.log(<span class="string">&quot;出错列号：&quot;</span>, columnNumber);</span><br><span class="line">    console.log(<span class="string">&quot;错误详情：&quot;</span>, errorObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这段代码要放在head内，并且css不能内联。</p><h2 id="5-NSURLProtocol-做网页缓存"><a href="#5-NSURLProtocol-做网页缓存" class="headerlink" title="5. NSURLProtocol(做网页缓存)"></a>5. NSURLProtocol(做网页缓存)</h2><p>见<a href="https://www.jianshu.com/p/9989ef064f7d">WKWebView中NSURLProtocol的使用以及对H5的缓存</a>，这是利用NSURLProtocol做网页缓存以及带来的隐患。</p><h2 id="6-WKWebView的截屏问题-做意见反馈"><a href="#6-WKWebView的截屏问题-做意见反馈" class="headerlink" title="6.  WKWebView的截屏问题(做意见反馈)"></a>6.  WKWebView的截屏问题(做意见反馈)</h2><p>WKWebView 下通过 <code>-[CALayer renderInContext:]</code>实现截屏的方式失效，需要通过以下方式实现截屏功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">ImageSnapshot</span>) </span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)imageSnapshot &#123; </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size,<span class="literal">YES</span>,<span class="keyword">self</span>.contentScaleFactor); </span><br><span class="line">    [<span class="keyword">self</span> drawViewHierarchyInRect:<span class="keyword">self</span>.bounds afterScreenUpdates:<span class="literal">YES</span>]; </span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>(); </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>(); </span><br><span class="line">    <span class="keyword">return</span> newImage; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然而这种方式依然解决不了 webGL 页面的截屏问题，Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：<strong>对webGL 页面的截屏结果不是空白就是纯黑图片</strong>。</p><h2 id="7-window-alert-引起的crash问题-暂时没遇到"><a href="#7-window-alert-引起的crash问题-暂时没遇到" class="headerlink" title="7. window.alert()引起的crash问题(暂时没遇到)"></a>7. window.alert()引起的crash问题(暂时没遇到)</h2><h2 id="8-WKWebView拦截协议"><a href="#8-WKWebView拦截协议" class="headerlink" title="8. WKWebView拦截协议"></a>8. WKWebView拦截协议</h2><p>WKWebView内默认不允许iTunes、weixin等协议跳转。</p><p>UIWebView打开ituns.apple.com、跳转到appStore、拨打电话、唤起邮箱等一系列操作，UIWebView自己处理不了会自动交给UIApplication 来处理。</p><p>WKWebView上述事件WKWebView 不会自动交给UIApplication 来处理，除此之外，js端通过window.open() 打开新的网页的动作也被禁掉了。</p><h2 id="9-User-Agent修改"><a href="#9-User-Agent修改" class="headerlink" title="9. User-Agent修改"></a>9. User-Agent修改</h2><ul><li><p>在UIWebView初始化之前，全局设置User-Agent才会生效</p></li><li><p>在shouldStartLoadWithRequest可以给某个request设置UA，但是需要重新[webView loadUrl]，注意判断条件，不要死循环</p></li><li><p><strong>不要擅自修改webView的User-Agent，务必要跟前端反复确认，是否有用UA来做一些设备区分，进而做一些系统、机型适配问题。</strong></p></li></ul><h2 id="10-didFinish不调用"><a href="#10-didFinish不调用" class="headerlink" title="10. didFinish不调用"></a>10. didFinish不调用</h2><p>WKWebView didFinishNavigation明明看起来页面加载完全，却不调用(<strong>一般只发生在第一次进入该页面</strong>)。经过自定义NSURLProtocol，拦截所有的H5加载资源，并在didCompleteWithError中打印资源的加载情况，发现有图片资源，域名有问题。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error Domain=<span class="built_in">NSURLErrorDomain</span> Code=<span class="number">-1003</span> <span class="string">&quot;未能找到使用指定主机名的服务器。 </span></span><br></pre></td></tr></table></figure><p>原因：DNS解析失败导致系统认定H5一直没加载完成！第二次再进入，系统缓存了DNS解析的映射记录，所以很快就认定资源错误，调用了didFinish方法。</p><h2 id="11-UI细节问题"><a href="#11-UI细节问题" class="headerlink" title="11. UI细节问题"></a>11. UI细节问题</h2><h3 id="11-1-WKWebView中-h5绝对布局不生效"><a href="#11-1-WKWebView中-h5绝对布局不生效" class="headerlink" title="11.1 WKWebView中 h5绝对布局不生效"></a>11.1 WKWebView中 h5绝对布局不生效</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ios 11之后</span></span><br><span class="line">_baseWebView.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br></pre></td></tr></table></figure><p>然后：前端需要在meta标签中增加 <strong>iPhoneX</strong>的适配**—<strong>适配方案</strong>viewport-fit<strong>：</strong>cover**</p><h3 id="11-2-iOS-12中WKWebView中表单-键盘"><a href="#11-2-iOS-12中WKWebView中表单-键盘" class="headerlink" title="11.2. iOS 12中WKWebView中表单 键盘"></a>11.2. iOS 12中WKWebView中表单 键盘</h3><p>iOS 12中WKWebView中表单键盘弹起自动上移，导致的兼容问题。</p><p>WKWebView会自动监听键盘弹出，并做上下移动处理(效果如同IQKeyboardManage这些库)，但是在iOS12中会有一些问题，键盘收起后，控件不恢复原状，或者部分控件消失等不兼容问题</p><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(kSystemVersion &lt; <span class="number">12.0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">12.0</span>, *)) &#123;</span><br><span class="line">     _webview.scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-WKWebview会下移20"><a href="#11-3-WKWebview会下移20" class="headerlink" title="11.3 WKWebview会下移20"></a>11.3 WKWebview会下移20</h3><p>解决方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iOS11前</span></span><br><span class="line">VC.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;  </span><br><span class="line"><span class="comment">//iOS11及以后</span></span><br><span class="line">_webview.scrollView.contentInsetAdjustmentBehavior;</span><br></pre></td></tr></table></figure><h2 id="12-H5标签不可点击，Native不受影响"><a href="#12-H5标签不可点击，Native不受影响" class="headerlink" title="12. H5标签不可点击，Native不受影响"></a>12. H5标签不可点击，Native不受影响</h2><p><em>iOS 11系统上，WKWebView内H5标签不可点击，Native不受影响。</em></p><p>在频繁的切换页面、刷新WKWebView的情况下，会出现WKWebView卡死，所有的H5标签不可点击，Native的UI不受影响，TabBarVC的几个子控制器最为严重，有时候切换、刷新四五次左右，就会出现这种情况。</p><p><strong>更新：结论：在viewWillAppear方法中调用了<code>evaluateJavaScript: completionHandler:</code>方法，将该方法的调用移到viewDidAppear方法中即可。</strong></p><p>下面是探索的一些步骤，也走了一些弯路，可绕过：</p><blockquote><p>分别从内存、视图、网络请求几个方面入手，按照以下步骤定位问题：</p><ol><li><p>对APP进行内存泄漏检测，优化了几处代码。毫无用处</p></li><li><p>WKWebView单独进程内存问题？因为有一些二级页面按照问题出现流程复现了N多次，都没有出现，所以暂时先排除</p></li><li><p>网速问题。发现网速差时，确实很容易复现，网速好的时候，试了好几次没复现！做了一些网络优化，比如及时cancel掉一些不需要的请求，没有效果。</p></li><li><p>视图加载、更新问题。猜测依据：一级页面更容易复现，且比二级页面多了一个Tabbar的视图。</p></li><li><p>结论：结合第3、4，猜测是网络过慢时，tabbar出现、隐藏，及WKWebView刷新、加载、渲染HTML，几种情况结合导致的WKWebView布局混乱。</p></li></ol><p>最后解决方法：包含WKWebView的一级页面，<code>viewDidAppear</code>时重新设置了一下WKWebView的约束。(设置UIScrollViewContentInsetAdjustmentAutomatic = YES，没有效果)</p><p>效果：大大改善了，但却没有根治问题。加了个保底方案，下拉刷新时，销毁旧WKWebView，创建新的，并loadRequest。(因为这些情况下iOS 11上出现的，且没有更低版本的测试机复现，所以暂时把修改限制在了iOS 11及以下的系统)</p></blockquote><p><strong>最后</strong>：有个最省事的方案，针对这些页面，<strong>将WKWebView替换成UIWebView</strong>。 可行，但逃避问题，不太可取，而且UIWebView、WKWebView各有一些特性，另一个不支持，比如WKWebView支持html，滚动时实时回调，而UIWebView只支持滚动停止时回调。且苹果已经不太支持UIWebView。还是早点拥抱WKWebView吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WKWebView-API&quot;&gt;&lt;a href=&quot;#WKWebView-API&quot; class=&quot;headerlink&quot; title=&quot;WKWebView API&quot;&gt;&lt;/a&gt;WKWebView API&lt;/h1&gt;&lt;h2 id=&quot;1-属性&quot;&gt;&lt;a href=&quot;#1-属性&quot;</summary>
      
    
    
    
    <category term="iOS" scheme="https://tenloy.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] 位运算实现加、减、乘、除运算</title>
    <link href="https://tenloy.github.io/2021/11/22/bit-calculation.html"/>
    <id>https://tenloy.github.io/2021/11/22/bit-calculation.html</id>
    <published>2021-11-22T16:35:03.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原理的理解。</p><p>今天就来看看怎么不使用显式“ + - * /”运算符来实现加减乘除运算。</p><p>下面我们一个一个来看。</p><h2 id="一、加法运算"><a href="#一、加法运算" class="headerlink" title="一、加法运算"></a>一、加法运算</h2><h3 id="1-1-十进制-举例"><a href="#1-1-十进制-举例" class="headerlink" title="1.1 十进制 举例"></a>1.1 十进制 举例</h3><p>先来个我们最熟悉的十进制的加法运算：</p><blockquote><p>13 + 9 = 22</p></blockquote><p>我们像这样来拆分这个运算过程：分别对各位数进行相加</p><ol><li><p>不考虑进位(要进位的值丢弃)：结果为sum：个位数3加上9为2；十位数1加上0为1； 最终结果为12；</p></li><li><p>只考虑进位(只保留进位的值)，结果为carry： 3 + 9 有进位，进位的值为10；</p></li><li><p>如果步骤2所得进位结果carry不为0。那么把步骤1所得sum、步骤2所得carry当成操作数重复步骤1、 2、3；</p><p>如果carry为0则结束，最终结果为步骤1所得sum：</p><p>这里即是对sum = 12 和carry = 10重复以上三个步骤：</p><p>a. 不考虑进位，分别对各位数进行相加:sum = 22; </p><p>b. 只考虑进位: 上一步没有进位，所以carry = 0； </p><p>c. 步骤2carry = 0，结束，结果为sum = 22.</p></li></ol><h3 id="1-2-二进制-举例"><a href="#1-2-二进制-举例" class="headerlink" title="1.2 二进制 举例"></a>1.2 二进制 举例</h3><p>我们发现这三板斧行得通！那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。</p><p>13的二进制为0000 1101，9的二进制为0000 1001:</p><ol><li><p>不考虑进位：分别对各位数进行相加：sum = 0000 1101 + 0000 1001 = 0000 0100</p></li><li><p>只考虑进位： 有两处进位，第0位和第3位，只考虑进位的结果为：carry = 0001 0010</p></li><li><p>步骤2 carry == 0 ?，不为0，重复步骤1 、2 、3；本例中，</p><p> a. 不考虑进位sum = 0001 0110;</p><p> b. 只考虑进位carry  = 0;</p><p> c. carry == 0？为0，结束，结果为sum = 0001 0110。转换成十进制刚好是22.</p></li></ol><h3 id="1-3-结论"><a href="#1-3-结论" class="headerlink" title="1.3 结论"></a>1.3 结论</h3><p>我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，其实：</p><ul><li>第一步不考虑进位的加法其实就是<font color=red>异或运算</font>；</li><li>第二步只考虑进位就是<font color=red>与运算并左移一位</font>；</li><li>第三步就是<strong>重复前面两步操作直到第二步进位结果为0</strong>。</li></ul><p>这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0011</span>, b = <span class="number">1001</span>;</span><br><span class="line">start;</span><br><span class="line"></span><br><span class="line">first loop;</span><br><span class="line"> <span class="number">1.1</span> sum = <span class="number">1010</span></span><br><span class="line"> <span class="number">1.2</span> carry = <span class="number">0010</span></span><br><span class="line"> <span class="number">1.3</span> carry != <span class="number">0</span> , go on;</span><br><span class="line"></span><br><span class="line">second loop;</span><br><span class="line"> <span class="number">2.1</span> sum = <span class="number">1000</span>;</span><br><span class="line"> <span class="number">2.2</span> carry = <span class="number">0100</span>;</span><br><span class="line"> <span class="number">2.3</span> carry != <span class="number">0</span>, go on;</span><br><span class="line"></span><br><span class="line">third loop;</span><br><span class="line"> <span class="number">3.1</span> sum = <span class="number">1100</span>;</span><br><span class="line"> <span class="number">3.2</span> carry = <span class="number">0000</span>;</span><br><span class="line"> <span class="number">3.3</span> carry == <span class="number">0</span>, stop; result = sum;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。</p><h3 id="1-4-代码"><a href="#1-4-代码" class="headerlink" title="1.4 代码"></a>1.4 代码</h3><p>有了上面的分析，我们不难写出如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">add</span>(sum, carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = num1 ^ num2;</span><br><span class="line">    <span class="built_in">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">int</span> a = sum;</span><br><span class="line">        <span class="built_in">int</span> b = carry;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！</p><h2 id="二、减法运算"><a href="#二、减法运算" class="headerlink" title="二、减法运算"></a>二、减法运算</h2><p>我们知道了位运算实现加法运算，那减法运算就相对简单一些了。我们实现了加法运算，自然的，我们会想到把减法运算11 - 6变形为加法运算11 + (-6)，即一个正数加上一个负数。是的，很聪明，其实我们的计算机也是这样操作的，那有的人会说为什么计算机不也像加法器一样实现一个减法器呢？对的，这样想当然是合理的，但是考虑到减法比加法来的复杂，实现起来比较困难。为什么呢？我们知道加法运算其实只有两个操作，加、 进位，而减法呢，减法会有借位操作，如果当前位不够减那就从高位借位来做减法，这里就会问题了，借位怎么表示呢？加法运算中，进位通过与运算并左移一位实现，而借位就真的不好表示了。所以我们自然的想到将减法运算转变成加法运算。</p><p>怎么实现呢？</p><p>刚刚我们说了减法运算可转变成一个正数加上一个负数，那首先就要来看看负数在计算机中是怎么表示的。</p><p>+8在计算机中表示为二进制的1000，那-8怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。这只是直观的表示方法，其实计算机是通过2的补码来表示负数的，那什么是2的补码（同补码，英文是2’s complement，其实应该翻译为2的补码）呢？它是一种用二进制表示有号数的方法，也是一种将数字的正负号变号的方式，求取步骤：</p><ul><li>第一步，每一个二进制位都取相反值，0变成1，1变成0（即反码）。</li><li>第二步，将上一步得到的值（反码）加1。</li></ul><p>简单来说就是取反加一！</p><p>关于补码更详细的内容可参<a href="https://link.jianshu.com/?t=!https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">维基百科-补码</a>，这里不再赘述。</p><p>其实我们利用的恰巧是补码的可以将数字的正负号变号的功能，这样我们就可以把减法运算转变成加法运算了，因为负数可以通过其对应正数求补码得到。计算机也是通过增加一个补码器配合加法器来做减法运算的，而不是再重新设计一个减法器。</p><p>以上，我们很容易写出了位运算做减法运算的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* num1: 减数</span></span><br><span class="line"><span class="comment">* num2: 被减数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">substract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> subtractor = <span class="keyword">add</span>(~num2, <span class="number">1</span>);<span class="comment">// 先求减数的补码（取反加一）</span></span><br><span class="line">    <span class="built_in">int</span> result = <span class="keyword">add</span>(num1, subtractor); <span class="comment">// add()即上述加法运算　　</span></span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、乘法运算"><a href="#三、乘法运算" class="headerlink" title="三、乘法运算"></a>三、乘法运算</h2><p>我们知道了加法运算的位运算实现，那很容易想到乘法运算可以转换成加法运算，被乘数加上乘数倍的自己不就行了么。这里还有一个问题，就是乘数和被乘数的正负号问题，我们这样处理，先处理乘数和被乘数的绝对值的乘积，然后根据它们的符号确定最终结果的符号即可。步骤如下：</p><blockquote><p>(1) 计算绝对值得乘积<br> (2) 确定乘积符号（同号为证，异号为负）</p></blockquote><p>有了这个思路，代码就不难写了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a: 被乘数</span></span><br><span class="line"><span class="comment">* b: 乘数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 取绝对值　　    </span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a;    </span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;<span class="comment">// 如果为负则取反加一得其补码，即正数　　    </span></span><br><span class="line">    <span class="comment">// 计算绝对值的乘积　　    </span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(count &lt; multiplier) &#123;        </span><br><span class="line">        product = <span class="keyword">add</span>(product, multiplicand);        </span><br><span class="line">        count = <span class="keyword">add</span>(count, <span class="number">1</span>);<span class="comment">// 这里可别用count++，都说了这里是位运算实现加法　　    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定乘积的符号　　    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;<span class="comment">// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        </span></span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的思路在步骤上没有问题，但是第一步对绝对值作乘积运算我们是通过不断累加的方式来求乘积的，这在乘数比较小的情况下还是可以接受的，但在乘数比较大的时候，累加的次数也会增多，这样的效率不是最高的。我们可以思考，如何优化求绝对值的乘积这一步。</p><p>考虑我们现实生活中手动求乘积的过程，这种方式同样适用于二进制，下面我以13*14为例，向大家演示如何用手动计算的方式求乘数和被乘数绝对值的乘积。</p><img src="/images/bit-cal/01.png" alt="01" style="zoom:95%;" /><p>从上图的计算过程可以看出，如果乘数当前位为1，则取被乘数左移一位的结果加到最终结果中；如果当前位为0，则取0加到乘积中（加0也就是什么也不做）；</p><p>整理成算法步骤：</p><blockquote><p>(1) 判断乘数是否为0，为0跳转至步骤(4)</p><p>(2) 将乘数与1作与运算，确定末尾位为1还是为0，如果为1，则相加数为当前被乘数；如果为0，则相加数为0；将相加数加到最终结果中；</p><p>(3) 被乘数左移一位，乘数右移一位；回到步骤(1)</p><p>(4) 确定符号位，输出结果；</p></blockquote><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;　　</span><br><span class="line">    <span class="comment">//将乘数和被乘数都取绝对值　</span></span><br><span class="line">    <span class="built_in">int</span> multiplicand = a &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~a, <span class="number">1</span>) : a; 　　</span><br><span class="line">    <span class="built_in">int</span> multiplier = b &lt; <span class="number">0</span> ? <span class="keyword">add</span>(~b , <span class="number">1</span>) : b;　　</span><br><span class="line">    　</span><br><span class="line">    <span class="comment">//计算绝对值的乘积　　</span></span><br><span class="line">    <span class="built_in">int</span> product = <span class="number">0</span>;　　</span><br><span class="line">    <span class="keyword">while</span>(multiplier &gt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span>((multiplier &amp; <span class="number">0x1</span>) &gt; <span class="number">0</span>) &#123;<span class="comment">// 每次考察乘数的最后一位　　　　</span></span><br><span class="line">            product = <span class="keyword">add</span>(product, multiplicand);　　　　</span><br><span class="line">        &#125; 　　　　</span><br><span class="line">        multiplicand = multiplicand &lt;&lt; <span class="number">1</span>;<span class="comment">// 每运算一次，被乘数要左移一位　　　　</span></span><br><span class="line">        multiplier = multiplier &gt;&gt; <span class="number">1</span>;<span class="comment">// 每运算一次，乘数要右移一位（可对照上图理解）　　</span></span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="comment">//计算乘积的符号　　</span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>) &#123;　　　　</span><br><span class="line">        product = <span class="keyword">add</span>(~product, <span class="number">1</span>);　　</span><br><span class="line">    &#125; 　　</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，第二种求乘积的方式明显要优于第一种。</p><h2 id="四、除法运算"><a href="#四、除法运算" class="headerlink" title="四、除法运算"></a>四、除法运算</h2><p>除法运算很容易想到可以转换成减法运算，即不停的用除数去减被除数，直到被除数小于除数时，此时所减的次数就是我们需要的商，而此时的被除数就是余数。这里需要注意的是符号的确定，商的符号和乘法运算中乘积的符号确定一样，即取决于除数和被除数，同号为证，异号为负；余数的符号和被除数一样。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* a : 被除数</span></span><br><span class="line"><span class="comment">* b : 除数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="comment">// 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span></span><br><span class="line">    <span class="keyword">while</span>(dividend &gt;= divisor)&#123;<span class="comment">// 直到商小于被除数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span>);        </span><br><span class="line">        dividend = substract(dividend, divisor);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;<span class="comment">// 如果除数和被除数异号，则商为负数  </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有和简单版乘法运算一样的问题，如果被除数非常大，除数非常小，那就要进行很多次减法运算，有没有更简便的方法呢？</p><p>上面的代码之所以比较慢是因为步长太小，每次只能用1倍的除数去减被除数，所以速度比较慢。那能不能增大步长呢？如果能，应该怎么增大步长呢？</p><p>计算机是一个二元的世界，所有的int型数据都可以用[2^0, 2^1, … , 2^31]这样一组基来表示（int型最高31位）。不难想到用除数的2^31, 2^30, … , 2^2, 2^1, 2^0 倍尝试去减被除数，如果减得动，则把相应的倍数加到商中；如果减不动，则依次尝试更小的倍数。这样就可以快速逼近最终的结果。</p><p>2的i次方其实就相当于左移i位，为什么从31位开始呢？因为int型数据最大值就是2^31啊。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">divide_v2</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span> &#123;   </span><br><span class="line">    <span class="comment">// 先取被除数和除数的绝对值    </span></span><br><span class="line">    <span class="built_in">int</span> dividend = a &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~a, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> divisor = b &gt; <span class="number">0</span> ? a : <span class="keyword">add</span>(~b, <span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">int</span> quotient = <span class="number">0</span>;<span class="comment">// 商    </span></span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;<span class="comment">// 余数    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//比较dividend是否大于divisor的(1&lt;&lt;i)次方，不要将dividend与(divisor&lt;&lt;i)比较，而是用(dividend&gt;&gt;i)与divisor比较，</span></span><br><span class="line">        <span class="comment">//效果一样，但是可以避免因(divisor&lt;&lt;i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       </span></span><br><span class="line">        <span class="keyword">if</span>((dividend &gt;&gt; i) &gt;= divisor) &#123;            </span><br><span class="line">            quotient = <span class="keyword">add</span>(quotient, <span class="number">1</span> &lt;&lt; i);            </span><br><span class="line">            dividend = substract(dividend, divisor &lt;&lt; i);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定商的符号    </span></span><br><span class="line">    <span class="keyword">if</span>((a ^ b) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果除数和被除数异号，则商为负数        </span></span><br><span class="line">        quotient = <span class="keyword">add</span>(~quotient, <span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 确定余数符号    </span></span><br><span class="line">    remainder = b &gt; <span class="number">0</span> ? dividend : <span class="keyword">add</span>(~dividend, <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> quotient;<span class="comment">// 返回商</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，计算机最基本的操作单元是字节(byte)，一个字节由8个位(bit)组成，一个位只能存储一个0或1，其实也就是高低电平。无论多么复杂的逻辑、庞大的数据、酷炫的界面，最终体现在计算机最底层都只是对0101的存储和运算。因此，了解位运算有助于提升我们对计算机底层操作原</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://tenloy.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Git的使用总结</title>
    <link href="https://tenloy.github.io/2021/11/10/git-use.html"/>
    <id>https://tenloy.github.io/2021/11/10/git-use.html</id>
    <published>2021-11-10T11:06:05.000Z</published>
    <updated>2022-09-07T02:38:36.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来交换修改。</li><li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。两个人的电脑之间可以相互推送修改。不过， 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li><li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB。(Microsoft的Word格式是二进制格式)。</li><li>文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</li></ul><h2 id="二、Git的安装"><a href="#二、Git的安装" class="headerlink" title="二、Git的安装"></a>二、Git的安装</h2><p>首先，试着输入<code>git</code>，看看系统有没有安装Git。</p><p>Mac OS X上安装Git：</p><h3 id="2-1-通过homebrew安装"><a href="#2-1-通过homebrew安装" class="headerlink" title="2.1 通过homebrew安装"></a>2.1 通过homebrew安装</h3><blockquote><p>引用官方的一句话：Homebrew是Mac OS 不可或缺的套件管理器。 </p><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。</p></blockquote><p>安装homebrew，然后通过homebrew安装Git。</p><h3 id="2-2-通过Command-Line-Tools安装"><a href="#2-2-通过Command-Line-Tools安装" class="headerlink" title="2.2 通过Command Line Tools安装"></a>2.2 通过Command Line Tools安装</h3><p>安装Xcode IDE附带的命令行工具—Command Line Tools(需要自己安装 <code>xcode-select--install</code> )</p><blockquote><p>Command Line Tools就是一个小型独立包，为mac终端用户提供了许多常用的命令行工具（实用程序、编译器等）。包括svn，git，make，GCC，clang，perl，size，strip，strings，libtool，cpp，what以及其他很多能够在Linux默认安装中找到的有用的命令。</p><p>安装目录： /Library/Developer/CommandLineTools/</p></blockquote><h2 id="三、Git的配置"><a href="#三、Git的配置" class="headerlink" title="三、Git的配置"></a>三、Git的配置</h2><h3 id="3-1-配置远程仓库"><a href="#3-1-配置远程仓库" class="headerlink" title="3.1 配置远程仓库"></a>3.1 配置远程仓库</h3><p>常见的本地、远程仓库几种模式：</p><ul><li><p>从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p></li><li><p>在GitHub上，可以任意Fork开源仓库(点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone)</p><ul><li>自己拥有Fork后的仓库的读写权限； </li><li>可以推送pull request给官方仓库来贡献代码( 当然，对方是否接受你的pull request就不一定了 )。</li></ul></li><li><p>将已存在的文件夹，变成 Git 仓库，并创建关联的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 本地文件夹名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把这个目录变成Git可以管理的仓库 ，会多一个.git的目录，是Git来跟踪管理版本库的，如非必要不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 </span></span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加后，远程库的名字一般就是origin，这是Git默认的叫法，也可以改成别的，只不过origin这个名字一看就知道是远程库。</span></span><br><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url(ssh/https)&gt; </span><br><span class="line"><span class="comment"># 一个本地仓库是可以关联多个远程库的，多次执行上面命令即可，但不能重名</span></span><br><span class="line"><span class="comment"># 查看远程库信息（如果没有推送权限，就不会看到push的地址）</span></span><br><span class="line">git remote [-v/--verbose]</span><br><span class="line"><span class="comment"># 删除已有的远程库</span></span><br><span class="line">git remote rm &lt;remoteName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的master分支内容推送的远程新的master分支，并建立本地master与远程仓库的master分支的关联，详见git push命令</span></span><br><span class="line">git push -u &lt;remote-name&gt; master </span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-配置忽略文件"><a href="#3-2-配置忽略文件" class="headerlink" title="3.2 配置忽略文件"></a>3.2 配置忽略文件</h3><h4 id="3-2-1-全局与局部忽略"><a href="#3-2-1-全局与局部忽略" class="headerlink" title="3.2.1 全局与局部忽略"></a>3.2.1 全局与局部忽略</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦。</p><p>此时，可以把要忽略的文件名填入忽略文件，Git就会自动忽略这些文件。可以定义忽略是全局的，还是局限于一个仓库。</p><ul><li>全局忽略文件：<code>/User/用户名/.gitignore_global</code> ;</li><li>仓库忽略文件：Git工作区的根目录下有一个特殊的 <code>.gitignore</code> 文件。</li></ul><h4 id="3-2-2-忽略文件的编写"><a href="#3-2-2-忽略文件的编写" class="headerlink" title="3.2.2 忽略文件的编写"></a>3.2.2 忽略文件的编写</h4><p>忽略文件的格式：</p><ul><li>注释格式同shell脚本： #注释；</li><li>忽略精确的文件名：文件名；</li><li>忽略所有此扩展名的文件：如 *.pbxuser 表示要忽略后缀名为.pbxuser的文件；</li><li>忽略文件夹下面的一切：如 build/ 表示要忽略 build 文件夹下的所有内容；</li><li><code>*</code> 表示通配符：如 <code>fastlane/screenshots/**/*.png</code>；</li><li><code>!</code> 表示取反：如 *.pbxuser 表示忽略所有后缀名为.pbxuser的文件，如果加上!default.pbxuser则表示，除了default.pbxuse忽略其它后缀名为pbxuse的文件。</li></ul><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件，比如IDE的一些个人偏好设置。</li></ul><p>不需要从头写.gitignore文件，<a href="https://github.com/github/gitignore">github/gitignore </a> 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。</p><p>如 iOS 项目忽略文件的几项配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## User settings</span></span><br><span class="line">xcuserdata/</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)</span></span><br><span class="line">*.xcscmblueprint</span><br><span class="line">*.xccheckout</span><br><span class="line"></span><br><span class="line"><span class="comment">## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)</span></span><br><span class="line">build/</span><br><span class="line">DerivedData/</span><br><span class="line"></span><br><span class="line"><span class="comment">## App packaging</span></span><br><span class="line">*.ipa</span><br><span class="line">*.dSYM.zip</span><br><span class="line">*.dSYM</span><br></pre></td></tr></table></figure><h4 id="3-2-3-忽略文件的检查"><a href="#3-2-3-忽略文件的检查" class="headerlink" title="3.2.3 忽略文件的检查"></a>3.2.3 忽略文件的检查</h4><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：The following paths are ignored by one of your .gitignore files，可以使用<code>git add -f &lt;file&gt;</code>强制添加。</p><p>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore -v &lt;file&gt;</code>命令检查， Git会告诉我们，.gitignore的第几行规则忽略了该文件。</p><h3 id="3-3-git-config配置"><a href="#3-3-git-config配置" class="headerlink" title="3.3 git config配置"></a>3.3 git config配置</h3><h4 id="3-3-1-三种优先级的配置"><a href="#3-3-1-三种优先级的配置" class="headerlink" title="3.3.1 三种优先级的配置"></a>3.3.1 三种优先级的配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config [--global | --system] &lt;oo&gt;.&lt;kk&gt; &lt;vv&gt;</span><br><span class="line"><span class="comment"># 如配置用户信息    git config user.name/email xx</span></span><br><span class="line"><span class="comment"># 如配置编辑器      git config core.editor emacs</span></span><br><span class="line"><span class="comment"># 如配置别名       git config alias.st status</span></span><br><span class="line"><span class="comment"># 如配置输出的着色  git config color.ui false</span></span><br></pre></td></tr></table></figure><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： </p><ul><li><code>/etc/gitconfig</code>：包含系统上每一个用户及他们仓库的通用配置，使用带有 <code>--system</code> 选项的git config时，会从此文件读写配置变量；</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。 </li><li>仓库目录下 <code>/.git/config</code>：只针对该仓库，在仓库中使用带有 <code>--local</code>(默认) 选项的git config时，会读写该文件；<br>在优先级方面，从上往下依次上升。</li></ul><p>git config 的配置项有很多，详细可以看 <a href="https://github.com/git/git/tree/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config">git文档</a>。下面只是列出常见的几种。</p><h4 id="3-3-2-配置用户信息"><a href="#3-3-2-配置用户信息" class="headerlink" title="3.3.2 配置用户信息"></a>3.3.2 配置用户信息</h4><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面已经说过，用了--global参数表示这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</span></span><br><span class="line">git config --global user.name “Your Name”</span><br><span class="line">git config --global user.email “email@example.com”</span><br></pre></td></tr></table></figure><p>用户名和邮箱地址的作用：</p><ul><li>每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改；</li><li>github 的 contributions 统计就是按邮箱来统计的。</li><li>注意：<strong>name、email是不用作git权限校验的，只为commit时做记录，随便怎么改都行</strong>。<br>亲证：误操作，用了一个全局配置的git name/email(公司的)用户名和邮箱，成功推送到了我的私人仓库</li></ul><p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p><h4 id="3-3-3-配置文本编辑器"><a href="#3-3-3-配置文本编辑器" class="headerlink" title="3.3.3 配置文本编辑器"></a>3.3.3 配置文本编辑器</h4><p>当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><blockquote><p>Vim 和 Emacs 是像 Linux 与 Mac 等基于 Unix 的系统上开发者经常使用的流行的文本编辑器。 如果你对这些编辑器都不是很了解或者你使用的是 Windows 系统，那么可能需要搜索如何在 Git 中配置你最常用的编辑器。 如果你不设置编辑器并且不知道 Vim 或 Emacs 是什么，当它们运行起来后你可能会被弄糊涂、不知所措。</p></blockquote><h4 id="3-3-4-配置Git别名"><a href="#3-3-4-配置Git别名" class="headerlink" title="3.3.4 配置Git别名"></a>3.3.4 配置Git别名</h4><p>别名可以使你的 Git 体验更简单、容易、熟悉。</p><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 <code>git config</code> 文件来轻松地为每一个命令设置一个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.co checkout </span><br><span class="line">git config --global alias.ci commit </span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span>  <span class="comment">#使用git last查看最后一次提交</span></span><br></pre></td></tr></table></figure><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 <code>!</code> 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 <code>git visual</code> 定义为 <code>gitk</code> 的别名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-配置权限校验缓存"><a href="#3-3-5-配置权限校验缓存" class="headerlink" title="3.3.5 配置权限校验缓存"></a>3.3.5 配置权限校验缓存</h4><p>如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。</p><p>如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 <code>git config --global credential.helper cache</code> 来设置它。</p><p>了解更多关于不同验证缓存的可用选项，查看 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a>。</p><h4 id="3-3-6-配置Git的着色"><a href="#3-3-6-配置Git的着色" class="headerlink" title="3.3.6 配置Git的着色"></a>3.3.6 配置Git的着色</h4><p>Git 充分支持对终端内容着色，对你凭肉眼简单、快速分析命令输出有很大帮助。</p><p>Git 会自动着色大部分输出内容，但如果你不喜欢花花绿绿，也可以关掉。 要想关掉 Git 的终端颜色输出，试一下这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个设置的默认值是 <code>auto</code>，它会着色直接输出到终端的内容；而当内容被重定向到一个管道或文件时，则忽略着色功能。</p><p>你也可以设置成 <code>always</code>，来忽略掉管道和终端的不同，即在任何情况下着色输出。 你很少会这么设置，在大多数场合下，如果你想在被重定向的输出中插入颜色码，可以传递 <code>--color</code> 标志给 Git 命令来强制它这么做。 默认设置就已经能满足大多数情况下的需求了。</p><p>要想具体到哪些命令输出需要被着色以及怎样着色，你需要用到和具体命令有关的颜色配置选项。 它们都能被置为 <code>true</code>、<code>false</code> 或 <code>always</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color.branch</span><br><span class="line">color.diff</span><br><span class="line">color.interactive</span><br><span class="line">color.status</span><br></pre></td></tr></table></figure><p>另外，以上每个配置项都有子选项，它们可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，为了让 <code>diff</code> 的输出信息以蓝色前景、黑色背景和粗体显示，你可以运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.diff.meta <span class="string">&quot;blue black bold&quot;</span></span><br></pre></td></tr></table></figure><p>你能设置的颜色有：<code>normal</code>、<code>black</code>、<code>red</code>、<code>green</code>、<code>yellow</code>、<code>blue</code>、<code>magenta</code>、<code>cyan</code> 或 <code>white</code>。 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择包括：<code>bold</code>、<code>dim</code>、<code>ul</code>（下划线）、<code>blink</code>、<code>reverse</code>（交换前景色和背景色）。</p><h4 id="3-3-7-查看配置信息"><a href="#3-3-7-查看配置信息" class="headerlink" title="3.3.7 查看配置信息"></a>3.3.7 查看配置信息</h4><p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=John Doe</span><br><span class="line">user.email=johndoe@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：<code>/etc/gitconfig</code> 与 <code>~/.gitconfig</code>）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。</p><p>你可以通过输入 <code>git config &lt;key&gt;</code>： 来检查 Git 的某一项配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure><h2 id="四、服务器上的Git"><a href="#四、服务器上的Git" class="headerlink" title="四、服务器上的Git"></a>四、服务器上的Git</h2><h3 id="4-1-Git-的四种传输协议"><a href="#4-1-Git-的四种传输协议" class="headerlink" title="4.1 Git 的四种传输协议"></a>4.1 Git 的四种传输协议</h3><p>Git 可以使用四种主要的协议来传输资料：本地协议（Local），HTTP 协议，SSH（Secure Shell）协议及 Git 协议。</p><h4 id="4-1-1-哑协议与智能协议之分"><a href="#4-1-1-哑协议与智能协议之分" class="headerlink" title="4.1.1 哑协议与智能协议之分"></a>4.1.1 哑协议与智能协议之分</h4><p><a href="https://www.progit.cn/#_%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">原文链接</a> Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。</p><p>如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。 这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 <code>GET</code> 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。</p><blockquote><p>现在已经很少使用哑协议了。 使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。 一般情况下都建议使用智能协议。</p></blockquote><p>哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。 智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><ul><li>为了上传数据至远端，Git 使用 <code>send-pack</code> 和 <code>receive-pack</code> 进程。 运行在客户端上的 <code>send-pack</code> 进程连接到远端运行的 <code>receive-pack</code> 进程。</li><li>当你在下载数据时， <code>fetch-pack</code> 和 <code>upload-pack</code> 进程就起作用了。 客户端启动 <code>fetch-pack</code> 进程，连接至远端的 <code>upload-pack</code> 进程，以协商后续传输的数据。</li></ul><h4 id="4-1-2-本地协议"><a href="#4-1-2-本地协议" class="headerlink" title="4.1.2 本地协议"></a>4.1.2 本地协议</h4><p>最基本的就是 <em>本地协议（Local protocol）</em> ，其中的远程版本库就是硬盘内的另一个目录。 这常见于团队每一个成员都对一个共享的文件系统（例如一个挂载的 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。 后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。</p><p>如果你使用共享文件系统，就可以从本地版本库克隆（clone）、推送（push）以及拉取（pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，使用版本库路径作为 URL。 例如，克隆一个本地版本库，可以执行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /opt/git/project.git</span><br></pre></td></tr></table></figure><p>或你可以执行这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> file:///opt/git/project.git</span><br></pre></td></tr></table></figure><p>如果在 URL 开头明确的指定 <code>file://</code>，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 <code>file://</code>，Git 会触发平时用于网路传输资料的进程，那通常是传输效率较低的方法。 指定 <code>file://</code> 的主要目的是取得一个没有外部参考（extraneous references）或对象（object）的干净版本库副本– 通常是在从其他版本控制系统导入后或一些类似情况（参见 <a href="https://www.progit.cn/#_git_internals">Git 内部原理</a> for maintenance tasks）需要这么做。 在此我们将使用普通路径，因为这样通常更快。</p><h4 id="4-1-3-SSH-协议"><a href="#4-1-3-SSH-协议" class="headerlink" title="4.1.3 SSH 协议"></a>4.1.3 SSH 协议</h4><p>架设 Git 服务器时常用 SSH 协议作为传输协议。 因为大多数环境下已经支持通过 SSH 访问 —— 即时没有也比较很容易架设。 SSH 协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。</p><p>通过 SSH 协议克隆版本库，你可以指定一个 <code>ssh://</code> 的 URL：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> ssh://user@server/project.git</span></span><br></pre></td></tr></table></figure><p>或者使用一个简短的 scp 式的写法：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> user@server:project.git</span></span><br></pre></td></tr></table></figure><p>你也可以不指定用户，Git 会使用当前登录的用户名。</p><h5 id="1-优势"><a href="#1-优势" class="headerlink" title="1. 优势"></a>1. 优势</h5><p>用 SSH 协议的优势有很多。 首先，SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具。 其次，通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密。 最后，与 HTTP/S 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据。</p><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>SSH 协议的缺点在于你不能通过他实现匿名访问。 即便只要读取数据，使用者也要有通过 SSH 访问你的主机的权限，这使得 SSH 协议不利于开源的项目。 如果你只在公司网络使用，SSH 协议可能是你唯一要用到的协议。 如果你要同时提供匿名只读访问和 SSH 协议，那么你除了为自己推送架设 SSH 服务以外，还得架设一个可以让其他人访问的服务。</p><h4 id="4-1-4-Git-协议"><a href="#4-1-4-Git-协议" class="headerlink" title="4.1.4 Git 协议"></a>4.1.4 Git 协议</h4><p>接下来是 Git 协议。 这是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 要让版本库支持 Git 协议，需要先创建一个 <code>git-daemon-export-ok</code> 文件 —— 它是 Git 协议守护进程为这个版本库提供服务的必要条件 —— 但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。 这意味着，通常不能通过 Git 协议推送。 由于没有授权机制，一旦你开放推送操作，意味着网络上知道这个项目 URL 的人都可以向项目推送数据。 不用说，极少会有人这么做。</p><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><p>目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><p>Git 协议缺点是缺乏授权机制。 把 Git 协议作为访问项目版本库的唯一手段是不可取的。 一般的做法里，会同时提供 SSH 或者 HTTPS 协议的访问服务，只让少数几个开发者有推送（写）权限，其他人通过 <code>git://</code> 访问只有读权限。 Git 协议也许也是最难架设的。 它要求有自己的守护进程，这就要配置 <code>xinetd</code> 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。</p><h4 id="4-1-5-HTTP-协议"><a href="#4-1-5-HTTP-协议" class="headerlink" title="4.1.5 HTTP 协议"></a>4.1.5 HTTP 协议</h4><p>Git 通过 HTTP 通信有两种模式。 在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。 Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为“智能” HTTP 协议，旧版本的一般被称为“哑” HTTP 协议。 我们先了解一下新的“智能” HTTP 协议。</p><h5 id="1-智能（Smart）-HTTP-协议"><a href="#1-智能（Smart）-HTTP-协议" class="headerlink" title="1. 智能（Smart） HTTP 协议"></a>1. 智能（Smart） HTTP 协议</h5><p><a href="https://www.progit.cn/#_smart_http">Smart HTTP</a>：我们一般通过 SSH 进行授权访问，通过 git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置 Smart HTTP 一般只需要在服务器上启用一个 Git 自带的名为 <code>git-http-backend</code> 的 CGI 脚本。 该 CGI 脚本将会读取由 <code>git fetch</code> 或 <code>git push</code> 命令向 HTTP URL 发送的请求路径和头部信息，来判断该客户端是否支持 HTTP 通信（不低于 1.6.6 版本的客户端支持此特性）。 如果 CGI 发现该客户端支持智能（Smart）模式，它将会以智能模式与它进行通信，否则它将会回落到哑（Dumb）模式下（因此它可以对某些老的客户端实现向下兼容）。</p><p>“智能” HTTP 协议的运行方式和 SSH 及 Git 协议类似，只是运行在标准的 HTTP/S 端口上并且可以使用各种 HTTP 验证机制，这意味着使用起来会比 SSH 协议简单的多，比如可以使用 HTTP 协议的用户名／密码的基础授权，免去设置 SSH 公钥。</p><p>智能 HTTP 协议或许已经是最流行的使用 Git 的方式了，它即支持像 <code>git://</code> 协议一样设置匿名服务，也可以像 SSH 协议一样提供传输时的授权和加密。 而且只用一个 URL 就可以都做到，省去了为不同的需求设置不同的 URL。 如果你要推送到一个需要授权的服务器上（一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。</p><p>事实上，类似 GitHub 的服务，你在网页上看到的 URL （比如， <code>https://github.com/schacon/simplegit[]</code>)，和你在克隆、推送（如果你有权限）时使用的是一样的。</p><h5 id="2-哑（Dumb）-HTTP-协议"><a href="#2-哑（Dumb）-HTTP-协议" class="headerlink" title="2. 哑（Dumb） HTTP 协议"></a>2. 哑（Dumb） HTTP 协议</h5><p>如果服务器没有提供智能 HTTP 协议的服务，Git 客户端会尝试使用更简单的“哑” HTTP 协议。 哑 HTTP 协议里 web 服务器仅把裸版本库当作普通文件来对待，提供文件服务。 哑 HTTP 协议的优美之处在于设置起来简单。 基本上，只需要把一个裸版本库放在 HTTP 根目录，设置一个叫做 <code>post-update</code> 的挂钩就可以了（见 <a href="https://www.progit.cn/#_git_hooks">Git 钩子</a>）。 此时，只要能访问 web 服务器上你的版本库，就可以克隆你的版本库。</p><p>通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。</p><h5 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h5><p>我们将只关注智能 HTTP 协议的优点。</p><p>不同的访问方式只需要一个 URL 以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用 Git 变得非常简单。 相比 SSH 协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用 Git 之前先在本地生成 SSH 密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少 SSH 相关程序的使用者，HTTP 协议的可用性是主要的优势。 与 SSH 协议类似，HTTP 协议也非常快和高效。</p><p>你也可以在 HTTPS 协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书。</p><p>另一个好处是 HTTP/S 协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过。</p><h5 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h5><p>在一些服务器上，架设 HTTP/S 协议的服务端会比 SSH 协议的棘手一些。 除了这一点，用其他协议提供 Git 服务与 “智能” HTTP 协议相比就几乎没有优势了。</p><p>如果你在 HTTP 上使用需授权的推送，管理凭证会比使用 SSH 密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如 OSX 的 Keychain 或者 Windows 的凭证管理器。 参考 <a href="https://www.progit.cn/#_credential_caching">凭证存储</a> 如何安全地保存 HTTP 密码。</p><h3 id="4-2-搭建Git服务器"><a href="#4-2-搭建Git服务器" class="headerlink" title="4.2 搭建Git服务器"></a>4.2 搭建Git服务器</h3><p>搭建Git服务器非常简单，通常10分钟即可完成； </p><ul><li>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis">Gitosis</a>； </li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite">Gitolite</a>。</li></ul><p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器</a></p><h3 id="4-3-error：hung-up-unexpectedly"><a href="#4-3-error：hung-up-unexpectedly" class="headerlink" title="4.3 error：hung up unexpectedly"></a>4.3 error：hung up unexpectedly</h3><p>使用场景：clone、push的时候报错<code>The remote end hung up unexpectedly</code>时</p><ul><li>git <code>config http.postBuffer 524288000 </code>(stackOverFlow上有人说好像对SSH协议报这个错时也有效)</li><li>也可能是：接口不通(Git默认端口22，可能运维改了)，或者网络不好</li><li>可以试试，具体还是以<code>“error: ...信息”</code>为准（ 如果改了postBuffer，问题解决之后，建议改回去 ）</li></ul><p>我当时因为传输了大量大文件，修改了http.postBuffer没用；</p><p>还有说修改http.lowSpeedLimit=0、http.lowSpeedTime=999999；设置允许的最低速度，最低速度时间(没试，我是SSH协议push的！）</p><p>修改了SSH的重连ServerAliveInterval=30、ServerAliveCountMax=5没用；</p><p>后来无奈，只能分批次上传。</p><h4 id="4-3-1-配置http-postBuffer"><a href="#4-3-1-配置http-postBuffer" class="headerlink" title="4.3.1 配置http.postBuffer"></a>4.3.1 配置http.postBuffer</h4><blockquote><p><a href="https://github.com/git/git/blob/7a2dc95cbc25b4b82cff35931f69f8a5aafeb878/Documentation/config/http.txt#L195-L209">官方链接</a></p><p>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally.  Default is 1 MiB, which is sufficient for most requests.</p><p>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard.  Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</p></blockquote><p>个人认为：这个参数是用来设置HTTP传输发送buffer池的大小(池子满了，或者数据已写入完毕就发送)</p><ul><li>客户端、服务端会根据这个参数来申请内存当做buffer池(所以如果太大了，会消耗内存，而且如果块太大，并不是所有的服务器系统都能正常接收处理的)</li><li>客户端推送的大小如果超过这个可能会失败(至于说是本地发送失败，还是因为服务端根据这个设置的接收buffer池大小，结果接收到的数据太大，缓冲区溢出造成的失败就不清楚了)</li><li>服务端应答的大小如果超过这个会分块传输</li><li>仅对禁用分块传输编码有效（因此仅在远程服务器或代理仅支持HTTP/1.0或不符合HTTP标准的情况下才应使用），意思是分块传输编码时，有自己的分块传输(块多大)策略，而且优先级更高</li></ul><p>服务端程序在接收客户端表单提交的数据时，需要先将数据存储到一个内存空间，然后做解析等后续工作，这个内存空间一般称之为接收缓冲区。对于post数据因为有Content-Length标记，服务端可以按标记的长度创建一个等于或稍大于提交数据的缓冲区；对于get，因为事先不知道提交的数据有多少，需要估计缓冲区长度，如果缓冲区很大而接收数据很小会造成内存浪费，而如果缓冲区小于接收数据，就可能造成缓冲区溢出。</p><p>“聪明的”黑客，会在溢出部分放置特殊的代码来攻陷你的服务器。<a href="https://www.cnblogs.com/meilibao/archive/2012/10/29/2744525.html">博客</a></p><h4 id="4-3-2-补充：Transfer-Encoding-chunked"><a href="#4-3-2-补充：Transfer-Encoding-chunked" class="headerlink" title="4.3.2 补充：Transfer-Encoding:chunked"></a>4.3.2 补充：Transfer-Encoding:chunked</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">维基百科</a></p><p>表示输出的内容长度不能确定， 通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度， 先把整个要输出的数据写到一个很大的字节数组里(如 ByteArrayOutputStream)，然后得到数组大小 -&gt; Content-Length。 </p><p>如果结合Transfer-Encoding: chunked使用，就不必申请一个很大的字节数组了，可以一块一块的输出，更科学，占用资源更少。 这在http协议中也是个常见的字段，用于http传送过程的分块技术，原因是http服务器响应的报文长度经常是不可预测的，使用Content-length的实体搜捕并不是总是管用。</p><h2 id="五、Git的两种鉴权方式"><a href="#五、Git的两种鉴权方式" class="headerlink" title="五、Git的两种鉴权方式"></a>五、Git的两种鉴权方式</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是：</p><ul><li>前者采用账号密码进行校验；</li><li>后者采用SSH秘钥对进行校验。</li></ul><h3 id="5-1-SSH"><a href="#5-1-SSH" class="headerlink" title="5.1 SSH"></a>5.1 SSH</h3><p><a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">GitHub官网配置步骤指导</a></p><p>只要选择正确的密钥，本地的私钥加密，对应的远程仓库账号中事先添加的公钥能解开就能提交成功。</p><p>生成公钥时，需要指定GitHub的邮箱地址，配置在GitHub中的公钥串中也包含邮箱，GitHub是校验的这个邮箱账号。</p><h4 id="5-1-1-ssh-agent"><a href="#5-1-1-ssh-agent" class="headerlink" title="5.1.1 ssh-agent"></a>5.1.1 ssh-agent</h4><p>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。参考链接：<a href="https://www.zsythink.net/archives/2407">了解ssh代理：ssh-agent</a>。</p><p>个人理解： 类似VPN代理软件吧，会拦截我们的请求并针对性地加以处理。还有一点相同的是： 将私钥加入ssh-agent后，即使删除私钥文件，本地计算机仍可以正常访问 GitHub 代码仓库。</p><h4 id="5-1-2-修改SSH默认端口"><a href="#5-1-2-修改SSH默认端口" class="headerlink" title="5.1.2 修改SSH默认端口"></a>5.1.2 修改SSH默认端口</h4><p>为了安全起见，有时会修改服务器ssh连接端口，比如改为3222。此时我们需要在 <em>/etc/ssh/ssh_config</em> 或者 <em>~/.ssh/config</em> 中找到行 <em>port 22</em> 并修改(像这种配置文件最好使用vim编辑器)。</p><h3 id="5-2-HTTPS"><a href="#5-2-HTTPS" class="headerlink" title="5.2 HTTPS"></a>5.2 HTTPS</h3><p>https 除了速度慢以外，还有个最大的麻烦是每次与远程仓库交互时，都必须输入账号(可以是git用户名，也可以是邮箱地址)、口令进行校验。</p><p>可以记住密码：</p><ul><li>Mac中可以存储在keychain中，<strong>在开启Keychain机制的情况下，进行权限校验后会自动将账号密码保存至Keychain Access</strong>。</li><li>Mac、Windows共用—— git 提供的 credential helper机制：可以将账号密码以 cache 的形式在内存中缓存一段时间（默认 15 分钟），或者以文件的形式存储起来（~/.git-credentials）。</li></ul><h3 id="5-3-配置不同账号访问不同仓库"><a href="#5-3-配置不同账号访问不同仓库" class="headerlink" title="5.3 配置不同账号访问不同仓库"></a>5.3 配置不同账号访问不同仓库</h3><p>当一台计算机中需要以不同账号访问不同的仓库时：</p><ul><li>SSH：如果不同的仓库配置了不同的公钥，那么在使用本地私钥时，就要加以区分。(当然也可以所有仓库都使用一套公钥、私钥，理论上私钥只有自己知道)。</li><li>HTTPS：如果不记住账号密码，即每次都输入账号密码，那就不需要配置。<ul><li>如果使用Keychain记住了密码，此时会根据仓库的 host 去 Keychain 中寻找账户密码，因为 Keychain 中针对这个host 存储了多个账号、密码，那找出的可能是错误的，此时就会权限校验失败。此时我们需要处理一下我们的仓库URL。</li></ul></li></ul><h4 id="5-3-1-SSH的处理"><a href="#5-3-1-SSH的处理" class="headerlink" title="5.3.1 SSH的处理"></a>5.3.1 SSH的处理</h4><p>以SSH方式：通过远程仓库的url（clone之后存储在 <code>repo/.git/config</code> 中）的host </p><ul><li>找到host配置的对应SSH-Key(SSH-Key一般都存在 <code>~/.ssh</code> 文件夹中)<ul><li>当只有一个SSH账号时，<code>/etc/ssh/ssh_config</code> 配置文件，默认直接指向 <code>~/.ssh/id_rsa</code>。</li><li>当有多个SSH账号时，<code>~/.ssh/config</code> 配置文件中，分别配置每个host对应的 <code>~/.ssh</code> 中的SSH-Key。</li></ul></li><li>通过密钥进行权限校验</li></ul><p>两个文件的影响范围：</p><ul><li><code>/etc/ssh/ssh_config</code> 下的配置是针对当前系统所有用户</li><li><code>~/.ssh/config</code> (/User/用户名/.ssh/config)只针对当前用户(默认是没有该文件的，只有当有多个用户，需要做映射时，才创建、配置)</li></ul><p>如果两个仓库host不相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host github.com <span class="comment"># Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件</span></span><br><span class="line">    Port 22         <span class="comment"># 端口号（如果不是默认22号端口则需要指定） </span></span><br><span class="line">    HostName github.com  <span class="comment"># 是代码仓库服务器的主机(此处是github)</span></span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa  <span class="comment"># 指明User对应的identityFile路径，即SSH-Key</span></span><br><span class="line">    User loten   <span class="comment"># 登录名（如gitlab的username） </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一个同上，如 smartgit</span></span><br></pre></td></tr></table></figure><p>如果两个仓库host也相同，则需要在Host中进行区分，然后经过 <code>CNAME</code> 映射到 <code>HostName</code>（<strong>Host相当于是HostName的别名</strong>），然后分别指向不同的SSH-key，即IdentityFile，从而实现了对两个 GitHub 账号的分离。（<strong>HostName才是真正指定 GitHub 服务器主机的字段</strong>）</p><p>在config文件修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debugtalk</span></span><br><span class="line">Host debugtalk</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User git</span><br><span class="line"></span><br><span class="line"><span class="comment"># DJI</span></span><br><span class="line">Host djileolee</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/dji_id_rsa</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure><p>此处改了还没完，还需要在各个项目中分别进行修改配置：代码提交、拉取时远程仓库的地址。 即<code>repo/.git/config</code>文件：可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将原先的远程仓库的URL  git@github.com:debugtalk/DroidMeter.git中的host改成我们刚设置的host(别名)</span></span><br><span class="line">git remote add origin git@debugtalk:debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure><h4 id="5-3-2-HTTPS的处理"><a href="#5-3-2-HTTPS的处理" class="headerlink" title="5.3.2 HTTPS的处理"></a>5.3.2 HTTPS的处理</h4><p>以HTTPS方式：通过远程仓库的url（clone之后存储在repo/.git/config中）。</p><p>比如：本来的HTTPS URL为 <code>https://github.com/loten/RSAHandle.git</code> 手动改为：<code>https://loten@github.com/loten/RSAHandle.git</code>。</p><p>注意：loten是GitHub的用户名，不能打错。在第一次拉取/推送的时候(钥匙串keychain中还没存储账号、密码)，会要求输入该用户名对应的密码：Password Required For user Roten8 on host github.com. 输入成功后，即可成功拉取/推送。</p><p>配置原理很容易理解，即将 GitHub 用户名添加到仓库的 Git 地址中，这样在执行 git 命令的时候，系统就会采用指定的 GitHub 用户名去<code>Keychain</code> 或 <code>~/.git-credentials</code> 中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p><p>然后可以发现使用这种方式修改之后，可以看到keychain中的存储信息的<strong>账号</strong>：<strong>由邮箱号变为了Git用户名</strong>。即不再仅仅通过host来寻找账号密码，而是找到keychain中，这个host下指定的用户名对应的密码，来使用。</p><p>参考链接： <a href="https://ruby-china.org/topics/30298">Git深入浅出 Git 权限校验 (最熟悉的陌生概念)</a></p><h2 id="六、从仓库目录角度了解Git工作原理"><a href="#六、从仓库目录角度了解Git工作原理" class="headerlink" title="六、从仓库目录角度了解Git工作原理"></a>六、从仓库目录角度了解Git工作原理</h2><h3 id="6-1-目录结构"><a href="#6-1-目录结构" class="headerlink" title="6.1 目录结构"></a>6.1 目录结构</h3><img src="/images/git/dir.png" alt="dir" style="zoom:80%;" /><ul><li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间。</li><li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间/工作区/工作目录，除了 .git 之外的都属于工作区。<ul><li>工作目录下的文件有两种状态：已跟踪tracked或未跟踪untracked（新创建的文件，没有被add到暂存区就是untracked状态）</li></ul></li><li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD 会只是当前的开发分支（branch）。</li><li>Stash：是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li></ul><blockquote><p>一个 modification 的提交要经历工作区——add到暂存区(staged)——commit到本地仓库——push到远程仓库</p></blockquote><p>文件的状态改变：</p><img src="/images/git/lifecycle.png" alt="lifecycle" style="zoom:80%;" /><h3 id="6-2-git文件夹-版本库"><a href="#6-2-git文件夹-版本库" class="headerlink" title="6.2 .git文件夹(版本库)"></a>6.2 .git文件夹(版本库)</h3><h4 id="6-2-1-index"><a href="#6-2-1-index" class="headerlink" title="6.2.1 index"></a>6.2.1 index</h4><p>暂存区是Git相比SVN的特色；</p><p>当修改了工作区里的一个文件时，这些修改一开始是<code>unstaged</code>状态，为了提交这些修改，你需要使用<code>git add</code>把它加入到index，使它成为<code>staged</code>状态。当你提交一个commit时，index里面的修改被提交；</p><p>当在工作区新增一个文件，文件是<code>untracked</code>状态，<code>git add &lt;file&gt;</code>添加到index，变为<code>tracked</code>状态。</p><h4 id="6-2-2-objects"><a href="#6-2-2-objects" class="headerlink" title="6.2.2 objects/"></a>6.2.2 objects/</h4><p>该文件夹下存储了所有数据内容。主要有四大对象：数据对象、树对象、提交对象、标签对象。</p><h5 id="1-数据对象-对应-文件"><a href="#1-数据对象-对应-文件" class="headerlink" title="1. 数据对象(对应 文件)"></a>1. 数据对象(对应 文件)</h5><p>Git 是一个内容寻址文件系统，即Git 的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索（retrieve）该内容。 </p><p>可以通过底层命令hash-object来<strong>演示</strong>上述效果——该命令可将任意数据保存于.git目录，并返回相应的键值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test content&#x27;</span> | git hash-object -w --stdin</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span><br><span class="line">git hash-object -w test.txt</span><br></pre></td></tr></table></figure><ul><li>-w选项指示hash-object命令存储数据对象；若不指定此选项，则该命令仅返回对应的键值。</li><li>–stdin选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。 </li><li>该命令输出一个长度为 40 个字符的校验和。 这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。</li><li>可以在objects目录下看到一个文件， <strong>校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名</strong>。</li></ul><p>可以通过 <code>cat-file</code> 命令从 Git 那里取回数据，这个命令简直就是一把剖析 Git 对象的瑞士军刀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 打印其内部存储的对象类型（SHA-1 值为目录名+文件名）：输出为：`blob`、`tree`、`commit`</span></span><br><span class="line">git cat-file -t &lt;SHA-1&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 打印对象里的内容  </span></span><br><span class="line">git cat-file -p &lt;SHA-1&gt;  <span class="comment"># -p: Pretty-print 自动判断内容的类型，并为我们显示格式友好的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># - blob对象，打印出是可视化的，我们做的修改</span></span><br><span class="line"><span class="comment"># - tree对象，打印出其包含的数据对象和子树对象的SHA-1指针</span></span><br><span class="line"><span class="comment"># - commit对象，打印出：tree对象、parent父提交对象、author(name、email、时间戳)、commiter、留空一行、注释</span></span><br></pre></td></tr></table></figure><p><strong>每当一个文件修改时，就会生成一个数据对象。数据对象的内容是源文件当前的全部内容</strong>(<strong>而非存储的修改内容，保证了每次切换节点时，快速恢复！</strong>)。</p><p>不过， 记住文件的每一个版本所对应的 SHA-1 值并不现实。另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。 上述类型的对象我们称之为数据对象（blob object）</p><h5 id="2-树对象-对应-目录"><a href="#2-树对象-对应-目录" class="headerlink" title="2. 树对象(对应 目录)"></a>2. 树对象(对应 目录)</h5><p>树对象（tree object）能解决文件名保存的问题，也允许我们将多个文件组织到一起。 <strong>Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化</strong>：</p><ul><li><p>所有内容均以树对象和数据对象的形式存储，其中<font color='red'>树对象对应了 UNIX 中的目录项</font><strong>，</strong><font color='red'>数据对象则大致上对应了 inodes 或文件内容</font>；</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Inode">inode</a>是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p><p>我觉得，理解inode，不仅有助于提高系统操作水平，还有助于体会Unix设计哲学，即如何把底层的复杂性抽象成一个简单概念，从而大大简化用户接口。</p><p><strong>一、inode是什么？</strong></p><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><p><strong>二、inode的内容</strong></p><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li><p>文件的字节数</p></li><li><p>文件拥有者的User ID</p></li><li><p>文件的Group ID</p></li><li><p>文件的读、写、执行权限</p></li><li><p>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</p></li><li><p>链接数，即有多少文件名指向这个inode</p></li><li><p>文件数据block的位置</p></li></ul><p>可以用stat命令，查看某个文件的inode信息：<code>stat example.txt</code></p></blockquote></li><li><p>一个树对象包含了一条或多条树对象记录（tree entry）；</p></li><li><p>每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p><ul><li>文件模式为 <code>100644</code>，表明这是一个普通文件。 </li><li><code>100755</code>，表示一个可执行文件；</li><li><code>120000</code>，表示一个符号链接。</li><li> 这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是 Git 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。</li></ul></li></ul><p>通常，Git 根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。</p><p>可以通过<code>write-tree</code>命令将暂存区内容写入一个树对象。</p><p>例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master^&#123;tree&#125;语法表示 master 分支上最新的提交所指向的树对象</span></span><br><span class="line">git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，lib子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象</span></span><br><span class="line">git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0</span><br><span class="line">100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件、以及一个目录：</p><img src="/images/git/data-model-1.png" alt="data-model-3" style="zoom:70%;" /><p>下面是个（非常规操作…）举例，你可以将一个旧的树对象加入新的树对象，使其成为新的树对象的一个子目录。 通过调用 <code>read-tree</code> 命令，可以把树对象读入暂存区。本例中，可以通过对 <code>read-tree</code> 指定 <code>--prefix</code> 选项，将一个已有的树对象作为子树读入暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">$ git write-tree</span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</span><br></pre></td></tr></table></figure><p>如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为 <code>bak</code> 的子目录，该子目录包含 test.txt 文件的第一个版本。 可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：</p><img src="/images/git/data-model-2.png" alt="data-model-3" style="zoom:70%;" /><h5 id="3-提交对象"><a href="#3-提交对象" class="headerlink" title="3. 提交对象"></a>3. 提交对象</h5><p><strong>树对象代表了我们想要跟踪的不同项目快照</strong>。然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。 并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。 而以上这些，正是提交对象（commit object）能为你保存的基本信息。</p><ul><li>可以通过调用<code>commit-tree</code>命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。</li><li>提交对象的格式很简单：<ul><li>它先指定一个顶层树对象，代表当前项目快照；<strong>这个树对象记录了此刻工作目录所有文件的状态，这也是Git切换快速便捷的原理</strong>。</li><li>然后是作者/提交者信息（依据你的user.name和user.email配置来设定，外加一个时间戳）；</li><li>留空一行，最后是提交注释。(重要的两点：顶层树对象、父提交对象)</li></ul></li><li>提交对象的<strong>SHA-1值即为commit id</strong></li></ul><p><strong>提交对象对应的这个最顶层的树对象就对应了我们的工作目录，下面的每一个tree对象对应我们项目中的文件夹，每一个的blob对象就是此时该文件的最新全部内容</strong>。比如下面是一个大项目的master分支上最新提交对应的树对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p master^&#123;tree&#125;</span><br><span class="line">100644 blob 17eb1b55d91525217c8615813a702207d038eec8.DS_Store</span><br><span class="line">100755 blob 47acf8552d011d70d98b1805a1f2fd00ca060356.gitignore</span><br><span class="line">040000 tree 7b19b9ca1fece9c204770f7ddfa3a362f12dbf2eLLBaseKit</span><br><span class="line">040000 tree 8f826ece85e875c00af345ab4b40c6661a512eb5LLIDCard</span><br><span class="line">040000 tree 3f96965ac93c24a71a4bff9bbfbc587d5889bc92LLLiveDetection</span><br><span class="line">100644 blob a42e52ed334aa15800dca69d256d0e340494551fPodfile</span><br><span class="line">100644 blob f0430fd46587a9c29a5385001adb89c6ae9ef759Podfile.lock</span><br><span class="line">040000 tree 44e5dd79ef5a0435e1f3a0ea112cbaf8b6b48071Pods</span><br><span class="line">040000 tree dd706fe8898be1a2a7ccdfc3fb61115a0aef4b01RTSu.xcodeproj</span><br><span class="line">040000 tree 65ac1588391931d47e65f7fc7c2032f6a738a819RTSu.xcworkspace</span><br><span class="line">040000 tree 221347dd21123109ffa63300c4003de34cfec8f4RTSu</span><br><span class="line">040000 tree bd7d6129ab1bbf677aaaab85f493ed437c976493RTSuJPush</span><br><span class="line">040000 tree 40152f8dc68864e779104a782278ee2bd3dcd9e4RTSuTests</span><br><span class="line">040000 tree b8397ded7e7b5efa1cc83bddc69a93fc2c6cc1c7RTSuUITests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以 git cat-file -p 打印上面的树对象，打印出来即是我们的源文件</span></span><br></pre></td></tr></table></figure><h5 id="4-三种对象的关系图"><a href="#4-三种对象的关系图" class="headerlink" title="4. 三种对象的关系图"></a>4. 三种对象的关系图</h5><p>每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时， Git 所做的实质工作——将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git/objects 目录下。 如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：</p><img src="/images/git/data-model-3.png" alt="data-model-3" style="zoom:80%;" /><h5 id="5-对象的存储"><a href="#5-对象的存储" class="headerlink" title="5. 对象的存储"></a>5. 对象的存储</h5><p>Git在存储内容时，会有个头部信息一并被保存</p><ul><li>以对象类型作为开头来构造一个头部信息：比如“blob”字符串，接着 Git 会添加一个空格，随后是数据内容的长度，最后是一个空字节（null byte）<code>&quot;blob #&#123;content.length&#125;\0&quot;</code></li><li>将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和</li><li>通过 zlib 压缩这条新内容</li><li>最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。 要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。 如果该子目录不存在则创建它。</li><li>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</li></ul><h4 id="6-2-3-refs"><a href="#6-2-3-refs" class="headerlink" title="6.2.3 refs/"></a>6.2.3 refs/</h4><p>存储指向数据（分支）的提交对象的指针；</p><p>GIT引用概述：由于一些地方需要用到SHA-1值，而SHA-1不易记录， 我们需要一个文件来保存 SHA-1 值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。</p><ul><li>在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；可以在.git/refs目录下找到这类含有 SHA-1 值的文件。(<strong>帮助我们记忆最新提交所在的位置</strong>)；</li><li>这基本就是 Git 分支的本质：<strong>一个指向某一系列提交之首的指针或引用</strong>， 当运行类似于 <code>git branch (branchname)</code> 这样的命令时，Git 实际上会运行 <code>update-ref</code> 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</li></ul><img src="/images/git/data-model-4.png" alt="data-model-4" style="zoom:90%;" /><h5 id="1-heads-—-HEAD引用"><a href="#1-heads-—-HEAD引用" class="headerlink" title="1. heads/ — HEAD引用"></a>1. heads/ — HEAD引用</h5><p>现在的问题是，当你执行<code>git branch (branchname)</code>时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。</p><p>HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针：</p><ul><li>如果查看 HEAD 文件的内容，一般而言我们看到的类似这样： <code>ref: refs/heads/master(或者当前分支名)</code>；</li><li>当我们执行<code>git commit</code>时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 SHA-1 值设置其父提交字段。</li></ul><p>/refs/heads/ 记录<code>本地</code>每个分支的提交之首</p><h5 id="2-tags-—-Tag引用"><a href="#2-tags-—-Tag引用" class="headerlink" title="2. tags/ — Tag引用"></a>2. tags/ — Tag引用</h5><p>标签对象（tag object）非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 </p><p>主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><ul><li>轻量标签： 只是一个特定提交的固定引用</li><li>附注标签：Git 会创建一个标签对象，并记录一个引用来指向该标签对象，而不是直接指向提交对象</li></ul><p>标签对象并非必须指向某个提交对象；你可以对任意类型的 Git 对象(比如数据、树对象)打标签</p><h5 id="3-remotes-—-远程引用-remote-reference"><a href="#3-remotes-—-远程引用-remote-reference" class="headerlink" title="3. remotes/ — 远程引用(remote reference)"></a>3. remotes/ — 远程引用(remote reference)</h5><p>如果你添加了一个远程版本库并对其执行过推送操作，Git 会记录下每一个分支最近一次推送操作时所对应的SHA-1值，并保存在refs/remotes目录下(文件名为远程分支名)</p><ul><li>远程引用和分支（位于refs/heads目录下的引用）之间最主要的区别在于，远程引用是只读的（本地仓库的commit可以reset来修改HEAD的指向，但是remote repo的是不能的）</li></ul><p><strong>子文件夹为远程仓库的名称（如果有多个远程仓库(config文件中有多个[remote xxx])就有多个子文件夹），文件夹中的文件名称是远程仓库中执行过推送操作的远程分支名</strong>。</p><h5 id="4-for-—-Gerrit"><a href="#4-for-—-Gerrit" class="headerlink" title="4. for/ — Gerrit"></a>4. for/ — Gerrit</h5><p>如果我们使用的是Gerrit（一种开放源代码的代码审查软件，使用网页界面。利用网页浏览器，同一个团队的软件开发者，可以在评审网页上相互审阅彼此修改后的代码，决定是否能够提交，回退或是继续修改。它使用版本控制系统Git作为底层）</p><ul><li>Gerrit为了保证每次代码提交都强制开启代码评审，要求研发人员在提交代码的时候统一使用: git push [remote_name] HEAD:refs/for/[branch_name]，执行后会在评审界面创建一条新的code review，只有通过review之后才可以合入远程仓库。</li><li>此时如果执行<code>git push origin HEAD:refs/head/master</code>，那么就会有“! [remote rejected] master -&gt; master (prohibited by Gerrit)”的错误信息，命令失效。</li><li>对于那些希望将Code Review粒度控制在单次提交级别的研发团队，使用基于Gerrit机制的工具是比较合适的。( <a href="https://cloud.baidu.com/product/xly.html">百度效率云的iCode</a>就是基于Gerrit机制开发的 )</li></ul><img src="/images/git/gerrit.png" alt="gerrit" style="zoom:80%;" /><p>下面一段是对“refs/for”更详细的描述：</p><blockquote><p>The documentation for Gerrit explains that you push to the “magical refs/for/‘branch’ ref using any Git client tool”.</p><p>This image is taken from the Intro to Gerrit. When you push to Gerrit, you do git push gerrit HEAD:refs/for/<code>&lt;BRANCH&gt;</code>. This pushes your changes to the staging area (in the diagram, “Pending Changes”). Gerrit doesn’t actually have a branch called <code>&lt;BRANCH&gt;</code>; it lies to the git client.</p><p>Internally, Gerrit has it’s own implementation for the Git and SSH stacks. This allows it to provide the “magical” refs/for/<code>&lt;BRANCH&gt;</code> refs.</p><p>When a push request is received to create a ref in one of these namespaces Gerrit performs its own logic to update the database, and then lies to the client about the result of the operation. A successful result causes the client to believe that Gerrit has created the ref, but in reality Gerrit hasn’t created the ref at all.  </p><p>After a successful patch (i.e, the patch has been pushed to Gerrit, [putting it into the “Pending Changes” staging area], reviewed, and the review has passed), Gerrit pushes the change from the “Pending Changes” into the “Authoritative Repository”, calculating which branch to push it into based on the magic it did when you pushed to refs/for/<code>&lt;BRANCH&gt;</code>. This way, successfully reviewed patches can be pulled directly from the correct branches of the Authoritative Repository.</p></blockquote><h4 id="6-2-4-HEAD"><a href="#6-2-4-HEAD" class="headerlink" title="6.2.4 HEAD"></a>6.2.4 HEAD</h4><p>指向当前分支的当前提交；</p><h4 id="6-2-5-config"><a href="#6-2-5-config" class="headerlink" title="6.2.5 config"></a>6.2.5 config</h4><p>文件包含项目特有的配置选项，覆盖Git的全局配置</p><h4 id="6-2-6-description"><a href="#6-2-6-description" class="headerlink" title="6.2.6 description"></a>6.2.6 description</h4><p>仅供 GitWeb 程序使用，我们无需关心</p><h4 id="6-2-7-hooks"><a href="#6-2-7-hooks" class="headerlink" title="6.2.7 hooks/"></a>6.2.7 hooks/</h4><p>包含客户端或服务端的钩子脚本（hook scripts）, hook用户操作，拦截一些不合理的行为命令</p><h4 id="6-2-8-info"><a href="#6-2-8-info" class="headerlink" title="6.2.8 info/"></a>6.2.8 info/</h4><p>目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）</p><h2 id="七、常用命令"><a href="#七、常用命令" class="headerlink" title="七、常用命令"></a>七、常用命令</h2><h3 id="7-1-提交、撤销与查看"><a href="#7-1-提交、撤销与查看" class="headerlink" title="7.1 提交、撤销与查看"></a>7.1 提交、撤销与查看</h3><h4 id="1-git-checkout-工作区的撤销"><a href="#1-git-checkout-工作区的撤销" class="headerlink" title="1. git checkout  工作区的撤销"></a>1. git checkout  工作区的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销文件在工作区的修改(处于暂存区的修改不受影响)</span></span><br><span class="line">git checkout -- &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果不加<code>--</code>，就变成了“切换到另一个分支”的命令</li><li>untracked的文件修改不受影响</li></ul><h4 id="2-git-add-暂存区的提交"><a href="#2-git-add-暂存区的提交" class="headerlink" title="2. git add 暂存区的提交"></a>2. git add 暂存区的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt; <span class="comment"># .表示全选</span></span><br></pre></td></tr></table></figure><p>是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：</p><ul><li>可以用它开始跟踪新文件</li><li>把已跟踪的文件放到暂存区。</li><li>还能用于合并时把有冲突的文件标记为已解决状态</li></ul><h4 id="3-git-rm-暂存区的提交"><a href="#3-git-rm-暂存区的提交" class="headerlink" title="3. git rm 暂存区的提交"></a>3. git rm 暂存区的提交</h4><p>删除文件，并将这个删除添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;filename&gt;</span><br><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="4-git-commit-本地仓库的提交"><a href="#4-git-commit-本地仓库的提交" class="headerlink" title="4. git commit 本地仓库的提交"></a>4. git commit 本地仓库的提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;commit message&#x27;</span></span><br><span class="line">git commit -am(-a -m) <span class="string">&#x27;commit message&#x27;</span> <span class="comment"># 将tracked状态的文件的修改`add+commit`(该命令对未跟踪状态的文件修改不生效)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上一条提交的 commit message</span></span><br><span class="line">git commit --amend <span class="comment"># amend(修改，修订；纠正)。修改后是一次新的提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改之前提交的 commit message。比如说，我想修改距此版本之前的第3条 commit message</span></span><br><span class="line"><span class="comment"># 第一步：运行</span></span><br><span class="line">git rebase -i HEAD~3  <span class="comment"># 需要变基，也就是重新提交一遍。与上面的限制是一样，提交对象的commit msg不可修改，除非重新产生提交对象</span></span><br><span class="line"><span class="comment"># -i, --interactive(互动) 允许用户编辑要rebase的提交列表.</span></span><br><span class="line"><span class="comment"># 比如，此时显示</span></span><br><span class="line"><span class="comment"># pick 56b2308 feat(pages): home DONE</span></span><br><span class="line"><span class="comment"># pick 82f65eb fix(pages movie): slides bug fixed</span></span><br><span class="line"><span class="comment"># pick 08b2087 feat(pages home &amp; movie): add FABs animation </span></span><br><span class="line"><span class="comment"># 第二步：将要修改的那条 commit message，如 pick 56b2308 feat(pages): home DONE，pick 改为 edit，修改完成后保存退出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三步：然后仍然是运行下面的命令修改commit message</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四步：最后运行</span></span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p>将暂存区里所有的修改提交到本地仓库的当前分支：</p><ul><li>会显示： file changed(文件修改)、insertions(插入行)、deletions(删除行)</li><li>可以多次add，一次commit</li></ul><p>commit id解释说明： 看到的一串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。</p><p>为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><h4 id="5-git-reset-暂存区与本地仓库的撤销"><a href="#5-git-reset-暂存区与本地仓库的撤销" class="headerlink" title="5. git reset 暂存区与本地仓库的撤销"></a>5. git reset 暂存区与本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure><p>将当前分支的HEAD指向给定的版本，并根据模式的不同决定是否修改index和working tree。</p><ul><li><p>–soft模式</p><ul><li>指定commit id之后的所有commit的修改、目前index中暂存的修改都被保留在index中；</li><li>working tree中还没暂存的修改保持原样。</li></ul></li><li><p>–mixed(默认)</p><ul><li>清空index</li><li>指定commit id之后的所有commit的修改、目前index中暂存的修改、目前working tree中还没暂存的修改都被保留在工作区中</li><li>可以巧用<code>git reset</code>来<strong>撤销添加到暂存区中的修改</strong>(放入了工作区)，即<code>git reset HEAD &lt;file&gt;</code></li></ul></li><li><p>–hard：</p><ul><li>清空index、workingtree，指定commit id之后的所有提交修改也不会保留。</li></ul></li></ul><p>需要注意：</p><ul><li>reset是<strong>操作的本地仓库</strong>，所以只能reset那些未push到remote仓库的commit。</li><li>Git的版本回退速度非常快，因为Git会保存所有修改，而reset实质上是重置本地仓库的HEAD到指定的commit id，即当你回退版本的时候，Git仅仅是在改变HEAD指向。</li><li>想从3回滚到1，可以使用<code>git log</code>来查看提交日志，获取commit id；</li><li>如果commit已经push到远程仓库，那么origin/HEAD是不受影响的(<code>提交的修改仍保留在远程仓库</code>)，还是指向最新的commit id，此时sourceTree会提示有提交未拉取。<br>如果在这个本地仓库的版本上做修改，提交的时候会失败：<code>Updates were rejected because the tip of your current branch is behind its remote counterpart</code>，即告诉你需要先pull再push。</li></ul><h5 id="撤销之后想恢复"><a href="#撤销之后想恢复" class="headerlink" title="撤销之后想恢复"></a>撤销之后想恢复</h5><p>假如我们刚刚使用了reset –hard从commit3回滚到了1（并清空了工作区），想再恢复到3：</p><blockquote><p>前提是被丢弃的分支或commit信息还没有被git gc清除，一般情况下，gc对那些无用的object会保留很长时间后才清除的。</p></blockquote><p>第一步：通过git log -g命令来找到需要恢复的信息对应的commitid。可以通过提交的时间和日期来辨别，找到执行reset –hard之前的那个commit对应的commitid。（使用 git reflog 从命令日志中找到commit对应的commitid也是可以的）。</p><p>第二步：</p><ol><li>仍然可以使用git reset：<code>git reset &lt;commitid&gt;</code></li><li>使用<code>git branch &lt;branchname&gt; &lt;commitid&gt;</code>，会新建分支，并将到commitid为止的代码、各种提交记录等信息都恢复到了新分支上。</li></ol><h4 id="6-git-revert-本地仓库的撤销"><a href="#6-git-revert-本地仓库的撤销" class="headerlink" title="6. git revert 本地仓库的撤销"></a>6. git revert 本地仓库的撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>回滚指定的提交，并产生一条新的commit。</p><p>在指定commit id的时候，除了通过<code>git log</code>、<code>git reflog</code>来查看，还可以指定通过HEAD(大写)来指定，<code>HEAD</code>表示当前分支当前版本， 上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="7-git-status"><a href="#7-git-status" class="headerlink" title="7. git status"></a>7. git status</h4><p>查看仓库当前的状态：</p><ul><li>changes to be committed: 将要被提交的修改包括以下</li><li>no changes added to commit：没有被暂存修改要提交</li><li>changes not staged for commit：以下修改没有被暂存</li><li>no thing to commit, working tree clean：没有需要提交的修改，而且工作目录是干净的</li></ul><h4 id="8-git-log"><a href="#8-git-log" class="headerlink" title="8. git log"></a>8. git log</h4><p>显示从最近到最远的提交日志。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线。</p><ul><li>–graph：显示 ASCII 图形表示的分支合并历史</li><li>–decorate 标记会让git log显示每个commit的引用(如:分支、tag等) </li><li>–simplify-by-decoration 只显示被branch或tag引用的commit(如果去掉该参数，分支图与GUI显示的基本一致了)</li><li>–all 表示显示所有的branch，这里也可以选择，比如我只想显示分支ABC的关系，则将–all替换为branchA branchB branchC</li><li>–abbrev-commit：仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</li><li>–pretty：使用其他格式显示历史提交信息。可用的选项包括 oneline(简写一行)，short，full，fuller 和 format（后跟指定格式）</li><li>-<code>&lt;num&gt;</code>：显示几条</li><li><a href="https://www.progit.cn/#_viewing_history">等等</a></li></ul><p>常用的git log命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --decorate --oneline --simplify-by-decoration --all</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> [branch_name] <span class="comment"># 打印指定分支的提交。如git log dev/3.27.0 --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定作者指定时间的记录</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;xxx&#x27;</span> <span class="comment">#指定人</span></span><br><span class="line">git <span class="built_in">log</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> <span class="comment">#指定时间段</span></span><br><span class="line">git <span class="built_in">log</span> --name-only <span class="comment"># 只列出提交文件的名称</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&#x27;zhangsan&#x27;</span> --before=<span class="string">&#x27;2019-4-23&#x27;</span> --after=<span class="string">&#x27;2019-3-31&#x27;</span> --name-only </span><br></pre></td></tr></table></figure><p>感觉再怎么着也没GUI清晰…</p><p>举例：一个统计代码仓库提交、去重的小脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出commit、然后手动去重(避免某些人不规范使用git，提msg一样的commit)即可</span></span><br><span class="line">array=(<span class="string">&quot;name1&quot;</span> <span class="string">&quot;name2&quot;</span> <span class="string">&quot;name3&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$element</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="variable">$element</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span> --since=<span class="string">&quot;2020-03-01&quot;</span> --until=<span class="string">&quot;2020-08-31&quot;</span> --no-merges &gt;~/xxxx.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计行数的命令</span></span><br><span class="line"><span class="comment"># 统计某个人、时间范围内、增删代码行数</span></span><br><span class="line">git <span class="built_in">log</span> --author=XX --since=<span class="string">&quot;2021-03-01&quot;</span> --until=<span class="string">&quot;2021-12-31&quot;</span> --no-merges --pretty=tformat: --numstat | awk <span class="string">&#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added line s: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="9-git-reflog"><a href="#9-git-reflog" class="headerlink" title="9. git reflog"></a>9. git reflog</h4><p>显示命令历史，记录每一次命令</p><h4 id="10-git-push"><a href="#10-git-push" class="headerlink" title="10. git push"></a>10. git push</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [-u | --set-upstream] [&lt;远程仓库名&gt;] [&lt;本地分支名&gt;]  [&lt;:远程分支名&gt;] </span><br></pre></td></tr></table></figure><p>将当前分支的修改推送到远程分支，如果没有该远程分支则创建；</p><p>远程分支名可以写为<code>refs/heads/xx</code>或直接写为<code>xx</code>，好像没区别。</p><ul><li>如果只省略<code>&lt;:远程分支&gt;</code>：将指定的本地分支上的修改推送到同名的远程主机分支上；</li><li>如果只省略<code>&lt;本地分支名&gt;</code>：表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 <code>git push origin --delete master</code>。注意：不会影响本地分支；</li><li>如果当前分支是某个远程仓库中某个分支的跟踪分支，且两者同名，git push后省略远程仓库名、本地分支名、远程分支名等一切参数；</li><li>不带任何参数的git push，默认只推送当前分支，这叫做simple方式，还有一种matching方式，会推送所有有对应的远程分支的本地分支， Git 2.0之前默认使用matching，现在改为simple方式。如果想更改设置，可以使用git config命令。<code>git config --global push.default matching</code> OR <code>git config --global push.default simple</code>；可以使用<code>git config -l </code>查看配置</li><li>Tag对象与Commit对象十分相似，所以上面一些用法，在推送、删除tag对象时同样适用，比如git push origin :tagName 删除远程tag。</li></ul><h4 id="11-冲突处理"><a href="#11-冲突处理" class="headerlink" title="11. 冲突处理"></a>11. 冲突处理</h4><p><strong>执行git push之前，养成git pull的好习惯</strong>，如果有冲突，先处理冲突。</p><p>如果远程分支有别人的提交，而本地没有拉取，git push的时候，会失败</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27; hint: Updates were rejected because the remote contains work that you do not have locally.</span><br></pre></td></tr></table></figure><p>此时，应先拉取，再push，push之后发现，提交分支图上，出现了分叉，这是因为你的commit及远程他人的提交的父提交对象都是同一个commit对象，所以图谱上当然有分叉。且额外创建了一个新的commit：<code> Merge branch ‘&lt;branch&gt;’ of github.com...</code>，如果不想要这种情况可以使用<code>git rebase</code>。</p><h4 id="12-git-rebase"><a href="#12-git-rebase" class="headerlink" title="12. git rebase"></a>12. git rebase</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;branch&gt;  <span class="comment"># 操作当前分支变基</span></span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>将当前分支(分叉)上的一系列提交的基(父提交)改为指定分支的最新提交</li><li>视觉效果：消除了分支、push的时候远程有提交未拉取造成的分叉</li><li>注意：只能变基本地的分支，如果commit已经推到了远程，就不要再在本地操作了，会弄混乱：此时操作之后根据rebase的工作原理，相当于本地分支新增了数个commit，然后远程仓库中的几个老commit因为被本地分支上删除就会被认成是未拉取的commit。可以先删除远程分支，再变基，再推送。</li></ul><img src="/images/git/rebase.png" alt="rebase" style="zoom:80%;" /><p>本质是：</p><ol><li>把当前分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase“目录中)</li><li>然后把当前分支的根commit更新为指定分支的最新commit</li><li>最后把保存的这些补丁重新应用到当前分支上</li><li>更新之后，老的commit会丢弃，而&lt;当前分支&gt;引用指向新创建的最新commit</li></ol><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h4 id="13-git-pull"><a href="#13-git-pull" class="headerlink" title="13. git pull"></a>13. git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [远程仓库名] [远程分支名][:&lt;本地分支名&gt;] <span class="comment"># git pull origin develop:develop (:前后无空格)</span></span><br></pre></td></tr></table></figure><ul><li>[:&lt;本地分支名&gt;] 可以省略，表示拉取并与当前分支合并；</li><li>如果当前分支是跟踪分支，那么可以直接<code>git pull</code>；</li><li>实质上，这等同于先做<code>git fetch</code>（从远程获取最新版本(即对象和引用)到本地，不会自动合并），再执行<code>git merge</code>；</li></ul><p>避免与本地的改动冲突：</p><ul><li>如果本地仓库没有commit：先stash，再pull，再应用stash；</li><li>如果本地仓库中有commit：加<code>--rebase</code>参数：与git rebase功能类似，表示把你的本地当前分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到 <code>.git/rebase</code> 目录中)，然后把本地当前分支更新为最新的”origin”分支，最后把保存的这些补丁应用到本地当前分支上。 </li></ul><h3 id="7-2-分支-平行宇宙"><a href="#7-2-分支-平行宇宙" class="headerlink" title="7.2 分支(平行宇宙)"></a>7.2 分支(平行宇宙)</h3><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 </p><p>但Git的分支是与众不同的，无论创建、切换和删除分支都很快。</p><p>前面已经提到，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支，默认有一条分支叫主分支，即master分支。</p><h4 id="1-git-branch-创建-删除-查看分支"><a href="#1-git-branch-创建-删除-查看分支" class="headerlink" title="1. git branch 创建/删除/查看分支"></a>1. git branch 创建/删除/查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch &lt;branchname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支。如果一个分支还没被合并，会删除失败， 提示：如果删除，将丢失掉修改，可以使用大写的-D参数强行删除</span></span><br><span class="line">git branch -d &lt;branch&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push &lt;remote&gt; &lt;:remote-branch&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支重命名(如果已经推送远程，那么需要删除远程，重新推送)</span></span><br><span class="line">git branch -m oldName newName</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有分支，当前分支前面会标一个*号</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><h4 id="2-git-checkout-切换"><a href="#2-git-checkout-切换" class="headerlink" title="2. git checkout 切换"></a>2. git checkout 切换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt;    <span class="comment"># 切换到分支</span></span><br><span class="line">git checkout -b &lt;branch&gt; <span class="comment"># 创建并切换分支</span></span><br></pre></td></tr></table></figure><p>前面讲过，撤销修改是 <code>git checkout -- &lt;file&gt;</code>，为了避免混淆，最新版本的Git提供了新的git switch命令来切换分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch &lt;branch&gt;    <span class="comment"># 切换</span></span><br><span class="line">git switch -c &lt;branch&gt; <span class="comment"># 创建并切换</span></span><br></pre></td></tr></table></figure><h4 id="3-跟踪分支"><a href="#3-跟踪分支" class="headerlink" title="3. 跟踪分支"></a>3. 跟踪分支</h4><p>跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入git pull、git push，Git 能自动地识别去<code>哪个服务器(仓库名指定的)</code>上的<code>哪个分支</code>pull、push。</p><h5 id="1-跟踪分支的设置"><a href="#1-跟踪分支的设置" class="headerlink" title="1) 跟踪分支的设置"></a>1) 跟踪分支的设置</h5><ul><li><p>从一个远程跟踪分支检出本地分支时，选择<strong>本地分支是否跟踪远程分支</strong>；</p></li><li><p>当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支；</p></li><li><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用-u或–set-upstream-to选项运行git branch来显式地设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/mybranch1 mybranch1</span><br></pre></td></tr></table></figure><ul><li>后者可省略，表示当前本地分支</li><li>一定要加origin，否则表示本地分支，而且还能跟踪成功，表示当前本地分支跟踪了另一个本地分支</li></ul></li><li><p>git push的时候设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u/--set-upstream origin localBranch:remoteBranch  <span class="comment"># 后者可省略，表示远程同名分支</span></span><br></pre></td></tr></table></figure><p>表示把localBranch分支上的修改提交到remoteBranch上，并建立跟踪关联。相比之下这种方式比上面那种使用的更普遍，因为<strong>上面那个首先需要有那个远程分支才可以用</strong>。</p></li><li><p>如果想要查看设置的所有跟踪分支，可以使用<code>git branch -vv</code>： 会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。</p></li></ul><h5 id="2-如果未设置跟踪分支"><a href="#2-如果未设置跟踪分支" class="headerlink" title="2) 如果未设置跟踪分支"></a>2) 如果未设置跟踪分支</h5><p>无论是否存在同名的远程分支，git push、git pull时都要加上<code>&lt;远程主机名&gt; &lt;本地分支名&gt;</code></p><p>不然前者报错： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch &lt;localBranch&gt; has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use `git push --set-upstream origin &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><p>后者报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. </span><br><span class="line">`git pull &lt;remote&gt; &lt;branch&gt;`</span><br><span class="line">If you wish to set tracking information for this branch you can do so with: `git branch --set-upstream-to=origin/&lt;remoteBranch&gt; &lt;localBranch&gt;`</span><br></pre></td></tr></table></figure><h5 id="3-如果设置了跟踪分支"><a href="#3-如果设置了跟踪分支" class="headerlink" title="3) 如果设置了跟踪分支"></a>3) 如果设置了跟踪分支</h5><p>设置成功后，会提示：Branch ‘testBranch’ set up to track remote branch ‘testBranch’ from ‘origin’.</p><p>本地分支与跟踪的远程分支是否同名：</p><ul><li><p>是：可以直接使用git push、git pull，省略之后的参数</p></li><li><p>否：依然可以使用git pull。不能直接使用git push，省略之后报错：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match the name of your current branch.  </span><br><span class="line">To push to the upstream branch on the remote, use `git push origin HEAD:remoteBranch`</span><br><span class="line">To push to the branch of the same name on the remote, use `git push origin HEAD`</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-git-merge-合并"><a href="#4-git-merge-合并" class="headerlink" title="4. git merge 合并"></a>4. git merge 合并</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;  <span class="comment"># 合并指定分支到当前分支</span></span><br></pre></td></tr></table></figure><p>如果合并发生冲突(两个分支都对一个文件进行修改)，需要解决冲突后，再手动commit。</p><ul><li>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</li></ul><h5 id="–no-ff"><a href="#–no-ff" class="headerlink" title="–no-ff"></a>–no-ff</h5><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式：</p><ul><li>当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”</li><li>举例：比如从master上创建分支A，在A上有了数个commit，master上没有提交，此时将A合并到master，实质是将master直接指向A的最新commit（将master引用指向的SHA-1值改为A最新的commit对象的SHA-1值）。</li><li>普通模式的合并有分叉，可以看出曾经做过合并，而fast forward合并看不出来曾经做过合并。</li></ul><p><strong>如果不是fast-forward模式，Git就会在merge时生成一个新的commit。</strong></p><p>可以强制禁用Fast forward模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &lt;“merge”&gt; &lt;branch&gt;   <span class="comment"># 要加commit message，因为会生成一个新commit对象</span></span><br></pre></td></tr></table></figure><img src="/images/git/git-merge-no-ff.png" alt="git-merge-no-ff" style="zoom:67%;" /><p>建议都加上 <code>--no-ff</code>：</p><ul><li>如果有些分支合并后删除，那么<code>--no-ff</code>可以很清楚的看到这些分支的历史存在的信息。反之，fast-forward模式就会导致不知道这些分支曾经存在过。</li><li>可以将所有一起实现了一项功能的 commit 组合在一起。否则，您必须手动读取所有日志消息，来判定一项功能实现所需要的commit。此时，撤销整个功能（即一组提交）是一个真正令人头疼的问题。</li><li>是的，它会创建更多（空）commit 对象，但收益远大于成本。</li></ul><h4 id="5-git-log-查看"><a href="#5-git-log-查看" class="headerlink" title="5. git log 查看"></a>5. git log 查看</h4><p>显示分支合并图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="6-git-cherry-pick"><a href="#6-git-cherry-pick" class="headerlink" title="6. git cherry-pick"></a>6. git cherry-pick</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得在另一个分支中单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。</span></span><br><span class="line">git cherry-pick &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移多个提交</span></span><br><span class="line">git cherry-pick &lt;HashA&gt; &lt;HashB&gt; <span class="comment"># 将 A 和 B 两个提交应用到当前分支</span></span><br><span class="line">git cherry-pick A..B  <span class="comment"># 转移从 A 到 B 的所有提交</span></span><br><span class="line">                      <span class="comment"># 提交 A 必须早于提交 B，否则命令将失败，但不会报错。</span></span><br><span class="line">                      <span class="comment"># 提交 A 将不会包含在 Cherry pick 中，即(A, B]</span></span><br><span class="line">git cherry-pick A^..B <span class="comment"># 包含A，即[A, B]</span></span><br></pre></td></tr></table></figure><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><ul><li>–continue<br>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。<br><code>git cherry-pick --continue</code></li><li>–abort<br>发生代码冲突后，放弃合并，回到操作前的样子。</li><li>–quit<br>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</li></ul><h3 id="7-3-stash"><a href="#7-3-stash" class="headerlink" title="7.3 stash"></a>7.3 stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment"># 将更改储藏在脏工作目录中，clean目前工作区</span></span><br><span class="line"></span><br><span class="line">git stash list <span class="comment"># 查看所有stash</span></span><br><span class="line"><span class="comment"># stash@&#123;0&#125;: WIP on master: 049d078 added the index file </span></span><br><span class="line"><span class="comment"># stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span></span><br><span class="line"></span><br><span class="line">git stash apply [&lt;stash&gt;]  <span class="comment"># 恢复，但是恢复后，stash内容并不删除</span></span><br><span class="line"><span class="comment"># 可以通过名字指定它，像这样：git stash apply stash@&#123;2&#125;。</span></span><br><span class="line"><span class="comment"># 如果不指明，Git 默认使用最近的储藏并尝试应用它</span></span><br><span class="line"></span><br><span class="line">git stash drop [&lt;stash&gt;]   <span class="comment"># 删除</span></span><br><span class="line"></span><br><span class="line">git stash pop [&lt;stash&gt;]    <span class="comment"># 恢复的同时把stash内容也删掉</span></span><br></pre></td></tr></table></figure><h3 id="7-4-tag"><a href="#7-4-tag" class="headerlink" title="7.4 tag"></a>7.4 tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; [commit]    <span class="comment"># 打一个轻量标签，如果省略&lt;commit&gt;，则表示最新提交</span></span><br><span class="line"></span><br><span class="line">git tag -a &lt;name&gt; -m &lt;<span class="string">&quot;message&quot;</span>&gt; [commit]  <span class="comment"># 打附注标签(带有说明)，用-a指定标签名，-m指定说明文字</span></span><br><span class="line"></span><br><span class="line">git tag <span class="comment"># 查看所有标签， 标签不是按时间顺序列出，而是按字母排序</span></span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; <span class="comment"># 查看标签信息</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 推送标签到远程</span></span><br><span class="line">git push origin --tags    <span class="comment"># 一次性推送全部尚未推送到远程的本地标签</span></span><br><span class="line"></span><br><span class="line">git tag -d &lt;name&gt;  <span class="comment"># 删除标签</span></span><br><span class="line">git push &lt;remote&gt; &lt;:tagname | refs/tags/&lt;tagname&gt;&gt; <span class="comment"># 删除远程标签</span></span><br></pre></td></tr></table></figure><p>如果tag与分支同名，在/refs/heads/、/refs/tags/下都能找到文件名为这个名字的文件，此时操作时如果直接写标签名，可能会报错：<code>...match more than one</code>。</p><h3 id="7-5-补丁的创建与应用"><a href="#7-5-补丁的创建与应用" class="headerlink" title="7.5 补丁的创建与应用"></a>7.5 补丁的创建与应用</h3><p>Git 提供了两种补丁方案</p><ul><li>用 <code>git diff</code> 生成的UNIX标准补丁.diff文件： .diff文件只是记录文件改变的内容，不带有commit记录信息，多个commit可以合并成一个diff文件。 </li><li>用 <code>git format-patch</code> 生成的Git专用.patch 文件:  .patch文件带有记录文件改变的内容，也带有commit记录信息。每个commit对应一个patch文件。</li></ul><p><strong>在Git下，我们可以使用.diff文件也可以使用.patch 文件来打补丁，主要应用场景有：CodeReview、代码迁移等。</strong></p><h4 id="7-5-1-创建补丁git-diff"><a href="#7-5-1-创建补丁git-diff" class="headerlink" title="7.5.1 创建补丁git diff"></a>7.5.1 创建补丁git diff</h4><p>顾名思义就是查看<code>已跟踪tracked文件</code>的difference：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff [--cached] [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [查看文件名] [&gt; diff补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>不加参数即默认比较工作区与暂存区；</li><li>如果加了一个commit id，表示比较目前代码与指定commit的差异 = 当前工作区+暂存区+指定commit后的commit修改；</li><li>如果加了两个commit id，表示比较后者与前者两次提交之间的差异；</li><li>如果加了–cached（后面即使没有commit id，默认相当于有个HEAD），意义是在上条的基础上忽略工作区的改动，即差异 = 当前暂存区 + 指定commit后的commit修改；</li><li>在上面的基础上，后面如果加了 <code>&gt; 文件名</code>，表示将上面比较出的差异，导出一个补丁，可以拷贝到另一机器或者另一个马甲项目中应用。</li></ul><h4 id="7-5-2-创建补丁git-patch"><a href="#7-5-2-创建补丁git-patch" class="headerlink" title="7.5.2 创建补丁git patch"></a>7.5.2 创建补丁git patch</h4><p>会将指定commit id 后的每一个commit分别单独生成patch文件。</p><p>patch文件按照commit的先后顺序从1开始编号。</p><p>patch文件会生成到当前目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch [&lt;commit&gt; [(^.. | ..)&lt;commit&gt;]] [-n] [&gt; patch补丁文件名]</span><br></pre></td></tr></table></figure><ul><li>commitId 如果省略，表示HEAD指针指向的commit</li><li>-n 表示为HEAD后的n个 commit 生成 patch</li></ul><h4 id="7-5-3-补丁应用git-apply"><a href="#7-5-3-补丁应用git-apply" class="headerlink" title="7.5.3 补丁应用git apply"></a>7.5.3 补丁应用git apply</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查patch/diff是否能正常打入。如果没有任何输出，那么表示可以顺利接受这个补丁</span></span><br><span class="line">git apply --check patch/diff文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用补丁</span></span><br><span class="line">git apply patch/diff文件名</span><br><span class="line"><span class="comment"># apply patch 成功后会自动commit，并且保留原来commit的comments，submittor等信息。但是commit id会新生成</span></span><br><span class="line"><span class="comment"># apply diff 成功后，会将修改放入工作区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将能打的补丁先打上，有冲突的会生成.rej文件，此时可以找到这些文件进行手动打补丁</span></span><br><span class="line">git apply --reject patch/diff文件名</span><br></pre></td></tr></table></figure><p>此外，patch补丁文件，还可以使用git am命令来应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am &lt;path/to/xxx.patch&gt; </span><br></pre></td></tr></table></figure><p>补丁冲突解决：</p><p>在打补丁过程中有时候会出现冲突的情况，有冲突时会打入失败。此时需要解决冲突： </p><ol><li>首先使用 以下命令行，自动合入 patch 中不冲突的代码改动，同时保留冲突的部分： git apply –reject xxxx.patch . 此时会在终端中显示出冲突的大致代码， 同时会生成后缀为 .rej 的文件，保存没有合并进去的部分的内容，可以参考这个进行冲突解决。</li><li>解决完冲突后删除后缀为 .rej 的文件，并执行 <code>git add .</code> 添加改动到暂存区. </li><li>接着执行 <code>git am --resolved</code> 或者 <code>git am --continue</code></li></ol><p>说明：在打入patch冲突时，可以执行git am –skip跳过此次冲突，也可以执行git am –abort回退打入patch的动作，还原到操作前的状态。</p><h4 id="7-5-4-手动修改补丁文件"><a href="#7-5-4-手动修改补丁文件" class="headerlink" title="7.5.4 手动修改补丁文件"></a>7.5.4 手动修改补丁文件</h4><img src="/images/git/patch.png" alt="patch" style="zoom:90%;" /><p>有时候patch apply遇到问题，可以根据当前上下文，手动修改patch再进行apply。</p><p>上图就是修改前的patch。patch格式说明，其格式为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@@ -[起始行号],[修改前的行数] +[起始行号],[修改后的行数]</span><br></pre></td></tr></table></figure><p>在新增或删除一行时，记得修改 [修改后的行数]</p><h2 id="八、分支管理策略"><a href="#八、分支管理策略" class="headerlink" title="八、分支管理策略"></a>八、分支管理策略</h2><blockquote><p>只有适合自己团队的，才是最好的。下面介绍的是一些经典的策略，但并不一定适合你。</p></blockquote><h3 id="8-1-develop—release—master"><a href="#8-1-develop—release—master" class="headerlink" title="8.1 develop—release—master"></a>8.1 develop—release—master</h3><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">参考链接 — A successful Git branching model</a></p><img src="/images/git/git-model.png" alt="Snip20200423_10" style="zoom:70%;" /><p>如果项目是持续交付软件(比如前端/后端)，那建议采用更简单的工作流程(比如 <a href="https://guides.github.com/introduction/flow/">GitHub flow</a>)；如果您正在构建明确版本化的软件，或者需要支持软件的多个版本同时运营，那本文的分支模型还是很有帮助的。</p><p>中央仓库拥有两个具有无限生命周期的主要分支：master与develop。这个两个分支的生命周期是整个项目周期。</p><ul><li><strong>master</strong>与<strong>develop</strong>分支：<ul><li>master分支是创建git仓库时自动生成的，随即我们就会从master分支创建平行分支 — develop分支。</li><li>master分支的 <code>HEAD</code> 始终指向/反映当前生产环境的代码状态。</li><li>develop分支的 <code>HEAD</code> 始终指向/反映下一个交付版本的开发的最新状态。有人将其称为<strong>“集成分支”</strong>（<strong>integration branch</strong>）。</li><li>当develop分支中的源代码达到稳定点并准备发布时，所有更改都应该以某种方式(<em>中间经过Release branches处理，后面细讲</em>)合并回master，然后打个Tag（使用发布版本号命名）。</li><li><strong>严格遵守</strong>：每次将更改合并回master分支时，这必然表示是一个新的生产版本。即<strong>master 上的每个提交都是定义的新版本</strong>。因此理论上，每次在 master 上进行提交，我们可以使用 Git hook 脚本来自动构建我们的软件并将其推出到我们的生产服务器上。</li></ul></li></ul><p>之外，还有各种支持分支来实现团队成员之间的并行开发、生产版本的准备、快速修复生产问题。</p><p>与master和develop分支不同，这些分支的生命周期总是有限的，因为它们最终会被合并到 develop 或 master 分支，然后删除。（<strong>建议：merge分支时，都加上 <code>--no-ff</code> 参数</strong>）</p><p>这些分支中的每一个都有特定的目的，并且必须遵守严格的规则，即它们是从什么分支中创建，需要合并到什么分支。</p><ul><li><strong>Feature branches</strong>：功能分支，有时也称主题分支(topic branches)。<ul><li><strong>从develop分支创建，完成后合并回develop分支。</strong></li><li>用于为即将发布的、或遥远的未来版本开发新功能。</li><li>当我们开始开发一个特性时，这个特性将被合并到的目标发布版本很可能是未知的。只要特性处于开发阶段，feature 分支就会一直存在，直到最终被合并回develop分支（新特性确定要添加到即将发布的版本中）或丢弃（实验效果不佳）。</li><li>feature 分支通常仅存在于开发人员的仓库中，而不存在于 origin 中。(<em>取决于需不需要协作吧</em>)。使用完就可以删除了。</li></ul></li><li><strong>Release branches</strong>：发布分支。命名规范<code>release-*</code> （*最好是版本号）<ul><li><strong>从develop分支创建，完成后合并回develop和master分支。</strong></li><li>当 develop（几乎）达到了新版本的期望状态，至少所有新版本中需要的 feature 都合并到 develop 中时，我们从develop分支出一个release分支。在此分支上做一些发布版本的准备工作，准备一些发布的元数据，如版本号、构建日期等。此时，develop分支就可以接收/集成下一个大版本的功能。<ul><li>release分支创建之时，我们才能根据版本号更新规则确定新版本的版本号，此前，develop 分支只是反映了“下一个版本”的变化，但不清楚“下一个版本”最终会变成 0.3 还是 1.0 等。</li></ul></li><li>这个新分支可能会存在一段时间，直到发布可能确定推出。在此期间，可以在此分支（而不是develop）中修复一些小错误。严禁在此分支上添加新feature，它们必须合并到develop分支中，等待下一个发布版本。</li><li>当release分支真正准备好要发布时，我们需要：<ul><li>release 分支被<strong>合并到 master</strong> 中。对 master 上的此次提交<strong>打个Tag</strong>，以便将来参考此历史版本。</li><li>在release分支上所做的更改需要<strong>合并回 develop</strong>，以便将来的版本也包含这些错误修复。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">$ git tag -a 1.2</span><br><span class="line"></span><br><span class="line">$ git checkout develop</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line"><span class="comment"># 这一步很可能会导致合并冲突（因为我们已经更改了版本号）。如果是这样，修复它并提交。</span></span><br></pre></td></tr></table></figure></li></ul></li><li>此时，发布完成，release分支可以被删除，不再需要它。</li></ul></li><li><strong>Hotfix branches</strong>：热修复分支，命名规范 <code>hotfix-*</code> (*可以是版本号，也可以约定为其他)。主要为修复线上特别紧急的bug准备的。<ul><li><strong>从master分支创建，完成后合并回develop与master分支。</strong></li><li>hotfix 分支与 release 分支非常相似，因为它们也是在为新的生产版本做准备，尽管是计划外的…。当必须立即解决生产版本中的严重错误，等不到正常的版本迭代(develop/release分支代码还不够稳定)时，可以在 master 分支上，找到生产版本对应的Tag，从此处分支出一个 hotfix 分支。</li><li>后续跟release分支基本一致：确定版本号、通过一个或多个的commit修复错误、准备发布的元数据、测试完成合并回master、打tag标记发布版本、合并到develop。</li><li>此处规则有一个例外是，<strong>如果当前存在 release 分支，hotfix 分支需要合并到该 release 而不是 develop 分支中</strong>。一是因为 release 分支需要同步此修改，二是 release 完成时，会合并到develop 分支中，也会导致最终这个bugfix会合并develop分支中。（如果develop中的工作立即就需要这个bugfix，等不到release分支完成，那也可以将bugfix合并到develop中）</li><li>发布完成，hotfix 分支也可以删除了。</li></ul></li><li>关于bugfix，可以在release分支上直接进行，也可以每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</li></ul><p>下图剔除了一些说明，看起来简单些：</p><img src="/images/git/git-model-simple.png" alt="Snip20200423_10" style="zoom:80%;" /><h3 id="8-2-develop—release合并"><a href="#8-2-develop—release合并" class="headerlink" title="8.2 develop—release合并"></a>8.2 develop—release合并</h3><p>总结下来：develop、release分支是分别负责版本发布流程中的feature分支集成/合并 和 测试、发布两部分。</p><p>这两个分支有两种合并方案：</p><ul><li>省去release分支：在develop分支上合并feature分支、集成测试、发布准备。发布后合并master。</li></ul><img src="/images/git/Snip20200423_10.png" alt="Snip20200423_10" style="zoom:90%;" /><ul><li>省去develop分支：版本的集成、测试、发布，都在对应的 <code>release-*</code> / <code>release/xx</code> 分支上进行。如下图是据说是美团的命名示意图：</li></ul><img src="/images/git/Snip20200423_11.png" alt="Snip20200423_11" style="zoom:90%;" /><h3 id="8-3-develop—release—feature合并"><a href="#8-3-develop—release—feature合并" class="headerlink" title="8.3 develop—release—feature合并"></a>8.3 develop—release—feature合并</h3><p>如果团队规模较小，每次开发功能时，基本就能确定要上线的版本号，并且功能比较耦合，几个团队成员没必要单独开辟各自的 <code>feature/xxx</code> 分支。</p><p>此时，就可以省略 <code>feature</code> 这类分支。</p><p>每次开发时，直接开辟 <code>release/*</code> / <code>develop/*</code> / <code>daily/*</code> 分支（*建议为版本号）。在此分支上完成开发、(中间就没有集成这一步了)、测试、发布。</p><h2 id="九、报错集锦"><a href="#九、报错集锦" class="headerlink" title="九、报错集锦"></a>九、报错集锦</h2><h3 id="9-1-超过100M报错"><a href="#9-1-超过100M报错" class="headerlink" title="9.1 超过100M报错"></a>9.1 超过100M报错</h3><p>超过50M警告：remote: warning: File ppt/Implementing AutoML Techniques at Salesforce Scale.pdf is 66.68 MB; this is larger than GitHub’s recommended maximum file size of 50.00 MB</p><p>超过100M报错：remote: error: GH001: Large files detected. You may want to try Git Large File Storage - <a href="https://git-lfs.github.com/">https://git-lfs.github.com</a>. 报错信息，里面提供了解决办法，就是使用 <a href="https://www.iteblog.com/redirect.php?url=aHR0cHM6Ly9naXQtbGZzLmdpdGh1Yi5jb20v&article=true">Git Large File Storage (LFS)</a>。</p><p><strong>Find 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有超过100M的文件</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -size +102400k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索名字为xxx的文件/文件夹</span></span><br><span class="line">find ./ -iname <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜出并删除，删除过程中可能会出现override r-r--r-- xxxx(系统当前用户名)/staff for 文件名? 没有权限的意思，加sudo即可</span></span><br><span class="line">find ./ -name <span class="string">&quot;.git&quot;</span> -<span class="built_in">exec</span> rm -r <span class="string">&quot;&#123;&#125;&quot;</span> \;</span><br></pre></td></tr></table></figure><h2 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a>十、参考链接</h2><ul><li><a href="https://www.progit.cn/#_pro_git">《Pro Git》</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 — 廖雪峰</a></li></ul><p>GUI工具：</p><ul><li>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 </li><li>Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;一、Git&quot;&gt;&lt;/a&gt;一、Git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;集中式版本控制系统，版本库是集中存放在中央服务器的(服务器必须联网才能连接)。所有人都是通过中央服务器来</summary>
      
    
    
    
    <category term="Git" scheme="https://tenloy.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>(七) dyld与Objc—_objc_init、map_images、load_images</title>
    <link href="https://tenloy.github.io/2021/10/21/dyld-objc.html"/>
    <id>https://tenloy.github.io/2021/10/21/dyld-objc.html</id>
    <published>2021-10-21T10:20:00.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前文回顾"><a href="#一、前文回顾" class="headerlink" title="一、前文回顾"></a>一、前文回顾</h2><p>上一篇<a href="https://tenloy.github.io/2021/09/27/compile-dynamic-link.html">(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>，大概梳理了dyld的加载流程，这一次主要展开<strong>“第八步 执行初始化方法”</strong>，其是我们日常紧密接触的OBJC Runtime初始化启动的上文。</p><p>先简单回顾一下Runtime的初始化之前的流程：</p><ol><li>内核XNU加载Mach-O</li><li>从XNU内核态将控制权转移到dyld用户态</li><li>dyld：<ol><li>设置运行环境</li><li>实例化ImageLoader加载所需的动态库、并进行链接(符号绑定、重定位)。每个image对应一个ImageLoader实例</li><li>进行images的初始化：先初始化动态库，再初始化可执行文件。这步过程中，<strong>Runtime会向dyld中注册回调函数。dyld会在每个image加载、初始化、移除时分别调用Runtime的回调函数：map_images、load_images、unmap_images</strong>. </li><li>最后找到主程序的入口main()函数并返回。</li></ol></li></ol><p>可以在程序中，通过符号断点的形式<code>Debug → breakpoints → create symbolic breakpoint</code>来看这几个函数的调用堆栈：</p><p>添加符号断点：</p><img src="/images/compilelink/35.png" alt="35" style="zoom:90%;" /><p>load_images的调用堆栈(之一)：</p><img src="/images/compilelink/31.png" alt="35" style="zoom:90%;" /><p>在进入 <code>libobjc</code> 之前，我们必须要先了解 OC 中类的底层结构，可以先阅读<a href="https://tenloy.github.io/2021/10/11/runtime-data-structure.html">下篇</a>(如果已经熟悉，那略过)。</p><h2 id="二、-objc-init"><a href="#二、-objc-init" class="headerlink" title="二、_objc_init()"></a>二、_objc_init()</h2><p>通过方法的文档注释，可以大概了解它的作用：启动初始化，注册dyld中image相关的回调通知，由libSystem在库(image)的初始化之前调用。</p><h3 id="2-1-objc-init-源码实现"><a href="#2-1-objc-init-源码实现" class="headerlink" title="2.1 _objc_init()源码实现"></a>2.1 _objc_init()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init()"></a>2.2 tls_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程局部/本地存储(Thread Local Storage, TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</span></span><br><span class="line"><span class="comment">// 线程私有数据(Thread Specific Data, TSD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc&#x27;s key for pthread_getspecific</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _objc_pthread_key TLS_DIRECT_KEY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">tls_key_t</span> _objc_pthread_key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> tls init：线程本地存储的初始化。</span></span><br><span class="line"><span class="comment"> _objc_pthread_destroyspecific 是线程的销毁函数。以 TLS_DIRECT_KEY 为 Key，在线程的本地存储空间中保存线程对应对销毁函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="built_in">pthread_key_init_np</span>(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = <span class="built_in">tls_create</span>(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pthread_key_init_np</code> 是属于 <code>libpthread</code> 库中的方法了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 为静态键设置析构函数，因为它不是用pthread_key_create()创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_init_np</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配用于表示进程中线程特定数据的键，键对进程中的所有线程来说是全局的。</span></span><br><span class="line"><span class="comment"> * 创建线程特定数据时，所有线程最初都具有与该键关联的NULL值。</span></span><br><span class="line"><span class="comment"> * @param key 指向从进程中已分配的键</span></span><br><span class="line"><span class="comment"> * @param destructor 指向析构函数，destuctor的形参是线程与键关联的数据。在线程终止时调用该函数，以达到释放内存的目的</span></span><br><span class="line"><span class="comment"> * @return 成功返回0.其他任何返回值都表示出现了错误。如果出现下列任一情况，pthread_key_create()将失败并返回相应的值</span></span><br><span class="line"><span class="comment">       EAGAIN：key名称空间已用完</span></span><br><span class="line"><span class="comment">       ENOMEM：此进程中虚拟内存不足，无法创建新键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-runtime-init"><a href="#2-3-runtime-init" class="headerlink" title="2.3 runtime_init()"></a>2.3 runtime_init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> objc &#123;</span><br><span class="line">  <span class="comment">// 主要用来为类统计分类、追加分类到类、清除分类数据、清除类数据。</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UnattachedCategories</span> :</span> <span class="keyword">public</span> ExplicitInitDenseMap&lt;Class, category_list&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> UnattachedCategories unattachedCategories; </span><br><span class="line">  <span class="comment">// allocatedClasses 是已使用 objc_allocateClassPair allocated 过的所有类（和元类）的表</span></span><br><span class="line">  <span class="keyword">static</span> ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtime_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">init</span>(<span class="number">32</span>); <span class="comment">// 初始化分类的存储容器, 是Map</span></span><br><span class="line">    objc::allocatedClasses.<span class="built_in">init</span>(); <span class="comment">// 初始化类的存储容器，是Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-cache-t-init"><a href="#2-4-cache-t-init" class="headerlink" title="2.4 cache_t::init()"></a>2.4 cache_t::init()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/restartable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述用户空间的可恢复范围</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_vm_address_t</span> location;     <span class="comment">// 指向可重启动section开头的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    length;       <span class="comment">// 锚定在location的section的长度</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>    recovery_offs;<span class="comment">// 应该用于恢复的初始位置的偏移量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>      flags;</span><br><span class="line">&#125; <span class="keyword">task_restartable_range_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TASK_RESTARTABLE_RANGES</span></span><br><span class="line">  <span class="comment">// mach_msg_type_number_t 当前是 unsigned int 的别名，定义别名利于不同的平台做兼容</span></span><br><span class="line">  <span class="keyword">mach_msg_type_number_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// kern_return_t 当前是 int 的别名</span></span><br><span class="line">  <span class="keyword">kern_return_t</span> kr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计objc_restartableRanges数组中location成员值不为空的task_restartable_range_t的数量</span></span><br><span class="line">  <span class="keyword">while</span> (objc_restartableRanges[count].location) &#123;</span><br><span class="line">      count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为当前任务注册一组可重启范围。Register a set of restartable ranges for the current task.</span></span><br><span class="line">  kr = <span class="built_in">task_restartable_ranges_register</span>(<span class="built_in">mach_task_self</span>(),</span><br><span class="line">                                        objc_restartableRanges, count);</span><br><span class="line">  <span class="keyword">if</span> (kr == KERN_SUCCESS) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册失败则停止运行</span></span><br><span class="line">  _objc_fatal(<span class="string">&quot;task_restartable_ranges_register failed (result 0x%x: %s)&quot;</span>,</span><br><span class="line">              kr, <span class="built_in">mach_error_string</span>(kr));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HAVE_TASK_RESTARTABLE_RANGES</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局搜索 <code>objc_restartableRanges</code> 可看到，在 <code>_collecting_in_critical</code> 函数中有看到有对其的遍历读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/* 第一次申请或扩容；扩容时，会清空现有数据. 扩容系数不同平台有3/4、7/8 */</span></span></span><br><span class="line">  ▼ void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity, bool freeOld);</span><br><span class="line">  <span class="comment">// 或 void cache_t::eraseNolock(const char *func); // 将整个缓存重置为未缓存查找</span></span><br><span class="line">    <span class="comment">/* 将指定的malloc的内存添加到稍后要释放的内存列表中。</span></span><br><span class="line"><span class="comment">       size用于收集的阈值。它不必精确地与块的大小相同。*/</span></span><br><span class="line">    ▼ <span class="function"><span class="keyword">void</span> <span class="title">cache_t::collect_free</span><span class="params">(<span class="keyword">bucket_t</span> *data, <span class="keyword">mask_t</span> capacity)</span></span></span><br><span class="line"><span class="function">        <span class="comment">/* 尝试释放累积的失效缓存. collectALot更努力地释放内存 */</span></span></span><br><span class="line">      ▼ void cache_t::collectNolock(bool collectALot); </span><br><span class="line">          <span class="comment">/* 用于判断当前是否可以对旧的方法缓存（扩容后的旧的方法缓存表）进行收集释放</span></span><br><span class="line"><span class="comment">             返回 true 表示objc_msgSend（或其他缓存读取器(cache reader)）当前正在缓存中查找，并</span></span><br><span class="line"><span class="comment">             且可能仍在使用某些garbage。返回 false 的话表示 garbage 中的 bucket_t 没有被在使用。</span></span><br><span class="line"><span class="comment">             即当前有其它线程正在读取使用我们的旧的方法缓存表时，此时不能对旧的方法缓存表进行内存释放*/</span></span><br><span class="line">        ▼ <span class="keyword">static</span> <span class="keyword">int</span> _collecting_in_critical(<span class="keyword">void</span>);  <span class="comment">//(critical 危急的；临界的；关键的)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-dyld-objc-notify-register"><a href="#2-5-dyld-objc-notify-register" class="headerlink" title="2.5 _dyld_objc_notify_register()"></a>2.5 _dyld_objc_notify_register()</h3><p><code>_dyld_objc_notify_register</code> 函数仅供 objc runtime 使用，注册当 mapped、unmapped 和 initialized objc images 时要调用的处理程序。Dyld 将使用包含 <code>objc-image-info</code> section 的 images 数组回调 <code>mapped</code> 函数。</p><blockquote><p>在iOS 13系统中，iOS将全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p></blockquote><p>在 dyld3 中，<code>_dyld_objc_notify_register</code> 函数的实现逻辑有一些改变，此处不再赘述了。</p><ul><li>map_images : dyld 将 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : dyld 初始化 image 会触发该方法，进行+load的调用</li><li>unmap_image : dyld 将 image 移除时 , 会触发该函数</li></ul><h2 id="三、map-images"><a href="#三、map-images" class="headerlink" title="三、map_images()"></a>三、map_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped(映射、加载) in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images</span><span class="params">(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_images_nolock</span>(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-map-images-nolock"><a href="#3-1-map-images-nolock" class="headerlink" title="3.1 map_images_nolock()"></a>3.1 map_images_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理由dyld映射的给定图像。</span></span><br><span class="line"><span class="comment"> * 执行所有的类注册和修复(或延迟查找丢失的超类等)，并调用+load方法。</span></span><br><span class="line"><span class="comment"> * Info[]是自底向上的顺序，即libobjc将在数组中比任何链接到libobjc的库更早。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_images_nolock</span><span class="params">(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态变量，表示第一次调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hList 是统计 mhdrs 中的每个 mach_header 对应的 header_info</span></span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如有必要，执行首次初始化。</span></span><br><span class="line">    <span class="comment">// 此函数在 ordinary library 初始化程序之前调用。</span></span><br><span class="line">    <span class="comment">// 延迟初始化，直到找到使用 objc 的图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是第一次加载，则准备初始化环境</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="built_in">preopt_init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启 OBJC_PRINT_IMAGES 环境变量时，启动时则打印 images 数量。</span></span><br><span class="line">    <span class="comment">// 如：objc[10503]: IMAGES: processing 296 newly-mapped images... </span></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing %u newly-mapped images...\n&quot;</span>, mhCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 class 的数量。根据总数调整各种表格的大小。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// typedef struct mach_header_64 headerType;</span></span><br><span class="line">            <span class="comment">// 取得指定 image 的 header 指针</span></span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 以 mdr 构建其 header_info，并添加到全局的 header 列表中（是一个链表，大概看源码到现在还是第一次看到链表的使用）。</span></span><br><span class="line">            <span class="comment">// 且通过 GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;); 读取 __objc_classlist 区中的 class 数量添加到 totalClasses 中，</span></span><br><span class="line">            <span class="comment">// 以及未从 dyld shared cache 中找到 mhdr 的 header_info 时，添加 class 的数量到 unoptimizedTotalClasses 中。</span></span><br><span class="line">            <span class="keyword">auto</span> hi = <span class="built_in">addHeader</span>(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里有两种情况下 hi 为空：</span></span><br><span class="line">            <span class="comment">// 1. mhdr 的 magic 不是既定的 MH_MAGIC、MH_MAGIC_64、MH_CIGAM、MH_CIGAM_64 中的任何一个</span></span><br><span class="line">            <span class="comment">// 2. 从 dyld shared cache 中找到了 mhdr 的 header_info，并且 isLoaded 为 true（）</span></span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// #define MH_EXECUTE 0x2 /* demand paged executable file demand 分页可执行文件 */ </span></span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable&#x27;s size</span></span><br><span class="line">                <span class="comment">// 根据主要可执行文件的大小调整一些数据结构的大小</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">size_t</span> count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ⬇️ GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">                <span class="comment">// 获取 __objc_selrefs 区中的 SEL 的数量</span></span><br><span class="line">                _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// GETSECT(_getObjc2MessageRefs, message_ref_t, &quot;__objc_msgrefs&quot;); </span></span><br><span class="line">                <span class="comment">// struct message_ref_t &#123;</span></span><br><span class="line">                <span class="comment">//     IMP imp;</span></span><br><span class="line">                <span class="comment">//     SEL sel;</span></span><br><span class="line">                <span class="comment">// &#125;;</span></span><br><span class="line">                <span class="comment">// ⬇️ 获取 __objc_msgrefs 区中的 message 数量</span></span><br><span class="line">                _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">                <span class="comment">// 打印 image 信息</span></span><br><span class="line">                <span class="comment">// 如：objc[10565]: IMAGES: loading image for /usr/lib/system/libsystem_blocks.dylib (has class properties) (preoptimized)</span></span><br><span class="line">                _objc_inform(<span class="string">&quot;IMAGES: loading image for %s%s%s%s%s\n&quot;</span>, </span><br><span class="line">                             hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                             mhdr-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>() ? <span class="string">&quot; (has class properties)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                             hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">optimizedByDyld</span>()?<span class="string">&quot; (preoptimized)&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️</span></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until the executable itself is found. </span></span><br><span class="line">    <span class="comment">// 执行 one-time runtime initialization，必须推迟到找到可执行文件本身。</span></span><br><span class="line">    <span class="comment">// This needs to be done before further initialization.</span></span><br><span class="line">    <span class="comment">// 这需要在进一步初始化之前完成。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The executable may not be present in this infoList if the executable does not contain</span></span><br><span class="line">    <span class="comment">// Objective-C code but Objective-C is dynamically loaded later.</span></span><br><span class="line">    <span class="comment">// 如果可执行文件不包含 Objective-C 代码但稍后动态加载 Objective-C，则该可执行文件可能不会出现在此 infoList 中。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        <span class="comment">// 初始化 selector 表并注册内部使用的 selectors。</span></span><br><span class="line">        <span class="built_in">sel_init</span>(selrefCount);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ⬇️⬇️⬇️ 这里的 arr_init 函数超重要，可看到它内部做了三件事：</span></span><br><span class="line">        <span class="comment">// 1. 自动释放池的初始化（实际是在 TLS 中以 AUTORELEASE_POOL_KEY 为 KEY 写入 tls_dealloc 函数（自动释放池的销毁函数：内部所有 pages pop 并 free））</span></span><br><span class="line">        <span class="comment">// 2. SideTablesMap 初始化，也可理解为 SideTables 的初始化（为 SideTables 这个静态全局变量开辟空间）</span></span><br><span class="line">        <span class="comment">// 3. AssociationsManager 的初始化，即为全局使用的关联对象表开辟空间</span></span><br><span class="line">        <span class="comment">// void arr_init(void) </span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     AutoreleasePoolPage::init();</span></span><br><span class="line">        <span class="comment">//     SideTablesMap.init();</span></span><br><span class="line">        <span class="comment">//     _objc_associations_init();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">arr_init</span>();</span><br><span class="line">        </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在较低版本下 DYLD_MACOSX_VERSION_10_13 之前的版本中禁用 +initialize fork safety，大致看看即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app is too old (&lt; 10.13).</span></span><br><span class="line">        <span class="comment">// Disable +initialize fork safety if the app has a</span></span><br><span class="line">        <span class="comment">//   __DATA,__objc_fork_ok section.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dyld_get_program_sdk_version</span>() &lt; DYLD_MACOSX_VERSION_10_13) &#123;</span><br><span class="line">            DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                             <span class="string">&quot;safety enforcement because the app is &quot;</span></span><br><span class="line">                             <span class="string">&quot;too old (SDK version &quot;</span> SDK_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                             <span class="built_in">FORMAT_SDK</span>(<span class="built_in">dyld_get_program_sdk_version</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; hCount; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> hi = hList[i];</span><br><span class="line">            <span class="keyword">auto</span> mh = hi-&gt;<span class="built_in">mhdr</span>();</span><br><span class="line">            <span class="keyword">if</span> (mh-&gt;filetype != MH_EXECUTE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">getsectiondata</span>(hi-&gt;<span class="built_in">mhdr</span>(), <span class="string">&quot;__DATA&quot;</span>, <span class="string">&quot;__objc_fork_ok&quot;</span>, &amp;size)) &#123;</span><br><span class="line">                DisableInitializeForkSafety = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;INITIALIZE: disabling +initialize fork &quot;</span></span><br><span class="line">                                 <span class="string">&quot;safety enforcement because the app has &quot;</span></span><br><span class="line">                                 <span class="string">&quot;a __DATA,__objc_fork_ok section&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// assume only one MH_EXECUTE image</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️ 下面就来到了最核心的地方</span></span><br><span class="line">    <span class="comment">// 以 header_info *hList[mhCount] 数组中收集到的 images 的 header_info 为参，直接进行 image 的读取</span></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把开始时初始化的静态局部变量 firstTime 置为 NO</span></span><br><span class="line">    firstTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️</span></span><br><span class="line">    <span class="comment">// _read_images 看完再看下面的 loadImageFuncs 函数  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call image load funcs after everything is set up.</span></span><br><span class="line">    <span class="comment">// 一切设置完毕后调用 image 加载函数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> func : loadImageFuncs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; mhCount; i++) &#123;</span><br><span class="line">            <span class="built_in">func</span>(mhdrs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map_images_nolock</code> 就是：</p><ul><li>对 <code>const struct mach_header * const mhdrs[]</code> 参数的处理，把数组中的 <code>mach_header</code> 转换为 <code>header_info</code> 并存在 <code>header_info *hList[mhCount]</code> 数组中。</li><li>并统计 <code>totalClasses</code> 和 <code>unoptimizedTotalClasses</code> 的数量</li><li>然后调用下面的 <code>_read_images</code> 函数</li></ul><blockquote><p>在阅读_read_images()函数前，先来了解一下class在加载过程都有哪些状态，在objc中以怎样的数据结构来记录的。</p></blockquote><h3 id="3-2-class加载过程中的flag标志"><a href="#3-2-class加载过程中的flag标志" class="headerlink" title="3.2 class加载过程中的flag标志"></a>3.2 class加载过程中的flag标志</h3><p>当调用 runtime API 动态创建类的过程，包括三个步骤：</p><ul><li>调用<code>Class objc_allocateClassPair(...)</code>构建类；</li><li>添加必要的成员变量、方法等元素；</li><li>调用<code>void objc_registerClassPair(Class cls)</code>注册类；</li></ul><p>然而，runtime 从镜像（image）加载类的过程会更加精细，在加载类的不同阶段会被标记为不同的类型（还是<code>objc_class</code>结构体，只是<code>flags</code>不同），例如：</p><ul><li><strong>future class</strong>（未来要解析的类，也称懒加载类）<ul><li>named class（已确定名称类）：将<code>cls</code>标记为 named class，以<code>cls-&gt;mangledName()</code>类名为关键字添加到全局记录的<code>gdb_objc_realized_classes</code>哈希表中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>allocated class（已分配内存类）：将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的<code>allocatedClasses</code>哈希表中（无需关键字），表示已为类分配固定内存空间；</li></ul></li><li><strong>remapped class</strong>（已重映射类）</li><li><strong>realized class</strong>（已认识/实现类）</li><li>loaded class（已加载类）：已执行<code>load</code>方法的类</li><li>initialized class（已初始化类）：已执行<code>initialize()</code>方法的类</li></ul><blockquote><p>realized: adj. 已实现的; v. 意识到，认识到，理解；实现；把（概念等）具体表现出来.</p><p>OC 类在被使用之前（譬如调用类方法），需要进行一系列的初始化，譬如：指定 <code>superclass</code>、指定 <code>isa</code> 指针、<code>attach categories</code> 等等；libobjc 在 runtime 阶段就可以做这些事情，但是有些过于浪费，更好的选择是懒处理，这一举措极大优化了程序的执行速度。而 runtime 把对类的惰性初始化过程称为「realize」。</p><p>利用已经被 <code>realize</code> 的类含有 <code>RW_REALIZED</code> 和 <code>RW_REALIZING</code> 标记的特点，可以为项目找出无用类；因为没有被使用的类，一定没有被 <code>realized</code>。</p></blockquote><h4 id="3-2-1-class-rw-t-gt-flags"><a href="#3-2-1-class-rw-t-gt-flags" class="headerlink" title="3.2.1 class_rw_t-&gt;flags"></a>3.2.1 class_rw_t-&gt;flags</h4><p><code>class_rw_t</code>的<code>flags</code>为可读写。其中比较重要的一些值定义列举如下，均以RW_为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该类是已实现/已认识/已初始化处理过的类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZED           (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// 该类是尚未解析的unresolved future class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// 该类已经初始化。完成执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZED        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// 该类正在初始化。正在执行initialize()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INITIALIZING       (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// class_rw_t-&gt;ro是class_ro_t的堆拷贝。此时类的class_rw_t-&gt;ro是可写入的，拷贝之前ro的内存区域锁死不可写入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_COPIED_RO          (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// class allocated but not yet registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTING       (1&lt;&lt;26)</span></span><br><span class="line"><span class="comment">// class allocated and registered</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_CONSTRUCTED        (1&lt;&lt;25)</span></span><br><span class="line"><span class="comment">// 该类的load方法已经调用过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_LOADED             (1&lt;&lt;23)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"><span class="comment">// 该类的实例可能存在关联对象。默认编译选项下，无需定义该位，因为都可能有关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_INSTANCES_HAVE_ASSOCIATED_OBJECTS (1&lt;&lt;22)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该类的实例具有特定的GC layout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_HAS_INSTANCE_SPECIFIC_LAYOUT      (1 &lt;&lt; 21)</span></span><br><span class="line"><span class="comment">// 该类禁止在其实例上使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_FORBIDS_ASSOCIATED_OBJECTS        (1&lt;&lt;20)</span></span><br><span class="line"><span class="comment">// 该类正在实现，但是未实现完成</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RW_REALIZING          (1&lt;&lt;19)</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-class-ro-t-gt-flags"><a href="#3-2-2-class-ro-t-gt-flags" class="headerlink" title="3.2.2 class_ro_t-&gt;flags"></a>3.2.2 class_ro_t-&gt;flags</h4><p><code>class_ro_t</code>的<code>flags</code>成员为只读。其中比较重要的一些值定义列举如下，均以<code>RO_</code>为前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类是元类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_META               (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// 类是根类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_ROOT               (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// 类有CXX构造/析构函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_STRUCTORS  (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// 类有实现load方法</span></span><br><span class="line"><span class="comment">// #define RO_HAS_LOAD_METHOD    (1&lt;&lt;3)</span></span><br><span class="line"><span class="comment">// 隐藏类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HIDDEN             (1&lt;&lt;4)</span></span><br><span class="line"><span class="comment">// class has attribute(objc_exception): OBJC_EHTYPE_$_ThisClass is non-weak</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_EXCEPTION          (1&lt;&lt;5)</span></span><br><span class="line"><span class="comment">// class has ro field for Swift metadata initializer callback</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_SWIFT_INITIALIZER (1&lt;&lt;6)</span></span><br><span class="line"><span class="comment">// 类使用ARC选项编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARC             (1&lt;&lt;7)</span></span><br><span class="line"><span class="comment">// 类有CXX析构函数，但没有CXX构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_CXX_DTOR_ONLY  (1&lt;&lt;8)</span></span><br><span class="line"><span class="comment">// class is not ARC but has ARC-style weak ivar layout </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_HAS_WEAK_WITHOUT_ARC (1&lt;&lt;9)</span></span><br><span class="line"><span class="comment">// 类禁止使用关联对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FORBIDS_ASSOCIATED_OBJECTS (1&lt;&lt;10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class is in an unloadable bundle - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FROM_BUNDLE        (1&lt;&lt;29)</span></span><br><span class="line"><span class="comment">// class is unrealized future class - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_FUTURE             (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// class is realized - must never be set by compiler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_REALIZED           (1&lt;&lt;31)</span></span><br></pre></td></tr></table></figure><h3 id="3-3-read-images"><a href="#3-3-read-images" class="headerlink" title="3.3 _read_images()"></a>3.3 _read_images()</h3><p>观看下面内容之前，如果对 OC 中 <code>Class</code>、<code>Category</code>、<code>Protocol</code>的实现结构(底层的结构体实现及成员变量)不熟悉，建议先看一下<a href="">Runtime(一)：面向对象(Class和Object)的基本数据结构</a>、<a href="">Runtime(二)：Category、Protocol的实现与加载</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 headerList 开头的链表中的 headers 进行初始处理</span></span><br><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">uint32_t</span> hIndex;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    </span><br><span class="line">    Class *resolvedFutureClasses = nil;</span><br><span class="line">    <span class="keyword">size_t</span> resolvedFutureClassCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态局部变量，如果是第一次调用 _read_images 则 doneOnce 值为 NO</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> doneOnce;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> launchTime = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测量 image 加载步骤的持续时间</span></span><br><span class="line">    <span class="comment">// 对应 objc-env.h 中的 OPTION( PrintImageTimes, OBJC_PRINT_IMAGE_TIMES, &quot;measure duration of image loading steps&quot;)</span></span><br><span class="line">    <span class="function">TimeLogger <span class="title">ts</span><span class="params">(PrintImageTimes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EACH_HEADER 是给下面的 for 循环使用的宏，遍历 hList 数组中的 header_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EACH_HEADER \</span></span><br><span class="line">    hIndex = <span class="number">0</span>;         \</span><br><span class="line">    hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]); \</span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><h4 id="1-是否是第一次加载"><a href="#1-是否是第一次加载" class="headerlink" title="1. 是否是第一次加载"></a>1. 是否是第一次加载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1⃣️</span></span><br><span class="line"><span class="comment">// 第一次调用 _read_images 时，doneOnce 值为 NO，会进入 if 执行里面的代码 </span></span><br><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">    <span class="comment">// 把静态局部变量 doneOnce 置为 YES，之后调用 _read_images 都不会再进来</span></span><br><span class="line">    <span class="comment">// 第一次调用 _read_images 的时候，class、protocol、selector、category 都没有，</span></span><br><span class="line">    <span class="comment">// 需要创建容器来保存这些东西，此 if 内部，最后是创建一张存 class 的表。</span></span><br><span class="line">    doneOnce = YES;</span><br><span class="line">    </span><br><span class="line">    launchTime = YES;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段是在低版本（swifit3 之前、OS X 10.11 之前）下禁用 non-pointer isa 时的一些打印信息，</span></span><br><span class="line"><span class="comment">// 为了减少我们的理解负担，这里直接进行了删除，想要学习的同学可以去看一下源码</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointers, OBJC_DISABLE_TAGGED_POINTERS, &quot;disable tagged pointer optimization of NSNumber et al.&quot;)</span></span><br><span class="line">    <span class="comment">// 禁用 NSNumber 等的 Tagged Pointers 优化时</span></span><br><span class="line">    <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">        <span class="comment">// 内部直接把 Tagged Pointers 用到的 mask 全部置为 0</span></span><br><span class="line">        <span class="built_in">disableTaggedPointers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// OPTION( DisableTaggedPointerObfuscation, OBJC_DISABLE_TAG_OBFUSCATION, &quot;disable obfuscation of tagged pointers&quot;)</span></span><br><span class="line">    <span class="comment">// 可开启 OBJC_DISABLE_TAG_OBFUSCATION，禁用 Tagged Pointer 的混淆。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机初始化 objc_debug_taggedpointer_obfuscator。</span></span><br><span class="line">    <span class="comment">// tagged pointer obfuscator 旨在使攻击者在存在缓冲区溢出或其他对某些内存的写控制的情况下更难将特定对象构造为标记指针。</span></span><br><span class="line">    <span class="comment">// 在设置或检索有效载荷值（payload values）时， obfuscator 与 tagged pointers 进行异或。</span></span><br><span class="line">    <span class="comment">// 它们在第一次使用时充满了随机性。</span></span><br><span class="line">    <span class="built_in">initializeTaggedPointerObfuscator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OPTION( PrintConnecting, OBJC_PRINT_CLASS_SETUP, &quot;log progress of class and category setup&quot;)</span></span><br><span class="line">    <span class="comment">// objc[26520]: CLASS: found 25031 classes during launch 在 objc-781 下在启动时有 25031 个类（包含所有的系统类和自定义类）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// namedClasses</span></span><br><span class="line">    <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">    <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPreoptimized 如果我们有一个有效的优化共享缓存（valid optimized shared cache），则返回 YES。</span></span><br><span class="line">    <span class="comment">// 然后是不管三目运算符返回的是 unoptimizedTotalClasses 还是 totalClasses，它都会和后面的 4 / 3 相乘，</span></span><br><span class="line">    <span class="comment">// 注意是 4 / 3</span></span><br><span class="line">    <span class="keyword">int</span> namedClassesSize = (<span class="built_in">isPreoptimized</span>() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// gdb_objc_realized_classes 是一张全局的哈希表，虽然名字中有 realized，但是它的名字其实是一个误称，</span></span><br><span class="line">    <span class="comment">// 实际上它存放的是不在 dyld shared cache 中的 class，无论该 class 是否 realized。</span></span><br><span class="line">    gdb_objc_realized_classes = <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 objc-781 下执行到这里时，会有如下打印:</span></span><br><span class="line">    <span class="comment">// objc[19881]: 0.04 ms: IMAGE TIMES: first time tasks</span></span><br><span class="line">    <span class="comment">// 这个过程花了 0.04 毫秒</span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修复预编译时-selector-错乱问题"><a href="#2-修复预编译时-selector-错乱问题" class="headerlink" title="2. 修复预编译时 @selector 错乱问题"></a>2. 修复预编译时 @selector 错乱问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 注册并修正 selector references. Fix up @selector references</span></span><br><span class="line">  <span class="comment">//（其实就是把 image 的 __objc_selrefs 区中的 selector 放进全局的 selector 集合中，修改其中不一致的地址）</span></span><br><span class="line"><span class="comment">// 也就是当 SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); 中的 SEL 和通过 SEL sel = sel_registerNameNoLock(name, isBundle); 注册返回的 SEL 不同时，就把 sels 中的 SEL 修正为 sel_registerNameNoLock 中返回的地址。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 加锁 selLock</span></span><br><span class="line">      <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 遍历 header_info **hList 中的 header_info</span></span><br><span class="line">      <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 如果指定的 hi 不需要预优化则跳过</span></span><br><span class="line">          <span class="keyword">if</span> (hi-&gt;<span class="built_in">hasPreoptimizedSelectors</span>()) <span class="keyword">continue</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 根据 mhdr()-&gt;filetype 判断 image 是否是 MH_BUNDLE 类型</span></span><br><span class="line">          <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// GETSECT(_getObjc2SelectorRefs, SEL, &quot;__objc_selrefs&quot;);</span></span><br><span class="line">          <span class="comment">// 获取 __objc_selrefs 区中的 SEL</span></span><br><span class="line">          SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 记录数量</span></span><br><span class="line">          UnfixedSelectors += count;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// static objc::ExplicitInitDenseSet&lt;const char *&gt; namedSelectors;</span></span><br><span class="line">          <span class="comment">// 是一个静态全局 set，用来存放 Selector（名字，Selector 本身就是字符串）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 遍历把 sels 中的所有 selector 放进全局的 selector 集合中   </span></span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          </span><br><span class="line">              <span class="comment">// sel_cname 函数内部实现是返回：(const char *)(void *)sel; 即把 SEL 强转为 char 类型</span></span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(sels[i]);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 注册 SEL，并返回其地址</span></span><br><span class="line">              SEL sel = <span class="built_in">sel_registerNameNoLock</span>(name, isBundle);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// 如果 SEL 地址发生变化，则把它设置为相同</span></span><br><span class="line">              <span class="keyword">if</span> (sels[i] != sel) &#123;</span><br><span class="line">                  sels[i] = sel;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里打印注册并修正 selector references 用的时间</span></span><br><span class="line">  <span class="comment">// 在 objc-781 下打印：objc[27056]: 0.44 ms: IMAGE TIMES: fix up selector references</span></span><br><span class="line">  <span class="comment">// 耗时 0.44 毫秒</span></span><br><span class="line">  ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up selector references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-readClass-读取类信息，修复future-classes"><a href="#3-readClass-读取类信息，修复future-classes" class="headerlink" title="3. readClass()读取类信息，修复future classes"></a>3. readClass()读取类信息，修复future classes</h4><p>通过 readClass 读取出来类的信息，修复未解析的future classes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line"><span class="comment">// 发现 classes。修复 unresolved future classes。标记 bundle classes。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns if any OS dylib has overridden its copy in the shared cache</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exists in iPhoneOS 3.1 and later </span></span><br><span class="line"><span class="comment">// Exists in Mac OS X 10.10 and later</span></span><br><span class="line"><span class="keyword">bool</span> hasDyldRoots = <span class="built_in">dyld_shared_cache_some_image_overridden</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">mustReadClasses</span>(hi, hasDyldRoots)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="comment">// Image 已充分优化，我们无需调用 readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ClassList, classref_t const, &quot;__objc_classlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 __objc_classlist 区中的 classref_t</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从编译后的类列表中取出所有类，获取到的是一个 classref_t 类型的指针 </span></span><br><span class="line">    <span class="comment">// classref_t is unremapped class_t* ➡️ classref_t 是未重映射的 class_t 指针</span></span><br><span class="line">    <span class="comment">// typedef struct classref * classref_t; // classref_t 是 classref 结构体指针</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点 ⚠️⚠️⚠️⚠️ 在这里：readClass。</span></span><br><span class="line">        <span class="comment">// 我们留在下面单独分析。</span></span><br><span class="line">        Class newCls = <span class="built_in">readClass</span>(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// 类被移动但未被删除。目前，这种情况只发生在新类解析未来类时。</span></span><br><span class="line">            <span class="comment">// 非惰性地实现下面的类</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// realloc 原型是 extern void *realloc(void *mem_address, unsigned int newsize);</span></span><br><span class="line">            <span class="comment">// 先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，</span></span><br><span class="line">            <span class="comment">// 如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，</span></span><br><span class="line">            <span class="comment">// 而后释放原来 mem_address 所指内存区域（注意：原来指针是自动释放，不需要使用 free），</span></span><br><span class="line">            <span class="comment">// 同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。</span></span><br><span class="line">            </span><br><span class="line">            resolvedFutureClasses = (Class *)<span class="built_in">realloc</span>(resolvedFutureClasses, (resolvedFutureClassCount+<span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现 classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 3.17 ms: IMAGE TIMES: discover classes</span></span><br><span class="line"><span class="comment">// 耗时 3.17 毫秒（和前面的 0.44 毫秒比，多出不少）</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-future-class的生成"><a href="#1-future-class的生成" class="headerlink" title="1) future class的生成"></a>1) future class的生成</h5><p><code>objc_class</code>的<code>isFuture()</code>函数，用于判断类是否为 future class。future class 对理解类的加载过程有重要作用。</p><p>首先看 <strong>future class 是如何生成的</strong> — <code>addFutureNamedClass()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 安装cls作为类结构，用于命名类(如果之后出现)。 </span></span><br><span class="line"><span class="comment"> 将传入的 cls 参数，配置为类名为 name的 future class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配 cls 所需的 class_rw_t、class_ro_t 的内存空间；</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">class_ro_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 将 cls 的类名置为 name；</span></span><br><span class="line">    ro-&gt;name = <span class="built_in">strdupIfMutable</span>(name);</span><br><span class="line">    <span class="comment">// 3. 将 class_rw_t 的 RO_FUTURE 位置为1，RO_FUTURE 等于 RW_FUTURE；</span></span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    cls-&gt;<span class="built_in">data</span>()-&gt;flags = RO_FUTURE; </span><br><span class="line"><span class="comment">// 4. 以 name 为关键字(key)，将 cls 添加到一个全局的哈希表 futureNamedClasses；</span></span><br><span class="line">    old = <span class="built_in">NXMapKeyCopyingInsert</span>(<span class="built_in">futureNamedClasses</span>(), name, cls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> NXMapTable *future_named_class_map = nil;</span><br><span class="line"><span class="comment">/* 返回一个map，key为 classname, value 为 unrealized future classes(Class实例)*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">futureNamedClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) <span class="keyword">return</span> future_named_class_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// future_named_class_map is big enough for CF’s classes and a few others</span></span><br><span class="line">    future_named_class_map = </span><br><span class="line">        <span class="built_in">NXCreateMapTable</span>(NXStrValueMapPrototype, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future_named_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为给定的类名分配一个未解析的未来类 unresolved future class</span></span><br><span class="line"><span class="comment"> * 如果已经分配，则返回任何现有分配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class _objc_allocateFutureClass(<span class="keyword">const</span> <span class="keyword">char</span> *name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    NXMapTable *map = <span class="built_in">futureNamedClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cls = (Class)<span class="built_in">NXMapGet</span>(map, name))) &#123;</span><br><span class="line">        <span class="comment">// 存在名为name的future class</span></span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 分配用于保存objc_class的内存空间</span></span><br><span class="line">    cls = _calloc_class(<span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构建名为name的future class并全局记录到 futureNamedClasses 哈希表</span></span><br><span class="line">    <span class="built_in">addFutureNamedClass</span>(name, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> Return the id of the named class.</span></span><br><span class="line"><span class="comment"> 如果该类不存在，则返回一个未初始化的类结构，该结构将在类加载时使用。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span>&#123;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Class look_up_class(const char *name, </span></span><br><span class="line"><span class="comment">              bool includeUnconnected __attribute__((unused)), </span></span><br><span class="line"><span class="comment">              bool includeClassHandler __attribute__((unused))) // unconnected is OK，因为总有一天它会成为真正的class</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cls = <span class="built_in">look_up_class</span>(name, YES, NO);</span><br><span class="line">    <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;FUTURE: found %p already in use for %s&quot;</span>, </span><br><span class="line">                         (<span class="keyword">void</span>*)cls, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还没有名为name的class或future class。做一个。</span></span><br><span class="line">    <span class="keyword">return</span> _objc_allocateFutureClass(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用链向上追溯到 <code>Class objc_getFutureClass</code>，该函数并没有在 runtime 源代码中被调用到。而用于从 <code>namedFutureClasses</code> 哈希表中获取 future class 的<code>popFutureClass(...)</code> 函数是有间接通过<code>readClass(...)</code>函数被广泛调用。因此，<strong>构建 future class 的逻辑大多隐藏在 runtime 的内部实现中未公布，只有使用 future class 的逻辑是开源的</strong>。</p><h5 id="2-future-class的获取"><a href="#2-future-class的获取" class="headerlink" title="2) future class的获取"></a>2) future class的获取</h5><p> <code>popFutureNamedClass</code> 用于从 <code>futureNamedClasses</code> 哈希表中弹出类名为<code>name</code>的 future class，这是获取全局记录的 future class 的唯一入口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Removes the named class from the unrealized future class list, because it has been realized.</span></span><br><span class="line"><span class="comment"> * Returns nil if the name is not used by a future class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">popFutureNamedClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future_named_class_map) &#123;</span><br><span class="line">        cls = (Class)<span class="built_in">NXMapKeyFreeingRemove</span>(future_named_class_map, name);</span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; <span class="built_in">NXCountMapTable</span>(future_named_class_map) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NXFreeMapTable</span>(future_named_class_map);</span><br><span class="line">            future_named_class_map = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-future-class的使用-—-readClass"><a href="#3-future-class的使用-—-readClass" class="headerlink" title="3) future class的使用 — readClass"></a>3) future class的使用 — readClass</h5><p>readClass 用于读取<code>cls</code>中的类数据，关键处理逻辑表述如下：</p><ul><li>若 <code>futureNamedClasses</code> 哈希表中存在 <code>cls-&gt;mangledName()</code> 类名的 future class，则将<code>cls</code>重映射（remapping）到新的类 <code>newCls</code>（具体重映射过程在下面4小节中详细讨论），然后将 <code>newCls</code> 标记为 remapped class，以<code>cls</code>为关键字添加到全局记录的 <code>remappedClasses()</code> 哈希表中；</li><li>将<code>cls</code>标记为 named class，以 <code>cls-&gt;mangledName()</code> 类名为关键字添加到全局记录的 <code>gdb_objc_realized_classes</code> 哈希map中，表示 runtime 开始可以通过类名查找类（注意元类不需要添加）；</li><li>将<code>cls</code>及其元类标记为 allocated class，并将两者均添加到全局记录的 <code>allocatedClasses</code> 哈希set中，表示已为类分配固定内存空间；</li></ul><blockquote><p>注意：传入<code>readClass(...)</code>的<code>cls</code>参数是<code>Class</code>类型，而函数返回结果也是<code>Class</code>，为什么读取类信息是“从类中读取类信息”这样怪异的过程呢？</p><p>其实是因为<code>cls</code>参数来源于 runtime 未开源的、从镜像（image）中读取类的过程。该过程输出的<code>objc_class</code>存在特殊之处：要么输出 future class，要么输出正常(normal)类但是其<code>bits</code>指向的是<code>class_ro_t</code>结构体而非<code>class_rw_t</code>，之所以如此是因为从镜像读取的是编译时决议的静态数据，本来就应该保存在<code>class_ro_t</code>结构体中。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* readClass</span></span><br><span class="line"><span class="comment">* Read a class and metaclass as written by a compiler.</span></span><br><span class="line"><span class="comment">* Returns the new class pointer. This could be: </span></span><br><span class="line"><span class="comment">* - cls</span></span><br><span class="line"><span class="comment">* - nil  (cls has a missing weak-linked superclass)</span></span><br><span class="line"><span class="comment">* - something else (space for this class was reserved by a future class)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images or objc_readClassPair</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">Class <span class="title">readClass</span><span class="params">(Class cls, <span class="keyword">bool</span> headerIsBundle, <span class="keyword">bool</span> headerIsPreoptimized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName = cls-&gt;<span class="built_in">nonlazyMangledName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类的继承链上，存在既不是根类（RO_ROOT位为0）又没有超类的类，则为missingWeakSuperclass</span></span><br><span class="line">    <span class="comment">// 注意：这是唯一的向remappedClasses中添加nil值的入口</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">missingWeakSuperclass</span>(cls)) &#123;</span><br><span class="line">        <span class="built_in">addRemappedClass</span>(cls, nil);</span><br><span class="line">        cls-&gt;<span class="built_in">setSuperclass</span>(nil);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 兼容旧版本libobjc的配置，可忽略</span></span><br><span class="line">    cls-&gt;<span class="built_in">fixupBackwardDeployingStableSwift</span>();</span><br><span class="line"></span><br><span class="line">    Class replacing = nil;</span><br><span class="line">    <span class="keyword">if</span> (mangledName != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">            <span class="comment">// 这个name已经被分配为future class，全局记录。</span></span><br><span class="line">            <span class="comment">// 将cls的内容拷贝到newCls(也就是future class)中，保存future class的rw中的数据。将cls-&gt;data设置为rw-&gt;ro</span></span><br><span class="line">            <span class="comment">// 以cls为关键字将构建的newCls添加到全局记录的remappedClasses哈希表中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newCls-&gt;<span class="built_in">isAnySwift</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Can&#x27;t complete future class request for &#x27;%s&#x27; &quot;</span></span><br><span class="line">                            <span class="string">&quot;because the real class is too big.&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">            <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Manually set address-discriminated ptrauthed fields</span></span><br><span class="line">            <span class="comment">// so that newCls gets the correct signatures.</span></span><br><span class="line">            newCls-&gt;<span class="built_in">setSuperclass</span>(cls-&gt;<span class="built_in">getSuperclass</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">initIsa</span>(cls-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line"></span><br><span class="line">            rw-&gt;<span class="built_in">set_ro</span>((<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>());</span><br><span class="line">            newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">            <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;<span class="built_in">getName</span>());</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line"></span><br><span class="line">            replacing = cls;</span><br><span class="line">            cls = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123;</span><br><span class="line">        <span class="comment">// class list built in shared cache</span></span><br><span class="line">        <span class="comment">// 已存在该类名的named class</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(mangledName == <span class="literal">nullptr</span> || <span class="built_in">getClassExceptSomeSwift</span>(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mangledName) &#123; <span class="comment">// 一些Swift泛型类可以惰性地生成它们的名称</span></span><br><span class="line">            <span class="comment">// 将类添加到 named classes</span></span><br><span class="line">            <span class="built_in">addNamedClass</span>(cls, mangledName, replacing);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Class meta = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *metaRO = meta-&gt;bits.<span class="built_in">safe_ro</span>();</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() &amp;&amp; <span class="string">&quot;Metaclass with lazy name must have a pointer to the corresponding nonmetaclass.&quot;</span>);</span><br><span class="line">            <span class="built_in">ASSERT</span>(metaRO-&gt;<span class="built_in">getNonMetaclass</span>() == cls &amp;&amp; <span class="string">&quot;Metaclass nonmetaclass pointer must equal the original class.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将类添加到 allocated classes</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="comment">// 设置RO_FROM_BUNDLE位</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-future-class小结"><a href="#4-future-class小结" class="headerlink" title="4) future class小结"></a>4) future class小结</h5><p>从上文<code>readClass(...)</code>代码<code>if (Class newCls = popFutureNamedClass(mangledName))</code>分支内<code>free((void *)old_ro)</code>语句，得出在<code>cls</code>映射到<code>newCls</code>过程中，完全丢弃了 future class 的<code>ro</code>数据。最后，结合以上所有代码，可以归纳以下结论：</p><ul><li><p>Future class 类的有效数据实际上仅有：类名和<code>rw</code>。<code>rw</code>中的数据作用也非常少，仅使用<code>flags</code>的<code>RO_FUTURE</code>（实际上就是<code>RW_FUTURE</code>）标记类是 future class；</p></li><li><p>Future class 的作用是为指定类名的类，提前分配好内存空间，调用<code>readClass(...)</code>函数读取类时，才正式写入类的数据。 Future class 是用于支持类的懒加载机制；</p></li></ul><h4 id="4-remapped-重新映射-classes"><a href="#4-remapped-重新映射-classes" class="headerlink" title="4. remapped(重新映射) classes"></a>4. remapped(重新映射) classes</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fix up remapped classes</span></span><br><span class="line">    <span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line">    <span class="comment">// Class list 和 nonlazy class list 仍未映射。</span></span><br><span class="line">    <span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">    <span class="comment">// Class refs 和 super refs 被重新映射为消息调度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是修复重映射 classes，!noClassesRemapped() 在这里为 false，所以一般走不进来，</span></span><br><span class="line">    <span class="comment">// 将未映射 class 和 super class 重映射，被 remap 的类都是非懒加载的类</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">noClassesRemapped</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2ClassRefs, Class, &quot;__objc_classrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_classrefs 区中的类引用</span></span><br><span class="line">            Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历 classrefs 中的类引用，如果类引用已被重新分配或者是被忽略的弱链接类，</span></span><br><span class="line">            <span class="comment">// 就将该类引用重新赋值为从重映射类表中取出新类</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// Fix up a class ref, in case the class referenced has been reallocated or is an ignored weak-linked class.</span></span><br><span class="line">                <span class="comment">// 修复 class ref，以防所引用的类已 reallocated 或 is an ignored weak-linked class。</span></span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">            <span class="comment">// GETSECT(_getObjc2SuperRefs, Class, &quot;__objc_superrefs&quot;);</span></span><br><span class="line">            <span class="comment">// 获取 __objc_superrefs 区中的父类引用</span></span><br><span class="line">            classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="built_in">remapClassRef</span>(&amp;classrefs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里打印修复重映射 classes 用的时间</span></span><br><span class="line">    <span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: remap classes</span></span><br><span class="line">    <span class="comment">// 耗时 0 毫秒，即 Fix up remapped classes 并没有执行 </span></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: remap classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_FIXUP</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> cacheSupportsProtocolRoots = <span class="built_in">sharedCacheSupportsProtocolRoots</span>();</span><br></pre></td></tr></table></figure><h5 id="1-future-class-的重映射"><a href="#1-future-class-的重映射" class="headerlink" title="1) future class 的重映射"></a>1) future class 的重映射</h5><p>在上面 <code>readClass()</code> 中有提到类的重映射，重映射的类被标记为 remapped class，并以映射前的类为关键字，添加到全局的<code>remappedClass</code>哈希表中。回顾<code>readClass()</code>函数中，类的重映射代码如下，关于处理过程的详细描述已注释到代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 若该类名已被标记为future class，则弹出该类名对应的future class 赋值给newCls</span></span><br><span class="line"><span class="keyword">if</span> (Class newCls = <span class="built_in">popFutureNamedClass</span>(mangledName)) &#123;</span><br><span class="line">    <span class="comment">// 2. rw记录future class的rw</span></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw = newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 3. future class的ro记为old_ro，后面释放其占用的内存空间并丢弃</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *old_ro = rw-&gt;ro;</span><br><span class="line">    <span class="comment">// 4. 将cls中的数据拷贝到newCls，主要是要沿用cls的isa、superclass和cache数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(newCls, cls, <span class="built_in"><span class="keyword">sizeof</span></span>(objc_class));</span><br><span class="line">    <span class="comment">// 5. rw记录cls的ro</span></span><br><span class="line">    rw-&gt;ro = (<span class="keyword">class_ro_t</span> *)newCls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 6. 沿用future class的rw、cls的ro</span></span><br><span class="line">    newCls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    <span class="comment">// 7. 释放future class的ro占用的空间</span></span><br><span class="line">    <span class="built_in">freeIfMutable</span>((<span class="keyword">char</span> *)old_ro-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)old_ro);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 将newCls以cls为关键字添加到remappedClasses哈希表中</span></span><br><span class="line">    <span class="built_in">addRemappedClass</span>(cls, newCls);</span><br><span class="line">    </span><br><span class="line">    replacing = cls;</span><br><span class="line">    cls = newCls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合上面代码的详细注释，可知<code>cls</code>重映射到<code>newCls</code>后，<code>newCls</code>的数据保留了<code>cls</code>中的<code>superclass</code>、<code>cache</code>成员，但是<code>bits</code>中指向<code>class_rw_t</code>结构体地址的位域（<code>FAST_DATA_MASK</code>）指向了<strong>新的<code>class_rw_t</code>结构体</strong>。该结构体的<code>ro</code>指针指向<code>cls-&gt;data()</code>所指向的内存空间中保存的<code>class_ro_t</code>结构体，其他数据则是直接沿用 从<code>namedFutureClasses</code>哈希表中弹出的 future class 的<code>class_rw_t</code>结构体（通过future class 的<code>data()</code>方法返回）中数据。</p><blockquote><p>注意：虽然<code>objc_class</code>的<code>data()</code>方法声明为返回<code>class_rw_t *</code>，但是究其本质，它只是返回了<code>objc_class</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>标记的位域中保存的内存地址，该内存地址实际上可以保存任何类型的数据。在<code>Class readClass(Class cls, bool headerIsBundle, bool headerIsPreoptimized)</code>函数中，传入的<code>cls</code>所指向的<code>objc_class</code>结构体有其特殊之处：<code>cls</code>的<code>bits</code>成员的<code>FAST_DATA_MASK</code>位域，指向的内存空间保存的是<code>class_ro_t</code>结构体，并不是通常的<code>class_rw_t</code>。</p></blockquote><h5 id="2-通用类的重映射"><a href="#2-通用类的重映射" class="headerlink" title="2) 通用类的重映射"></a>2) 通用类的重映射</h5><p>通用的类重映射调用<code>static class remapClass(Class cls)</code>，注意当传入的<code>cls</code>类不在<code>remappedClasses</code>哈希表中时，直接返回<code>cls</code>本身；<code>static void remapClassRef(Class *clsref)</code>可对传入的<code>Class* clsref</code>重映射（改变<code>*clsref</code>的值），返回时<code>clsref</code>将 指向<code>*clsref</code>重映射后的类。类的重映射相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取remappedClasses，保存已重映射的所有类的全局哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXMapTable *<span class="title">remappedClasses</span><span class="params">(<span class="keyword">bool</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态的全局哈希表，没有找到remove接口，只会无限扩张</span></span><br><span class="line">    <span class="keyword">static</span> NXMapTable *remapped_class_map = nil;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remapped_class_map) <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">    <span class="keyword">if</span> (!create) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remapped_class_map is big enough to hold CF’s classes and a few others</span></span><br><span class="line">    <span class="built_in">INIT_ONCE_PTR</span>(remapped_class_map, </span><br><span class="line">                  <span class="built_in">NXCreateMapTable</span>(NXPtrValueMapPrototype, <span class="number">32</span>), </span><br><span class="line">                  <span class="built_in">NXFreeMapTable</span>(v));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remapped_class_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将oldcls重映射得到的newcls，以oldcls为关键字插入到remappedClasses哈希表中</span></span><br><span class="line"><span class="comment">// 注意：从代码透露出来的信息是，remappedClasses中只保存 future class 重映射的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRemappedClass</span><span class="params">(Class oldcls, Class newcls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintFuture) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;FUTURE: using %p instead of %p for %s&quot;</span>, </span><br><span class="line">                     (<span class="keyword">void</span>*)newcls, (<span class="keyword">void</span>*)oldcls, oldcls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = <span class="built_in">NXMapInsert</span>(<span class="built_in">remappedClasses</span>(YES), oldcls, newcls);</span><br><span class="line">    <span class="built_in">assert</span>(!old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取cls的重映射类</span></span><br><span class="line"><span class="comment">// 注意：当remappedClasses为空或哈希表中不存在`cls`关键字，是返回`cls`本身，否则返回`cls`重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *map = <span class="built_in">remappedClasses</span>(NO);</span><br><span class="line">    <span class="keyword">if</span> (!map  ||  <span class="built_in">NXMapMember</span>(map, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Class的指针的重映射，返回时传入的clsref将 指向*clsref重映射后的类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remapClassRef</span><span class="params">(Class *clsref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    Class newcls = <span class="built_in">remapClass</span>(*clsref);    </span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) *clsref = newcls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-remap小结"><a href="#3-remap小结" class="headerlink" title="3) remap小结"></a>3) remap小结</h5><p>最后归纳出以下结论：</p><ul><li>Future class 进行重映射后，会返回新的类，保存在<code>remappedClasses</code>全局哈希表中；</li><li>正常类重映射返回类本身；</li><li>重映射的真正的目的是支持类的懒加载，懒加载类暂存为 future class 只记录类名及 future class 属性，在调用<code>readClass</code>才正式载入类数据。</li></ul><h4 id="5-类中如果有协议，读取协议"><a href="#5-类中如果有协议，读取协议" class="headerlink" title="5. 类中如果有协议，读取协议"></a>5. 类中如果有协议，读取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="comment">// 发现 protocols，修正 protocol refs。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个长度是 16 的 NXMapTable</span></span><br><span class="line">    NXMapTable *protocol_map = <span class="built_in">protocols</span>();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;<span class="built_in">hasPreoptimizedProtocols</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip reading protocols if this is an image from the shared cache and we support roots</span></span><br><span class="line">    <span class="comment">// 如果这是来自 shared cache 的 image 并且我们 support roots，则跳过 reading protocols</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Note, after launch we do need to walk the protocol as the protocol in the shared cache is marked with isCanonical()</span></span><br><span class="line">    <span class="comment">// and that may not be true if some non-shared cache binary was chosen as the canonical definition</span></span><br><span class="line">    <span class="comment">// 启动后，我们确实需要遍历协议，因为 shared cache 中的协议用 isCanonical() 标记，如果选择某些非共享缓存二进制文件作为规范定义，则可能不是这样</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; isPreoptimized &amp;&amp; cacheSupportsProtocolRoots) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintProtocols) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;PROTOCOLS: Skipping reading protocols in image: %s&quot;</span>, hi-&gt;<span class="built_in">fname</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolList, protocol_t * const, &quot;__objc_protolist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protolist 区下的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> * <span class="keyword">const</span> *protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Read a protocol as written by a compiler.</span></span><br><span class="line">        <span class="built_in">readProtocol</span>(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印发现并修正 protocols 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 5.45 ms: IMAGE TIMES: discover protocols</span></span><br><span class="line"><span class="comment">// 耗时 05.45 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover protocols&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="6-映射协议"><a href="#6-映射协议" class="headerlink" title="6. 映射协议"></a>6. 映射协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right answer already but we don&#x27;t know for sure.</span></span><br><span class="line"><span class="comment">// Preoptimized images 可能已经有了正确的答案，但我们不确定。</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// At launch time, we know preoptimized image refs are pointing at the shared cache definition of a protocol.</span></span><br><span class="line">    <span class="comment">// 在启动时，我们知道 preoptimized image refs 指向协议的 shared cache 定义。</span></span><br><span class="line">    <span class="comment">// We can skip the check on launch, but have to visit @protocol refs for shared cache images loaded later.</span></span><br><span class="line">    <span class="comment">// 我们可以跳过启动时的检查，但必须访问 @protocol refs 以获取稍后加载的 shared cache images。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (launchTime &amp;&amp; cacheSupportsProtocolRoots &amp;&amp; hi-&gt;<span class="built_in">isPreoptimized</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2ProtocolRefs, protocol_t *, &quot;__objc_protorefs&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_protorefs 区的 protocol_t</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// Fix up a protocol ref, in case the protocol referenced has been reallocated.</span></span><br><span class="line">        <span class="comment">// 修复 protocol ref，以防 protocol referenced 已重新分配。</span></span><br><span class="line">        <span class="built_in">remapProtocolRef</span>(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 @protocol references 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: fix up @protocol references</span></span><br><span class="line"><span class="comment">// 因为是第一次启动，则并不进行</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: fix up @protocol references&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-加载分类"><a href="#7-加载分类" class="headerlink" title="7. 加载分类"></a>7. 加载分类</h4><p>把 category 的数据追加到原类中去！很重要。</p><p>这里并不会执行，didInitialAttachCategories 是一个静态全局变量，默认是 false，对于启动时出现的 categories，discovery 被推迟到 <code>_dyld_objc_notify_register</code> 调用完成后的第一个 <code>load_images</code> 调用。所以这里 if 里面的 Discover categories 是不会执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. 发现类别。</span></span><br><span class="line"><span class="comment">// 仅在完成 initial category attachment 后才执行此操作。</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// didInitialAttachCategories 是一个静态全局变量，默认是 false，</span></span><br><span class="line"><span class="comment">// static bool didInitialAttachCategories = false; 在load_images()函数体中，才会置为true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (didInitialAttachCategories) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Discover categories. 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.00 ms: IMAGE TIMES: discover categories</span></span><br><span class="line"><span class="comment">// 对于启动时出现的 categories，discovery 被推迟到 _dyld_objc_notify_register 调用完成后的第一个 load_images 调用。</span></span><br><span class="line"><span class="comment">// 所以这里 if 里面的 category 数据加载是不会执行的。</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: discover categories&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当其他线程在该线程完成其修复(thread finishes its fixups)之前调用新的category代码时，category discovery必须延迟以避免潜在的竞争。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +load 由 prepare_load_methods() 处理</span></span><br></pre></td></tr></table></figure><h4 id="8-realize非懒加载类-—-realized-class"><a href="#8-realize非懒加载类-—-realized-class" class="headerlink" title="8. realize非懒加载类 — realized class"></a>8. realize非懒加载类 — realized class</h4><p>懒加载：类没有实现 +load 函数，在使用的第一次才会加载，当我们给这个类的发送消息时，如果是第一次，在消息查找的过程中就会判断这个类是否加载，没有加载就会加载这个类。懒加载类在首次调用方法的时候，才会去调用 <code>realizeClassWithoutSwift</code> 函数去进行加载。</p><p>非懒加载：类的内部实现了 +load 函数，类的加载就会提前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="comment">// 实现非懒加载类（为了+load调用、静态实例）</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取 hi 的 __objc_nlclslist 区中的非懒加载类（即实现了 +load 函数的类）</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 重映射类， 获取正确的类指针</span></span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// static void addClassTableEntry(Class cls, bool addMeta = true) &#123; ... &#125;</span></span><br><span class="line">        <span class="comment">// 将一个类添加到用来存储所有类的全局的 set 中（auto &amp;set = objc::allocatedClasses.get();）。</span></span><br><span class="line">        <span class="comment">// 如果 addMeta 为 true（默认为 true），也自动添加类的元类到这个 set 中。</span></span><br><span class="line">        <span class="comment">// 这个类可以通过 shared cache 或 data segments 成为已知类，但不允许已经在 dynamic table 中。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// allocatedClasses 是 objc 命名空间中的一个静态变量。</span></span><br><span class="line">        <span class="comment">// A table of all classes (and metaclasses) which have been allocated with objc_allocateClassPair.</span></span><br><span class="line">        <span class="comment">// 已使用 objc_allocateClassPair 分配空间的存储所有 classes（和 metaclasses）的 Set。</span></span><br><span class="line">        <span class="comment">// namespace objc &#123;</span></span><br><span class="line">        <span class="comment">//     static ExplicitInitDenseSet&lt;Class&gt; allocatedClasses;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把 cls 放入 allocatedClasses 中，然后递归把 metaclass 放入 allocatedClasses 中</span></span><br><span class="line">        <span class="built_in">addClassTableEntry</span>(cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 cls 是否是来自稳定的 Swift ABI 的 Swift 类</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">swiftMetadataInitializer</span>()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class %s with a metadata initializer &quot;</span></span><br><span class="line">                            <span class="string">&quot;is not allowed to be non-lazy&quot;</span>,</span><br><span class="line">                            cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes We can&#x27;t disallow all Swift classes because of classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">            <span class="comment">// 也禁止 relocatable classes 我们不能因为像 Swift.__EmptyArrayStorage 这样的类而禁止所有 Swift 类</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现 Swift 之外的 classes</span></span><br><span class="line">        <span class="comment">// 对类 cls 执行首次初始化，包括分配其读写数据。不执行任何 Swift 端初始化。返回类的真实类结构。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 大概是设置 ro rw 和一些标识位的过程，也包括递归实现父类（supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass), nil);）</span></span><br><span class="line">        <span class="comment">// 和元类（metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()), nil);），</span></span><br><span class="line">        <span class="comment">// 然后更新 cls 的父类和元类（cls-&gt;superclass = supercls; cls-&gt;initClassIsa(metacls);），</span></span><br><span class="line">        <span class="comment">// 将 cls 连接到其父类的子类列表（addSubclass(supercls, cls);）（操作 class_rw_t 的 Class firstSubclass; 和 Class nextSiblingClass; 两个成员变量），</span></span><br><span class="line">        <span class="comment">// 修正 cls 的方法列表、协议列表和属性列表，</span></span><br><span class="line">        <span class="comment">// 以及最后的附加任何未完成的 categories（主要包含 method list、protocol list、property list）</span></span><br><span class="line">        <span class="comment">//（objc::unattachedCategories.attachToClass）。</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里打印 Realize non-lazy classes 用的时间</span></span><br><span class="line"><span class="comment">// 在 objc-781 下打印：objc[56474]: 0.23 ms: IMAGE TIMES: realize non-lazy classes</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize non-lazy classes&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="1-realizeClassWithoutSwift"><a href="#1-realizeClassWithoutSwift" class="headerlink" title="1) realizeClassWithoutSwift()"></a>1) realizeClassWithoutSwift()</h5><p>调用<code>readClass(...)</code>读取类数据只是载入了类的<code>class_ro_t</code>静态数据，因此仍需要进一步配置<code>objc_class</code>的<code>class_rw_t</code>结构体的数据。这个过程为 class realizing，姑且称之为认识/实现类。具体包括：</p><ul><li>配置<code>class_rw_t</code>的<code>RW_REALIZED</code>、<code>RW_REALIZING</code>位；</li><li>根据<code>class_ro_t</code>的<code>RO_META</code>位的值，配置<code>class_rw_t</code>的<code>version</code>；</li><li>因为静态载入的父类、元类有可能被重映射，因此要保证类的父类、元类完成class realizing；</li><li>配置<code>class_rw_t</code>的<code>superclass</code>；</li><li>初始化<code>objc_class</code>的<code>isa</code>指针；</li><li>配置<code>ivarLayout</code>、<code>instanceSize</code>、<code>instanceStart</code>。该步骤非常重要，新版本 runtime 支持 non-fragile instance variables，类的<code>instanceStart</code>、<code>instanceSize</code>会根据父类的<code>instanceSize</code>动态调整，且需要按 WORD 对齐（TODO：后续在独立的文章中详细介绍）；</li><li>配置<code>class_rw_t</code>的<code>RO_HAS_CXX_STRUCTORS</code>、<code>RO_HAS_CXX_DTOR_ONLY</code>、<code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>；</li><li>添加子类/根类；</li><li>将<code>class_ro_t</code>中的基本方法列表、属性列表、协议列表，类的分类（category）中的方法列表等信息添加到<code>class_rw_t</code>中（TODO：后续在独立的文章中详细介绍）；</li></ul><p>实现 class realizing 的代码主要在<code>static Class realizeClassWithoutSwift(Class cls)</code>函数中，只需要知道其大致过程即可。具体代码及注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* 对类 cls 执行首次初始化，包括分配其读写(read-write)数据。</span></span><br><span class="line"><span class="comment">* 不执行任何 Swift 端初始化。</span></span><br><span class="line"><span class="comment">* 返回类的真实类结构(real class structure)</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">realizeClassWithoutSwift</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        <span class="built_in">validateAlreadyRealizedClass</span>(cls);</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ASSERT</span>(cls == <span class="built_in">remapClass</span>(cls));  <span class="comment">// // 传入的类必须存在于remappedClasses全局哈希表中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 曾经是 a future class. 所以 rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">        ro = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">ro</span>();  <span class="comment">// cls的rw指向class_rw_t结构体，ro指向class_ro_t结构体，维持原状</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(!isMeta);</span><br><span class="line">        cls-&gt;<span class="built_in">changeInfo</span>(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常类(Normal class). 需要为rw分配内存，并将ro指针指向 传入的cls-&gt;data()所指向的内存空间</span></span><br><span class="line">        rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">        rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;<span class="built_in">setData</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cls-&gt;cache.<span class="built_in">initializeToEmptyOrPreoptimizedInDisguise</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_CACHE_META</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) cls-&gt;cache.<span class="built_in">setBit</span>(FAST_CACHE_META);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose an index for this class.</span></span><br><span class="line">    <span class="comment">// Sets cls-&gt;instancesRequireRawIsa if indexes no more indexes are available</span></span><br><span class="line">    cls-&gt;<span class="built_in">chooseClassArrayIndex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现父类和元类，如果它们还没有实现。</span></span><br><span class="line">    <span class="comment">//   对于根类，这需要在上面设置RW_REALIZED之后完成。</span></span><br><span class="line">    <span class="comment">//   对于根元类，这需要在选择类索引之后完成。</span></span><br><span class="line">    <span class="comment">// (假设这些类都没有 Swift 内容，或者 Swift 的初始化程序(initializers)已经被调用)</span></span><br><span class="line">    <span class="comment">// (如果我们添加对 Swift 类的 ObjC 子类的支持，请修复这个假设是错误的。)</span></span><br><span class="line">    supercls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">getSuperclass</span>()), nil); <span class="comment">// 父类 realizing</span></span><br><span class="line">    metacls = <span class="built_in">realizeClassWithoutSwift</span>(<span class="built_in">remapClass</span>(cls-&gt;<span class="built_in">ISA</span>()), nil);  <span class="comment">// 元类 realizing</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">        <span class="comment">// 元类不需要来自non pointer ISA 的任何特性</span></span><br><span class="line">        <span class="comment">// 这允许在objc_retain/objc_release中为类提供一个faspath。</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsa</span>(); <span class="comment">// 配置RW_REQUIRES_RAW_ISA位。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 为一些类或平台禁用 non-pointer isa</span></span><br><span class="line">        <span class="keyword">bool</span> instancesRequireRawIsa = cls-&gt;<span class="built_in">instancesRequireRawIsa</span>();</span><br><span class="line">        <span class="keyword">bool</span> rawIsaIsInherited = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">bool</span> hackedDispatch = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableNonpointerIsa) &#123;</span><br><span class="line">            <span class="comment">// Non-pointer isa disabled by environment or app SDK version</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hackedDispatch  &amp;&amp;  <span class="number">0</span> == <span class="built_in">strcmp</span>(ro-&gt;<span class="built_in">getName</span>(), <span class="string">&quot;OS_object&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// hack for libdispatch et al - isa also acts as vtable pointer</span></span><br><span class="line">            hackedDispatch = <span class="literal">true</span>;</span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (supercls  &amp;&amp;  supercls-&gt;<span class="built_in">getSuperclass</span>()  &amp;&amp;</span><br><span class="line">                 supercls-&gt;<span class="built_in">instancesRequireRawIsa</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这也是通过addSubclass()传播的</span></span><br><span class="line">            <span class="comment">// 但是 nonpointer isa 设置需要更早.</span></span><br><span class="line">            <span class="comment">// 特殊情况：instancerequirerawisa不从根类传播到根元类</span></span><br><span class="line">            instancesRequireRawIsa = <span class="literal">true</span>;</span><br><span class="line">            rawIsaIsInherited = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 配置RW_REQUIRES_RAW_ISA位</span></span><br><span class="line">        <span class="keyword">if</span> (instancesRequireRawIsa) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(rawIsaIsInherited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于存在class remapping的可能性，因此需要更新父类及元类</span></span><br><span class="line">    cls-&gt;<span class="built_in">setSuperclass</span>(supercls);</span><br><span class="line">    cls-&gt;<span class="built_in">initClassIsa</span>(metacls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整ivarLayout —— Reconcile(协调) instance variable offsets / layout</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) <span class="built_in">reconcileInstanceVariables</span>(cls, supercls, ro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整instanceSize —— Set fastInstanceSize if it wasn&#x27;t set already.</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInstanceSize</span>(ro-&gt;instanceSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123;</span><br><span class="line">        cls-&gt;<span class="built_in">setHasCxxDtor</span>();</span><br><span class="line">        <span class="keyword">if</span> (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123;</span><br><span class="line">            cls-&gt;<span class="built_in">setHasCxxCtor</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 ro 或从父类传播关联对象禁止标志。</span></span><br><span class="line">    <span class="keyword">if</span> ((ro-&gt;flags &amp; RO_FORBIDS_ASSOCIATED_OBJECTS) ||</span><br><span class="line">        (supercls &amp;&amp; supercls-&gt;forbidsAssociatedObjects()))</span><br><span class="line">    &#123;</span><br><span class="line">        rw-&gt;flags |= RW_FORBIDS_ASSOCIATED_OBJECTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将此类连接到其父类的子类列表</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        <span class="built_in">addSubclass</span>(supercls, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addRootClass</span>(cls);  <span class="comment">// 添加父类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rw中需要保存ro中的一些数据，例如ro中的基础方法列表、属性列表、协议列表</span></span><br><span class="line">    <span class="comment">// rw还需要载入分类的方法列表</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    <span class="built_in">methodizeClass</span>(cls, previously);  <span class="comment">// methodize: vt. 使…有条理；为…定顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-methodizeClass"><a href="#2-methodizeClass" class="headerlink" title="2) methodizeClass"></a>2) methodizeClass</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* methodizeClass</span></span><br><span class="line"><span class="comment">* Fixes up cls&#x27;s method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Attaches any outstanding categories.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodizeClass</span><span class="params">(Class cls, Class previously)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> ro = rw-&gt;<span class="built_in">ro</span>();</span><br><span class="line">    <span class="keyword">auto</span> rwe = rw-&gt;<span class="built_in">ext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装类自己实现的方法和属性。Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 将ro中的基本方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *list = ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, &amp;list, <span class="number">1</span>, YES, <span class="built_in">isBundleClass</span>(cls), <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (rwe) rwe-&gt;methods.<span class="built_in">attachLists</span>(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的属性列表添加到rw的属性列表中</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; proplist) &#123;</span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将ro中的协议列表添加到rw的协议列表中</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (rwe &amp;&amp; protolist) &#123;</span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类特殊处理。</span></span><br><span class="line">    <span class="comment">// 根类可以获得额外的方法实现(如果它们还没有的话). 这些适用于类别替换(category replacements)之前。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRootMetaclass</span>()) &#123;</span><br><span class="line">        <span class="built_in">addMethod</span>(cls, @<span class="built_in">selector</span>(initialize), (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories. 将分类中的方法列表添加到rw的方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (previously) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) &#123;</span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_METACLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当类重定位时，带有类方法的类别categories可能会注册在类本身而不是元类metaclass上。告诉attachToClass去查找这些。</span></span><br><span class="line">            objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, previously,</span><br><span class="line">                                                     ATTACH_CLASS_AND_METACLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    objc::unattachedCategories.<span class="built_in">attachToClass</span>(cls, cls,</span><br><span class="line">                                             isMeta ? ATTACH_METACLASS : ATTACH_CLASS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-处理没有使用的类"><a href="#9-处理没有使用的类" class="headerlink" title="9. 处理没有使用的类"></a>9. 处理没有使用的类</h4><p>第一次启动时并不会执行，我们也可以看到 <code>resolvedFutureClasses</code> 中并没有记录到需要执行 <code>realizeClassWithoutSwift</code> 的类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize newly-resolved future classes, in case CF manipulates them</span></span><br><span class="line"><span class="comment">// 实现 newly-resolved future classes，以防 CF 操作它们</span></span><br><span class="line"><span class="keyword">if</span> (resolvedFutureClasses) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resolvedFutureClassCount; i++) &#123;</span><br><span class="line">        Class cls = resolvedFutureClasses[i];</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class is not allowed to be future&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现类</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将此类及其所有子类标记为需要原始 isa 指针</span></span><br><span class="line">        cls-&gt;<span class="built_in">setInstancesRequireRawIsaRecursively</span>(<span class="literal">false</span><span class="comment">/*inherited*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(resolvedFutureClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc[56474]: 0.00 ms: IMAGE TIMES: realize future classes</span></span><br><span class="line"><span class="comment">// 打印时间为 0.00 毫秒</span></span><br><span class="line">ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: realize future classes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( DebugNonFragileIvars, OBJC_DEBUG_NONFRAGILE_IVARS, &quot;capriciously rearrange non-fragile ivars&quot;)</span></span><br><span class="line"><span class="comment">//（反复无常地重新排列非脆弱的 ivars）</span></span><br><span class="line"><span class="comment">// 如果开启了 OBJC_DEBUG_NONFRAGILE_IVARS 这个环境变量，则会执行 realizeAllClasses() 函数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-lazily realizes 所有已知 image 中所有未实现的类。(即对已知的 image 中的所有类：懒加载和非懒加载类全部进行实现)</span></span><br><span class="line"><span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">    <span class="built_in">realizeAllClasses</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print preoptimization statistics</span></span><br><span class="line"><span class="comment">// 打印预优化统计信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTION( PrintPreopt, OBJC_PRINT_PREOPTIMIZATION, &quot;log preoptimization courtesy of dyld shared cache&quot;)</span></span><br><span class="line"><span class="comment">// 日志预优化由 dyld shared cache 提供</span></span><br></pre></td></tr></table></figure><h4 id="10-log输出"><a href="#10-log输出" class="headerlink" title="10. log输出"></a>10. log输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (PrintPreopt) &#123;</span><br><span class="line">        <span class="comment">// 一些 log 输出...</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EACH_HEADER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、load-images"><a href="#四、load-images" class="headerlink" title="四、load_images()"></a>四、load_images()</h2><h3 id="4-1-load-images-源码实现"><a href="#4-1-load-images-源码实现" class="headerlink" title="4.1 load_images()源码实现"></a>4.1 load_images()源码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 处理 dyld 映射的 images 中的 +load </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// didInitialAttachCategories 标记加载分类的，默认值为 false，</span></span><br><span class="line">    <span class="comment">// didCallDyldNotifyRegister 标记 _dyld_objc_notify_register 是否调用完成</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">loadAllCategories</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 mh 中不包含 +load 就直接不加锁 return（且 without taking locks）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hasLoadMethods 函数是根据 `headerType *mhdr` 的 `__objc_nlclslist` 区和 `__objc_nlcatlist` 区中是否有数据，来判断是否有 +load 函数要执行。(即是否包含非懒加载类和非懒加载分类) </span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loadMethodLock 是一把递归互斥锁（加锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现(Discover) +load 方法</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// runtimeLock 加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有要调用的 +load 方法(Class、SuperClass、Category中的)</span></span><br><span class="line">        <span class="built_in">prepare_load_methods</span>((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 调用获取到的所有 +load 方法：从调用中，可以看到依次调用父类、子类、分类的load方法</span></span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-loadAllCategories-分类加载"><a href="#4-2-loadAllCategories-分类加载" class="headerlink" title="4.2 loadAllCategories() 分类加载"></a>4.2 loadAllCategories() 分类加载</h3><h4 id="4-2-1-loadAllCategories"><a href="#4-2-1-loadAllCategories" class="headerlink" title="4.2.1 loadAllCategories()"></a>4.2.1 loadAllCategories()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAllCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-load-categories-nolock"><a href="#4-2-2-load-categories-nolock" class="headerlink" title="4.2.2 load_categories_nolock()"></a>4.2.2 load_categories_nolock()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            <span class="keyword">locstamped_category_t</span> lc&#123;cat, hi&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Ignore the category.</span></span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category.</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;<span class="built_in">isStubClass</span>()) &#123;</span><br><span class="line">                <span class="comment">// Stub(桩) classes永远不会实现(realized)。Stub classes在初始化之前不知道它们的元类，因此我们必须将带</span></span><br><span class="line">                <span class="comment">// 有类方法或属性的类别添加到Stub classes本身。methodizeClass() 将找到它们并将它们适当地添加到元类中。</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    cat-&gt;instanceProperties ||</span><br><span class="line">                    cat-&gt;classMethods ||</span><br><span class="line">                    cat-&gt;protocols ||</span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 首先，将category注册到其目标类(target class)。</span></span><br><span class="line">                <span class="comment">// 然后，如果class is realized，则重建类的方法列表（等）。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，实例方法、协议、属性添加到类.</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;instanceMethods ||  </span><br><span class="line">                    cat-&gt;protocols ||  </span><br><span class="line">                    cat-&gt;instanceProperties)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, ATTACH_EXISTING);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把分类中的，类方法、协议添加到元类</span></span><br><span class="line">                <span class="keyword">if</span> (cat-&gt;classMethods  ||  </span><br><span class="line">                    cat-&gt;protocols  ||  </span><br><span class="line">                    (hasClassProperties &amp;&amp; cat-&gt;_classProperties))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                        <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 对应</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;);</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2CategoryList2, category_t * const, &quot;__objc_catlist2&quot;);</span></span><br><span class="line">    <span class="comment">// _getObjc2CategoryList 取得 DATA 段 &quot;__objc_catlist&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">    <span class="comment">// _getObjc2CategoryList2 取得 DATA 段 &quot;__objc_catlist2&quot; section 中的 category 数据</span></span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist2</span>(&amp;count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-attachCategories"><a href="#4-2-3-attachCategories" class="headerlink" title="4.2.3 attachCategories()"></a>4.2.3 attachCategories()</h4><ul><li><p>把所有Category的方法、属性、协议数据，合并到一个大数组中。后面参与编译的Category数据，会在数组的前面。</p></li><li><p>将合并后的分类数据(方法、属性、协议)，插入到类原来数据的前面。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将方法列表、属性和协议从categories附加到class。</span></span><br><span class="line"><span class="comment">// 假设cats_list中的所有categories都已加载，并按加载顺序排序，最老的类别优先。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">attachCategories</span>(Class cls, <span class="keyword">const</span> <span class="keyword">locstamped_category_t</span> *cats_list, <span class="keyword">uint32_t</span> cats_count, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintReplacedMethods)) &#123;</span><br><span class="line">        <span class="built_in">printReplacements</span>(cls, cats_list, cats_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(PrintConnecting)) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: attaching %d categories to%s class &#x27;%s&#x27;%s&quot;</span>,</span><br><span class="line">                     cats_count, (flags &amp; ATTACH_EXISTING) ? <span class="string">&quot; existing&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>(), (flags &amp; ATTACH_METACLASS) ? <span class="string">&quot; (meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在发布期间，只有少数类的类别超过 64 个。</span></span><br><span class="line"><span class="comment"> 这使用了一个小stack，避免了 malloc。</span></span><br><span class="line"><span class="comment"> Categories 必须以正确的顺序添加，即从后到前。为了通过分块(chunking)来做到这一点，我们从前到后迭代cats_list，向后构建本地缓冲区，</span></span><br><span class="line"><span class="comment"> 并在块上调用attachLists。 attachLists将列表放在前面，因此最终结果按预期顺序排列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">method_list_t</span>   *mlists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">property_list_t</span> *proplists[ATTACH_BUFSIZ];</span><br><span class="line">    <span class="keyword">protocol_list_t</span> *protolists[ATTACH_BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                <span class="built_in">prepareMethodLists</span>(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists, mcount);</span><br><span class="line">                mcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mlists[ATTACH_BUFSIZ - ++mcount] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;<span class="built_in">isBundle</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist =</span><br><span class="line">            entry.cat-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propcount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists, propcount);</span><br><span class="line">                propcount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            proplists[ATTACH_BUFSIZ - ++propcount] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocount == ATTACH_BUFSIZ) &#123;</span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists, protocount);</span><br><span class="line">                protocount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            protolists[ATTACH_BUFSIZ - ++protocount] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">prepareMethodLists</span>(cls, mlists + ATTACH_BUFSIZ - mcount, mcount,</span><br><span class="line">                           NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(mlists + ATTACH_BUFSIZ - mcount, mcount);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; ATTACH_EXISTING) &#123;</span><br><span class="line">            <span class="built_in">flushCaches</span>(cls, __func__, [](Class c)&#123;</span><br><span class="line">                <span class="comment">// constant caches have been dealt with in prepareMethodLists</span></span><br><span class="line">                <span class="comment">// if the class still is constant here, it&#x27;s fine to keep</span></span><br><span class="line">                <span class="keyword">return</span> !c-&gt;cache.<span class="built_in">isConstantOptimizedCache</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rwe-&gt;properties.<span class="built_in">attachLists</span>(proplists + ATTACH_BUFSIZ - propcount, propcount);</span><br><span class="line"></span><br><span class="line">    rwe-&gt;protocols.<span class="built_in">attachLists</span>(protolists + ATTACH_BUFSIZ - protocount, protocount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-hasLoadMethods"><a href="#4-3-hasLoadMethods" class="headerlink" title="4.3 hasLoadMethods()"></a>4.3 hasLoadMethods()</h3><p>根据 <code>headerType *mhdr</code> 的 <code>__objc_nlclslist</code> 区和 <code>__objc_nlcatlist</code> 区中是否有数据，来判断是否有 <code>+load</code> 函数要执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick scan for +load methods that doesn&#x27;t take a lock.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 1. 首先去看类列表中，有没有load方法</span></span><br><span class="line">    <span class="comment">// 读取__DATA段(Segment)中的__objc_nlclslist区(section)中的非懒加载类的列表。判断count是否大于1，大于1说明有load方法，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 去所有的category中看，是否有load方法</span></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 读取__DATA段中的__objc_nlcatlist区中非懒加载分类的列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-prepare-load-methods"><a href="#4-3-prepare-load-methods" class="headerlink" title="4.3 prepare_load_methods()"></a>4.3 prepare_load_methods()</h3><p>获取所有要调用的 +load 方法（父类、子类、分类）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlclslist 区的数据，即获取所有非懒加载类</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23) // class +load has been called</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span></span><br><span class="line">    <span class="comment">// 需要调用 +load 的 classes 列表</span></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span></span><br><span class="line">    <span class="comment">// 用于下面 call_load_methods 函数调用 </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部会递归调用，从传入的cls依次向上查找superClass，并调用add_class_to_loadable_list方法，将实现了load方法的类的：Class cls、IMP method收集</span></span><br><span class="line">        <span class="comment">// 父类、子类都通过该方法收集出来，父类们先被收集，即先被调用</span></span><br><span class="line">        <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span></span><br><span class="line">    <span class="comment">// 获取所有 __objc_nlcatlist 区的数据，即获取所有非懒加载分类</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历这些分类</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// weak-linked class：</span></span><br><span class="line">        <span class="comment">//   如果我们在一个库中使用新版本系统的一些特性API，但又想程序可以在低版本系统上运行，这个时候对这些符号使用弱引用就好。</span></span><br><span class="line">        <span class="comment">//   使用了弱引用之后，即使在版本较旧的环境下跑，也可以运行，只是相应的符号是NULL。</span></span><br><span class="line">        <span class="comment">//   有一点需要说明的是，如果一个framework没有为新加入的符号加入弱引用，那也不必担心，我们只要在链接时弱引用(weak link)整个framework就好</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;<span class="built_in">isSwiftStable</span>()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果分类所属的类没有实现就先去实现</span></span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言</span></span><br><span class="line">        <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要调用 +load 的 categories 列表</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          static struct loadable_category *loadable_categories = nil;</span></span><br><span class="line"><span class="comment">          struct loadable_category &#123;</span></span><br><span class="line"><span class="comment">              Category cat;  // may be nil</span></span><br><span class="line"><span class="comment">              IMP method;</span></span><br><span class="line"><span class="comment">          &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历这些分类，并将Category cat、IMP method收集到 loadable_categories 数组中保存</span></span><br><span class="line">        <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-1-schedule-class-load"><a href="#4-3-1-schedule-class-load" class="headerlink" title="4.3.1 schedule_class_load"></a>4.3.1 schedule_class_load</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule_class_load 将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法。（用于后续 call_load_methods 函数调用）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span></span><br><span class="line">    <span class="built_in">ASSERT</span>(cls-&gt;<span class="built_in">isRealized</span>());  <span class="comment">// _read_images should realize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// class +load has been called</span></span><br><span class="line">    <span class="comment">// #define RW_LOADED (1&lt;&lt;23)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RW_LOADED 是 class +load 已被调用的掩码</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    <span class="comment">// 优先处理 superclass 的 +load 函数</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static struct loadable_class *loadable_classes = nil;</span></span><br><span class="line">    <span class="comment">// struct loadable_class &#123;</span></span><br><span class="line">    <span class="comment">//    Class cls;  // may be nil</span></span><br><span class="line">    <span class="comment">//    IMP method;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span></span><br><span class="line">    <span class="comment">// loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span></span><br><span class="line">    <span class="comment">// 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 RW_LOADED 设置到类的 Flags 中</span></span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class cls has just become connected. Schedule it for +load if it implements a +load method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 class 中获取 load 方法</span></span><br><span class="line">    method = cls-&gt;<span class="built_in">getLoadMethod</span>();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;<span class="built_in">nameForLogging</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 判断当前 loadable_classes 这个数组是否已经被全部占用</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 3. 在当前数组的基础上扩大数组的大小：realloc</span></span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="built_in"><span class="keyword">sizeof</span></span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 把传入的 class 以及对应的方法的实现IMP加到列表中</span></span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-call-load-methods"><a href="#4-4-call-load-methods" class="headerlink" title="4.4 call_load_methods()"></a>4.4 call_load_methods()</h3><p><code>+load</code> 函数的调用顺序：父类 -&gt; 子类 -&gt; 分类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment"> * Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment"> * Category +load methods are not called until after the parent class&#x27;s +load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="comment">// 重入调用什么都不做；最外层的调用将完成工作。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果正在 loading 则 return，</span></span><br><span class="line">    <span class="comment">// 保证当前 +load 方法同时只有一次被调用</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建自动释放池</span></span><br><span class="line">    <span class="keyword">void</span> *pool = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 不停调用类的 + load 方法</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span></span><br><span class="line">            <span class="built_in">call_class_loads</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 调用 分类中的 +load 函数， 只调用一次 call_category_loads</span></span><br><span class="line">        <span class="comment">// 因为上面的 call_class_loads 函数内部，已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，否则循环就结束了。 </span></span><br><span class="line">        more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line">    <span class="comment">// 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动释放池进行 pop</span></span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记处理完成了，可以进行下一个了</span></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-关于-load-方法的几个QA"><a href="#4-5-关于-load-方法的几个QA" class="headerlink" title="4.5 关于 +load 方法的几个QA"></a>4.5 关于 +load 方法的几个QA</h3><p>Q: +load的应用？</p><p>A: <code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p><p>由于它的调用<em>不是惰性</em>(non-lazy)的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>的绝佳时机。</p><p>因为 load 调用时机过早，并且当多个 Class 没有关联（继承与派生），我们无法知道 Class 中 load 方法的优先调用关系，所以一般不会在 load 方法中引入其他的类，这是在开发当中需要注意的。</p><p>不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p><p>Q: 重载自己 Class 的 +load 方法时需不需要调父类？</p><p>A: runtime 负责按继承顺序递归调用，所以我们不能调 super</p><p>Q: 在自己 Class 的 +load 方法时能不能替换系统 framework（比如 UIKit）中的某个类的方法实现</p><p>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p><p>Q: 重载 +load 时需要手动添加 @autoreleasepool 么？</p><p>A: 不需要，在 runtime 调用 +load 方法前后是加了 objc_autoreleasePoolPush() 和 objc_autoreleasePoolPop() 的。</p><p>Q: 想让一个类的 +load 方法被调用是否需要在某个地方 import 这个文件</p><p>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，+load 方法就会被调用（Reveal SDK 就是利用这一点，只要引入到工程中就能工作）</p><h2 id="五、类的加载过程总结"><a href="#五、类的加载过程总结" class="headerlink" title="五、类的加载过程总结"></a>五、类的加载过程总结</h2><p>类存在懒加载机制，懒加载类先标记为 future class，正式加载 future class 数据需要调用<code>readClass(...)</code>方法，对 future class 进行重映射（remapping）；</p><p>截止至完成 class realizing，类的加载过程大致如下图所示。</p><ul><li>future class列是懒加载类（future class）的流程，经过了“添加懒加载类-&gt;加载懒加载类信息-&gt;懒加载类重映射-&gt;实现懒加载类”四步；</li><li>normal class列是普通的非懒加载类的加载流程，只经过“加载类信息-&gt;实现类”两个步骤。</li></ul><img src="/images/compilelink/37.png" alt="36" style="zoom:88%;" /><p>类完成 class realizing 后，还需要执行类及分类中的<code>load()</code>方法，最后在程序运行过程中第一次调用类的方法时（实现逻辑在<code>IMP lookUpImpOrForward(...)</code>函数中）触发<code>isInitialized()</code>检查，若未初始化，则需要先执行类的<code>initialize()</code>方法。至此，类正式加载完成。</p><blockquote><p>注意：最后的 class initializing 严格意义上应该不属于类的加载过程，可以将其归为独立的类初始化阶段。类的加载在<code>load()</code>方法执行后就算是完成了。</p></blockquote><h2 id="六、unmap-images"><a href="#六、unmap-images" class="headerlink" title="六、unmap_images()"></a>六、unmap_images()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Process the given image which is about to be unmapped by dyld.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image</span>(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="built_in">unmap_image_nolock</span>(mh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-unmap-image-nolock"><a href="#6-1-unmap-image-nolock" class="headerlink" title="6.1 unmap_image_nolock()"></a>6.1 unmap_image_nolock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line"><span class="built_in">unmap_image_nolock</span>(<span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: processing 1 newly-unmapped image...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find the runtime&#x27;s header_info struct for the image</span></span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;<span class="built_in">mhdr</span>() == (<span class="keyword">const</span> headerType *)mh) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintImages) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;IMAGES: unloading image for %s%s%s\n&quot;</span>, </span><br><span class="line">                     hi-&gt;<span class="built_in">fname</span>(),</span><br><span class="line">                     hi-&gt;<span class="built_in">mhdr</span>()-&gt;filetype == MH_BUNDLE ? <span class="string">&quot; (bundle)&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">                     hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">isReplacement</span>() ? <span class="string">&quot; (replacement)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _unload_image(hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove header_info from header list</span></span><br><span class="line">    <span class="built_in">removeHeader</span>(hi);</span><br><span class="line">    <span class="built_in">free</span>(hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-unload-image"><a href="#6-2-unload-image" class="headerlink" title="6.2 _unload_image()"></a>6.2 _unload_image()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _unload_image</span></span><br><span class="line"><span class="comment">* Only handles MH_BUNDLE for now.</span></span><br><span class="line"><span class="comment">* Locking: write-lock and loadMethodLock acquired by unmap_image</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _unload_image(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.<span class="built_in">assertLocked</span>();</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload unattached categories and categories waiting for +load.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore __objc_catlist2. We don&#x27;t support unloading Swift</span></span><br><span class="line">    <span class="comment">// and we never will.</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *catlist = hi-&gt;<span class="built_in">catlist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme for MH_DYLIB cat&#x27;s class may have been unloaded already</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// unattached list</span></span><br><span class="line">        objc::unattachedCategories.<span class="built_in">eraseCategoryForClass</span>(cat, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +load queue</span></span><br><span class="line">        <span class="built_in">remove_category_from_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unload classes.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather classes from both __DATA,__objc_clslist </span></span><br><span class="line">    <span class="comment">// and __DATA,__objc_nlclslist. arclite&#x27;s hack puts a class in the latter</span></span><br><span class="line">    <span class="comment">// only, and we need to unload that class if we unload an arclite image.</span></span><br><span class="line"></span><br><span class="line">    objc::DenseSet&lt;Class&gt; classes&#123;&#125;;</span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classlist = hi-&gt;<span class="built_in">nlclslist</span>(&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (cls) classes.<span class="built_in">insert</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First detach classes from each other. Then free each class.</span></span><br><span class="line">    <span class="comment">// This avoid bugs where this loop unloads a subclass before its superclass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">remove_class_from_loadable_list</span>(cls);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls-&gt;<span class="built_in">ISA</span>(), YES);</span><br><span class="line">        <span class="built_in">detach_class</span>(cls, NO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class cls: classes) &#123;</span><br><span class="line">        <span class="built_in">free_class</span>(cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">        <span class="built_in">free_class</span>(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX FIXME -- Clean up protocols:</span></span><br><span class="line">    <span class="comment">// &lt;rdar://problem/9033191&gt; Support unloading protocols at dylib/image unload time</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme DebugUnload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903965201530888#heading-0">Runtime源代码解读2（类和对象）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前文回顾&quot;&gt;&lt;a href=&quot;#一、前文回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前文回顾&quot;&gt;&lt;/a&gt;一、前文回顾&lt;/h2&gt;&lt;p&gt;上一篇&lt;a href=&quot;https://tenloy.github.io/2021/09/27/compil</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</title>
    <link href="https://tenloy.github.io/2021/10/18/compile-dynamic-link.html"/>
    <id>https://tenloy.github.io/2021/10/18/compile-dynamic-link.html</id>
    <published>2021-10-18T04:26:09.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、动态链接"><a href="#一、动态链接" class="headerlink" title="一、动态链接"></a>一、动态链接</h2><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个个单独的可执行文件。</p><p>动态链接涉及运行时的链接及多个文件的装载，必需要有操作系统的支持，因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。目前主流的操作系统几乎都支持动态链接这种方式。</p><p>link 这个过程就是将加载进来的二进制变为可用状态的过程。简单来说就是：<code>rebase =&gt; binding</code>。先来介绍动态链接中的几个概念：</p><h3 id="1-1-rebase"><a href="#1-1-rebase" class="headerlink" title="1.1 rebase"></a>1.1 rebase</h3><p>rebase就是指针修正的过程。</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。而<strong>data</strong>段中的数据也会存在<strong>引用</strong>关系。 我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(相对于text段开始的偏移)。 </p><p>当二进制加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。 这个过程就是rebase的过程。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h3 id="1-2-bind"><a href="#1-2-bind" class="headerlink" title="1.2 bind"></a>1.2 bind</h3><blockquote><p>“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。</p></blockquote><p>bind就是符号绑定的过程。</p><p>为什么要bind? 因为符号在不同的库里面。</p><p>举个简单的例子，我们代码里面调用了 <code>NSClassFromString</code>. 但是<code>NSClassFromString</code>的代码和符号都是在 <code>Foundation.framework</code> 这个动态库里面。而在程序未加载之前，我们的代码是不知道<code>NSLog</code>在哪里的，于是编译器就编译了一个 <strong>stub</strong> 来调用 <code>NSClassFromString</code>:</p><img src="/images/compilelink/39.png" alt="39" style="zoom:97%;" /><p>可以看到，我们的代码里面直接从 pc + 0x3701c的地方取出来一个值，然后直接br， 也就是认为这个值就是 <code>NSClassFromString</code>的真实地址了。我们再看看这个位置的值是啥：</p><img src="/images/compilelink/40.png" alt="40" style="zoom:100%;" /><p>也就是说，这块地址的8个字节会在<strong>bind</strong>之后存入的就是 <code>NSClassFromString</code>的代码地址， 那么就实现了真正调用 <code>NSClassFromString</code>的过程。</p><p>上面我们知道了为啥要<strong>bind</strong>. 那是如何bind的呢？ bind又分为哪些呢？</p><h4 id="1-2-1-怎么bind"><a href="#1-2-1-怎么bind" class="headerlink" title="1.2.1 怎么bind"></a>1.2.1 怎么bind</h4><p>首先 mach-o 的 LoadCommand里面的会有一个cmd来描述 dynamic loader info，数据结构与示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下的偏移量是相对于目标文件/可执行文件的起始地址，注意后者的起始地址一般不会是0，寻址时要加上</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dyld_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmd;            <span class="comment">/* LC_DYLD_INFO or LC_DYLD_INFO_ONLY */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   cmdsize;        <span class="comment">/* sizeof(struct dyld_info_command) */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_off;     <span class="comment">/* file offset to rebase info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   rebase_size;    <span class="comment">/* size of rebase info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_off;       <span class="comment">/* file offset to binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   bind_size;      <span class="comment">/* size of binding info  */</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Some C++ programs require dyld to unique symbols so that all images in the process use the same copy of some code/data. </span></span><br><span class="line"><span class="comment">    This step is done after binding. </span></span><br><span class="line"><span class="comment">    The content of the weak_bind info is an opcode stream like the bind_info. But it is sorted alphabetically by symbol name. This enable dyld to walk all images with weak binding information in order and look for collisions. </span></span><br><span class="line"><span class="comment">    If there are no collisions, dyld does no updating. That means that some fixups are also encoded in the bind_info. </span></span><br><span class="line"><span class="comment">    For instance, all calls to &quot;operator new&quot; are first bound to libstdc++.dylib using the information in bind_info. Then if some image overrides operator new that is detected when the weak_bind information is processed and the call to operator new is then rebound.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_off;  <span class="comment">/* file offset to weak binding info   */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   weak_bind_size; <span class="comment">/* size of weak binding info  */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_off;  <span class="comment">/* file offset to lazy binding info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   lazy_bind_size; <span class="comment">/* size of lazy binding infs */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_off;     <span class="comment">/* file offset to export info */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   export_size;    <span class="comment">/* size of export infs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解析出来会得到这样的信息：</p><ul><li><code>rebase</code>：就是针对 “mach-o在加载到虚拟内存中不是固定的首地址” 这一现象做数据修正的过程。一般可执行文件在没有ASLR造成的首地址不固定的情况下，装载进虚拟地址中的首地址都是固定的，比如：Linux下一般都是<code>0x08040000</code>，Windows下一般都是<code>0x0040000</code>，Mach-O的TEXT地址在__PageZero之后的<code>0x100000000</code>地址.</li><li><code>binding</code>：就是将这个二进制调用的外部符号进行绑定的过程。 比如我们objc代码中需要使用到NSObject，即符号<code>_OBJC_CLASS_$_NSObject</code>，但是这个符号又不在我们的二进制中，在系统库 Foundation.framework中，因此就需要binding这个操作将对应关系绑定到一起。</li><li><code>lazyBinding</code>：就是在加载动态库的时候不会立即binding，当时当第一次调用这个方法的时候再实施binding。 做到的方法也很简单： 通过<code>dyld_stub_binder</code>这个符号来做。 lazy binding的方法第一次会调用到dyld_stub_binder, 然后dyld_stub_binder负责找到真实的方法，并且将地址bind到桩上，下一次就不用再bind了。</li><li><code>weakBinding</code>：OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</li></ul><img src="/images/compilelink/41.png" alt="41" style="zoom:90%;" /><p>可以看到，这里面记录了二进制data段里面哪些是 rebase信息，哪些是binding信息：</p><img src="/images/compilelink/42.png" alt="42" style="zoom:78%;" /><p>可以看到binding info的数据结构，bind的过程根据不同的opcode解析出不同的信息，在opcode为<code>BIND_OPCODE_DO_BIND</code>的时候，会执行<code>bindLocation</code>来进行bind。</p><p>截取了 bindLocation 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">ImageLoaderMachO::bindLocation</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context,...)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// do actual update</span></span><br><span class="line">    <span class="keyword">uintptr_t</span>* locationToFix = (<span class="keyword">uintptr_t</span>*)location;</span><br><span class="line">    <span class="keyword">uint32_t</span>* loc32;</span><br><span class="line">    <span class="keyword">uintptr_t</span> newValue = value+addend;</span><br><span class="line">    <span class="keyword">uint32_t</span> value32;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_POINTER:</span><br><span class="line">            <span class="comment">// test first so we don&#x27;t needless dirty pages</span></span><br><span class="line">            <span class="keyword">if</span> ( *locationToFix != newValue )</span><br><span class="line">                *locationToFix = newValue;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_ABSOLUTE32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)newValue;</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BIND_TYPE_TEXT_PCREL32:</span><br><span class="line">            loc32 = (<span class="keyword">uint32_t</span>*)locationToFix;</span><br><span class="line">            value32 = (<span class="keyword">uint32_t</span>)(newValue - (((<span class="keyword">uintptr_t</span>)locationToFix) + <span class="number">4</span>));</span><br><span class="line">            <span class="keyword">if</span> ( *loc32 != value32 )</span><br><span class="line">                *loc32 = value32;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            dyld::<span class="built_in">throwf</span>(<span class="string">&quot;bad bind type %d&quot;</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出， bind过程也不是单纯的就是把符号地址填过来就好了， 还有type和addend的逻辑。不过一般不多见，大部分都是<code>BIND_TYPE_POINTER</code>.</p><p>addend 一般用于要bind某个数组中的某个子元素时，记录这个子元素在数组的偏移。</p><h4 id="1-2-2-Lazy-Bind"><a href="#1-2-2-Lazy-Bind" class="headerlink" title="1.2.2 Lazy Bind"></a>1.2.2 Lazy Bind</h4><p>延迟加载是为了启动速度。上面看到bind的过程，发现bind的过程需要查到对应的符号再进行bind. 如果在启动的时候，所有的符号都立即bind成功，那么势必拖慢启动速度。</p><p>其实很多符号都是LazyBind的。就是第一次调用到才会真正的bind.</p><p>其实刚才截图的 <code>imp___la_symbol_ptr__objc_getClass</code> 就是一个 LazyBind 的符号。 图中的 0x10d6e8 指向了 <code>stub_helper</code> 这个section中的代码。</p><img src="/images/compilelink/43.png" alt="43" style="zoom:90%;" /><p>如上图中</p><ul><li>先取了 <code>0x10d6f0</code> 的 4个字节数据存入 w16. 这个数据其实是 lazy bind info段的偏移</li><li>然后走到 0x10d6d0, 取出 ImageLoader cache, 存入 x17</li><li>把 lazy bind info offset 和 ImageLoaderCache 存入栈上。</li><li>然后取出 dyld_stub_binder的地址，存入x16. 跳转 dyld_stub_binder</li><li>dyld_stub_binder 会根据传入的 lazy bind info的 offset来执行真正的bind. bind结束后，刚才看到的 <code>0x10d6e8</code> 这个地址就变成了 <code>NSClassFromString</code>。就完成了LazyBind的过程。</li></ul><p><code>dyld_stub_binder</code>的源码此处不再展示。</p><h4 id="1-2-3-Weak-Bind"><a href="#1-2-3-Weak-Bind" class="headerlink" title="1.2.3 Weak Bind"></a>1.2.3 Weak Bind</h4><p>OC的代码貌似不会编译出<code>Weak Bind</code>. 目前遇到的<code>Weak Bind</code>都是C++的 <code>template</code> 的方法。特点就是：Weak bind的符号每加载进来二进制都会bind到最新的符号上。比如2个动态库里面都有同样的<code>weak bind</code>符号，那么所有的的符号引用都会bind到后加载进来的那个符号上。</p><h2 id="二、库-静态库和动态库"><a href="#二、库-静态库和动态库" class="headerlink" title="二、库: 静态库和动态库"></a>二、库: 静态库和动态库</h2><p>库(Library)，是我们在开发中的重要角色，库的作用在于代码共享、模块分割以及提升良好的工程管理实践。说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p><p>为什么要用库？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件(<strong>静态库和动态库的共同点就是不会暴露内部具体的代码信息</strong>)。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p><p>根据库在使用的时候 Link 时机或者说方式(静态链接、动态链接)，库分为静态库和动态库。</p><h3 id="2-1-静态库"><a href="#2-1-静态库" class="headerlink" title="2.1 静态库"></a>2.1 静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，linux 下的.a，Mac 下的 .a .framework）。之所以叫做静态，是因为静态库在<code>链接时</code>会被完整地拷贝一份到可执行文件中(会使最终的可执行文件体积增大)。被多个程序使用就会有多份冗余拷贝。如果更新静态库，需要重新编译一次可执行文件，重新链接新的静态库。</p><h3 id="2-2-动态库"><a href="#2-2-动态库" class="headerlink" title="2.2 动态库"></a>2.2 动态库</h3><p>动态库即动态链接库。与静态库相反，动态库在编译时并不会被拷贝到可执行文件中，可执行文件中只会存储指向动态库的引用(使用了动态库的符号、及对应库的路径等)。等到程序<code>运行时</code>，动态库才会被真正加载进来，此时，先根据记录的库路径找到对应的库，再通过记录的名字符号找到绑定的地址。</p><p>动态库的优点是：</p><ul><li><strong>减少可执行文件体积</strong>：相比静态链接，动态链接在编译时不需要打进去(不需要拷贝到每个可执行文件中)，所以可执行文件的体积要小很多。</li><li><strong>代码共用</strong>：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份(因为这个原因，动态库也被称作<strong>共享库</strong>)。</li><li><strong>易于维护</strong>：使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</li></ul><p>常见的可执行文件的形式：</p><ul><li><p>Linux系统中，ELF动态链接文件被称为<strong>动态共享对象</strong>(<code>DSO，Dynamic SharedObjects</code>)，简称共享对象，一般都是以 <code>.so</code> 为扩展名的一些文件；</p></li><li><p>Windows系统中，动态链接文件被称为<strong>动态链接库</strong>(<code>Dynamical Linking Library</code>)，通常就是我们平时很常见的以 <code>.dll</code> 为扩展名的文件；</p></li><li><p>OS X 和其他 UN*X 不同，它的库不是“共享对象(.so)”，因为 OS X 和 ELF 不兼容，而且这个概念在 Mach-O 中不存在。OS 中的动态链接文件一般称为<strong>动态库</strong>文件，带有 <code>.dylib</code>、<code>.framework</code>及链接符号<code>.tbd</code>。</p><ul><li>库文件可以在 <code>/usr/lib</code> 目录下找到(这一点和其他所有的 UN*X 一样，不同的是在OS X 和 iOS 中没有/lib目录)，这些库已被设置全局可用。</li><li>我们在使用系统的.dylib动态库时，经常发现没有头文件，其实这些库的头文件都位于一个已知位置，如<code>/usr/local/include</code>、<code>/usr/include</code>等 (后者文件夹在新系统中由SDK附带了，见 <a href="https://apple.stackexchange.com/questions/372032/usr-include-missing-on-macos-catalina-with-xcode-11">/usr/include missing on macOS Catalina (with Xcode 11)</a> )。</li></ul></li><li><p>OS X 与其他 UN*X 另一点不同是：没有<code>libc</code>。开发者可能熟悉其他 UN*X 上的C运行时库(或Windows上的MSVCRT) 。但是在 OS X 上对应的库<code>/usr/lib/libc.dylib</code>只不过是指向<code>libSystem.B.dylib</code>的符号链接。</p></li><li><p>以C语言运行库为例，补充一下<strong>运行库</strong>的概念：任何一个C程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其所依赖的函数所构成的函数集合。当然，它还理应包括各种标准库函数的实现。这样的一个代码集合称之为运行时库（Runtime Library）。而C语言的运行库，即被称为C运行库（CRT）。<strong>运行库顾名思义是让程序能正常运行的一个库。</strong></p></li></ul><h3 id="2-3-两个非常重要的库-LibSystem、libobjc"><a href="#2-3-两个非常重要的库-LibSystem、libobjc" class="headerlink" title="2.3  两个非常重要的库 LibSystem、libobjc"></a>2.3  两个非常重要的库 LibSystem、libobjc</h3><p>libSystem 提供了 LibC(运行库) 的功能，还包含了在其他 UN*X 上原本由其他一些库提供的功能，列几个熟知的：</p><ul><li>GCD libdispatch</li><li>C语言库 libsystem_c</li><li>Block libsystem_blocks</li><li>加密库(比如常见的md5函数) libcommonCrypto</li></ul><p>还有些库(如数学库 libm、线程库 libpthread)虽然在/usr/lib中看到虽然有这些库的文件，但都是libSystem.B.dylib的替身/快捷方式，即都是指向libSystem的符号链接。</p><p>libSystem 库是系统上所有二进制代码的绝对先决条件，即所有的二进制文件都依赖这个库，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。这个库还是/usr/ib/system目录下一些库的保护伞库(通过<code>LC_REEXPORT_LIB</code>加载命令重新导出了符号) 。</p><p>总结来说：<strong>libSystem在运行库的基础上，增加了一些对底层系统调用和内核服务的抽象接口。</strong>所以在下面的流程中，会发现<strong>libSystem是先于其他动态库初始化</strong>的。</p><p><strong>libobjc</strong>与libsystem一样，都是默认添加的lib，包含iOS开发天天接触的objc runtime.</p><h3 id="2-4-补充两个概念-模块与image"><a href="#2-4-补充两个概念-模块与image" class="headerlink" title="2.4 补充两个概念: 模块与image"></a>2.4 补充两个概念: 模块与image</h3><ul><li><code>程序模块</code>：从本质上讲，普通可执行程序和动态库中都包含指令和数据，这一点没有区别。在使用动态库的情况下，程序本身被分为了程序主要模块(<code>Program1</code>)和动态链接文件(<code>Lib.so</code> <code>Lib.dylib</code> <code>Lib.dll</code>)，但实际上它们都可以看作是整个程序的一个模块，所以当我们提到程序模块时可以指程序主模块也可以指动态链接库。</li><li><code>映像(image)</code> ，通常也是指这两者。可执行文件/动态链接文件，在装载时被直接映射到进程的虚拟地址空间中运行，它是进程的虚拟空间的映像，所以很多时候，也被叫做映像/镜像文件(Image File)。</li></ul><h3 id="2-5-a-dylib与-framework的区别"><a href="#2-5-a-dylib与-framework的区别" class="headerlink" title="2.5 .a/.dylib与.framework的区别"></a>2.5 .a/.dylib与.framework的区别</h3><p>前者是纯二进制文件，文件不能直接使用，需要有.h文件的配合，后者除了二进制文件、头文件还有资源文件，代码可以直接导入使用(<code>.a + .h + sourceFile = .framework</code>)。</p><p>Framework 是苹果公司的 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件（nib/xib、图片、国际化文本）、说明文档等集中在一起，方便开发者使用。<strong>Framework 其实是资源打包的方式，和静态库动态库的本质是没有什么关系</strong>(<strong>所以framework文件可以是静态库也可以是动态库，iOS 中用到的所有系统 framework 都是动态链接的</strong>)。</p><p>在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。但是iOS平台在 iOS 8 之前，苹果不允许第三方框架使用动态方式加载，开发者可以使用的动态 Framework 只有苹果系统提供的 UIKit.Framework，Foundation.Framework 等。开发者要进行模块化，只能打包成静态库文件：<code>.a + 头文件</code>、<code>.framework</code>(这时候的 Framework 只支持打包成静态库的 Framework)，前种方式打包不够方便，使用时也比较麻烦，没有后者的便捷性。</p><p>iOS 8/Xcode 6 推出之后，允许开发者有条件地创建和使用动态库，支持了动态 Framework。开发者打包的动态 Framework 和系统的 UIKit.Framework 还是有很大区别。后者不需要拷贝到目标程序中，是一个链接。而前者在打包和提交 app 时会<strong>被放到 app  main bundle 的根目录中，运行在沙盒里</strong>，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载，因此苹果又把这种 Framework 称为 Embedded Framework(可植入性 Framework)。</p><p>不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主app和插件之间共享动态库还是可行的。</p><p>数量上，苹果公司建议最多使用6个非系统动态库。</p><p>然后就是，在上传App Store打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有Embedded 的动态库，所以如果是动态从服务器更新的动态库，是签名不了的，sandbox验证动态库的签名非法时，就会造成crash。因此应用插件化、软件版本实时模块升级等功能在iOS上无法实现。不过在 in house(企业发布) 包和develop 包中可以使用。</p><h2 id="三、Mach-O-文件的动态链接-—-dyld"><a href="#三、Mach-O-文件的动态链接-—-dyld" class="headerlink" title="三、Mach-O 文件的动态链接 — dyld"></a>三、Mach-O 文件的动态链接 — dyld</h2><h3 id="3-1-dyld2与dyld3"><a href="#3-1-dyld2与dyld3" class="headerlink" title="3.1 dyld2与dyld3"></a>3.1 dyld2与dyld3</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。</p></blockquote><p>在2017WWDC，Apple推出了Dyld3。在iOS 13系统中，iOS全面采用新的dyld 3以替代之前版本的dyld 2。dyld 3带来了可观的性能提升，减少了APP的启动时间。</p><p>Dyld2是从程序开始时才开始执行的，而Dyld3则将Dyld2的一些过程进行了分解。</p><img src="/images/compilelink/44.png" alt="44" style="zoom:60%;" /><p>Dyld3最大的特点是部分进程外的，分为out-of-process，和in-process。即操作系统在当前app进程之外完成了一部分dyld2在进程内的工作。以达到提升app启动性能和增强安全的目的。</p><p>out-process会做：</p><ul><li>分析Mach-O Headers</li><li>分析以来的动态库</li><li>查找需要的Rebase和Bind的符号</li><li>将上面的分析结果写入缓存。</li></ul><p>in-process会做：</p><ul><li>读取缓存的分析结果</li><li>验证分析结果</li><li>加载Mach-O文件</li><li>Rebase&amp;Bind</li><li>Initializers</li></ul><p>使用了Dyld3后，App的启动速度会进一步提高。</p><p>而WWDC2019 苹果宣布针对Dyld3做了以下优化：</p><ul><li><strong>避免链接无用的framework；</strong></li><li><strong>避免在app启动时链接动态库；</strong></li><li><strong>硬链接所有依赖项</strong></li></ul><h3 id="3-2-dyld的工作机制"><a href="#3-2-dyld的工作机制" class="headerlink" title="3.2 dyld的工作机制"></a>3.2 dyld的工作机制</h3><p>在<a href="https://www.jianshu.com/p/bff19e0a80d4">Mach-O 文件的装载</a>完成，即内核加载器做完相关的工作后，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DYLINKER</code>加载命令指定的动态链接器在用户态完成的。通常情况下，使用的是 <code>/usr/lib/dyld</code> 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。</p><p>链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。</p><blockquote><p>dyld是一个用户态的进程。dyld不属于内核的一部分，而是作为一个单独的开源项目由苹果进行维护的(当然也属于Darwin的一部分) ，点击查看<a href="http://www.opensource.apple.com/source/dyld">项目网址</a>。从内核的角度看，dyld是一个可插入的组件，可以替换为第三方的链接器。dyld对应的二进制文件有两个，分别是<code>/usr/lib/dyld</code>、<code>/urs/lib/system/libdyld.dylib</code>，前者<code>通用二进制格式(FAT)</code>，filetype为<code>MH_DYLINKER</code>，后者是普通的动态链接库格式(Mach-O)。</p></blockquote><img src="/images/compilelink/30.png" style="zoom:80%;" /><p>从调用堆栈上看dyld、libdyld.dylib的作用：</p><img src="/images/compilelink/31.png" style="zoom:90%;" /><p>前者<code>dyld</code>是<strong>一段可执行的程序</strong>，内核将其映射至进程地址空间，将控制权交给它进行执行，递归加载所需的动态库，其中也会将动态链接器的另一种形式的<code>libdyld.dylib</code>加载，因为动态链接器dyld其不但在应用的装载阶段起作用，在主程序运行的时候，其充当<strong>一个库</strong>的角色，还提供了<code>dlopen</code>、<code>dlsym</code>等api，可以让主程序<strong>显式运行时链接</strong>(见下文)。(关于这一点，没有找到明确的文档说明。如果有人有正确的理解，请一定要评论区告诉我一下，感激不尽)</p><blockquote><p>Linux中，动态链接库的存在形式稍有不同，Linux动态链接器本身是一个共享对象(动态库)，它的路径是/lib/ld-linux.so.2，这实际上是个软链接，它指向/lib/ld-x.y.z.so， 这个才是真正的动态连接器文件。共享对象其实也是ELF文件，它也有跟可执行文件一样的ELF文件头（包括e_entry、段表等）。动态链接器是个非常特殊的共享对象，它不仅是个共享对象，还是个可执行的程序，可以直接在命令行下面运行。因为ld.so是共享对象，又是动态链接器，所以本来应由动态链接器进行的共享对象的重定位，就要靠自己来，又称“自举”。自举完成后ld.so以一个共享对象的角色，来实现动态链接库的功能。</p></blockquote><p>我们需要了解一下<code>LC_LOAD_DYLIB</code>这个加载命令，这个命令会告诉链接器在哪里可以找到这些符号，即动态库的相关信息(ID、时间戳、版本号、兼容版本号等)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span> <span class="title">name</span>;</span>              <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;             <span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;       <span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version; <span class="comment">/* library&#x27;s compatibility vers number */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;         <span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;     <span class="comment">/* includes pathname string */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> <span class="title">dylib</span>;</span>   <span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接器要加载每一个指定的库，并且搜寻匹配的符号。每个被链接的库(Mach-O格式)都有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过<code>LC_SYMTAB</code>加载命令指定的 symoff 找到。对应的符号名称在 stroff， 总共有 nsyms 条符号信息。</p><p>下面是<code>LC_SYMTAB</code>的load_command：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 &lt;mach-o/dyld.h&gt; 动态库头文件中，也为我们提供了查询所有动态库 image 的方法(也可以使用<code>otool -L 文件路径</code>命令来查看，但看着没代码全)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listImages</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint32_t</span> ic = _dyld_image_count();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Got %d images\n&quot;</span>, ic);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic; ++ i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %p\t%s\t(slide: %p)\n&quot;</span>,</span><br><span class="line">               i,</span><br><span class="line">               _dyld_get_image_header(i),</span><br><span class="line">               _dyld_get_image_name(i),</span><br><span class="line">               _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listImages();  <span class="comment">//调用方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>: </span><br><span class="line">  ...</span><br><span class="line">  <span class="number">45</span>: <span class="number">0x1ab331000</span>/usr/lib/libobjc.A.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  <span class="number">46</span>: <span class="number">0x1e1767000</span>/usr/lib/libSystem.B.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br><span class="line">  <span class="number">70</span>: <span class="number">0x107220000</span>/usr/lib/system/introspection/libdispatch.dylib(slide: <span class="number">0x107220000</span>)</span><br><span class="line">  <span class="number">71</span>: <span class="number">0x1ab412000</span>/usr/lib/system/libdyld.dylib(slide: <span class="number">0x2b1b8000</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h2 id="四、dyld工作流程详解"><a href="#四、dyld工作流程详解" class="headerlink" title="四、dyld工作流程详解"></a>四、dyld工作流程详解</h2><p>通过源码来看一下dyld的工作流程，只是部分片段，详细的可以下载源码。</p><h3 id="4-1-dyld-start"><a href="#4-1-dyld-start" class="headerlink" title="4.1 __dyld_start"></a>4.1 __dyld_start</h3><p>下面的汇编代码很简单，如果不清楚，可以看一下这篇汇编入门文章<a href="https://www.jianshu.com/p/23a9110cff96">iOS需要了解的ARM64汇编</a>。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#if __arm64__</span></span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.align</span> <span class="number">2</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line"><span class="symbol">__dyld_start:</span></span><br><span class="line"><span class="comment">; 操作fp栈帧寄存器，sp栈指针寄存器，配置函数栈帧</span></span><br><span class="line"><span class="keyword">mov</span> x28, <span class="built_in">sp</span></span><br><span class="line"><span class="keyword">and</span>     <span class="built_in">sp</span>, x28, #~<span class="number">15</span><span class="comment">// force 16-byte alignment of stack</span></span><br><span class="line"><span class="keyword">mov</span>x0, <span class="number">#0</span></span><br><span class="line"><span class="keyword">mov</span>x1, <span class="number">#0</span></span><br><span class="line">stpx1, x0, [<span class="built_in">sp</span>, #-<span class="number">16</span>]!<span class="comment">// make aligned terminating frame</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">fp</span>, <span class="built_in">sp</span><span class="comment">// set up fp to point to terminating frame</span></span><br><span class="line"><span class="keyword">sub</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">// make room for local variables</span></span><br><span class="line"><span class="comment">; L(long 64位) P(point)，在前面的汇编一文中，我们已经知道：r0 - r30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 </span></span><br><span class="line"><span class="comment">; 当使用 x0 - x30访问时，它就是一个64位的数。</span></span><br><span class="line"><span class="comment">; 当使用 w0 - w30访问时，访问的是这些寄存器的低32位</span></span><br><span class="line"><span class="comment">#if __LP64__       </span></span><br><span class="line"><span class="keyword">ldr</span>     x0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     x1, [x28, <span class="number">#8</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     x2, x28, <span class="number">#16</span>            <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="keyword">ldr</span>     w0, [x28]               <span class="comment">// get app&#x27;s mh into x0</span></span><br><span class="line"><span class="keyword">ldr</span>     w1, [x28, <span class="number">#4</span>]           <span class="comment">// get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span></span><br><span class="line"><span class="keyword">add</span>     w2, w28, <span class="number">#8</span>             <span class="comment">// get argv into x2</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="keyword">adrp</span>x3,___dso_handle<span class="comment">@page</span></span><br><span class="line"><span class="keyword">add</span> x3,x3,___dso_handle<span class="comment">@pageoff // get dyld&#x27;s mh in to x4</span></span><br><span class="line"><span class="keyword">mov</span>x4,<span class="built_in">sp</span>                   <span class="comment">// x5 has &amp;startGlue</span></span><br><span class="line"><span class="comment">; 从上面的汇编代码可以看到，主要是在设置dyldbootstrap::start函数调用栈的配置，在前面的汇编一文中，我们已经知道函数的参数，主要通过x0-x7几个寄存器来传递</span></span><br><span class="line"><span class="comment">; 可以看到函数需要的几个参数app_mh，argc，argv，dyld_mh，&amp;startGlue分别被放置到了x0 x1 x2 x4 x5寄存器上</span></span><br><span class="line">    <span class="comment">; call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line"><span class="keyword">bl</span>__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line"><span class="keyword">mov</span>x16,x0                  <span class="comment">// save entry point address in x16</span></span><br></pre></td></tr></table></figure><h3 id="4-2-dyldbootstrap-start"><a href="#4-2-dyldbootstrap-start" class="headerlink" title="4.2 dyldbootstrap::start()"></a>4.2 dyldbootstrap::start()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//  主要做的是dyld的引导工作，一般这个工作通常由 dyld 和 crt(C运行时库 C Run-Time Libray )来完成。但dyld自身加载的时候，只能由自己来做。</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果有slide，那么需要重定位，必须在使用任何全局变量之前，进行该操作</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader); </span><br><span class="line">    <span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">    ++apple;</span><br><span class="line">    <span class="comment">// 为stack canary设置一个随机值</span></span><br><span class="line">    <span class="comment">// stack canary：栈的警惕标志(stack canary)，得名于煤矿里的金丝雀，用于探测该灾难的发生。具体办法是在栈的返回地址的存储位置之前放置一个整形值，该值在装入程序时随机确定。栈缓冲区攻击时从低地址向高地址覆盖栈空间，因此会在覆盖返回地址之前就覆盖了警惕标志。返回返回前会检查该警惕标志是否被篡改。</span></span><br><span class="line">    __guard_setup(apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">    <span class="comment">// 执行 dyld 中所有的C++初始化函数。run all C++ initializers inside dyld</span></span><br><span class="line">    runDyldInitializers(argc, argv, envp, apple);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 完成所有引导工作，调用dyld::main(). now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">    <span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-dyld-main"><a href="#4-3-dyld-main" class="headerlink" title="4.3 dyld::_main()"></a>4.3 dyld::_main()</h3><p>dyld也是Mach-O文件格式的，文件头中的 filetype 字段为<code>MH_DYLINKER</code>，区别与可执行文件的 <code>MH_EXECUTE</code>，所以dyld也是有main()函数的(默认名称是mian()，也可以自己修改入口地址的)。</p><p>因为这个函数太长，写在一起不好阅读，所以按照流程功能点，自上而下分为一个个代码片段。关键的函数会在代码中注释说明</p><h4 id="方法名及说明"><a href="#方法名及说明" class="headerlink" title="方法名及说明"></a>方法名及说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld的入口指针，内核加载dyld，跳转到__dyld_start函数：进行了一些寄存器设置，然后就调用了该函数。Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">// 返回主程序模块的mian()函数地址，__dyld_start中会跳到该地址。Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h4 id="第一步-配置上下文信息，设置运行环境，处理环境变量"><a href="#第一步-配置上下文信息，设置运行环境，处理环境变量" class="headerlink" title="第一步 配置上下文信息，设置运行环境，处理环境变量"></a>第一步 配置上下文信息，设置运行环境，处理环境变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第一步，设置运行环境</span></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">hexToBytes</span>(_simple_getenv(apple, <span class="string">&quot;executable_cdhash&quot;</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序的hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace dyld&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">&quot;dyld_file&quot;</span>));</span><br><span class="line"><span class="comment">// Trace the main executable&#x27;s load</span></span><br><span class="line"><span class="built_in">notifyKernelAboutImage</span>(mainExecutableMH, _simple_getenv(apple, <span class="string">&quot;executable_file&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取主程序的macho_header结构</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// 获取主程序的slide值</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">    ......</span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch started&quot;</span>);</span><br><span class="line"><span class="comment">// 传入Mach-O头部以及一些参数设置上下文信息</span></span><br><span class="line"><span class="built_in">setContext</span>(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">getcwd</span>(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 获取进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式</span></span><br><span class="line">    <span class="built_in">configureProcessRestrictions</span>(mainExecutableMH, envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 检测环境变量</span></span><br><span class="line"><span class="built_in">checkEnvironmentVariables</span>(envp);</span><br><span class="line"><span class="comment">// 在DYLD_FALLBACK为空时设置默认值</span></span><br><span class="line"><span class="built_in">defaultUninitializedFallbackPaths</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS则调用printOptions()打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line"><span class="built_in">printOptions</span>(argv);</span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV则调用printEnvironmentVariables()打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line"><span class="built_in">printEnvironmentVariables</span>(envp);</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">// 获取当前程序架构</span></span><br><span class="line"><span class="built_in">getHostInfo</span>(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure><h4 id="第二步-加载共享缓存"><a href="#第二步-加载共享缓存" class="headerlink" title="第二步 加载共享缓存"></a>第二步 加载共享缓存</h4><p>在iOS系统中，UIKit，Foundation等基础库是每个程序都依赖的，需要通过dyld（位于/usr/lib/dyld）一个一个加载到内存，然而如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。iOS的dyld采用了一个共享库预链接缓存，苹果从iOS 3.0开始将所有的基础库都移到了这个缓存中，合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下(OS X中是在/private/var/db/dyld目录)，按不同的架构保存分别保存着，如dyld_shared_cache_armv7。而且在OS X中还有一个辅助的.map文件，而iOS中没有。</p><p>如果在iOS上搜索大部分常见的库，比如所有二进制文件都依赖的libSystem，是搜索不到的，这个库的文件不在文件系统中，而是被缓存文件包含。关于如何从共享缓存中提取我们想看的库，可以参考链接<a href="https://www.dllhook.com/post/238.html#toc_1">dyld详解第一部分</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第二步，加载共享缓存 <span class="comment">// load shared cache</span></span></span><br><span class="line">   <span class="comment">// 检查共享缓存是否开启，iOS必须开启</span></span><br><span class="line"><span class="built_in">checkSharedRegionDisable</span>((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * mapSharedCache加载共享缓存库，其中调用loadDyldCache函数，展开loadDyldCache，有这么几种情况：</span></span><br><span class="line"><span class="comment">        * 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程）</span></span><br><span class="line"><span class="comment">        * 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide</span></span><br><span class="line"><span class="comment">        * 共享缓存不是第一次被加载，那么就不做任何处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="built_in">mapSharedCache</span>();</span><br><span class="line">&#125;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="built_in">addDyldImageToUUIDList</span>();</span><br></pre></td></tr></table></figure><h4 id="第三步-实例化主程序image"><a href="#第三步-实例化主程序image" class="headerlink" title="第三步 实例化主程序image"></a>第三步 实例化主程序image</h4><h5 id="1-源码解读"><a href="#1-源码解读" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>ImageLoader：前面已经提到image(映像文件)常见的有可执行文件、动态链接库。ImageLoader 作用是将这些文件加载进内存，且<strong>每一个文件对应一个ImageLoader实例来负责加载。</strong></p><p>从下面可以看到大概的顺序：先将动态链接的 image 递归加载，再依次进行可执行文件的链接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 展开 instantiateFromLoadedImage 函数, 可以看到主要分三步:</span></span><br><span class="line"><span class="comment"> * isCompatibleMachO()：检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line"><span class="comment"> * instantiateMainExecutable()： 就是实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line"><span class="comment"> * addImage()： 添加到 allImages中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sMainExecutable = <span class="built_in">instantiateFromLoadedImage</span>(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">gLinkContext.mainExecutableCodeSigned = <span class="built_in">hasCodeSignatureLoadCommand</span>(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line"><span class="built_in">checkVersionedPaths</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">proc_regionfilename</span>(<span class="built_in">getpid</span>(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = <span class="built_in">strdup</span>(dyldPathBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-instantiateFromLoadedImage"><a href="#2-instantiateFromLoadedImage" class="headerlink" title="2. instantiateFromLoadedImage"></a>2. instantiateFromLoadedImage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">//if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::<span class="built_in">instantiateMainExecutable</span>(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="built_in">addImage</span>(image);</span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw &quot;main executable not a known format&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中，我们大致可以看到加载有三步：</p><ul><li><code>isCompatibleMachO</code> 是检查mach-o的subtype是否是当前cpu可以支持； </li><li><code>instantiateMainExecutable</code> 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </li><li><code>addImage</code> 添加到 allImages中。</li></ul><h4 id="第四步-加载插入的动态库"><a href="#第四步-加载插入的动态库" class="headerlink" title="第四步 加载插入的动态库"></a>第四步 加载插入的动态库</h4><p>通过遍历 DYLD_INSERT_LIBRARIES 环境变量，调用 loadInsertedDylib 加载。</p><p>在三方App的Mach-O文件中通过修改DYLD_INSERT_LIBRARIES的值来加入我们自己的动态库，从而注入代码，hook别人的App。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第四步 加载插入的动态库</span></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line"><span class="built_in">loadInsertedDylib</span>(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库数量</span></span><br><span class="line">sInsertedDylibCount = sAllImages.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="第五步-链接主程序-重点link"><a href="#第五步-链接主程序-重点link" class="headerlink" title="第五步 链接主程序(重点link())"></a>第五步 链接主程序(重点link())</h4><h5 id="1-源码解读-1"><a href="#1-源码解读-1" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第五步 链接主程序</span></span><br><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line"><span class="keyword">if</span> ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line"><span class="comment">// previous link() on main executable has already adjusted its internal pointers for ASLR </span></span><br><span class="line">    <span class="comment">// work around that by rebasing by inverse amount</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">rebase</span>(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        link() 函数的递归调用函数堆栈形式</span></span><br><span class="line"><span class="comment">          ▼ ImageLoader::link() //启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line"><span class="comment">            ▼ recursiveLoadLibraries() //进行所有需求动态库的加载</span></span><br><span class="line"><span class="comment">              ▶︎ //确定所有需要的库</span></span><br><span class="line"><span class="comment">              ▼ context.loadLibrary() //来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line"><span class="comment">                ▼ load() // 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line"><span class="comment">                  ▶︎ loadPhase0() → loadPhase1() → ... → loadPhase5() → loadPhase5load() → loadPhase5open() → loadPhase6() 递归调用  //每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line"><span class="comment">                  ▼ loadPhase6() // 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="built_in">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">sMainExecutable-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line"><span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-ImageLoader-link"><a href="#2-ImageLoader-link" class="headerlink" title="2. ImageLoader::link()"></a>2. ImageLoader::link()</h5><blockquote><p>加载二进制的过程： instantiate(实例化) –&gt; addImage –&gt; link –&gt; runInitializers </p><p>其中link就是动态链接的过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t0 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">  <span class="comment">// 1. recursiveLoadLibraries 这一步就是根据 LoadCommand 中的 LC_LOAD_DYLIB 把依赖的动态库和Framework加载进来。也就是对这些动态库 instantiate 的过程。 只是动态库不会用instantiateMainExecutable方法来加载了，最终用的是 instantiateFromFile 来加载。</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveLoadLibraries</span>(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only do the loading step for preflights</span></span><br><span class="line"><span class="keyword">if</span> ( preflightOnly )</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">context.<span class="built_in">clearAllDepths</span>();</span><br><span class="line">  <span class="comment">// 2. recursiveUpdateDepth 刷新depth, 就是库依赖的层级。层级越深，depth越大。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  unsigned int ImageLoader::updateDepth(unsigned int maxDepth)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    STACK_ALLOC_ARRAY(ImageLoader*, danglingUpwards, maxDepth);</span></span><br><span class="line"><span class="comment">    unsigned int depth = this-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    for (auto&amp; danglingUpward : danglingUpwards) &#123;</span></span><br><span class="line"><span class="comment">      if ( danglingUpward-&gt;fDepth != 0)</span></span><br><span class="line"><span class="comment">        continue;</span></span><br><span class="line"><span class="comment">      danglingUpward-&gt;recursiveUpdateDepth(maxDepth, danglingUpwards);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return depth;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">updateDepth</span>(context.<span class="built_in">imageCount</span>());</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::<span class="built_in">ScopedTimer</span>(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t2 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="comment">// 3. recursiveRebase rebase的过程，recursiveRebase就会把主二进制和依赖进来的动态库全部rebase.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void ImageLoader::recursiveRebaseWithAccounting(const LinkContext&amp; context)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      this-&gt;recursiveRebase(context);</span></span><br><span class="line"><span class="comment">      vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveRebaseWithAccounting</span>(context);</span><br><span class="line">context.<span class="built_in">notifyBatch</span>(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">t3 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 4. 主二进制和依赖进来的动态库全部执行 bind</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      void ImageLoader::recursiveBindWithAccounting(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;recursiveBind(context, forceLazysBound, neverUnload, nullptr);</span></span><br><span class="line"><span class="comment">        vmAccountingSetSuspended(context, false);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveBindWithAccounting</span>(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">      <span class="comment">// 5. weakBind. 执行weakBind，这里看到如果是主二进制在link的话，是不会在这个时候执行weak bind的，在dyld::_main里面可以看到，是在link完成之后再执行的weakBind.</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">weakBind</span>(context);</span><br><span class="line">t5 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.<span class="built_in">size</span>() != <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 6. recursiveApplyInterposing. (主二进制link时候也不执行)</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveApplyInterposing</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now that all fixups are done, make __DATA_CONST segments read-only</span></span><br><span class="line"><span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t6 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.registerDOFs != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">recursiveGetDOFSections</span>(context, dofs);</span><br><span class="line">    <span class="comment">// 7. registerDOFs. 注册DTrace Object Format。DTrace(Dynamic Trace)是一个提供了 zero disable cost 的动态追踪框架，也就是说当代码中的探针关闭时，不会有额外的资源消耗 - 即使在生产版本中我们也可以将探针留在代码中。只有使用的时候才产生消耗。</span></span><br><span class="line">    <span class="comment">// DTrace 是动态的，也就是说我们可以将它附加在一个已经在运行的程序上，也可以不打断程序将它剥离。不需要重新编译或启动。</span></span><br><span class="line">context.<span class="built_in">registerDOFs</span>(dofs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint64_t</span> t7 = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear error strings</span></span><br><span class="line">(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done with initial dylib loads</span></span><br><span class="line">fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-反向依赖"><a href="#3-反向依赖" class="headerlink" title="3. 反向依赖"></a>3. 反向依赖</h5><p>每个库之间的符号并非只能单向依赖。即库与库之间是可以相互依赖符号的。</p><blockquote><p>单向依赖：即 A.dylib 依赖 B.dylib。那么B中就不能依赖A中的符号。</p></blockquote><blockquote><p>一次dyld加载进来的二进制之间可以相互依赖符号。</p></blockquote><p>原因很简单，就是因为上面看到动态链接过程中，并不是完全加载完一个被依赖的动态库，再加载下一个的。而是 recursiveLoadLibraies，recursiveRebase，recursiveBind。 所有的单步操作都会等待前一步所有的库完成。因此当 recursiveBind的时候，所有的动态库二进制已经加载进来了，符号就可以互相找了。</p><p>一次dyld的过程只会一次动态link，这次link的过程中的库符号可以互相依赖的，但是如果你通过<code>dlopen</code>、<code>-[NSBundle loadBundle]</code>的方式来延迟加载的动态库就不能反向依赖了，必须单向依赖，因为这是另外一次dyld的过程了。</p><p>反向依赖还要有个条件，条件就是符号必须存在，如果因为编译优化把符号给strip了，那就没法bind了，还是会加载失败的。</p><h4 id="第六步-链接插入的动态库"><a href="#第六步-链接插入的动态库" class="headerlink" title="第六步 链接插入的动态库"></a>第六步 链接插入的动态库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第六步 链接插入的动态库</span></span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">link</span>(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::<span class="built_in">RPathChain</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">image-&gt;<span class="built_in">setNeverUnloadRecursive</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;<span class="built_in">inSharedCache</span>() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;<span class="built_in">registerInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">sImageRoots[i]-&gt;<span class="built_in">applyInterposing</span>(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">gLinkContext.<span class="built_in">notifyBatch</span>(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;<span class="built_in">recursiveBind</span>(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第七步-弱符号绑定weakBind"><a href="#第七步-弱符号绑定weakBind" class="headerlink" title="第七步 弱符号绑定weakBind"></a>第七步 弱符号绑定weakBind</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第七步 执行弱符号绑定。weakBind: 从代码中可以看出这一步会对所有含有弱符号的镜像合并排序进行bind。OC中没发现应用场景，可能是C++的吧</span></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sMainExecutable-&gt;<span class="built_in">recursiveMakeDataReadOnly</span>(gLinkContext);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CRSetCrashLogMessage</span>(<span class="string">&quot;dyld: launch, running initializers&quot;</span>);</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h4 id="第八步-执行初始化方法initialize"><a href="#第八步-执行初始化方法initialize" class="headerlink" title="第八步 执行初始化方法initialize"></a>第八步 执行初始化方法initialize</h4><h5 id="1-源码解读-2"><a href="#1-源码解读-2" class="headerlink" title="1. 源码解读"></a>1. 源码解读</h5><p>dyld会优先初始化动态库，然后初始化主程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第八步 执行初始化方法initialize() </span></span><br><span class="line">      <span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">//attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line"><span class="comment">//与之对应的是attribute((destructor))修饰的函数, 是主程序 main() 执行之后的一些全局函数析构操作, 也是记录在一个Section __mod_term_func中.</span></span><br><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有的监视进程，本进程要进入main()函数了。 notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="built_in">notifyMonitoringDyldMain</span>();</span><br><span class="line">      <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h5 id="2-initializeMainExecutable"><a href="#2-initializeMainExecutable" class="headerlink" title="2. initializeMainExecutable()"></a>2. initializeMainExecutable()</h5><p>调用函数堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先初始化动态库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123; </span><br><span class="line">   sImageRoots[i]-&gt;<span class="built_in">runInitializers</span>(gLinkContext, initializerTimes[<span class="number">0</span>]); </span><br><span class="line">&#125;  <span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line"><span class="comment">// 再初始化可执行文件 </span></span><br><span class="line">  <span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line">▼ sMainExecutable-&gt;<span class="built_in">runInitializers</span>() </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">    ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()      <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">      ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()      <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doImageInit</span>()         <span class="comment">// 解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">        ▶︎ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">        <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">      ▼ context.<span class="built_in">notifySingle</span>(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ▶︎ (*sNotifyObjCInit)(image-&gt;<span class="built_in">getRealPath</span>(), image-&gt;<span class="built_in">machHeader</span>());</span><br><span class="line">        <span class="comment">// 通知objc, 该image已经完成初始化。objc会调用load_images()</span></span><br><span class="line">▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br></pre></td></tr></table></figure><p>在上面的<code>doImageInit</code>、<code>doModInitFunctions</code>函数中，会发现都有判断<code>libSystem</code>库是否已加载的代码，即<strong>libSystem要首先加载、初始化</strong>。在上文中，我们已经强调了这个库的重要性。之所以在这里又提到，是因为这个库也起到了将dyld与objc关联起来的作用：</p><img src="/images/compilelink/32.png" style="zoom:80%;" /><h5 id="2-dyld到objc的流程-详细见下篇"><a href="#2-dyld到objc的流程-详细见下篇" class="headerlink" title="2. dyld到objc的流程(详细见下篇)"></a>2. dyld到objc的流程(详细见下篇)</h5><p>可以从上面的调用堆栈中看到，从dyld到objc的流程：</p><ol><li><p><code>libSystem</code> 库的初始化</p></li><li><p><code>libdispatch</code> 库的初始化：<code>libdispatch</code> 是实现 GCD 的核心用户空间库。在 <code>void libdispatch_init(void)</code> 方法中会调用 <code>void _os_object_init(void)</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_include(<span class="meta-string">&lt;objc/objc-internal.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/objc-internal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                                  <span class="comment">// __asm__ 使函数调用编译为“调用_objc_retain”</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> id _Nullable <span class="title">objc_retain</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_retain&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">objc_release</span><span class="params">(id _Nullable obj)</span> __<span class="title">asm__</span><span class="params">(<span class="string">&quot;_objc_release&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_prepare(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_parent(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_atfork_child(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __has_include(&lt;objc/objc-internal.h&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>*_os_objc_destructInstance(id obj) &#123;</span><br><span class="line">    <span class="comment">// noop if only Libystem is loaded</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _os_object_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    Block_callbacks_RR callbacks = &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">sizeof</span></span>(Block_callbacks_RR),</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_retain,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;objc_release,</span><br><span class="line">        (<span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">const</span> <span class="keyword">void</span> *))&amp;_os_objc_destructInstance</span><br><span class="line">    &#125;;</span><br><span class="line">    _Block_use_RR2(&amp;callbacks);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *v = <span class="built_in">getenv</span>(<span class="string">&quot;OBJC_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;DISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line">    v = <span class="built_in">getenv</span>(<span class="string">&quot;LIBDISPATCH_DEBUG_MISSING_POOLS&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (v) _os_object_debug_missing_pools = _dispatch_parse_bool(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>然后就是 <a href="https://opensource.apple.com/tarballs/objc4/">objc的源码</a> <code>objc-os.mm</code>中的 <code>_object_init</code> 函数了：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// runtime环境的各种初始化</span></span><br><span class="line">    <span class="built_in">environ_init</span>();   <span class="comment">// 环境变量初始化。读取影响运行时的环境变量。如果需要，还可以打印环境变量</span></span><br><span class="line">    <span class="built_in">tls_init</span>();       <span class="comment">// 关于线程key的绑定，如线程的析构函数</span></span><br><span class="line">    <span class="built_in">static_init</span>();    <span class="comment">// 运行C++静态构造函数</span></span><br><span class="line">    <span class="built_in">runtime_init</span>();</span><br><span class="line">    <span class="built_in">exception_init</span>(); <span class="comment">// 初始化libobjc的异常处理系统，由map_images()调用。</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">cache_t</span>::<span class="built_in">init</span>();</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 初始化 trampoline machinery。通常这什么都不做，因为一切都是惰性初始化的，但对于某些进程，我们会主动加载 trampolines dylib。</span></span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册dyld事件的监听，监听每个image(动态库、可执行文件)的加载，该方法是dyld提供的，内部调用了dyld::registerObjCNotifiers这个方法，记录了这三个分别对应map，init，unmap事件的回调函数。会在相应时机触发</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// runtime 监听到dyld中image加载后，调用 map_images 做解析和处理，至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被 runtime 所管理，在这之后，runtime 的那些方法（动态添加 Class、swizzle 等等才能生效）</span></span><br><span class="line">    <span class="comment">// 接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_dyld_objc_notify_register</code> 这个方法在苹果开源的dyld里面可以找到，然后看到调用了<code>dyld::registerObjCNotifiers</code>这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// record functions to call</span></span><br><span class="line">  sNotifyObjCMapped   = mapped;</span><br><span class="line">  sNotifyObjCInit     = init;</span><br><span class="line">  sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call &#x27;mapped&#x27; function with all images mapped so far</span></span><br><span class="line">       <span class="comment">// 第一次先触发一次ObjCMapped</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">notifyBatchPartial</span>(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//内部会触发sNotifyObjCMapped的调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">      <span class="comment">// ignore request to abort during registration</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字面意思可以明白，传进来的分别是 map, init, unmap事件的回调。 dyld的事件通知有以下几种，分别会在特定的时机发送：(注意：map、init、unmap对应到下面枚举中的名称并不一致)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dyld_image_state_mapped                 = <span class="number">10</span>,       <span class="comment">// No batch notification for this</span></span><br><span class="line">  dyld_image_state_dependents_mapped      = <span class="number">20</span>,       <span class="comment">// Only batch notification for this</span></span><br><span class="line">  dyld_image_state_rebased                = <span class="number">30</span>, </span><br><span class="line">  dyld_image_state_bound                  = <span class="number">40</span>,</span><br><span class="line">  dyld_image_state_dependents_initialized = <span class="number">45</span>,       <span class="comment">// Only single notification for this</span></span><br><span class="line">  dyld_image_state_initialized            = <span class="number">50</span>,</span><br><span class="line">  dyld_image_state_terminated             = <span class="number">60</span>        <span class="comment">// Only single notification for this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这三个函数就很熟悉了，位于<code>objc-runtime-new.mm</code>中，objc运行时老生常谈的几个方法(关于OBJC的部分，内容太多，这里简单介绍，下篇细谈)，每次有新的镜像加载时都会在指定时机触发这几个方法：</p><ul><li>map_images : 每当 dyld 将一个 image 加载进内存时 , 会触发该函数进行image的一些处理：如果是首次，初始化执行环境等，之后<code>_read_images</code>进行读取，进行类、元类、方法、协议、分类的一些加载。</li><li>load_images : 每当 dyld 初始化一个 image 会触发该方法，会对该 image 进行+load的调用</li><li>unmap_image : 每当 dyld 将一个 image 移除时 , 会触发该函数</li></ul><img src="/images/compilelink/33.png" style="zoom:75%;" /><p>值得说明的是，这个初始化的过程远比写出来的要复杂，这里只提到了 runtime 这个分支，还有像 GCD、XPC 等重头的系统库初始化分支没有提及（当然，有缓存机制在，也不会重复初始化），总结起来就是 main 函数执行之前，系统做了非常多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p><p>然后，从上面最后的代码(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); 以及注释<code>register cxa_atexit() handler to run static terminators in all loaded images when this process exits</code>可以看出注册了<code>cxa_atexit()</code>函数，当此进程退出时，该处理程序会运行所有加载的image中的静态终止程序(static terminators)。</p><h4 id="第九步-查找主程序入口点并返回，-dyld-start会跳转进入"><a href="#第九步-查找主程序入口点并返回，-dyld-start会跳转进入" class="headerlink" title="第九步 查找主程序入口点并返回，__dyld_start会跳转进入"></a>第九步 查找主程序入口点并返回，__dyld_start会跳转进入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> mark -- 第九步 查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">    <span class="comment">// find entry point for main executable</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line"><span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">halt</span>(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_UNIXTHREAD</span>();</span><br><span class="line">*startGlue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* message) &#123;</span><br><span class="line"><span class="built_in">syncAllImages</span>();</span><br><span class="line"><span class="built_in">halt</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: launch failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>引自<a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a>一文中的片段，<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html">《 Mike Ash 这篇 blog 》</a>对 dyld 作用顺序的概括：</p><ol><li> 从 kernel 留下的原始调用栈引导和启动自己</li><li> 将程序依赖的动态链接库<strong>递归</strong>加载进内存，当然这里有<strong>缓存机制</strong></li><li> non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li><li> Runs static initializers for the executable</li><li> 找到可执行文件的 main 函数，准备参数并调用</li><li> 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li><li> 程序main函数 return 后执行 static terminator</li><li> 某些场景下 main 函数结束后调 libSystem 的 <strong>_exit</strong> 函数</li></ol><p>然后，使用调用堆栈，来看下dyld的工作流程，只注释了认为重要的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 内核XNU加载Mach-O</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 从 XNU内核态 将控制权转移到 dyld用户态</span></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start   <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::<span class="built_in">start</span>()   <span class="comment">//dyldInitialization.cpp，负责dyld的引导工作</span></span><br><span class="line">      ▼ dyld::_main()   <span class="comment">// dyld.cpp</span></span><br><span class="line">    ▶︎ <span class="comment">// 第一步，设置运行环境</span></span><br><span class="line">    ▶︎ <span class="comment">// 第二步，加载共享缓存</span></span><br><span class="line">    ▶︎ <span class="comment">// 第三步 实例化主程序，会实例化一个主程序ImageLoader</span></span><br><span class="line">    ▼ <span class="built_in">instantiateFromLoadedImage</span>()  </span><br><span class="line">        ▶︎ <span class="built_in">isCompatibleMachO</span>()  <span class="comment">// 检查mach-o的subtype是否是当前cpu可以支持；</span></span><br><span class="line">        ▶︎ <span class="built_in">instantiateMainExecutable</span>()  <span class="comment">// 实例化可执行文件，这个期间会解析LoadCommand，这个之后会发送 dyld_image_state_mapped 通知；</span></span><br><span class="line">        ▶︎ <span class="built_in">addImage</span>()  <span class="comment">// 将可执行文件这个image，添加到 allImages中</span></span><br><span class="line">    ▶︎ <span class="comment">// 第四步，循环调用该函数，加载插入的动态库</span></span><br><span class="line">    ▶︎ <span class="built_in">loadInsertedDylib</span>()  </span><br><span class="line">    ▶︎ <span class="comment">// 第五步，调用link()函数，链接主程序</span></span><br><span class="line">    ▼ <span class="built_in">link</span>()  </span><br><span class="line">  ▼ ImageLoader::<span class="built_in">link</span>() <span class="comment">//启动主程序的连接进程   —— ImageLoader.cpp，ImageLoader类中可以发现很多由dyld调用来实现二进制加载逻辑的函数。</span></span><br><span class="line">▼ <span class="built_in">recursiveLoadLibraries</span>() <span class="comment">//进行所有需求动态库的加载</span></span><br><span class="line">  ▶︎ <span class="comment">//确定所有需要的库</span></span><br><span class="line">  ▼ context.<span class="built_in">loadLibrary</span>() <span class="comment">//来逐个加载。context对象是一个简单的结构体，包含了在方法和函数之间传递的函数指针。这个结构体的loadLibrary成员在libraryLocator()函数（dyld.cpp）中初始化，它完成的功能也只是简单的调用load()函数。</span></span><br><span class="line">    ▼ <span class="built_in">load</span>() <span class="comment">// 源码在dyld.cpp，会调用各种帮助函数。</span></span><br><span class="line">      ▶︎ <span class="built_in">loadPhase0</span>() → <span class="built_in">loadPhase1</span>() → ... → <span class="built_in">loadPhase5</span>() → <span class="built_in">loadPhase5load</span>() → <span class="built_in">loadPhase5open</span>() → <span class="built_in">loadPhase6</span>() 递归调用  <span class="comment">//每一个函数都负责加载进程工作的一个具体任务。比如，解析路径或者处理会影响加载进程的环境变量。</span></span><br><span class="line">      ▼ <span class="built_in">loadPhase6</span>() <span class="comment">// 该函数从文件系统加载需求的dylib到内存中。然后调用一个ImageLoaderMachO类的实例对象。来完成每个dylib对象Mach-O文件具体的加载和连接逻辑。</span></span><br><span class="line">    ▶︎ <span class="comment">// 第六步，调用link()函数，链接插入的动态库</span></span><br><span class="line">    ▶︎ <span class="comment">// 第七步，对主程序进行弱符号绑定weakBind</span></span><br><span class="line">    ▶︎ sMainExecutable-&gt;<span class="built_in">weakBind</span>(gLinkContext);</span><br><span class="line">    ▶︎ <span class="comment">// 第八步，执行初始化方法 initialize。attribute((constructor)) 修饰的函数就是在这一步执行的, 即在主程序的main()函数之前。__DATA中有个Section __mod_init_func就是记录这些函数的。</span></span><br><span class="line">    ▼ <span class="built_in">initializeMainExecutable</span>()  <span class="comment">// dyld会优先初始化动态库，然后初始化主程序。</span></span><br><span class="line">          ▼ sMainExecutable-&gt;<span class="built_in">runInitializersrunInitializers</span>()  <span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">            ▼ ImageLoader::<span class="built_in">processInitializers</span>()</span><br><span class="line">              ▼ ImageLoader::<span class="built_in">recursiveInitialization</span>()  <span class="comment">// 循环遍历images list中所有的imageloader，recursive(递归)初始化。Calling recursive init on all images in images list</span></span><br><span class="line">                ▼ ImageLoaderMachO::<span class="built_in">doInitialization</span>()  <span class="comment">// 初始化这个image. initialize this image</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doImageInit</span>()  <span class="comment">//解析LC_ROUTINES_COMMAND 这个加载命令，可以参考loader.h中该命令的说明，这个命令包含了动态共享库初始化函数的地址，该函数必须在库中任意模块初始化函数(如C++ 静态构造函数等)之前调用</span></span><br><span class="line">                  ▼ ImageLoaderMachO::<span class="built_in">doModInitFunctions</span>()  <span class="comment">// 内部会调用C++全局对象的构造函数、__attribute__((constructor))修饰的C函数</span></span><br><span class="line">                  <span class="comment">// 以上两个函数中，libSystem相关的都是要首先执行的，而且在上述递归加载动态库过程，libSystem是默认引入的，所以栈中会出现libSystem_initializer的初始化方法</span></span><br><span class="line">          ▶︎ (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">    ▶︎ <span class="comment">// 第九步，查找入口点 main() 并返回，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▶︎ (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;<span class="built_in">getEntryFromLC_MAIN</span>();</span><br></pre></td></tr></table></figure><img src="/images/compilelink/34.png" style="zoom:80%;" /><p>关于更多的理论知识，可以阅读下<a href="https://juejin.im/post/6844903922654511112#heading-23">iOS程序员的自我修养-MachO文件动态链接（四）</a>、<a href="https://juejin.im/post/6844903926051897358">实践篇—fishhook原理</a>(：程序运行期间通过修改符号表(nl_symbol_ptr和la_symbol_ptr)，来替换要hook的符号对应的地址)，将《程序员的自我修养》中的理论结合iOS系统中的实现机制做了个对比介绍。</p><h2 id="五、加载动态库方式二-dlopen"><a href="#五、加载动态库方式二-dlopen" class="headerlink" title="五、加载动态库方式二: dlopen"></a>五、加载动态库方式二: dlopen</h2><blockquote><p>加载动态库的另一种方式：显式运行时链接dlopen</p></blockquote><p>上面的这种动态链接，其实还可以称为<strong>装载时链接</strong>，与静态链接相比，其实都是属于在程序运行之前进行的链接。还有另一种动态链接称为<strong>显式运行时链接</strong>(<strong>Explicit Runtime Linking</strong>)。</p><p>装载时链接：是在程序开始运行时(前)<strong>通过dyld动态加载</strong>。通过dyld加载的动态库需要在编译时进行链接，链接时会做标记，绑定的地址在加载后再决定。</p><p>显式运行时链接：即在运行时<strong>通过动态链接器dyld提供的API dlopen 和 dlsym 来加载</strong>。这种方式，在编译时是不需要参与链接的。</p><ul><li>dlopen会把共享库载入运行进程的地址空间，载入的共享库也会有未定义的符号，这样会触发更多的共享库被载入。</li><li>dlopen也可以选择是立刻解析所有引用还是滞后去做。</li><li>dlopen打开动态库后返回的是模块的指针(句柄/文件描述符(FD))</li><li>dlsym的作用就是通过dlopen返回的动态库指针和函数的符号，得到函数的地址然后使用。</li></ul><p><strong>不过，通过这种运行时加载远程动态库的 App，苹果公司是不允许上线 App Store 的，所以只能用于线下调试环节。</strong></p><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="https://www.cnblogs.com/guohai-stronger/p/11915571.html">MachO文件详解–逆向开发</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/">dyld与ObjC</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/">Dyld之二: 动态链接过程</a></li><li><a href="https://www.dllhook.com/post/238.html#toc_14">dyld详解</a></li><li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">iOS 程序 main 函数之前发生了什么</a></li><li><a href="https://juejin.cn/post/6844904068867948552">iOS探索 浅尝辄止dyld加载流程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、动态链接&quot;&gt;&lt;a href=&quot;#一、动态链接&quot; class=&quot;headerlink&quot; title=&quot;一、动态链接&quot;&gt;&lt;/a&gt;一、动态链接&lt;/h2&gt;&lt;p&gt;动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</title>
    <link href="https://tenloy.github.io/2021/10/14/compile-vm-asrl.html"/>
    <id>https://tenloy.github.io/2021/10/14/compile-vm-asrl.html</id>
    <published>2021-10-14T04:26:04.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ASLR引入"><a href="#一、ASLR引入" class="headerlink" title="一、ASLR引入"></a>一、ASLR引入</h2><p>进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方式。然而，这意味着某个给定程序在某个给定架构上的进程初始虚拟内存镜像都是基本一致的。而且更严重的问题在于，即使是在进程正常运行的生命周期中，大部分内存分配的操作都是按照同样的方式进行的，因此使得内存中的地址分布具有非常强的可预测性。</p><p>尽管这有助于调试，但是也给黑客提供了更大的施展空间。黑客主要采用的方法是代码注入：通过重写内存中的函数指针，黑客就可以将程序的执行路径转到自己的代码，将程序的输入转变为自己的输入。重写内存最常用的方法是采用缓冲区溢出(即利用未经保护的内存复制操作越过上数组的边界)，可参考<a href="https://www.jianshu.com/p/4703ad3efbb9">缓冲区溢出攻击</a>，将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏printf()格式化字符串以及基于堆的缓冲区溢出。此外，任何用户指针甚至结构化的异常处理程序都可以导致代码注入。这里的关键问题在于判断重写哪些指针，也就是说，可靠地判断注入的代码应该在内存中的什么位置。</p><p>不论被破解程序的薄弱环节在哪里：缓冲区溢出、格式化字符串攻击或其他方式，黑客都可以花大力气破解一个不安全的程序，找到这个程序的地址空间布局，然后精心设计一种方法，这种方法可以可靠地重现程序中的薄弱环节，并且可以在类似的系统上暴露出一样的薄弱环节。</p><p>现在大部分操作系统中都采用了一种称为地址空间布局随机化(ASLR) 的技术，这是一种避免攻击的有效保护。进程每一次启动时，地址空间都会被简单地随机化：<strong>只是偏移，而不是搅乱</strong>。基本的布局(程序文本、数据和库)仍然是一样的。然而，这些部分具体的地址都不同了——区别足够大，可以阻挡黑客对地址的猜测。<strong>实现方法是通过内核将Mach-O的段“平移”某个随机系数</strong>。</p><h2 id="二、ASLR"><a href="#二、ASLR" class="headerlink" title="二、ASLR"></a>二、ASLR</h2><p>地址空间布局随机化(Address Space Layout Randomization，ASLR)是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。iOS4.3开始引入了ASLR技术。</p><p>下面分别来看一下，未使用ASLR、使用了ASLR下，进程虚拟地址空间内的分布。下图中左侧是mach-O可执行文件，右侧是链接之后的虚拟地址空间，如果对<code>__TEXT</code>、<code>__DATA</code>等Segment概念不清楚的地方，可以看一些第二篇关于Mach-O文件结构的介绍。</p><img src="/images/compilelink/46.jpg" alt="26" style="zoom:55%;" /><h3 id="2-1-未使用ASLR的虚拟地址空间"><a href="#2-1-未使用ASLR的虚拟地址空间" class="headerlink" title="2.1 未使用ASLR的虚拟地址空间"></a>2.1 未使用ASLR的虚拟地址空间</h3><ul><li>函数代码存放在__TEXT段中</li><li>全局变量存放在__DATA段中</li><li>可执行文件的内存地址是0x0</li><li>代码段（__TEXT）的内存地址就是LC_SEGMENT(__TEXT)中的VM Address：arm64设备下，为<code>0x100000000</code>；非arm64下为<code>0x4000</code></li><li>可以使用<code>size -l -m -x</code>来查看Mach-O的内存分布</li></ul><img src="/images/compilelink/26.png" alt="26" style="zoom:55%;" /><h3 id="2-2-使用了ASLR的虚拟地址空间"><a href="#2-2-使用了ASLR的虚拟地址空间" class="headerlink" title="2.2 使用了ASLR的虚拟地址空间"></a>2.2 使用了ASLR的虚拟地址空间</h3><ul><li>LC_SEGMENT(__TEXT)的VM Address为<code>0x100000000</code></li><li>ASLR随机产生的Offset（偏移）为<code>0x5000</code></li></ul><img src="/images/compilelink/27.png" alt="26" style="zoom:55%;" /><h3 id="2-3-符号地址计算"><a href="#2-3-符号地址计算" class="headerlink" title="2.3 符号地址计算"></a>2.3 符号地址计算</h3><blockquote><p>函数(变量)符号的内存地址、可执行文件地址计算</p></blockquote><h4 id="2-3-1-函数内存地址计算"><a href="#2-3-1-函数内存地址计算" class="headerlink" title="2.3.1 函数内存地址计算"></a>2.3.1 函数内存地址计算</h4><ul><li><strong>File Offset:</strong> 在当前架构(MachO)文件中的偏移量。</li><li> <strong>VM Address【未偏移/ASLR偏移前】:</strong> 编译链接后，映射到虚拟地址中的内存起始地址。 <code>VM Address = File Offset + __PAGEZERO Size</code>(__PAGEZERO段在MachO文件中没有实际大小，在VM中展开)</li><li><strong>Load Address【ASLR偏移后的VM Address】:</strong> 在运行时加载到虚拟内存的起始位置。Slide是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同。<code>Load Address = VM Address + Slide(ASLR Offset)</code><ul><li>真正的运行时地址。本质也是虚拟地址空间中的地址，当未开启ASLR时，Load Address(运行时VM Address) ＝ 上面的静态VM Address</li></ul></li></ul><p>由于dsym符号表是编译时生成的地址，crash堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash日志里的符号地址被称为Stack Address，而编译后的符号地址被称为Symbol Address，他们之间的关系如下：<code>Stack Address = Symbol Address + Slide</code>。</p><p>符号化就是通过Stack Address到dsym文件中寻找对应符号信息的过程。</p><p><strong>Hopper、IDA图形化工具中的地址都是未使用ASLR前的VM Address</strong>。</p><h4 id="2-3-2-ASLR-Offset的获取"><a href="#2-3-2-ASLR-Offset的获取" class="headerlink" title="2.3.2 ASLR Offset的获取"></a>2.3.2 ASLR Offset的获取</h4><p>ASLR Offset有的地方也叫做<code>slide</code>，获取方法：</p><ul><li><p>在运行时由API <code>dyld_get_image_vmaddr_slide()</code>，来获取image虚拟地址的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型如下：</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">intptr_t</span>   _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> image_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般使用方法如下：</span></span><br><span class="line"><span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> index  = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>lldb</code>命令<code>image list -o -f</code> 进行获取（本地、远程<code>debugserver</code>调试都可以），如下图：</p><img src="/images/compilelink/28.png" alt="26" style="zoom:80%;" /></li><li><p>根据运行时crash中的 <code>binary image</code>信息 和 ELF 文件的 <code>load command</code> 计算的到。比如下例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是crash信息，其中包括了抛出异常的线程的函数调用栈信息，日志下方有binary image信息，都只摘取了部分：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一列，调用顺序</span></span><br><span class="line"><span class="comment"> 第二列，对应函数所属的 binary image</span></span><br><span class="line"><span class="comment"> 第三列，stack address</span></span><br><span class="line"><span class="comment"> 第四列，地址的符号＋偏移的表示法，运算结果等于第三列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Last Exception Backtrace:  </span><br><span class="line"><span class="number">0</span>   CoreFoundation                <span class="number">0x189127100</span> __exceptionPreprocess + <span class="number">132</span>  </span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib               <span class="number">0x1959e01fc</span> objc_exception_throw + <span class="number">60</span>  </span><br><span class="line"><span class="number">2</span>   CoreFoundation                <span class="number">0x189127040</span> +[NSException raise:format:] + <span class="number">128</span>  </span><br><span class="line"><span class="number">3</span>   CrashDemo                     <span class="number">0x100a8666c</span> <span class="number">0x10003c000</span> + <span class="number">10790508</span>  </span><br><span class="line"><span class="number">4</span>   libsystem_platform.dylib      <span class="number">0x19614bb0c</span> _sigtramp + <span class="number">56</span>  </span><br><span class="line"><span class="number">5</span>   CrashDemo                     <span class="number">0x1006ef164</span> <span class="number">0x10003c000</span> + <span class="number">7024996</span>  </span><br><span class="line"><span class="number">6</span>   CrashDemo                     <span class="number">0x1006e8580</span> <span class="number">0x10003c000</span> + <span class="number">6997376</span>  </span><br><span class="line"><span class="number">7</span>   CrashDemo                     <span class="number">0x1006e8014</span> <span class="number">0x10003c000</span> + <span class="number">6995988</span>  </span><br><span class="line"><span class="number">8</span>   CrashDemo                     <span class="number">0x1006e7c94</span> <span class="number">0x10003c000</span> + <span class="number">6995092</span>  </span><br><span class="line"><span class="number">9</span>   CrashDemo                     <span class="number">0x1006f2460</span> <span class="number">0x10003c000</span> + <span class="number">7038048</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 第一列，虚拟地址空间区块；</span></span><br><span class="line"><span class="comment"> 第二列，映射文件名；</span></span><br><span class="line"><span class="comment"> 第三列：加载的image的UUID；</span></span><br><span class="line"><span class="comment"> 第四列，映射文件路径 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Binary Images:  </span><br><span class="line"><span class="number">0x10003c000</span> - <span class="number">0x100f7bfff</span> CrashDemo arm64  &lt;b5ae3570a013386688c7007ee2e73978&gt; /var/mobile/Applications/<span class="number">05</span>C398CE<span class="number">-21E9</span><span class="number">-43</span>C2<span class="number">-967F</span><span class="number">-26</span>DD0A327932/CrashDemo.app/CrashDemo  </span><br><span class="line"><span class="number">0x12007c000</span> - <span class="number">0x1200a3fff</span> dyld arm64  &lt;<span class="number">628</span>da833271c3f9bb8d44c34060f55e0&gt; /usr/lib/dyld</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是使用 otool 工具查看到的 MedicalRecordsFolder（我的程序）的 加载命令 。</span></span><br><span class="line">$otool -l CrashDemo.app/CrashDemo   </span><br><span class="line">CrashDemo.app/CrashDemo:  </span><br><span class="line">Load command <span class="number">0</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">72</span>  </span><br><span class="line">  segname __PAGEZERO  </span><br><span class="line">   vmaddr <span class="number">0x0000000000000000</span>  </span><br><span class="line">   vmsize <span class="number">0x0000000100000000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">0</span>  </span><br><span class="line">  maxprot <span class="number">0x00000000</span>  </span><br><span class="line"> initprot <span class="number">0x00000000</span>  </span><br><span class="line">   nsects <span class="number">0</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">Load command <span class="number">1</span>  </span><br><span class="line">      cmd LC_SEGMENT_64  </span><br><span class="line">  cmdsize <span class="number">792</span>  </span><br><span class="line">  segname __TEXT  </span><br><span class="line">   vmaddr <span class="number">0x0000000100000000</span>  </span><br><span class="line">   vmsize <span class="number">0x000000000000c000</span>  </span><br><span class="line">  fileoff <span class="number">0</span>  </span><br><span class="line"> filesize <span class="number">49152</span>  </span><br><span class="line">  maxprot <span class="number">0x00000005</span>  </span><br><span class="line"> initprot <span class="number">0x00000005</span>  </span><br><span class="line">   nsects <span class="number">9</span>  </span><br><span class="line">    flags <span class="number">0x0</span>  </span><br><span class="line">……  </span><br><span class="line">Load command <span class="number">2</span> </span><br><span class="line">……  </span><br></pre></td></tr></table></figure><p>在 binary image 第一行可以看出进程空间的 0x10003c000 - 0x100f7bfff 这个区域在运行时被映射为 CrashDemo 内的内容，也就是我们的 ELF 文件(区域起始地址为0x10003c000)。<br>而在 Load Command 中看到的<code>__TEXT</code>的段起始地址却是 0x0000000100000000。<br>显而易见：slide = 0x10003c000(Load Address) - 0x100000000(VM Address) = 0x3c000；之后，就可以通过公式<code>symbol address = stack address - slide;</code> 来计算stack address 在crash log 中已经找到了。</p></li></ul><h4 id="2-3-3-Symbol-Address符号化"><a href="#2-3-3-Symbol-Address符号化" class="headerlink" title="2.3.3 Symbol Address符号化"></a>2.3.3 Symbol Address符号化</h4><ul><li><p>利用<code>dwarfdump</code>可以从dsym文件中得到symbol Address对应的内容：</p><ul><li>拿到crash日志后，我们要先确定dsym文件是否匹配。可以使用下面命令查看dsym文件所有架构的UUID：<code>dwarfdump --uuid CrashDemo.app.dSYM </code>，然后跟crash日志中Binary Images中的UUID相比对。</li><li>用得到的Symbol Address去 dsym 文件中查询，命令如下：<code>dwarfdump --arch arm64 --lookup [Symbol Address] CrashDemo.app.dSYM</code>，就可以定位下来具体的代码、函数名、所处的文件、行等信息了</li></ul></li><li><p>如果只是简单的获取符号名，可以用<code>atos</code>来符号化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -o [dsym file path] -l [Load Address] -arch [arch <span class="built_in">type</span>] [Stack Address]</span><br></pre></td></tr></table></figure><ul><li>不需要指定Symbol Address，只需要Load Address、Stack Address即可。</li></ul></li></ul><h2 id="三、进程地址空间"><a href="#三、进程地址空间" class="headerlink" title="三、进程地址空间"></a>三、进程地址空间</h2><p>由于ASLR的作用，进程的地址空间变得流动性非常大。但是尽管具体的地址会随机“滑动”某个小的偏移量，但整体布局保持不变。</p><p>内存空间分为以下几个段：</p><ul><li><strong>__PAGEZERO</strong>：在32位的系统中，这是内存中单独的一个页面(4KB)，而且这个页面所有的访问权限都被撤消了。在 64 位系统上，这个段对应了一个完整的32位地址空间(即前4GB)。这个段有助于捕捉空指针引用(因为空指针实际上就是 0)，或捕捉将整数当做指针引用(因为32位平台下的 4095 以下的值，以及64位平台下4GB以下的值都在这个范围内)。由于这个范围内所有访问权限(读、写和执行)都被撤消了，所以在这个范围内的任何解引用操作都会引发来自 MMU 的硬件页错误， 进而产生一个内核可以捕捉的陷阱。内核将这个陷阱转换为C++异常或表示总线错误的POSIX信号(SIGBUS) 。</li></ul><blockquote><p>PAGEZERO不是设计给进程使用的，但是多少成为了恶意代码的温床。想要通过“额外”代码感染Mach-O的攻击者往往发现可以很方便地通过PAGEZERO实现这个目的。PAGEZERO通常不属于目标文件的一部分(其对应的加载指令LC_SEGMENT将filesize指定为0)，但是对此并没有严格的要求.</p></blockquote><ul><li><strong>__TEXT</strong>：这个段存放的是程序代码。和其他所有操作系统一样，文本段被设置为r-x，即只读且可执行。这不仅可以防止二进制代码在内存中被修改，还可以通过共享这个只读段优化内存的使用。通过这种方式，同一个程序的多个实例可以仅使用一份TEXT副本。文本段通常包含多个区，实际的代码在_text区中。文本段还可以包含其他只读数据，例如常量和硬编码的字符串。</li><li><strong>__LINKEDIT</strong>：由dyld使用，这个区包含了字符串表、符号表以及其他数据。</li><li><strong>__IMPORT</strong>：用于 i386 的二进制文件的导入表。</li><li><strong>__DATA</strong>：用于可读/可写的数据。</li><li><strong>__MALLOC_TINY</strong>：用于小于一个页面大小的内存分配。</li><li><strong>__MALLOC_SMALL</strong>：用于几个页面大小的内存分配。</li></ul><p>下面是使用<code>vmmap(1)</code>输出的一个实例<code>程序a</code>在<code>32位</code>硬件设备上运行的进程地址空间，显示了区域的名称、地址范围、权限(当前权限和最高权限)以及映射的名称(通常对应的是Mach-O目标文件，如果有的话)。</p><p>32位进程的虚拟地址空间布局：</p><img src="/images/compilelink/29.png" alt="26" style="zoom:90%;" /><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>应该注意的是，尽管ASLR是很显著的改进，但也不是万能药。黑客仍然能找到聪明的方法破解程序。事实上，目前臭名昭著的“Star 3.0”漏洞就攻破了ASLR，这个漏洞越狱了 iPad 2 上的iOS 4.3。这种破解使用了Retum-Oriented Programming(ROP)攻击技术，通过缓冲区溢出破坏栈，以设置完整的栈帧， 模拟对libSystem的调用。同样的技术也用在iOS 5.0.1的“corona”漏洞中，这个漏洞成功地攻入了所有的苹果设备，包括当时最新的iPhone 4S。</p><p>预防攻击的唯一之道就是编写更加安全的代码，并且采用严格的代码审查，既要包含自动的技术，也要有人工的介入。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li>《深入解析Mac OS X &amp; iOS 操作系统》</li><li><a href="https://blog.csdn.net/zhongad007/article/details/90022617">动态调试之ASLR</a></li><li><a href="https://blog.csdn.net/xiaofei125145/article/details/50456614">iOS crash log 解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ASLR引入&quot;&gt;&lt;a href=&quot;#一、ASLR引入&quot; class=&quot;headerlink&quot; title=&quot;一、ASLR引入&quot;&gt;&lt;/a&gt;一、ASLR引入&lt;/h2&gt;&lt;p&gt;进程在自己私有的虚拟地址空间中启动。按照传统方式，进程每一次启动时采用的都是固定的可预见的方</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(四) Mach-O 文件的装载</title>
    <link href="https://tenloy.github.io/2021/10/10/compile-load.html"/>
    <id>https://tenloy.github.io/2021/10/10/compile-load.html</id>
    <published>2021-10-10T04:26:00.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/compilelink/25.png" alt="25" style="zoom:80%;" /><p>先附上源码地址：结合 <a href="https://opensource.apple.com/tarballs/xnu/">XNU</a> 源码(应该不是最新的，且不怎么全，不过用来分析学习也差不多了)，来看加载器的流程，效果更好。重要的两个类：</p><ul><li><code>bsd/kern/kern_exec.c</code>：进程执行的相关操作：线程创建、数据初始化等。</li><li><code>bsd/kern/mach_loader.c</code>：Mach-O文件解析加载相关。第二节中提到的Mach-O文件中的内核加载器负责处理的load command 对应的内核中处理的函数都在该文件中，比如处理<code>LC_SEGMET</code>命令的<code>load_segment</code>函数、处理<code>LC_LOAD_DYLINKER</code>命令的<code>load_dylinker</code>函数(负责调用命令指定的动态链接器)。</li></ul><h2 id="一、装载概述"><a href="#一、装载概述" class="headerlink" title="一、装载概述"></a>一、装载概述</h2><p>在链接完成之后，应用开始运行之前，有一段装载过程，我们都知道程序执行时所需要的指令和数据必须在内存中才能够被正常运行。</p><p>最简单的办法就是将程序运行所需要的指令和数据全都装入内存中，这样程序就可以顺利运行，这就是最简单的<code>静态装入</code>的办法。</p><p>但是很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量不够时，根本的解决办法就是添加内存。相对于磁盘来说，内存是昂贵且稀有的，这种情况自计算机磁盘诞生以来一直如此。所以人们想尽各种办法，希望能够在不添加内存的情况下让更多的程序运行起来，尽可能有效地利用内存。后来研究发现，程序运行时是有<code>局部性原理</code>的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是<code>动态装入</code>的基本原理。（这也是<code>虚拟地址空间</code>机制要解决的问题，这里不再赘述，大学都学过）</p><p>覆盖装入（Overlay）和页映射（Paging）是两种很典型的动态装载方法，它们所采用的思想都差不多，原则上都是利用了程序的局部性原理。动态装入的思想是程序用到哪个模块，就将哪个模块装入内存，如果不用就暂时不装入，存放在磁盘中。</p><h2 id="二、装载理论篇"><a href="#二、装载理论篇" class="headerlink" title="二、装载理论篇"></a>二、装载理论篇</h2><p>在虚拟存储中，现代的硬件MMU都提供地址转换的功能。有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。</p><p>事实上，从操作系统的角度来看，一个进程最关键的特征是它拥有独立的虚拟地址空间，这使得它有别于其他进程。很多时候一个程序被执行同时都伴随着一个新的进程的创建，那么我们就来看看这种最通常的情形：<strong>创建一个进程，然后装载相应的可执行文件并且执行</strong>。在有虚拟存储的情况下，上述过程最开始只需要做三件事情：</p><ul><li>创建一个独立的虚拟地址空间。</li><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><p><strong>首先是创建虚拟地址空间</strong>。一个虚拟空间由<code>一组页映射函数</code>将<code>虚拟空间的各个页</code>映射至相应的<code>物理空间</code>，所以创建一个虚拟空间实际上并不是创建空间而是<code>创建映射函数所需要的相应的数据结构</code>，在i386 的Linux下，创建虚拟地址空间实际上只是分配一个页目录（Page Directory）就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误的时候再进行设置。</p><p><strong>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</strong>。上面那一步的<code>页映射关系函数是虚拟空间到物理内存的映射关系</code>，这一步所做的是<code>虚拟空间与可执行文件的映射关系</code>。我们知道，当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正常运行。</p><p>但是很明显的一点是，当操作系统捕获到缺页错误时，它应知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。从某种角度来看，这一步是整个装载过程中最重要的一步，也是传统意义上“装载”的过程。</p><blockquote><p>由于可执行文件在装载时实际上是被映射的虚拟空间，所以可执行文件很多时候又被叫做映像文件（Image）。</p></blockquote><p>很明显，这种映射关系只是保存在操作系统内部的一个数据结构。Linux中将进程虚拟空间中的一个段叫做<strong>虚拟内存区域</strong>（VMA, Virtual Memory Area）；在Windows中将这个叫做<strong>虚拟段</strong>（Virtual Section），其实它们都是同一个概念。</p><blockquote><p>VMA是一个很重要的概念，它对于我们理解程序的装载执行和操作系统如何管理进程的虚拟空间有非常重要的帮助。</p></blockquote><p>操作系统在内部保存这种结构，很明显是因为当程序执行发生段错误时，它可以<code>通过查找这样的一个数据结构来定位错误页在可执行文件中的位置</code>。</p><p><strong>将CPU指令寄存器设置成可执行文件入口，启动运行</strong>。第三步其实也是最简单的一步，操作系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。这一步看似简单，实际上在操作系统层面上比较复杂，它涉及内核堆栈和用户堆栈的切换、CPU运行权限的切换。不过从进程的角度看这一步可以简单地认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址(通常是text区的地址)。</p><ul><li>ELF文件头中，有<code>e_entry</code>字段保存入口地址</li><li>Mach-O文件中的<code>LC_MAIN</code>加载指令作用就是设置程序主程序的入口点地址和栈大小)</li></ul><h2 id="三、Mach-O文件的装载"><a href="#三、Mach-O文件的装载" class="headerlink" title="三、Mach-O文件的装载"></a>三、Mach-O文件的装载</h2><p><a href="https://www.jianshu.com/p/332b183c055a">(二) Mach-O 文件结构</a> 介绍 <code>Mach Heade</code> 中的 <code>Load Command</code> 加载命令，结合其用途，就可以简单看出可执行文件的装载流程：</p><ul><li><p>首先，是由内核加载器(定义在<code>bsd/kern/mach_loader.c</code>文件中)来处理一些需要由内核加载器直接使用的加载命令。<strong>内核的部分(内核加载器)负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作</strong>。（这也是本篇内容主要讲的）</p></li><li><p>接着，对于需要动态链接(使用了动态库)的可执行文件(大部分可执行文件都是动态链接的)来说，<strong>控制权会转交给链接器，链接器进而接着处理文件头中的其他加载命令</strong>。真正的库加载和符号解析的工作都是通过<code>LC_LOAD_DY LINKER</code>命令指定的<code>动态链接器</code>在用户态完成的。（下一篇文章再细讲<code>dyld</code>及<code>动态链接</code>）</p></li></ul><p>下面通过代码来看一下具体的过程。下面通过一个调用栈图来说明， 这里面每个方法都做了很多事情，这里只注释了到_dyld_start的关键操作，很简略。有兴趣可以详细看源码<code>kern_exec.c</code>、<code>mach_loader.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">▼ execve       <span class="comment">// 用户点击了app，用户态会发送一个系统调用 execve 到内核</span></span><br><span class="line">  ▼ __mac_execve  <span class="comment">// 主要是为加载镜像进行数据的初始化，以及资源相关的操作，以及创建线程</span></span><br><span class="line">    ▼ exec_activate_image <span class="comment">// 拷贝可执行文件到内存中，并根据不同的可执行文件类型选择不同的加载函数，所有的镜像的加载要么终止在一个错误上，要么最终完成加载镜像。</span></span><br><span class="line">      <span class="comment">// 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 该方法为Mach-o Binary对应的执行方法；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Fat Binary，对应方法为exec_fat_imgact；</span></span><br><span class="line"><span class="comment">       * 如果image类型为Interpreter Script，对应方法为exec_shell_imgact</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ▼ exec_mach_imgact   </span><br><span class="line">        ▶︎ <span class="comment">// 首先对Mach-O做检测，会检测Mach-O头部，解析其架构、检查imgp等内容，判断魔数、cputype、cpusubtype等信息。如果image无效，会直接触发assert(exec_failure_reason == OS_REASON_NULL); 退出。</span></span><br><span class="line">          <span class="comment">// 拒绝接受Dylib和Bundle这样的文件，这些文件会由dyld负责加载。然后把Mach-O映射到内存中去，调用load_machfile()</span></span><br><span class="line">        ▼ load_machfile</span><br><span class="line">          ▶︎ <span class="comment">// load_machfile会加载Mach-O中的各种load monmand命令。在其内部会禁止数据段执行，防止溢出漏洞攻击，还会设置地址空间布局随机化（ASLR），还有一些映射的调整。</span></span><br><span class="line">            <span class="comment">// 真正负责对加载命令解析的是parse_machfile()</span></span><br><span class="line">          ▼ parse_machfile  <span class="comment">//解析主二进制macho</span></span><br><span class="line">            ▶︎ <span class="comment">/* </span></span><br><span class="line"><span class="comment">               * 首先，对image头中的filetype进行分析，可执行文件MH_EXECUTE不允许被二次加载(depth = 1)；动态链接编辑器MH_DYLINKER必须是被可执行文件加载的(depth = 2)</span></span><br><span class="line"><span class="comment">               * 然后，循环遍历所有的load command，分别调用对应的内核函数进行处理</span></span><br><span class="line"><span class="comment">               *   LC_SEGMET：load_segment函数：对于每一个段，将文件中相应的内容加载到内存中：从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。</span></span><br><span class="line"><span class="comment">               *   LC_UNIXTHREAD：load_unixthread函数，见下文</span></span><br><span class="line"><span class="comment">               *   LC_MAIN：load_main函数</span></span><br><span class="line"><span class="comment">               *   LC_LOAD_DYLINKER：获取动态链接器相关的信息，下面load_dylinker会根据信息，启动动态链接器</span></span><br><span class="line"><span class="comment">               *   LC_CODE_SIGNATURE：load_code_signature函数，进行验证，如果无效会退出。理论部分，回见第二节load_command `LC_CODE_SIGNATURE `部分。</span></span><br><span class="line"><span class="comment">               *   其他的不再多说，有兴趣可以自己看源码</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            ▼ load_dylinker <span class="comment">// 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span></span><br><span class="line">              ▼ parse_machfile <span class="comment">// 开始解析 dyld 这个mach-o文件</span></span><br><span class="line">                ▼ load_unixthread <span class="comment">// 解析 dyld 的 LC_UNIXTHREAD 命令，这个过程中会解析出entry_point</span></span><br><span class="line">                  ▼ load_threadentry  <span class="comment">// 获取入口地址</span></span><br><span class="line">                    ▶︎ thread_entrypoint  <span class="comment">// 里面只有i386和x86架构的，没有arm的，但是原理是一样的</span></span><br><span class="line">                  ▶︎ <span class="comment">//上一步获取到地址后，会再加上slide，ASLR偏移，到此，就获取到了dyld的入口地址，也就是 _dyld_start 函数的地址</span></span><br><span class="line">        ▼ activate_exec_state</span><br><span class="line">          ▶︎ thread_setentrypoint <span class="comment">// 设置entry_point。直接把entry_point地址写入到用户态的寄存器里面了。</span></span><br><span class="line">          <span class="comment">//这一步开始，_dyld_start就真正开始执行了。</span></span><br><span class="line"></span><br><span class="line">▼ dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start() </span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line">        ▼ 这是下篇内容</span><br></pre></td></tr></table></figure><h2 id="四、Linux-ELF文件的装载（了解）"><a href="#四、Linux-ELF文件的装载（了解）" class="headerlink" title="四、Linux ELF文件的装载（了解）"></a>四、Linux ELF文件的装载（了解）</h2><p>首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用 <code>execve()</code>系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。 execve() 系统调用被定义在unistd.h，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三个参数分别是被执行的程序文件名、执行参数和环境变量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>; </span><br></pre></td></tr></table></figure><p>Glibc对该系统调用进行了包装，提供了 execl()、execlp()、execle()、execv()、execvp()等5个不同形式的exec系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到 execve() 这个系统中。</p><p>在进入 execve() 系统调用之后，Linux内核就开始进行真正的装载工作。</p><ul><li><p><code>sys_execve()</code>，在内核中，该函数是execve()系统调用相应的入口，定义在arch\i386\kernel\Process.c。 该函数进行一些参数的检查复制之后，调用 do_execve()。</p></li><li><p><code>do_execve()</code>，该函数会首先查找被执行的文件，如果找到文件，则读取文件的前128个字节。目的是判断文件的格式，每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称做<code>魔数</code>（Magic Number），通过对魔数的判断可以确定文件的格式和类型。比如：</p><ul><li>ELF的可执行文件格式的头4个字节为0x7F、’e’、’l’、’f’；</li><li>Java的可执行文件格式的头4个字节为’c’、’a’、’f’、’e’；</li><li>如果被执行的是Shell脚本或perl、python等这种解释型语言的脚本，那么它的第一行往往是 “#!/bin/sh” 或 “#!/usr/bin/perl” 或 “#!/usr/bin/python” ，这时候前两个字节<code>&#39;#&#39;</code>和<code>&#39;!&#39;</code>就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。</li></ul><p>当do_execve()读取了这128个字节的文件头部之后，然后调用search_binary_handle()。</p></li><li><p><code>search_binary_handle()</code>，该函数会去搜索和匹配合适的可执行文件装载处理过程。<strong>Linux中所有被支持的可执行文件格式都有相应的装载处理过程</strong>，此函数会通过判断文件头部的魔数确定文件的格式，并且调用相应的装载处理过程。比如：</p><ul><li>ELF可执行文件的装载处理过程叫做 load_elf_binary()； </li><li>a.out可执行文件的装载处理过程叫做 load_aout_binary()；</li><li>装载可执行脚本程序的处理过程叫做 load_script()。</li></ul></li><li><p><code>load_elf_binary()</code>，这个函数被定义在fs/Binfmt_elf.c，代码比较长，它的主要步骤是：</p><ol><li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中段（Segment）的数量。</li><li>寻找动态链接的“.interp”段，设置动态链接器路径。</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是 DT_FINI 的地址（动态链接相关）。</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中 <code>e_entry</code> 所指的地址；对于动态链接的ELF可执行文件，程序入口点是动态链接器。</li></ol></li></ul><p>当 load_elf_binary() 执行完毕，返回至 do_execve() 再返回至 sys_execve() 时， 上面的第5步中已经把系统调用的返回地址改成了被装载的ELF程序(或动态链接器)的入口地址了。所以当 <code>sys_execve()</code>系统调用从内核态返回到用户态时，EIP 寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="">《深入理解Mach OS X &amp; iOS 操作系统》</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/">Dyld系列之一：_dyld_start之前</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/compilelink/25.png&quot; alt=&quot;25&quot; style=&quot;zoom:80%;&quot; /&gt;

&lt;p&gt;先附上源码地址：结合 &lt;a href=&quot;https://opensource.apple.com/tarballs/xnu/&quot;&gt;XNU&lt;</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(三) Mach-O 文件的静态链接</title>
    <link href="https://tenloy.github.io/2021/10/08/compile-static-link.html"/>
    <id>https://tenloy.github.io/2021/10/08/compile-static-link.html</id>
    <published>2021-10-08T04:25:56.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链接概述"><a href="#一、链接概述" class="headerlink" title="一、链接概述"></a>一、链接概述</h2><p>链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？</p><p>很久以前，人们编写程序时，将所有源代码都写在同一个文件中，发展到后来一个程序源代码的文件长达数百万行，以至于人们没有能力维护这个程序。</p><p>后来，出现了模块化。现代的大型软件往往拥有成千上万个模块，这些模块之间相互依赖又相对独立。这种按照层次化及模块化存储和组织源代码有很多好处，比如代码更容易阅读、理解、重用，每个模块可以单独开发、编译、测试，改变部分代码不需要编译整个程序等。</p><p>在一个程序被分割成多个模块以后，这些模块之间最后如何组合形成一个单一的程序是须解决的问题。<code>模块之间如何组合的问题可以归结为模块之间如何通信的问题</code>，最常见的属于静态语言的C/C++模块之间通信有两种方式，一种是模块间的<strong>函数调用</strong>，另外一种是模块间的<strong>变量访问</strong>。函数访问须知道目标函数的地址，变量访问也须知道目标变量的地址，所以这两种方式都可以归结为一种方式，那就是<code>模块间符号的引用</code>。模块间依靠符号来通信类似于拼图版，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者一拼接刚好完美组合。这个模块的拼接过程就是：<strong>链接</strong></p><img src="/images/compilelink/18.jpg" alt="18" style="zoom:100%;" /><p>综上所述，链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。现代的高级语言的诸多特性和功能，使得编译器、链接器更为复杂，功能更为强大，但从原理上来讲，链接器的工作无非就是把一些指令对其他符号地址的引用加以修正。<strong>链接过程主要包括了地址和空间分配（Address and StorageAllocation）、符号决议（Symbol Resolution）和重定位 （Relocation）等这些步骤。</strong>（<code>符号可以理解为函数名和变量名</code>）</p><p>链接分为静态链接、动态链接。本篇只讲静态链接及静态链接器。</p><ul><li>静态链接是把目标文件（一个或多个）和需要的静态库链接成可执行文件。</li><li>动态链接是在可执行文件<code>装载</code>、<code>运行</code>时进行的文件的链接。</li></ul><h2 id="二、静态链接"><a href="#二、静态链接" class="headerlink" title="二、静态链接"></a>二、静态链接</h2><h3 id="2-1-链接器"><a href="#2-1-链接器" class="headerlink" title="2.1 链接器"></a>2.1 链接器</h3><p>lld链接器是LLVM的一个子项目，旨在为LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。</p><p>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p><h3 id="2-2-静态链接过程"><a href="#2-2-静态链接过程" class="headerlink" title="2.2 静态链接过程"></a>2.2 静态链接过程</h3><h4 id="2-2-1-两步链接"><a href="#2-2-1-两步链接" class="headerlink" title="2.2.1 两步链接"></a>2.2.1 两步链接</h4><p>我们知道，可执行文件中的代码段和数据段都是由输入的目标文件中合并而成的。那么链接过程就产生了第一个问题：对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？</p><ol><li><p><strong>按序叠加</strong>：一个最简单的方案就是将输入的目标文件按照次序叠加起来。（比如按照编译顺序，先编译的在前）。</p><p><strong>缺点</strong>：在有很多输入文件的情况下，输出文件将会有很多零散的段。假如有数百个目标文件，且都分别有.text段、.data段、.bss段，那最后的输出文件将会有成百上千个零散的段。这种做法非常浪费空间，因为每个段都须要有一定的地址和空间对齐要求(<strong>x86中，段的装载地址和空间的对齐单位是页，也就是4096字节</strong>)。</p></li><li><p><strong>相似段合并</strong>：将相同性质的段合并到一起。</p></li></ol><img src="/images/compilelink/19.jpg" alt="18" style="zoom:90%;" /><p>现在的链接器空间分配的策略基本上都会使相似段(Section)合并，使用这种方法的链接器一般都采用一种叫两步链接（Two-pass Linking）的方法。也就是说整个链接过程分两步：</p><h4 id="2-2-2-符号表与符号"><a href="#2-2-2-符号表与符号" class="headerlink" title="2.2.2 符号表与符号"></a>2.2.2 符号表与符号</h4><p>以下示例来自<a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a>，过程很简单，就是对于目标文件、可执行文件的MachOView的分析，目标文件、可执行文件是链接过程的输入、输出，通过对两个文件中的<code>符号表Symbols</code>、<code>代码段__TEXT.__text</code>来看一下引用符号的空间与地址分配、地址绑定过程。关于目标文件、可执行文件的生成上一篇文章已经讲过，本篇文章就直接看分析结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c 文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_var;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    func(a+global_var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">=========================</span><br><span class="line"><span class="comment">// b.c 文件</span></span><br><span class="line"><span class="keyword">int</span> global_var = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    global_var = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成a.o b.o</span></span><br><span class="line">xcrun -sdk iphoneos clang -c a.c b.c -target arm64-apple-ios12.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o和b.o链接成可执行文件ab</span></span><br><span class="line">xcrun -sdk iphoneos clang a.o b.o -o ab -target arm64-apple-ios12.2</span><br></pre></td></tr></table></figure><p>请注意，生成的a.o和b.o目标文件，都是基于arm64。a.o和b.o目标文件通过静态链接后生成可执行文件ab。（由于基于arm64，其实链接过程，也有动态链接库libSystem.B.dylib(系统库)参与,但本文忽略动态链接的参与，只讨论静态链接）。</p><img src="/images/compilelink/20.png" alt="18" style="zoom:80%;" /><p>在可执行文件ab中，之所以<code>__TEXT.text</code>段的虚拟地址为<code>0x100000000</code>，而在文件中的位置(偏移)为<code>0</code>，是因为在链接生成可执行文件时，产生的一个特殊的段<code>__PAGEZERO</code>，这个段，在可执行文件中不占空间<code>File Offest</code>、<code>File Size</code>都为0，而在虚拟地址空间中，占用了很大的空间，<code>VMSize</code>为<code>0x100000000(4G)</code>.</p><p>在进入重定位之前，这里还需要再介绍一下符号表相关的知识点：符号表的加载命令、符号表的结构。</p><h5 id="1-符号表的加载命令"><a href="#1-符号表的加载命令" class="headerlink" title="1. 符号表的加载命令"></a>1. 符号表的加载命令</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/loader.h&gt;中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* 加载命令的前两个参数都是cmd和cmdsize，cmd为加载命令的类型，符号表对应的值为LC_SYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* symtab_command结构体的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>symoff;<span class="comment">/* 符号表在文件中的偏移（位置） */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>nsyms;<span class="comment">/* 符号表入口的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>stroff;<span class="comment">/* 字符串表在文件中的偏移(位置) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>strsize;<span class="comment">/* 字符串表的大小(字节数) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2. 符号表"></a>2. 符号表</h5><p>符号表也是一个数组，里面元素是结构体nlist_64。符号表示意图见下方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> n_strx;   <span class="comment">/* 字符串表的index，可以找到符号对应的字符串（index into the string table） */</span></span><br><span class="line">    &#125; n_un;                <span class="comment">/* 历史原因，忽略 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_type;       <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  n_sect;       <span class="comment">/* section的编号或NO_SECT（section number or NO_SECT） */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* 符号的地址值（value of this symbol (or stab offset)） */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它先不管，要是有兴趣，可以去头文件&lt;mach-o/nlist.h&gt;查看。</span></span><br></pre></td></tr></table></figure><p>左侧是a.o的符号表，右侧是可执行文件的(全局)符号表：</p><img src="/images/compilelink/21.png" alt="18" style="zoom:80%;" /><p>相比于<code>a.o</code>、<code>b.o</code>目标文件，此时，可执行文件<code>ab</code>中的全局符号表中，每个符号都有了对应的(虚拟空间)地址，这是重定位的前提。</p><h5 id="3-符号表中符号的几种类型"><a href="#3-符号表中符号的几种类型" class="headerlink" title="3. 符号表中符号的几种类型"></a>3. 符号表中符号的几种类型</h5><blockquote><p><a href="https://www.jianshu.com/p/bda60193808d">引自-符号和符号表</a></p></blockquote><p>每个可重定位模块都有一个符号表，它包含了在本模块中定义和引用的符号，有三种链接器符号：</p><table><thead><tr><th>类型</th><th>特征</th><th>举例</th></tr></thead><tbody><tr><td><strong>Global symbols</strong>（模块内部定义的<strong>全局符号</strong>）</td><td>由本模块定义并能被其他模块引用的符号</td><td>例如，非static C函数和非 static的C全局变量（指不带static的全局变量）</td></tr><tr><td><strong>External symbols</strong>（外部定义的<strong>全局符号</strong>）</td><td>由其他模块定义并被本模块引用了的全局符号</td><td>例如，在本模块中extern声明的其它模块中定义的符号</td></tr><tr><td><strong>Local symbols</strong>（本模块的<strong>局部符号</strong>）</td><td>仅由本模块内定义和引用的本地符号</td><td>例如，在本模块中定义的带static 的C函数和全局变量。</td></tr></tbody></table><p><strong>注意：链接器局部符号</strong></p><ul><li><strong>不是指程序中的局部变量</strong>（分配在栈中的临时性变量），链接器是不关心这种局部变量的。</li><li><strong>个人理解</strong>：局部符号在本模块内定义并引用，按照符号解析的功能来看，其是不参与符号解析的。这也是为什么多个目标文件中出现同名的局部符号，在链接时，却不会报<code>符号重定义</code>的原因。并且查看链接后的可执行文件，符号表中，是可以同时存在多个同名局部符号的。</li></ul><h4 id="2-2-3-第一步-空间与地址分配"><a href="#2-2-3-第一步-空间与地址分配" class="headerlink" title="2.2.3 第一步 空间与地址分配"></a>2.2.3 第一步 空间与地址分配</h4><p>“链接器为目标文件分配地址和空间”这句话中的“地址和空间”其实有两个含义：</p><ul><li>第一个是在输出的可执行文件中的空间；</li><li>第二个是在装载后的虚拟地址中的虚拟地址空间。</li></ul><p>对于有实际数据的段，比如“.text”和“.data”来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；而对于“.bss”这样的段来说，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。</p><p>事实上，我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接过程关系并不是很大。</p><h5 id="1-相似段合并"><a href="#1-相似段合并" class="headerlink" title="1. 相似段合并"></a>1. 相似段合并</h5><p>扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<code>全局符号表</code>。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</p><p>应该说地址与空间分配，地址：分配到哪；空间：分配多大。链接器的地址与空间分配，既是指在可执行文件中的分配，也指在虚拟地址空间中的分配。</p><ul><li><code>可执行文件的地址空间</code>与目标文件中一样，地址从0开始。</li><li><code>虚拟地址空间</code>中的地址并非从0开始，比如Linux下，ELF可执行文件中的数据，在进程虚拟地址空间中，默认从0x08048000开始分配。</li></ul><p>我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这个关系到下一步重定位中，关于地址计算的步骤(重定位中，地址修正是修正为符号的虚拟地址空间中的地址)，而且可执行文件本身的空间分布、分配与链接过程关系并不是很大。</p><p>这一步过程：</p><ul><li>会将多个输入模块(目标文件)的数据收集，相似段进行合并，见上图。</li><li>重新计算段在可执行文件中的偏移、大小。</li><li>重新计算段在虚拟地址空间中的偏移、大小。</li></ul><p>这些信息在<code>LC_SEGMENT_64</code>中看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 初始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* segment包含的section的个数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-符号地址的确定-rebase"><a href="#2-符号地址的确定-rebase" class="headerlink" title="2. 符号地址的确定(rebase)"></a>2. 符号地址的确定(rebase)</h5><p>当前面一步完成之后，链接器开始计算各个符号的虚拟地址。(这一步修正地址的符号是本文件内定义的(数据、函数)符号，关于外部符号的引用重定位在第二步)</p><p>一个mach-o的二进制文件中，包含了<strong>text</strong>段和<strong>data</strong>段。我们知道在代码中，我们可以用<strong>指针</strong>来引用，那么在一个文件中怎么代表引用呢，那就是<strong>偏移</strong>(<strong>目标文件中符号表中的符号的地址，都是相对于text段起始的偏移</strong>)。</p><p>当目标文件、动态库文件等二进制文件加载到内存中的时候，起始地址就是申请的内存的起始地址（slide)，不会是0，那么如何再能够找到这些引用的正确内存位置呢？ 把<strong>偏移</strong>加上(slide)就好了。</p><img src="/images/compilelink/38.png" alt="38" style="zoom:70%;" /><h4 id="2-2-4-第二步-符号解析与重定位"><a href="#2-2-4-第二步-符号解析与重定位" class="headerlink" title="2.2.4 第二步 符号解析与重定位"></a>2.2.4 第二步 符号解析与重定位</h4><p>使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。</p><h5 id="1-符号解析"><a href="#1-符号解析" class="headerlink" title="1. 符号解析"></a>1. 符号解析</h5><p>符号解析：解析每个模块中<code>引用的符号</code>，将其与某个目标模块中的<code>符号定义</code>建立关联。</p><ul><li>每个定义的符号在代码段或数据段中都被分配了存储空间，将符号引用与符号定义建立关联后，就可在重定位时将引用的符号的地址重定位为相关联的定义的符号的地址。</li><li>如果没找到定义，会给出一个类似<code>“undefined reference to &#39;xxx&#39;”</code>、<code> “Undefined symbols”</code>类似的链接错误。导致这个问题的原因很多，最常见的一般都是链接时缺少了某个库、输入目标文件路径不正确、符号的声明与定义不一样等。</li><li>如果找到了，进行符号决议(绑定)：<ul><li>如果找到了一个，直接绑定；</li><li>如果链接器在输入模块中找到了一个以上的外部符号定义，会按照它的规则选择其中一个符号定义或者报错。<code>强弱符号</code>规则：<ul><li>对于C/C++语言来说，编译器默认函数和已初始化的全局变量为强符号，未初始化的全局变量为弱符号。</li><li>强符号只能被定义一次，否则报符号重复定义错误。符号的重复定义错误与类型无关，只要经过符号修饰机制后产生的符号相同，就报符号重复<code>“ld: dumplicate symbols”</code></li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选强符号。(Xcode中默认设置了clang编译参数，遇到强弱符号会报重复定义错误)</li><li>如果一个符号在所有目标文件中都是弱符号，会选择占用空间最大的一个（《程序员的自我修养》）</li></ul></li><li>动态库链接中还有<code>全局符号介入</code>规则(如果相同符号名的符号已存在，则后加入的符号被忽略))。</li></ul></li></ul><blockquote><p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定 （Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的。</p><p>大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如“决议”更倾向于静态链接，而“绑定”更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p></blockquote><p><strong>符号解析时会选择一个确切的定义，即每个全局符号仅占一处存储空间。</strong></p><p><strong>编码建议：</strong></p><ul><li>尽量避免使用全局变量</li><li>一定要用时：<ul><li>尽量使用内部链接定义，如用static修饰</li><li>全局变量要赋初值，<strong>避免潜在的强弱符号造成的不可知错误</strong>，赋初值后，编译器检测到重复定义会报错，提醒开发者修正。</li></ul></li><li><strong>头文件中，不能写<code>Global symbols</code>的定义</strong>(否则若头文件若被多处<code>#include</code>，预处理后展开，文件内容替换该行，就相当于直接在多个源文件中出现全局符号定义，会报错)。如果要定义全局变量，一定要用static修饰，设置为<code>Local symbols</code>。</li></ul><p>符号解析完成，全局符号表中符号都有对应的定义处的地址。接下来就是重定位工作：<strong>根据重定位表<code>Relocations</code>中符号信息，在全局符号表<code>Symbols</code>中找到符号的<code>定义地址</code>，然后找到符号在代码段<code>__TEXT.text</code>中的使用地址，进行指令的地址修正。</strong></p><h5 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2. 重定位"></a>2. 重定位</h5><p>重定位就是指针修正的过程。</p><p>假设有A、B两个目标文件，B中引用了A中的一个变量并对其进行赋值，对应AT&amp;T汇编为<code>movl $0x2a, var</code>。</p><p>由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为 0，等待链接器在将目标文件A和B链接起来的时候再将其修正。我们假设A和B链接后，变量var的地址确定下来为0x1000，那么链接器将会把这个指令的目标地址部分修改成0x10000。这个地址修正的过程也被叫做<strong>重定位（Relocation）</strong>，每个要被修正的地方叫一个<strong>重定位入口（Relocation Entry）</strong>。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p><p>从上面的示例中，可以看到：a文件使用了B文件中的global_var和func两个符号，那是怎么知道这两个符号的地址呢？</p><p>在a.o目标文件中：</p><img src="/images/compilelink/22.png" alt="18" style="zoom:70%;" /><ul><li>global_var（地址0）和func（地址0x2c，这条指令本身地址）都是假地址。编译器暂时用0x0和0x2c替代着，把真正地址计算工作留给链接器。</li><li>通过前面的空间与地址分配可以得知，链接器在完成地址与空间分配后，就可以确定所有符号的虚拟地址了。</li><li>此时，链接器根据符号的地址对每个需要重定位的指令进行地址修正。</li></ul><p>在链接后的ab可执行文件中：</p><img src="/images/compilelink/23.png" alt="18" style="zoom:70%;" /><p>可以看到global_var（地址0x100008000，指向data段，值为1）和func（地址0x100007f90，指向func函数地址）都是真正的地址。</p><p>链接器是怎么知道a模块里哪些指令要被调整，这些指令如何调整。事实上a.o里，有一个重定位表，专门保存这些与重定位相关的信息。而且每个section的section_64的header的reloff（重定位入口的文件偏移，即在重定位表里的偏移）和nreloc（几个需要重定位的符号），让链接器知道a模块的哪个section里的指令需要调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-重定位表"><a href="#3-重定位表" class="headerlink" title="3. 重定位表"></a>3. 重定位表</h5><p>重定位表可以认为是一个数组，数组里的元素为结构体relocation_info。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义在&lt;mach-o/reloc.h&gt;里</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> &#123;</span></span><br><span class="line">   <span class="keyword">int32_t</span>    r_address;<span class="comment">/* 重定位的符号在自己所在section中的偏移(地址)；offset in the section to what is being relocated */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>   r_symbolnum:<span class="number">24</span>,<span class="comment">/* 如果r_extern == 0(外部符号)，则表示符号在符号表中的索引，如果r_extern == 0，则表示section的序数；symbol index if r_extern == 1 or section ordinal if r_extern == 0 */</span></span><br><span class="line">              r_pcrel:<span class="number">1</span>, <span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">              r_length:<span class="number">2</span>,<span class="comment">/* 重定位符号的长度；0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">              r_extern:<span class="number">1</span>,<span class="comment">/* 不包含引用符号的值(即为外部符号)；does not include value of sym referenced */</span></span><br><span class="line">              r_type:<span class="number">4</span>;        <span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r_address和r_length足够让我们知道要重定位的字节了；</span></span><br></pre></td></tr></table></figure><img src="/images/compilelink/24.png" alt="18" style="zoom:70%;" /><p>可以看出：</p><ul><li>a.o文件的重定位表中记录符号了_func和_global_var两个需要重定位的符号，并且<code>r_address</code>给出了两个符号在代码段section的位置，<code>r_symbolnum</code>指向了符号在符号表的index。</li><li>链接时候，a.o里面有这两符号的引用，然后b.o里面有这两符号的定义，一起合并到全局符号表里（见下方符号表部分中的示意图）。</li><li>在全局符号表里，可以找到这两个符号的虚拟内存位置和其它信息，就可以完成重定位工作(对指令进行地址修正)了。</li></ul><h3 id="2-3-静态库链接"><a href="#2-3-静态库链接" class="headerlink" title="2.3 静态库链接"></a>2.3 静态库链接</h3><p>一个静态库可以简单看成一组目标文件的集合，即多个目标文件经过压缩打包后形成的一个文件。</p><p>静态库链接：是指自己的模块与静态库里的某个模块（用到的某个目标文件，或多个目标文件）链接成可执行文件。其实和静态链接概念一样，只是这里，我们这里取了静态库里的某个/多个目标文件与我们自己的目标文件一起作为输入。</p><p>Q：为什么静态运行库里面一个目标文件只包含一个函数？比如libc.a静态库里面printf.o只有printf()函数、strlen.o只有strlen()函数，为什么要这样组织？</p><p>A：我们知道，<strong>链接器在链接静态库的时候是<code>以目标文件为单位</code>的</strong>。比如我们引用了静态库中的printf()函数，那么链接器就会把库中包含printf()函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件（函数）就不要链接到最终的输出文件中。</p><h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903912198127623#heading-5">iOS程序员的自我修养-MachO文件静态链接（三）</a></li><li><a href="">《程序员的自我修养》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、链接概述&quot;&gt;&lt;a href=&quot;#一、链接概述&quot; class=&quot;headerlink&quot; title=&quot;一、链接概述&quot;&gt;&lt;/a&gt;一、链接概述&lt;/h2&gt;&lt;p&gt;链接通常是一个让人比较费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(二) Mach-O 文件结构</title>
    <link href="https://tenloy.github.io/2021/10/06/compile-macho.html"/>
    <id>https://tenloy.github.io/2021/10/06/compile-macho.html</id>
    <published>2021-10-06T04:25:50.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式<code>Mach-O的结构</code>，方便了解之后的<code>链接</code>生成可执行文件的过程。</p><p>先附上相关源码地址：与Mach-O 文件格式有关的结构体定义都可以从 <code>/usr/include/mach-o/loader.h</code> 中找到(直接在xcode项目中找到<code>loader.h</code>，然后Show In Finder即可)。</p><h2 id="一、进程与二进制格式"><a href="#一、进程与二进制格式" class="headerlink" title="一、进程与二进制格式"></a>一、进程与二进制格式</h2><p>进程在众多操作系统中都有提及，它是作为一个正在执行的程序的实例，这是 UNIX 的一个基本概念。而进程的出现是特殊文件在内从中加载得到的结果，这种文件必须使用操作系统可以认知的格式，这样才对该文件引入依赖库，初始化运行环境以及顺利地执行创造条件。</p><p><strong>Mach-O</strong>（Mach Object File Format）是 macOS 上的可执行文件格式，类似于 Linux 和大部分 UNIX 的原生格式 <strong>ELF</strong>（Extensible Firmware Interface）。macOS 支持三种可执行格式：解释器脚本格式、通用二进制格式和 Mach-O 格式(关于三者区别，在下面说到Mach-O Header的时候介绍)。</p><h2 id="二、相关工具"><a href="#二、相关工具" class="headerlink" title="二、相关工具"></a>二、相关工具</h2><p>命令行工具</p><ul><li><p>file 命令，查看Mach-O文件的基本信息：<code>file 文件路径</code></p></li><li><p>otool 命令，查看Mach-O特定部分和段的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看Mach-O文件的header信息</span></span><br><span class="line">otool -h 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件的load commands信息</span></span><br><span class="line">otool -l 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Mach-O文件所使用到的动态库</span></span><br><span class="line">otool -L 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更多使用方法，终端输入otool -help查看</span></span><br></pre></td></tr></table></figure></li><li><p>lipo 命令，来处理多架构Mach-O文件，常用命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看架构信息</span></span><br><span class="line">lipo -info 文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出某种类型的架构</span></span><br><span class="line">lipo 文件路径 -thin 架构类型 -output 输出文件路径</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并多种架构类型</span></span><br><span class="line">lipo 文件路径1 文件路径2 -output 输出文件路径</span><br></pre></td></tr></table></figure></li><li><p>nm命令，llvm提供，可以查看目标文件符号表里的内容：符号、对应的地址、符号的一些修饰符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: llvm symbol table dumper</span><br><span class="line">USAGE: nm [options] &lt;input files&gt;</span><br></pre></td></tr></table></figure></li></ul><p>GUI工具</p><ul><li>MachOView：文件浏览。<a href="https://github.com/gdbinit/MachOView">MachOView官网</a></li><li>Hopper Disassembler、IDA Pro：反汇编工具</li></ul><h2 id="三、Mach-O-文件格式"><a href="#三、Mach-O-文件格式" class="headerlink" title="三、Mach-O 文件格式"></a>三、Mach-O 文件格式</h2><p>Mach-O 文件格式在官方文档中有一个描述图，很多教程中都引用到。<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html">官网文档</a></p><img src="/images/compilelink/12.png" alt="12" style="zoom:90%;" /><p>可以看的出 Mach-O 主要由 3 部分组成，下面一一讲述。Load Command的作用是指导内核加载器、动态链接器怎么将可执行文件装载到内存进行执行。所以Load Command放到最后一部分。</p><h3 id="3-1-示例"><a href="#3-1-示例" class="headerlink" title="3.1 示例"></a>3.1 示例</h3><p>用 helloworld 来做个试验：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// main.cpp</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>clang -g main.cpp -o main</code> 生成执行文件。然后拖入到 <em>MachOView</em> 中来查看一下加载 Segment 的结构（当然使用 <em>Synalyze It!</em> 也能捕捉到这些信息的，但是 <em>MachOView</em> 更对结构的分层更加一目了然）：</p><img src="/images/compilelink/13.jpg" alt="12" style="zoom:80%;" /><h3 id="3-2-Mach-O-头"><a href="#3-2-Mach-O-头" class="headerlink" title="3.2 Mach-O 头"></a>3.2 Mach-O 头</h3><p>Mach-O 头（Mach Header）描述了 Mach-O 的 CPU 架构、大小端、文件类型以及加载命令等信息。它的作用是让内核在读取该文件创建虚拟进程空间的时候，检查文件的合法性以及当前硬件的特性是否能支持程序的运行。</p><p>以下只给出 64 位定义的代码，因为 32 位的区别是缺少了一个预留字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC    0xfeedface    <span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM    0xcefaedfe    <span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;            <span class="comment">/* magic(魔数)：用来确认文件的格式，操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。 */</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>    cputype;        <span class="comment">/* CPU架构 */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>    cpusubtype;  <span class="comment">/* CPU子版本 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filetype;         <span class="comment">/* 文件类型，常见的Mach-O文件有：MH_OBJECT(目标文件)、MH_EXECUTABLE(可执行二进制文件)、MH_DYLIB(动态库)等等。这些文件类型定义在 loader.h 文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    ncmds;            <span class="comment">/* 加载器中加载命令的数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sizeofcmds;       <span class="comment">/* 加载器中所有加载命令的总大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;            <span class="comment">/* dyld 加载需要的一些标志，其中MH_PIE表示启用地址空间布局随机化(ASLR)。其他的值在loader.h文件中同样可以找到 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved;         <span class="comment">/* 64位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>魔数会表明文件的格式。filetype会表明具体是什么文件类型(都是猫，也分黑猫、白猫)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// magic：常见的魔数(Mac是小端模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mach-O文件。用途：macOS 的原生二进制格式</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC0xfeedface  <span class="comment">/* 32位设备上的魔数，大端模式(符合人类阅读习惯，高位数据在前) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM0xcefaedfe  <span class="comment">/* 32位、小端(高位地址在后)，CIGAM就是MAGIC反过来写，从命名上也可以看出端倪 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_MAGIC_64 0xfeedfacf  <span class="comment">/* 64位、大端 */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span>   MH_CIGAM_64 0xcffaedfe  <span class="comment">/* 64位、小端 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通用二进制格式FAT。用途：包含多种架构支持的二进制格式，只在 macOS 上支持。(在文章末尾简单介绍一下，有兴趣可以瞜一眼)</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC     0xcafebabe</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM     0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC_64  0xcafebabf</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM_64  0xbfbafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC_64) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//脚本格式。用途：主要用于 shell 脚本，但是也常用语其他解释器，如 Perl, AWK 等。也就是我们常见的脚本文件中在 `#!` 标记后的字符串，即为执行命令的指令方式，以文件的 stdin 来传递命令。</span></span><br><span class="line">  <span class="comment">// 魔数为 \x7FELF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filetype：常见的Mach-O格式的文件类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_OBJECT  0x1<span class="comment">/* 可重定位的目标文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_EXECUTE0x2<span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLIB  0x6<span class="comment">/* 动态绑定共享库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DYLINKER0x7<span class="comment">/* 动态链接编辑器，如dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_BUNDLE  0x8<span class="comment">/* 动态绑定bundle(包)文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_DSYM  0xa<span class="comment">/* 调试所用的符号文件 */</span></span></span><br></pre></td></tr></table></figure><p>举例：利用otool工具查看Mach-o文件的头部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ otool -hv bibi.decrypted </span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">   MH_MAGIC     ARM         V7  0x00     EXECUTE    59       6016   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br><span class="line"></span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    59       6744   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</span><br></pre></td></tr></table></figure><h3 id="3-3-Data"><a href="#3-3-Data" class="headerlink" title="3.3 Data"></a>3.3 Data</h3><p>数据区（Data）：Data 中每一个段（Segment）的数据都保存在此，段的概念和 ELF 文件中段的概念类似，都拥有一个或多个 Section ，用来存放数据和代码。</p><blockquote><p>Raw segment data存放了所有的原始数据，而Load commands相当于Raw segment data的索引目录</p></blockquote><h4 id="3-3-1-Segment-段"><a href="#3-3-1-Segment-段" class="headerlink" title="3.3.1 Segment(段)"></a>3.3.1 Segment(段)</h4><p>其中，LC_SEGMENT_64定义了一个64位的段，当文件加载后映射到地址空间(包括段里面节的定义)。64位段的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;          <span class="comment">/* Load Command类型，这里LC_SEGMENT_64代表将文件中64位的段映射到进程的地址空间。LC_SEGMENT_64和LC_SEGMENT的结构差别不大 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;      <span class="comment">/* 代表Load commands的大小 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];  <span class="comment">/* 16字节的段名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;       <span class="comment">/* 段映射到虚拟地址中的内存起始地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;       <span class="comment">/* 段映射到虚拟地址中的内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;      <span class="comment">/* 段在当前架构(MachO)文件中的偏移量，如果是胖二进制文件，也指的是相对于当前MachO文件的偏移 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;     <span class="comment">/* 段在文件中的大小 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   maxprot;      <span class="comment">/* 段页面的最高内存保护，用八进制表示(4=r(read)，2=w(write)，1=x(execute执行权限)) */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>   initprot;     <span class="comment">/* 段页面最初始的内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;       <span class="comment">/* 段(segment)包含的区(section)的个数(如果存在的话) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 段页面标志 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>系统将 fileoff 偏移处 filesize 大小的内容加载到虚拟内存的 vmaddr 处，大小为vmsize，段页面的权限由initprot进行初始化。它的权限可以动态改变，但是不能超过maxprot的值，例如 _TEXT 初始化和最大权限都是可读/可执行/不可写。</strong></p><p>常见的<code>LC_SEGMENT</code> Segment (cmd为<code>LC_SEGMET</code>)，其<code>segname[16]</code>有以下几种值：</p><ul><li><strong>__PAGEZERO</strong>：空指针陷阱段，映射到虚拟内存空间的第1页，用于捕捉对 NULL 指针的引用。</li><li><strong>__TEXT</strong>：代码段/只读数据段。</li><li><strong>__DATA</strong>：读取和写入数据的段。</li><li><strong>__LINKEDIT</strong>：动态链接器需要使用的信息，包括符号表、重定位表、绑定信息、懒加载信息等。</li><li><strong>__OBJC</strong>：包含会被Objective Runtime使用到的一些数据。(从Macho文档上看，他包含了一些编译器私有的节。没有任何公开的资料描述)</li></ul><h4 id="3-3-2-Section-节"><a href="#3-3-2-Section-节" class="headerlink" title="3.3.2 Section(节)"></a>3.3.2 Section(节)</h4><p>从示例图中可以看到，部分的 Segment (<code>__TEXT</code> 和 <code>__DATA</code>) 可以进一步分解为 Section。</p><p>之所以按照 Segment(段) -&gt; Section(节) 的结构组织方式，是因为在同一个 Segment 下的 Section，在内存中的权限相同(编译时，编译器把相同权限的section放在一起，成为segment)，可以不完全按照 Page 的大小进行内存对齐，节省内存的空间。而 Segment 对外整体暴露，在装载程序时，完整映射成一个vma(Virtual Memory Address)，更好的做到内存对齐，减少内存碎片（可以参考《OS X &amp; iOS Kernel Programming》第一章内容）。</p><p>Section 具体的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];   <span class="comment">/* Section 的名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;           <span class="comment">/* Section 映射到虚拟地址的偏移（所在的内存地址） */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;           <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;         <span class="comment">/* Section 在当前架构文件中的偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;          <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;         <span class="comment">/* 重定位入口的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;         <span class="comment">/* 重定位入口的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;          <span class="comment">/* Section标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;      <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;      <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;      <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合示例图，下面列举一些常见(并非全部)的 Section：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __TEXT Segment(段)下面的节：</span></span><br><span class="line">  __text              <span class="comment">// 程序可执行的代码区域</span></span><br><span class="line">  __stubs             <span class="comment">// 间接符号存根。本质上是一小段代码，跳转到懒加载/延迟绑定(lazybinding)指针表(即__DATA.la_symbol_ptr)。找到对应项指针指向的地址。</span></span><br><span class="line">  __sub_helper        <span class="comment">// 辅助函数。帮助解决懒加载符号加载，上述提到的lazybinding的表(__DATA.la_symbol_ptr)中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span></span><br><span class="line">  __objc_methname     <span class="comment">// 方法名</span></span><br><span class="line">  __objc_classname    <span class="comment">// 类名</span></span><br><span class="line">  __objc_methtype     <span class="comment">// 方法签名</span></span><br><span class="line">  __cstring           <span class="comment">// 去重后的只读的C风格字符串，包含OC的部分字符串和属性名</span></span><br><span class="line">  __const             <span class="comment">// 初始化过的常量</span></span><br><span class="line">  __unwind_info       <span class="comment">// 用户存储处理异常情况信息</span></span><br><span class="line">  __eh_frame          <span class="comment">// 调试辅助信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __DATA Segment(段)下面的节：</span></span><br><span class="line">  __data              <span class="comment">// 初始化过的可变的数据</span></span><br><span class="line">  __const             <span class="comment">// 没有初始化过的常量</span></span><br><span class="line">  __bss               <span class="comment">// 没有初始化的静态变量</span></span><br><span class="line">  __common            <span class="comment">// 没有初始化过的符号声明</span></span><br><span class="line">  __nl_symbol_ptr     <span class="comment">// 非延迟导入/非懒加载(lazy-binding)符号指针表，每个表项中的指针都指向一个在dyld加载过程中，搜索完成的符号。即在dyld加载时会立即绑定值。</span></span><br><span class="line">  __la_symbol_ptr     <span class="comment">// 延迟导入/懒加载(lazy-binding)符号指针表，每个表项中的指针一开始指向stub_helper。在第 1 次调用时才会绑定值。</span></span><br><span class="line">  __got               <span class="comment">// 非懒加载全局指针表</span></span><br><span class="line">  __mod_init_func     <span class="comment">// 初始化/constructor(构造)函数</span></span><br><span class="line">  __mod_term_func     <span class="comment">// destructor(析构)函数</span></span><br><span class="line">  __cfstring          <span class="comment">// OC字符串</span></span><br><span class="line">  __objc_classlist    <span class="comment">// 程序中的类列表</span></span><br><span class="line">  __objc_nlclslist    <span class="comment">// 程序中自己实现了+load方法的类</span></span><br><span class="line">  __objc_protolist    <span class="comment">// 协议的列表</span></span><br><span class="line">  __objc_classrefs    <span class="comment">// 被引用的类列表</span></span><br><span class="line">  __objc_ivar         <span class="comment">// 成员变量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-stubs-与-stub-helper"><a href="#3-4-stubs-与-stub-helper" class="headerlink" title="3.4 __stubs 与 __stub_helper"></a>3.4 <code>__stubs</code> 与 <code>__stub_helper</code></h3><blockquote><p>用来实现 LazyBind 的两个section：<code>__TEXT.__stubs</code>、<code>__TEXT.__stub_helper</code></p></blockquote><p>在 wikipedia 有一个关于 <a href="https://en.wikipedia.org/wiki/Method_stub">Method stub</a> 的词条，大意就是：Stub 是指用来替换一部分功能的程序段。桩程序可以用来模拟已有程序的行为（比如一个远端机器的过程）或是对将要开发的代码的一种临时替代。</p><p>总结来说：</p><ul><li>stub就是一段代码，功能为：跳转到 <code>__DATA.__la_symbol_ptr</code>( <code>__DATA</code> Segment 中的 <code>__la_symbol_ptr</code> Section) 对应表项的数据，所指向的地址。</li><li><code>__la_symbol_ptr</code> 里面的所有表项的数据在初始时都会被 binding 成 <code>__stub_helper</code>。</li><li>当懒加载符号第一次使用到的时候，按照上面的结构，会跳转到<code>__stub_helper</code>这个section的代码，然后代码中会调用<code>dyld_stub_binder</code>来执行真正的bind。 bind结束后，就将<code>__la_symbol_ptr</code>中该懒加载符号 原本对应的指向<code>__stub_helper</code>的地址 修改为 符号的真实地址。</li><li>之后的调用中，虽然依旧会跳到 <code>__stub</code> 区域，但是 <code>__la_symbol_ptr</code>表由于在之前的调用中获取到了符号的真实地址而已经修正完成，所以无需在进入 <code>dyld_stub_binder</code> 阶段，可以直接使用符号。</li></ul><p>这样就完成了LazyBind的过程。Stub 机制 其实和 <code>wikipedia</code> 上的说法一致，设置一个桩函数(模拟、占位函数)并采用 <strong>lazy</strong> 思想做成延迟 binding 的流程。</p><p>在《深入解析 Mac OS X &amp; iOS操作系统》中有详细的验证，也可以参考<a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho (1)</a> 自己动手验证一下。</p><h3 id="3-5-Load-Command"><a href="#3-5-Load-Command" class="headerlink" title="3.5 Load Command"></a>3.5 Load Command</h3><p>Mach-O文件头中包含了非常详细的指令，这些指令在被调用时清晰地指导了如何设置并加载二进制数据。这些指令，或称为“加载命令”，紧跟在基本的mach_header之后。</p><p>每一条命令，在<code>load.c</code>文件中，都有对应的结构体，来记录信息。共同点是都采用“<code>类型-长度-值</code>”的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmd;       <span class="comment">/* 32位的cmd值(表示类型) ，下面列举了部分 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>cmdsize;   <span class="comment">/* 32位的cmdsize值(32位二进制为4的倍数，64位二进制为8的倍数) */</span></span><br><span class="line">  ...                      <span class="comment">/* 记录命令本身的一些信息 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面列举一些load command的类型(对应的cmd值)，这里只列举了部分，全面的可以看源码，总共50多种load command。按照加载命令是由内核加载器、动态链接器处理分开记录。</span></span><br><span class="line"><span class="comment">// 内核加载器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SEGMENT                0x1  <span class="comment">/* 定义一个段(Segment)，加载后被映射到内存中，包括里面的节(Section) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLINKER          0xe  <span class="comment">/* 默认的加载器路径。通常路径是“/usr/lib/dyld” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_UUID                   0x1b   <span class="comment">/* 用于标识Mach-0文件的ID，匹配二进制文件与符号表。在分析崩溃堆栈信息能用到，通过地址在符号表中找到符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_CODE_SIGNATURE         0x1d  <span class="comment">/* 代码签名信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ENCRYPTION_INFO_64     0x2C   <span class="comment">/* 文件是否加密的标志，加密内容的偏移和大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态链接器处理的加载命令：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SYMTAB                 0x2  <span class="comment">/* 为文件定义符号表和字符串表，在链接文件时被链接器使用，同时也用于调试器映射符号到源文件。符号表定义的本地符号仅用于调试，而已定义和未定义的 external 符号被链接器使用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYSYMTAB               0xb  <span class="comment">/* 将符号表中给出符号的额外符号信息提供给动态链接器。 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_LOAD_DYLIB             0xc    <span class="comment">/* 加载动态链接库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_ID_DYLIB               0xd  <span class="comment">/* 动态库的标识，包括动态库名称、当前版本号、兼容版本号。可以使用“otool-L xxx”命令查看 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_RPATH                 (0x1c | LC_REQ_DYLD)    <span class="comment">/* RunpathSearchPaths，@rpath搜索的路径 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_DYLD_INFO              0x22  <span class="comment">/* compressed dyld information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DYLD_INFO_ONLY        (0x22 | LC_REQ_DYLD)  <span class="comment">/* 记录了有关链接的重要信息，包括在__LINKEDIT中动态链接相关信息的具体偏移和大小。ONLY表示这个加载指令是程序运行所必需的，如果旧的链接器无法识别它，程序就会出错 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_VERSION_MIN_IPHONEOS   0x25   <span class="comment">/* 系统要求的最低版本 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_FUNCTION_STARTS        0x26   <span class="comment">/* 函数起始地址表，使调试器和其他程序能很容易地看到一个地址是否在函数内 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_MAIN                  (0x28 | LC_REQ_DYLD)    <span class="comment">/* 程序的入口。dyld获取该地址，然后跳转到该处执行。replacement for LC_UNIXTHREAD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_DATA_IN_CODE           0x29   <span class="comment">/* 定义在代码段内的非指令的表   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LC_SOURCE_VERSION         0x2A   <span class="comment">/* 构建二进制文件的源代码版本号 */</span></span></span><br></pre></td></tr></table></figure><p>有一些命令是由<code>内核加载器</code>(定义在<code>bsd/kern/mach_loader.c</code>文件中) 直接使用的， 其他命令是由<code>动态链接器</code>处理的。</p><img src="/images/compilelink/14.png" alt="12" style="zoom:70%;" /><img src="/images/compilelink/15.png" alt="12" style="zoom:70%;" /><p>在Mach-O文件加载解析时，多个Load Command会告诉操作系统应当如何加载文件中每个Segment的数据，对系统内核加载器和动态链接器起引导作用。(不同的数据对应不同的加载命令，可以看到<code>segment_command_64</code>、<code>symtab_command</code>、<code>dylib_command</code>等，下面我们会讲解Segment的加载命令，下一节讲静态链接时，会涉及符号表symtab的加载命令)。</p><p>下面，以三个内核加载器负责解析处理的load command，来简单看下：</p><h4 id="3-5-1-LC-LOAD-DYLIB与LC-ID-DYLIB"><a href="#3-5-1-LC-LOAD-DYLIB与LC-ID-DYLIB" class="headerlink" title="3.5.1 LC_LOAD_DYLIB与LC_ID_DYLIB"></a>3.5.1 LC_LOAD_DYLIB与LC_ID_DYLIB</h4><p>可执行文件（MH_EXECUTE类型）的Mach-O都会存在LC_LOAD_DYLIB类型的Load Command，该Load Command指定了当前Mach-O需要依赖的动态库（可以是系统的动态库也可以是开发者创建的动态库）。</p><p>LC_LOAD_DYLIB类型的Load Command在内存中对应struct dylib_command结构，dylib_command结构包含struct dylib结构，struct dylib结构中name字段标记了动态库的路径。那么这个路径是从哪里来的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态链接库由两个东西标识。</span></span><br><span class="line"><span class="comment">   路径名（为执行而找到的库的名称）和兼容性版本号。 路径名必须匹配，并且库的用户中的兼容性号必须大于或等于正在使用的库。 </span></span><br><span class="line"><span class="comment">   时间戳用于记录库的构建和复制到用户的时间，因此它可以用来确定运行时使用的库是否与构建程序时使用的完全相同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>  <span class="title">name</span>;</span><span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;<span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;<span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version;<span class="comment">/* library&#x27;s compatibility vers number*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 动态链接库（mach header中的filetype == MH_DYLIB）包含一个 dylib_command (cmd == LC_ID_DYLIB) 来标识库。</span></span><br><span class="line"><span class="comment"> 使用动态链接库的模块包含它使用到的每个动态库的 dylib_command（cmd == LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB 或 LC_REEXPORT_DYLIB）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* includes pathname string */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span><span class="title">dylib</span>;</span><span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LC_ID_DYLIB：动态库的Mach-O是MH_DYLIB类型的，一个动态库中必须包含一个LC_ID_DYLIB类型的Load Command（一般位于__LINKEDIT之后），它在内存中也是一个struct dylib_command结构，会有name字段。</p><ul><li>这里的dylib_command信息会在LINK时作为LC_LOAD_DYLIB类型的Load Command插入进可执行文件（MH_EXECUTE 类型的Mach-O）中。</li></ul><p>打开APP时，dyld会先递归遍历所有类型为LC_LOAD_DYLIB的Load Command从而查找依赖库，查找的路径即是由对应的dylib_command结构的name指定，一般为@rpath/DYNAME.framework/DYNAME。如果在指定各种查找路径都找不到，就会出现”dyld: Library not loaded”错误。</p><h4 id="3-5-2-LC-CODE-SIGNATURE-数字签名"><a href="#3-5-2-LC-CODE-SIGNATURE-数字签名" class="headerlink" title="3.5.2 LC_CODE_SIGNATURE(数字签名)"></a>3.5.2 LC_CODE_SIGNATURE(数字签名)</h4><p>Mach-O二进制文件有一个重要特性就是可以进行数字签名。尽管在 OS X 中仍然没怎么使用数字签名，不过由于代码签名和新改进的沙盒机制绑定在一起，所以签名的使用率也越来越高。在 iOS 中，代码签名是强制要求的，这也是苹果尽可能对系统封锁的另一种尝试：在 iOS 中只有苹果自己的签名才会被认可。在 OS X 中，code sign(1) 工具可以用于操纵和显示代码签名。man手册页，以及 Apple’s code signing guide 和 Mac OS X Code Signing In Depth文档都从系统管理员的角度详细解释了代码签名机制。</p><p><code>LC_CODE_SIGNATURE</code> 包含了 Mach-O 二进制文件的代码签名，如果这个签名和代码本身不匹配(或者如果在iOS上这条命令不存在)，那么内核会立即给进程发送一个SIGKILL信号将进程杀掉，没有商量的余地，毫不留情。</p><p>在iOS 4之前，还可以通过两条sysctl(8)命令覆盖负责强制执行(利用内核的MAC，即Mandatory AccessControl)的内核变量，从而实现禁用代码签名检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w security.mac.proc_enforce &#x3D; 0 &#x2F;&#x2F;禁用进程的MAC</span><br><span class="line">sysctl -w security.mac.vnode_enforce&#x3D;0 &#x2F;&#x2F;禁用VNode的MAC</span><br></pre></td></tr></table></figure><p>而在之后版本的iOS中，苹果意识到只要能够获得root权限，越狱者就可以覆盖内核变量。因此这些变量变成了只读变量。untethered越狱(即完美越狱)因为利用了一个内核漏洞所以可以修改这些变量。由于这些变量的默认值都是启用签名检查，所以不完美越狱会导致非苹果签名的应用程序崩溃——除非i设备以完美越狱的方式引导。</p><p>此外，通过 Saurik 的 ldid 这类工具可以在 Mach-O 中嵌入伪代码签名。这个工具可以替代OS X的code sign(1)，允许生成自我签署认证的伪签名。这在iOS中尤为重要，因为签名和沙盒模型的应用程序“entitlement”绑定在一起， 而后者在iOS中是强制要求的。entitlement 是声明式的许可(以plist的形式保存)，必须内嵌在Mach-O中并且通过签名盖章，从而允许执行安全敏感的操作时具有运行时权限。</p><p>OS X 和 iOS 都有一个特殊的系统调用csops(#169)用于代码签名的操作</p><h4 id="3-5-3-LC-SEGMENT-进程虚拟内存设置"><a href="#3-5-3-LC-SEGMENT-进程虚拟内存设置" class="headerlink" title="3.5.3 LC_SEGMENT(进程虚拟内存设置)"></a>3.5.3 LC_SEGMENT(进程虚拟内存设置)</h4><p>LC_SEGMENT(或LC_SEGMENT_64) 命令是最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些“段”直接从Mach-O二进制文件加载到内存中。</p><p>每一条LC_SEGMENT[64] 命令都提供了段布局的所有必要细节信息。见上文的数据结构成员变量。</p><p>有了LC_SEGMENT命令，设置进程虚拟内存的过程就变成遵循LC_SEGMENT命令的简单操作。对于每一个段，将文件中相应的内容加载到内存中：<strong>从偏移量为 fileoff 处加载 filesize 字节到虚拟内存地址 vmaddr 处的 vmsize 字节</strong>。每一个段的页面都根据 initprot 进行初始化，initprot 指定了如何通过读/写/执行位初始化页面的保护级别。段的保护设置可以动态改变，但是不能超过 maxprot 中指定的值(在iOS中，+x和+w是互斥的)。</p><h4 id="3-5-4-LC-MAIN-设置主线程入口地址"><a href="#3-5-4-LC-MAIN-设置主线程入口地址" class="headerlink" title="3.5.4 LC_MAIN(设置主线程入口地址)"></a>3.5.4 LC_MAIN(设置主线程入口地址)</h4><p>从Mountain Lion开始，一条新的加载命令<code>LC_MAIN</code>替代了<code>LC_UNIX_THREAD</code>命令。</p><ul><li>后者的作用是：开启一个unix线程，初始化栈和寄存器，通常情况下，除了指令指针(Intel的IP)或程序计数器(ARM的r15)之外，所有的寄存器值都为0。</li><li>前者作用是<strong>设置程序主线程的入口点地址和栈大小</strong>。</li></ul><p>这条命令比LC_UNIXTHREAD命令更实用一些， 因为无论如何除了程序计数器之外所有的寄存器都设置为0了。由于没有LC_UNIXTHREAD命令， 所以不可以在之前版本的 OS X 上运行使用了LC_MAIN的二进制文件(在加载时会导致dyld(1)崩溃)。</p><img src="/images/compilelink/16.png" alt="12" style="zoom:90%;" /><p>LC_Main对应的加载命令如下，记录了可执行文件的入口函数<code>int main(int argc, char * argv[])</code>的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmd;        <span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  cmdsize;    <span class="comment">/* 24 */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  entryoff;   <span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">  <span class="keyword">uint64_t</span>  stacksize;  <span class="comment">/* if not zero, initial stack size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从定义上可以看到入口函数的地址计算：<code>Entry Point = vm_addr(__TEXT) + entryOff + Slide</code></p><p>从<a href="https://opensource.apple.com/source/dyld/">dyld的源码</a>里能看到对Entry Point的获取和调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dyld</span><br><span class="line">  ▼ __dyld_start  <span class="comment">// 源码在dyldStartup.s这个文件，用汇编实现</span></span><br><span class="line">    ▼ dyldbootstrap::start()   <span class="comment">// dyldInitialization.cpp</span></span><br><span class="line">      ▼ dyld::_main()</span><br><span class="line">        ▼ <span class="comment">//函数的最后，调用 getEntryFromLC_MAIN，从 Load Command 读取LC_MAIN入口，如果没有LC_MAIN入口，就读取LC_UNIXTHREAD，然后跳到主程序的入口处执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dyldbootstrap &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line">    <span class="comment">// sets up some registers and call this function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">uintptr_t</span></span><br><span class="line">    _main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">            <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">            <span class="keyword">uintptr_t</span>* startGlue) &#123;</span><br><span class="line">        <span class="comment">// find entry point for main executable</span></span><br><span class="line">        result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下这几种load command所表示的信息。关于进程地址空间分布、线程入口在第四节 —— 装载会从进程启动到运行详细梳理一下流程。</p><h2 id="四、通用二进制格式（Universal-Binary）"><a href="#四、通用二进制格式（Universal-Binary）" class="headerlink" title="四、通用二进制格式（Universal Binary）"></a>四、通用二进制格式（Universal Binary）</h2><p>通常也被称为<code>胖二进制格式（Fat Binary）</code>，Apple 提出这个概念是为了解决一些历史原因，macOS（更确切的应该说是 OS X）最早是构建于 PPC 架构智商，后来才移植到 Intel 架构（从 Mac OS X Tiger 10.4.7 开始），通用二进制格式的二进制文件可以在 PPC 和 x86 两种处理器上执行。</p><p>说到底，通用二进制格式只不过是对多架构的二进制文件的打包集合文件，而 macOS 中的多架构二进制文件也就是适配不同架构的 Mach-O 文件。即一个通用二进制格式包含了很多个 Mach-O 格式文件。它有以下特点：</p><ul><li>因为需要存储多种架构的代码，所以通用二进制文件要比单架构二进制文件要大</li><li>因为两种种架构之间可以共用一些资源，所以两种架构的通用二进制文件大小不会达到单一架构版本的两倍。</li><li>运行过程中只会调用其中的部分代码，所以运行起来不会占用额外的内存</li></ul><p><strong>Fat Header</strong> 的数据结构在 <code>&lt;mach-o/fat.h&gt;</code> 头文件中有定义，可以参看 <code>/usr/include/mach-o/fat.h</code> 找到定义头：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC    0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM    0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;           <span class="comment">/* FAT_MAGIC 或 FAT_MAGIC_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nfat_arch;       <span class="comment">/* 结构体实例的个数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>     cputype;      <span class="comment">/* cpu 说明符 (int) */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>  cpusubtype;   <span class="comment">/* 指定 cpu 确切型号的整数 (int) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       offset;       <span class="comment">/* CPU 架构数据相对于当前文件开头的偏移值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       size;         <span class="comment">/* 数据大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       align;        <span class="comment">/* 数据内润对其边界，取值为 2 的幂 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>cputype</code> 和 <code>cpusubtype</code> 两个字段这里不讲述，可以参看 <code>/usr/include/mach/machine.h</code> 头中对其的定义，另外 <a href="https://developer.apple.com/documentation/kernel/mach_header?language=objc">Apple 官方文档</a>中也有简单的描述。</p><p>在 <code>fat_header</code> 中，<code>magic</code> 也就是我们之前在表中罗列的 <em>magic</em> 标识符，也可以类比成 UNIX 中 ELF 文件的 <em>magic</em> 标识。加载器会通过这个符号来判断这是什么文件，通用二进制的 <em>magic</em> 为 <code>0xcafebabe</code>。<code>nfat_arch</code> 字段指明当前的通用二进制文件中包含了多少个不同架构的 Mach-O 文件。<code>fat_header</code> 后会跟着多个 <code>fat_arch</code>，并与多个 Mach-O 文件及其描述信息（文件大小、CPU 架构、CPU 型号、内存对齐方式）相关联。</p><p>这里可以通过 <code>file</code> 命令来查看简要的架构信息，这里以 iOS 平台 WeChat 4.5.1 版本为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ file Desktop/WeChat.app/WeChat</span><br><span class="line">Desktop/WeChat.app/WeChat: Mach-O universal binary with 2 architectures: [arm_v7: Mach-O executable arm_v7] [arm64]</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture armv7):    Mach-O executable arm_v7</span><br><span class="line">Desktop/WeChat.app/WeChat (<span class="keyword">for</span> architecture arm64):    Mach-O 64-bit executable arm64</span><br></pre></td></tr></table></figure><p>进一步，也可以使用 <code>otool</code> 工具来打印其 <code>fat_header</code> 详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~ otool -f -V Desktop/WeChat.app/WeChat</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic FAT_MAGIC</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture armv7</span><br><span class="line">    cputype CPU_TYPE_ARM</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM_V7</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 16384</span><br><span class="line">    size 56450224</span><br><span class="line">    align 2^14 (16384)</span><br><span class="line">architecture arm64</span><br><span class="line">    cputype CPU_TYPE_ARM64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_ARM64_ALL</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 56475648</span><br><span class="line">    size 64571648</span><br><span class="line">    align 2^14 (16384)</span><br></pre></td></tr></table></figure><p>之后我们用 <em>Synalyze It!</em> 来查看 WeChat 的 Mach64 Header 的效果：</p><img src="/images/compilelink/17.jpg" alt="12" style="zoom:80%;" /><ul><li>  从第一个段中得到 <code>magic = 0xcafebabe</code> ，说明是 <code>FAT_MAGIC</code>。</li><li>  第二段中所存储的字段为 <code>nfat_arch = 0x00000002</code>，说明该 App 中包含了两种 CPU 架构。</li><li>  后续的则是 <code>fat_arch</code> 结构体中的内容，<code>cputype(0x0000000c)</code>、<code>cpusubtype(0x00000009)</code>、<code>offset(0x00004000)</code>、<code>size(0x03505C00)</code> 等等。如果只含有一种 CPU 架构，是没有 fat 头定义的，这部分则可跳过，从而直接过去 <code>arch</code> 数据。</li></ul><blockquote><p><strong>注意，在mach-o中，数据结构中的地址表示：如果是value、address等，那一般是绝对地址；如果是偏移量offset等，一般都是相对于目标文件/可执行文件（注意，尤其是后者，起始地址不会是0，寻址时要加上起始地址）。</strong></p></blockquote><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://juejin.im/post/6844903959618912263#heading-10">iOS逆向学习之四（初识Mach-O）</a></li><li><a href="https://www.desgard.com/iOS-Source-Probe/C/mach-o/Mach-O%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%B4%A2.html">Mach-O 文件格式探索</a></li><li><a href="">《iOS应用逆向与安全》— 刘培庆</a></li><li><a href="http://satanwoo.github.io/2017/06/13/Macho-1/">深入剖析Macho(1)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇说到源码经过预处理、编译、汇编之后生成目标文件，这一章介绍一下iOS、Mac OS中目标文件的格式&lt;code&gt;Mach-O的结构&lt;/code&gt;，方便了解之后的&lt;code&gt;链接&lt;/code&gt;生成可执行文件的过程。&lt;/p&gt;
&lt;p&gt;先附上相关源码地址：与Mach-O 文件格</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>(一) Clang/LLVM 介绍、OC 程序的编译过程</title>
    <link href="https://tenloy.github.io/2021/10/05/compile-clang-llvm.html"/>
    <id>https://tenloy.github.io/2021/10/05/compile-clang-llvm.html</id>
    <published>2021-10-05T04:25:45.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编译、链接工具-—-Clang-LLVM"><a href="#一、编译、链接工具-—-Clang-LLVM" class="headerlink" title="一、编译、链接工具 — Clang/LLVM"></a>一、编译、链接工具 — Clang/LLVM</h2><blockquote><p><a href="https://llvm.org/">官网定义：</a></p><ul><li>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies(LLVM项目是一系列分模块、可重用的编译<strong>工具链</strong>). Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</li><li>Clang is an “LLVM native” C/C++/Objective-C compiler. </li></ul></blockquote><h3 id="1-1-LLVM是什么"><a href="#1-1-LLVM是什么" class="headerlink" title="1.1 LLVM是什么"></a>1.1 LLVM是什么</h3><h4 id="1-1-1-诞生"><a href="#1-1-1-诞生" class="headerlink" title="1.1.1 诞生"></a>1.1.1 诞生</h4><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的克里斯·拉特纳(Chris Lattner，twitter为 <a href="https://twitter.com/clattner_llvm">clattner_llvm</a>） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。</p><p>2005年，由于GCC 对于 Objective-C 的支持比较差，效率和性能都没有办法达到苹果公司的要求，而且它还难以推动 GCC 团队。于是，苹果公司决定自己来掌握编译相关的工具链，于是将Chris Lattner招入麾下，发起了 Clang 软件项目。</p><ul><li>Clang 作为 LLVM 编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用LLVM编译成平台相关的机器语言。Clang支持C、C++、Objective C。</li><li>测试证明Clang编译Objective-C代码时速度为GCC的3倍，还能针对用户发生的编译错误准确地给出建议。</li><li>此后，苹果使用的 GCC 全面替换成了 LLVM。</li></ul><p>2010年，Chris Lattner开始主导开发 Swift 语言。这也使得 Swift 这门集各种高级语言特性的语言，能够在非常高的起点上，出现在开发者面前。</p><p>2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p><h4 id="1-1-2-概述"><a href="#1-1-2-概述" class="headerlink" title="1.1.2 概述"></a>1.1.2 概述</h4><p>llvm有广义和狭义两种定义：</p><ul><li>在广义中，llvm特指一整个编译器框架，<strong>是一个模块化和可重用的编译器和工具链技术的集合</strong>，由前端、优化器、后端组成，clang只是用于c/c++的一种前端，llvm针对不同的语言可以设计不同的前端，同样的针对不同的平台架构（amd，arm，misp），也会有不同后端设计</li><li>在狭义中 ，特指llvm后端，指优化器（pass）对IR进行一系列优化直到目标代码生成的过程</li></ul><p>llvm特点：</p><ul><li>模块化</li><li>统一的中间代码IR，而前端、后端可以不一样。而GCC的前端、后端耦合在了一起，所以支持一门新语言或者新的平台，非常困难。</li><li>功能强大的Pass系统，根据依赖性自动对Pass（包括分析、转换和代码生成Pass）进行排序，管道化以提高效率。</li></ul><h4 id="1-1-3-LLVM的子项目"><a href="#1-1-3-LLVM的子项目" class="headerlink" title="1.1.3 LLVM的子项目"></a>1.1.3 LLVM的子项目</h4><p>简单罗列LLVM几个主要的子项目，详见<a href="https://llvm.org/">官网</a>：</p><ul><li><p>LLVM Core libraries：LLVM核心库提供了一个独立于源和目标架构的现代<a href="https://llvm.org/docs/Passes.html">优化器optimizer</a>，以及对许多流行cpu(以及一些不太常见的cpu)的<a href="https://llvm.org/docs/CodeGenerator.html">代码生成(code generation)</a>支持。这些库是围绕一种被称为LLVM中间表示(“LLVM IR”)的良好指定的代码表示构建的。</p></li><li><p><strong>Clang</strong>：一个 C/C++/Objective-C 编译器，提供高效快速的编译效率，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。(见下文详述)</p></li><li><p>lld： 是LLVM开发一个内置的，平台独立的链接器，去除对所有第三方链接器的依赖。在2017年5月，lld已经支持ELF、PE/COFF、和Mach-O。在lld支持不完全的情况下，用户可以使用其他项目，如 GNU ld 链接器。 </p><p>lld支持链接时优化。当LLVM链接时优化被启用时，LLVM可以输出bitcode而不是本机代码，而本机代码生成由链接器优化处理。</p></li><li><p>LLDB：基于 LLVM 和 Clang提供的库构建的一个优秀的本地调试器，使用了 Clang ASTs、表达式解析器、LLVM JIT、LLVM 反汇编器等。</p></li></ul><h3 id="1-2-Clang"><a href="#1-2-Clang" class="headerlink" title="1.2 Clang"></a>1.2 Clang</h3><p>从<a href="http://llvm.org/svn/llvm-project/cfe/trunk/lib/">Clang的源码</a>目录中可以大致看出Clang提供的功能：</p><img src="/images/compilelink/01.png" alt="01" style="zoom:80%;" /><h4 id="1-2-1-Clang提供了哪些功能？"><a href="#1-2-1-Clang提供了哪些功能？" class="headerlink" title="1.2.1 Clang提供了哪些功能？"></a>1.2.1 Clang提供了哪些功能？</h4><p>Clang 为一些需要分析代码语法、语义信息的工具提供了基础设施。分别是：</p><ul><li><p><strong>LibClang</strong>。LibClang提供了一个稳定的高级 C 接口，Xcode 使用的就是 LibClang。LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有 Token、遍历语法树、代码补全等。由于 API 很稳定，Clang 版本更新对其 影响不大。但是，LibClang 并不能完全访问到 Clang AST 信息。</p></li><li><p><strong>Clang Plugins</strong>。可以在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。插件是在运 行时由编译器加载的动态库，方便集成到构建系统中。<br>使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。<br>应用：实现命名规范、代码规范等一些扩展功能</p></li><li><p><strong>LibTooling</strong>。是一个 C++ 接口，所写的工具不依赖于构建系统，可以作为一个命令单独使用。与 Clang Plugins 相比，LibTooling 无法影响编译过程；与 LibClang 相比，LibTooling 的接口没有那么稳定。<br>应用：做代码转换，比如把 OC 转 JavaScript 或 Swift；代码检查。</p></li></ul><h4 id="1-2-2-Clang的优点"><a href="#1-2-2-Clang的优点" class="headerlink" title="1.2.2 Clang的优点"></a>1.2.2 Clang的优点</h4><p>Clang 是 C、C++、Objective-C 的编译前端，而 Swift 有自己的编译前端 （也就是 Swift 前端多出的 SIL optimizer）。Clang 有哪些优势？</p><ul><li>对于使用者来说，Clang 编译的速度非常快，对内存的使用率非常低，并且兼容 GCC。</li><li>对于代码诊断来说， Clang 也非常强大，Xcode 也是用的 Clang。使用 Clang 编译前端，可以精确地显示出问题所在的行和具体位置，并且可以确切地说明出现这个问题的原因，并指出错误的类型是什么，使得我们可以快速掌握问题的细节。这样的话，我们不用看源码，仅通过 Clang 突出标注的问题范围也能够了解到问题的情况。</li><li>Clang 对 typedef 的保留和展开也处理得非常好。typedef 可以缩写很长的类型，保留 typedef 对于粗粒度诊断分析很有帮助。但有时候，我们还需要了解细节，对 typedef 进行展开即可。</li><li>Fix-it 提示也是 Clang 提供的一种快捷修复源码问题的方式。在宏的处理上，很多宏都是深度嵌套的， Clang 会自动打印实例化信息和嵌套范围信息来帮助你进行宏的诊断和分析。</li><li>Clang 的架构是模块化的。除了代码静态分析外，利用其输出的接口还可以开发用于代码转义、代码生成、代码重构的工具，方便与 IDE 进行集成。</li></ul><p>Clang 是基于 C++ 开发的，如果你想要了解 Clang 的话，需要有一定的 C++ 基础。但是，Clang 源码本身质量非常高，有很多值得学习的地方，比如说目录清晰、功能解耦做得很好、分类清晰方便组合和复用、代码风格统一而且规范、注释量大便于阅读等。</p><h3 id="1-3-LLVM架构-三段式"><a href="#1-3-LLVM架构-三段式" class="headerlink" title="1.3 LLVM架构(三段式)"></a>1.3 LLVM架构(三段式)</h3><p>传统的编译器的架构如下:</p><img src="/images/compilelink/04.png" alt="01" style="zoom:100%;" /><p>LLVM不同的就是对于不同的语言它都提供了同一种中间表示。LLVM的架构如下，</p><img src="/images/compilelink/05.png" alt="01" style="zoom:75%;" /><p>当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端，其它部分完成可以复用，不用重新设计。在基于LLVM进行代码混淆时，只需要关注中间层代码(IR)表示。</p><h3 id="1-4-Clang-LLVM架构"><a href="#1-4-Clang-LLVM架构" class="headerlink" title="1.4 Clang-LLVM架构"></a>1.4 Clang-LLVM架构</h3><p>Clang-LLVM架构，即用Clang作为前端的LLVM(编译工具集)。</p><p>Clang-LLVM下，一个源文件的编译过程：</p><img src="/images/compilelink/02.png" alt="01" style="zoom:65%;" /><p>iOS 开发完整的编译流程图：</p><img src="/images/compilelink/03.png" alt="01" style="zoom:80%;" /><p>LLVM架构的主要组成部分：</p><ul><li><strong>前端</strong>：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如gcc，clang(Clang-LLVM)。<a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>支持三种表达形式：<ul><li>内存中的格式(in-memory compiler IR)</li><li>磁盘上的二进制格式(on-disk bitcode，<code>.bc</code>后缀)</li><li>便于阅读的文本格式，类似于汇编语言(<code>.ll</code>后缀，其有自己的语法)</li></ul></li><li><strong>优化</strong>(Optimizations)：被实现为遍历程序的某些部分以收集信息或转换程序的passes。<a href="https://llvm.org/docs/Passes.html">文档链接</a><ul><li>pass(v.通过/传递/变化 n.<strong>通道</strong>/<strong>流程</strong>/<strong>阶段</strong>) ：pass就是“遍历一遍IR，同时可以对它做一些操作”的意思。是 LLVM 优化(optimize)工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</li><li>文档中将LLVM提供的passe分为三类。<ul><li>分析(analysis) passes：计算出一些信息，可以用于调试、程序可视化，也可以被其他passes使用。</li><li>转换(transform) passes：可以使用 analysis passes，也可使其无效。这类passes都会以某种方式改变程序。</li><li>实用(utility) passes：提供了一些实用性的功能，但不适合分类。例如，将函数提取到bitcode或将模块写入bitcode的passes既不是analysis也不是transform。</li></ul></li><li>一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。我们可以自己编写Pass，做一些代码混淆优化等操作。</li></ul></li><li><strong>后端</strong>：后端用来生成实际的机器码。至3.4版本的LLVM已经支持多种后端指令集，比如主流的x86、x86-64、z/Architecture、ARM和PowerPC等。</li></ul><h3 id="1-5-应用"><a href="#1-5-应用" class="headerlink" title="1.5 应用"></a>1.5 应用</h3><ul><li>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</li><li>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</li><li>Gallium3D 中使用 LLVM 进行 JIT 优化</li><li>Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度</li><li>LLVM-Lua 用LLVM 来编译 lua 代码</li><li>gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</li></ul><p>下面，通过具体的代码、命令，来看一下iOS中源代码详细的编译、链接过程</p><h2 id="二、编译、静态链接过程"><a href="#二、编译、静态链接过程" class="headerlink" title="二、编译、静态链接过程"></a>二、编译、静态链接过程</h2><blockquote><p>从源码到可执行文件 — iOS应用编译、静态链接过程</p></blockquote><p>我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击run就完事了，那么在点击run之后编译器背后又做了哪些事情呢？</p><p>我们先来一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINEEight 8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eight = DEFINEEight;</span><br><span class="line">    <span class="keyword">int</span> six = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> rank = eight + six;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rank);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个文件，我们可以通过命令行直接编译，然后链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o</span><br><span class="line">xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main</span><br></pre></td></tr></table></figure><p>然后将该可执行文件copy到手机目录 /usr/bin 下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xx-iPhone:/usr/bin root<span class="comment"># ./main</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>下面深入剖析其中的过程。</p><h3 id="Clang常用命令与参数"><a href="#Clang常用命令与参数" class="headerlink" title="Clang常用命令与参数"></a>Clang常用命令与参数</h3><p><a href="https://clang.llvm.org/docs/ClangCommandLineReference.html">参考链接</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看编译的步骤</span></span><br><span class="line">clang -ccc-print-phases main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewrite Objective-C source to C++，将OC源代码重写为C++(仅供参考，与真正的运行时代码还是有细微差别的)</span></span><br><span class="line"><span class="comment">// 如果想了解真正的代码，可以使用-emit-llvm参数查看.ll中间代码</span></span><br><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看操作内部命令</span></span><br><span class="line">clang -##<span class="meta"># main.m -o main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接生成可执行文件</span></span><br><span class="line">clang main.m <span class="comment">// 默认生成的文件名为a.out</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">    -cc1：Clang编译器前端具有几个额外的Clang特定功能，这些功能不通过GCC兼容性驱动程序接口公开。 -cc1参数表示将使用编译器前端，而不是驱动程序。 clang -cc1功能实现了核心编译器功能。</span></span><br><span class="line"><span class="comment">-E：只进行预编译处理(preprocessor)</span></span><br><span class="line"><span class="comment">-S：只进行预编译、编译工作</span></span><br><span class="line"><span class="comment">-c：只进行预处理、编译、汇编工作</span></span><br><span class="line"><span class="comment">-fmodules：允许modules的语言特性。</span></span><br><span class="line"><span class="comment">在使用#include、#import时，会看到预处理时已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如Foundation。</span></span><br><span class="line"><span class="comment">所以有了pch预处理文件，可以在这里去引入一些通用的头文件。</span></span><br><span class="line"><span class="comment">后来Xcode新建的项目里面去掉了pch文件，引入了moduels的概念，把一些通用的库打成modules的形式，然后导入。现在Xcode中默认是打开的，即编译源码时会加上-fmodules参数。也是因为modules机制的出现，pch不再默认自动创建。</span></span><br><span class="line"><span class="comment">使用了该参数，在导入库的地方，只需要 @import Foundation; 就行</span></span><br><span class="line"><span class="comment">可以看到使用了@import之后，clang -fmodules xx 生成的文件中，不再有上万行的系统库的代码引入，精简了很多。</span></span><br><span class="line"><span class="comment">-fsyntax-only：防止编译器生成代码,只是语法级别的说明和修改</span></span><br><span class="line"><span class="comment">-Xclang &lt;arg&gt;：向clang编译器传递参数</span></span><br><span class="line"><span class="comment">-dump-tokens：运行预处理器,拆分内部代码段为各种token</span></span><br><span class="line"><span class="comment">-ast-dump：构建抽象语法树AST,然后对其进行拆解和调试</span></span><br><span class="line"><span class="comment">-fobjc-arc：为OC对象生成retain和release的调用</span></span><br><span class="line"><span class="comment">-emit-llvm：使用LLVM描述汇编和对象文件</span></span><br><span class="line"><span class="comment">-o &lt;file&gt;：输出到目标文件</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><p>查看更多的<code>clang</code>使用方法可以在终端输入<code>clang --hep</code>查看,也可以点击下面的链接:<a href="https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110">https://link.jianshu.com/?t=https://gist.github.com/masuidrive/5231110</a></p><h3 id="2-1-预处理（Preprocess）"><a href="#2-1-预处理（Preprocess）" class="headerlink" title="2.1 预处理（Preprocess）"></a>2.1 预处理（Preprocess）</h3><p>预编译过程主要处理源代码文件中的以”#”开头的预编译指令，<strong>不检查语法错误</strong>。规则如下：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。 </li><li>处理所有条件预编译指令，比如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件内容插入到(全部复制到)该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。#include 可以导入任何(合法/不合法)文件，都能展开。</li><li>删除所有的注释“//”和“/* */”，会变成空行。 </li><li>保留所有的 #pragma 编译器指令，因为编译器须要使用它们。</li><li>添加行号和文件名标识，比如# 2 “main.m” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。<br>  格式是“<code># 行号 文件名 标志</code>”，参数解释如下：<ul><li>行号与文件名：表示从它后一行开始的内容来源于哪一个文件的哪一行</li><li>标志：可以是1,2,3,4四个数字，每个数字的含义如下：<br>1：表示新文件的开始<br>2：表示从一个被包含的文件中返回<br>3：表示后面的内容来自系统头文件<br>4：表示后面的内容应当被当做一个隐式的extern ‘C’块</li></ul></li></ul><p>经过预编译后的<code> .i 文件</code>不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 .i 文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><p>可以通过执行以下命令，<code>-E</code>表示只进行预编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m </span><br><span class="line"><span class="comment"># 或者 </span></span><br><span class="line">clang -E -fmodules main.m <span class="comment"># 此时需要源码中改为@import</span></span><br></pre></td></tr></table></figure><p>执行完这个命令之后，我们会发现导入了很多的头文件内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"># 408 &quot;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;MacOSX.platform&#x2F;Developer&#x2F;SDKs&#x2F;MacOSX.sdk&#x2F;usr&#x2F;include&#x2F;stdio.h&quot; 2 3 4</span><br><span class="line"># 2 &quot;main.m&quot; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int eight &#x3D; 8;</span><br><span class="line">    int six &#x3D; 6;</span><br><span class="line">    int rank &#x3D; eight + six;</span><br><span class="line">    printf(&quot;%d\n&quot;,rank);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的预处理已经把宏替换了，并且导入了头文件。</p><h3 id="2-2-词法分析-Lexical-Analysis"><a href="#2-2-词法分析-Lexical-Analysis" class="headerlink" title="2.2 词法分析 (Lexical Analysis)"></a>2.2 词法分析 (Lexical Analysis)</h3><p>预处理之后，就是编译。编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这个过程往往是我们所说的整个程序构建的核心部分，也是最复杂的部分之一。</p><p>首先，Clang 会对代码进行词法分析，将代码切分成 Token。你可以在<a href="https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def">这个链接</a>中，看到 Clang 定义的所有 Token 类型。我们可以把这些 Token 类型，分为下面这 4 类。 </p><ul><li>关键字：语法中的关键字，比如 if、else、while、for 等;</li><li>标识符：变量名;</li><li>字面量：值、数字、字符串; </li><li>特殊符号：加减乘除、左右括号等符号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure><p>每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int &#39;int&#39; [StartOfLine]Loc&#x3D;&lt;main.m:4:1&gt;</span><br><span class="line">identifier &#39;main&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:4:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:4:9&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:4:10&gt;</span><br><span class="line">l_brace &#39;&#123;&#39;Loc&#x3D;&lt;main.m:4:11&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:5:5&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:15&gt;</span><br><span class="line">numeric_constant &#39;8&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:5:17 &lt;Spelling&#x3D;main.m:2:21&gt;&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:5:28&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:6:5&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:13&gt;</span><br><span class="line">numeric_constant &#39;6&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:6:15&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:6:16&gt;</span><br><span class="line">int &#39;int&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:7:5&gt;</span><br><span class="line">identifier &#39;rank&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:9&gt;</span><br><span class="line">equal &#39;&#x3D;&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:14&gt;</span><br><span class="line">identifier &#39;eight&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:16&gt;</span><br><span class="line">plus &#39;+&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:22&gt;</span><br><span class="line">identifier &#39;six&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:7:24&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:7:27&gt;</span><br><span class="line">identifier &#39;printf&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:8:5&gt;</span><br><span class="line">l_paren &#39;(&#39;Loc&#x3D;&lt;main.m:8:11&gt;</span><br><span class="line">string_literal &#39;&quot;%d\n&quot;&#39;Loc&#x3D;&lt;main.m:8:12&gt;</span><br><span class="line">comma &#39;,&#39;Loc&#x3D;&lt;main.m:8:18&gt;</span><br><span class="line">identifier &#39;rank&#39;Loc&#x3D;&lt;main.m:8:19&gt;</span><br><span class="line">r_paren &#39;)&#39;Loc&#x3D;&lt;main.m:8:23&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:8:24&gt;</span><br><span class="line">return &#39;return&#39; [StartOfLine] [LeadingSpace]Loc&#x3D;&lt;main.m:9:5&gt;</span><br><span class="line">numeric_constant &#39;0&#39; [LeadingSpace]Loc&#x3D;&lt;main.m:9:12&gt;</span><br><span class="line">semi &#39;;&#39;Loc&#x3D;&lt;main.m:9:13&gt;</span><br><span class="line">r_brace &#39;&#125;&#39; [StartOfLine]Loc&#x3D;&lt;main.m:10:1&gt;</span><br><span class="line">eof &#39;&#39;Loc&#x3D;&lt;main.m:10:2&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-语法、语义分析"><a href="#2-3-语法、语义分析" class="headerlink" title="2.3 语法、语义分析"></a>2.3 语法、语义分析</h3><p>这个阶段有两个模块Parser(语法syntax分析器)、Sema(语义分析Semantic)配合完成：</p><ul><li>Parser：遍历每个Token做词句分析，根据当前语言的语法，验证语法是否正确，最后生成一个 节点（Nodes）并记录相关的信息。</li><li>Semantic：在Lex 跟 syntax Analysis之后, 已经确保 词 句已经是正确的形式，semantic 接着做return values, size boundaries, uninitialized variables 等检查，如果发现语义上有错误给出提示；如果没有错误就会将 Token 按照语法组合成语义，生成 Clang 语义节点(Nodes)，然后将这些节点按照层级关系构成抽象语法树(AST)。</li></ul><p>AST可以说是Clang的核心，大部分的优化, 判断都在AST处理（例如寻找Class, 替换代码…等)。此步骤会将 Clang Attr  转换成 AST 上的 AttributeList，能在clang插件上透过 <code>Decl::getAttr&lt;T&gt;</code> 获取</p><blockquote><p>Clang Attributes：是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程, 一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中, Ex: <code>NS_CLASS_AVAILABLE_IOS(9_0)</code></p></blockquote><p>结构跟其他Compiler的AST相同。与其他编译器不同的是 Clang的AST是由C++构成类似Class、Variable的层级表示，其他的则是以汇编语言编写。这代表着AST也能有对应的api，这让AST操作, 获取信息都比较容易，甚至还夹带着地址跟代码位置。</p><blockquote><p>AST Context: 存储所有AST相关资讯, 且提供ASTMatcher等遍历方法</p></blockquote><p>在 Clang的定义中，节点主要分成三种，其他的都是这三种的派生。</p><ul><li><strong>Type</strong>：类型。对应 <code>clang::Type</code><ul><li>类型层级中的基类。</li><li>Type具体到某个语言的类型时便可以派生出 PointerType(指针类型)、ObjCObjectType(objc对象类型)、BuiltinType(内置基础数据类型)等。</li></ul></li><li><strong>Decl</strong>：<em>declaration，声明</em>。对应 <code>clang::Decl</code><ul><li>表示一个声明（或定义definition）。比如variable、typedef、function、struct等。</li><li>派生类比如FunctionDecl、ParmVarDecl。</li></ul></li><li><strong>Stmt</strong>：<em>statement，陈述/语句</em>。对应 <code>clang::stmt</code>。<ul><li>派生类比如：<ul><li>CompoundStmt：一组语句，如 { stmt stmt }。</li><li>DeclStmt：用于decl与stmt混合使用的适配器类。</li><li>ValueStmt：可能有value和type的语句。</li><li>ReturnStmt等…</li></ul></li><li><strong>Expr</strong>：<em>expression，表达式</em>。（<code>clang::Expr</code> 继承自上面的 <code>clang::ValueStmt</code>）</li><li><strong>Literal</strong>：<em>字面量</em>，是一个特殊的 Expr。</li></ul></li></ul><p>通过这三种的联结、重复或选择（alternative)就能构成一门编程语言。举个例子，下图的一段代码：详细可以看<a href="https://www.stephenw.cc/2018/01/08/clang-ast/">了解 Clang AST</a></p><img src="/images/compilelink/06.png" alt="01" style="zoom:70%;" /><p>从上图中可以看到：</p><ul><li>一个FunctionDecl（函数的实现）由一个 ParmVarDecl联结 CompoundStmt组成。</li><li>函数的 CompoundStmt 由 DeclStmt和 ReturnStmt联结组成。</li><li>还可以发现这段代码的ParmVarDecl由 BuiltinType 和一个标识符字面量联结组成。</li></ul><p>很明显一门编程语言中还有很多其他形态，我们都可以用这种方式描述出来。所以说从抽象的角度看，拥有无限种形态的编程语言便可以用有限的形式来表示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&#96;-FunctionDecl 0x7fcbb9947b20 &lt;main.m:4:1, line:10:1&gt; line:4:5 main &#39;int ()&#39;</span><br><span class="line">  &#96;-CompoundStmt 0x7fcbb9947fc8 &lt;col:11, line:10:1&gt;</span><br><span class="line">    |-DeclStmt 0x7fcbb9947c50 &lt;line:5:5, col:28&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947bd0 &lt;col:5, line:2:21&gt; line:5:9 used eight &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947c30 &lt;line:2:21&gt; &#39;int&#39; 8</span><br><span class="line">    |-DeclStmt 0x7fcbb9947d00 &lt;line:6:5, col:16&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947c80 &lt;col:5, col:15&gt; col:9 used six &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-IntegerLiteral 0x7fcbb9947ce0 &lt;col:15&gt; &#39;int&#39; 6</span><br><span class="line">    |-DeclStmt 0x7fcbb9947e20 &lt;line:7:5, col:27&gt;</span><br><span class="line">    | &#96;-VarDecl 0x7fcbb9947d30 &lt;col:5, col:24&gt; col:9 used rank &#39;int&#39; cinit</span><br><span class="line">    |   &#96;-BinaryOperator 0x7fcbb9947e00 &lt;col:16, col:24&gt; &#39;int&#39; &#39;+&#39;</span><br><span class="line">    |     |-ImplicitCastExpr 0x7fcbb9947dd0 &lt;col:16&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |     | &#96;-DeclRefExpr 0x7fcbb9947d90 &lt;col:16&gt; &#39;int&#39; lvalue Var 0x7fcbb9947bd0 &#39;eight&#39; &#39;int&#39;</span><br><span class="line">    |     &#96;-ImplicitCastExpr 0x7fcbb9947de8 &lt;col:24&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |       &#96;-DeclRefExpr 0x7fcbb9947db0 &lt;col:24&gt; &#39;int&#39; lvalue Var 0x7fcbb9947c80 &#39;six&#39; &#39;int&#39;</span><br><span class="line">    |-CallExpr 0x7fcbb9947f20 &lt;line:8:5, col:23&gt; &#39;int&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f08 &lt;col:5&gt; &#39;int (*)(const char *, ...)&#39; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">    | | &#96;-DeclRefExpr 0x7fcbb9947e38 &lt;col:5&gt; &#39;int (const char *, ...)&#39; Function 0x7fcbb9932e70 &#39;printf&#39; &#39;int (const char *, ...)&#39;</span><br><span class="line">    | |-ImplicitCastExpr 0x7fcbb9947f68 &lt;col:12&gt; &#39;const char *&#39; &lt;NoOp&gt;</span><br><span class="line">    | | &#96;-ImplicitCastExpr 0x7fcbb9947f50 &lt;col:12&gt; &#39;char *&#39; &lt;ArrayToPointerDecay&gt;</span><br><span class="line">    | |   &#96;-StringLiteral 0x7fcbb9947e98 &lt;col:12&gt; &#39;char [4]&#39; lvalue &quot;%d\n&quot;</span><br><span class="line">    | &#96;-ImplicitCastExpr 0x7fcbb9947f80 &lt;col:19&gt; &#39;int&#39; &lt;LValueToRValue&gt;</span><br><span class="line">    |   &#96;-DeclRefExpr 0x7fcbb9947eb8 &lt;col:19&gt; &#39;int&#39; lvalue Var 0x7fcbb9947d30 &#39;rank&#39; &#39;int&#39;</span><br><span class="line">    &#96;-ReturnStmt 0x7fcbb9947fb8 &lt;line:9:5, col:12&gt;</span><br><span class="line">      &#96;-IntegerLiteral 0x7fcbb9947f98 &lt;col:12&gt; &#39;int&#39; 0</span><br></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><p>语法树直观图:</p><img src="/images/compilelink/07.png" alt="01" style="zoom:90%;" /><h4 id="2-3-1-静态分析-Static-Analyzer"><a href="#2-3-1-静态分析-Static-Analyzer" class="headerlink" title="2.3.1 静态分析 (Static Analyzer)"></a>2.3.1 静态分析 (Static Analyzer)</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg      Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when casting a malloc&#39;ed type T, whether the size is a multiple of the size of T</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><a href="http://clang-analyzer.llvm.org/scan-build.html">scan-build</a> 是用于静态分析代码的工具，它包含在 clang 的源码包中。使用scan-build可以从命令行运行分析器，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">roten@localhost scan-build % .&#x2F;scan-build --use-analyzer&#x3D;xcode xcodebuild -project Demo123.xcodeproj    &#x2F;&#x2F; 需要设置 --use-analyzer指定 clang 的路径</span><br><span class="line"></span><br><span class="line">scan-build: Using &#39;&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang&#39; for static analysis</span><br><span class="line">Build settings from command line:</span><br><span class="line">    CLANG_ANALYZER_EXEC &#x3D; &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS &#x3D; </span><br><span class="line">    CLANG_ANALYZER_OUTPUT &#x3D; plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR &#x3D; &#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER &#x3D; YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">** BUILD SUCCEEDED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory &#39;&#x2F;var&#x2F;folders&#x2F;1r&#x2F;n7kwlmgn74l3pvvht646f6fm0000gp&#x2F;T&#x2F;scan-build-2020-09-01-140523-22105-1&#39; because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure><p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org/">Clang 静态分析器</a></p><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。</p><h3 id="2-4-IR代码生成-CodeGen"><a href="#2-4-IR代码生成-CodeGen" class="headerlink" title="2.4 IR代码生成 (CodeGen)"></a>2.4 IR代码生成 (CodeGen)</h3><p>CodeGen负责将语法树从顶至下遍历，翻译成LLVM IR，LLVM IR是Frontend的输出，也是LLVM Backerend的输入，桥接前后端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID &#x3D; &#39;main.m&#39;</span><br><span class="line">source_filename &#x3D; &quot;main.m&quot;</span><br><span class="line">target datalayout &#x3D; &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple &#x3D; &quot;x86_64-apple-macosx10.15.0&quot;</span><br><span class="line"></span><br><span class="line">@.str &#x3D; private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline optnone ssp uwtable</span><br><span class="line">define i32 @main() #0 &#123;</span><br><span class="line">  %1 &#x3D; alloca i32, align 4</span><br><span class="line">  %2 &#x3D; alloca i32, align 4</span><br><span class="line">  %3 &#x3D; alloca i32, align 4</span><br><span class="line">  %4 &#x3D; alloca i32, align 4</span><br><span class="line">  store i32 0, i32* %1, align 4</span><br><span class="line">  store i32 8, i32* %2, align 4</span><br><span class="line">  store i32 6, i32* %3, align 4</span><br><span class="line">  %5 &#x3D; load i32, i32* %2, align 4</span><br><span class="line">  %6 &#x3D; load i32, i32* %3, align 4</span><br><span class="line">  %7 &#x3D; add nsw i32 %5, %6</span><br><span class="line">  store i32 %7, i32* %4, align 4</span><br><span class="line">  %8 &#x3D; load i32, i32* %4, align 4</span><br><span class="line">  %9 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %8)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) #1</span><br><span class="line"></span><br><span class="line">attributes #0 &#x3D; &#123; noinline optnone ssp uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;min-legal-vector-width&quot;&#x3D;&quot;0&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-jump-tables&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line">attributes #1 &#x3D; &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;&#x3D;&quot;false&quot; &quot;darwin-stkchk-strong-link&quot; &quot;disable-tail-calls&quot;&#x3D;&quot;false&quot; &quot;less-precise-fpmad&quot;&#x3D;&quot;false&quot; &quot;no-frame-pointer-elim&quot;&#x3D;&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-nans-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;&#x3D;&quot;false&quot; &quot;no-trapping-math&quot;&#x3D;&quot;false&quot; &quot;probe-stack&quot;&#x3D;&quot;___chkstk_darwin&quot; &quot;stack-protector-buffer-size&quot;&#x3D;&quot;8&quot; &quot;target-cpu&quot;&#x3D;&quot;penryn&quot; &quot;target-features&quot;&#x3D;&quot;+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot; &quot;unsafe-fp-math&quot;&#x3D;&quot;false&quot; &quot;use-soft-float&quot;&#x3D;&quot;false&quot; &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags &#x3D; !&#123;!0, !1, !2, !3, !4, !5, !6, !7&#125;</span><br><span class="line">!llvm.ident &#x3D; !&#123;!8&#125;</span><br><span class="line"></span><br><span class="line">!0 &#x3D; !&#123;i32 2, !&quot;SDK Version&quot;, [2 x i32] [i32 10, i32 15]&#125;</span><br><span class="line">!1 &#x3D; !&#123;i32 1, !&quot;Objective-C Version&quot;, i32 2&#125;</span><br><span class="line">!2 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Version&quot;, i32 0&#125;</span><br><span class="line">!3 &#x3D; !&#123;i32 1, !&quot;Objective-C Image Info Section&quot;, !&quot;__DATA,__objc_imageinfo,regular,no_dead_strip&quot;&#125;</span><br><span class="line">!4 &#x3D; !&#123;i32 4, !&quot;Objective-C Garbage Collection&quot;, i32 0&#125;</span><br><span class="line">!5 &#x3D; !&#123;i32 1, !&quot;Objective-C Class Properties&quot;, i32 64&#125;</span><br><span class="line">!6 &#x3D; !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;</span><br><span class="line">!7 &#x3D; !&#123;i32 7, !&quot;PIC Level&quot;, i32 2&#125;</span><br><span class="line">!8 &#x3D; !&#123;!&quot;Apple clang version 11.0.0 (clang-1100.0.33.12)&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-1-中间代码优化-Optimize"><a href="#2-4-1-中间代码优化-Optimize" class="headerlink" title="2.4.1 中间代码优化 (Optimize)"></a>2.4.1 中间代码优化 (Optimize)</h4><p>可以在中间代码层次去做一些优化工作，我们在Xcode的编译设置里面也可以设置优化级别<code>-O1</code>,<code>-O3</code>,<code>-Os</code>对应着不同的入参，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。</p><img src="/images/compilelink/08.png" alt="01" style="zoom:95%;" /><img src="/images/compilelink/09.png" alt="01" style="zoom:85%;" /><p>我们还可以去写一些自己的Pass，官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html">Writing an LLVM Pass — LLVM 5 documentation</a>。</p><h3 id="2-5-生成字节码-LLVM-Bitcode"><a href="#2-5-生成字节码-LLVM-Bitcode" class="headerlink" title="2.5 生成字节码 (LLVM Bitcode)"></a>2.5 生成字节码 (LLVM Bitcode)</h3><p>我们在Xcode7中默认生成bitcode就是这种的中间形式存在，开启了bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对bitcode做一个进一步的优化，如果有新的后端架构，仍然可以用这份bitcode去生成。</p><blockquote><p>Bitcode是编译后的程序的中间表现，包含Bitcode并上传到App Store Connect的Apps会在App Store上编译和链接。包含Bitcode可以在不提交新版本App的情况下，允许Apple在将来的时候再次优化你的App 二进制文件。<br>对于iOS Apps，Enable bitcode 默认为YES，是可选的（可以改为NO）。对于WatchOS和tvOS，bitcode是强制的。如果你的App支持bitcode，App Bundle（项目中所有的target）中的所有的Apps和frameworks都需要包含Bitcode。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure><img src="/images/compilelink/10.png" alt="01" style="zoom:90%;" /><h3 id="2-6-生成相关汇编"><a href="#2-6-生成相关汇编" class="headerlink" title="2.6 生成相关汇编"></a>2.6 生成相关汇编</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.section</span>__TEXT,__text,regular,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">10</span>, <span class="number">15</span>sdk_version <span class="number">10</span>, <span class="number">15</span></span><br><span class="line">.globl_main                   ## -- Begin <span class="meta">function</span> main</span><br><span class="line">.p2align<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line"><span class="symbol">_main:</span>                                  ## <span class="comment">@main</span></span><br><span class="line">.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq<span class="number">$32</span>, %rsp</span><br><span class="line">movl<span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line">movl<span class="number">$8</span>, -<span class="number">8</span>(%rbp)</span><br><span class="line">movl<span class="number">$6</span>, -<span class="number">12</span>(%rbp)</span><br><span class="line">movl-<span class="number">8</span>(%rbp), %eax</span><br><span class="line">addl-<span class="number">12</span>(%rbp), %eax</span><br><span class="line">movl%eax, -<span class="number">16</span>(%rbp)</span><br><span class="line">movl-<span class="number">16</span>(%rbp), %esi</span><br><span class="line">leaqL_.str(%rip), %rdi</span><br><span class="line">movb<span class="number">$0</span>, %al</span><br><span class="line">callq_printf</span><br><span class="line">xorl%esi, %esi</span><br><span class="line">movl%eax, -<span class="number">20</span>(%rbp)         ## <span class="number">4</span>-byte Spill</span><br><span class="line">movl%esi, %eax</span><br><span class="line">addq<span class="number">$32</span>, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line"><span class="meta">.section</span>__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">L_.str:</span>                                 ## <span class="comment">@.str</span></span><br><span class="line"><span class="meta">.asciz</span><span class="string">&quot;%d\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.section</span>__<span class="meta">DATA</span>,__objc_imageinfo,regular,no_dead_strip</span><br><span class="line"><span class="symbol">L_OBJC_IMAGE_INFO:</span></span><br><span class="line"><span class="meta">.long</span><span class="number">0</span></span><br><span class="line"><span class="meta">.long</span><span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure><h3 id="2-7-生成目标文件"><a href="#2-7-生成目标文件" class="headerlink" title="2.7 生成目标文件"></a>2.7 生成目标文件</h3><p>编译阶段完成，接下来就是汇编阶段。汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译就可以了。</p><p>这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure><img src="/images/compilelink/11.png" alt="01" style="zoom:90%;" /><h3 id="2-8-生成可执行文件"><a href="#2-8-生成可执行文件" class="headerlink" title="2.8 生成可执行文件"></a>2.8 生成可执行文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main  <span class="comment"># 生成可执行文件</span></span><br><span class="line">./main  <span class="comment"># 执行 可执行文件 代码</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印结果：14</span><br></pre></td></tr></table></figure><h3 id="2-9-记录一个Clang命令报错"><a href="#2-9-记录一个Clang命令报错" class="headerlink" title="2.9 记录一个Clang命令报错"></a>2.9 记录一个Clang命令报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:59:11: error: #include nested too deeply  </span><br><span class="line"># include &lt;stdint.h&gt;  </span><br><span class="line">          ^  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;include&#x2F;stdint.h:82:11: error: #include nested too deeply</span><br><span class="line"># include &lt;inttypes.h&gt;</span><br><span class="line">          ^</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>可能是xcode-select 没装，于是执行xcode-select –install 进行工具安装。</p></li><li><p>如果问题还在。brew doctor一下就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/includes</span><br><span class="line">brew doctor 2&gt;&amp;1 | grep <span class="string">&quot;/usr/local/include&quot;</span> | awk <span class="string">&#x27;&#123;$1=$1;print&#125;&#x27;</span> | xargs -I _ mv _ /tmp/includes </span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://github.com/SOHU-Co/kafka-node/issues/881">https://github.com/SOHU-Co/kafka-node/issues/881</a></p></li></ol><h2 id="三、小结：iOS从编码到打包"><a href="#三、小结：iOS从编码到打包" class="headerlink" title="三、小结：iOS从编码到打包"></a>三、小结：iOS从编码到打包</h2><ul><li>首先我们编写完成代码之后，会通过LLVM编译器预处理我们的代码，比如将宏放在指定的位置</li><li>预处理结束之后，LLVM会对代码进行词法分析和语法分析，生成AST。AST是抽象语法树，主要用来进行快速遍历，实现静态代码检查的功能。</li><li>AST会生成IR，IR是一种更加接近机器码的语言，通过IR可以生成不同平台的机器码。对于iOS平台，IR生成的可执行文件就是Mach-O.</li><li>然后通过链接器将符号和地址绑定在一起，并且将项目中的多个Mach-O文件(目标文件)合并成一个Mach-O文件(可执行文件)。(<strong>关于Mach-O、链接下一节讲</strong>)</li><li>将可执行文件与资源文件、storyboard、xib等打包，最后通过签名等操作生成.app文件，然后对.app文件进行压缩就生成了我们可以安装的ipa包。</li><li>当然，ipa包的安装途径有两种：<ul><li>通过开发者账号上传到App Store，然后在App Store上下载安装。</li><li>通过PP助手、iFunBox、Xcode等工具来安装</li></ul></li></ul><h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><ul><li><a href="http://blog.alonemonkey.com/2016/12/21/learning-llvm/">关于LLVM，这些东西你必须知道!</a> 本篇文章大部分来自此文章。按照自己的理解记忆方式删减、添加了一些知识。原文中还补充有：<ul><li>Clang的三大基础设施(libclang、LibTooling、ClangPlugin)的应用、代码示例</li><li>动手写Pass的代码示例</li></ul></li><li><a href="https://xiaozhuanlan.com/topic/4916328705">深入剖析 iOS 编译 Clang / LLVM — 戴铭</a></li><li><a href="">《程序员的自我修养》</a></li><li><a href="https://juejin.im/post/6844903716709990414#heading-6">(Xcode) 編譯器小白筆記 - LLVM前端Clang</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编译、链接工具-—-Clang-LLVM&quot;&gt;&lt;a href=&quot;#一、编译、链接工具-—-Clang-LLVM&quot; class=&quot;headerlink&quot; title=&quot;一、编译、链接工具 — Clang/LLVM&quot;&gt;&lt;/a&gt;一、编译、链接工具 — Clang/LL</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>[转] Make 命令的使用与NodeJS案例</title>
    <link href="https://tenloy.github.io/2021/10/02/makefile.html"/>
    <id>https://tenloy.github.io/2021/10/02/makefile.html</id>
    <published>2021-10-02T04:25:45.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程 — 阮一峰</a></p></blockquote><p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</p><p><a href="https://en.wikipedia.org/wiki/Make_(software)">Make</a>是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><p>本文介绍Make命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是Isaac Schlueter的<a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08">《Makefile文件教程》</a>和<a href="https://www.gnu.org/software/make/manual/make.html">《GNU Make手册》</a>。</p><h1 id="一、Make的概念"><a href="#一、Make的概念" class="headerlink" title="一、Make的概念"></a>一、Make的概念</h1><p>Make这个词，英语的意思是”制作”。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make a.txt</span><br></pre></td></tr></table></figure><p>但是，如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。</p><p>比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br></pre></td></tr></table></figure><p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。</p><p><strong>像这样的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ make --file=rules.txt</span><br></pre></td></tr></table></figure><p>上面代码指定make命令依据rules.txt文件中的规则，进行构建。</p><p>总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p><h1 id="二、Makefile文件的格式"><a href="#二、Makefile文件的格式" class="headerlink" title="二、Makefile文件的格式"></a>二、Makefile文件的格式</h1><p>很多开发者不了解 Makefile 是什么，这个其实很正常，因为很多集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，我们不用去手动编写。</p><p>那么，究竟什么是 Makefile 呢？<strong>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。</strong>其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p><p>构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h2 id="2-2-目标（target）"><a href="#2-2-目标（target）" class="headerlink" title="2.2 目标（target）"></a>2.2 目标（target）</h2><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make  clean</span><br></pre></td></tr></table></figure><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册</a>。</p><p><strong>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><p>上面代码执行Makefile文件的第一个目标。</p><h2 id="2-3-前置条件（prerequisites）"><a href="#2-3-前置条件（prerequisites）" class="headerlink" title="2.3 前置条件（prerequisites）"></a>2.3 前置条件（prerequisites）</h2><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;this is the source&quot;</span> &gt; source.txt</span><br></pre></td></tr></table></figure><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure><p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure><h2 id="2-4-命令（commands）"><a href="#2-4-命令（commands）" class="headerlink" title="2.4 命令（commands）"></a>2.4 命令（commands）</h2><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">all:</span><br><span class="line">&gt; <span class="built_in">echo</span> Hello, world</span><br></pre></td></tr></table></figure><p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p><p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    <span class="built_in">export</span> foo=bar</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar; <span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure><p>另一个解决办法是在换行符前加反斜杠转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar; \</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    <span class="built_in">export</span> foo=bar; </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三、Makefile文件的语法"><a href="#三、Makefile文件的语法" class="headerlink" title="三、Makefile文件的语法"></a>三、Makefile文件的语法</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><p>井号（#）在Makefile中表示注释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line">result.txt: source.txt</span><br><span class="line">    <span class="comment"># 这是注释</span></span><br><span class="line">    cp source.txt result.txt <span class="comment"># 这也是注释</span></span><br></pre></td></tr></table></figure><h2 id="3-2-回声（echoing）"><a href="#3-2-回声（echoing）" class="headerlink" title="3.2 回声（echoing）"></a>3.2 回声（echoing）</h2><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>执行上面的规则，会得到下面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>在命令的前面加上@，就可以关闭回声。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure><p>现在再执行<code>make test</code>，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br><span class="line">    @<span class="built_in">echo</span> TODO</span><br></pre></td></tr></table></figure><h2 id="3-3-通配符"><a href="#3-3-通配符" class="headerlink" title="3.3 通配符"></a>3.3 通配符</h2><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">        rm -f *.o</span><br></pre></td></tr></table></figure><h2 id="3-4-模式匹配"><a href="#3-4-模式匹配" class="headerlink" title="3.4 模式匹配"></a>3.4 模式匹配</h2><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure><p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p><h2 id="3-5-变量和赋值符"><a href="#3-5-变量和赋值符" class="headerlink" title="3.5 变量和赋值符"></a>3.5 变量和赋值符</h2><p>Makefile 允许使用等号自定义变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $(txt)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p><p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    @<span class="built_in">echo</span> $<span class="variable">$HOME</span></span><br></pre></td></tr></table></figure><p>有时，变量的值可能指向另一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看<a href="https://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure><h2 id="3-6-内置变量（Implicit-Variables）"><a href="#3-6-内置变量（Implicit-Variables）" class="headerlink" title="3.6 内置变量（Implicit Variables）"></a>3.6 内置变量（Implicit Variables）</h2><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure><h2 id="3-7-自动变量（Automatic-Variables）"><a href="#3-7-自动变量（Automatic-Variables）" class="headerlink" title="3.7 自动变量（Automatic Variables）"></a>3.7 自动变量（Automatic Variables）</h2><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><h3 id="1"><a href="#1" class="headerlink" title="1. $@"></a>1. $@</h3><p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 $@ 就指代foo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt: </span><br><span class="line">    touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    touch a.txt</span><br><span class="line">b.txt:</span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure><h3 id="2-lt"><a href="#2-lt" class="headerlink" title="2. $&lt;"></a>2. $&lt;</h3><p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp $&lt; <span class="variable">$@</span> </span><br></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp b.txt a.txt </span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3. $?"></a>3. $?</h3><p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p><h3 id="4"><a href="#4" class="headerlink" title="4. $^"></a>4. $^</h3><p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p><h3 id="5"><a href="#5" class="headerlink" title="5. $*"></a>5. $*</h3><p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p><h3 id="6-D-和-F"><a href="#6-D-和-F" class="headerlink" title="6. $(@D) 和 $(@F)"></a>6. $(@D) 和 $(@F)</h3><p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p><h3 id="7-lt-D-和-lt-F"><a href="#7-lt-D-和-lt-F" class="headerlink" title="7. $(&lt;D) 和 $(&lt;F)"></a>7. $(&lt;D) 和 $(&lt;F)</h3><p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册</a>。下面是自动变量的一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest/%.txt: src/%.txt</span><br><span class="line">    @[ -d dest ] || mkdir dest</span><br><span class="line">    cp $&lt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p><h2 id="3-8-判断和循环"><a href="#3-8-判断和循环" class="headerlink" title="3.8 判断和循环"></a>3.8 判断和循环</h2><p>Makefile使用 Bash 语法，完成判断和循环。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> $<span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> one two three; <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面代码的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><h2 id="3-9-函数"><a href="#3-9-函数" class="headerlink" title="3.9 函数"></a>3.9 函数</h2><p>Makefile 还可以使用函数，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure><p>Makefile提供了许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用。下面是几个常用的内置函数。</p><h3 id="1-shell-函数"><a href="#1-shell-函数" class="headerlink" title="1. shell 函数"></a>1. shell 函数</h3><p>shell 函数用来执行 shell 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(shell <span class="built_in">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure><h3 id="2-wildcard-函数"><a href="#2-wildcard-函数" class="headerlink" title="2. wildcard 函数"></a>2. wildcard 函数</h3><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure><h3 id="3-subst-函数"><a href="#3-subst-函数" class="headerlink" title="3. subst 函数"></a>3. subst 函数</h3><p>subst 函数用来文本替换，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure><p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class="line"><span class="comment"># bar is now `a,b,c&#x27;.</span></span><br></pre></td></tr></table></figure><h3 id="4-patsubst函数"><a href="#4-patsubst函数" class="headerlink" title="4. patsubst函数"></a>4. patsubst函数</h3><p>patsubst 函数用于模式匹配的替换，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure><p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure><h3 id="5-替换后缀名"><a href="#5-替换后缀名" class="headerlink" title="5 替换后缀名"></a>5 替换后缀名</h3><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><h1 id="四、Makefile-的实例"><a href="#四、Makefile-的实例" class="headerlink" title="四、Makefile 的实例"></a>四、Makefile 的实例</h1><h2 id="4-1-执行多个目标"><a href="#4-1-执行多个目标" class="headerlink" title="4.1 执行多个目标"></a>4.1 执行多个目标</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p><h2 id="4-2-编译C语言项目"><a href="#4-2-编译C语言项目" class="headerlink" title="4.2 编译C语言项目"></a>4.2 编译C语言项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o </span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">     rm edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">.PHONY: edit clean</span><br></pre></td></tr></table></figure><h1 id="五、CMake、NMake介绍"><a href="#五、CMake、NMake介绍" class="headerlink" title="五、CMake、NMake介绍"></a>五、CMake、NMake介绍</h1><p>make工具就根据makefile文件中的命令进行编译和链接的。</p><p>makefile在一些简单的工程完全可以人工拿下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改，这时候就出现了下面的Cmake这个工具。</p><p>cmake就可以更加简单的生成makefile文件给上面那个make用。当然cmake还有其他更牛X功能，就是可以<strong>跨平台</strong>生成对应平台能用的makefile，我们就不用再自己去修改了。</p><p>可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。</p><p>CMakeList.txt是需要我们自己手写的。</p><img src="/images/compilelink/45.png" alt="45" style="zoom:80%;" /><p>nmake是Microsoft Visual Studio中的附带命令，需要安装VS，实际上可以说相当于linux的make</p><h1 id="六、案例：使用-Make-构建网站"><a href="#六、案例：使用-Make-构建网站" class="headerlink" title="六、案例：使用 Make 构建网站"></a>六、案例：使用 Make 构建网站</h1><p>网站开发正变得越来越专业，涉及到各种各样的工具和流程，迫切需要构建自动化。</p><p>所谓”构建自动化”，就是指使用构建工具，自动实现”从源码到网页”的开发流程。这有利于提高开发效率、改善代码质量。</p><p>本文介绍如何使用make命令，作为网站的构建工具。以下内容既是make语法的实例，也是网站构建的实战教程。你完全可以将代码略作修改，拷贝到自己的项目。</p><h2 id="6-1-Make的优点"><a href="#6-1-Make的优点" class="headerlink" title="6.1 Make的优点"></a>6.1 Make的优点</h2><p>首先解释一下，为什么要用Make。</p><p>目前，网站项目（尤其是Node.js项目）有三种构建方案。</p><blockquote><ul><li>方案一：基于Node.js的专用构建工具（<a href="https://gruntjs.com/">Grunt</a>、<a href="http://gulpjs.com/">Gulp</a>、<a href="http://brunch.io/">Brunch</a>、<a href="https://github.com/broccolijs/broccoli">Broccoli</a>、<a href="http://mimosa.io/">Mimosa</a>）</li><li>方案二：npm run命令（<a href="http://substack.net/task_automation_with_npm_run">教程1</a>、<a href="http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/">2</a>、<a href="http://gon.to/2015/02/26/gulp-is-awesome-but-do-we-really-need-it/">3</a>）</li><li>方案三：make命令</li></ul></blockquote><p>我觉得，make是大型项目的首选方案。npm run可以认为是make的简化形式，只适用于简单项目，而Grunt、Gulp那样的工具，有很多问题。</p><p><strong>（1）插件问题</strong></p><p>Grunt和Gulp的操作，都由插件完成。即使是文件改名这样简单的任务，都要写插件，相当麻烦。而Make是直接调用命令行，根本不用担心找不到插件。</p><p><strong>（2）兼容性问题</strong></p><p>插件的版本，必须与Grunt和Gulp的版本匹配，还必须与对应的命令行程序匹配。比如，<a href="https://github.com/gruntjs/grunt-contrib-jshint">grunt-contrib-jshint插件</a>现在是0.11.0版，对应Grunt 0.4.5版和JSHint 2.6.0版。万一Grunt和JSHint升级，而插件没有升级，就有可能出现兼容性问题。Make是直接调用JSHint，不存在这个问题。</p><p><strong>（3）语法问题</strong></p><p>Grunt和Gulp都有自己的语法，并不容易学，尤其是Grunt，语法很罗嗦，很难一眼看出来代码的意图。当然，make也不容易学，但它有复用性，学会了还可以用在其他场合。</p><p><strong>（4）功能问题</strong></p><p>make已经使用了几十年，全世界无数的大项目都用它构建，早就证明非常可靠，各种情况都有办法解决，前人累积的经验和资料也非常丰富。相比之下，Grunt和Gulp的历史都不长，使用范围有限，目前还没有出现它们能做、而make做不到的任务。</p><p>基于以上理由，我看好make。</p><h2 id="6-2-常见的构建任务"><a href="#6-2-常见的构建任务" class="headerlink" title="6.2 常见的构建任务"></a>6.2 常见的构建任务</h2><p>下面是一些常见的网站构建任务。</p><ul><li>检查语法</li><li>编译模板</li><li>转码</li><li>合并</li><li>压缩</li><li>测试</li><li>删除</li></ul><p>这些任务用到 <a href="http://jshint.com/">JSHint</a>、<a href="http://handlebarsjs.com/">handlebars</a>、<a href="http://coffeescript.org/">CoffeeScript</a>、<a href="http://lisperator.net/uglifyjs/">uglifyjs</a>、<a href="https://mochajs.org/">mocha</a> 等工具。对应的package.json文件如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;coffee-script&quot;</span>: <span class="string">&quot;~1.9.1&quot;</span>,</span><br><span class="line"> <span class="string">&quot;handlebars&quot;</span>: <span class="string">&quot;~3.0.0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;jshint&quot;</span>: <span class="string">&quot;^2.6.3&quot;</span>,</span><br><span class="line"> <span class="string">&quot;mocha&quot;</span>: <span class="string">&quot;~2.2.1&quot;</span>,</span><br><span class="line"> <span class="string">&quot;uglify-js&quot;</span>: <span class="string">&quot;~2.4.17&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看，Make 命令怎么完成这些构建任务。</p><h2 id="6-3-Makefile的通用配置"><a href="#6-3-Makefile的通用配置" class="headerlink" title="6.3 Makefile的通用配置"></a>6.3 Makefile的通用配置</h2><p>开始构建之前，要编写Makefile文件。它是make命令的配置文件。所有任务的构建规则，都写在这个文件。</p><p>首先，写入两行通用配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH  := node_modules/.bin:$(PATH)</span><br><span class="line">SHELL := /bin/bash</span><br></pre></td></tr></table></figure><p>上面代码的PATH和SHELL都是BASH变量。它们被重新赋值。</p><p>PATH变量重新赋值为，优先在 node_modules/.bin 目录寻找命令。这是因为（当前项目的）node模块，会在 node_modules/.bin 目录设置一个符号链接。PATH变量指向这个目录以后，调用各种命令就不用写路径了。比如，调用JSHint，就不用写 ~/node_modules/.bin/jshint ，只写 jshint 就行了。</p><p>SHELL变量指定构建环境使用BASH。</p><h2 id="6-4-检查语法错误"><a href="#6-4-检查语法错误" class="headerlink" title="6.4 检查语法错误"></a>6.4 检查语法错误</h2><p>第一个任务是，检查源码有没有语法错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js_files = $(shell find ./lib -name <span class="string">&#x27;*.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">lint: $(js_files)</span><br><span class="line"> jshint $?</span><br></pre></td></tr></table></figure><p>上面代码中，shell函数调用find命令，找出lib目录下所有js文件，保存在变量js_files。然后，就可以用jshint检查这些文件。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make lint</span><br></pre></td></tr></table></figure><h2 id="6-5-模板编译"><a href="#6-5-模板编译" class="headerlink" title="6.5 模板编译"></a>6.5 模板编译</h2><p>第二个任务是编译模板。假定模板都在templates目录，需要编译为build目录下的templates.js文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build/templates.js: templates/*.handlebars</span><br><span class="line"> mkdir -p $(dir <span class="variable">$@</span>)</span><br><span class="line"> handlebars templates/*.handlebars &gt; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">template: build/templates.js</span><br></pre></td></tr></table></figure><p>上面代码查看build目录是否存在，如果不存在就新建一个。dir函数用于取出构建目标的路径名（build），内置变量$@代表构建目标（build/templates.js）。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make template</span><br></pre></td></tr></table></figure><h2 id="6-6-Coffee脚本转码"><a href="#6-6-Coffee脚本转码" class="headerlink" title="6.6 Coffee脚本转码"></a>6.6 Coffee脚本转码</h2><p>第三个任务是，将CofferScript脚本转为JavaScript脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source_files := $(wildcard lib/*.coffee)</span><br><span class="line">build_files  := $(source_files:lib/%.coffee=build/%.js)</span><br><span class="line"></span><br><span class="line">build/%.js: lib/%.coffee</span><br><span class="line"> coffee -co $(dir <span class="variable">$@</span>) $&lt;</span><br><span class="line"></span><br><span class="line">coffee: $(build_files)</span><br></pre></td></tr></table></figure><p>上面代码中，首先获取所有的Coffee脚本文件，存放在变量source<em>files，函数wildcard用来扩展通配符。然后，将变量source</em>files中的coffee文件名，替换成js文件名，即 lib/x.coffee 替换成 build/x.js 。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make coffee</span><br></pre></td></tr></table></figure><h2 id="6-7-合并文件"><a href="#6-7-合并文件" class="headerlink" title="6.7 合并文件"></a>6.7 合并文件</h2><p>使用cat命令，合并多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS_FILES := $(wildcard build/*.js)</span><br><span class="line">OUTPUT := build/bundle.js</span><br><span class="line"></span><br><span class="line">concat: $(JS_FILES)</span><br><span class="line"> cat $^ &gt; $(OUTPUT)</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make concat</span><br></pre></td></tr></table></figure><h2 id="6-8-压缩JavaScript脚本"><a href="#6-8-压缩JavaScript脚本" class="headerlink" title="6.8 压缩JavaScript脚本"></a>6.8 压缩JavaScript脚本</h2><p>将所有JavaScript脚本，压缩为build目录下的app.js。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app_bundle := build/app.js</span><br><span class="line"></span><br><span class="line">$(app_bundle): $(build_files) $(template_js)</span><br><span class="line"> uglifyjs -cmo <span class="variable">$@</span> $^</span><br><span class="line"></span><br><span class="line">min: $(app_bundle)</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make min</span><br></pre></td></tr></table></figure><p>还有另一种写法，可以另行指定压缩工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UGLIFY ?= uglify</span><br><span class="line"></span><br><span class="line">$(app_bundle): $(build_files) $(template_js)</span><br><span class="line"> $(UGLIFY) -cmo <span class="variable">$@</span> $^</span><br></pre></td></tr></table></figure><p>上面代码将压缩工具uglify放在变量UGLIFY。注意，变量的赋值符是 ?= ，表示这个变量可以被命令行参数覆盖。</p><p>调用时这样写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make UGLIFY=node_modules/.bin/jsmin min</span><br></pre></td></tr></table></figure><p>上面代码，将jsmin命令给变量UGLIFY，压缩时就会使用jsmin命令。</p><h2 id="6-9-删除临时文件"><a href="#6-9-删除临时文件" class="headerlink" title="6.9 删除临时文件"></a>6.9 删除临时文件</h2><p>构建结束前，删除所有临时文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line"> rm -rf build</span><br></pre></td></tr></table></figure><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br></pre></td></tr></table></figure><h2 id="6-10-测试"><a href="#6-10-测试" class="headerlink" title="6.10 测试"></a>6.10 测试</h2><p>假定测试工具是mocha，所有测试用例放在test目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>: $(app_bundle) $(test_js)</span><br><span class="line"> mocha</span><br></pre></td></tr></table></figure><p>当脚本和测试用例都存在，上面代码就会执行mocha。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="6-11-多任务执行"><a href="#6-11-多任务执行" class="headerlink" title="6.11 多任务执行"></a>6.11 多任务执行</h2><p>构建过程需要一次性执行多个任务，可以指定一个多任务目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build: template concat min clean</span><br></pre></td></tr></table></figure><p>上面代码将build指定为执行模板编译、文件合并、脚本压缩、删除临时文件四个任务。</p><p>使用时调用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make build</span><br></pre></td></tr></table></figure><p>如果这行规则在Makefile的最前面，执行时可以省略目标名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure><p>通常情况下，make一次执行一个任务。如果任务都是独立的，互相没有依赖关系，可以用参数 -j 指定同时执行多个任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make -j build</span><br></pre></td></tr></table></figure><h2 id="6-12-声明伪文件"><a href="#6-12-声明伪文件" class="headerlink" title="6.12 声明伪文件"></a>6.12 声明伪文件</h2><p>最后，为了防止目标名与现有文件冲突，显式声明哪些目标是伪文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: lint template coffee concat min <span class="built_in">test</span> clean build</span><br></pre></td></tr></table></figure><h2 id="6-13-Makefile文件示例"><a href="#6-13-Makefile文件示例" class="headerlink" title="6.13 Makefile文件示例"></a>6.13 Makefile文件示例</h2><p>下面是两个简单的Makefile文件，用来补充make命令的其他构建任务。</p><p>实例一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PROJECT = <span class="string">&quot;My Fancy Node.js project&quot;</span></span><br><span class="line"></span><br><span class="line">all: install <span class="built_in">test</span> server</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>: ;@<span class="built_in">echo</span> <span class="string">&quot;Testing <span class="variable">$&#123;PROJECT&#125;</span>.....&quot;</span>; \</span><br><span class="line"> <span class="built_in">export</span> NODE_PATH=.; \</span><br><span class="line"> ./node_modules/mocha/bin/mocha;</span><br><span class="line"></span><br><span class="line">install: ;@<span class="built_in">echo</span> <span class="string">&quot;Installing <span class="variable">$&#123;PROJECT&#125;</span>.....&quot;</span>; \</span><br><span class="line"> npm install</span><br><span class="line"></span><br><span class="line">update: ;@<span class="built_in">echo</span> <span class="string">&quot;Updating <span class="variable">$&#123;PROJECT&#125;</span>.....&quot;</span>; \</span><br><span class="line"> git pull --rebase; \</span><br><span class="line"> npm install</span><br><span class="line"></span><br><span class="line">clean : ;</span><br><span class="line"> rm -rf node_modules</span><br><span class="line"></span><br><span class="line">.PHONY: <span class="built_in">test</span> server install clean update</span><br></pre></td></tr></table></figure><p>实例二。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: build-js build-css</span><br><span class="line"></span><br><span class="line">build-js: </span><br><span class="line">browserify -t brfs src/app.js &gt; site/app.js</span><br><span class="line"></span><br><span class="line">build-css:</span><br><span class="line">stylus src/style.styl &gt; site/style.css</span><br><span class="line"></span><br><span class="line">.PHONY build-js build-css</span><br></pre></td></tr></table></figure><h2 id="6-14-参考链接"><a href="#6-14-参考链接" class="headerlink" title="6.14 参考链接"></a>6.14 参考链接</h2><ul><li>Jess Telford, <a href="https://github.com/jesstelford/cloverfield-build-make">Example using Makefile for cloverfield</a></li><li>Oskar Schöldström, <a href="http://oxy.fi/2013/02/03/how-to-use-makefiles-in-your-web-projects/">How to use Makefiles in your web projects</a></li><li>James Coglan, <a href="https://blog.jcoglan.com/2014/02/05/building-javascript-projects-with-make/">Building JavaScript projects with Make</a></li><li>Rob Ashton, <a href="http://codeofrob.com/entries/the-joy-of-make-at-jsconfeu.html">The joy of make</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.ruanyifeng.com/blog/2015/02/make.html&quot;&gt;Make 命令教程 — 阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码变成可执行文件，叫做编译（com</summary>
      
    
    
    
    <category term="编译链接与装载" scheme="https://tenloy.github.io/categories/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>常见架构模式: MVC、MVP、MVVM、VIPER</title>
    <link href="https://tenloy.github.io/2021/09/28/architectural-pattern.html"/>
    <id>https://tenloy.github.io/2021/09/28/architectural-pattern.html</id>
    <published>2021-09-28T07:22:58.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译自：<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">iOS Architecture Patterns</a>(模式图也已汉化)。在<a href="http://slides.com/borlov/arch/fullscreen#/">这里</a>可以看到一个幻灯片</p></blockquote><p>在 iOS 中使用 MVC 架构感觉很奇怪？ 迁移到MVVM架构又怀有疑虑？听说过 VIPER 又不确定是否真的值得切换？</p><p>相信你会找到以上问题的答案，如果没找到请在评论中指出。</p><p>你将要整理出你在 iOS 环境下所有关于架构模式的知识。我们将带领大家简要的回顾一些流行的架构，并且在理论和实践上对它们进行比较，通过一些小的例子深化你的认知。如果对文中提到的一些关键词有兴趣，可以点击连接去查看更详细的内容。</p><p>掌控设计模式可能会使人上瘾，所以要当心，你可能会对一些问题清晰明了，不再像阅读之前那样迷惑，比如下面这些问题：</p><ul><li>谁应该来负责网络请求？Model 还是 Controller ？</li><li>应该怎样向一个新的页面的 ViewModel 传入一个 Model ?</li><li>谁来创建一个 VIPER 模块，是 Router 还是 Presenter ?</li></ul><img src="/images/pattern/01.jpg" alt="01" style="zoom:90%;" /><h2 id="一、为什么要关注架构设计？"><a href="#一、为什么要关注架构设计？" class="headerlink" title="一、为什么要关注架构设计？"></a>一、为什么要关注架构设计？</h2><p>因为假如你不关心架构，那么总有一天，需要在同一个庞大的类中调试若干复杂的事情，你会发现在这样的条件下，根本不可能在这个类中快速的找到以及有效的修改任何bug.当然，把这样的一个类想象为一个整体是困难的，因此，有可能一些重要的细节总会在这个过程中会被忽略。如果现在的你正是处于这样一个开发环境中，很有可能具体的情况就像下面这样：</p><ul><li>这个类是一个UIViewController的子类</li><li>数据直接在UIViewController中存储</li><li>UIView类几乎不做任何事情</li><li>Model 仅仅是一个数据结构</li><li>单元测试覆盖不了任何用例</li></ul><p>即使是你遵循了Apple的指导原则并且实现了其 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式，以上这些情况仍旧会出现。不必惊慌，Apple所提出的 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC</a> 模式存在一些问题，我们之后会详述。</p><p>在此，我们可以定义一个好的架构应该具备的特点：</p><ol><li>任务均衡分摊给具有清晰角色的实体</li><li>可测试性通常都来自与上一条（对于一个合适的架构是非常容易）</li><li>易用性和低成本维护</li></ol><h3 id="1-1-为什么采用分布式"><a href="#1-1-为什么采用分布式" class="headerlink" title="1.1 为什么采用分布式?"></a>1.1 为什么采用分布式?</h3><p>采用分布式可以在我们要弄清楚一些事情的原理时保持一个均衡的负载。如果你认为你的开发工作越多，你的大脑越能习惯复杂的思维，其实这是对的。但是，不能忽略的一个事实是，这种思维能力并不是线性增长的，而且也并不能很快的到达峰值。所以，能够战胜这种复杂性的最简单的方法就是在遵循 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一功能原则</a> 的前提下，将功能划分给不同的实体。</p><h3 id="1-2-为什么需要易测性？"><a href="#1-2-为什么需要易测性？" class="headerlink" title="1.2 为什么需要易测性？"></a>1.2 为什么需要易测性？</h3><p>其实这条要求对于哪些习惯了单元测试的人并不是一个问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失效。这就意味着，测试可以避免开发者在运行时才发现问题—-当应用到达用户的设备，每一次维护都需要浪费长达至少<a href="http://appreviewtimes.com/">一周</a>的时间才能再次分发给用户。</p><h3 id="1-3-为什么需要易用性？"><a href="#1-3-为什么需要易用性？" class="headerlink" title="1.3 为什么需要易用性？"></a>1.3 为什么需要易用性？</h3><p>这个问题没有固定的答案，但值得一提的是，最好的代码是那些从未写过的代码。因此，代码写的越少，Bug就越少。这意味着希望写更少的代码不应该被单纯的解释为开发者的懒惰，而且也不应该因为偏爱更聪明的解决方案而忽视了它的维护开销。</p><h2 id="二、MV-X-系列概要"><a href="#二、MV-X-系列概要" class="headerlink" title="二、MV(X)系列概要"></a>二、MV(X)系列概要</h2><p>当今我们已经有很架构设计模式方面的选择:</p><ul><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></li><li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a></li><li><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a></li><li><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a></li></ul><p>前三种设计模式都把一个应用中的实体分为以下三类：</p><ul><li><strong>Models</strong> — 负责主要的数据或者操作数据的<a href="https://en.wikipedia.org/wiki/Data_access_layer">数据访问层</a>，可以想象 Perspn 和 PersonDataProvider 类。</li><li><strong>Views</strong> — 负责展示层（GUI），对于iOS环境可以联想一下以 UI 开头的所有类。</li><li><strong>Controller/Presenter/ViewModel</strong> — 负责协调 Model 和 View，通常根据用户在View上的动作在Model上作出对应的更改，并根据 Model 的更改更新 View。</li></ul><p>将实体进行划分给我们带来了以下好处：</p><ul><li>更好的理解它们之间的关系</li><li>复用（尤其是对于View和Model）</li><li>独立的测试</li></ul><p>让我们开始了解MV(X)系列，之后再返回到VIPER模式。</p><h2 id="三、MVC的过去"><a href="#三、MVC的过去" class="headerlink" title="三、MVC的过去"></a>三、MVC的过去</h2><p>在我们探讨Apple的MVC模式之前，我们来看下<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">传统的MVC模式</a>。</p><img src="/images/pattern/02.png" alt="01" style="zoom:80%;" /><p>在这种情况下，View是无状态的。一旦Model被改变，Controller就会简单地渲染View。就像网页一样，在点击了跳转到某个其他页面的连接之后就会完全的重新加载页面。</p><p>虽然可以在 iOS 应用程序中实现传统的 MVC，但由于架构问题，它没有多大意义 —— 三个实体是紧密耦合的，实体间相互都有通信。这很显然会大大降低了三者的复用性，而这正是我们不愿意看到的。鉴于此我们不再给出例子。</p><blockquote><p>传统的MVC架构不适用于当下的iOS开发</p></blockquote><h2 id="四、苹果的MVC"><a href="#四、苹果的MVC" class="headerlink" title="四、苹果的MVC"></a>四、苹果的MVC</h2><h3 id="4-1-愿景"><a href="#4-1-愿景" class="headerlink" title="4.1 愿景"></a>4.1 愿景</h3><p>Cocoa MVC：</p><img src="/images/pattern/03.png" alt="" style="zoom:80%;" /><p>由于Controller是一个介于View 和 Model之间的协调器，所以View和Model之间没有任何直接的联系。Controller是一个最小可重用单元，这对我们来说是一个好消息，因为我们总要找一个地方来写逻辑复杂度较高的代码，而这些代码又不适合放在Model中。</p><p>理论上来讲，这种模式看起来非常直观，但你有没有感到哪里有一丝诡异？你甚至听说过，有人将MVC的缩写展开成（Massive View Controller），更有甚者，<a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">为View controller减负</a>也成为iOS开发者面临的一个重要话题。如果苹果继承并且对MVC模式有一些进展，所有这些为什么还会发生？</p><h3 id="4-2-现实"><a href="#4-2-现实" class="headerlink" title="4.2 现实"></a>4.2 现实</h3><p>Realistic Cocoa MVC：</p><img src="/images/pattern/04.png" alt="" style="zoom:80%;" /><p>Cocoa的MVC模式驱使人们写出臃肿的视图控制器，因为它们与View的生命周期息息相关，因此很难说View和ViewController是分离的。</p><p>尽管仍可以将业务逻辑和数据转换到Model，但是大多数情况下当需要为View减负的时候我们却无能为力了，很多时候，View的最大的任务就是向Controller传递用户动作事件。</p><p>ViewController最终会承担一切代理和数据源的职责，还负责一些分发和取消网络请求以及一些其他的任务，因此它的名字的由来…你懂的。</p><p>你可能会看见过很多次这样的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var userCell = tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;identifier&quot;</span>) as UserCell</span><br><span class="line">userCell.configureWithUser(user)</span><br></pre></td></tr></table></figure><p>这个cell，就是个直接使用 Model 来配置的 View，此时其实已经违背了MVC的原则，但是这种情况是一直发生的，甚至于人们不觉得这里有哪些不对。如果严格遵守MVC的话，你会把对cell的设置放在 Controller 中，而不是向这个View传递一个Model对象，但这样就会大大增加Controller的体积。</p><blockquote><p>Cocoa 的MVC被写成Massive View Controller 是不无道理的。</p></blockquote><p>直到进行<a href="http://nshipster.com/unit-testing/">单元测试</a>的时候才会发现问题越来越明显。因为你的ViewController和View是紧密耦合的，对它们进行测试就显得很艰难，你得有足够的创造性来模拟View和它们的生命周期，在以这样的方式来写View Controller的同时，业务逻辑的代码也逐渐被分散到View的布局代码中去。</p><p>我们看下一些简单的例子:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123; <span class="comment">// View + Controller</span></span><br><span class="line">    var person: Person!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVC</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.person = model;</span><br></pre></td></tr></table></figure><blockquote><p>MVC可以在一个正在显示的ViewController中实现</p></blockquote><p>这段代码看起来可测试性并不强，我们可以把和greeting相关的都放到GreetingModel中然后分开测试，但是这样我们就无法通过直接调用在GreetingViewController中的UIView相关的方法（viewDidLoad和didTapButton方法）来测试页面的展示逻辑了，因为一旦调用则会使整个页面都变化，这对单元测试来讲并不是什么好消息。</p><p>事实上，在单独一个模拟器中（比如iPhone 4S）加载并测试UIView并不能保证在其他设备中也能正常工作（例如iPad），因此我建议在单元测试的Target的设置下移除”Host Application”项，并且不要在模拟器中测试你的应用。</p><blockquote><p>View和Controller之间的交互 <a href="http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/">并不适合使用单元测试</a> 来测试。</p></blockquote><p>以上所述，似乎Cocoa MVC 看起来是一个相当差的架构方案。我们来重新评估一下文章开头我们提出的MVC一系列的特征:</p><ul><li><strong>任务均摊</strong> —— View和Model确实是分开的，但是View和Controller却是紧密耦合的</li><li><strong>可测试性</strong> —— 由于糟糕的分散性，只能对Model进行测试</li><li><strong>易用性</strong> —— 与其他几种模式相比最小的代码量。熟悉的人很多，因而即使对于经验不那么丰富的开发者来讲维护起来也较为容易。</li></ul><p>如果你不想在架构选择上投入更多精力，那么Cocoa MVC无疑是最好的方案，而且你会发现一些其他维护成本较高的模式对于你所开发的小的应用是一个致命的打击。</p><blockquote><p>就开发速度而言，Cocoa MVC是最好的架构选择方案。</p></blockquote><h2 id="五、MVP-Passive-View"><a href="#五、MVP-Passive-View" class="headerlink" title="五、MVP(Passive View)"></a>五、MVP(Passive View)</h2><h3 id="5-1-MVP-实现了Cocoa的MVC的愿景"><a href="#5-1-MVP-实现了Cocoa的MVC的愿景" class="headerlink" title="5.1 MVP 实现了Cocoa的MVC的愿景"></a>5.1 MVP 实现了Cocoa的MVC的愿景</h3><p>Passive View variant of MVP：</p><img src="/images/pattern/05.png" alt="" style="zoom:75%;" /><p>这看起来不正是苹果所提出的MVC方案吗？确实是的，这种模式的名字是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>（Passive View variant，被动视图变体），但是，这就是说苹果的MVC实际上就是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>了？不，并不是这样的。如果你仔细回忆一下，View是和Controller紧密耦合的，但是MVP的协调器Presenter并没有对ViewController的生命周期做任何改变，因此View可以很容易的被模拟出来。在Presenter中根本没有和布局有关的代码，但是它却负责更新View的数据和状态。</p><blockquote><p>假如告诉你UIViewController就是View呢？</p></blockquote><p>就MVP而言，UIViewController的子类实际上就是Views并不是Presenters。这点区别使得这种模式的可测试性得到了极大的提高，付出的代价是开发速度的一些降低，因为必须要做一些手动的数据和事件绑定，从下例中可以看出：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewPresenter &#123;</span><br><span class="line">    init(view: GreetingView, person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingViewPresenter &#123;</span><br><span class="line">    unowned let view: GreetingView</span><br><span class="line">    let person: Person</span><br><span class="line">    required init(view: GreetingView, person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.view = view</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        let greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var presenter: GreetingViewPresenter!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.presenter.showGreeting()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVP</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter(view: view, person: model)</span><br><span class="line">view.presenter = presenter</span><br></pre></td></tr></table></figure><h3 id="5-2-关于整合问题的重要说明"><a href="#5-2-关于整合问题的重要说明" class="headerlink" title="5.2 关于整合问题的重要说明"></a>5.2 关于整合问题的重要说明</h3><p>MVP是第一个如何协调整合三个实际上分离的层次的架构模式，既然我们不希望View和Model耦合，那么在显示的View Controller（其实就是View）中处理这种协调的逻辑就是不正确的，因此我们需要在其他地方来做这些事情。例如，我们可以做基于整个App范围内的路由服务，由它来负责执行协调任务，以及View到View的展示。这个出现并且必须处理的问题不仅仅是在MVP模式中，同时也存在于以下几种方案中。</p><p>我们来看下MVP模式下的三个特性的分析：</p><ul><li>任务均摊 —— 我们将最主要的任务划分到Presenter和Model，而View的功能较少（虽然上述例子中Model的任务也并不多）。</li><li>可测试性 —— 非常好，由于一个功能简单的View层，所以测试大多数业务逻辑也变得简单</li><li>易用性 —— 在我们上边不切实际的简单的例子中，代码量是MVC模式的2倍，但同时MVP的概念却非常清晰</li></ul><blockquote><p>iOS 中的MVP意味着可测试性强、代码量大。</p></blockquote><h3 id="5-3-变体-—-MVP-Supervising-Controller"><a href="#5-3-变体-—-MVP-Supervising-Controller" class="headerlink" title="5.3 变体 — MVP(Supervising Controller)"></a>5.3 变体 — MVP(Supervising Controller)</h3><p>还有一些其他形态的MVP —— Supervising Controller MVP（监听Controller的MVP）。</p><blockquote><p>核心是：Bindings(绑定)和Hooters(此处译作信号)</p></blockquote><p>这个变体包含了View和Model之间的直接绑定，但是Presenter(Supervising Controller)仍然来管理来自View的动作事件，同时也能胜任对View的更新。</p><p>Supervising Controller variant of the MVP：</p><img src="/images/pattern/07.png" alt="" style="zoom:75%;" /><p>但是我们之前就了解到，模糊的职责划分是非常糟糕的，更何况将View和Model紧密的联系起来。这和Cocoa的桌面开发的原理有些相似。</p><p>和传统的MVC一样，写这样的例子没有什么价值，故不再给出。</p><h2 id="六、MVVM"><a href="#六、MVVM" class="headerlink" title="六、MVVM"></a>六、MVVM</h2><blockquote><p>最新且是最伟大的MV(X)系列的一员</p></blockquote><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a>架构是MV(X)系列最新的一员，因此让我们希望它已经考虑到MV(X)系列中之前已经出现的问题。</p><p>从理论层面来讲MVVM看起来不错，我们已经非常熟悉View和Model，以及Meditor，在MVVM中它是View Model。</p><img src="/images/pattern/08.png" alt="" style="zoom:75%;" /><p>它和MVP模式看起来非常像:</p><ul><li>MVVM将ViewController视作View</li><li>在View和Model之间没有紧密的联系</li></ul><p>此外，它还有像监管(Supervising)版本的MVP那样的绑定功能，但这个绑定不是在View和Model之间，而是在View和ViewModel之间。</p><p>那么问题来了，在iOS中ViewModel实际上代表什么？它基本上就是UIKit下的每个控件以及控件的状态。ViewModel调用会改变Model同时会将Model的改变更新到自身，并且因为我们绑定了View和ViewModel，第一步就是相应的更新状态。</p><h3 id="6-2-绑定"><a href="#6-2-绑定" class="headerlink" title="6.2 绑定"></a>6.2 绑定</h3><p>我在MVP部分已经提到这点了，但是该部分我们仍会继续讨论。</p><p>如果我们自己不想自己实现，那么我们有两种选择:</p><ul><li>基于KVO的绑定库如 <a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a> 和 <a href="https://github.com/SwiftBond/Bond">SwiftBond</a></li><li>完全的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6">函数响应式编程</a>，比如像<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>、<a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>或者 <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li></ul><p>事实上，尤其是最近，你听到MVVM就会想到ReactiveCoca，反之亦然。尽管通过简单的绑定来使用MVVM是可实现的，但是ReactiveCocoa却能更好的发挥MVVM的特点。</p><p>但是关于这个框架有一个不得不说的事实：强大的能力来自于巨大的责任。当你开始使用Reactive的时候有很大的可能就会把事情搞砸。换句话来说就是，如果发现了一些错误，调试出这个bug可能会花费大量的时间，看下 Reactive Debugging 函数调用栈：</p><img src="/images/pattern/09.jpg" alt="" style="zoom:90%;" /><p>在我们简单的例子中，FRF框架和KVO被过渡禁用，取而代之地我们直接去调用showGreeting方法更新ViewModel，以及通过greetingDidChange 回调函数使用属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Model</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewModelProtocol: <span class="keyword">class</span> &#123;</span><br><span class="line">    var greeting: String? &#123; get &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; <span class="comment">// function to call when greeting did change</span></span><br><span class="line">    init(person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewModel : GreetingViewModelProtocol &#123;</span><br><span class="line">    let person: Person</span><br><span class="line">    var greeting: String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.greetingDidChange?(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</span><br><span class="line">    required init(person: Person) &#123;</span><br><span class="line">        <span class="keyword">self</span>.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greeting = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">self</span>.person.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span> &#123;</span><br><span class="line">    var viewModel: GreetingViewModelProtocol! &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            <span class="keyword">self</span>.viewModel.greetingDidChange = &#123; [unowned <span class="keyword">self</span>] viewModel <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.greetingLabel.text = viewModel.greeting</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>.viewModel, action: <span class="string">&quot;showGreeting&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of MVVM</span></span><br><span class="line">let model = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>)</span><br><span class="line">let viewModel = GreetingViewModel(person: model)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.viewModel = viewModel</span><br></pre></td></tr></table></figure><p>让我们再来看看关于三个特性的评估：</p><ul><li>任务均摊 —— 在例子中并不是很清晰，但是事实上，MVVM的View要比MVP中的View承担的责任多。因为前者通过ViewModel的设置绑定来更新状态，而后者只监听Presenter的事件但并不会对自己有什么更新。</li><li>可测试性 —— ViewModel不知道关于View的任何事情，这允许我们可以轻易的测试ViewModel。同时View也可以被测试，但是由于属于UIKit的范畴，对他们的测试通常会被忽略。</li><li>易用性 —— 在我们例子中的代码量和MVP的差不多，但是在实际开发中，我们必须把View中的事件指向Presenter并且手动的来更新View，如果使用绑定的话，MVVM代码量将会小的多。</li></ul><blockquote><p>MVVM很诱人，因为它集合了上述方法的优点，并且由于在View层的绑定，它并不需要其他附加的代码来更新View，尽管这样，可测试性依然很强。</p></blockquote><h2 id="七、VIPER"><a href="#七、VIPER" class="headerlink" title="七、VIPER"></a>七、VIPER</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><blockquote><p>VIPER —— 把LEGO建筑经验迁移到iOS app的设计</p></blockquote><p><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a>是我们最后要介绍的，由于不是来自于MV(X)系列，它具备一定的趣味性。</p><p>迄今为止，划分责任的粒度是很好的选择。VIPER在责任划分层面进行了迭代，VIPER分为五个层次:</p><img src="/images/pattern/10.png" alt="" style="zoom:70%;" /><p>VIPER</p><ul><li><strong>交互器</strong> —— 包括关于数据和网络请求的业务逻辑，例如创建一个实体（数据），或者从服务器中获取一些数据。为了实现这些功能，需要使用服务、管理器，但是他们并不被认为是VIPER架构内的模块，而是外部依赖。</li><li><strong>展示器</strong> —— 包含UI层面的业务逻辑以及在交互器层面的方法调用。</li><li><strong>实体</strong> —— 普通的数据对象，不属于数据访问层次，因为数据访问属于交互器的职责。</li><li><strong>路由器</strong> —— 用来连接VIPER的各个模块。</li></ul><p>基本上，VIPER模块可以是一个屏幕或者用户使用应用的整个过程 —— 例如认证过程，可以由一屏完成或者需要几步才能完成，你的模块期望是多大的，这取决于你。</p><p>当我们把VIPER和MV(X)系列作比较时，我们会在任务均摊性方面发现一些不同:</p><ul><li><strong>Model</strong>（数据交互）逻辑以实体（Entities）为单位（作为最小的数据结构）拆分到交互器（Interactor）中。</li><li><strong>Controller/Presenter/ViewModel</strong>的UI展示方面的职责移到了Presenter中，但是并没有数据转换相关的操作。</li><li><strong>VIPER</strong>是第一个通过路由器（Router）实现明确的地址导航模式。</li></ul><blockquote><p>找到一个适合的方法来实现路由对于iOS应用是一个挑战，MV(X)系列避开了这个问题。</p></blockquote><p>例子中并不包含路由和模块之间的交互，所以和MV(X)系列部分架构一样不再给出例子。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">UIKit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person &#123; <span class="comment">// Entity (usually more complex e.g. NSManagedObject)</span></span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> GreetingData &#123; <span class="comment">// Transport data structure (not Entity)</span></span><br><span class="line">    let greeting: String</span><br><span class="line">    let subject: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingProvider &#123;</span><br><span class="line">    func provideGreetingData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingOutput: <span class="keyword">class</span> &#123;</span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingInteractor : GreetingProvider &#123;</span><br><span class="line">    <span class="keyword">weak</span> var output: GreetingOutput!</span><br><span class="line">    </span><br><span class="line">    func provideGreetingData() &#123;</span><br><span class="line">        let person = Person(firstName: <span class="string">&quot;David&quot;</span>, lastName: <span class="string">&quot;Blaine&quot;</span>) <span class="comment">// usually comes from data access layer</span></span><br><span class="line">        let subject = person.firstName + <span class="string">&quot; &quot;</span> + person.lastName</span><br><span class="line">        let greeting = GreetingData(greeting: <span class="string">&quot;Hello&quot;</span>, subject: subject)</span><br><span class="line">        <span class="keyword">self</span>.output.receiveGreetingData(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewEventHandler &#123;</span><br><span class="line">    func didTapShowGreetingButton()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: <span class="keyword">class</span> &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</span><br><span class="line">    <span class="keyword">weak</span> var view: GreetingView!</span><br><span class="line">    var greetingProvider: GreetingProvider!</span><br><span class="line">    </span><br><span class="line">    func didTapShowGreetingButton() &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingProvider.provideGreetingData()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</span><br><span class="line">        let greeting = greetingData.greeting + <span class="string">&quot; &quot;</span> + greetingData.subject</span><br><span class="line">        <span class="keyword">self</span>.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> GreetingViewController : <span class="built_in">UIViewController</span>, GreetingView &#123;</span><br><span class="line">    var eventHandler: GreetingViewEventHandler!</span><br><span class="line">    let showGreetingButton = <span class="built_in">UIButton</span>()</span><br><span class="line">    let greetingLabel = <span class="built_in">UILabel</span>()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">self</span>.showGreetingButton.addTarget(<span class="keyword">self</span>, action: <span class="string">&quot;didTapButton:&quot;</span>, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func didTapButton(button: <span class="built_in">UIButton</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.eventHandler.didTapShowGreetingButton()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// layout code goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Assembling of VIPER module, without Router</span></span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter()</span><br><span class="line">let interactor = GreetingInteractor()</span><br><span class="line">view.eventHandler = presenter</span><br><span class="line">presenter.view = view</span><br><span class="line">presenter.greetingProvider = interactor</span><br><span class="line">interactor.output = presenter</span><br></pre></td></tr></table></figure><p>让我们再来评估一下特性:</p><ul><li>任务均摊 —— 毫无疑问，VIPER是任务划分中的佼佼者。</li><li>可测试性 —— 不出意外地，更好的分布性就有更好的可测试性。</li><li>易用性 —— 最后你可能已经猜到了维护成本方面的问题。你必须为很小功能的类写出大量的接口。</li></ul><h3 id="7-2-什么是LEGO"><a href="#7-2-什么是LEGO" class="headerlink" title="7.2 什么是LEGO"></a>7.2 什么是LEGO</h3><p>当使用VIPER时，你的感觉就像是用乐高积木来搭建一个城堡，这也是一个表明当前存在一些问题的信号。可能现在就应用VIPER架构还为时过早，考虑一些更为简单的模式可能会更好。一些人会忽略这些<a href="https://inessential.com/2014/03/16/smaller_please">问题</a>，大材小用。假定他们笃信VIPER架构会在未来给他们的应用带来一些好处，虽然现在维护起来确实是有些不合理。如果你也持这样的观点，我为你推荐 <a href="https://github.com/rambler-ios/Generamba">Generamba</a> 这个用来搭建VIPER架构的工具。虽然我个人感觉，使用起来就像加农炮的自动瞄准系统，而不是简单的像投石器那样的简单的抛掷。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>我们了解了集中架构模式，希望你已经找到了到底是什么在困扰你。毫无疑问通过阅读本篇文章，你已经了解到其实并没有完全的银弹。所以选择架构是一个根据实际情况具体分析利弊的过程。</p><p>因此，在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，然后突然意识到一个页面在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;译自：&lt;a href=&quot;https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52&quot;&gt;iOS Architecture Patterns&lt;/a&gt;(模式</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的设计模式</title>
    <link href="https://tenloy.github.io/2021/09/25/design-pattern.html"/>
    <id>https://tenloy.github.io/2021/09/25/design-pattern.html</id>
    <published>2021-09-25T09:37:12.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、架构相关术语"><a href="#一、架构相关术语" class="headerlink" title="一、架构相关术语"></a>一、架构相关术语</h1><h2 id="1-1-架构"><a href="#1-1-架构" class="headerlink" title="1.1 架构"></a>1.1 架构</h2><p>软件架构就是软件的基本结构。是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。</p><p>软件架构会包括软件组件、组件之间的关系，组件特性以及组件间关系的特性，如类与类之间的关系、模块与模块之 间的关系、客户端与服务端的关系。</p><p>五种常见的软件架构，<a href="http://www.ruanyifeng.com/blog/2016/09/software-architecture.html">软件架构入门 — 阮一峰</a></p><ul><li>分层架构<ul><li>三层：展现层、业务层、数据层</li><li>四层：展现层、业务层、网络层、本地数据层</li></ul></li><li>事件驱动架构</li><li>微核架构(又称插件架构)</li><li>微服务架构</li><li>云架构</li></ul><h2 id="1-2-架构与框架"><a href="#1-2-架构与框架" class="headerlink" title="1.2 架构与框架"></a>1.2 架构与框架</h2><blockquote><p><a href="https://cloud.tencent.com/developer/article/1438723">架构和框架的区别 原文链接</a></p></blockquote><p>人们对软件架构存在非常多的误解，其中一个最为普遍的误解就是：将架构（Architecture）和框架（Framework）混为一谈。其实很简单， 一句话：框架是软件，架构不是软件。</p><ul><li>框架落脚在“架”字上，可以理解成名词性的，是一个客观性的名词存在，如.Net Framework； </li><li>架构体现在“构”字上，理解成构造，是一个动词性的，是一系列动作发生的策略性体现。</li></ul><p><strong>框架是一种特殊的软件</strong>，它并不能提供完整无缺的解决方案，而是为构建整个解决方案提供良好的基础。</p><ul><li>框架是半成品。典型地，框架是系统或子系统的半成品；框架中的服务尅被最终应用系统直接调用，而框架中的扩展点是供应用开发人 员定制的“可变化点”。</li></ul><p><strong>架构不是软件</strong>，而是一种设计理念(思想)，是关于软件如何设计的重要策略。</p><ul><li>软件架构决策设计到如何将软件系统分解成不同的部分、各部分之间的静态结构关系和动态交互关系等。</li><li>经过完整的开发过程之后，这些架构决策将体现在最终开发出的软件系统中；当然，引入软件架构之后，整个开发过程变成了“分两步走”，而架构决策往往会体现在框架之中。或许，人们常把架构和框架混为一谈的原因就在于此吧！我们不能指着某些代码，说这就是软件架构，因为软件架构是比具体代码高一个抽象层次的概念。 </li><li><strong>架构势必被代码所体现和遵循，但任何一段具体的代码都代表不了架构</strong>。</li></ul><p>框架技术和架构技术的出现，都是为了解决软件系统日益复杂所带来的困难而采取“分而治之”思维的结果—–先大局后局部，就出现了架构；先通用后专用，就出现了框架。</p><p>简而言之，框架和架构的关系可以总结为两句话：</p><ul><li>为了尽早验证架构设计，或者处于支持产品线开发的目的，可以<strong>将关键的通用机制甚至整个架构以框架的方式进行实现</strong>；</li><li>业界（及公司内部）可能存在大量可供重用的框架，这些框架或者已经实现了软件架构所需的重要架构机制，或者为未来系统的某个子 系统提供了可扩展的半成品，所以<strong>最终的软件架构可以借助这些框架构造</strong>。</li></ul><h2 id="1-3-架构模式"><a href="#1-3-架构模式" class="headerlink" title="1.3 架构模式"></a>1.3 架构模式</h2><p>架构模式是软件架构中在给定环境下，针对常遇到的问题的、通用且可重用的解决方案。—— 维基百科</p><ul><li><p>类似于软件设计模式，但覆盖范围更广，致力于软件工程中不同问题，如计算机硬件性能限制、高可用性、业务风险极小化。一些架构模式会透过软件框架实现。</p></li><li><p>维基百科中，将MVC、MVVM等称为架构模式。(在Head First设计模式中，也将其称为复合设计模式(是作者的个人名词)，是指将两个以上的普通设计模式结合而成的新设计模式)。</p></li></ul><h2 id="1-4-设计模式"><a href="#1-4-设计模式" class="headerlink" title="1.4 设计模式"></a>1.4 设计模式</h2><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</p><ul><li>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</li><li>面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。</li><li>设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</li></ul><p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p><h2 id="1-5-内聚、耦合"><a href="#1-5-内聚、耦合" class="headerlink" title="1.5 内聚、耦合"></a>1.5 内聚、耦合</h2><h3 id="1-5-1-内聚性"><a href="#1-5-1-内聚性" class="headerlink" title="1.5.1 内聚性"></a>1.5.1 内聚性</h3><p>内聚性（Cohesion）也称为内聚力，是从功能角度来度量<strong>模块内的组成部分之间相互联系的紧密程度</strong>。</p><p>因为：</p><ul><li>当一个模块或一个类被设计成只支持一组相关的功能时，那内聚性肯定很高。</li><li>反之，当被设计成支持一组不相关的功能时，那模块内的组成部分联系紧密程度肯定不高，也就是低内聚。</li></ul><p>所以，内聚性也用来衡量一个类或模块是否达到单一目的或责任。</p><p><strong>内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，比背负很多责任的低内聚类更容易维护</strong>。</p><p>一般会希望程序的模块有高内聚性，因为高内聚性一般和许多理想的软件特性有关，包括鲁棒性、可靠度、可复用性及易懂性等特性，而低内聚性一般也代表不易维护、不易测试、不易复用以及难以理解。</p><h3 id="1-5-2-耦合性"><a href="#1-5-2-耦合性" class="headerlink" title="1.5.2 耦合性"></a>1.5.2 耦合性</h3><p>耦合性（Coupling，Dependency）或称耦合力或耦合度，是一个和内聚性相对的概念。描述的是软件结构中，<strong>模块及模块之间联系的紧密程度，可以体现在，信息或参数依赖的程度</strong>。</p><blockquote><p>耦合度，可以简单理解为当一个类发生变更时，对其他类造成的影响程度，影响越小则耦合度越弱，影响越大耦合度越强。</p></blockquote><p>耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p><p>一般而言高内聚性代表低耦合性，反之亦然。内聚性是由赖瑞·康斯坦丁所提出，是以实务上可减少维护及修改的“好”软件的特性为基础。</p><h3 id="1-5-3-高内聚、松耦合"><a href="#1-5-3-高内聚、松耦合" class="headerlink" title="1.5.3 高内聚、松耦合"></a>1.5.3 高内聚、松耦合</h3><p>软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚；而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合。</p><h2 id="1-6-透明-对xx透明"><a href="#1-6-透明-对xx透明" class="headerlink" title="1.6 透明(对xx透明)"></a>1.6 透明(对xx透明)</h2><p>在汉语中，透明有以下两种看起来截然相反的含义：(前者是看的清清楚楚，后者是看不到)</p><ul><li>比喻公开而无遮掩。比如建立一个公开、公正、 透明的用人制度。</li><li>能透过光线的。比如透明玻璃。（<font color='red'>对xx透明，意思就是xx看不到该事物/属性</font>）<ul><li>虽然在日常使用中所指的“透明”是对可见光，但它也可以延伸到用于指代任何种类的辐射。</li><li>例如医学中：肉体对X光是透明的，但骨头却不是，使得X光成像对医疗非常有用。</li><li>例如计算机中：计算机术语“透明”是指客观存在并且运行着但是我们看不到的特性。即它客观存在，但对于大多数、特定类别的开发人员而言是不需要了解的东西，这就是计算机学中所指的透明。换种说法，透明就是一个黑盒，你只需要应用它给出的接口，而不需要了解其内在机理。<ul><li>计算机组织对电脑用户是透明的，就是说计算机组织对用户来说是看不到的，也不需要看到的。</li><li>透传，即透明传输（pass-through），指的是在通讯中不管传输的业务内容如何，只负责将传输的内容由源地址传输到目的地址，而不对业务数据内容做任何改变。<ul><li>从上层角度看，似乎就是一个透明的管道，什么都可以传。</li><li>非透明传输就是底层协议要对传输内容有限制或者修改。</li></ul></li></ul></li></ul></li></ul><p>注意：计算机中，有些场景的“透明”，也会被人错表达为第一种的意思，阅读时需要结合上下文理解，避免被误导。</p><h2 id="1-7-程序设计中的抽象与接口"><a href="#1-7-程序设计中的抽象与接口" class="headerlink" title="1.7 程序设计中的抽象与接口"></a>1.7 程序设计中的抽象与接口</h2><p><em>此处，并不是指编程语言中的抽象类、接口类。而是程序设计中的抽象、接口概念。</em></p><h3 id="抽象和抽象化的两种解读"><a href="#抽象和抽象化的两种解读" class="headerlink" title="抽象和抽象化的两种解读"></a>抽象和抽象化的两种解读</h3><p>抽象：</p><ul><li>从众多的具体事物中，抽取共同的、本质的属性，舍弃个别的、非本质的属性，从而形成概念。（所以抽象作为形容词，也意味着不具体的、笼统的；空洞的（跟「具体」相对））</li><li>将复杂物体的一个或几个特性抽出去而只注意其他特性的行动或过程(如头脑只思考树本身的形状或只考虑树叶的颜色，不受它们的大小和形状的限制)。比如：<ul><li>抽象艺术：打破了艺术原来强调主题写实再现的局限，把艺术基本要素，进行抽象的组合，创造出抽象的形式，因而突破了艺术必须具有可以辨认形象的籓篱，开创了艺术新的发展天地。</li><li>抽象画：与自然物象极少或完全没有相近之处，而又具强烈的形式构成面貌的绘画。</li></ul></li></ul><p>与上面对应，抽象化也有了两种解读：</p><ul><li>忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li>在计算机科学中，抽象化（Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是<strong>隐藏起它的实现细节</strong>。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。—— 维基百科<ul><li>为了使抽象的成品（算法）不会出现问题，要注意抽象时是否漏掉重要特征。</li></ul></li></ul><p>程序设计中，需要根据上下文来区分语义。(<em>尤其是桥接模式那里….乍得一看，都被定义搞晕了</em>)。编程语言中的抽象类、接口类中，抽象很明显是前种含义。</p><h3 id="程序设计接口"><a href="#程序设计接口" class="headerlink" title="程序设计接口"></a>程序设计接口</h3><p>接口或界面（interface）泛指<strong>实体把自己提供给外界的一种抽象化物</strong>（可以为另一实体），用以由内部操作分离出<strong>外部沟通方法</strong>，使其能被修改内部而不影响外界其他实体与其交互的方式，就如面向对象编程提供的多重抽象化。</p><p>接口可能也提供某种意义上的在讲不同语言的实体之间的翻译，诸如人类与电脑之间。因为接口是一种间接手段，所以相比起直接沟通，会引致些额外负担。</p><p>常见的接口：</p><ul><li>人类与电脑等信息机器或人类与程序之间的接口称为用户界面。</li><li>电脑等信息机器硬件组件间的接口叫硬件接口。</li><li>电脑等信息机器软件组件间的接口叫软件接口，其存在于分离的软件组件间，并提供一种机制使这些组件可以沟通。</li></ul><p>程序编写或设计的方法论中所关心的接口，是作为程序组件功能的抽象化，属于软件接口的一类。提供给软件组件间的接口会被访问到的事物的种类可以包括：常量、资料类型、程序的种类、例外规格、类型签名。在某些个案，定义变量作为接口的一部分可能会很有用。</p><h2 id="1-8-关注点分离原则（SOC）"><a href="#1-8-关注点分离原则（SOC）" class="headerlink" title="1.8 关注点分离原则（SOC）"></a>1.8 关注点分离原则（SOC）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>关注点分离 (<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns，SoC</a>) 是将计算机程序分成不同部分的设计原则。每个部分负责处理一个不同的关注点(<a href="https://en.wikipedia.org/wiki/Concern_(computer_science)">concern</a>)。</p><ul><li><em>说是设计原则，但因为太过基本、深刻，所以一般讲设计原则时，有时不会将其列在内。</em></li></ul><p>关注点是对计算机程序代码(<em>的执行结果</em>)有影响的一组特定信息。</p><ul><li>关注点可以<strong>很宽泛</strong>，比如“应用程序的硬件细节”、“数据库交互的细节”；也可以<strong>很具体</strong>，比如“要实例化的类的名称”。</li><li>横切关注点(<a href="https://en.wikipedia.org/wiki/Cross-cutting_concern">Cross-cutting concern</a>)：也是程序的一部分，但它会依赖或影响程序的其他多个部分。<ul><li>一般是不会影响到系统核心功能的信息，其通常会作为一些附加功能，横切多个核心关注点模块。</li><li>比如：日志记录模块。因为日志记录策略必然会影响系统的每个已记录部分。因此，日志记录横切所有记录的类和方法，即日志代码会复制分散到各个相关位置。其他如信息安全、监控、数据验证模块等。</li><li>AOP旨在将横切关注点封装到<em>切面</em>(<em>aspects</em>)以保持模块化。这允许对处理封装横切关注点的代码进行干净的隔离和重用。</li></ul></li></ul><p>所以关注点分离的应用，可大到系统架构层次，也可小到特定的类或函数的设计。</p><p><strong>能够很好地体现 SoC 的程序称为模块化(modular)程序</strong>。通过将信息封装在具有良好定义接口的代码段中，可以实现模块化，从而实现关注点分离。封装是一种信息隐藏的手段。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>模块化：将整个程序的代码分开成各部分的高层分解（<strong>横向分离</strong>成模块或子系统）；</li><li>架构层次：比如分层架构，将关注点<strong>纵向分离</strong>为表示层、业务逻辑层、数据访问层、持久层等。</li><li>架构模式层次：比如MVC 或 MVP 等架构设计模式可以将数据(Model)、显示(View)、控制(Controller，控制和处理输入输出等)三者分离。</li><li>编程思想上的体现：<ul><li>面向过程编程，将关注点分离为过程或函数；</li><li>面向对象编程，将关注点分离为对象；</li><li>函数式编程，将关注点分离为函数；</li><li>面向切面编程，将关注点分离为切面(aspects)和对象等；</li></ul></li><li>更低层的，比如：<ul><li>OOP中，单一职责原则(SRP)，规定一个类应该只有一个引起它变化的原因(<em>关注点</em>)，否则类应该被拆分。</li><li>同理，接口、函数的拆分等。</li></ul></li></ul><p>这也是SOC与OOP原则之单一职责原则(SRP)的区别：</p><ul><li>SOC是设计原则，除了OOP，还适用于其他很多的编程思想中。</li><li>本质区别是<strong>关注点分离的划分模块的大小</strong>，SOC中模块可大到架构分层，可小到函数设计。<strong>SRP原则可以看做是SOC在OOP编程中，Class 层次的一种实现。</strong></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>关注点分离的价值在于简化计算机程序的开发和维护。当关注点分开时，各部分可以重复使用，以及独立开发和更新。</p><p>关注点分离是一种抽象形式。与大多数抽象一样，分离关注点意味着添加额外的代码接口，通常会创建更多要执行的代码。</p><h1 id="二、设计模式中对象之间的关系"><a href="#二、设计模式中对象之间的关系" class="headerlink" title="二、设计模式中对象之间的关系"></a>二、设计模式中对象之间的关系</h1><p>在面向对象设计模式中，类与类之间主要有6种关系，他们分别是：依赖、关联、聚合、组合、泛化、实现。</p><p>它们的耦合度依次增强。</p><h2 id="2-1-依赖-dependency"><a href="#2-1-依赖-dependency" class="headerlink" title="2.1 依赖(dependency)"></a>2.1 依赖(dependency)</h2><blockquote><p>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</p></blockquote><p>依赖(Dependency)关系是类与类之间的联接，表示一个类依赖于另一个类的定义。<strong>一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。</strong></p><p>依赖关系用一条带箭头的虚线表示（A依赖于B）。</p><img src="/images/pattern/17.jpg" alt="21" style="zoom:100%;" /><h2 id="2-2-关联-association"><a href="#2-2-关联-association" class="headerlink" title="2.2 关联(association)"></a>2.2 关联(association)</h2><blockquote><p>对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</p></blockquote><p><strong>关联关系分为单向关联和双向关联。</strong></p><ul><li>单向关联表现为：类A当中使用了类B，其中类B是作为类A的成员变量。</li><li>双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。</li></ul><p>关联(Association）关系是类与类之间的联接，它使一个类知道另一个类的属性和方法。<strong>关联关系一般使用成员变量来实现。</strong></p><p><strong>注意：</strong></p><ol><li>java双向关联关系代码样例会抛出java.lang.StackOverflowError(未实验)</li><li>在OC中双向关联时，注意不要引起循环导入(会编译报错的)</li></ol><p>关联关系用一条带箭头的实线表示（表示A关联了B，但 B没关联A）。</p><img src="/images/pattern/18.jpg" alt="21" style="zoom:100%;" /><h2 id="2-3-聚合-aggregation"><a href="#2-3-聚合-aggregation" class="headerlink" title="2.3 聚合(aggregation)"></a>2.3 聚合(aggregation)</h2><blockquote><p><strong>聚合关系是关联关系的一种</strong>，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p></blockquote><p>聚合(Aggregation) 是<strong>强的关联关系。聚合是整体和个体之间的关系。</strong>与关联关系一样，<strong>聚合关系也是通过实例变量实现的。</strong>但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</p><p><strong>例如：</strong>部门类与员工类，部门由员工组成，部门解散员工照样生活。</p><p>聚合关系用一条带空心菱形箭头的实线表示（A聚合到B上，或者说B由A组成）。</p><img src="/images/pattern/19.jpg" alt="21" style="zoom:100%;" /><h2 id="2-4-组合-composition"><a href="#2-4-组合-composition" class="headerlink" title="2.4 组合(composition)"></a>2.4 组合(composition)</h2><blockquote><p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系。一般来说，为了表示组合关系，<strong>常常会使用构造方法来达到初始化的目的</strong>，在初始化的时候，就将”部分”传入。</p></blockquote><ul><li><strong>它要求普通的聚合关系中”整体”负责”部分”的生命周期，它们之间是共生共死的</strong>，并且”部分”单独存在时没有任何意义。”整体”负责保持”部分“存活，在一些情况下将”部分”湮灭掉</li><li><strong>组合关系是不能共享的，</strong>整体“可以将”部分”传递给另一个对象，由后者负责其的生命周期。换言之，”部分”在每一个时刻只能与一个对象发生组合关系，由后者排他地负责生命周期。部分和整体的生命周期一样。</li></ul><p><strong>举例</strong>：</p><ul><li>公司类与部门类。公司由部门组成，公司破产倒闭，部门则不复存在，没有部门存在，公司也没有了。</li><li>人class与灵魂类、肉体类。当人的生命周期开始时，必须同时有灵魂和肉体；当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</li></ul><p>组合关系用一条带实心菱形箭头的实线表示（A组成B，或者B由A组成）。</p><img src="/images/pattern/20.jpg" alt="21" style="zoom:100%;" /><h2 id="2-5-泛化-generalization"><a href="#2-5-泛化-generalization" class="headerlink" title="2.5 泛化(generalization)"></a>2.5 泛化(generalization)</h2><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)。</p><p>继承关系为 is-a的关系；反之，两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>泛化关系表现为继承非抽象类；</p><p>类图中，泛化关系用一条带空心三角箭头的实线表示（A继承自B）。</p><img src="/images/pattern/21.jpg" alt="21" style="zoom:100%;" /><h2 id="2-6-实现-realize"><a href="#2-6-实现-realize" class="headerlink" title="2.6 实现(realize)"></a>2.6 实现(realize)</h2><p>实线，又称为细化。表现为继承抽象类；</p><p>类图中，实现关系用一条带空心三角箭头的虚线表示；</p><img src="/images/pattern/23.jpg" alt="23" style="zoom:100%;" /><p><strong>关联、聚合、组合只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联，聚合，还是组合关系，则是无法判断的。</strong></p><h2 id="2-7-关联与继承优缺点对比"><a href="#2-7-关联与继承优缺点对比" class="headerlink" title="2.7 关联与继承优缺点对比"></a>2.7 关联与继承优缺点对比</h2><p>在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。如装饰者模式、桥接模式都是这个原则的体现。</p><p>在《阿里巴巴Java开发手册》中也重申了此设计原则：谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。不得已使用继承时，必须符合里氏替换原则。</p><p><a href="https://juejin.cn/post/6844903938106343431">为什么阿里巴巴建议开发者谨慎使用继承？</a></p><table><thead><tr><th>关联关系</th><th>继承关系</th></tr></thead><tbody><tr><td>优点：不破坏封装，<strong>更安全</strong>。</td><td>缺点：破坏封装。</td></tr><tr><td>优点：整体类与局部类之间松耦合，彼此相对独立，<strong>灵活性高</strong>。</td><td>缺点：子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性。也称继承具备强侵入性（父类代码侵入子类）</td></tr><tr><td>优点：具有较好的<strong>可扩展性</strong>。</td><td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td></tr><tr><td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td><td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td></tr><tr><td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td><td>缺点：子类不能改变父类的接口（3.2节 里氏替换原则）</td></tr><tr><td>缺点：整体类不能自动获得和局部类同样的接口</td><td>优点：子类能自动继承父类的接口。（父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能。）</td></tr><tr><td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td><td>优点：创建子类的对象时，无须创建父类的对象</td></tr></tbody></table><h3 id="继承破坏封装？"><a href="#继承破坏封装？" class="headerlink" title="继承破坏封装？"></a>继承破坏封装？</h3><p>封装：通过公有化方法访问私有化属性，使得数据不容易被任意窜改，常用private修饰属性；</p><p>继承：通过子类继承父类从而获得父类的属性和方法，正常情况下，用protected修饰属性，专门用于给子类继承的，权限一般在本包下和子类里；</p><p>继承破坏了封装：是因为属性的访问修饰符被修改，使得属性在本包和子类里可以任意修改属性的数据，数据的安全性从而得不到保障。</p><h3 id="何时使用继承？"><a href="#何时使用继承？" class="headerlink" title="何时使用继承？"></a>何时使用继承？</h3><ul><li>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型（<em>是否要使用多态</em>）。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。  —— 《Java编程思想》</li><li>只有当子类真正是超类的子类型时，才适合用继承（<em>从现实语义进行思考</em>）。换句话说，对于两个类A和B，只有当两者之间确实存在is-a关系的时候，类B才应该继续类A。  —— 《Effective Java》</li></ul><h2 id="2-8-补充：委托"><a href="#2-8-补充：委托" class="headerlink" title="2.8 补充：委托"></a>2.8 补充：委托</h2><p>委托：是设计模式中的一项基本技巧。</p><p>有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。 —— 维基百科</p><p><em>感觉这个与关联的概念很相似。虽然说委托模式，但应该不算是一种模式。</em></p><h1 id="三、面向对象的七大设计原则"><a href="#三、面向对象的七大设计原则" class="headerlink" title="三、面向对象的七大设计原则"></a>三、面向对象的七大设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><blockquote><p>OO原则是我们的目标，而设计模式是我们的做法。每个设计模式背后都包含了几个OO原则的概念，很多时候，在设计时有两难的情况，这时候我们必须回归到OO原则，以方便判断取舍。 — 《Header First 设计模式》</p></blockquote><p><strong>所有的原则、设计模式最终都是为了：松耦合、易复用、方便开发维护。</strong></p><p>SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。</p><h2 id="3-1-开放-封闭原则（OCP）"><a href="#3-1-开放-封闭原则（OCP）" class="headerlink" title="3.1 开放-封闭原则（OCP）"></a>3.1 开放-封闭原则（OCP）</h2><h3 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h3><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶提出，他在 1988 年的著作《面向对象软件构造》中提出：<strong>软件实体应当对扩展开放，对修改关闭</strong>，这就是开闭原则的经典定义。</p><p>这里的软件实体包括以下几个部分：</p><ol><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ol><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h3 id="3-1-2-作用"><a href="#3-1-2-作用" class="headerlink" title="3.1.2 作用"></a>3.1.2 作用</h3><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p><ul><li>对软件测试的影响<ul><li>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li></ul></li><li>可以提高代码的可复用性<ul><li>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li></ul></li><li>可以提高软件的可维护性<ul><li>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</li></ul></li></ul><h3 id="3-1-3-封装变化原则"><a href="#3-1-3-封装变化原则" class="headerlink" title="3.1.3 封装变化原则"></a>3.1.3 封装变化原则</h3><blockquote><p><strong>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</strong>。 —— Header First设计模式</p></blockquote><p>换句话说，如果毎次新的需求一来，都会使某方面的代码发生变化，那么你就可以确定，这部分的代码需要被抽出来，和其他稳定的代码有所区分。</p><p>下面是这个原则的另一种思考方式：“把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分“。使得代码变化的不经意后果变少，变得更有弹性。</p><p>这样的概念很简单，几乎是毎个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”。</p><h3 id="3-1-4-实现"><a href="#3-1-4-实现" class="headerlink" title="3.1.4 实现"></a>3.1.4 实现</h3><h4 id="抽象约束、封装变化"><a href="#抽象约束、封装变化" class="headerlink" title="抽象约束、封装变化"></a>抽象约束、封装变化</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>举例：</p><ul><li>如装饰者模式</li><li>简单些的，如下面例子</li></ul><h3 id="3-1-5-举例"><a href="#3-1-5-举例" class="headerlink" title="3.1.5 举例"></a>3.1.5 举例</h3><p>下面以 Windows 的桌面主题为例介绍开闭原则的应用。</p><p>分析：Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的，其类图如下所示。</p><img src="/images/pattern/11.png" alt="11" style="zoom:100%;" /><h2 id="3-2-里氏替换原则（LSP）"><a href="#3-2-里氏替换原则（LSP）" class="headerlink" title="3.2 里氏替换原则（LSP）"></a>3.2 里氏替换原则（LSP）</h2><h3 id="对继承的理解"><a href="#对继承的理解" class="headerlink" title="对继承的理解"></a>对继承的理解</h3><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性。</p><p>当对继承体系中的类修改时：</p><ul><li><p>如果修改的是基类：那修改时，必须考虑到所有的子类，否则父类修改后，所有涉及到子类的功能都有可能会产生故障。</p></li><li><p>如果修改的是子类：通过重写父类的方法来完成新的功能写起来虽然简单，但是，其实继承包含这样一层含义：<strong>父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约</strong>，虽然它并不强制要求所有的子类必须遵从这些契约。</p><p>也就是说，如果子类对父类的非抽象方法任意修改：</p><ul><li>会对整个继承体系造成破坏。</li><li>整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</li></ul></li></ul><p>而里氏替换原则就是表达了上面这一层含义。</p><h3 id="3-2-1-定义"><a href="#3-2-1-定义" class="headerlink" title="3.2.1 定义"></a>3.2.1 定义</h3><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》里提出来的，她提出：<strong>继承必须确保超类所拥有的性质在子类中仍然成立</strong>。即<strong>子类型必须能够替换掉它们的父类型</strong>。</p><ul><li>性质1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</li><li>性质2：所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。</p><p>里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id="3-2-2-作用"><a href="#3-2-2-作用" class="headerlink" title="3.2.2 作用"></a>3.2.2 作用</h3><p>里氏替换原则的主要作用如下。</p><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它避免了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h3 id="3-2-3-实现"><a href="#3-2-3-实现" class="headerlink" title="3.2.3 实现"></a>3.2.3 实现</h3><p><font color='red'>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</font>也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的定义可以总结如下：</p><ul><li><strong>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</strong>（即里氏转换原则要求子类从抽象继承而不是从具体继承）</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><blockquote><p><strong>疑问</strong>：如果子类继承或实现的是抽象类或者接口的话，那只能引用子类了，这还怎么体现“替换”这个原则？</p><p><strong>回答</strong>：此时还需要我们遵循依赖倒置原则，那么在代码运行中，声明的变量、方法的形参应该都是抽象类或者是接口类型的，而实际传递的是抽象类的子类或者接口的实现类。声明-&gt;实际传递，就体现了“替换”的原则。</p></blockquote><p>如果程序违背了里氏替换原则，则继承类的对象，如果在基类出现的地方，替换基类对象，就会出现运行错误。这时其修正方法是：<font color='red'>取消原来的继承关系，重新设计它们之间的关系</font>。</p><h3 id="3-2-4-举例"><a href="#3-2-4-举例" class="headerlink" title="3.2.4 举例"></a>3.2.4 举例</h3><p>下面以“几维鸟不是鸟”为例来说明里氏替换原则。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鸟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> flySpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        flySpeed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFlyTime</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (distance / flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//燕子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Swallow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//几维鸟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrownKiwi</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        flySpeed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行错误的原因是：几维鸟类因为没有飞行的能力，所以重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更抽象的父类，如动物类，然后定义它们奔跑的能力。</p><p>几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。</p><h2 id="3-3-依赖倒置原则（DIP）"><a href="#3-3-依赖倒置原则（DIP）" class="headerlink" title="3.3 依赖倒置原则（DIP）"></a>3.3 依赖倒置原则（DIP）</h2><h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义"></a>3.3.1 定义</h3><p>依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor 公司总裁罗伯特·马丁于 1996 年在 C++ Report 上发表的文章。</p><p>依赖倒置原则的原始定义为：<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</strong>。</p><ul><li>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。</li><li>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现接口或继承抽象类的类，其特点就是可以直接被实例化。</li></ul><p>其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><h3 id="3-3-2-作用"><a href="#3-3-2-作用" class="headerlink" title="3.3.2 作用"></a>3.3.2 作用</h3><p>依赖倒置原则的主要作用如下：</p><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h3 id="3-3-3-实现"><a href="#3-3-3-实现" class="headerlink" title="3.3.3 实现"></a>3.3.3 实现</h3><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ul><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>模块间的依赖关系都通过接口或抽象类产生，即形参、变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体/实现类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ul><p>代表：工厂模式</p><h3 id="3-3-4-举例"><a href="#3-3-4-举例" class="headerlink" title="3.3.4 举例"></a>3.3.4 举例</h3><p>下面以“顾客购物程序”为例来说明依赖倒置原则的应用。</p><p>分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(ShaoguanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(WuyuanShop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了</p><h3 id="3-3-5-好莱坞原则"><a href="#3-3-5-好莱坞原则" class="headerlink" title="3.3.5 好莱坞原则"></a>3.3.5 好莱坞原则</h3><p>依赖倒置原则，延伸出一个好莱坞原则。</p><blockquote><p>别调用（打电话给）我们，我们会调用（打电话给）你。</p><p>在好莱坞，演员把简历递交给演艺公司后就只有回家等待。由演艺公司（<strong>高层</strong>）对整个娱乐项的完全控制，演员（<strong>底层</strong>）只能被动式的接受公司的差使，在需要的环节中，完成自己的演出。</p></blockquote><p>好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。</p><p>在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，<strong>高层组件对待低层组件的方式是“别调用我们，我们会调用你”。尽量避免向上调用和相互调用</strong>。</p><ul><li>低层组件可以参与计算，但是高层组件控制何时以及如何让底层组件参与</li><li>低层组件绝对不可以直接调用高阶组件</li></ul><p>代表：模板方法模式</p><ul><li>由超类主控一切，当它们需要的时候，自然会去调用子类 — Header First设计模式</li><li><strong>因为要重写父类的方法，为了不违背里氏替换原则，那就是将要重写的父类中的方法声明为抽象方法。</strong></li></ul><blockquote><p>个人疑问：超类相比于子类，算是高层组件么？</p><p>Header First设计模式中：所谓“高层组件”，是由其他低层组件定义其行为的类。</p></blockquote><h2 id="3-4-单一职责原则（SRP）"><a href="#3-4-单一职责原则（SRP）" class="headerlink" title="3.4 单一职责原则（SRP）"></a>3.4 单一职责原则（SRP）</h2><h3 id="3-4-1-定义"><a href="#3-4-1-定义" class="headerlink" title="3.4.1 定义"></a>3.4.1 定义</h3><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁 于《敏捷软件开发：原则、模式和实践》一书中提出的。</p><p>单一职责原则规定<strong>一个类应该只有一个引起它变化的原因</strong>，否则类应该被拆分。</p><blockquote><p>职责、改变的联系？<strong>类的每个责任都有改变的潜在区域。超过一个责任，就意味着超过一个改变的区域。</strong></p></blockquote><p>比如我们设计一个类不但要管理某种聚合，还要负责相关的操作和遍历。那么如果这个集合改变，这个类也必须改变；如果我们遍历的方式改变的话，这个类也必须跟着改变。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><p>这个原则就在告诉我们，<strong>尽量让每个类保持单一责任</strong>。没错，这听起来很容易，但做起来并不简单：<strong>区分设计中的责任，是最困难的事情之一。</strong>我们的大脑很习惯看着一大群的行为，然后将它们集中化一起，尽管他们可能属于两个或多个不同的责任。想要成功的唯一方法，就是努力不懈地检查你的设计，随件系统的成长，随时观察有没有迹象显示某个类改变的原因超出一个。</p><p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><h3 id="3-4-2-作用"><a href="#3-4-2-作用" class="headerlink" title="3.4.2 作用"></a>3.4.2 作用</h3><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="3-4-3-实现"><a href="#3-4-3-实现" class="headerlink" title="3.4.3 实现"></a>3.4.3 实现</h3><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><p>代表：迭代器模式</p><h3 id="3-4-4-举例"><a href="#3-4-4-举例" class="headerlink" title="3.4.4 举例"></a>3.4.4 举例</h3><p>下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p><p>析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做法是生活辅导由辅导员负责，学业指导由学业导师负责。</p><img src="/images/pattern/12.png" alt="12" style="zoom:85%;" /><h2 id="3-5-接口隔离原则（ISP）"><a href="#3-5-接口隔离原则（ISP）" class="headerlink" title="3.5 接口隔离原则（ISP）"></a>3.5 接口隔离原则（ISP）</h2><h3 id="3-5-1-定义"><a href="#3-5-1-定义" class="headerlink" title="3.5.1 定义"></a>3.5.1 定义</h3><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：<strong>客户端不应该被迫依赖于它不使用的方法</strong>。</p><p>该原则还有另外一个定义：<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大(臃肿)的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h3 id="3-5-2-作用"><a href="#3-5-2-作用" class="headerlink" title="3.5.2 作用"></a>3.5.2 作用</h3><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="3-5-3-实现"><a href="#3-5-3-实现" class="headerlink" title="3.5.3 实现"></a>3.5.3 实现</h3><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="3-5-4-举例"><a href="#3-5-4-举例" class="headerlink" title="3.5.4 举例"></a>3.5.4 举例</h3><p>下面以学生成绩管理程序为例介绍接口隔离原则的应用。</p><p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p><img src="/images/pattern/13.png" alt="13" style="zoom:75%;" /><h2 id="3-6-迪米特法则（LoD）"><a href="#3-6-迪米特法则（LoD）" class="headerlink" title="3.6 迪米特法则（LoD）"></a>3.6 迪米特法则（LoD）</h2><h3 id="3-6-1-定义"><a href="#3-6-1-定义" class="headerlink" title="3.6.1 定义"></a>3.6.1 定义</h3><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学的一个名为迪米特的研究项目，由伊恩·荷兰提出，被 UML 创始者之一的布奇普及，后来又因为在经典著作《程序员修炼之道》提及而广为人知。</p><p>迪米特法则的定义是：<strong>只与你的直接朋友交谈，不跟“陌生人”说话</strong>。</p><ul><li><p>这个原则告诉我们要<strong>减少对象之间的交互，一个对象应当对其他对象有尽可能少的了解，只留下几个“密友”</strong>。</p></li><li><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发该调用。</p></li><li><p>“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p></li></ul><p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要话很多成本维护，也会以为太复杂而不容易被其他人了解。</p><h3 id="3-6-2-作用"><a href="#3-6-2-作用" class="headerlink" title="3.6.2 作用"></a>3.6.2 作用</h3><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><ol><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ol><p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><h3 id="3-6-3-实现"><a href="#3-6-3-实现" class="headerlink" title="3.6.3 实现"></a>3.6.3 实现</h3><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><ol><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ol><p>所以，在运用迪米特法则时要注意以下 6 点。</p><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ol><p>代表：外观模式、中介者模式</p><h3 id="3-6-4-举例"><a href="#3-6-4-举例" class="headerlink" title="3.6.4 举例"></a>3.6.4 举例</h3><p>明星与经纪人的关系实例。</p><p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><img src="/images/pattern/14.png" alt="14" style="zoom:85%;" /><h2 id="3-7-合成复用原则（CRP）"><a href="#3-7-合成复用原则（CRP）" class="headerlink" title="3.7 合成复用原则（CRP）"></a>3.7 合成复用原则（CRP）</h2><h3 id="3-7-1-定义"><a href="#3-7-1-定义" class="headerlink" title="3.7.1 定义"></a>3.7.1 定义</h3><blockquote><p>“有一个”比”是一个”更好。（有些地方不将其列入设计原则，太过具体）</p></blockquote><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时：</p><ul><li><p>要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p></li><li><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p></li></ul><h3 id="3-7-2-作用"><a href="#3-7-2-作用" class="headerlink" title="3.7.2 作用"></a>3.7.2 作用</h3><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p><ol><li>它维持了类的封装性。因为成员对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成员对象的唯一方法是通过成员对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的对象。</li></ol><h3 id="3-7-3-实现"><a href="#3-7-3-实现" class="headerlink" title="3.7.3 实现"></a>3.7.3 实现</h3><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p><p>代表：策略模式。</p><h3 id="3-7-4-举例"><a href="#3-7-4-举例" class="headerlink" title="3.7.4 举例"></a>3.7.4 举例</h3><p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。</p><p>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。下图就是用继承关系实现的汽车分类的类图。</p><img src="/images/pattern/15.png" alt="15" style="zoom:80%;" /><p>可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下所示。</p><img src="/images/pattern/16.png" alt="16" style="zoom:80%;" /><h2 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h2><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p><p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p><table><thead><tr><th><div style="width:95px">设计原则</div></th><th>一句话归纳</th><th>目的</th></tr></thead><tbody><tr><td>开闭原则</td><td>对扩展开放，对修改关闭</td><td>降低维护带来的新风险</td></tr><tr><td>里氏替换原则</td><td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td><td>防止继承泛滥</td></tr><tr><td>依赖倒置原则</td><td>高层不应该依赖低层，要面向接口编程</td><td>更利于代码结构的升级扩展</td></tr><tr><td>单一职责原则</td><td>一个类只干一件事，实现类要单一</td><td>便于理解，提高代码的可读性</td></tr><tr><td>接口隔离原则</td><td>一个接口只干一件事，接口要精简单一</td><td>功能解耦，高聚合、低耦合</td></tr><tr><td>迪米特法则</td><td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td><td>只和朋友交流，不和陌生人说话，减少代码臃肿</td></tr><tr><td>合成复用原则</td><td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td><td>降低代码耦合</td></tr></tbody></table><p>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p><h1 id="四、设计模式分类"><a href="#四、设计模式分类" class="headerlink" title="四、设计模式分类"></a>四、设计模式分类</h1><p>根据设计模式之间的共性(功能、针对的角色等角度)，可以把设计模式分为几类，常见的有两种分类：</p><img src="/images/pattern/30.png" alt="30" style="zoom:100%;" /><p>了解分类有利于我们理解、思考、比较、选型。</p><h2 id="4-1-根据作用范围分类"><a href="#4-1-根据作用范围分类" class="headerlink" title="4.1 根据作用范围分类"></a>4.1 根据作用范围分类</h2><p>根据模式主要是作用在类上，还是对象上，或者说所处理的是类还是对象，可以分为：</p><ul><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。<ul><li>即在类模式类图中，一般只存在继承和实现、依赖。</li></ul></li><li>对象模式：用于处理对象之间的关系，这些关系可以通过关联、组合或聚合来实现，在运行时刻是可以变化的，更具动态性。<ul><li>即在对象模式类图中，会存在关联、聚合、组合关系。</li><li>换句话说，只要存在对象的聚合或组合关系(对象存在关联关系)，就叫做对象创建模式</li></ul></li></ul><p>根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分设计模式都属于对象型设计模式。</p><h2 id="4-2-根据功能分类"><a href="#4-2-根据功能分类" class="headerlink" title="4.2 根据功能分类"></a>4.2 根据功能分类</h2><h3 id="4-2-1-创建型模式"><a href="#4-2-1-创建型模式" class="headerlink" title="4.2.1 创建型模式"></a>4.2.1 创建型模式</h3><ul><li>类创建型模式：处理类的创建。</li><li>对象创建型模式：处理对象的创建。</li></ul><p>详细地说，对象创建型模式把对象的部分创建的工作推迟到另一个对象中，而类创建型模式将它推迟到子类中。</p><p><em>除了工厂模式是类创建模式，其它都是对象创建型模式。</em></p><blockquote><p>疑问：抽象工厂中看着没有涉及对象关联关系，为什么是对象创建型模式呢？</p><p>在<a href="https://blog.csdn.net/wan2083/article/details/1482894">某处</a>看到另一种解读(正确性不确定…)：</p><ul><li><p>类创建型模式：只需要知道创建产品的类或类层次结构，就可以创建出相应的对象。调用者只需要看到创建对象的类，而不需要知道自己将会得到什么样的一个对象。在这里体现出了，<strong>调用者要知道创建对象的类</strong>。</p></li><li><p>对象创建型模式：调用者通过一个函数来创建对象，所以调用者必须知道自己将要得到什么样的对象，只要知道将要得到对象的特征就行了，将其传给工厂方法来获得要的对象。在这里体现出了，<strong>调用者要知道对象的特征</strong>。</p></li></ul></blockquote><h3 id="4-2-2-结构型模式"><a href="#4-2-2-结构型模式" class="headerlink" title="4.2.2 结构型模式"></a>4.2.2 结构型模式</h3><ul><li>类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 </li><li>对象结构型模式：关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 </li></ul><p><em>除了Adapter(类)模式是类结构型模式，其它包括Adapter(对象)模式等都是对象结构型模式。</em></p><h3 id="4-2-3-行为型模式"><a href="#4-2-3-行为型模式" class="headerlink" title="4.2.3 行为型模式"></a>4.2.3 行为型模式</h3><ul><li>类行为型模式：主要通过继承、多态等方式来分配父类与子类的职责。</li><li>对象行为型模式：主要是通过对象关联等方式来分配两个或多个类的职责。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</li></ul><p><em>除了解释器、模板方法模式是类行为型模式，其它都是对象行为型模式。</em></p><h1 id="五、创建型模式-怎么创建对象"><a href="#五、创建型模式-怎么创建对象" class="headerlink" title="五、创建型模式(怎么创建对象)"></a>五、创建型模式(怎么创建对象)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象。通俗的说，就是用于<strong>描述“怎样创建对象”</strong>，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。</p><p>为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p><ul><li><p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p></li><li><p>创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时指定。</p></li><li><p>通常应该是工厂方法开始，当设计者设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。</p></li></ul><h2 id="5-1-简单工厂模式-生产多个类对象"><a href="#5-1-简单工厂模式-生产多个类对象" class="headerlink" title="5.1 简单工厂模式(生产多个类对象)"></a>5.1 简单工厂模式(生产多个类对象)</h2><blockquote><p><strong>简而言之：一个工厂类 负责创建 多个具体类的对象（是同一父类）。</strong>  （因为太简单了？不计入23种设计模式之列）</p></blockquote><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，所以简单工厂模式(Simple Factory Pattern)又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><p>在简单工厂模式中，可以<strong>根据参数的不同返回不同类的实例</strong>。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>简单工厂模式包含如下角色：</p><ul><li>工厂角色(Factory)：负责实现创建所有实例的内部逻辑；工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品(Product)：是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；</li><li>具体产品(ConcreteProduct)：是具体类，其实例也就是我们的创建目标。</li></ul><img src="/images/pattern/24.jpg" alt="24" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Product* <span class="title">Factory::createProduct</span><span class="params">(string proname)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;A&quot;</span> == proname )&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductA</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;B&quot;</span> == proname)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProductB</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><p>优点：</p><ul><li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。</li><li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，可以减少使用者的记忆量。</li><li>在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li></ul><p>缺点：</p><ul><li>简单工厂模式最大的问题在于工厂类的职责相对过重，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。违背高聚合原则。</li><li>当增加新的产品时，需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h2 id="5-2-工厂方法模式-生产单个类对象"><a href="#5-2-工厂方法模式-生产单个类对象" class="headerlink" title="5.2 工厂方法模式(生产单个类对象)"></a>5.2 工厂方法模式(生产单个类对象)</h2><blockquote><p><strong>简而言之，一个工厂子类 负责创建 一个具体类的对象。</strong></p></blockquote><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。</p><p>在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p>当出现新的具体类时，只需要为其新创建一个具体的工厂类就可以获得该新类的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p>工厂方法模式包含如下角色：</p><ul><li>Product：抽象产品</li><li>ConcreteProduct：具体产品</li><li>Factory：抽象工厂</li><li>ConcreteFactory：具体工厂</li></ul><p><strong>具体工厂同具体产品之间是一对一的关系</strong>。</p><img src="/images/pattern/25.png" alt="25" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  AbstractFactory * fc = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">  Product * prod = fc-&gt;<span class="built_in">newProduct</span>();</span><br><span class="line">  prod-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> fc;</span><br><span class="line">  <span class="keyword">delete</span> prod;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><p>优点：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程，甚至无须知道具体产品类的类名。</li><li>灵活性增强，对于新产品的创建，无须修改原来代码，只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><p>缺点：</p><ul><li>类的个数容易过多，增加系统的复杂度、编译开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。</li><li>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>客户只关心产品的品牌，不关心创建产品的细节。</li><li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂类只提供创建产品的接口。</li></ul><h3 id="实例-—-日志记录器"><a href="#实例-—-日志记录器" class="headerlink" title="实例 — 日志记录器"></a>实例 — 日志记录器</h3><p>某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。</p><img src="/images/pattern/26.jpg" alt="26" style="zoom:80%;" /><h2 id="5-3-抽象工厂模式-生产一个产品族"><a href="#5-3-抽象工厂模式-生产一个产品族" class="headerlink" title="5.3 抽象工厂模式(生产一个产品族)"></a>5.3 抽象工厂模式(生产一个产品族)</h2><blockquote><p><strong>简而言之，一个工厂子类 负责创建 一个产品族 (同一个工厂生产的，位于不同产品继承结构中的一组产品)</strong></p></blockquote><h3 id="概念：产品等级结构、产品族"><a href="#概念：产品等级结构、产品族" class="headerlink" title="概念：产品等级结构、产品族"></a>概念：产品等级结构、产品族</h3><p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p><ul><li><strong>产品等级结构</strong> ：产品等级结构即<strong>产品的继承结构</strong>，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构。</li><li><strong>产品族</strong> ：在抽象工厂模式中，<strong>产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品</strong>。<ul><li>商业中，产品族一般是指同一家公司以同一品牌生产的一组相关产品。一个公司可能会创建一个产品系列来利用现有客户对其原有品牌的忠诚度。</li></ul></li></ul><p>如海尔电器工厂生产的海尔电视机、海尔电冰箱，这是一个产品族。</p><p>而海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><img src="/images/pattern/27.png" alt="27" style="zoom:80%;" /><blockquote><p>族：事物有共同属性的一大类；种族(共同起源)、民族(共同语言、文化)、宗族(共同血缘)、家族(同姓)。</p><p>簇：相当于“丛”，密集的或长在一块儿但不粘在一起的一丛</p><p>族，某些场景，又称簇(family) ？</p><p>也可指<strong>具有相同或相似的功能结构或性能，共享主要的产品特征、组件或者子结构</strong>，并通过<strong>变型配置</strong>来满足特定市场的一组产品的聚类。</p><p>类簇：类簇是Foundation框架中广泛使用的设计模式。类簇将一些私有的、具体的子类组合在一个公共的、抽象的超类下面，以这种方法来组织类可以简化一个面向对象框架的公开架构，而又不减少功能的丰富性。</p></blockquote><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构"><a href="#标准结构" class="headerlink" title="标准结构"></a>标准结构</h4><p>抽象工厂模式包含如下角色：</p><ul><li>抽象工厂(Abstract Factory)：包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂(Concrete Factory)</li><li>抽象产品(Abstract Product)：抽象工厂模式有多个抽象产品。</li><li>具体产品(ConcreteProduct)</li></ul><p><strong>具体工厂同具体产品之间是一对多的关系</strong>。</p><img src="/images/pattern/28.jpg" alt="28" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  AbstractFactory * fc  = <span class="keyword">new</span> <span class="built_in">ConcreteFactory1</span>();</span><br><span class="line">  AbstractProductA * pa = fc-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">  AbstractProductB * pb = fc-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">  pa-&gt;<span class="built_in">use</span>();</span><br><span class="line">  pb-&gt;<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line">  AbstractFactory * fc2  = <span class="keyword">new</span> <span class="built_in">ConcreteFactory2</span>();</span><br><span class="line">  AbstractProductA * pa2 = fc2-&gt;<span class="built_in">createProductA</span>();</span><br><span class="line">  AbstractProductB * pb2 = fc2-&gt;<span class="built_in">createProductB</span>();</span><br><span class="line">  pa2-&gt;<span class="built_in">use</span>();</span><br><span class="line">  pb2-&gt;<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="退化的工厂"><a href="#退化的工厂" class="headerlink" title="退化的工厂"></a>退化的工厂</h4><p>当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p><p>当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</p><h3 id="优缺点-开闭原则的倾斜性"><a href="#优缺点-开闭原则的倾斜性" class="headerlink" title="优缺点(开闭原则的倾斜性)"></a>优缺点(开闭原则的倾斜性)</h3><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：抽象工厂模式的扩展有一定的“开闭原则”倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。而抽象工厂模式扩展时：</p><ol><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，或者说增加一个新的产品等级时，所有的工厂类都需要进行修改，不满足开闭原则。</li></ol><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。如有人只喜欢穿某一个品牌的衣服和鞋。</li></ul><h2 id="5-4-建造者-生成器模式-不同配置"><a href="#5-4-建造者-生成器模式-不同配置" class="headerlink" title="5.4 建造者/生成器模式(不同配置)"></a>5.4 建造者/生成器模式(不同配置)</h2><blockquote><p><strong>简而言之：多个建造者子类 负责创建 同一个具体类对象。每个建造者子类 负责创建 不同的该类对象的配置</strong></p><p>比如：建造者是在创建KFC套餐。抽象建造者规定要创建：主食+饮料。其中一个建造者子类创建的是汉堡+果汁；另一个建造者创建的是鸡肉卷+可乐。</p></blockquote><p>在软件开发中，存在一些复杂对象，实例化时存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>造者模式(Builder Pattern)是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><p>它将变与不变相分离，即<strong>产品的组成部分是不变的，但每一部分是可以灵活选择的</strong>。（成员变量们一样，值可以不一样）</p><p>建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-1"><a href="#标准结构-1" class="headerlink" title="标准结构"></a>标准结构</h4><p>建造者模式包含如下角色：</p><ul><li><p>指挥者(Director)：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p></li><li><p>抽象建造者(Builder)：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</p></li><li><p>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。<strong>一个具体建造者会创建一种不同的产品对象(组成部分相同，数据不同)。</strong></p></li><li><p>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</p></li></ul><p><strong>具体建造者同具体产品之间是多对一的关系（一个具体产品有多种建造方式）</strong>。</p><img src="/images/pattern/29.jpg" alt="29" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_a,m_b,m_c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Product</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setA</span><span class="params">(string str)</span></span>&#123; m_a = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setB</span><span class="params">(string str)</span></span>&#123; m_b = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setC</span><span class="params">(string str)</span></span>&#123; m_c = str; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;product has&quot;</span> &lt;&lt; m_a &lt;&lt; m_b &lt;&lt; m_c &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Product * m_prod;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Builder</span>() &#123; m_prod = <span class="keyword">new</span> <span class="built_in">Product</span>(); &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Product * <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_prod; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span>:</span> <span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ConcreteBuilder</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ConcreteBuilder</span>() &#123;&#125;</span><br><span class="line">  <span class="comment">//不同的建造者，可以实现不同产品的建造  </span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setA</span>(<span class="string">&quot;A Style &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setB</span>(<span class="string">&quot;B Style &quot;</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>&#123;  m_prod-&gt;<span class="built_in">setC</span>(<span class="string">&quot;C style &quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Builder * m_pbuilder;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Director</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Director</span>()&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setBuilder</span><span class="params">(Builder* buider)</span></span>&#123;  m_pbuilder = buider;  &#125;</span><br><span class="line">  <span class="function">Product* <span class="title">constuct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartA</span>();</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartB</span>();</span><br><span class="line">    m_pbuilder-&gt;<span class="built_in">buildPartC</span>();</span><br><span class="line">    <span class="keyword">return</span> m_pbuilder-&gt;<span class="built_in">getResult</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  ConcreteBuilder * builder = <span class="keyword">new</span> <span class="built_in">ConcreteBuilder</span>();</span><br><span class="line">  Director director;</span><br><span class="line">  director.<span class="built_in">setBuilder</span>(builder);</span><br><span class="line">  Product * pd =  director.<span class="built_in">construct</span>();</span><br><span class="line">  pd-&gt;<span class="built_in">show</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> builder;</span><br><span class="line">  <span class="keyword">delete</span> pd;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：</p><ol><li>隔离了客户与生产过程；</li><li>负责控制产品的生成过程。</li></ol><p>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</p><h4 id="简化结构"><a href="#简化结构" class="headerlink" title="简化结构"></a>简化结构</h4><ul><li>省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li><li>省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。</li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>封装性好，构建和表示分离。在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得<strong>相同的创建过程</strong>可以创建不同的产品对象。</li><li>扩展性好，符合“开闭原则”：<ul><li>各个具体的建造者相互独立，有利于系统的解耦。可以很方便地替换具体建造者或增加新的具体建造者， 使用<strong>不同的具体建造者</strong>即可创建不同的产品对象。</li><li>指挥者类针对抽象建造者类编程，增加新的具体建造者无须修改原有类库的代码。</li></ul></li><li><strong>可以更加精细地控制产品的创建过程</strong> 。建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ul><p>缺点：</p><ul><li><strong>产品的组成部分必须相同</strong>，这限制了其使用范围。</li><li>如果产品内部复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li></ul><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得<strong>相同的创建过程可以创建不同的产品</strong>。</li></ul><p>在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。</p><h3 id="比较：与工厂模式的不同"><a href="#比较：与工厂模式的不同" class="headerlink" title="比较：与工厂模式的不同"></a>比较：与工厂模式的不同</h3><p>建造者（Builder）模式和工厂模式的关注点不同：</p><ul><li>工厂方法模式更注重零部件的创建过程(<strong>一步生成</strong>)；</li><li>建造者模式注重零部件的组装过程，它侧重于<strong>一步步构造</strong>一个复杂对象，返回一个完整的对象；</li></ul><p>但两者可以结合使用。</p><p>与抽象工厂模式的差别就更多了:</p><ul><li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品</strong> ，而 <strong>抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤。</li><li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="5-5-单例模式"><a href="#5-5-单例模式" class="headerlink" title="5.5 单例模式"></a>5.5 单例模式</h2><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>单例模式(Singleton Pattern)是指一个类只有一个实例，且该类能自行创建这个实例并向整个系统提供使用的一种模式。</p><p>单例模式的要点有三个：</p><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p>单例模式包含如下角色：</p><ul><li>Singleton：单例</li></ul><img src="/images/pattern/31.jpg" alt="Singleton" style="zoom:100%;" /><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li>单例类的构造函数为私有，确保用户无法通过new关键字直接实例化它。</li><li>提供一个自身的静态私有成员变量；</li><li>提供一个公有的静态工厂方法。</li></ul><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>单例模式可以保证内存里只有一个实例，减少了内存上的开销。</li><li>对于一些需要频繁创建和销毁、实例化过程很占用资源的对象，单例模式无疑可以提高系统的性能。</li><li>单例模式设置全局访问点，所以它可以严格控制客户怎样以及何时访问它，可以优化和共享资源的访问。</li><li>扩展：允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><p>缺点：</p><ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li><li>滥用单例将带来一些负面问题，如：<ul><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</li><li>现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul></li></ul><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统中要求一个类只有一个实例对象。比如：<ul><li>业务限制：一个班中的班长、每个人的身份证号、系统中唯一的序列号生成器等。</li><li>系统限制：该类的实例，会占用过多的资源，只允许创建一个对象。</li></ul></li><li>类对象，频繁实例化，又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>类对象，实例化时会占用较多的资源，或耗时较长，且经常使用。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>扩展：如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li></ul><h2 id="5-6-原型模式-clone对象"><a href="#5-6-原型模式-clone对象" class="headerlink" title="5.6 原型模式(clone对象)"></a>5.6 原型模式(clone对象)</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。</p><p>用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><img src="/images/pattern/32.png" alt="32" style="zoom:100%;" /><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p><p>OC 中的 NSCopying 协议也指定了 copyWithZone() 方法，具体类需要遵循此协议，实现方法。</p><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>在某些环境下，复制对象比创建一个新对象，性能上更加优良。</li></ul><p>缺点：</p><ul><li>需要为每一个类都配置一个 clone 方法</li><li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li><li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li></ul><h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h3><p>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</p><h1 id="六、结构型模式-怎么组成更大的结构"><a href="#六、结构型模式-怎么组成更大的结构" class="headerlink" title="六、结构型模式(怎么组成更大的结构)"></a>六、结构型模式(怎么组成更大的结构)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>结构型模式(Structural Pattern)用于<strong>描述如何将类或对象按某种布局组成更大的结构</strong>。就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。</p><p>或者说，结构型模式是描述怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装性（适配器，桥接）。</p><p>如装饰、代理、外观、适配器、组合、桥接、享元等 7 种结构型模式。</p><h2 id="6-1-装饰模式-功能扩展"><a href="#6-1-装饰模式-功能扩展" class="headerlink" title="6.1 装饰模式(功能扩展)"></a>6.1 装饰模式(功能扩展)</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li>继承机制：子类在拥有父类方法的同时，还可以拥有自身方法。</li><li>关联机制：将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。（或者说装饰器对象包裹原始对象）</li></ul><p><em>关联机制扩展功能相比继承的优点见下文。</em></p><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p>其别名也可以称为包装器(Wrapper)，根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-2"><a href="#标准结构-2" class="headerlink" title="标准结构"></a>标准结构</h4><p>装饰器模式主要包含以下角色。</p><ol><li>抽象构件类（Component）：定义一个抽象接口，以规范准备接收附加责任的对象。</li><li>具体构件类（ConcreteComponent）：实现抽象构件。将会通过装饰角色为其添加一些职责</li><li>抽象装饰类（Decorator）：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰类（ConcreteDecorator）：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><img src="/images/pattern/33.jpg" alt="33" style="zoom:100%;" /><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类对其进行扩展。 </li></ul><h4 id="简化结构-1"><a href="#简化结构-1" class="headerlink" title="简化结构"></a>简化结构</h4><p>装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如：</p><ul><li>简化1：如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li><li>简化2：如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> decorator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体构件角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123; syso(<span class="string">&quot;创建具体构件角色&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span>    </span>&#123; syso(<span class="string">&quot;调用具体构件角色的方法operation()&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123; <span class="keyword">this</span>.component = component; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span>               </span>&#123; component.operation(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体装饰角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123; <span class="keyword">super</span>(component); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syso(<span class="string">&quot;为具体构件角色增加额外的功能addedFunction()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component p = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        Component d = <span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><p>装饰模式与继承关系的目的都是要扩展对象的功能。相比于继承，使用装饰器的好处：</p><ul><li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</li><li>继承是一种耦合度较高的静态关系，无法在程序运行时动态扩展。即装饰模式可以提供比继承更多的<strong>灵活性</strong>。可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>当扩展功能增多时，子类会很膨胀。而装饰器模式中，通过使用<strong>不同的具体装饰类</strong>、这些<strong>具体装饰类的排列组合</strong>，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，<strong>符合“开闭原则”</strong>。</li></ul><p>装饰模式的缺点:</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ul><h3 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：<ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）.</li></ul></li></ul><h2 id="6-2-代理模式-控制访问"><a href="#6-2-代理模式-控制访问" class="headerlink" title="6.2 代理模式(控制访问)"></a>6.2 代理模式(控制访问)</h2><blockquote><p><strong>核心是控制访问。</strong></p></blockquote><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>代理模式(Proxy Pattern) ：给某对象提供一个代理(也叫替身、占位符)以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><blockquote><p>疑问：从定义来看，代理模式的核心是控制对目标对象的访问，类似服务器中的反向代理(安全防护、负载均衡等)？那正向代理(扩展目标对象的功能，如VPN软件等)算不算代理模式？如果不属于，那正向代理这种对应到软件开发中，应该属于什么模式呢？</p></blockquote><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色。声明真实主题和代理对象实现的方法。</li><li>Proxy: 代理主题角色。提供了与真实主题相同的接口，其内部含有对真实主题的引用。控制外部对真实主题的访问。</li><li>RealSubject: 真实主题角色</li></ul><img src="/images/pattern/34.jpg" alt="34" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Proxy::<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">  <span class="comment">//有人觉得 RealSubject对象的创建应该是在main中实现；我认为RealSubject应该</span></span><br><span class="line">  <span class="comment">//对用户是透明的，用户所面对的接口都是通过代理的；这样才是真正的代理； </span></span><br><span class="line">  m_pRealSubject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">&#125;</span><br><span class="line">Proxy::~<span class="built_in">Proxy</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span> m_pRealSubject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::afterRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Proxy::afterRequest&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::preRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Proxy::preRequest&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proxy::request</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">preRequest</span>();</span><br><span class="line">  m_pRealSubject-&gt;<span class="built_in">request</span>();</span><br><span class="line">  <span class="built_in">afterRequest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p><p>在Java中，根据代理的创建时期，代理模式分为静态代理和动态代理。</p><ul><li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li><li>动态：利用反射机制在运行时创建代理类。</li></ul><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。</li></ul><p>缺点：</p><ul><li>代理模式会造成系统设计中类的数量增加，增加了系统的复杂度；</li><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢；</li></ul><h3 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li>图片代理：对大图浏览的控制。用户通过浏览器访问网页时先不加载真实的大图，而是先加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。</li><li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<ul><li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li></ul></li><li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li><li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li><li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="6-3-外观模式-功能包装"><a href="#6-3-外观模式-功能包装" class="headerlink" title="6.3 外观模式(功能包装)"></a>6.3 外观模式(功能包装)</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 </p><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>外观模式(Facade Pattern)：为子系统中的一组接口提供一个一致的界面。即外部与该子系统的通信必须通过一个统一的外观对象（高层接口）进行，这个高层接口使得这一子系统更加容易使用。</p><p>通俗点说：我们创建一个接口简化而统一的类，用来包装子系统中一个或多个复杂的类。</p><p>外观模式又称为门面模式，它是一种对象结构型模式。</p><p>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度2个以上的类对象，我们经常都会自觉地创建一个新的类封装这些类功能，提供精简的接口，让高层模块可以更加容易地使用子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-3"><a href="#标准结构-3" class="headerlink" title="标准结构"></a>标准结构</h4><p>外观模式包含如下角色：</p><ul><li>外观（Facade）角色：为子系统对外提供一个统一的接口。将客户的请求代理给适当的子系统中的类。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。注意：子系统中的类是没有Facade的任何信息的，即没有对Facade对象的引用。</li></ul><img src="/images/pattern/35.jpg" alt="35" style="zoom:100%;" /><p>注意点：</p><ul><li><p>一般将外观类设计为单例类。</p></li><li><p>一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。</p></li><li><p>不要试图通过外观类为子系统增加新行为。</p><p>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p></li><li><p>外观模式与迪米特法则</p><p>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Facade.h&quot;</span></span></span><br><span class="line">Facade::<span class="built_in">Facade</span>()&#123;</span><br><span class="line">  m_SystemA  = <span class="keyword">new</span> <span class="built_in">SubSystemClassA</span>();</span><br><span class="line">  m_SystemB = <span class="keyword">new</span> <span class="built_in">SubSystemClassB</span>();</span><br><span class="line">  m_SystemC = <span class="keyword">new</span> <span class="built_in">SubSystemClassC</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Facade::~<span class="built_in">Facade</span>()&#123;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemA;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemB;</span><br><span class="line">  <span class="keyword">delete</span> m_SystemC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Facade::wrapOpration</span><span class="params">()</span></span>&#123;</span><br><span class="line">  m_SystemA-&gt;<span class="built_in">operationA</span>();</span><br><span class="line">  m_SystemB-&gt;<span class="built_in">operationB</span>();</span><br><span class="line">  m_SystemC-&gt;<span class="built_in">opeartionC</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-抽象外观类的引入"><a href="#扩展-抽象外观类的引入" class="headerlink" title="扩展: 抽象外观类的引入"></a>扩展: 抽象外观类的引入</h4><ul><li>外观模式最大的缺点在于违背了“开闭原则”，当增加、移除子系统类时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。</li><li>对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统类对象。</li><li>同时可以通过修改配置文件来达到不修改源代码并更换外观类的目的。</li></ul><img src="/images/pattern/36.jpg" alt="36" style="zoom:100%;" /><h3 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>缺点：</p><ul><li>不能很好地限制客户使用子系统中的类，如果对客户访问子系统中的类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，当增加或移除子系统中的类时可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h3 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>当一个子系统中多个类与客户程序、其他子系统之间存在依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构(分层结构)中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="6-4-适配器模式-API转换"><a href="#6-4-适配器模式-API转换" class="headerlink" title="6.4 适配器模式(API转换)"></a>6.4 适配器模式(API转换)</h2><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p><p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，这可能是因为现有类中使用到的方法名与目标类中定义的方法名不一致等原因所导致的。而如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><p>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。</p><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。</p><p>适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><h3 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h3><p>适配器模式包含如下角色：</p><ul><li>Target：目标抽象类。当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>Adaptee：适配者类。被访问和适配的现存组件库中的组件接口。</li><li>Adapter：适配器类。它是一个转换器，把适配者类的接口转换成目标接口，让客户按目标接口的格式访问适配者。<ul><li>对象适配器：引用适配者类的对象。</li><li>类适配器：继承适配者类。</li></ul></li></ul><p>适配器模式有对象适配器和类适配器两种实现：</p><h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><img src="/images/pattern/37.jpg" alt="37" style="zoom:100%;" /><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><img src="/images/pattern/38.jpg" alt="38" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">        Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">        Target target = <span class="keyword">new</span> ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h4><ul><li>认适配器模式(Default Adapter Pattern)或缺省适配器模式：<ul><li>当适配器不需要全部实现目标接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</li></ul></li><li>双向适配器模式：既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。（<em>额，想象不出来使用场景</em>）</li></ul><h3 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>增加了类的透明性，将具体的实现封装在适配者类中，对于客户端类来说是透明的。</li><li>提高了类的复用性，程序员不需要修改原有代码而重用现有的适配者类。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p>类适配器模式的独有优点：</p><ul><li>由于适配器类是适配者类的子类，因此可以在类适配器中修改一些适配者的方法，使得类适配器的灵活性更强。</li></ul><p>对象适配器模式的独有优点：</p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个对象适配器可以把适配者类和它的子类都适配到目标接口。</li><li>而类适配器模式的缺陷在于：对于Java、C#等不支持多继承的语言，一次最多只能适配一个适配者类。</li></ul><p>缺点：</p><ul><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><h3 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用适配器模式：</p><ul><li><p>系统需要使用现有的类，而这些类的接口不符合系统的需要。</p><blockquote><p>修改一下使用的地方不就行了？有些场景无法修改，比如要使用该类的系统是面向多个模块的，不能单因为这个新的类就修改原系统中的代码。</p></blockquote></li><li><p>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p></li></ul><h2 id="6-5-组合模式-组合和个体使用一致性"><a href="#6-5-组合模式-组合和个体使用一致性" class="headerlink" title="6.5 组合模式(组合和个体使用一致性)"></a>6.5 组合模式(组合和个体使用一致性)</h2><blockquote><p>个人：这个组合，好像跟对象之间的组合关系并不等价。这个组合是表示”整体-部分“的关系，对应对象之间的聚合、组合关系？</p></blockquote><p>在现实生活中、软件开发中，存在很多“部分-整体”的关系，例如：</p><ul><li>大学中的部门与学院；</li><li>总公司中的部门与分公司；</li><li>卖电脑的商家，可以卖配件，也可以卖组装整机；</li><li>文件系统中，复制文件，可以一个个文件复制粘贴，也可以整个文件夹复制粘贴；</li><li>窗体程序中，可以操作一个个简单控件，也可以同样的方式操作容器控件；</li></ul><p>对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>将多个对象组合成树状结构，以表示“整体-部分”的层次结构。实现组合模式，可以<strong>使得用户对单个对象和组合对象的使用具有一致性</strong>。</p><p><em>即不管将要操作的是组合对象还是单个对象，我们都可以统一处理，如果是组合对象，它自己负责将操作分发到内部的所有单个对象上。</em></p><p>树状结构图一般如下：</p><img src="/images/pattern/39.png" alt="39" style="zoom:80%;" /><p>根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；</p><p>叶子节点与树枝节点在语义上不属于用一种类型。</p><p>但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。即在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。</p><h3 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h3><p>组合模式包含以下主要角色。</p><ul><li>抽象构件（Component）角色：为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。<ul><li>在透明式的组合模式中，还声明访问和管理子节点的接口；</li><li>在安全式的组合模式中，不声明访问和管理子节点的接口，管理工作由树枝构件自己完成。</li></ul></li><li>树叶构件（Leaf）角色：没有子节点，继承或实现抽象构件。</li><li>树枝构件（Composite）角色 / 中间构件：有子节点，继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ul><p>组合模式分为：</p><h4 id="透明式的组合模式"><a href="#透明式的组合模式" class="headerlink" title="透明式的组合模式"></a>透明式的组合模式</h4><p>该方式中，抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。</p><img src="/images/pattern/40.jpg" alt="40" style="zoom:100%;" /><h4 id="安全式的组合模式"><a href="#安全式的组合模式" class="headerlink" title="安全式的组合模式"></a>安全式的组合模式</h4><p>该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</p><img src="/images/pattern/41.jpg" alt="40" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 透明式的组合模式的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全式的组合模式的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处要将树枝构件类型更改为 Composite 类型，以便获取管理子节点的操作方法。</span></span><br><span class="line">        Composite c0 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Composite c1 = <span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        Component leaf3 = <span class="keyword">new</span> Leaf(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-复杂的组合模式"><a href="#扩展-复杂的组合模式" class="headerlink" title="扩展: 复杂的组合模式"></a>扩展: 复杂的组合模式</h4><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点拥有不同的实现，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。</p><img src="/images/pattern/42.jpg" alt="42" style="zoom:100%;" /><h3 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ol><p>缺点：</p><ol><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能；</li></ol><h3 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ol><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能。</p><p>说明：假如李先生到韶关“天街e角”生活用品店购物：</p><ul><li>用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；</li><li>用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；</li><li>用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；</li><li>用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。</li></ul><p>现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。</p><p>安全组合模式设计，其结构图如下图：</p><img src="/images/pattern/43.jpg" alt="43" style="zoom:90%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> composite;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">0</span>;</span><br><span class="line">        Bags BigBag, mediumBag, smallRedBag, smallWhiteBag;</span><br><span class="line">        Goods sp;</span><br><span class="line">        BigBag = <span class="keyword">new</span> Bags(<span class="string">&quot;大袋子&quot;</span>);</span><br><span class="line">        mediumBag = <span class="keyword">new</span> Bags(<span class="string">&quot;中袋子&quot;</span>);</span><br><span class="line">        smallRedBag = <span class="keyword">new</span> Bags(<span class="string">&quot;红色小袋子&quot;</span>);</span><br><span class="line">        smallWhiteBag = <span class="keyword">new</span> Bags(<span class="string">&quot;白色小袋子&quot;</span>);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;婺源特产&quot;</span>, <span class="number">2</span>, <span class="number">7.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;婺源地图&quot;</span>, <span class="number">1</span>, <span class="number">9.9f</span>);</span><br><span class="line">        smallRedBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;韶关香菇&quot;</span>, <span class="number">2</span>, <span class="number">68</span>);</span><br><span class="line">        smallWhiteBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;韶关红茶&quot;</span>, <span class="number">3</span>, <span class="number">180</span>);</span><br><span class="line">        smallWhiteBag.add(sp);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;景德镇瓷器&quot;</span>, <span class="number">1</span>, <span class="number">380</span>);</span><br><span class="line">        mediumBag.add(sp);</span><br><span class="line">        mediumBag.add(smallRedBag);</span><br><span class="line">        sp = <span class="keyword">new</span> Goods(<span class="string">&quot;李宁牌运动鞋&quot;</span>, <span class="number">1</span>, <span class="number">198</span>);</span><br><span class="line">        BigBag.add(sp);</span><br><span class="line">        BigBag.add(smallWhiteBag);</span><br><span class="line">        BigBag.add(mediumBag);</span><br><span class="line">        System.out.println(<span class="string">&quot;您选购的商品有：&quot;</span>);</span><br><span class="line">        BigBag.show();</span><br><span class="line">        s = BigBag.calculation();</span><br><span class="line">        System.out.println(<span class="string">&quot;要支付的总价是：&quot;</span> + s + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象构件：物品</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span></span>; <span class="comment">//计算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树叶构件：商品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;    <span class="comment">//数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> unitPrice; <span class="comment">//单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">int</span> quantity, <span class="keyword">float</span> unitPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">        <span class="keyword">this</span>.unitPrice = unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity * unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;(数量：&quot;</span> + quantity + <span class="string">&quot;，单价：&quot;</span> + unitPrice + <span class="string">&quot;元)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树枝构件：袋子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bags</span> <span class="keyword">implements</span> <span class="title">Articles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;     <span class="comment">//名字  </span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Articles&gt; bags = <span class="keyword">new</span> ArrayList&lt;Articles&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bags</span><span class="params">(String name)</span>        </span>&#123; <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Articles c)</span>     </span>&#123; bags.add(c);        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Articles c)</span>  </span>&#123; bags.remove(c);     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Articles <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> bags.get(i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;</span><br><span class="line">            s += ((Articles) obj).calculation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;</span><br><span class="line">            ((Articles) obj).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-桥接模式-接口与实现分离"><a href="#6-6-桥接模式-接口与实现分离" class="headerlink" title="6.6 桥接模式(接口与实现分离)"></a>6.6 桥接模式(接口与实现分离)</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h3 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h3><p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p><h4 id="抽象、实现部分？-先见1-7小节"><a href="#抽象、实现部分？-先见1-7小节" class="headerlink" title="抽象、实现部分？(先见1.7小节)"></a>抽象、实现部分？(先见1.7小节)</h4><p>注意，这里提到的抽象部分、实现部分与编程语言中的接口或抽象类、实现类是不同的含义。这里的抽象部分是指接口(interface，或者界面)：</p><ul><li>抽象部分（也被称为接口）是一些实体的高阶控制层。该层自身不完成任何具体的工作，它需要将工作委派给实现部分层（也被称为平台）。——  <a href="https://refactoringguru.cn/design-patterns/bridge">《深入设计模式》</a></li><li>《Head First设计模式》一书中也有场景，将抽象部分表示为一个系统对外暴露的接口。</li></ul><p>举个例子，在实际的程序中，抽象部分可以是用户操作界面（比如GUI），而实现部分则是底层操作系统代码（API），GUI层调用API层来对用户的各种操作做出响应。</p><p>一般来说，你可以在两个独立方向上扩展这种应用：</p><ul><li>开发多个不同的GUI（例如面向普通用户和管理员进行分别配置）</li><li>支持多个不同的API（例如，能够在Windows、Linux和macOS上运行该程序）。</li></ul><h4 id="抽象与实现分离"><a href="#抽象与实现分离" class="headerlink" title="抽象与实现分离"></a>抽象与实现分离</h4><ul><li>”将抽象部分与它的实现部分分离“，就是<strong>实现系统可能有多角度/维度分类，每一种分类都有可能变化，那么就把这种多角度/维度分离出来让它们独立变化，减少它们之间的耦合</strong>。—— 《大话设计模式》</li><li>桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变。这两个类层次之间的关系就叫桥接。——《Head First设计模式》</li></ul><blockquote><p>维度（Dimension），又称维数、量纲和次元，是描述<strong>对象状态所需的独立参数（数学）或系统自由度（物理）的数量</strong>。在物理学和数学中，数学空间的维数被非正式地定义为指定其中任何点所需的最小坐标数(1维是线，只需指定长度。2维是一个平面，需指定长度和宽度。3维是一个立体，需指定长度、宽度、高度)。</p></blockquote><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>桥接模式通过将继承改为组合的方式来解决这个问题。具体来说，就是<strong>抽取其中一个维度并使之成为独立的类层次，这样就可以在初始类中引用这个新层次的对象</strong>，从而使得一个类不必拥有所有的状态和行为。</p><h3 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-4"><a href="#标准结构-4" class="headerlink" title="标准结构"></a>标准结构</h4><p>桥接模式包含如下角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充/精炼/精确抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><p>桥接模式的一个常见使用场景就是替换继承。在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使得二者可以独立地变化。</p><img src="/images/pattern/44.jpg" alt="44" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  RefinedAbstraction.cpp</span></span><br><span class="line"><span class="comment">//  Implementation of the Class RefinedAbstraction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">RefinedAbstraction::<span class="built_in">RefinedAbstraction</span>()  &#123; &#125;</span><br><span class="line">RefinedAbstraction::<span class="built_in">RefinedAbstraction</span>(Implementor* imp) :<span class="built_in">Abstraction</span>(imp) &#123; &#125;</span><br><span class="line">RefinedAbstraction::~<span class="built_in">RefinedAbstraction</span>() &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RefinedAbstraction::operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do something else ,and then &quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_pImp-&gt;<span class="built_in">operationImp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现类1</span></span><br><span class="line">    Implementor * pImp = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorA</span>();</span><br><span class="line">    Abstraction * pa = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(pImp);</span><br><span class="line">    pa-&gt;<span class="built_in">operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体实现类2</span></span><br><span class="line">    Implementor * pImpb = <span class="keyword">new</span> <span class="built_in">ConcreteImplementorB</span>();</span><br><span class="line">    Abstraction * pb = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>(pImpb);</span><br><span class="line">    pb-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pa;</span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与适配器模式联用"><a href="#扩展-与适配器模式联用" class="headerlink" title="扩展: 与适配器模式联用"></a>扩展: 与适配器模式联用</h4><p>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><img src="/images/pattern/46.jpg" alt="46" style="zoom:100%;" /><h3 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>抽象与实现分离。提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。符合开闭原则。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>符合合成复用原则</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><p>缺点是：</p><ul><li>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程。</li><li>要求能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li></ul><h3 id="适用场景-11"><a href="#适用场景-11" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展</strong>。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li><li>对于那些<strong>不希望使用继承、或不希望因为多层次继承导致系统类的个数急剧增加</strong>的系统，桥接模式尤为适用。</li></ul><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>案例1：</p><p>设备及其遥控器的架构设计。 <strong>设备</strong> Device类作为实现部分， 而 <strong>遥控器</strong> Remote类则作为抽象部分。</p><p>最初类层次结构被拆分为两个部分： 设备和遥控器。</p><img src="/images/pattern/48.png" alt="48" style="zoom:90%;" /><p>案例2：</p><p>女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。</p><p>本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。</p><img src="/images/pattern/45.jpg" alt="45" style="zoom:85%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Color color;</span><br><span class="line">    Bag bag;</span><br><span class="line">    color = (Color) ReadXML.getObject(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">    bag = (Bag) ReadXML.getObject(<span class="string">&quot;bag&quot;</span>);</span><br><span class="line">    bag.setColor(color);</span><br><span class="line">    String name = bag.getName();</span><br><span class="line">    show(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-享元模式-对象复用池"><a href="#6-7-享元模式-对象复用池" class="headerlink" title="6.7 享元模式(对象复用池)"></a>6.7 享元模式(对象复用池)</h2><h3 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h3><p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。</p><ul><li>系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</li><li>模式要求能够共享的对象必须是细粒度对象，因此它又称为蝇量模式、轻量级模式。</li></ul><p>它是一种对象结构型模式。</p><p>通过享元模式，可以大幅度减少需要创建的对象数量，节约内存空间，提高系统的性能。</p><h3 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h3><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><h4 id="内部状态、外部状态"><a href="#内部状态、外部状态" class="headerlink" title="内部状态、外部状态"></a>内部状态、外部状态</h4><p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</p><ul><li>内部状态是<strong>存储在享元对象内部</strong>并且不会随环境改变而改变的状态，因此内部状态可以共享。<ul><li>外部直接只能读取不能修改其数值。</li></ul></li><li>外部状态是随环境改变而改变的、不可以共享的状态。即外部状态可以被“从外部”改变。<ul><li><strong>享元对象的外部状态必须由客户端保存</strong>，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。</li><li>一个外部状态与另一个外部状态之间是相互独立的。</li></ul></li></ul><p>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态。</p><h4 id="标准结构-5"><a href="#标准结构-5" class="headerlink" title="标准结构"></a>标准结构</h4><p>享元模式包含如下角色：</p><ul><li>Flyweight: 抽象享元类。所有具体享元类的超类或接口，接口中定义的方法，使得Flyweight可以接收并操作传入享元对象中的外部状态。</li><li>ConcreteFlyweight: 具体享元类。继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间。</li><li>UnsharedConcreteFlyweight: 非共享具体享元类。<ul><li>Flyweight接口只是使共享成为可能，但它并不强制共享。</li><li>尽管我们大部分情况下，都需要共享对象来降低内存的消耗。但个别情况下也有可能不需要共享的。</li></ul></li><li>FlyweightFactory: 享元工厂类。负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><img src="/images/pattern/49.jpg" alt="49" style="zoom:100%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂</span></span><br><span class="line"><span class="function">Flyweight* <span class="title">FlyweightFactory::getFlyweight</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    map&lt;string,Flyweight*&gt;::iterator itr = m_mpFlyweight.<span class="built_in">find</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(itr == m_mpFlyweight.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        Flyweight * fw = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>(str);</span><br><span class="line">        m_mpFlyweight.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(str,fw));</span><br><span class="line">        <span class="keyword">return</span> fw;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;aready in the pool,use the exist one:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> itr-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> :</span> <span class="keyword">public</span> Flyweight &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string intrinsicState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteFlyweight</span>(string str)&#123;</span><br><span class="line">        intrinsicState = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteFlyweight</span>()&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Flyweight[&quot;</span> &lt;&lt; intrinsicState &lt;&lt; <span class="string">&quot;] do operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非共享具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> :</span> <span class="keyword">public</span> Flyweight &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string intrinsicState;  <span class="comment">// 内部状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string otherState; <span class="comment">//其他的状态。会被外部改变，所以此对象不可复用</span></span><br><span class="line">    <span class="built_in">UnsharedConcreteFlyweight</span>(string str)&#123;</span><br><span class="line">        intrinsicState = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">UnsharedConcreteFlyweight</span>()&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;不要共享我 Flyweight[&quot;</span> &lt;&lt; intrinsicState &lt;&lt; <span class="string">&quot;] do operation.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FlyweightFactory factory;</span><br><span class="line">    Flyweight * fw = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    fw-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    Flyweight * fw2 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    fw2-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    <span class="comment">//aready exist in pool</span></span><br><span class="line">    Flyweight * fw3 = factory.<span class="built_in">getFlyweight</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    fw3-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    Flyweight * fw4 = <span class="keyword">new</span> <span class="built_in">UnsharedConcreteFlyweight</span>(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">    fw4-&gt;<span class="built_in">operation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h4><p>在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</p><h4 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h4><p>将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><h4 id="扩展-与其他模式的联用"><a href="#扩展-与其他模式的联用" class="headerlink" title="扩展: 与其他模式的联用"></a>扩展: 与其他模式的联用</h4><ul><li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li><li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li></ul><h3 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul><p>缺点：</p><ul><li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li></ul><h3 id="适用场景-12"><a href="#适用场景-12" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用享元模式：</p><ul><li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li></ul><p>享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p><h1 id="七、行为型模式-协作及职责分配"><a href="#七、行为型模式-协作及职责分配" class="headerlink" title="七、行为型模式(协作及职责分配)"></a>七、行为型模式(协作及职责分配)</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p><p>行为型模式(Behavioral Pattern)用于描述类或对象之间<strong>怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。</strong></p><p>只要是行为型模式，都涉及到类和对象如何交互及分配职责。</p><ol><li><strong>算法和对象间职责的分配</strong>。即通过行为型模式，可以更加清晰地划分类与对象的职责。</li><li><strong>运行时，实例对象之间的交互</strong>(<strong>或者说通信模式</strong>)。行为型模式刻画了在程序运行时难以跟踪的、复杂的控制流。</li></ol><p>如策略、模板方法、观察者、状态、备忘录、迭代器、命令、职责链、中介者、解释器、访问者等 11 种行为型模式。</p><h2 id="7-1-策略模式-拆分算法族到各策略子类"><a href="#7-1-策略模式-拆分算法族到各策略子类" class="headerlink" title="7.1 策略模式(拆分算法族到各策略子类)"></a>7.1 策略模式(拆分算法族到各策略子类)</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</p><p>比如想要进行数据的查找、排序，而查找、排序的实现有很多种，在指定的场景下选用正确的算法，效果更优。</p><p>选择策略的形式 ：</p><ul><li>一种常用的方法是硬编码(Hard Coding)在一个类中，即在该类中提供多个方法，每一个方法对应一个具体的查找算法；</li><li>将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。</li></ul><p>这两种的缺点：如果需要增加一种新的查找算法，需要修改封装算法类的源代码；且在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。违背开闭原则、单一职责原则。</p><ul><li>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</li><li>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</li></ul><h3 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h3><p>策略模式(Strategy Pattern)：定义一系列算法(也称算法族)，将每一种算法封装起来，并让它们可以相互替换。（每种算法实现对应一个抽象策略的子类。）</p><p>此模式让算法独立于使用它的客户而变化，即算法的变化不会影响到使用算法的客户。也称为政策模式(Policy)。</p><h3 id="结构-13"><a href="#结构-13" class="headerlink" title="结构"></a>结构</h3><p>策略模式包含如下角色：</p><ul><li>Context: 上下文类。持有一个策略类的引用，最终给客户端调用。</li><li>Strategy: 抽象策略类。定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，上下文类中使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>ConcreteStrategy: 具体策略类。实现了抽象策略定义的接口，提供具体的算法实现。</li></ul><img src="/images/pattern/50.jpg" alt="50" style="zoom:100%;" /><p>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</p><p>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Strategy * s1 = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    Context * cxt = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">    cxt-&gt;<span class="built_in">setStrategy</span>(s1);</span><br><span class="line">    cxt-&gt;<span class="built_in">algorithm</span>();</span><br><span class="line">    </span><br><span class="line">    Strategy *s2 = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>();</span><br><span class="line">    cxt-&gt;<span class="built_in">setStrategy</span>(s2);</span><br><span class="line">    cxt-&gt;<span class="built_in">algorithm</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="keyword">delete</span> s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>使用策略模式可以避免使用多重条件转移语句，如 if…else 语句、switch…case 语句。</li><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法：该模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式提供了可以替换继承关系的办法。</li></ul><p>缺点</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类。<strong>当存在的策略很多时，可以通过使用享元模式在一定程度上减少对象的数量</strong>。</li></ul><h3 id="适用场景-13"><a href="#适用场景-13" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h2 id="7-2-模板方法模式-延迟实现算法某些步"><a href="#7-2-模板方法模式-延迟实现算法某些步" class="headerlink" title="7.2 模板方法模式(延迟实现算法某些步)"></a>7.2 模板方法模式(延迟实现算法某些步)</h2><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p>我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。</p><h3 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h3><p>模板方法（Template Method）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="结构-14"><a href="#结构-14" class="headerlink" title="结构"></a>结构</h3><p>模板方法模式包含以下主要角色。</p><ul><li><p>抽象类/抽象模板（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：</p><ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。<ul><li>抽象方法：在抽象类中声明，由具体子类实现。</li><li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li><li>钩子方法：钩子是内容为空的可选步骤。 即使不重写钩子， 模板方法也能工作。 钩子通常放置在算法重要步骤的前后， 为子类提供额外的算法扩展点。正确使用“钩子方法”可以使得子类控制父类的行为。如下图中的 <code>step2()</code> 方法。</li></ul></li></ul></li><li><p>具体子类/具体实现（Concrete Class）：可以重写所有步骤/基本方法，但不能重写模板方法自身。</p></li></ul><img src="/images/pattern/51.jpg" alt="51" style="zoom:100%;" /><p>客户端必须知道所有的具体实现类，并自行决定使用哪一个具体实现类。</p><h3 id="优缺点-14"><a href="#优缺点-14" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点:</p><ol><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ol><p>缺点:</p><ol><li><strong>对每个不同的实现都需要定义一个子类</strong>，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li><li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li></ol><h3 id="适用场景-14"><a href="#适用场景-14" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li></ol><h2 id="7-3-观察者模式-一对多的依赖关系"><a href="#7-3-观察者模式-一对多的依赖关系" class="headerlink" title="7.3 观察者模式(一对多的依赖关系)"></a>7.3 观察者模式(一对多的依赖关系)</h2><p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众等。</p><p>在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。</p><h3 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h3><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><p>观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p><h3 id="结构-15"><a href="#结构-15" class="headerlink" title="结构"></a>结构</h3><h4 id="标准观察者模式"><a href="#标准观察者模式" class="headerlink" title="标准观察者模式"></a>标准观察者模式</h4><p>观察者模式包含如下角色：</p><ul><li>Subject: 抽象目标/主题类。提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>ConcreteSubject: 具体目标/主题类。当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>Observer: 抽象观察者。是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>ConcreteObserver: 具体观察者。实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><img src="/images/pattern/52.jpg" alt="52" style="zoom:90%;" /><ul><li>一个目标可以有任意数目的与之相依赖的观察者。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Obeserver*&gt; m_vtObj;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Obeserver * pObeserver)</span></span>&#123;</span><br><span class="line">        m_vtObj.<span class="built_in">push_back</span>(pObeserver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Obeserver * pObeserver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.<span class="built_in">begin</span>(); </span><br><span class="line">            itr != m_vtObj.<span class="built_in">end</span>(); itr++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*itr == pObeserver) &#123;</span><br><span class="line">                m_vtObj.<span class="built_in">erase</span>(itr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;Obeserver*&gt;::iterator itr = m_vtObj.<span class="built_in">begin</span>(); </span><br><span class="line">            itr != m_vtObj.<span class="built_in">end</span>(); itr++) &#123;</span><br><span class="line">            (*itr)-&gt;<span class="built_in">update</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> i)</span></span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObeserver</span> :</span> <span class="keyword">public</span> Obeserver &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_objName;</span><br><span class="line">    <span class="keyword">int</span> m_obeserverState;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObeserver</span>(string name) &#123;</span><br><span class="line">        m_objName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteObeserver</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject * sub)</span> </span>&#123;</span><br><span class="line">        m_obeserverState = sub-&gt;<span class="built_in">getState</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;update oberserver[&quot;</span> &lt;&lt; m_objName &lt;&lt; <span class="string">&quot;] state:&quot;</span> </span><br><span class="line">             &lt;&lt; m_obeserverState &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="狭义的发布订阅者模式"><a href="#狭义的发布订阅者模式" class="headerlink" title="狭义的发布订阅者模式"></a>狭义的发布订阅者模式</h4><p><a href="https://www.zhihu.com/question/23486749">观察者模式和发布订阅模式有什么不同？</a></p><ul><li><p>发布订阅模式属于广义上的观察者模式：发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式</p></li><li><p>发布订阅模式多了个事件通道：</p><ul><li><p>在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应。</p><img src="/images/pattern/53.png" alt="53" style="zoom:100%;" /></li><li><p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件。以此避免发布者和订阅者之间产生依赖关系。（<em>一般还会有个remove观察者的方法</em>）</p><img src="/images/pattern/54.png" alt="54" style="zoom:100%;" /></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：每当数据中心DataHub中有数据准备好，就通知DownloadTask进行下载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 DownloadManager 类作为事件通道。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DownloadManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  <span class="built_in">this</span>.uId = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DownloadManager.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.events[eventType]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> subscribers = <span class="built_in">this</span>.events[eventType],</span><br><span class="line">    count = subscribers ? subscribers.length : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">    <span class="keyword">var</span> subscriber = subscribers[count];</span><br><span class="line">    subscriber.handler(eventType, subscriber.taskId, url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DownloadManager.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.events[eventType]) &#123;</span><br><span class="line">    <span class="built_in">this</span>.events[eventType] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> taskId = (++<span class="built_in">this</span>.uId).toString();</span><br><span class="line">  <span class="built_in">this</span>.events[eventType].push(&#123;</span><br><span class="line">    taskId: taskId,</span><br><span class="line">    handler: handler</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> taskId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataHub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">DataHub.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  callback(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个订阅者</span></span><br><span class="line"><span class="keyword">var</span> dataLoader = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, taskId, url</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Task &#x27;</span> + taskId + <span class="string">&#x27; load data from &#x27;</span> + url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅。需要借助事件管理器</span></span><br><span class="line"><span class="keyword">var</span> downloadManager = <span class="keyword">new</span> DownloadManager();</span><br><span class="line"><span class="keyword">var</span> downloadTask1 = downloadManager.subscribe(<span class="string">&#x27;dataReady&#x27;</span>, dataLoader);</span><br><span class="line"><span class="comment">// notify</span></span><br><span class="line">dataHub.notify(<span class="string">&#x27;http://somedomain.someaddress&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">  downloadManager.publish(<span class="string">&#x27;dataReady&#x27;</span>, url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="优缺点-15"><a href="#优缺点-15" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><p>缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li></ul><h3 id="适用场景-15"><a href="#适用场景-15" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p><p>MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。</p><h2 id="7-4-状态模式-对象不同状态下不同行为"><a href="#7-4-状态模式-对象不同状态下不同行为" class="headerlink" title="7.4 状态模式(对象不同状态下不同行为)"></a>7.4 状态模式(对象不同状态下不同行为)</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的<strong>对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化</strong>。</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，<strong>把相关“判断逻辑”提取出来：把受环境改变影响的对象行为包装在不同的状态对象中，系统处于哪种情况，直接使用相应的状态类对象进行处理</strong>。这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><p>在UML中可以使用状态图来描述对象状态的变化。</p><h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>状态模式与<a href="https://en.wikipedia.org/wiki/Finite-state_machine">有限状态机</a>的概念紧密相关。</p><img src="/images/pattern/56.jpg" alt="56" style="zoom:100%;" /><p>其主要思想是程序在任意时刻仅可处于几种有限的状态中。 在任何一个特定状态中，程序的行为都不相同，且可瞬间从一个状态切换到另一个状态。不过，根据当前状态，程序可能会切换到另外一种状态，也可能会保持当前状态不变。这些数量有限且预先定义的状态切换规则被称为<em>转移</em>。</p><p>这类系统具有一系列离散的输入输出信息和有穷数目的内部状态(状态:概括了对过去输入信息处理的状况)。系统只需要根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为。每当系统处理了当前的输入后，系统的内部状态也将发生改变。</p><h3 id="定义-17"><a href="#定义-17" class="headerlink" title="定义"></a>定义</h3><p>状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)。</p><p>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</p><h3 id="结构-16"><a href="#结构-16" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-可切换状态的状态模式"><a href="#标准结构-可切换状态的状态模式" class="headerlink" title="标准结构(可切换状态的状态模式)"></a>标准结构(可切换状态的状态模式)</h4><p>状态模式包含如下角色：</p><ul><li>Context: 上下文类<ul><li>保存了对于一个具体状态对象的<strong>引用</strong>， 并会将所有与该状态相关的工作委派给它。</li><li>上下文通过抽象状态接口与状态对象交互， 且会提供一个<strong>设置器</strong>用于传递新的状态对象。</li><li>Context有时候可以充当状态管理器(State Manager)的角色，即也可以在上下文类中对状态进行切换操作。</li></ul></li><li>State: 抽象状态类<ul><li>声明特定状态所对应的行为，可以有一个或多个行为。</li><li>这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</li></ul></li><li>ConcreteState: 具体状态类<ul><li><strong>实现不同的状态所对应的行为</strong>。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。</li><li><strong>状态对象可存储对于上下文对象的反向引用或者通过方法参数传入</strong>（上下文类和状态类之间存在一种双向的关联关系）。状态可以通过该引用从上下文处获取所需信息，并且能<font color='red'>触发状态转移</font>。</li></ul></li></ul><img src="/images/pattern/55.png" alt="55" style="zoom:100%;" /><p><strong>上下文和具体状态都可以设置上下文的下个状态。通过替换上下文所引用的状态对象来完成实际的状态转换。</strong></p><p>抽象状态类的产生是由于上下文类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。</p><p>由于上下文类可以设置为任一具体状态类，因此它针对抽象状态类进行编程。</p><p>上下文类对象在其内部状态改变时可以改变它的行为，<strong>对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> :</span> <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConcreteStateA</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> State * m_pState = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteStateA</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> State * <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pState)&#123;</span><br><span class="line">            m_pState = <span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context * c)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;doing something in State A.\n done,change state to B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        c-&gt;<span class="built_in">changeState</span>(ConcreteStateB::<span class="built_in">Instance</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *m_pState;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>() &#123;</span><br><span class="line">        m_pState = ConcreteStateA::<span class="built_in">Instance</span>();  <span class="comment">//default is a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Context</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State * st)</span></span>&#123;</span><br><span class="line">        m_pState = st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_pState-&gt;<span class="built_in">handle</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Context * c = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    c-&gt;<span class="built_in">request</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单状态模式结构"><a href="#简单状态模式结构" class="headerlink" title="简单状态模式结构"></a>简单状态模式结构</h4><p>可切换状态的状态模式：</p><ul><li>大多数的状态模式都是可以切换状态的状态模式。</li><li>在实现状态切换时，在具体状态类内部需要调用上下文类Context的setState()方法进行状态的转换操作，在具体状态类中可以调用到上下文类的方法，因此状态类与上下文类之间通常还存在关联关系或者依赖关系。通过在状态类中引用上下文类的对象来回调上下文类的setState()方法实现状态的切换。</li><li>在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至上下文类的源代码，否则系统无法切换到新增状态。</li></ul><p>简单状态模式：</p><ul><li>是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。</li><li>对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到上下文类中。</li><li>遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li></ul><h4 id="扩展：状态的共享"><a href="#扩展：状态的共享" class="headerlink" title="扩展：状态的共享"></a>扩展：状态的共享</h4><p>在有些情况下，会创建多个上下文对象，这些对象会共享这一组状态。为了避免具体状态类对象的重复创建，常见有以下两种解决方式：</p><ol><li>引入享元模式，将这些具体状态对象放在集合中供程序共享。</li><li>将这些状态对象定义为的具体状态类的静态成员对象(<em>如上面的demo代码</em>)。</li></ol><p>如果多个上下文对象需要共享同一个状态（<em>意思是这个状态不是对象的，而是所有本类的对象共同拥有的属性？</em>），那么需要将这些状态对象定义为上下文类的静态成员对象。</p><h4 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h4><p>状态模式和策略模式的 UML 类图架构很像，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，彼此之间是独立的，用户可自行更换策略算法。而状态模式的各个状态间存在相互关系，彼此之间在一定条件下存在自动切换状态的效果，并且用户无法指定状态，只能设置初始状态。</p><h3 id="优缺点-16"><a href="#优缺点-16" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li><strong>结构清晰</strong>，状态模式将与特定状态相关的行为局部化到一个状态中，而不是集中在一个巨大的条件语句块中。并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将<strong>状态转换显示化</strong>，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，<strong>有利于程序的扩展</strong>。通过定义新的子类很容易地增加新的状态和转换。</li></ul><p>缺点</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态的行为也需修改对应类的源代码。</li></ul><h3 id="适用场景-16"><a href="#适用场景-16" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>某个类的对象存在多种状态，对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h3 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="案例1-TCPConnection"><a href="#案例1-TCPConnection" class="headerlink" title="案例1: TCPConnection"></a>案例1: TCPConnection</h4><p>这个示例来自《设计模式》，展示了一个简化版的TCP协议实现；TCP连接的状态有多种可能，状态之间的转换有相应的逻辑前提；这是使用状态模式的场合；</p><img src="/images/pattern/57.jpg" alt="57" style="zoom:100%;" /><h4 id="案例2-多线程的状态转换"><a href="#案例2-多线程的状态转换" class="headerlink" title="案例2: 多线程的状态转换"></a>案例2: 多线程的状态转换</h4><p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如下图所示。</p><img src="/images/pattern/58.jpg" alt="58" style="zoom:100%;" /><img src="/images/pattern/59.jpg" alt="59" style="zoom:96%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreStateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadContext context = <span class="keyword">new</span> ThreadContext();</span><br><span class="line">        context.start();</span><br><span class="line">        context.getCPU();</span><br><span class="line">        context.suspend();</span><br><span class="line">        context.resume();</span><br><span class="line">        context.getCPU();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上下文类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadState state;</span><br><span class="line">    ThreadContext() &#123;</span><br><span class="line">        state = <span class="keyword">new</span> New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ThreadState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadState <span class="title">getState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> state; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span>           </span>&#123; ((New) state).start(<span class="keyword">this</span>);       &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">()</span>          </span>&#123; ((Runnable)state).getCPU(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span>         </span>&#123; ((Running) state).suspend(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span>            </span>&#123; ((Running) state).stop(<span class="keyword">this</span>);    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span>          </span>&#123; ((Blocked) state).resume(<span class="keyword">this</span>);  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象状态类：线程状态</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String stateName; <span class="comment">//状态名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：新建状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">New</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">New</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;新建状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：新建状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用start()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;新建状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Runnable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是新建状态，不能调用start()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：就绪状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;就绪状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：就绪状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCPU</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;获得CPU时间--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;就绪状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Running());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是就绪状态，不能获取CPU.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：运行状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Running</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;运行状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：运行状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用suspend()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;运行状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Blocked());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用stop()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;运行状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Dead());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是运行状态，不能调用stop()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：阻塞状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocked</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;阻塞状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：阻塞状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">(ThreadContext hj)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用resume()方法--&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (stateName.equals(<span class="string">&quot;阻塞状态&quot;</span>)) &#123;</span><br><span class="line">            hj.setState(<span class="keyword">new</span> Runnable());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体状态类：死亡状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dead</span> <span class="keyword">extends</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateName = <span class="string">&quot;死亡状态&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程处于：死亡状态.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-备忘录模式-保存临时状态以备回滚"><a href="#7-5-备忘录模式-保存临时状态以备回滚" class="headerlink" title="7.5 备忘录模式(保存临时状态以备回滚)"></a>7.5 备忘录模式(保存临时状态以备回滚)</h2><h3 id="定义-18"><a href="#定义-18" class="headerlink" title="定义"></a>定义</h3><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><blockquote><p>snapshot(快照)：在电脑系统中，快照是整个系统在某个时间点上的状态。该名词由摄影中借用而来。它储存了系统映象，让电脑系统在出现问题时，可以快速恢复到未出问题前的状况。</p><p>在版本管理中，snapshot快照版本通常是指开发过程中的不稳定版本。对比于release发布版本。</p></blockquote><h3 id="结构-17"><a href="#结构-17" class="headerlink" title="结构"></a>结构</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>到底该如何生成一个快照呢？</p><ul><li>遍历对象的所有成员变量并将其数值复制保存？但只有当对象对其内容没有严格访问权限限制的情况下，你才能使用该方式。不过很遗憾，绝大部分对象会使用私有成员变量来存储重要数据，这样别人就无法轻易查看其中的内容。</li><li>就算公开所有成员变量，你可通过上面的方式，随时生成对象的状态快照，但这种方式仍存在一些严重问题。未来你可能会添加或删除一些成员变量。这听上去很简单，但需要对负责复制受影响对象状态的类进行更改。</li></ul><p>备忘录模式将创建状态快照（Snapshot）的工作委派给实际状态的拥有者<strong>原发器/发起人</strong>（Originator）对象。 这样其他对象就不再需要从 “外部” 复制对象状态了，原发起器类拥有其状态的完全访问权，因此可以自行生成快照。</p><p>模式建议将对象状态的副本存储在一个名为<strong>备忘录</strong>（Memento）的特殊对象中。而将备忘录保存在<strong>负责人/管理者</strong>（Caretakers）类中（<em>通常会有个备忘录列表，如果不需要支持多次回滚，那仅持有一个对象引用即可</em>）。</p><ul><li>只有原发器拥有对备忘录所有成员的访问权限，从而能随时从备忘录中获取数据，来恢复其以前的状态。</li><li>其他对象必须使用受限接口与备忘录进行交互，它们可以获取快照的元数据（创建时间和操作名称等）。</li></ul><h4 id="标准结构-支持类嵌套"><a href="#标准结构-支持类嵌套" class="headerlink" title="标准结构(支持类嵌套)"></a>标准结构(支持类嵌套)</h4><p>所以，备忘录模式的主要角色如下。</p><ul><li>原发器/发起人（Originator）角色：生成自身状态的快照，创建备忘录对象并能在需要时通过备忘录对象恢复自身状态。它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：是原发器状态快照的值对象（value object）。通常做法是将备忘录设为不可变的，并通过构造函数一次性传递数据。</li><li>负责人/管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><img src="/images/pattern/60.jpg" alt="60" style="zoom:100%;" /><p>在支持嵌套类的编程语言中，可以将备忘录类嵌套在原发器中，这样原发器就可访问备忘录的成员变量和方法（即使这些方法被声明为私有），同时限制了Caretaker的访问权限。</p><h4 id="不支持类嵌套的结构"><a href="#不支持类嵌套的结构" class="headerlink" title="不支持类嵌套的结构"></a>不支持类嵌套的结构</h4><p>在不支持嵌套类的编程语言中，为了能使原发器对象能够完全访问备忘录对象，需要将将备忘录的所有成员变量声明为公有。另一方面，为了限制其对备忘录成员变量的直接访问权限，可在Caretaker与备忘录之间新增一个中间接口进行交互，该接口仅声明与备忘录元数据相关的方法。</p><img src="/images/pattern/61.jpg" alt="61" style="zoom:100%;" /><h4 id="扩展-与原型模式联用"><a href="#扩展-与原型模式联用" class="headerlink" title="扩展: 与原型模式联用"></a>扩展: 与原型模式联用</h4><p>在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类。</p><h3 id="优缺点-17"><a href="#优缺点-17" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p>缺点：</p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="适用场景-17"><a href="#适用场景-17" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li></ul><h2 id="7-6-迭代器模式-抽取封装集合的遍历"><a href="#7-6-迭代器模式-抽取封装集合的遍历" class="headerlink" title="7.6 迭代器模式(抽取封装集合的遍历)"></a>7.6 迭代器模式(抽取封装集合的遍历)</h2><p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，通常的做法是将创建和遍历都放在同一个类中，缺点：</p><ol><li>不利于程序的扩展，如果要新增遍历方法(DFS、BFS、随机存取等)就必须修改程序源代码，这违背了 “开闭原则”。</li><li>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。此外，有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</li><li>使用多种集合的客户端代码可能并不关心存储数据的方式。不过由于集合提供不同的元素访问方式，你的代码将不得不与特定的集合类进行耦合。</li></ol><p>那将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ol><li>暴露了聚合类的内部表示，使其数据不安全；</li><li>增加了客户的负担。</li></ol><p>“迭代器模式”能较好地克服以上缺点，它<strong>将集合的遍历行为抽取为单独的迭代器对象</strong>，置于客户访问类与聚合类之间，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”。</p><h3 id="定义-19"><a href="#定义-19" class="headerlink" title="定义"></a>定义</h3><p>提供一种方法来顺序访问一个聚合对象中的各个元素，而又不暴露该聚合对象的内部表示。</p><h3 id="结构-18"><a href="#结构-18" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-6"><a href="#标准结构-6" class="headerlink" title="标准结构"></a>标准结构</h4><p>迭代器模式主要包含以下角色。</p><ul><li>抽象聚合（Aggregate）角色：需要声明一个或多个方法来获取与集合兼容的迭代器。请注意， 返回方法的类型要声明为抽象迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，在客户端请求迭代器时返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义了遍历聚合所需的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合。</li></ul><img src="/images/pattern/62.jpg" alt="62" style="zoom:100%;" /><p><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。这样一来客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器。</p><p>所有迭代器必须实现相同的接口。 这样一来，只要有合适的迭代器，客户端代码就能兼容任何类型的集合或遍历算法。如果你需要采用特殊方式来遍历集合，只需创建一个新的迭代器类即可，无需对集合或客户端进行修改。</p><p>在日常开发中，我们几乎不会自行创建迭代器，而是会从集合中获取。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。</p><h4 id="扩展-与组合模式联用"><a href="#扩展-与组合模式联用" class="headerlink" title="扩展: 与组合模式联用"></a>扩展: 与组合模式联用</h4><p>迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问。</p><h3 id="优缺点-18"><a href="#优缺点-18" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li><li>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。<ul><li>抽象迭代器为遍历不同的聚合结构提供一个统一的接口。</li><li>支持以不同方式遍历一个聚合，自定义迭代器的子类以支持新的遍历。</li></ul></li><li>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。相似的， 你可以暂停遍历并在需要时继续。</li><li>可以将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。提升了数据结构、算法的独立性、弹性、交互操作性。</li></ul><p>缺点：</p><ul><li>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正。</li><li>对于某些特殊集合，使用迭代器可能比直接遍历的效率低。</li></ul><h3 id="适用场景-18"><a href="#适用场景-18" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式。<ul><li>迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便， 而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</li></ul></li><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。<ul><li>该模式为集合和迭代器提供了一些通用接口。如果你在代码中使用了这些接口，那么将其他实现了这些接口的集合和迭代器传递给它时，它仍将可以正常运行。</li></ul></li></ul><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p><h2 id="7-7-命令模式-将方法调用转化为对象"><a href="#7-7-命令模式-将方法调用转化为对象" class="headerlink" title="7.7 命令模式(将方法调用转化为对象)"></a>7.7 命令模式(将方法调用转化为对象)</h2><h3 id="概念：参数、参数化"><a href="#概念：参数、参数化" class="headerlink" title="概念：参数、参数化"></a>概念：参数、参数化</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote><ul><li>也叫参变量。在所讨论的某个数学或物理问题中，于给定条件下取固定值的变量。如在平面直角坐标系中，如果曲线l上任意一点的坐标（x，y）都可以表示为在某个区间内的变量t的函数，那么所得到的方程x=f（t），y=g（t）就叫做该曲线的参数方程，变量t叫做参数。</li><li>表明任何现象、机构、装置的某种性质的量。如导电率、导热率、膨胀系数等。</li><li>在程序设计中，又称形式引数（formal argument），是一种在调用子程序时用以向子程序传递数据的特殊变量，这些被传递数据也就是子程序引数（arguments）的值。</li></ul></blockquote><h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><blockquote><p><a href="https://en.wikipedia.org/wiki/Parametric_design">参数化设计</a>：将系统本身编写为函数与过程，使用某些可以编辑的参数或变量，来操纵或改变方程或系统的最终结果。</p></blockquote><p>参数化是一种方法，或者说一种思想。在建模、生活中很多地方都可以用到。简单来说，就是用<strong>最少的元素，控制最多的内容</strong>。从一个物体中抽取一个或几个要素，作为<strong>参数</strong>。其他的要素作为<strong>从动要素</strong>。通过<strong>公式</strong>对参数的计算，得到所有从动要素的值。从而<strong>生成符合要求的整个物体</strong>。</p><p>这个物体你可以理解为一个零件，也可以是包含多个零件的装配体。建立起从动要素和参数的关联的这个过程，称之为参数化。这个关联（公式）是静态的，但参数是动态的，它在它的取值范围内可以随意改变。</p><p><strong>所谓“参数化”就是把一个事物或者问题用参数来表示的行为。</strong>（<em>知道了参数的值就知道了整个事物的模样</em>）。</p><p>此外，有些场景，参数化就是简单的表面意思：<strong>使某个事物可以当做(泛型类、函数的)参数传递。</strong>比如C++模板中常说的<em>类型参数化</em>。</p><h3 id="定义-20"><a href="#定义-20" class="headerlink" title="定义"></a>定义</h3><h4 id="举例引入"><a href="#举例引入" class="headerlink" title="举例引入"></a>举例引入</h4><p>以编辑器为例，一般在工具栏、右键菜单栏、快捷键中 ，都会支持复制、粘贴功能，那我们需要怎么组织这段代码？</p><ul><li>将操作代码复制进许多个类中。</li><li>让菜单栏依赖于我们工具栏中的按钮。(更糟)</li></ul><p>优秀的软件设计通常会将关注点进行分离，而这往往会导致软件的分层。上面的例子中，我们可以清晰的划分出一层负责用户图像界面，一层负责业务逻辑。一个 GUI 对象传递一些参数来调用一个业务逻辑对象。 这个过程通常被描述为一个对象发送<strong>请求</strong>给另一个对象。</p><p>GUI 层可以直接访问业务逻辑层：</p><img src="/images/pattern/63.jpg" alt="63" style="zoom:100%;" /><p>命令模式建议 GUI 对象不直接提交这些请求。 你应该将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成<em>命令</em>类， 该类中仅包含一个用于触发请求的方法。</p><p>命令对象负责连接不同的 GUI 和业务逻辑对象。 此后， GUI 对象无需了解业务逻辑对象是否获得了请求， 也无需了解其对请求进行处理的方式。 GUI 对象触发命令即可， 命令对象会自行处理所有细节工作。</p><img src="/images/pattern/64.jpg" alt="64" style="zoom:100%;" /><p>此外，当我们订餐时，服务员记下你点的食物， 写在一张纸上。然后来到厨房，把订单贴在墙上。过了一段时间，厨师拿到了订单，他根据订单来准备食物。厨师将做好的食物和订单一起放在托盘上。服务员看到托盘后对订单进行检查，确保所有食物都是你要的，然后将食物放到了你的桌上。</p><p>那张纸就是一个命令，它在厨师开始烹饪前一直位于队列中。命令中包含与烹饪这些食物相关的所有信息，厨师能够根据它马上开始烹饪。</p><h4 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h4><p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p><p>命令模式将请求调用者和请求接收者解耦，使得两者不直接交互。</p><h3 id="结构-19"><a href="#结构-19" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-7"><a href="#标准结构-7" class="headerlink" title="标准结构"></a>标准结构</h4><p>命令模式包含如下角色：</p><ul><li>抽象命令类(Command)：通常仅声明一个执行命令的方法 execute()。</li><li>具体命令类(Concrete Command)：<ul><li>实现各种类型的请求。</li><li>具体命令自身并不完成工作， 而是会将调用委派其所拥有的接收者对象（业务逻辑对象）。</li><li>接收对象执行方法所需的参数可以声明为具体命令的成员变量。可将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化。</li></ul></li><li>接收者(Receiver)：<ul><li>包含部分业务逻辑，几乎任何对象都可以作为接收者。</li><li>绝大部分命令只处理如何将请求传递到接收者的细节，接收者自己会完成实际的工作。</li></ul></li><li>发送者(Sender)/触发者(Invoker)：<ul><li>负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。</li><li>发送者触发命令，而不向接收者直接发送请求。</li><li>注意，发送者并不负责创建命令对象，它通常会通过构造函数从客户端处获得预先生成的命令。</li></ul></li></ul><img src="/images/pattern/65.jpg" alt="65" style="zoom:100%;" /><p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_pCommand;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Invoker</span>(Command * pCommand) &#123;</span><br><span class="line">        m_pCommand = pCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Invoker</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoker calling&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pCommand-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> :</span> <span class="keyword">public</span> Command &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver *m_pReceiver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCommand</span>(Receiver * pReceiver)&#123;</span><br><span class="line">        m_pReceiver = pReceiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteCommand</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteCommand::execute&quot;</span>  &lt;&lt; endl;</span><br><span class="line">        m_pReceiver-&gt;<span class="built_in">action</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Receiver</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Receiver</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receiver action.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    Receiver * pReceiver = <span class="keyword">new</span> <span class="built_in">Receiver</span>();</span><br><span class="line">    ConcreteCommand * pCommand = <span class="keyword">new</span> <span class="built_in">ConcreteCommand</span>(pReceiver);</span><br><span class="line">    Invoker * pInvoker = <span class="keyword">new</span> <span class="built_in">Invoker</span>(pCommand);</span><br><span class="line">    pInvoker-&gt;<span class="built_in">call</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pReceiver;</span><br><span class="line">    <span class="keyword">delete</span> pCommand;</span><br><span class="line">    <span class="keyword">delete</span> pInvoker;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与其他模式的联用-1"><a href="#扩展-与其他模式的联用-1" class="headerlink" title="扩展: 与其他模式的联用"></a>扩展: 与其他模式的联用</h4><p>宏命令又称为组合命令，它是命令模式和组合模式联用的产物。</p><ul><li>宏命令也是一个具体命令，不过它包含了对其他命令对象的引用，在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法，一个宏命令的成员对象可以是简单命令，还可以继续是宏命令。执行一个宏命令将执行多个具体命令，从而实现对命令的批处理。</li></ul><p>命令模式还可以同备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式</p><h3 id="优缺点-19"><a href="#优缺点-19" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li><li>在需要的时候，可以很容易地将命令记入日志。</li></ul><p>缺点</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="适用场景-19"><a href="#适用场景-19" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。<ul><li>命令模式将特定的方法调用转化为独立对象。 带来了许多有趣的应用：你可以将命令作为方法的参数进行传递、将命令保存在其他对象中，或者在运行时切换已连接的命令等。</li></ul></li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（<em>结合备忘录模式实现</em>）。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><p>很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。</p><h2 id="7-8-责任链模式-将请求处理者们连成链"><a href="#7-8-责任链模式-将请求处理者们连成链" class="headerlink" title="7.8 责任链模式(将请求处理者们连成链)"></a>7.8 责任链模式(将请求处理者们连成链)</h2><p>在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。</p><h3 id="定义-21"><a href="#定义-21" class="headerlink" title="定义"></a>定义</h3><p>责任链模式(Chain of Responsibility)，也叫职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。(<em>每个处理者收到请求后，均可选择处理该请求，或将其传递给链上的下个处理者。</em>)</p><p>责任链模式将请求的发送者和处理者解耦，即客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递。</p><p>而系统也可以在不影响客户使用的情况下，动态地重新组织和分配责任。</p><h3 id="结构-20"><a href="#结构-20" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-8"><a href="#标准结构-8" class="headerlink" title="标准结构"></a>标准结构</h4><p>责任链模式主要包含以下角色。</p><ul><li>抽象处理者(Handler)：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者(Concrete Handler)：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<ul><li>处理者通常是独立且不可变的，需要通过构造函数一次性地获得所有必要地数据。</li></ul></li><li>客户类(Client)：根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。</li></ul><img src="/images/pattern/66.jpg" alt="66" style="zoom:100%;" /><p>责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p><h4 id="扩展-纯、不纯的责任链模式"><a href="#扩展-纯、不纯的责任链模式" class="headerlink" title="扩展: 纯、不纯的责任链模式"></a>扩展: 纯、不纯的责任链模式</h4><p>责任链模式存在以下两种情况。</p><ul><li>纯的责任链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li><li>不纯的责任链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</li></ul><h4 id="对比-与状态模式的区别"><a href="#对比-与状态模式的区别" class="headerlink" title="对比: 与状态模式的区别"></a>对比: 与状态模式的区别</h4><p>状态模式和责任链模式。但在某些情况下，状态模式中的状态可以理解为责任，那么在这种情况下，两种模式都可以使用。</p><p>相似处：</p><ul><li>都会发生状态或责任的转移。(<em>状态的转移可能是有环的，而责任链不能出现环。</em>)</li><li>都能消除 if-else 分支过多的问题。</li></ul><p>不过两者还是有很明显的区别的：</p><ul><li><p>从定义来看，状态模式强调的是一个对象内在状态的改变，而责任链模式强调的是外部节点对象间的改变。</p></li><li><p>从代码实现上来看，两者最大的区别就是状态模式的各个状态对象知道自己要进入的下一个状态对象，而责任链模式并不清楚其下一个节点处理对象，因为链式组装由客户端负责。</p></li></ul><h3 id="优缺点-20"><a href="#优缺点-20" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>将请求的发送者和接受者解耦。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p>缺点：</p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="适用场景-20"><a href="#适用场景-20" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li></ul><h2 id="7-9-中介者模式-将依赖从网状变星型"><a href="#7-9-中介者模式-将依赖从网状变星型" class="headerlink" title="7.9 中介者模式(将依赖从网状变星型)"></a>7.9 中介者模式(将依赖从网状变星型)</h2><p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。</p><p><em>例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，牵一发而动全身，非常复杂。</em></p><p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。</p><p><em>如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。</em></p><p>这样的例子还有很多，例如：</p><ul><li>你刚刚参加工作想租房，可以找“房屋中介”；</li><li>刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</li><li>MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；</li><li>常用的 QQ 聊天程序的“中介者”是 QQ 服务器。</li></ul><p>所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p><h3 id="定义-22"><a href="#定义-22" class="headerlink" title="定义"></a>定义</h3><p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>中介者模式又称为调停者模式。</p><h3 id="结构-21"><a href="#结构-21" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-9"><a href="#标准结构-9" class="headerlink" title="标准结构"></a>标准结构</h4><p>中介者模式包含以下主要角色。</p><ul><li>抽象中介者(Mediator)：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者(Concrete Mediator)：实现中介者接口。<ul><li>定义一个 List 或 map (<em>可根据具体同事类对象的个数等因素来决定</em>)来管理所有的同事对象。</li><li>协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li></ul></li><li>抽象同事类(Colleague)：定义同事类的接口。<ul><li>每个同事类都有一个指向中介者对象的引用。该引用被声明为中介者接口类型，可通过将其连接到不同的中介者以使其能在其他程序中复用。</li><li>提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li></ul></li><li>具体同事类(Concrete Colleague)：是抽象同事类的实现者。<ul><li>是各种包含业务逻辑的类。</li><li>当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul></li></ul><img src="/images/pattern/67.jpg" alt="67" style="zoom:100%;" /><p>中介者模式可以使对象之间的关系数量急剧减少。中介者承担两方面的职责：</p><ul><li>中转作用（结构性）：<ul><li>通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li>对于同事对象来说，中介者看上去完全就是一个黑箱。发送者不知道最终会由谁来处理自己的请求，接收者也不知道最初是谁发出了请求。</li></ul></li><li>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> :</span> <span class="keyword">public</span> Mediator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,Colleague*&gt; m_mpColleague;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteMediator</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteMediator</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> nWho,string str)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,Colleague*&gt;::const_iterator itr = m_mpColleague.<span class="built_in">find</span>(nWho);</span><br><span class="line">        <span class="keyword">if</span>(itr == m_mpColleague.<span class="built_in">end</span>())&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not found this colleague!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Colleague* pc = itr-&gt;second;</span><br><span class="line">        pc-&gt;<span class="built_in">receivemsg</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">int</span> nWho, Colleague * aColleague)</span></span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,Colleague*&gt;::const_iterator itr = m_mpColleague.<span class="built_in">find</span>(nWho);</span><br><span class="line">        <span class="keyword">if</span>(itr == m_mpColleague.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_mpColleague.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nWho,aColleague));</span><br><span class="line">            <span class="comment">//同时将中介类暴露给colleague </span></span><br><span class="line">            aColleague-&gt;<span class="built_in">setMediator</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> :</span> <span class="keyword">public</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteColleagueA</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConcreteColleagueA</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> toWho,string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send msg from colleagueA,to:&quot;</span> &lt;&lt; toWho &lt;&lt; endl;</span><br><span class="line">        m_pMediator-&gt;<span class="built_in">operation</span>(toWho,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">receivemsg</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteColleagueA reveivemsg:&quot;</span> &lt;&lt; str &lt;&lt;endl;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    ConcreteColleagueA * pa = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueA</span>();</span><br><span class="line">    ConcreteColleagueB * pb = <span class="keyword">new</span> <span class="built_in">ConcreteColleagueB</span>();</span><br><span class="line">    ConcreteMediator * pm = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line">    pm-&gt;<span class="built_in">registered</span>(<span class="number">1</span>,pa);</span><br><span class="line">    pm-&gt;<span class="built_in">registered</span>(<span class="number">2</span>,pb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sendmsg from a to b</span></span><br><span class="line">    pa-&gt;<span class="built_in">sendmsg</span>(<span class="number">2</span>,<span class="string">&quot;hello,i am a&quot;</span>);</span><br><span class="line">    <span class="comment">// sendmsg from b to a</span></span><br><span class="line">    pb-&gt;<span class="built_in">sendmsg</span>(<span class="number">1</span>,<span class="string">&quot;hello,i am b&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pa,pb,pm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构-不存在抽象中介者"><a href="#结构-不存在抽象中介者" class="headerlink" title="结构: 不存在抽象中介者"></a>结构: 不存在抽象中介者</h4><ol><li>不定义中介者接口，把具体中介者对象实现成为单例。</li><li>同事对象不持有中介者，而是在需要的时候直接获取中介者对象并调用。</li></ol><img src="/images/pattern/69.jpg" alt="69" style="zoom:100%;" /><h4 id="结构-不存在抽象组件类"><a href="#结构-不存在抽象组件类" class="headerlink" title="结构: 不存在抽象组件类"></a>结构: 不存在抽象组件类</h4><p>抽象组件类并不是一定要存在的，尤其是对于已有代码的重构，更不能保证所有组件都会继承同一个抽象组件类。</p><img src="/images/pattern/68.jpg" alt="68" style="zoom:100%;" /><h3 id="优缺点-21"><a href="#优缺点-21" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ul><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li><li>类之间各司其职，符合迪米特法则。<ul><li>通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</li></ul></li></ul><p>缺点</p><ul><li>在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h3 id="适用场景-21"><a href="#适用场景-21" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><p>中介者模式可以方便地应用于图形界面(GUI)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。(<em>比如：iOS开发中的路由模块</em>)</p><h2 id="7-10-解释器模式-自定义嵌入式DSL"><a href="#7-10-解释器模式-自定义嵌入式DSL" class="headerlink" title="7.10 解释器模式(自定义嵌入式DSL)"></a>7.10 解释器模式(自定义嵌入式DSL)</h2><p>解释器（Interpreter）模式能引起一些高级开发者的兴趣。这是因为解释器模式的思想是让非初级用户和领域专家使用一门简单的语言（没编程语言那么复杂的语言）来表达思想。</p><p>解释器模式，常用于创建一种专注于某个特定领域的计算机语言。这种语言称为领域特定语言（Domain Specific Language, DSL）。</p><p>DSL 分为内部/嵌入式 DSL 和外部 DSL(前者的实现依赖于某种宿主语言)，而解释器模式仅与内部 DSL 相关。我们的目标是使用宿主语言提供的特性构建一种简单但有用的语言。</p><h3 id="概念：文法、句子、语法树"><a href="#概念：文法、句子、语法树" class="headerlink" title="概念：文法、句子、语法树"></a>概念：文法、句子、语法树</h3><blockquote><p>语法：语言的结构规则，包括词的构成和变化、词组和句子的组织（概括起来就是两部分：词法和句法）。又称文法。</p></blockquote><p>无论是机器语言还是自然语言，都有它自己的文法规则。例如，中文中的“句子”的文法如下。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 符号“::=”表示“定义为”</span><br><span class="line">// 用〈 和 〉括住的是非终结符：是用来表示语法成分的符号，有时也称为“语法变量”</span><br><span class="line">// 没有括住的是终结符：是文法所定义的语言的基本符号，有时也称为token</span><br><span class="line"></span><br><span class="line">〈句子〉::=〈主语〉〈谓语〉〈宾语〉</span><br><span class="line">〈主语〉::=〈代词〉|〈名词〉</span><br><span class="line">〈谓语〉::=〈动词〉</span><br><span class="line">〈宾语〉::=〈代词〉|〈名词〉</span><br><span class="line">〈代词〉你|我|他</span><br><span class="line">〈名词〉大学生|筱霞|英语</span><br><span class="line">〈动词〉::=是|学习</span><br></pre></td></tr></table></figure><p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p><p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。如下图所示是“我是大学生”的语法树。</p><img src="/images/pattern/70.jpg" alt="70" style="zoom:100%;" /><h3 id="定义-23"><a href="#定义-23" class="headerlink" title="定义"></a>定义</h3><p>解释器模式(Interpreter)的定义：定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。是一种类行为型模式。</p><p>解释器模式需要解决的是，<strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子</strong>。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><p><em>比方说，我们常常会使用正则表达式，在字符串中搜索匹配的字符或判断一个字符串是否符合我们规定的格式。正则表达式就是解释器模式的一种应用，解释器为正则表达式定义了一套文法（如何表示一个特定的正则表达式），以及如何解释这个正则表达式。</em></p><p>这种模式用编译语言的方式来分析应用中的实例。实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><h3 id="结构-22"><a href="#结构-22" class="headerlink" title="结构"></a>结构</h3><p>解释器模式包含以下主要角色。</p><ul><li>抽象表达式(Abstract Expression)：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式(Terminal Expression)：抽象表达式的子类。<ul><li>实现与文法中终结符相关联的解释操作。</li><li>文法中的每一个终结符都有一个具体终结表达式与之相对应。</li></ul></li><li>非终结符表达式(Nonterminal Expression)：抽象表达式的子类。<ul><li>实现与文法中非终结符相关联的解释操作。</li><li>文法中的每条规则都对应于一个非终结符表达式类。</li></ul></li><li>环境(Context)：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。<ul><li>环境类传递数据给表达式类/解释器类有两种方式：1. 将Context对象作为 interpret() 方法的参数传入。 2. 事先在Context类中，完成表达式类对象的配置(<em>如下图</em>)。</li></ul></li><li>客户端(Client)：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><img src="/images/pattern/71.jpg" alt="71" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">解释器模式设计一个“韶粵通”公交车卡的读卡器程序。</span></span><br><span class="line"><span class="comment">说明：假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> net.biancheng.c.interpreter;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*文法规则</span></span><br><span class="line"><span class="comment">  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;</span></span><br><span class="line"><span class="comment">  &lt;city&gt; ::= 韶关|广州</span></span><br><span class="line"><span class="comment">  &lt;person&gt; ::= 老人|妇女|儿童</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context bus = <span class="keyword">new</span> Context();</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的老人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;韶关的年轻人&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的妇女&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;广州的儿童&quot;</span>);</span><br><span class="line">        bus.freeRide(<span class="string">&quot;山东的儿童&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) set.add(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(info)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression city = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression person = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city, Expression person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        String s[] = info.split(<span class="string">&quot;的&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> city.interpret(s[<span class="number">0</span>]) &amp;&amp; person.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] citys = &#123;<span class="string">&quot;韶关&quot;</span>, <span class="string">&quot;广州&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] persons = &#123;<span class="string">&quot;老人&quot;</span>, <span class="string">&quot;妇女&quot;</span>, <span class="string">&quot;儿童&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Expression cityPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Expression city = <span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person = <span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        cityPerson = <span class="keyword">new</span> AndExpression(city, person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = cityPerson.interpret(info);</span><br><span class="line">        <span class="keyword">if</span> (ok) System.out.println(<span class="string">&quot;您是&quot;</span> + info + <span class="string">&quot;，您本次乘车免费！&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(info + <span class="string">&quot;，您不是免费人员，本次乘车扣费2元！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-22"><a href="#优缺点-22" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ul><p>缺点：</p><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li></ul><h3 id="适用场景-22"><a href="#适用场景-22" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li></ul><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题</p><h2 id="7-11-访问者模式-“访问者”一词很贴切"><a href="#7-11-访问者模式-“访问者”一词很贴切" class="headerlink" title="7.11 访问者模式(“访问者”一词很贴切)"></a>7.11 访问者模式(“访问者”一词很贴切)</h2><blockquote><p><strong>每个访问者对集合中每个元素的处理不同。</strong>将操作从数据结构中抽出，封成访问者类。</p></blockquote><p>在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如：</p><ul><li>公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；</li><li>电影或电视剧中的人物角色，不同的观众对他们的评价也不同；</li><li>顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</li></ul><img src="/images/pattern/73.jpg" alt="73" style="zoom:90%;" /><p>对于这些数据元素相对稳定而访问方式多种多样的数据结构，访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。</p><h3 id="定义-24"><a href="#定义-24" class="headerlink" title="定义"></a>定义</h3><p>访问者模式(Visitor)的定义：将作用于某种数据结构中的各元素的<strong>操作，从数据结构中分离出来</strong>封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。</p><h3 id="结构-23"><a href="#结构-23" class="headerlink" title="结构"></a>结构</h3><h4 id="标准结构-10"><a href="#标准结构-10" class="headerlink" title="标准结构"></a>标准结构</h4><p>访问者模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类。</p><p>访问者模式包含以下主要角色。</p><ul><li>抽象访问者(Visitor)：定义一个访问具体元素的接口。<ul><li>为每个具体元素类声明一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。</li></ul></li><li>具体访问者(ConcreteVisitor)：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素(Element)：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素(ConcreteElement)：实现抽象元素角色提供的 accept() 操作。<ul><li>该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法：方法体通常都是 visitor.visit(this) </li><li>另外具体元素中可能还包含本身业务逻辑的相关操作。</li></ul></li><li>对象结构(Object Structure)：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ul><img src="/images/pattern/72.png" alt="72" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.c.visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStructure os = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor); </span><br><span class="line">        <span class="comment">// 具体访问者A访问--&gt;具体元素A的操作。</span></span><br><span class="line">        <span class="comment">// 具体访问者A访问--&gt;具体元素B的操作。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        visitor = <span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        <span class="comment">// 具体访问者B访问--&gt;具体元素A的操作。</span></span><br><span class="line">        <span class="comment">// 具体访问者B访问--&gt;具体元素B的操作。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者A访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体访问者B访问--&gt;&quot;</span> + element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素A的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;具体元素B的操作。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; i = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-与其他模式联用"><a href="#扩展-与其他模式联用" class="headerlink" title="扩展: 与其他模式联用"></a>扩展: 与其他模式联用</h4><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p><ul><li><p>与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。上面类图中的对象结构是用 List 实现的，它通过 List 对象的 Iterator() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</p></li><li><p>与“组合模式”联用。因为访问者模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。部分类图如下：</p><img src="/images/pattern/74.png" alt="74" style="zoom:100%;" /></li></ul><h3 id="优缺点-23"><a href="#优缺点-23" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ul><p>缺点：</p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ul><h3 id="适用场景-23"><a href="#适用场景-23" class="headerlink" title="适用场景"></a>适用场景</h3><p>当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。</p><p>简而言之，就是<strong>当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式</strong>。</p><ul><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li><li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html">《Graphic Design Patterns》(很不错的，很详细…不过，有些地方详细到有点点的啰嗦)</a></li><li><a href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析(内容挺精简的)</a></li><li><a href="https://refactoringguru.cn/design-patterns/bridge">《深入设计模式》</a></li><li>《Header First设计模式》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、架构相关术语&quot;&gt;&lt;a href=&quot;#一、架构相关术语&quot; class=&quot;headerlink&quot; title=&quot;一、架构相关术语&quot;&gt;&lt;/a&gt;一、架构相关术语&lt;/h1&gt;&lt;h2 id=&quot;1-1-架构&quot;&gt;&lt;a href=&quot;#1-1-架构&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的编程范式</title>
    <link href="https://tenloy.github.io/2021/09/20/program-thought.html"/>
    <id>https://tenloy.github.io/2021/09/20/program-thought.html</id>
    <published>2021-09-20T09:37:12.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、术语"><a href="#一、术语" class="headerlink" title="一、术语"></a>一、术语</h2><h3 id="1-1-模式与模型"><a href="#1-1-模式与模型" class="headerlink" title="1.1 模式与模型"></a>1.1 模式与模型</h3><p>模式：模式（Pattern）是解决某一类问题的方法论，把解决某类问题的方法总结归纳到理论高度，就是模式。</p><p>模型：模型可以指实物。也可以是概念的模型，模型是由元素、关系、操作以及控制其相互作用的规则组成的概念系统。</p><p>既然模型是系统，那么它也应该满足系统的三要件：组成要素、连接方式、功能或目标。</p><h3 id="1-2-思想-范式-语言"><a href="#1-2-思想-范式-语言" class="headerlink" title="1.2 思想-范式-语言"></a>1.2 思想-范式-语言</h3><blockquote><p>编程思想(仅仅是思想层面) →  编程范式(已经形成一套方法论) → 编程语言(编程范式的具体实现，从API的设计中能很明显看出)。</p></blockquote><p>所以，编程语言是对编程思想的实现。如实现面向对象编程思想的编程语言，其标准库就会暴露出功能对象以供使用。</p><h2 id="二、编程范式"><a href="#二、编程范式" class="headerlink" title="二、编程范式"></a>二、编程范式</h2><p><a href="https://en.wikipedia.org/wiki/Programming_paradigm"><strong>编程范型、编程范式或程序设计法</strong></a>(Programming paradigm)：范即模范、典范之意，范式即<strong>模式、方法</strong></p><ul><li>是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。</li><li>编程范型提供了（同时决定了）程序员对程序执行的看法。例如：<ul><li>在面向对象编程中，程序员认为程序是一系列相互作用的对象，</li><li>在函数式编程中，一个程序会被看作是一个无状态的函数计算的序列。</li></ul></li></ul><p>许多编程范式以其禁止的技术和启用的技术而闻名。例如：纯函数式编程不允许有副作用；结构化编程不允许使用goto。可能是因为这个原因，新的范型常常被那些习惯于较早的风格的人认为是教条主义或过分严格。然而，避免使用某些技术可以更容易地理解程序行为，并证明有关程序正确性的定理。</p><h3 id="2-1-编程范式和编程语言"><a href="#2-1-编程范式和编程语言" class="headerlink" title="2.1 编程范式和编程语言"></a>2.1 编程范式和编程语言</h3><p>正如软件工程中不同的群体会提倡不同的“方法学”一样，不同的编程语言也会提倡不同的“编程范型”。 编程范型和编程语言之间的关系可能十分复杂：</p><ul><li>一些语言是专门为某个特定的范型设计的（如Smalltalk和Java支持面向对象编程，而Haskell和Scheme则支持函数式编程）</li><li>还有另一些编程语言支持多种范型（如Ruby、Common Lisp、Python和Oz）。例如，C++设计时，支持过程化编程、面向对象编程以及泛型编程。然而，设计师和程序员们要考虑如何使用这些范型元素来构建一个程序。一个人可以用C++写出一个完全过程化的程序，另一个人也可以用C++写出一个纯粹的面向对象程序，甚至还有人可以写出杂揉了两种范型的程序。</li></ul><h3 id="2-2-常见的编程范式"><a href="#2-2-常见的编程范式" class="headerlink" title="2.2 常见的编程范式"></a>2.2 常见的编程范式</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%B5%90%E6%A7%8B%E5%8C%96%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">非结构化编程</a>（对比：结构化）—— 更详细全面的分类可以查看维基百科 — <a href="https://en.wikipedia.org/wiki/Programming_paradigm">编程范式</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">结构化编程</a>（对比：非结构化）<ul><li><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B">模块化</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</a><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E7%BC%96%E7%A8%8B">基于类</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">基于原型</a></li><li>根据关注点分离：<ul><li><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">面向切面(Aspect-oriented, AOP)</a></li><li><a href="https://en.wikipedia.org/wiki/Role-oriented_programming">Role-oriented</a></li><li><a href="https://en.wikipedia.org/wiki/Subject-oriented_programming">Subject-oriented</a></li></ul></li></ul></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8B">指令式编程</a>（对比：声明式(宣告式)编程）<ul><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">过程式</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B">声明式(宣告式)编程</a>（对比：指令式）<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">函数式</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E7%BC%96%E7%A8%8B">数据流式</a><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">响应式</a></li></ul></li></ul></li></ul><h2 id="三、声明式编程"><a href="#三、声明式编程" class="headerlink" title="三、声明式编程"></a>三、声明式编程</h2><p>声明式编程(Declarative programming)或译为宣告式编程，是一种编程范式，通常被定义为除命令式以外的编程范式。它<strong>描述目标的性质，让电脑明白目标，而非流程</strong>。</p><ul><li>声明式编程不用告诉电脑问题领域，从而避免随之而来的副作用。而<strong>命令式编程则需要用算法来明确的指出每一步该怎么做。</strong></li><li>声明式编程通过函数、推理规则或重写规则，来描述变量之间的关系(如React.js  UI = f(state))。它的语言运行器（编译器或解释器）采用了一个固定的算法，以从这些关系产生结果。</li></ul><p>声明式语言包包括数据库查询语言(SQL，XQuery)，正则表达式，逻辑编程，函数式编程和组态管理系统。</p><p>声明式编程语言通常用作解决人工智能和约束满足问题。</p><p><strong>React是一个声明式编程框架，使得使用者只需要描述目标/状态，怎么实现交给我(框架底层)。</strong></p><h2 id="四、面向切面编程-AOP"><a href="#四、面向切面编程-AOP" class="headerlink" title="四、面向切面编程(AOP)"></a>四、面向切面编程(AOP)</h2><p>面向方面编程 (Aspect-oriented programming，AOP) 是一种编程范式，旨在通过允许分离横切关注点(<a href="https://en.wikipedia.org/wiki/Cross-cutting_concern">cross-cutting</a>)来增加模块化。AOP会将横切关注点封装到<em>切面</em>(<em>aspects</em>)模块中。这允许对处理封装横切关注点的代码进行干净的隔离和重用。</p><p>它可以实现在不修改代码本身的情况下，向现有代码添加行为(又称是一个advice)。通过“切入点(point-cut)”规范指定要修改哪些代码，例如：如果函数名称以’set’开头，记录这些函数的调用。</p><p>这允许将不属于业务逻辑核心的行为（例如日志记录）添加到程序中，而不会使功能的代码核心混乱。</p><p>概念：</p><ul><li>关注点是对计算机程序代码(<em>的执行结果</em>)有影响的一组特定信息。关注点可以<strong>很宽泛</strong>，比如“应用程序的硬件细节”、“数据库交互的细节”；也可以<strong>很具体</strong>，比如“要实例化的类的名称”。</li><li><a href="https://en.wikipedia.org/wiki/Cross-cutting_concern">Cross-cutting concern</a>：横切关注点，也是程序的一部分，但它会依赖或影响程序的其他多个部分。<ul><li>一般是不会影响到系统核心功能的信息，其通常会作为一些附加功能，横切多个核心关注点模块。</li><li>比如：日志记录模块。因为日志记录策略必然会影响系统的每个已记录部分。因此，日志记录横切所有记录的类和方法，即日志代码会复制分散到各个相关位置。其他如信息安全、监控、数据验证模块等。</li></ul></li><li><a href="https://en.wikipedia.org/wiki/Pointcut">Pointcuts</a>：切入点，是一组连接点(join points)。切入点指定了需要应用advice的确切位置，也就是嵌入修改代码的地方。切入点通常使用类名或方法名指定，在某些情况下使用匹配类名或方法名的正则表达式。</li><li><a href="https://en.wikipedia.org/wiki/Advice_(programming)">Advice</a>：描述了一类函数，它会在某些函数运行时，对其进行修改。应用的位置由Pointcuts指定。</li></ul><p>通俗点总结：<strong>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong>一般，我们管切入到指定类指定方法的代码片段称为切面(aspect)，而切入到哪些类、哪些方法则叫切入点。</p><p><em>注意，aspect此处不要理解为“方面“，“切面“更符合语义（和一个模块相切的一个面）。</em></p><p>有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p><p>AOP其实只是OOP的一个很有力的补充而已。OOP是从二维上区分出一个个的类来，而AOP则是加上了时间维度，能够从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。从技术上来说，Java上的AOP基本上是通过代理机制实现的。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、术语&quot;&gt;&lt;a href=&quot;#一、术语&quot; class=&quot;headerlink&quot; title=&quot;一、术语&quot;&gt;&lt;/a&gt;一、术语&lt;/h2&gt;&lt;h3 id=&quot;1-1-模式与模型&quot;&gt;&lt;a href=&quot;#1-1-模式与模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="架构与设计模式" scheme="https://tenloy.github.io/categories/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>图形处理(三) - 图形处理实践案例</title>
    <link href="https://tenloy.github.io/2021/09/15/graphics-processing-case.html"/>
    <id>https://tenloy.github.io/2021/09/15/graphics-processing-case.html</id>
    <published>2021-09-15T15:54:07.000Z</published>
    <updated>2022-09-07T02:38:36.221Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。<a href="https://juejin.cn/post/6846687599591948301">原文链接 — iOS图片处理实践</a>、<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">项目代码</a>。</p><h2 id="一、图片手动解码"><a href="#一、图片手动解码" class="headerlink" title="一、图片手动解码"></a>一、图片手动解码</h2><p>写在前面：图片编码解码理论见上上篇</p><p>场景：适用于需要快速显示图片的地方，例如tableCell，先把图片进行bitmap解码操作加入缓存。同时如果是超大图可以和下面第三节的图片压缩方法搭配使用。</p><p>解决方案：通过CGBitmapContextCreate 重绘图片，这种压缩的图片等于手动进行了一次解码，可以加快图片的展示</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片处理-强制解压缩操作-把元数据绘制到当前的上下文-压缩图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithBitmap:(<span class="built_in">CGFloat</span>)scale &#123;</span><br><span class="line">   <span class="comment">//获取当前图片数据源</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//设置大小改变压缩图片</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef)*scale;</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef)*scale;</span><br><span class="line">   <span class="comment">//创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGImageGetColorSpace</span>(imageRef);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建绘制当前图片的上下文</span></span><br><span class="line"><span class="comment">    CGBitmapContextCreate(void * __nullable data,</span></span><br><span class="line"><span class="comment">     size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span></span><br><span class="line"><span class="comment">     CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span></span><br><span class="line"><span class="comment">     data：所需要的内存空间 传nil会自动分配</span></span><br><span class="line"><span class="comment">     width/height：当前画布的大小</span></span><br><span class="line"><span class="comment">     bitsPerComponent：每个颜色分量的大小 RGBA 每一个分量占1个字节</span></span><br><span class="line"><span class="comment">     bytesPerRow：每一行使用的字节数 4*width</span></span><br><span class="line"><span class="comment">     bitmapInfo：RGBA绘制的顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef =</span><br><span class="line">   <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>,</span><br><span class="line">                         width,</span><br><span class="line">                         height,</span><br><span class="line">                         <span class="number">8</span>,</span><br><span class="line">                         <span class="number">4</span>*width,</span><br><span class="line">                         colorSpace,</span><br><span class="line">                         kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//根据数据源在上下文（画板）绘制图片</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   </span><br><span class="line">   imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、大图在本地的高效显示"><a href="#二、大图在本地的高效显示" class="headerlink" title="二、大图在本地的高效显示"></a>二、大图在本地的高效显示</h2><p>项目场景：1、下载大图后需要显示在屏幕上；2、本地读取大图显示在屏幕上。特别是对性能和图片要求较高的时候。</p><p>最佳解决方案：WWDC2018 苹果给的方案，见上上篇最后一节。</p><h2 id="三、图片压缩"><a href="#三、图片压缩" class="headerlink" title="三、图片压缩"></a>三、图片压缩</h2><p>写在前面：首先介绍两种最简单最常见的压缩方式，下面复杂的压缩方式也是在此之上的扩展，可以根据实际情况进行调整；</p><p>关于质量的压缩，苹果提供了一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageJPEGRepresentation</span>(image, compression);</span><br></pre></td></tr></table></figure><p>关于这个方法，理论上值越小表示图片质量越低，图片文件自然越小。但是并不是 compression 取 0，就是0b大小，取 1 就是原图。而且如果你是一张很大的图，即使compression = 0.0001等或更小，图片压缩到一定大小后，都无法再被压缩下去。</p><h3 id="3-1-按照指定压缩比例压缩图片"><a href="#3-1-按照指定压缩比例压缩图片" class="headerlink" title="3.1 按照指定压缩比例压缩图片"></a>3.1 按照指定压缩比例压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照质量压缩</span></span><br><span class="line"><span class="comment">//主要弊端：如果有大图按这个方法，尺寸有可能依然很大</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQuality:(<span class="built_in">CGFloat</span>)rate &#123;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, rate);</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-按照指定尺寸压缩图片"><a href="#3-2-按照指定尺寸压缩图片" class="headerlink" title="3.2 按照指定尺寸压缩图片"></a>3.2 按照指定尺寸压缩图片</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照尺寸压缩</span></span><br><span class="line"><span class="comment">// 主要弊端：图片可能会变形，质量也无法保证</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">   <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">   [<span class="keyword">self</span> drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-具体的应用场景分析"><a href="#3-3-具体的应用场景分析" class="headerlink" title="3.3 具体的应用场景分析"></a>3.3 具体的应用场景分析</h3><h4 id="1-上传或存储有大小要求的图片"><a href="#1-上传或存储有大小要求的图片" class="headerlink" title="1. 上传或存储有大小要求的图片"></a>1. 上传或存储有大小要求的图片</h4><p>循环逐渐减小图片尺寸，直到图片稍小于指定大小，这样做的好处是可以在我们限定图片大小后，图片尺寸也是此时最大的。问题是循环次数多，效率低，耗时长。可以用二分法来提高效率：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环逐渐减小图片尺寸，直到图片稍小于指定大小</span></span><br><span class="line"><span class="comment">// 同样的问题是循环次数多，效率低，耗时长。可以用二分法来提高效率，具体代码省略。这里介绍另外一种方法，比二分法更好，压缩次数少，而且可以使图片压缩后刚好小于指定大小(不只是 &lt; maxLength， &gt; maxLength * 0.9)。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleSize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">   <span class="built_in">UIImage</span> *resultImage = <span class="keyword">self</span>;</span><br><span class="line">   <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">       lastDataLength = data.length;</span><br><span class="line">       <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">       <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">       <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">       <span class="comment">// Use image to draw (drawInRect:), image is larger but more compression time</span></span><br><span class="line">       <span class="comment">// Use result image to draw, image is smaller but less compression time</span></span><br><span class="line">       [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">       resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">       <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">       data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-上传或存储有质量要求的图片"><a href="#2-上传或存储有质量要求的图片" class="headerlink" title="2. 上传或存储有质量要求的图片"></a>2. 上传或存储有质量要求的图片</h4><p>循环压缩图片质量直到图片稍小于指定大小，默认循环6次，循环太多次后面也再也压不下去，当然这个次数可以自行配置。好处就是最大限度的保证了图片质量。同样用二分法来提高效率。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环压缩图片质量直到图片稍小于指定大小。</span></span><br><span class="line"><span class="comment">// ⚠️：注意：当图片质量低于一定程度时，继续压缩没有效果。默认压缩最多6次,通过二分法来优化循环次数多</span></span><br><span class="line"><span class="comment">// 压缩图片质量的优点在于，尽可能保留图片清晰度，图片不会明显模糊；缺点在于，不能保证图片压缩后小于指定大小。</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)compressWithCycleQulity:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在大小有上限的情况下尽量保证质量"><a href="#3-在大小有上限的情况下尽量保证质量" class="headerlink" title="3. 在大小有上限的情况下尽量保证质量"></a>3. 在大小有上限的情况下尽量保证质量</h4><p>两种图片压缩方法结合 尽量兼顾质量和大小。以确保大小合适为标准。好处就是在大小限定的情况下最大保证了质量和尺寸。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)compressWithQulitySize:(<span class="built_in">NSInteger</span>)maxLength &#123;</span><br><span class="line">    <span class="comment">// Compress by quality</span></span><br><span class="line">    <span class="built_in">CGFloat</span> compression = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        compression = (max + min) / <span class="number">2</span>;</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(<span class="keyword">self</span>, compression);</span><br><span class="line">        <span class="keyword">if</span> (data.length &lt; maxLength * <span class="number">0.9</span>) &#123;</span><br><span class="line">            min = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length &gt; maxLength) &#123;</span><br><span class="line">            max = compression;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="keyword">if</span> (data.length &lt; maxLength) <span class="keyword">return</span> resultImage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Compress by size</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> lastDataLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123;</span><br><span class="line">        lastDataLength = data.length;</span><br><span class="line">        <span class="built_in">CGFloat</span> ratio = (<span class="built_in">CGFloat</span>)maxLength / data.length;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>((<span class="built_in">NSUInteger</span>)(resultImage.size.width * sqrtf(ratio)),</span><br><span class="line">                                 (<span class="built_in">NSUInteger</span>)(resultImage.size.height * sqrtf(ratio))); <span class="comment">// Use NSUInteger to prevent white blank</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">        [resultImage drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height)];</span><br><span class="line">        resultImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        data = <span class="built_in">UIImageJPEGRepresentation</span>(resultImage, compression);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、图片像素修改操作"><a href="#四、图片像素修改操作" class="headerlink" title="四、图片像素修改操作"></a>四、图片像素修改操作</h2><p>写在前面：这部分的理论都是通过图片重绘来修改修该图片位图中的像素值，从而达到图片的修改。</p><h3 id="4-1-图片灰度图-黑白图"><a href="#4-1-图片灰度图-黑白图" class="headerlink" title="4.1 图片灰度图(黑白图)"></a>4.1 图片灰度图(黑白图)</h3><p>灰度图的三种颜色转换算法：</p><ol><li><p>浮点算法：R = G = B = 0.3<em>R + 0.59</em>G + 0.11*B</p></li><li><p>平均值法：R = G = B = (R+G+B)/3</p></li><li><p>任取一个分量色：R = G = B = R或G或B</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToGray:(<span class="built_in">NSInteger</span>)type &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), <span class="keyword">self</span>.CGImage);</span><br><span class="line">    <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">    <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">            <span class="comment">//计算平均值重新存储像素点-直接操作像素点</span></span><br><span class="line">            uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">            <span class="comment">//rgbPiexl[0],rgbPiexl[1],rgbPiexl[2];</span></span><br><span class="line">            <span class="comment">//(rgbPiexl[0]+rgbPiexl[1]+rgbPiexl[2])/3;</span></span><br><span class="line">            uint32_t gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">1</span>) &#123;</span><br><span class="line">                gray = (rgbPiexl[<span class="number">0</span>]+rgbPiexl[<span class="number">1</span>]+rgbPiexl[<span class="number">2</span>])/<span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">                gray = rgbPiexl[<span class="number">0</span>]*<span class="number">0.3</span>+rgbPiexl[<span class="number">1</span>]*<span class="number">0.59</span>+rgbPiexl[<span class="number">2</span>]*<span class="number">0.11</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rgbPiexl[<span class="number">0</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">1</span>] = gray;</span><br><span class="line">            rgbPiexl[<span class="number">2</span>] = gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文绘制</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-修改图片的RGB值"><a href="#4-2-修改图片的RGB值" class="headerlink" title="4.2 修改图片的RGB值"></a>4.2 修改图片的RGB值</h3><p>通过修改图片的RGB值来控制图片的颜色显示。或者替换某种颜色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageToRGB:(<span class="built_in">CGFloat</span>)rk g:(<span class="built_in">CGFloat</span>)gk b:(<span class="built_in">CGFloat</span>)bk &#123;</span><br><span class="line">   <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">   <span class="comment">//1、获取图片宽高</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">   <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">   <span class="comment">//2、创建颜色空间</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">   <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">   <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">   <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">   <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">   <span class="comment">//5、将彩色图片像素点重新设置颜色</span></span><br><span class="line">   <span class="comment">//取平均值 R=G=B=(R+G+B)/3</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;height; y++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;width; x++) &#123;</span><br><span class="line">           <span class="comment">//操作像素点</span></span><br><span class="line">           uint8_t *rgbPiexl = (uint8_t *)&amp;imagePiexl[y*width+x];</span><br><span class="line">           <span class="comment">//该色值下不做处理</span></span><br><span class="line">           <span class="keyword">if</span> (rgbPiexl[<span class="number">0</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">1</span>]&gt;<span class="number">245</span>&amp;&amp;rgbPiexl[<span class="number">2</span>]&gt;<span class="number">245</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;该色值下不做处理&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               rgbPiexl[<span class="number">0</span>] = rgbPiexl[<span class="number">0</span>]*rk;</span><br><span class="line">               rgbPiexl[<span class="number">1</span>] = rgbPiexl[<span class="number">1</span>]*gk;</span><br><span class="line">               rgbPiexl[<span class="number">2</span>] = rgbPiexl[<span class="number">2</span>]*bk;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据上下文绘制</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">   <span class="comment">//释放用过的内存</span></span><br><span class="line">   <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">   free(imagePiexl);</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-图片打码"><a href="#4-3-图片打码" class="headerlink" title="4.3 图片打码"></a>4.3 图片打码</h3><p>马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置马赛克</span></span><br><span class="line"><span class="comment">//马赛克就是让图片看上去模糊不清。将特定区域的像素点设置为同一种颜色，整体就会变得模糊，区域块越大越模糊，越小越接近于原始像素。</span></span><br><span class="line"><span class="comment">//同样使用强制解压缩操作，操作像素点，马赛克部分实际操作</span></span><br><span class="line"><span class="comment">//1、设置区域大小；</span></span><br><span class="line"><span class="comment">//2、在该区域获取一个像素点（第一个）作为整个区域的取色；</span></span><br><span class="line"><span class="comment">//3、将取色设置到区域中；</span></span><br><span class="line"><span class="comment">//4、取下一个区域同上去色设置区域</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageToMosaic:(<span class="built_in">NSInteger</span>)size; &#123;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="keyword">self</span>.CGImage;</span><br><span class="line">    <span class="comment">//1、获取图片宽高</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">    <span class="built_in">NSUInteger</span> height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">    <span class="comment">//2、创建颜色空间</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="comment">//3、根据像素点个数创建一个所需要的空间</span></span><br><span class="line">    <span class="built_in">UInt32</span> *imagePiexl = (<span class="built_in">UInt32</span> *)calloc(width*height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    <span class="built_in">CGContextRef</span> contextRef = <span class="built_in">CGBitmapContextCreate</span>(imagePiexl, width, height, <span class="number">8</span>, <span class="number">4</span>*width, colorSpaceRef, kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="comment">//4、根据图片数据源绘制上下文</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(contextRef, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">    <span class="comment">//5、获取像素数组</span></span><br><span class="line">    <span class="built_in">UInt8</span> *bitmapPixels = <span class="built_in">CGBitmapContextGetData</span>(contextRef);</span><br><span class="line">    <span class="built_in">UInt8</span> *pixels[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">NSUInteger</span> currentPixels = <span class="number">0</span>;<span class="comment">//当前的像素点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> preCurrentPiexls = <span class="number">0</span>;<span class="comment">//</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> mosaicSize = size;<span class="comment">//马赛克尺寸</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>;  i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span> ; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            currentPixels = i * width + j;</span><br><span class="line">            <span class="keyword">if</span> (i % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % mosaicSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    memcpy(pixels, bitmapPixels + <span class="number">4</span> * currentPixels, <span class="number">4</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, pixels, <span class="number">4</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCurrentPiexls = (i - <span class="number">1</span>) * width + j;</span><br><span class="line">                memcpy(bitmapPixels + <span class="number">4</span> * currentPixels, bitmapPixels + <span class="number">4</span> * preCurrentPiexls, <span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据上下文创建图片数据源</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> finalRef = <span class="built_in">CGBitmapContextCreateImage</span>(contextRef);</span><br><span class="line">    <span class="comment">//释放用过的内存</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(contextRef);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpaceRef);</span><br><span class="line">    free(imagePiexl);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:finalRef scale:<span class="keyword">self</span>.scale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、图形框架合成图片"><a href="#五、图形框架合成图片" class="headerlink" title="五、图形框架合成图片"></a>五、图形框架合成图片</h2><p>使用不同图形框架合成图片，添加滤镜水印等。</p><p>写在前面：理论和上面像素修改一样，通过操作像素达到修改图片的目的，但是这里使用了系统提供的不同框架和第三方GPUImage。不同框架效率也有所不一样。这里每段代码都加入了对应像素（黑白处理），只是为了学习，后面可以根据需求在对应代码块添加或替换对应对像素的操作，亦可后面加入参数进行封装。</p><h3 id="5-1-直接绘图合成"><a href="#5-1-直接绘图合成" class="headerlink" title="5.1 直接绘图合成"></a>5.1 直接绘图合成</h3><p>此方案原理上就是通过绘图，将多张图片的像素按照自己的设计绘制在一张图片上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingPixels:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line">   <span class="comment">// 1. Get the raw pixels of the image</span></span><br><span class="line">   <span class="built_in">UInt32</span> * backPixels;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGImageRef</span> backCGImage = [backImage <span class="built_in">CGImage</span>];</span><br><span class="line">   <span class="built_in">NSUInteger</span> backWidth = <span class="built_in">CGImageGetWidth</span>(backCGImage);</span><br><span class="line">   <span class="built_in">NSUInteger</span> backHeight = <span class="built_in">CGImageGetHeight</span>(backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSUInteger</span> backBytesPerRow = bytesPerPixel * backWidth;</span><br><span class="line"></span><br><span class="line">   backPixels = (<span class="built_in">UInt32</span> *)calloc(backHeight * backWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(backPixels, backWidth, backHeight,</span><br><span class="line">                                                bitsPerComponent, backBytesPerRow, colorSpace,</span><br><span class="line">                                                kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, backWidth, backHeight), backCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. Blend the pattern onto the image</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> frontCGImage = [frontImage <span class="built_in">CGImage</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.1 Calculate the size &amp; position of the pattern</span></span><br><span class="line">   <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line">   <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line">   <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"> <span class="comment">//    CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line">       <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.2 Scale &amp; Get pixels of the pattern</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> frontBytesPerRow = bytesPerPixel * frontSize.width;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UInt32</span> *frontPixels = (<span class="built_in">UInt32</span> *)calloc(frontSize.width * frontSize.height, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextRef</span> frontContext = <span class="built_in">CGBitmapContextCreate</span>(frontPixels, frontSize.width, frontSize.height,</span><br><span class="line">                                                     bitsPerComponent, frontBytesPerRow, colorSpace,</span><br><span class="line">                                                     kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">CGContextDrawImage</span>(frontContext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, frontSize.width, frontSize.height),frontCGImage);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.3 Blend each pixel</span></span><br><span class="line">   <span class="built_in">NSUInteger</span> offsetPixelCountForInput = frontOrigin.y * backWidth + frontOrigin.x;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; frontSize.height; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; frontSize.width; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> *backPixel = backPixels + j * backWidth + i + offsetPixelCountForInput;</span><br><span class="line">           <span class="built_in">UInt32</span> backColor = *backPixel;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">UInt32</span> * frontPixel = frontPixels + j * (<span class="keyword">int</span>)frontSize.width + i;</span><br><span class="line">           <span class="built_in">UInt32</span> frontColor = *frontPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Blend the pattern with 50% alpha</span></span><br><span class="line"><span class="comment">//            CGFloat frontAlpha = 0.5f * (A(frontColor) / 255.0);</span></span><br><span class="line">           <span class="built_in">CGFloat</span> frontAlpha = <span class="number">1.0</span>f * (A(frontColor) / <span class="number">255.0</span>);</span><br><span class="line">           <span class="built_in">UInt32</span> newR = R(backColor) * (<span class="number">1</span> - frontAlpha) + R(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newG = G(backColor) * (<span class="number">1</span> - frontAlpha) + G(frontColor) * frontAlpha;</span><br><span class="line">           <span class="built_in">UInt32</span> newB = B(backColor) * (<span class="number">1</span> - frontAlpha) + B(frontColor) * frontAlpha;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Clamp, not really useful here :p</span></span><br><span class="line">           newR = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newR));</span><br><span class="line">           newG = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newG));</span><br><span class="line">           newB = MAX(<span class="number">0</span>,MIN(<span class="number">255</span>, newB));</span><br><span class="line"></span><br><span class="line">           *backPixel = RGBAMake(newR, newG, newB, A(backColor));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Convert the image to Black &amp; White</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; backHeight; j++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; backWidth; i++) &#123;</span><br><span class="line">           <span class="built_in">UInt32</span> * currentPixel = backPixels + (j * backWidth) + i;</span><br><span class="line">           <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Average of RGB = greyscale</span></span><br><span class="line">           <span class="built_in">UInt32</span> averageColor = (R(color) + G(color) + B(color)) / <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">           *currentPixel = RGBAMake(averageColor, averageColor, averageColor, A(color));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. Create a new UIImage</span></span><br><span class="line">   <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">   <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 5. Cleanup!</span></span><br><span class="line">   <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">   <span class="built_in">CGContextRelease</span>(frontContext);</span><br><span class="line">   free(backPixels);</span><br><span class="line">   free(frontPixels);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-CoreGraphics-框架合成图片"><a href="#5-2-CoreGraphics-框架合成图片" class="headerlink" title="5.2 CoreGraphics 框架合成图片"></a>5.2 CoreGraphics 框架合成图片</h3><p>使用CoreGraphics框架合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingCoreGraphics:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage; &#123;</span><br><span class="line"> <span class="built_in">CGRect</span> imageRect = &#123;<span class="built_in">CGPointZero</span>,backImage.size&#125;;</span><br><span class="line"> <span class="built_in">NSInteger</span> backWidth = <span class="built_in">CGRectGetWidth</span>(imageRect);</span><br><span class="line"> <span class="built_in">NSInteger</span> backHeight = <span class="built_in">CGRectGetHeight</span>(imageRect);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1. Blend the pattern onto our image</span></span><br><span class="line"> <span class="built_in">CGFloat</span> frontImageAspectRatio = frontImage.size.width / frontImage.size.height;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">NSInteger</span> targetFrontWidth = backWidth * <span class="number">0.25</span>;</span><br><span class="line"> <span class="built_in">CGSize</span> frontSize = <span class="built_in">CGSizeMake</span>(targetFrontWidth, targetFrontWidth / frontImageAspectRatio);</span><br><span class="line"><span class="comment">//  CGPoint frontOrigin = CGPointMake(backWidth * 0.5, backHeight * 0.2);</span></span><br><span class="line"> <span class="built_in">CGPoint</span> frontOrigin = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">CGRect</span> frontRect = &#123;frontOrigin, frontSize&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIGraphicsBeginImageContext</span>(backImage.size);</span><br><span class="line"> <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// flip drawing context</span></span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flip = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line"> <span class="built_in">CGAffineTransform</span> flipThenShift = <span class="built_in">CGAffineTransformTranslate</span>(flip,<span class="number">0</span>,-backHeight);</span><br><span class="line"> <span class="built_in">CGContextConcatCTM</span>(context, flipThenShift);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.1 Draw our image into a new CGContext</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [backImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 1.2 Set Alpha to 0.5 and draw our pattern on</span></span><br><span class="line"> <span class="built_in">CGContextSetBlendMode</span>(context, kCGBlendModeSourceAtop);</span><br><span class="line"> <span class="built_in">CGContextSetAlpha</span>(context,<span class="number">0.5</span>);</span><br><span class="line"> <span class="built_in">CGRect</span> transformedpatternRect = <span class="built_in">CGRectApplyAffineTransform</span>(frontRect, flipThenShift);</span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, transformedpatternRect, [frontImage <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">UIImage</span> * imageWithFront = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"> <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 2. Convert our image to Black and White</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.1 Create a new context with a gray color space</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, backWidth, backHeight,</span><br><span class="line">                          <span class="number">8</span>, <span class="number">0</span>, colorSpace, (<span class="built_in">CGBitmapInfo</span>)kCGImageAlphaNone);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.2 Draw our image into the new context</span></span><br><span class="line"> <span class="built_in">CGContextDrawImage</span>(context, imageRect, [imageWithFront <span class="built_in">CGImage</span>]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2.3 Get our new B&amp;W Image</span></span><br><span class="line"> <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"> <span class="built_in">UIImage</span> * finalImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Cleanup</span></span><br><span class="line"> <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"> <span class="built_in">CFRelease</span>(imageRef);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> finalImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-CoreImage-框架合成图片"><a href="#5-3-CoreImage-框架合成图片" class="headerlink" title="5.3 CoreImage 框架合成图片"></a>5.3 CoreImage 框架合成图片</h3><p>使用CoreImage 框架以添加滤镜形式合成图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)processUsingCoreImage:(UIImage *)backImage frontImage:(UIImage *)frontImage &#123;</span><br><span class="line">  CIImage * backCIImage &#x3D; [[CIImage alloc] initWithImage:backImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 1. Create a grayscale filter</span><br><span class="line">  CIFilter * grayFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorControls&quot;];</span><br><span class="line">  [grayFilter setValue:@(0) forKeyPath:@&quot;inputSaturation&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. Create our pattern filter</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Cheat: create a larger pattern image</span><br><span class="line">  UIImage * patternFrontImage &#x3D; [self createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">  CIImage * frontCIImage &#x3D; [[CIImage alloc] initWithImage:patternFrontImage];</span><br><span class="line"></span><br><span class="line">  CIFilter * alphaFilter &#x3D; [CIFilter filterWithName:@&quot;CIColorMatrix&quot;];</span><br><span class="line">&#x2F;&#x2F;  CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:0.5 W:0];</span><br><span class="line">     CIVector * alphaVector &#x3D; [CIVector vectorWithX:0 Y:0 Z:1.0 W:0];</span><br><span class="line">  [alphaFilter setValue:alphaVector forKeyPath:@&quot;inputAVector&quot;];</span><br><span class="line">  </span><br><span class="line">  CIFilter * blendFilter &#x3D; [CIFilter filterWithName:@&quot;CISourceAtopCompositing&quot;];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. Apply our filters</span><br><span class="line">  [alphaFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  frontCIImage &#x3D; [alphaFilter outputImage];</span><br><span class="line"></span><br><span class="line">  [blendFilter setValue:frontCIImage forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  [blendFilter setValue:backCIImage forKeyPath:@&quot;inputBackgroundImage&quot;];</span><br><span class="line">  CIImage * blendOutput &#x3D; [blendFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  [grayFilter setValue:blendOutput forKeyPath:@&quot;inputImage&quot;];</span><br><span class="line">  CIImage * outputCIImage &#x3D; [grayFilter outputImage];</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. Render our output image</span><br><span class="line">  CIContext * context &#x3D; [CIContext contextWithOptions:nil];</span><br><span class="line">  CGImageRef outputCGImage &#x3D; [context createCGImage:outputCIImage fromRect:[outputCIImage extent]];</span><br><span class="line">  UIImage * outputImage &#x3D; [UIImage imageWithCGImage:outputCGImage];</span><br><span class="line">  CGImageRelease(outputCGImage);</span><br><span class="line">  </span><br><span class="line">  return outputImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createPaddedPatternImageWithSize 这是个生成滤镜图案的代码块具体请看<a href="https://link.juejin.cn/?target=https://github.com/EricStone1900/ImageOperate-OC">DEMO</a></p><h3 id="5-4-GPUImage-框架合成图片"><a href="#5-4-GPUImage-框架合成图片" class="headerlink" title="5.4 GPUImage 框架合成图片"></a>5.4 GPUImage 框架合成图片</h3><p>使用GPUImage 框架以添加滤镜形式合成图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)processUsingGPUImage:(<span class="built_in">UIImage</span> *)backImage frontImage:(<span class="built_in">UIImage</span> *)frontImage &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 1. Create our GPUImagePictures</span></span><br><span class="line">   GPUImagePicture * backGPUImage = [[GPUImagePicture alloc] initWithImage:backImage];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> *fliterImage = [<span class="keyword">self</span> createPaddedPatternImageWithSize:backImage.size pattern:frontImage];</span><br><span class="line">   GPUImagePicture * frontGPUImage = [[GPUImagePicture alloc] initWithImage:fliterImage];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 2. Setup our filter chain</span></span><br><span class="line">   GPUImageAlphaBlendFilter * alphaBlendFilter = [[GPUImageAlphaBlendFilter alloc] init];</span><br><span class="line">   alphaBlendFilter.mix = <span class="number">0.5</span>;</span><br><span class="line">   </span><br><span class="line">   [backGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">0</span>];</span><br><span class="line">   [frontGPUImage addTarget:alphaBlendFilter atTextureLocation:<span class="number">1</span>];</span><br><span class="line">   </span><br><span class="line">   GPUImageGrayscaleFilter * grayscaleFilter = [[GPUImageGrayscaleFilter alloc] init];</span><br><span class="line">   </span><br><span class="line">   [alphaBlendFilter addTarget:grayscaleFilter];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 3. Process &amp; grab output image</span></span><br><span class="line">   [backGPUImage processImage];</span><br><span class="line">   [frontGPUImage processImage];</span><br><span class="line">   [grayscaleFilter useNextFrameForImageCapture];</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">UIImage</span> * output = [grayscaleFilter imageFromCurrentFramebuffer];</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-对比总结"><a href="#5-5-对比总结" class="headerlink" title="5.5 对比总结"></a>5.5 对比总结</h3><ul><li>从代码量来看：明显1直接绘图合成的代码量明显高出许多。CoreImage，和GPUImage的方案要自己加入pattern图，其实代码量也不算少。因此仅从合成图这个功能来看。代码量上 CoreGraphic方案最优。</li><li>从性能来看：本地测试，CoreGraphic，直接绘图合成，速度最快。GPUImage也差不多，CoreImage添加滤镜方案最慢。</li><li>从可控多样性需求来说：GPUImage本来就提供很多滤镜，同时开源。无疑当前最佳，但是其他的都可以自己进行对应功能封装。</li></ul><p>总的来说还是要看项目需求，个人觉得一般性添加水印，合成图片什么如果要直接用CoreGraphic是个不错的选择，以后有时间可以基于CoreGraphic封装功能。</p><h2 id="六、参考文档"><a href="#六、参考文档" class="headerlink" title="六、参考文档"></a>六、参考文档</h2><ul><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/822841145b52">iOS图片压缩</a></li><li><a href="https://link.juejin.cn/?target=https://www.raywenderlich.com/sessions/new?return_path=/2335-image-processing-in-ios-part-1-raw-bitmap-modification">Image-Processing</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在项目中因为性能原因，最好不要叠加太多UIView，CALayer层级的显示；但是很多情况又必须使用到图片的合成或是像素、滤镜处理。这里针这些常用的图片处理使用不同图形处理框架进行相关编码实践。&lt;a href=&quot;https://juejin.cn/post/68466875</summary>
      
    
    
    
    <category term="图形处理与渲染" scheme="https://tenloy.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    
    
  </entry>
  
</feed>
